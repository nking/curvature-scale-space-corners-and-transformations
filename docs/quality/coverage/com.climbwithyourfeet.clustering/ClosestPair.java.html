<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClosestPair.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">com.climbwithyourfeet.clustering</a> &gt; <span class="el_source">ClosestPair.java</span></div><h1>ClosestPair.java</h1><pre class="source lang-java linenums">package com.climbwithyourfeet.clustering;

import com.climbwithyourfeet.clustering.util.PairFloat;
import com.climbwithyourfeet.clustering.util.Sorter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Find the closest pair of points in a set of points by using divide and 
 * conquer to reduce the number of comparisons
 * 
 * From pseudocode in Intro to Algorithms by Cormen et al.
 * 
 * runtime complexity is ~ O(N lg N).
 *
 * @author nichole
 */
public class ClosestPair {

<span class="fc" id="L23">    private boolean debug = false;</span>
    
    /**
     *
     */
<span class="fc" id="L28">    public ClosestPair() {</span>
<span class="fc" id="L29">    }</span>
    
    /**
     *
     */
    public void setDebug() {
<span class="nc" id="L35">        this.debug = true;</span>
<span class="nc" id="L36">    }</span>

    /**
     * find the closest pair within the x,y set of points.
     * note that the given arrays will have their item orders altered.
     *
     * @param xPoints
     * @param yPoints
     * @return
     *     returns 5 items in array:  shortest distance between pairs, pt1 x, pt1 y, pt2 x, pt2 y
     */
    public ClosestPairFloat findClosestPair(List&lt;Float&gt; xPoints, List&lt;Float&gt; yPoints) {
        
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">        if (xPoints == null) {</span>
<span class="nc" id="L50">	    	throw new IllegalArgumentException(&quot;xpoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">	    if (yPoints == null) {</span>
<span class="nc" id="L53">	    	throw new IllegalArgumentException(&quot;ypoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">	    if (xPoints.size() != yPoints.size()) {</span>
<span class="nc" id="L56">	    	throw new IllegalArgumentException(</span>
                &quot;xpoints must have the same number of items as y&quot;);
        }
        
<span class="fc" id="L60">        List&lt;PairFloat&gt; p = new ArrayList&lt;PairFloat&gt;();</span>
<span class="fc" id="L61">        List&lt;PairFloat&gt; x = new ArrayList&lt;PairFloat&gt;();</span>
<span class="fc" id="L62">        List&lt;PairFloat&gt; y = new ArrayList&lt;PairFloat&gt;();</span>
        
<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (int i = 0; i &lt; xPoints.size(); i++) {</span>
<span class="fc" id="L65">            float xPoint = xPoints.get(i);</span>
<span class="fc" id="L66">            float yPoint = yPoints.get(i);</span>
            // since the points xy are not going to be modified, can reuse xy
<span class="fc" id="L68">            PairFloat xy = new PairFloat(xPoint, yPoint);</span>
<span class="fc" id="L69">            p.add(xy);</span>
<span class="fc" id="L70">            y.add(xy);</span>
        }
<span class="fc" id="L72">        Sorter.mergeSortByXThenY(p);</span>
<span class="fc" id="L73">        x.addAll(p);</span>
        
<span class="fc" id="L75">        Sorter.mergeSortByYThenX(y);</span>
        
<span class="fc" id="L77">        return divide(p, x, y);</span>
    }
                
    /**
     * use divide and conquer to find the pair of points with the smallest 
     * separation.  note that x and y have to contain objects that are the
     * same instance as the objects in p.
     * 
     * @param p should be ordered left to right already
     * @param x
     * @param y
     * @return 
     */
    protected ClosestPairFloat divide(List&lt;PairFloat&gt; p, List&lt;PairFloat&gt; x, 
        List&lt;PairFloat&gt; y) {
        
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (p.size() &lt;= 3) {</span>
<span class="fc" id="L94">            return bruteForceMinDistance(p);</span>
        }
                            
<span class="fc" id="L97">        int q = p.size() &gt;&gt; 1; // 0 1 *2*  3 4 5</span>

<span class="fc" id="L99">        List&lt;PairFloat&gt; pL = new ArrayList&lt;PairFloat&gt;(q);</span>
<span class="fc" id="L100">        List&lt;PairFloat&gt; pR = new ArrayList&lt;PairFloat&gt;(q);</span>
        
        // need a datastructure to search for pL members.  for a hash table, search is O(1).
        //  will assume that the java HashSet implementation has O(1) insert and search
<span class="fc" id="L104">        Set&lt;PairFloat&gt; isInL = new HashSet&lt;PairFloat&gt;();</span>
        
<span class="fc" id="L106">        List&lt;PairFloat&gt; xL = new ArrayList&lt;PairFloat&gt;(q);</span>
<span class="fc" id="L107">        List&lt;PairFloat&gt; xR = new ArrayList&lt;PairFloat&gt;(q);</span>
<span class="fc" id="L108">        List&lt;PairFloat&gt; yL = new ArrayList&lt;PairFloat&gt;(q);</span>
<span class="fc" id="L109">        List&lt;PairFloat&gt; yR = new ArrayList&lt;PairFloat&gt;(q);</span>
        
        // p is already sorted by x, so fill in the subsets for p and x
<span class="fc bfc" id="L112" title="All 2 branches covered.">        for (int i = 0; i &lt; q; ++i) {</span>
<span class="fc" id="L113">            PairFloat pi = p.get(i);</span>
<span class="fc" id="L114">            pL.add(pi);</span>
<span class="fc" id="L115">            xL.add(pi);</span>
<span class="fc" id="L116">            isInL.add(pi);</span>
        }
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (int i = q; i &lt; p.size(); ++i) {</span>
<span class="fc" id="L119">            PairFloat pi = p.get(i);</span>
<span class="fc" id="L120">            pR.add(pi);</span>
<span class="fc" id="L121">            xR.add(pi);</span>
        }
        
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (int i = 0; i &lt; y.size(); ++i) {</span>
<span class="fc" id="L125">            PairFloat yi = y.get(i);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (isInL.contains(yi)) {</span>
<span class="fc" id="L127">                yL.add(yi);</span>
            } else {
<span class="fc" id="L129">                yR.add(yi);</span>
            }
        }
        
        // use 2 recursive calls for conquer

        // find closest pair in pL w/ pL, xL, and yL
<span class="fc" id="L136">        ClosestPairFloat cpL = divide(pL, xL, yL);</span>

        // find closest pair in pP w/ pR, xR, and yR
<span class="fc" id="L139">        ClosestPairFloat cpR = divide(pR, xR, yR);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">        ClosestPairFloat d = (cpL.separation &lt;= cpR.separation) ? cpL : cpR;</span>
        
<span class="fc" id="L143">        return combine(yL, yR, d, xL.get(xL.size() - 1), xR.get(0));            </span>
    }
    
    /**
     * runtime complexity:
     *    O(N) plus a small fraction of points contributing O(m lg m) for a sort
     * @param yL
     * @param yR
     * @param d
     * @param leftMostL
     * @param rightMostR
     * @return 
     */
    protected ClosestPairFloat combine(List&lt;PairFloat&gt; yL, List&lt;PairFloat&gt; yR, 
        ClosestPairFloat d,  PairFloat leftMostL, PairFloat rightMostR) {
        
<span class="fc" id="L159">        List&lt;PairFloat&gt; yPrime = new ArrayList&lt;PairFloat&gt;();</span>
        
<span class="fc" id="L161">        float delta = d.separation;</span>
        
        // find the points in yL that have x within delta from leftMostL
        // traversing yL (rather than xL) to keep yPrime ordered
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (int i = 0; i &lt; yL.size(); ++i) {</span>
<span class="fc" id="L166">            float xPoint = yL.get(i).getX();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if ((leftMostL.getX() - xPoint) &lt;= delta) {</span>
<span class="fc" id="L168">                yPrime.add(yL.get(i));</span>
            }
        }
        
        // find the points in yR that have x within delta from rightMostR
        // traversing yR (rather than xR) to keep yPrime ordered
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (int i = 0; i &lt; yR.size(); ++i) {</span>
<span class="fc" id="L175">            float xPoint = yR.get(i).getX();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            if ((xPoint - rightMostR.getX()) &lt;= delta) {</span>
<span class="fc" id="L177">                yPrime.add(yR.get(i));</span>
            }
        }
        
<span class="fc" id="L181">        int idx0 = -1;</span>
<span class="fc" id="L182">        int idx1 = -1;</span>
<span class="fc" id="L183">        double minDistSq = Double.MAX_VALUE;</span>
        
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int i = 0; i &lt; yPrime.size(); i++) {</span>
            
<span class="fc" id="L187">            PairFloat yi = yPrime.get(i);</span>
            
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            for (int j = (i + 1); j &lt; (i + 8); j++) {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (j &gt; (yPrime.size() - 1)) {</span>
<span class="fc" id="L191">                    break;</span>
                }
                
<span class="fc" id="L194">                PairFloat yj = yPrime.get(j);</span>
                
<span class="fc" id="L196">                float diffX = yi.getX() - yj.getX();</span>
<span class="fc" id="L197">                float diffY = yi.getY() - yj.getY();</span>
                
<span class="fc" id="L199">                double distSq = (diffX * diffX) + (diffY * diffY);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L201">                    minDistSq = distSq;</span>
<span class="fc" id="L202">                    idx0 = i;</span>
<span class="fc" id="L203">                    idx1 = j;</span>
                }
            }
        }
       
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (minDistSq == Double.MAX_VALUE) {</span>
<span class="nc" id="L209">            return d;</span>
        }
        
<span class="fc" id="L212">        float dist = (float)Math.sqrt(minDistSq);</span>
        
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (dist &lt; delta) {</span>
<span class="nc" id="L215">            return new ClosestPairFloat(yPrime.get(idx0), yPrime.get(idx1), dist);</span>
        } else {
<span class="fc" id="L217">            return d;</span>
        }        
    }
    
    /**
     *
     * @param p
     * @return
     */
    protected ClosestPairFloat bruteForceMinDistance(List&lt;PairFloat&gt; p) {
        
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (p.size() &lt; 1) {</span>
<span class="nc" id="L229">            return new ClosestPairFloat(null, null, Float.MAX_VALUE);</span>
        }
        
<span class="fc" id="L232">        double minDistSq = Double.MAX_VALUE;</span>
<span class="fc" id="L233">        int idx0 = -1;</span>
<span class="fc" id="L234">        int idx1 = -1;</span>

<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (int i = 0; i &lt; p.size(); i++) {</span>
            
<span class="fc" id="L238">            PairFloat pi = p.get(i);</span>
            
<span class="fc bfc" id="L240" title="All 2 branches covered.">            for (int j = i; j &lt; p.size(); j++) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (i == j) {</span>
<span class="fc" id="L242">                    continue;</span>
                }
                
<span class="fc" id="L245">                PairFloat pj = p.get(j);</span>
                
<span class="fc" id="L247">                float diffX = pi.getX() - pj.getX();</span>
<span class="fc" id="L248">                float diffY = pi.getY() - pj.getY();</span>
<span class="fc" id="L249">                double distSq = (diffX * diffX) + (diffY * diffY);</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">                if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L252">                    minDistSq = distSq;</span>
<span class="fc" id="L253">                    idx0 = i;</span>
<span class="fc" id="L254">                    idx1 = j;</span>
                }
            }
        }
        
<span class="fc" id="L259">        float minDist = (float)Math.sqrt(minDistSq);</span>
        
<span class="fc" id="L261">        return new ClosestPairFloat(p.get(idx0), p.get(idx1), minDist);</span>
    }

    /**
     *
     */
    public class ClosestPairFloat {
        PairFloat point0;
        PairFloat point1;
        float separation;

        /**
         *
         * @param p0
         * @param p1
         * @param sep
         */
        public ClosestPairFloat(PairFloat p0, PairFloat p1, float sep) {
            this.point0 = p0;
            this.point1 = p1;
            this.separation = sep;
        }
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
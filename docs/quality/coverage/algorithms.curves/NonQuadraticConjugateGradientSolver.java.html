<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NonQuadraticConjugateGradientSolver.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.curves</a> &gt; <span class="el_source">NonQuadraticConjugateGradientSolver.java</span></div><h1>NonQuadraticConjugateGradientSolver.java</h1><pre class="source lang-java linenums">package algorithms.curves;

import java.io.IOException;
import java.util.logging.Logger;

import algorithms.curves.GEVChiSquareMinimization.WEIGHTS_DURING_CHISQSUM;
import algorithms.util.PolygonAndPointPlotter;
import algorithms.util.ResourceFinder;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * &lt;code&gt;
   Class to find the minimum difference between a GEV model function(k, sigma, mu)
   and normalized data with errors.
   
   To make a solution faster than the very robust but slow downhill simplex method,
   would like to use the partial derivatives of the GEV 
   to make an iterative solution for chi-square minimization 
   of a non-linear, non-quadratic GEV model's difference from the data.
   
   This solution uses a pre-conditioner matrix with ICU0 function to help
   determine the next stop and direction. 
 
   Useful for implementing the code below was reading:
   
   
   http://en.wikipedia.org/wiki/Fletcher-Reeves#Nonlinear_conjugate_gradient
   
   and
   
   http://netlib.org/linalg/html_templates/node64.html#figdilu
   
   and browsing various books on optimization
   
    =============================================================================================
    
    Minimize f(vars)
         
     The function f is called the objective function or cost function.
     
      The vector x is an n-vector of independent variables: 
         vars = [var&lt;sub&gt;1&lt;/sub&gt;, var&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;, 
         var&lt;sub&gt;n&lt;/sub&gt;]&lt;sup&gt;T&lt;/sup&gt; is a member of set Real numbers. 
         The variables var&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, var&lt;sub&gt;n&lt;/sub&gt; are often 
         referred to as decision variables. 
     
      The optimization problem above can be viewed as a decision problem that 
      involves finding the best vector var of the decision variables over all 
      possible vectors in &amp;#937;.   By the best vector we mean the one that 
      results in the-smallest value of the objective function. 
      
      This vector is called the minimizer of f over &amp;#937;. 
      It is possible that there may be many minimizers. In this case, finding 
      any of the minimizers will suffice.
          
       Df is the first derivative of f(vars) and is 
           [partial deriv f/partial deriv var&lt;sub&gt;1&lt;/sub&gt;, partial deriv f/partial deriv var&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;]
       
       &amp;nabla;f = the gradient of f. 
       &amp;nabla;f = (Df)&lt;sup&gt;T&lt;/sup&gt;
       
       F(vars) is the 2nd derivative of f and is sometimes called the Hessian.
                                 | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;f/&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;var&lt;sub&gt;1&lt;/sub&gt;       &amp;#8230;    &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;f/&amp;#8706;var&lt;sub&gt;n&lt;/sub&gt;&amp;#8706;var&lt;sub&gt;1&lt;/sub&gt;
          F(vars) = D&lt;sup&gt;2&lt;/sup&gt;f(vars) =   |    &amp;#8230;           &amp;#8230;     &amp;#8230;
                                 | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;f/&amp;#8706;var&lt;sub&gt;1&lt;/sub&gt;&amp;#8706;var&lt;sub&gt;n&lt;/sub&gt;   &amp;#8230;    &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;f/&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;var&lt;sub&gt;n&lt;/sub&gt;
       
       Example:  Let f(x1, x2) = 5(x&lt;sub&gt;1&lt;/sub&gt;) + 8(x&lt;sub&gt;2&lt;/sub&gt;) + (x&lt;sub&gt;1&lt;/sub&gt;)(x&lt;sub&gt;2&lt;/sub&gt;) &amp;#8722; (x&lt;sub&gt;1&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt; &amp;#8722; 2(x&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;
             Df(x) = (&amp;nabla;f(x))&lt;sup&gt;T&lt;/sup&gt; = [&amp;#8706;f/&amp;#8706;x&lt;sub&gt;1&lt;/sub&gt;, &amp;#8706;f/&amp;#8706;x&lt;sup&gt;2&lt;/sup&gt;] = [5 + x&lt;sub&gt;2&lt;/sub&gt; &amp;#8722; 2x&lt;sub&gt;1&lt;/sub&gt;,  8 + x&lt;sub&gt;1&lt;/sub&gt; &amp;#8722; 4x&lt;sub&gt;2&lt;/sub&gt;]
             
                                | -2  1 |
             F(x) = D&lt;sup&gt;2&lt;/sup&gt;f(x)    = |  1 -4 |
             
       --------------------------------------------------------------------------------
       
       f(k, sigma, mu) = the GEV function
       
       Df = [&amp;#8706;/&amp;#8706;k, &amp;#8706;/&amp;#8706;sigma, &amp;#8706;/&amp;#8706;mu]
       
                     |   &amp;#8706;/&amp;#8706;k   |
       &amp;nabla;f = (Df)&lt;sup&gt;T&lt;/sup&gt; =   | &amp;#8706;/&amp;#8706;sigma |
                     |   &amp;#8706;/&amp;#8706;mu  |
            
                                              | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k     &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k        &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k     |
       F(k, sigma, mu) = D&lt;sup&gt;2&lt;/sup&gt;f(k, sigma, mu) =   | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma   &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma    &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;sigma |
                                              | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu      &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;mu       &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu    |
            
       M = D&lt;sup&gt;2&lt;/sup&gt;f(k, sigma, mu)
       
                                | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k        &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma       &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu     |     |   &amp;#8706;/&amp;#8706;k   |
       M^(-1) * &amp;nabla;f = M&lt;sup&gt;T&lt;/sup&gt; * &amp;nabla;f =  | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k    &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma   &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;mu |  *  | &amp;#8706;/&amp;#8706;sigma |
                                | &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k       &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;sigma      &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu    |     |   &amp;#8706;/&amp;#8706;mu  |
                                
                                | (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k * (&amp;#8706;/&amp;#8706;k) +  (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma) * (&amp;#8706;/&amp;#8706;sigma) + (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu) * (&amp;#8706;/&amp;#8706;mu)          |
                              = | (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k) * (&amp;#8706;/&amp;#8706;k) + (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) * (&amp;#8706;/&amp;#8706;sigma) + (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;mu)*(&amp;#8706;/&amp;#8706;mu) |
                                | (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k)*(&amp;#8706;/&amp;#8706;k) + (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;sigma)*(&amp;#8706;/&amp;#8706;sigma) + (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu)*(&amp;#8706;/&amp;#8706;mu)              |
                                
       Can use Incomplete Cholesky factorization with fill 0 on M&lt;sup&gt;(-1)&lt;/sup&gt; to create the pre-conditioning matrix.
       
           http://netlib.org/linalg/html_templates/node64.html#figdilu
           
           Let S be the non-zero set ({i,j} : a&lt;sub&gt;ij&lt;/sub&gt; != 0 )
           
            for i = 1, 2, &amp;#8230;
                set d&lt;sub&gt;ii&lt;/sub&gt; = a&lt;sub&gt;ii&lt;/sub&gt;
            for i = 1, 2, &amp;#8230;
                set d&lt;sub&gt;ii&lt;/sub&gt; = 1/d&lt;sub&gt;ii&lt;/sub&gt;
                for j = i + 1, i + 2, &amp;#8230;                       
                if (i, j) in set S and (j, i) in set S then
                    set d&lt;sub&gt;jj&lt;/sub&gt; = d&lt;sub&gt;jj&lt;/sub&gt; - a&lt;sub&gt;ji&lt;/sub&gt; * d&lt;sub&gt;ii&lt;/sub&gt; * a&lt;sub&gt;ij&lt;/sub&gt;
            
            set d(1,1) = (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k)
            set d(2,2) = (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma)
            set d(3,3) = (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu)
            
            i = 1:
                    set d(1,1) = 1./d(1,1) = 1./(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k)
                
                    | (1,1) (1,2) (1,3) | = | 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k)   
                d = | (2,1) (2,2) (2,3) | = |                     (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma)  
                    | (3,1) (3,2) (3,3) | = |                                             (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu) |
                  
                j=2:
                    set d(2,2) = (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma)
                j=3:
                    set d(3,3) = (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu)
                    
            i = 2:
                    set d(2,2) = 1./d(2,2) = ( 1./ ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma) ) )
                    
                    | (1,1) (1,2) (1,3) | = | 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k)   
                d = | (2,1) (2,2) (2,3) | = |                latest d(2,2)  
                    | (3,1) (3,2) (3,3) | = |                                             (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu) |
                    
                j=3:
                    set d(3,3) = d(3,3) - a(3,2) * d(2,2) * a(2,3)
                               =
                                 ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu) )
                                 -
                                 (
                                    (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;sigma)
                                    *
                                    ( 1./ ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma) ) )
                                    *
                                    &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;mu
                                 )
                                  
            i = 3:
                    set d(3,3) = 1./d(3,3)
                    
                        = 1./(
                                 ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu) )
                                 -
                                 (
                                    (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;sigma)
                                    *
                                    ( 1./ ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma) ) )
                                    *
                                    &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;mu
                                 )
                             ) 
                             
                             
    Then using the ICU0 matrix as preconditioner:
           
                                        | d(1,1)   0        0      |     |   &amp;#8706;/&amp;#8706;k   |
        (M_icuo)&lt;sup&gt;(-1)&lt;/sup&gt; * &amp;nabla;f = M&lt;sup&gt;T&lt;/sup&gt; * &amp;nabla;f =     | 0        d(2,2)   0      |  *  | &amp;#8706;/&amp;#8706;sigma |
                                        | 0        0        d(3,3) |     |   &amp;#8706;/&amp;#8706;mu  |
                                    
                                        | d(1,1) * (&amp;#8706;/&amp;#8706;k)     |
                                      = | d(2,2) * (&amp;#8706;/&amp;#8706;sigma) |
                                        | d(3,3) * (&amp;#8706;/&amp;#8706;mu)    |

             where d(1,1) is 1./(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k)
                   d(2,2) is ( 1./ ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma) ) )
                   d(3,3) is 1./(
                                     ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;mu) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;mu) )
                                     -
                                     (
                                        (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;mu&amp;#8706;sigma)
                                        *
                                        ( 1./ ( (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;sigma) - (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;k)*( 1/(&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k, that is &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;k) ) * (&amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;k&amp;#8706;sigma) ) )
                                        *
                                        &amp;#8706;&lt;sup&gt;2&lt;/sup&gt;/&amp;#8706;sigma&amp;#8706;mu
                                     )
                                 ) 
                                 
       Note that below in the code, r is &amp;nabla;f.
  &lt;/code&gt;
  @author nichole
 */
public class NonQuadraticConjugateGradientSolver extends AbstractCurveFitter {
    
    /**
     *
     */
<span class="fc" id="L201">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    /**
     *
     */
<span class="fc" id="L206">    protected int maxIterations = 200;</span>
    
    /**
     *
     */
    protected PolygonAndPointPlotter plotter;
    
    /**
     *
     */
<span class="fc" id="L216">    protected static float eps = 1e-8f;</span>
    
    /**
     *
     */
<span class="fc" id="L221">    protected static float convergedEps = 0.00001f;</span>
    
    /**
     *
     */
<span class="fc" id="L226">    protected boolean calcStepParamsSeparately = true;</span>
        
    /**
     *
     * @param xPoints
     * @param yPoints
     * @param xErrPoints
     * @param yErrPoints
     */
    public NonQuadraticConjugateGradientSolver(float[] xPoints, float[] yPoints,
        float[] xErrPoints, float[] yErrPoints) {

<span class="fc" id="L238">        super(xPoints, yPoints, xErrPoints, yErrPoints);</span>
<span class="fc" id="L239">    }    </span>

    /**
     *
     * @param maxNumber
     */
    public void setMaximumNumberOfIterations(int maxNumber) {
<span class="fc" id="L246">        this.maxIterations = maxNumber;</span>
<span class="fc" id="L247">    }</span>
    
    /**
     *
     * @param doUseDebug
     */
    @Override
    public void setDebug(boolean doUseDebug) {
        
<span class="fc" id="L256">        super.setDebug(doUseDebug);</span>
        
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (debug) {</span>
            try {
<span class="nc" id="L260">                plotter = new PolygonAndPointPlotter(xmin, xmax, ymin, ymax);</span>
<span class="nc" id="L261">            } catch (IOException e) {</span>
<span class="nc" id="L262">                log.severe(e.getMessage());</span>
<span class="nc" id="L263">            }</span>
        }
<span class="fc" id="L265">    }</span>
    
    /**
     * fit the x and y data using default ranges for the parameters k, sigma, and mu.
     * The generated curves use parameter step sizes determined from using
     * the k, sigma, and mu derivatives separately and keeping the best result.
     * @param weightMethod
     * @return 
     * @throws algorithms.curves.FailedToConvergeException
     * @throws java.io.IOException
     */
    public GEVYFit fitCurveKGreaterThanZero(WEIGHTS_DURING_CHISQSUM weightMethod) 
        throws FailedToConvergeException, IOException {
        
<span class="fc" id="L279">        calcStepParamsSeparately = true;</span>
        
<span class="fc" id="L281">        return fitCurveKGreaterThanZero();</span>
    }
    
    /**
     * fit the x and y data using default ranges for the parameters k, sigma, and mu.
     * The generated curves use parameter step sizes determined from using all
     * of the k, sigma, and mu derivatives at once.
     * @param weightMethod
     * @return 
     * @throws algorithms.curves.FailedToConvergeException
     * @throws java.io.IOException
     */
    public GEVYFit fitCurveKGreaterThanZeroAllAtOnce(WEIGHTS_DURING_CHISQSUM weightMethod) 
        throws FailedToConvergeException, IOException {
        
<span class="fc" id="L296">        calcStepParamsSeparately = false;</span>
        
<span class="fc" id="L298">        return fitCurveKGreaterThanZero();</span>
    }
    
    /**
     *
     * @return
     * @throws FailedToConvergeException
     * @throws IOException
     */
    protected GEVYFit fitCurveKGreaterThanZero() throws FailedToConvergeException, IOException {
        
<span class="fc" id="L309">        String filePath = ResourceFinder.findFileInResources(&quot;sim_curve_params_01.txt&quot;);</span>
        
<span class="fc" id="L311">        File f = new File(filePath);</span>
        
<span class="fc" id="L313">        BufferedReader reader = null;</span>
<span class="fc" id="L314">        FileReader fr = null;</span>
        
<span class="fc" id="L316">        List&lt;Float&gt; kParams = new ArrayList&lt;Float&gt;();</span>
<span class="fc" id="L317">        List&lt;Float&gt; sParams = new ArrayList&lt;Float&gt;();</span>
<span class="fc" id="L318">        List&lt;Float&gt; mParams = new ArrayList&lt;Float&gt;();</span>
        
        try {
<span class="fc" id="L321">            fr = new FileReader(f);</span>
<span class="fc" id="L322">            reader = new BufferedReader(fr);</span>
<span class="fc" id="L323">            String line = reader.readLine();</span>
<span class="fc" id="L324">            line = reader.readLine();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">            while (line != null) {</span>
                
<span class="fc" id="L327">                String[] params = line.split(&quot;\\s+&quot;);</span>
                
<span class="fc" id="L329">                kParams.add(Float.valueOf(params[0]));</span>
<span class="fc" id="L330">                sParams.add(Float.valueOf(params[1]));</span>
<span class="fc" id="L331">                mParams.add(Float.valueOf(params[2]));</span>
                                
<span class="fc" id="L333">                line = reader.readLine();</span>
<span class="fc" id="L334">            }</span>
            
        } finally {
<span class="pc bpc" id="L337" title="3 of 4 branches missed.">            if (fr != null) {</span>
<span class="pc" id="L338">                fr.close();</span>
            }
<span class="pc bpc" id="L340" title="3 of 4 branches missed.">            if (reader != null) {</span>
<span class="pc" id="L341">                reader.close();</span>
            }
        }
        
<span class="fc" id="L345">        int n = kParams.size();</span>
<span class="fc" id="L346">        int bestFitIndex = -1;</span>
<span class="fc" id="L347">        GEVYFit bestFit = null;</span>
        
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for (int i = 0; i &lt; n - 1; i++) {</span>
            
<span class="fc" id="L351">            float kMin = kParams.get(i).floatValue();</span>
<span class="fc" id="L352">            float kMax = kParams.get(i + 1).floatValue();</span>
<span class="fc" id="L353">            float sMin = sParams.get(i).floatValue();</span>
<span class="fc" id="L354">            float sMax = sParams.get(i + 1).floatValue();</span>
<span class="fc" id="L355">            float mMin = mParams.get(i).floatValue();</span>
<span class="fc" id="L356">            float mMax = mParams.get(i + 1).floatValue();</span>
            
<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (sMax &lt; sMin) {</span>
<span class="fc" id="L359">                sMax = sMin;</span>
            }
<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (mMax &lt; mMin) {</span>
<span class="fc" id="L362">                mMax = mMin;</span>
            }
            
<span class="fc" id="L365">            GEVYFit yFit = fitCurveParameters(kMin, kMax, sMin, sMax, mMin, mMax);</span>
            
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (yFit != null) {</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                if (bestFit == null) {</span>
<span class="fc" id="L369">                    bestFit = yFit;</span>
<span class="fc" id="L370">                    bestFitIndex = i;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">                } else if (yFit.chiSqStatistic &lt; bestFit.chiSqStatistic) {</span>
<span class="fc" id="L372">                    bestFit = yFit;</span>
<span class="fc" id="L373">                    bestFitIndex = i;</span>
                }
            }
        }
        
<span class="fc" id="L378">        return bestFit;</span>
    }

    /**
     * find the best fitting GEV by solving for each parameter in set {k, sigma, mu} separately
     * rather then minimizing the function for suggested changes by all derivatives at once.
     * 
     * So far, this is resulting in the best fits, but is sensitive to the starting point
     * and has not been tested over a wide range of data distributions.
     * 
     * The range of values given to this method by TwoPointVoidStats are those found to be most useful
     * for representing the range of normalized GEV curves that match the datasets given to it.
     * k &amp;lt; 0 are not fit because the distributions are not physical for the expected datasets,
     * though that can be changed if needed.
     * 
     * @param kMin  minimum range of value of k, the shape parameter
     * @param kMax  maximum range of value of k, the shape parameter
     * @param sigmaMin  minimum range of value of sigma, the scale parameter
     * @param sigmaMax  maximum range of value of sigma, the scale parameter
     * @param muMin  minimum range of value of mu, the location parameter
     * @param muMax  maximum range of value of mu, the location parameter
     * @return
     * @throws FailedToConvergeException
     */
    public GEVYFit fitCurveParametersSeparately(float kMin, float kMax, 
        float sigmaMin, float sigmaMax, float muMin, float muMax) throws 
        FailedToConvergeException {
        
<span class="nc" id="L406">        calcStepParamsSeparately = true;</span>
       
<span class="nc" id="L408">        return fitCurveParameters(kMin, kMax, sigmaMin, sigmaMax, muMin, muMax);</span>
    }
    
    /**
     * fit the x, y data with a GEV whose parameters are within the given ranges for k,
     * sigma, and mu.  The method attempts to fit for changes in k, sigma, and mu all
     * at once for each iteration.
     * 
     * @param kMin  minimum range of value of k, the shape parameter
     * @param kMax  maximum range of value of k, the shape parameter
     * @param sigmaMin  minimum range of value of sigma, the scale parameter
     * @param sigmaMax  maximum range of value of sigma, the scale parameter
     * @param muMin  minimum range of value of mu, the location parameter
     * @param muMax  maximum range of value of mu, the location parameter
     * @return
     * @throws FailedToConvergeException
     */
    public GEVYFit fitCurveParametersAllAtOnce(float kMin, float kMax, 
        float sigmaMin, float sigmaMax, float muMin, float muMax) throws 
        FailedToConvergeException {

<span class="fc" id="L429">        calcStepParamsSeparately = false;</span>
       
<span class="fc" id="L431">        return fitCurveParameters(kMin, kMax, sigmaMin, sigmaMax, muMin, muMax);</span>
    }

    /**
     * find the best fitting GEV by solving for each parameter in set {k, sigma, mu} separately
     * rather then minimizing the function for suggested changes by all derivatives at once.
     * 
     * So far, this is resulting in the best fits, but is sensitive to the starting point
     * and has not been tested over a wide range of data distributions.
     * 
     * The range of values given to this method by TwoPointVoidStats are those found to be most useful
     * for representing the range of normalized GEV curves that match the datasets given to it.
     * k &amp;lt; 0 are not fit because the distributions are not physical for the expected datasets,
     * though that can be changed if needed.
     * 
     * @param kMin  minimum range of value of k, the shape parameter
     * @param kMax  maximum range of value of k, the shape parameter
     * @param sigmaMin  minimum range of value of sigma, the scale parameter
     * @param sigmaMax  maximum range of value of sigma, the scale parameter
     * @param muMin  minimum range of value of mu, the location parameter
     * @param muMax  maximum range of value of mu, the location parameter
     * @return
     * @throws FailedToConvergeException
     */
    public GEVYFit fitCurveParameters(float kMin, float kMax, float sigmaMin, float sigmaMax,
        float muMin, float muMax) throws FailedToConvergeException {
        
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (kMin &lt; 0) {</span>
<span class="nc" id="L459">            throw new IllegalArgumentException(&quot;kMin must be larger than zero&quot;);</span>
        }
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (kMin &gt; kMax) {</span>
<span class="nc" id="L462">            throw new IllegalArgumentException(&quot;kMin must be less than kMax&quot;);</span>
        }
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (muMin &lt; 0) {</span>
<span class="nc" id="L465">            throw new IllegalArgumentException(&quot;muMin must be larger than zero. mu is usually near the peak of the normalized histogram's x value.&quot;);</span>
        }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (muMin &gt; muMax) {</span>
<span class="nc" id="L468">            throw new IllegalArgumentException(&quot;muMin must be less than muMax&quot;);</span>
        }
        /*if (muMax &gt; xmax) {
            throw new IllegalArgumentException(&quot;muMax must be less than the maximum value of x in the histogram (&quot; + xmax + &quot;)&quot;);
        }*/
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (sigmaMin &lt; 0) {</span>
<span class="nc" id="L474">            throw new IllegalArgumentException(&quot;sigmaMin must be larger than zero&quot;);</span>
        }
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        if (sigmaMin &gt; sigmaMax) {</span>
<span class="nc" id="L477">            throw new IllegalArgumentException(&quot;sigmaMin must be less than sigmaMax&quot;);</span>
        }
        
<span class="fc" id="L480">        float kVar = (kMax + kMin)/2.f;</span>
<span class="fc" id="L481">        float sigmaVar = (sigmaMax + sigmaMin)/2.f;</span>
<span class="fc" id="L482">        float muVar = (muMax + muMin)/2.f;</span>
        
        // the variables k, sigma, and mu
<span class="fc" id="L485">        float[] vars    = new float[]{kVar, sigmaVar, muVar};</span>
<span class="fc" id="L486">        float[] varsMin = new float[]{kMin, sigmaMin, muMin};</span>
<span class="fc" id="L487">        float[] varsMax = new float[]{kMax, sigmaMax, muMax};</span>
     
<span class="fc" id="L489">        float[] prevVars = new float[]{kVar, sigmaVar, muVar};</span>
        
<span class="fc" id="L491">        int varStopIdx = vars.length - 1;</span>
        
        // chiSqSumForLineSearch[0] holds current best chiSqSum for the last change in vars
        // chiSqSumForLineSearch[1] holds the return value from DerivGEV if step &gt; 0 was admissable
<span class="fc" id="L495">        float[] chiSqSumForLineSearch = new float[2];</span>
        
<span class="fc" id="L497">        chiSqSumForLineSearch[0] = DerivGEV.chiSqSum(vars[0], vars[1], vars[2], x, y, ye);</span>
        
        // r is current residual.  it holds deltaK, deltaSigma, and deltaMu
<span class="fc" id="L500">        float[] r = new float[3];</span>
        
<span class="fc" id="L502">        int nSameSequentially = 0;</span>
<span class="fc" id="L503">        float epsChiSame = 1e-5f;</span>
<span class="fc" id="L504">        float lastChiSqSum = Float.MAX_VALUE;</span>
        
<span class="fc" id="L506">        GEVYFit bestYFit = new GEVYFit();</span>
        
<span class="fc" id="L508">        int nIter = 0;</span>
                
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        while ((nIter &lt; maxIterations) /*&amp;&amp; (chiSqSumForLineSearch[0] &gt; convergedEps)*/) {</span>
            
<span class="fc bfc" id="L512" title="All 2 branches covered.">            if (nSameSequentially &gt; 0) {                            </span>
<span class="fc" id="L513">                break;</span>
            }
         
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (nIter &gt; 0) {</span>
                
<span class="fc bfc" id="L518" title="All 2 branches covered.">                if (calcStepParamsSeparately) {</span>
                    
<span class="fc bfc" id="L520" title="All 2 branches covered.">                    for (int k = 0; k &lt;= varStopIdx; k++) {</span>
                        // populate r with the best fitting derivatives for vars[]
<span class="fc" id="L522">                        DerivGEV.derivsThatMinimizeChiSqSum(vars, varsMin, varsMax, chiSqSumForLineSearch,</span>
                            x, y, ye, r, k, k);

<span class="fc bfc" id="L525" title="All 2 branches covered.">                        if (r[k] != 0) {</span>
<span class="fc" id="L526">                            vars[k] += r[k];</span>
<span class="fc" id="L527">                            chiSqSumForLineSearch[0] = chiSqSumForLineSearch[1];</span>
                        }

<span class="fc" id="L530">                        log.finest(&quot;   -&gt;r[&quot; + k + &quot;]=&quot; + r[k]  + &quot;  vars[&quot; + k + &quot;]=&quot; + vars[k] + &quot; nIter=&quot; + nIter);</span>
                    }
                    
                } else {
                
                    // populate r with the best fitting derivatives for vars[]
<span class="fc" id="L536">                    DerivGEV.derivsThatMinimizeChiSqSum(vars, varsMin, varsMax, chiSqSumForLineSearch,</span>
                        x, y, ye, r, 0, varStopIdx); 

<span class="fc bfc" id="L539" title="All 2 branches covered.">                    for (int k = 0; k &lt;= varStopIdx; k++) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                        if (r[k] != 0) {</span>
<span class="fc" id="L541">                            vars[k] += r[k];</span>
<span class="fc" id="L542">                            chiSqSumForLineSearch[0] = chiSqSumForLineSearch[1];</span>
                        }
                    }
                }
            }
            
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L549">                float[] yGEV = GeneralizedExtremeValue.generateNormalizedCurve(x, vars[0], vars[1], vars[2]);</span>
<span class="nc" id="L550">                float chiSqSum = DerivGEV.chiSqSum(yGEV, y, ye);</span>
                try {
<span class="nc" id="L552">                    String label = String.format(&quot;k=%4.4f &lt;*&gt;  s=%4.4f &lt;*&gt;  m=%4.4f &lt;*&gt;  n=%d  chi=%4.8f yscl=%.0f&quot;,</span>
<span class="nc" id="L553">                        vars[0], vars[1], vars[2], nIter, chiSqSum, this.yScale);</span>
<span class="nc" id="L554">                    plotFit(yGEV, label);</span>
<span class="nc" id="L555">                } catch (IOException e) {</span>
<span class="nc" id="L556">                    System.err.println(e.getMessage());</span>
<span class="nc" id="L557">                }</span>
            }
            
<span class="fc bfc" id="L560" title="All 2 branches covered.">            if ((nIter &gt; 0) &amp;&amp; </span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                ((Math.abs(lastChiSqSum - chiSqSumForLineSearch[0]) &lt; epsChiSame) </span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                || (Arrays.equals(prevVars, vars)))</span>
                ) {
<span class="fc" id="L564">                nSameSequentially++;</span>
            } else {
<span class="fc" id="L566">                nSameSequentially = 0;</span>
            }
<span class="fc" id="L568">            lastChiSqSum = chiSqSumForLineSearch[0];</span>
            
<span class="fc" id="L570">            System.arraycopy(vars, 0, prevVars, 0, vars.length);</span>
            
<span class="fc" id="L572">            nIter++;</span>
        }
        
<span class="fc" id="L575">        bestYFit = compareFits(bestYFit, vars, chiSqSumForLineSearch);</span>
        
<span class="fc" id="L577">        return bestYFit;</span>
    }
  
    /**
     *
     * @param bestYFit
     * @param vars
     * @param chiSqSumForLineSearch
     * @return
     */
    protected GEVYFit compareFits(GEVYFit bestYFit, float[] vars, float[] chiSqSumForLineSearch) {
        
<span class="pc bpc" id="L589" title="2 of 4 branches missed.">        if ((bestYFit == null) || (chiSqSumForLineSearch[0] &lt; bestYFit.getChiSqSum())) {</span>
            
<span class="fc" id="L591">            float[] yGEV = GeneralizedExtremeValue.generateNormalizedCurve(x, vars[0], vars[1], vars[2]);</span>
    
<span class="fc" id="L593">            float degreesOfFreedom = yGEV.length - 3 - 1;</span>

<span class="fc" id="L595">            float chiSqStatistic = chiSqSumForLineSearch[0]/degreesOfFreedom;</span>
            
<span class="fc" id="L597">            bestYFit = new GEVYFit();</span>
<span class="fc" id="L598">            bestYFit.setChiSqSum(chiSqSumForLineSearch[0]);</span>
<span class="fc" id="L599">            bestYFit.setChiSqStatistic(chiSqStatistic);</span>
<span class="fc" id="L600">            bestYFit.setK(vars[0]);</span>
<span class="fc" id="L601">            bestYFit.setSigma(vars[1]);</span>
<span class="fc" id="L602">            bestYFit.setMu(vars[2]);</span>
<span class="fc" id="L603">            bestYFit.setYFit(yGEV);</span>
<span class="fc" id="L604">            bestYFit.setX(x);</span>
<span class="fc" id="L605">            bestYFit.setXScale(xScale);</span>
<span class="fc" id="L606">            bestYFit.setYScale(yScale);</span>
        }
        
<span class="fc" id="L609">        return bestYFit;</span>
    }

    /**
     *
     * @param yGEV
     * @param label
     * @throws IOException
     */
    protected void plotFit(float[] yGEV, String label) throws IOException {

<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (plotter == null) {</span>
<span class="nc" id="L621">            throw new IllegalStateException(&quot;set debug in order to use plotFit&quot;);</span>
        }
        
        try {
<span class="nc" id="L625">            plotter.addPlot(x, y, xe, ye, x, yGEV, label);</span>
<span class="nc" id="L626">            String filePath = plotter.writeFile2();</span>
<span class="nc" id="L627">            log.finest(&quot;*** filePath=&quot; + filePath);</span>
<span class="nc" id="L628">        } catch (Exception e) {</span>
<span class="nc" id="L629">            Logger.getLogger(this.getClass().getSimpleName()).severe(e.getMessage());</span>
<span class="nc" id="L630">        }</span>
<span class="nc" id="L631">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
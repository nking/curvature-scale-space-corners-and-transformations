<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TwoPointBinarySearchTree.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry.clustering.twopointcorrelation</a> &gt; <span class="el_source">TwoPointBinarySearchTree.java</span></div><h1>TwoPointBinarySearchTree.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry.clustering.twopointcorrelation;

/**
 &lt;pre&gt;
  A holder for two-point identities, where the identities are the indexes
  of the indexer internal arrays.  N is the size of the dataset, that is
  the indexer.nXY.
  
  Runtime complexity:
     inserts are     O(lg₂(N)) at best and O(N) at worse.
     comparisons are O(lg₂(N))
 
  Space complexity:
     O(N)
 
  Note, could implement a balanced tree to make inserts at worse O(lg₂(N)).
 &lt;/pre&gt;
 
 * @author nichole
 */
class TwoPointBinarySearchTree implements ITwoPointIdentity {

<span class="fc" id="L23">    protected int n = 0;</span>

<span class="fc" id="L25">    protected Node root = null;</span>

    /**
     * constructor
     */
<span class="fc" id="L30">    TwoPointBinarySearchTree() {</span>
<span class="fc" id="L31">    }</span>

    @Override
    public long approximateMemoryUsed() {

<span class="nc" id="L36">        String arch = System.getProperty(&quot;sun.arch.data.model&quot;);</span>

<span class="nc bnc" id="L38" title="All 4 branches missed.">        boolean is32Bit = ((arch != null) &amp;&amp; arch.equals(&quot;64&quot;)) ? false : true;</span>

<span class="nc bnc" id="L40" title="All 2 branches missed.">        int nbits = (is32Bit) ? 32 : 64;</span>

<span class="nc" id="L42">        int arrayRefBits = 32;</span>

<span class="nc" id="L44">        int overheadBytes = 16;</span>

        // each Node:  overhead + int + int + 3 references
<span class="nc" id="L47">        int oneNodeInBits = 2*nbits * 3*arrayRefBits;</span>
<span class="nc" id="L48">        int oneNodeInBytes = (oneNodeInBits/8) + overheadBytes;</span>
<span class="nc" id="L49">        oneNodeInBytes += (oneNodeInBytes % 8);</span>

<span class="nc" id="L51">        int nNodesInBytes = n * oneNodeInBytes;</span>

        //                              root ref        nodes              1 ints
<span class="nc" id="L54">        long sumBytes = overheadBytes + (nbits/8)     + nNodesInBytes  + (nbits/8);</span>

<span class="nc" id="L56">        long padding = (sumBytes % 8);</span>

<span class="nc" id="L58">        sumBytes += padding;</span>

<span class="nc" id="L60">        return sumBytes;</span>
    }

    /**
     * check if combination is already stored, if not add it and return true, else
     * return false
     *
     * @param index0
     * @param index1
     * @return
     */
    @Override
    public boolean storeIfDoesNotContain(int index0, int index1) {

        // order the indexes to avoid double counting.
        int i0, i1;
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (index0 &lt; index1) {</span>
<span class="fc" id="L77">            i0 = index0;</span>
<span class="fc" id="L78">            i1 = index1;</span>
        } else {
<span class="nc" id="L80">            i0 = index1;</span>
<span class="nc" id="L81">            i1 = index0;</span>
        }

<span class="fc" id="L84">        Node node = search(i0, i1);</span>

<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (node != null) {</span>
<span class="fc" id="L87">            return false;</span>
        }

<span class="fc" id="L90">        insert(i0, i1);</span>

<span class="fc" id="L92">        return true;</span>
    }

    public Node search(int i0, int i1) {
<span class="fc" id="L96">        Node x = root;</span>
<span class="fc bfc" id="L97" title="All 4 branches covered.">        while ((x != null) &amp;&amp; (x.compare(i0, i1) != 0)) {</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            if (x.compare(i0, i1) &gt; 0) {</span>
<span class="nc" id="L99">                x = x.getLeft();</span>
            } else {
<span class="fc" id="L101">                x = x.getRight();</span>
            }
        }
<span class="fc" id="L104">        return x;</span>
    }

    protected void insert(int i0, int i1) {
<span class="fc" id="L108">        Node y = null;</span>
<span class="fc" id="L109">        Node x = root;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        while (x != null) {</span>
<span class="fc" id="L111">            y = x;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (x.compare(i0, i1) &gt; 0) {</span>
<span class="nc" id="L113">                x = x.getLeft();</span>
            } else {
<span class="fc" id="L115">                x = x.getRight();</span>
            }
        }

<span class="fc" id="L119">        Node z = new Node(i0, i1);</span>
<span class="fc" id="L120">        z.parent = y;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (y == null) {</span>
<span class="fc" id="L122">            root = z;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        } else if (y.compare(z) &gt; 0) {</span>
<span class="nc" id="L124">            y.setLeft(z);</span>
        } else {
<span class="fc" id="L126">            y.setRight(z);</span>
        }
<span class="fc" id="L128">        n++;</span>
<span class="fc" id="L129">    }</span>

    protected class Node {
        protected final int a0;
        protected final int a1;
        protected Node left;
        protected Node right;
        protected Node parent;
        public Node(int i0, int i1) {
            this.a0 = i0;
            this.a1 = i1;
        }
        public int compare(Node other) {
            return compare(other.a0, other.a1);
        }
        public int compare(int other0, int other1) {
            // for now, using n0.a0 &lt; n1.a0 then n0.a1 &lt; n1.a1
            if (a0 &lt; other0) {
                return -1;
            } else if (a0 &gt; other0) {
                return 1;
            }
            if (a1 &lt; other1) {
                return -1;
            } else if (a1 &gt; other1) {
                return 1;
            }
            return 0;
        }
        public Node getLeft() {
            return left;
        }
        public Node getRight() {
            return right;
        }
        public Node getParent() {
            return parent;
        }
        public void setLeft(Node lft) {
            left = lft;
        }
        public void setRight(Node rght) {
            right = rght;
        }
        public void setParent(Node prnt) {
            parent = prnt;
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
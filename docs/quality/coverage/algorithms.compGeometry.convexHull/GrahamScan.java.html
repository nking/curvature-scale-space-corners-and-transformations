<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GrahamScan.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry.convexHull</a> &gt; <span class="el_source">GrahamScan.java</span></div><h1>GrahamScan.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry.convexHull;

import algorithms.compGeometry.LinesAndAngles;
import algorithms.sorting.MultiArrayMergeSort;
import java.util.Arrays;

/**
  &lt;pre&gt;
  Solves the Convex Hull problem w/ a stack S of candidate points.
 
  Given a set of Q points returns the vertices of the ConvexHull(Q) in counterclockwise
  order.   a convex hull is the smallest convex polygon that will include all points in Q.
 
  Graham's Scan runs in O(n lg n).
    (in contrast to Jarvis's March which runs in O(nh) where h is the number of
    vertices in the convex hull.)
  Will adjust this after estimates...
 
  Both use a technique called 'rotational sweep' to process vertices in the order
  of the polar angles they form with a reference vertex.
 
  constructed from pseudo-code in Cormen et al. &quot;Introduction to Algorithms
 &lt;/pre&gt;
 
 * @author nichole
 */
public class GrahamScan {

    /**
     *
     */
<span class="fc" id="L32">    protected XYStack points = null;</span>

    /**
     *
     */
<span class="fc" id="L37">    protected float[] xHull = null;</span>

    /**
     *
     */
<span class="fc" id="L42">    protected float[] yHull = null;</span>

    /**
     *
     */
<span class="fc" id="L47">    public GrahamScan() {</span>
<span class="fc" id="L48">	}</span>

    /**
     *
     * @param x
     * @param y
     * @throws GrahamScanTooFewPointsException
     */
    public void computeHull(float[] x, float[] y) throws GrahamScanTooFewPointsException {

<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (x == null) {</span>
<span class="fc" id="L59">	    	throw new IllegalArgumentException(&quot;xArray cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L61" title="All 2 branches covered.">	    if (y == null) {</span>
<span class="fc" id="L62">	    	throw new IllegalArgumentException(&quot;yArray cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L64" title="All 2 branches covered.">	    if (x.length != y.length) {</span>
<span class="fc" id="L65">	    	throw new IllegalArgumentException(&quot;xArray must have the same number of items as yArray&quot;);</span>
        }
<span class="fc bfc" id="L67" title="All 2 branches covered.">	    if (x.length &lt; 3) {</span>
<span class="fc" id="L68">	        throw new IllegalArgumentException(&quot;xArray must have at least 3 items&quot;);</span>
        }

        /*
         * Q is a stack of candidate points which have been pushed once onto the stack
         * and removed if they are not vertices of the stack.
         *
         * when complete, the stack S contains the vertices of the hull in counterclockwise order.
         *
         * Q &gt; 3
         *
         * 1 -- let p0 be the point in Q w/ min y-coordinate, or leftmost point of a tie
         * 2 -- let &lt;p1, p2, ... pm&gt; be the remaining points in Q.
         *      sorted by polar angle in counter clockwise order around p0.
         *      ** if more than one point has the same angle, remove all but the one that is furthest from p0. **
         * 3 -- push p0 onto S
         * 4 -- push p1 onto S
         * 5 -- push p2 onto S
         * 6 -- for i=3 to m
         * 7 --     do while the angle formed by points NEXT-TO-TOP(S), TOP(S), and p_i makes a nonleft turn
         * 8 --         pop(S)
         * 9 --     push(S)
         * 10 -return S
         */

        // (1) let p0 be the point in Q w/ minimum yCoord,
        //     or the leftmost point if more than one w/ same minimum yCoord.
<span class="fc" id="L95">        MultiArrayMergeSort.sortBy1stArgThen2nd(y, x);</span>
        
<span class="fc" id="L97">        points = new XYStack(x.length);</span>

<span class="fc" id="L99">        int p0Index = 0;</span>

        // (2) let &lt;p1, p2, ..., pm&gt; be the remaining points in Q, sorted
	    //     by polar angle in counterclockwise order around p0
	    //     (if more than one pt has same angle, keep only the furthest from p0)
<span class="fc" id="L104">    	int nPointsUsable = PolarAngleMergeSort.sort(x[p0Index], y[p0Index], x, y);</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (nPointsUsable &lt; 3) {</span>
<span class="fc" id="L107">	        throw new GrahamScanTooFewPointsException(&quot;polar angle sorting has reduced the number of points to less than 3&quot;);</span>
        }

<span class="fc" id="L110">        points.push( x[p0Index], y[p0Index]);</span>
<span class="fc" id="L111">        points.push( x[1], y[1]);</span>
        //points.push( x[2], y[2]);
        
        float topX, topY;

        // for i = 3 to m
        //    while angle between next-to-top(S), top(S) and p_i makes a nonleft turn
        //        do pop(S)
        //    push(pi, S)
<span class="fc bfc" id="L120" title="All 2 branches covered.">        for (int i = 2; i &lt; nPointsUsable; i++) {</span>
    
<span class="fc" id="L122">            topX = points.peekTopX();</span>
<span class="fc" id="L123">            topY = points.peekTopY();</span>
            
<span class="fc" id="L125">            double direction = LinesAndAngles.direction(</span>
<span class="fc" id="L126">                points.peekNextToTopX(), points.peekNextToTopY(), topX, topY,</span>
                x[i], y[i]);
            
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">            while (!points.isEmpty() /*&amp;&amp; !Double.isNaN(direction)*/ &amp;&amp; (direction &gt; 0)) {</span>

<span class="fc" id="L131">                points.pop();</span>

<span class="fc" id="L133">                topX = points.peekTopX();</span>
<span class="fc" id="L134">                topY = points.peekTopY();</span>
                
<span class="fc" id="L136">                direction = LinesAndAngles.direction(</span>
<span class="fc" id="L137">                    points.peekNextToTopX(), points.peekNextToTopY(), topX, topY,</span>
                    x[i], y[i]);                
            }

<span class="fc" id="L141">            points.push(x[i], y[i]);</span>
        }

<span class="fc" id="L144">        populateHull();</span>
<span class="fc" id="L145">    }</span>

    /**
     *
     * @return
     */
    public float[] getXHull() {
<span class="fc" id="L152">        return this.xHull;</span>
    }

    /**
     *
     * @return
     */
    public float[] getYHull() {
<span class="fc" id="L160">        return this.yHull;</span>
    }

    /**
     *
     * @throws GrahamScanTooFewPointsException
     */
    protected void populateHull() throws GrahamScanTooFewPointsException {

<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (points == null) {</span>
<span class="fc" id="L170">            throw new GrahamScanTooFewPointsException(&quot;Points cannot be null.  Use computeHull first.&quot;);</span>
        }
        
<span class="fc" id="L173">        int n = points.getNPoints() + 1;</span>

<span class="fc" id="L175">        this.xHull = Arrays.copyOf(points.x, n);</span>
<span class="fc" id="L176">        this.yHull = Arrays.copyOf(points.y, n);</span>

<span class="fc" id="L178">        this.xHull[n-1] = points.x[0];</span>
<span class="fc" id="L179">        this.yHull[n-1] = points.y[0];</span>
<span class="fc" id="L180">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
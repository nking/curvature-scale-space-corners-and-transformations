package thirdparty.brendano.LBFGS;

import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Arrays;
import thirdparty.brendano.LBFGS.LBFGS.Function;

/**
 *
 * @author nichole
 */
public class Helper {
   
    /**
     * NOTE: NOT READY FOR USE.  THE Gradient calculation needs to be
     * improved.
     * a function that calculates the negative of the log likelihood
     * useful for 2D curve fitting.
     */
    public static class FunctionPolyML implements Function {

        final double[] xp;
        final double[] yp;
        final double[] initVars;

        //TODO: consider a constructor that accepts errors for the points
        
        public FunctionPolyML(final double[] xPoints, double[] yPoints,
            double[] init) {
            if (xPoints.length != yPoints.length) {
                throw new IllegalArgumentException(
                    "xPoints and yPoints must be same length");
            }
            this.xp = xPoints;
            this.yp = yPoints;
            this.initVars = init;
        }

        @Override
        public double evaluate(final double[] coeffs,
            final double[] outputGradient, int nCoeffs, double step) {
        
            final double[] diff = new double[yp.length];
            
            final double sumDiff = polynomialCoeffGradient(xp, yp, coeffs, 
                outputGradient, diff);
         
            // TODO: revisit this to consider including errors given
            //   to the code for each point.
            
            double[] mnAndStDv = MiscMath.getAvgAndStDev(diff);
            double sigma = mnAndStDv[1] * mnAndStDv[1];
            
            double f = Math.pow((1.0/(2.0*Math.PI*sigma)), (coeffs.length/2))
                * Math.exp(-1. * sumDiff/(2. * sigma));
    
            double lnf = -2. * Math.log(f);
            
            System.out.println(" lnf=" + lnf);

            return lnf;
        }
    }
 
    /**
     * calculate the gradient of the polynomial coefficients and return the
     * square root of the sum of the squared differences between data (xp, yp)
     * and the generated polynomial while populating the difference array
     * of y in the generated model and data yp.
     * 
     * @param xp
     * @param yp
     * @param coeffs
     * @param outputCoeffGrad
     * @param outputDiffY
     * @return 
     */
    public static double polynomialCoeffGradient(final double[] xp, 
        final double[] yp, final double[] coeffs, 
        final double[] outputCoeffGrad, final double[] outputDiffY) {
        
        double[] y = new double[xp.length];

        Arrays.fill(outputCoeffGrad, 0.);

        /*
        calculating the gradient of the polynomial coefficients

        example function generated by 3 coefficients:
           gen = c0 * x^2 + c1 * x^1 + c2
        
           d(gen)/d(c0) = x^2
           d(gen)/d(c1) = x^1
           d(gen)/d(c2) = 1
        */

        double[] gen = Misc.generate(coeffs, xp);

        MatrixUtil.subtract(gen, yp, outputDiffY);

        double sumDiff = 0;

        for (int i = 0; i < xp.length; ++i) {
            double x2 = 1;
            double dyAtX = outputDiffY[i];
            double dydx = dPolydXHL(coeffs, xp[i]);
            for (int j = coeffs.length - 1; j > -1; j--) {
                int varIdx = coeffs.length - j - 1;
                
                //dc/dx = dy/dx * dc/dy
                //dc = dx * dy/dx * dc/dy
                //outputCoeffGrad[varIdx] += (dyAtX * dydx / x2);
               
                double dx = dyAtX * (xp[i]/gen[i]);
                outputCoeffGrad[varIdx] +=
                    ( dx * dydx / (x2));
                
                x2 *= xp[i];
                
                if (x2 == 0.0) {
                    break;
                }
            }
            sumDiff += (dyAtX * dyAtX);
        }
        sumDiff = Math.sqrt(sumDiff);

        for (int j = 0; j < coeffs.length; ++j) {
            outputCoeffGrad[j] /= xp.length;
        }
        
        /*
        System.out.println("==>vars=" + Arrays.toString(coeffs));
        System.out.print("==>diff="); printFormattedArray(outputDiffY);
        System.out.println("==>sumDiff=" + sumDiff);
        System.out.print("==>gradient="); printFormattedArray(outputCoeffGrad);
        */
        
        return sumDiff;
    }
    
    /**
     * assuming that the polynomial coefficients coeff are given from
     * highest order to lowest, return the derivative of y with
     * respect to x.
     * e.g. for y = coeff[0] * x^2 + coeff[1] * x^1 + coeff[2]
     * it returns dydx = 2 * coeff[0] * x + coeff[1]
     * @param coeff
     * @param x
     * @return 
     */
    public static double dPolydXHL(double[] coeff, double x) {
        /*
        y = c0 * x^2 + c1 * x^1 + c2
        */
        double sum = 0;
        for (int i = 0; i < coeff.length; ++i) {
            int order = coeff.length - i - 1;
            if (order == 0) continue;
            sum += dPolydX(order, coeff[i], x);
        }
        
        return sum;
    }
    
    /**
     * assuming that the polynomial coefficients coeff are given from
     * lowest order to highest, return the derivative of y with
     * respect to x.
     * e.g. for y = coeff[0] + coeff[1] * x + coeff[2]*x^2
     * it returns dydx = coeff[1] + 2.*coeff[1]*x
     * @param coeff
     * @param x
     * @return 
     */
    public static double dPolydXLH(double[] coeff, double x) {
       
        double sum = 0;
        for (int order = 1; order < coeff.length; ++order) {
            sum += dPolydX(order, coeff[order], x);
        }
        
        return sum;
    }
    
    private static double dPolydX(int order, double coeff, double x) {
        
        if (order == 0) {
            return 0;
        }
        
        double dydx = coeff * (double)order * Math.pow(x, order - 1);
        
        return dydx;
    }
    
    private static void printFormattedArray(double[] a) {
        System.out.print("[");
        for (double m : a) {
            System.out.format("%.3f, ", (float)m);
        }
        System.out.println("]");
    }
}

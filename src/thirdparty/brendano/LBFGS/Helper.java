package thirdparty.brendano.LBFGS;

import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Arrays;
import thirdparty.brendano.LBFGS.LBFGS.Function;

/**
 *
 * @author nichole
 */
public class Helper {
   
    /**
     * NOTE: NOT READY FOR USE.  THE Gradient calculation needs to be
     * improved.
     * a function that calculates the negative of the log likelihood
     * useful for 2D curve fitting.
     */
    public static class FunctionPolyML implements Function {

        final double[] xp;
        final double[] yp;
        final double[] initVars;

        //TODO: consider a constructor that accepts errors for the points
        
        public FunctionPolyML(final double[] xPoints, double[] yPoints,
            double[] init) {
            if (xPoints.length != yPoints.length) {
                throw new IllegalArgumentException(
                    "xPoints and yPoints must be same length");
            }
            this.xp = xPoints;
            this.yp = yPoints;
            this.initVars = init;
        }

        @Override
        public double evaluate(final double[] coeffs,
            final double[] outputGradient, int nCoeffs, double step) {
        
            final double[] diff = new double[yp.length];
            
            final double sumDiff = polynomialCoeffGradient(xp, yp, coeffs, 
                outputGradient, diff);
         
            // TODO: revisit this to consider including errors given
            //   to the code for each point.
            
            double[] mnAndStDv = MiscMath.getAvgAndStDev(diff);
            double sigma = mnAndStDv[1] * mnAndStDv[1];
            
            double f = Math.pow((1.0/(2.0*Math.PI*sigma)), (coeffs.length/2))
                * Math.exp(-1. * sumDiff/(2. * sigma));
    
            double lnf = -2. * Math.log(f);
            
            //System.out.println(" lnf=" + lnf);
         
            return lnf;
        }
    }
 
    /**
     * calculate the gradient of the polynomial coefficients and return the
     * square root of the sum of the squared differences between data (xp, yp)
     * and the generated polynomial while populating the difference array
     * of y in the generated model and data yp.
     * 
     * @param xp
     * @param yp
     * @param coeffs
     * @param outputCoeffGrad
     * @param outputDiffY
     * @return 
     */
    public static double polynomialCoeffGradient(final double[] xp, 
        final double[] yp, final double[] coeffs, 
        final double[] outputCoeffGrad, final double[] outputDiffY) {
        
        double[] y = new double[xp.length];

        Arrays.fill(outputCoeffGrad, 0.);

        /*
        calculating the gradient of the polynomial coefficients

        example function generated by 3 coefficients:
           gen = c0 * x^2 + c1 * x^1 + c2

           d(gen)/d(c0) = x^2
           d(gen)/d(c1) = x^1
           d(gen)/d(c2) = 1

           d(c0)= d(gen)/x^2
           d(c1)= d(gen)/x
           d(c2)= d(gen)

           gen = c0 * x^2 + c1 * x^1 + c2
           d(gen)/d(x) = 2 * c0 * x + c1
           d(gen) = d(x) * (2 * c0 * x + c1)

           d(c0)= d(gen)/x^2
                = d(x) * (2 * c0 * x + c1) / x^2
           d(c1)= d(gen)/x
                = d(x) * (2 * c0 * x + c1) / x
           d(c2)= d(gen)/x
                = d(x) * (2 * c0 * x + c1)
        */

        double[] gen = Misc.generate(coeffs, xp);

        MatrixUtil.subtract(gen, yp, outputDiffY);

        double sumDiff = 0;

        for (int i = 0; i < xp.length; ++i) {
            double x2 = 1;
            double dx = outputDiffY[i];
            double d = dPolydX(coeffs, xp[i]);
            for (int j = coeffs.length - 1; j > -1; j--) {
                int varIdx = coeffs.length - j - 1;
                outputCoeffGrad[varIdx] += (dx * d / x2);                      
                x2 *= xp[i];
                if (x2 == 0.0) {
                    break;
                }
            }
            sumDiff += (dx * dx);
        }
        sumDiff = Math.sqrt(sumDiff);

        for (int j = 0; j < coeffs.length; ++j) {
            outputCoeffGrad[j] /= xp.length;
        }

        /*
        System.out.println("==>vars=" + Arrays.toString(vars));
        System.out.println("==>diff=" + Arrays.toString(diff));
        System.out.println("==>sumDiff=" + sumDiff);
        System.out.println("==>gradient=" + Arrays.toString(outputGradient));
        */

        return sumDiff;
    }
    
    /**
     * assuming that the polynomial coefficients coeff are given from
     * highest order to lowest, return the derivative of y with
     * respect to x.
     * e.g. for y = coeff[0] * x^2 + coeff[1] * x^1 + coeff[2]
     * it returns dydx = 2 * coeff[0] * x + coeff[1]
     * @param coeff
     * @param x
     * @return 
     */
    public static double dPolydX(double[] coeff, double x) {
        /*
        y = c0 * x^2 + c1 * x^1 + c2
        */
        double sum = 0;
        for (int order = (coeff.length - 1); order > 0; --order) {
            sum += dPolydX(order, coeff[order], x);
        }
        
        return sum;
    }
    
    private static double dPolydX(int order, double coeff, double x) {
        
        if (order == 0) {
            return 0;
        }
        
        double dydx = coeff * (double)order * Math.pow(x, order - 1);
        
        return dydx;
    }
}

{"name":"two-point-correlation","tagline":"Unsupervised Clustering Based Upon Voids in Two-Point Correlation","body":"<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot.001.png\" width=\"250\" height=\"250\"/> <img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot.002.png\" width=\"250\" height=\"250\"/> <img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot.004.png\" width=\"250\" height=\"250\"/>\r\n\r\nThe code is a <b>density based clustering algorithm</b>. The algorithm does not require prior knowledge of the number of clusters, nor does it require a separation distance for association of points, and the algorithm finds non-convex cluster shapes in a statistically based manner that is reproducable. The algorithm learns the association separation distance of points by the statistics of the data itself and applies that in a critical threshold for membership of points within a cluster.\r\n\r\nThe algorithm, in an unsupervised manner, constructs histograms of rectangular voids in the data and fits Generalized Extreme Value curves to the histograms to learn the background density. Clusters in the data are found as points that are within a separation distance smaller than the critical density for membership.\r\n\r\nThe results are available as data and visualized through generated html plots. (Improvements to packaging and documentation are in progress.)\r\n\r\nMore about the density distribution:\r\n\r\nThe location of the 'background' points in two dimensional space are likely Poisson, that is their locations in a fixed interval of space are independent of one another and occur randomly. The 2-point void densities are formed into a histogram that is well fit by Generalized Extreme Value (GEV) curves. Extreme value distributions are used to describe the maximum or minimum of values drawn from a sample distribution that is essentially exponential.\r\n\r\nThere are 2 methods for determining clusters in this code:\r\n\r\n  * (1) For datasets in which there are background points:\r\n  The peak of the GEV fit should represent the background density.  The clusters are then\r\n  defined statistically as being 2 to 3 times 'above the background', that is having\r\n  separations 2 to 3 times more dense than the background density. The code by default \r\n  uses a factor of 2.5, but methods are supplied to allow the user to set the background \r\n  to 2 or 3 instead, and there's also a method to set the background manually.  \r\n  The later manual setting is useful for a case where perhaps one determined the 1. 1. * * * ````\r\n  background density in one dataset and need to apply that to a 2nd dataset which \r\n  has the same background, but is 'saturated' with foreground points.  \r\n  \r\n  * (2) For datasets in which there are no background points:\r\n  Datasets which are only points which should be in groups, and essentially have no\r\n  background points are referred to as sparse background datasets.\r\n  For these datasets, the background density is zero, so we define the level above\r\n  the background by the edges of the densities of the group.  This edge density\r\n  is already  much larger than the background so it is the threshold density for\r\n  membership already.  This threshold density is the first x bin in a well formed\r\n  histogram of 2-point densities.\r\n\r\nThe code automatically determines which of method (1) and (2) to use.\r\n  \r\nIf the user has better knowledge of which should be applied, can set that with:\r\n>     useFindMethodForDataWithoutBackgroundPoints() \r\n>     or useFindMethodForDataWithBackgroundPoints()\r\n\r\nThe GEV curve contains 3 independent fitting parameters and the curve is an exponential combined with a polynomial, so it's resulting fitted parameters are not unique, but the curve is useful for characterizing the background point distribution by then integrating under the curve.\r\n \r\nThe points within a cluster are may have interesting distributions that can be better modeled after they've\r\nbeen found by these means.\r\n\r\nUsage as an API:\r\n>\r\n>To use the code with default settings:\r\n>  \r\n>       TwoPointCorrelation clusterFinder \r\n>            = new TwoPointCorrelation(x, y, xErrors, yErrors, totalNumberOfPoints);\r\n>  \r\n>       clusterFinder.calculateBackground();\r\n>       \r\n>       clusterFinder.findClusters();\r\n>  \r\n>  The results are available as group points or as convex hulls surrounding the groups:\r\n>\r\n>      int n = clusterFinder.getNumberOfGroups()\r\n>      \r\n>      int groupNumber = 0;\r\n>\r\n>      To get the hull for groupId 0:\r\n>          ArrayPair hull0 = clusterFinder.getGroupHull(groupNumber);\r\n>\r\n>      To get the points in groupId 0:\r\n>          ArrayPair group0 = clusterFinder.getGroup(groupNumber)\r\n>      \r\n>      To plot the results:\r\n>          String plotFilePath = clusterFinder.plotClusters();\r\n>\r\n> If debugging is turned on, plots are generated and those file paths are printed to standard out, and statements are printed to standard out.\r\n \r\n>  To set the background density manually:\r\n>\r\n>      TwoPointCorrelation clusterFinder \r\n>          = new TwoPointCorrelation(x, y, xErrors, yErrors, >getTotalNumberOfPoints());\r\n>      clusterFinder.setBackground(0.03f, 0.003f);\r\n>      clusterFinder.findClusters();\r\n>      String plotFilePath = clusterFinder.plotClusters();\r\n>\r\n\r\nIf the centers of the cluster hulls are needed for something else, seeds for a Voronoi diagram, for instance,\r\none can use:\r\n>\r\n>    ArrayPair seeds = clusterFinder.getHullCentroids();\r\n>\r\n\r\nThe scatter plots and histograms below use [d3 js](http://d3js.org)\r\n\r\n_*Note that improvements in the histogram code is *in progress*.  Currently datasets with a small number of points may have less than ideal solutions.*_\r\n\r\nNote also that the code has the ability to refine a solution:  that is to determine groups and then subtract them from the data and then re-determine the background density from the remaining points.  The ability is not enabled by default, but can be with the method setAllowRefinement().\r\nMore information is [here](https://github.com/nking/two-point-correlation/raw/master/docs/clustering_and_refinement.pdf).\r\n\r\n***\r\n\r\n>The citation for use of this code in a publication is:\r\n>\r\n>    `http://code.google.com/p/two-point-correlation/`, Nichole King,  \"Unsupervised Clustering Based Upon Voids in Two-Point Correlation\". March 15, 2013. <date accessed>\r\n\r\nNote that I wrote the core algorithm in this work (without the automated density calculation) several years ago and the results were part of a publication.\r\nWhat got published was the results from this algorithm used as input for another algorithm that requires \r\nknowledge of association radius in order to work.   The algorithm that used my algorithm's input required a parameter that was not derivable from it's use alone.\r\nSimilarly, \"k-means clustering\" requires knowledge of the number of clusters before use.  \"k-means++\" is an algorithm that suggests one can adjust the number of clusters k, but a statistical method of doing so would still require a density based analysis, and hence, it would need to do the same work as the algorithm here, but presumably less efficiently.  Delaunay Triangulation is useful if there are no background points within a dataset, that is all points will be members of a group, and if groups do not have non-convex shapes.  KDTrees are useful as a nearest neighbor algorithm, but its use in determining clusters would still require as input, an association radius.\r\nFun stuff, but the core of the algorithm here is was what I needed to create awhile back for work applied to surveys.  The addition published here is automation of the background determination and large improvements of the\r\noverall algorithm. \r\n\r\n***\r\n## Sparsely Populated Background\r\n\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/sparse.001.png\"/>\r\n\r\n***\r\n## Moderately Populated Background\r\n\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/moderate.002.png\"/>\r\n\r\n***\r\n## More Densely Populated Background\r\n\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/dense.001.png\"/>\r\n\r\n***\r\n## All Background, No Clusters\r\n\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/nobackground.001.png\"/>\r\n\r\n***\r\n## Non-Convex Morphology Clusters\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/wikipedia_dbscan.png\"/>\r\n\r\nThe cluster \"shape\" datasets collected at [http://cs.joensuu.fi/sipu/datasets/](http://cs.joensuu.fi/sipu/datasets/) are fit here with explanations of code settings used and comments about the data.\r\n\r\nThese clusters were found with the default algorithm settings.  No additional settings were needed for the background:\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_01.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_02.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_03.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_04.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_05.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_06.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_07.png\"/>\r\n\r\nThese clusters were found with the default algorithm settings plus using\r\nthe method useFindMethodForDataWithoutBackgroundPoints();\r\n\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_08.png\"/>\r\n\r\nThese clusters were found with the default algorithm settings plus using the method useFindMethodForDataWithoutBackgroundPoints();\r\nNote that these next 3 datasets have the uncommon property of being composed of isolated pairs of points, that is, there are never 3 or more points within the pair point separation of one another.  If one wanted to apply a slightly agglomerative approach to finding clusters in those datasets, one could use the found cluster centers in a new histogram and determine the critical density from those.  That isn't done in this algorithm in order to keep a uniform way of determining clusters in a statistically reproducable manner.\r\n\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_09.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_10.png\"/>\r\n<img src=\"https://github.com/nking/two-point-correlation/raw/master/docs/snapshot_shapes_11.png\"/>\r\n\r\n***\r\n\r\n## Performance Metrics\r\n\r\n>\r\n>Roughly determined by estimation and measured with a very small number of iterations on a computer with characteristics:\r\n>   64-bit Intel Core 2 Duo processor w/ speed 2 GHz w/ 4 MB L2 Cache\r\n>   3GB RAM and a bus speed of 800 MHz\r\n>\r\n>JVM characteristics:\r\n>    J2SE 1.6, 64-bit HotSpot server w/ initial heap size 512 MB and max heap size 1024 MB.\r\n>\r\n>Measurements are from the June 29, 2014 code (e35ea01990b54cc8e88b76e9ce30220a35cdb79d).\r\n>\r\n\r\nRuntime (RT) complexity for findVoids() is less than O(N^2) but it invokes functions that vary from O(1) to O(N-1) as \r\nit compares the range between points, so best is less than O(N^2) and worse is less than O(N^3).\r\nRT complexity for findGroups() is a little worse than O(N^2).\r\nThe RT complexity for findGroups is a DFS search over sorted x so is < O(N^2) due to being\r\nable to truncate the search over potential neighbors.  \r\n\r\n(NOTE that improvements in findGroups is in progress.  The total RT should be smaller\r\nafterwards by using memoization w/ Fibonacci Heaps in the findVoids stage to limit the neighbor search in findGroups's DFS.)\r\n\r\nEmpirically derived runtimes follow.\r\n\r\n>       N          findVoids        findGroups     Sys load  Total RT\r\n>     points      RT      mem       RT      mem     at start\r\n>              in sec   in MB     in sec  in MB               in sec\r\n>\r\n>        99      0       0.2        0      0.2      0.7        0     \r\n>                                                                \r\n>      1089      1       20         0      20       0.7        1 \r\n>                                                    \r\n>      10605     4                  1                          5 \r\n>                                                              \r\n>     101400    29       14        226     21       1          255\r\n>\r\n\r\n*Note that for the datasets with number of points > 15000, the void density is determined through partial sampling rather than complete sampling, so there may be a need occasionally to  override the automatic decision for sampling in the code.  Methods are provided to override defaults.*","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
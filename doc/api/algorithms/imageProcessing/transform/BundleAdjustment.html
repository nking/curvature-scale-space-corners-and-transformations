<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Fri Sep 13 18:45:45 PDT 2024 -->
<title>BundleAdjustment</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-09-13">
<meta name="description" content="declaration: package: algorithms.imageProcessing.transform, class: BundleAdjustment">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h1 title="Class BundleAdjustment" class="title">Class BundleAdjustment</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.imageProcessing.transform.BundleAdjustment</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">BundleAdjustment</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">given intrinsic and extrinsic camera parameters, coordinates for points
 in a world reference frame, and observations of those points in one or more
 camera, return data structures needed by Levenberg-Marquardt algorithm
 in refinement of the intrinsic and extrinsic camera parameters.
 BundleAdjustment calculates partial derivatives of the parameters
 and calculates the re-projection error to form the parameter update steps,
 the gradient covector, and the evaluation of the objective (minimize sum of squares of
 the re-projection error).

 The main method is solveSparsely(...).
 
 From Triggs et al. 2000, "Bundle Adjustment - A Modern Synthesis"
 "Bundle adjustment is the problem of refining a visual reconstruction to 
 produce jointly optimal 3D structure and viewing parameter (camera pose and/or 
 calibration) estimates. Optimal means that the parameter estimates are found 
 by minimizing some cost function that quantifies the model fitting error, and 
 jointly that the solution is simultaneously optimal with respect to both 
 structure and camera variations. The name refers to the ‘bundles’ of light 
 rays leaving each 3D feature and converging on each camera centre, which are 
 ‘adjusted’ optimally with respect to both feature and camera positions. 
 Equivalently — unlike independent model methods, which merge partial 
 reconstructions without up-dating their internal structure — all of the
 structure and camera parameters are adjusted together ‘in one bundle’."
 
 This version of Bundle-Adjustment uses Levenberg-Marquardt Algorithm (LMA) 
 step in each iteration solved by dense Cholesky decomposition (LMA-CD).
 
 TODO: consider implementing or finding an implementation of 
 Jakob Engel, Vladlen Koltun, and Daniel Cremers. 
 "Direct sparse odometry". 
 IEEE transactions on pattern analysis and machine intelligence, 
 40(3):611–625, 2018.

 TODO:  add gauge fix.  The gauge is the coordinate system a.k.a. datum
 in photogrammetry. (see Bartoli "Towards Gauge Invariant Bundle Adjustment:..."
 And related to that, consider adding constraints
 suggested in Seliski 2010: u_0 and v_0 are close to half the image lengths 
 and widths, respectively.  the angle between 2 image axes is close to 90.
  the focal lengths along both axes are greater than 0.     
 
 TODO: consider implementing the "reduced structure system" for the cases
 where (9^3)*mImages > (3^3)*nFeatures,  The "reduced camera system" is
 currently implemented only, but "reduced structure system"
 for some cases would be more efficient.
 
 <pre>
 for a bigger picture summary, see Section 
 "Objective functions for estimating epipolar geometry" on page 169 of
  MASKS (Ma, Soatto, Kosecká, and Sastry 2012, 
 "An Invitation to 3-D Vision").
 Also see Chap 5.2, pp 127-128 of MASKS for constrained optimization.
 </pre>
 <pre>
 Note, if need to estimate the intrinsic camera for initial conditions, one can generally
 start with:
 MASKS Algorithm 11.6, step 1:
 Guess a calibration matrix K by choosing the optical center at the center of the image,
 assuming the pixels to be square, and guessing the focal length f. For example, for
 an image plane of size (Dx X Dy) pixels, a typical guess is
     | f O Dx/2
 K = | 0 f Dy/2
     | 0 0 1
 with f = k X Dx, where k is typically chosen in the interval [0.5, 2].
 </pre></div>
<dl class="notes">
<dt>Author:</dt>
<dd>nichole</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>(package private) static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="BundleAdjustment.AuxiliaryArrays.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">BundleAdjustment.AuxiliaryArrays</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">BundleAdjustment</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#aIJBIJ(double%5B%5D,double%5B%5D,double%5B%5D%5B%5D,double,double,double%5B%5D,double%5B%5D%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.BundleAdjustment.AuxiliaryArrays,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">aIJBIJ</a><wbr>(double[]&nbsp;xWI,
 double[]&nbsp;xWCI,
 double[][]&nbsp;intr,
 double&nbsp;k1,
 double&nbsp;k2,
 double[]&nbsp;rotAngles,
 double[][]&nbsp;rot,
 double[]&nbsp;trans,
 <a href="BundleAdjustment.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">BundleAdjustment.AuxiliaryArrays</a>&nbsp;aa,
 double[][]&nbsp;outAIJ,
 double[][]&nbsp;outBIJ)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">NOTE: dFdPhi and dFdT include a partial derivative that is in the image reference frame.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>protected double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#calcReprojectionErrors(double%5B%5D%5B%5D,double%5B%5D%5B%5D,algorithms.matrix.BlockMatrixIsometric,double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean,boolean)" class="member-name-link">calcReprojectionErrors</a><wbr>(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 algorithms.matrix.BlockMatrixIsometric&nbsp;intr,
 double[][]&nbsp;extrRVecs,
 double[][]&nbsp;extrTrans,
 double[][]&nbsp;kRadials,
 boolean&nbsp;useR2R4,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>protected void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#calculateLMVectorsSparsely(double%5B%5D%5B%5D,double%5B%5D%5B%5D,gnu.trove.map.TIntObjectMap,algorithms.matrix.BlockMatrixIsometric,double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean,double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,double,double%5B%5D,boolean)" class="member-name-link">calculateLMVectorsSparsely</a><wbr>(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;imageFeaturesMap,
 algorithms.matrix.BlockMatrixIsometric&nbsp;intr,
 double[][]&nbsp;extrRVecs,
 double[][]&nbsp;extrTrans,
 double[][]&nbsp;kRadials,
 boolean&nbsp;useR2R4,
 double[]&nbsp;outDP,
 double[]&nbsp;outDC,
 double[]&nbsp;outGradP,
 double[]&nbsp;outGradC,
 double[]&nbsp;outFSqSum,
 double&nbsp;lambda,
 double[]&nbsp;outInitLambda,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">solve for bundle adjustment data structures needed by the Levenberg-Marquardt
 algorithm to refine the intrinsic and extrinsic camera parameters.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#pdCIJXWIJ(double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pdCIJXWIJ</a><wbr>(double[]&nbsp;xWCI,
 double[][]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">the partial derivative of the 2D coordinates of perspective projection 
 of the i-th feature point normalized, w.r.t.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#pdCpIJCIJ(double%5B%5D,double%5B%5D%5B%5D,double,double,double%5B%5D%5B%5D)" class="member-name-link">pdCpIJCIJ</a><wbr>(double[]&nbsp;xWCNI,
 double[][]&nbsp;intr,
 double&nbsp;k1,
 double&nbsp;k2,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">the partial derivative of the
 final 2D re-projected coordinates of the i-th feature point
 w.r.t.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#pdCpIJYJ(double%5B%5D,double%5B%5D%5B%5D,double,double,double%5B%5D%5B%5D)" class="member-name-link">pdCpIJYJ</a><wbr>(double[]&nbsp;xWCNI,
 double[][]&nbsp;intr,
 double&nbsp;k1,
 double&nbsp;k2,
 double[][]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">the partial derivative of the
 final 2D re-projected coordinates of the i-th feature point
 w.r.t.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#pdXWIJPhiJ(double%5B%5D,double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">pdXWIJPhiJ</a><wbr>(double[]&nbsp;xWI,
 double[]&nbsp;phi,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">the partial derivative of the
 final 2D re-projected coordinates of the i-th feature point
 w.r.t.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#populateCameraProjectionHomography(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">populateCameraProjectionHomography</a><wbr>(double[][]&nbsp;rot,
 double[]&nbsp;translation,
 double[][]&nbsp;outH)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">populate the homography matrix to transform world screen coordinates
 to projected 2D coordinates in the camera reference frame.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#populateCameraProjectionHomography(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,boolean)" class="member-name-link">populateCameraProjectionHomography</a><wbr>(double[][]&nbsp;rot,
 double[]&nbsp;translation,
 double[]&nbsp;outH,
 boolean&nbsp;useLeftHanded)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">populate the homography matrix to transform world screen coordinates
 to projected 2D coordinates in the camera reference frame.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setUseHomography()" class="member-name-link">setUseHomography</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">setting to use the homography matrix in the WCS projection to camera
 2-D reference frame.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#solveSparsely(double%5B%5D%5B%5D,double%5B%5D%5B%5D,gnu.trove.map.TIntObjectMap,algorithms.matrix.BlockMatrixIsometric,double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D,int,boolean,boolean)" class="member-name-link">solveSparsely</a><wbr>(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;imageFeaturesMap,
 algorithms.matrix.BlockMatrixIsometric&nbsp;intr,
 double[][]&nbsp;extrRVecs,
 double[][]&nbsp;extrTrans,
 double[][]&nbsp;kRadials,
 int&nbsp;nMaxIter,
 boolean&nbsp;useR2R4,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">NOTE: this method could use improvements and more testing.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>BundleAdjustment</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">BundleAdjustment</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="setUseHomography()">
<h3>setUseHomography</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">setUseHomography</span>()</div>
<div class="block">setting to use the homography matrix in the WCS projection to camera
 2-D reference frame.   The homography matrix is the first 2 columns of
 the rotation matrix and the translation vector as the 3rd column
 in the homography.  
 The default uses, instead, the full projection
 of Rotation * x_WCS + translation.
 Note that the partial derivatives calculated in making
 the Jacobian are derived from the full projection, not the homography,
 so there will be inconsistencies until that is fixed for the homography
 derivatives.</div>
</section>
</li>
<li>
<section class="detail" id="solveSparsely(double[][],double[][],gnu.trove.map.TIntObjectMap,algorithms.matrix.BlockMatrixIsometric,double[][],double[][],double[][],int,boolean,boolean)">
<h3>solveSparsely</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">solveSparsely</span><wbr><span class="parameters">(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;imageFeaturesMap,
 algorithms.matrix.BlockMatrixIsometric&nbsp;intr,
 double[][]&nbsp;extrRVecs,
 double[][]&nbsp;extrTrans,
 double[][]&nbsp;kRadials,
 int&nbsp;nMaxIter,
 boolean&nbsp;useR2R4,
 boolean&nbsp;useBouguetForRodrigues)</span>
                   throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">NOTE: this method could use improvements and more testing.

 given world scene features, the features observed in images,
 initial camera calibration and extrinsic parameters, use the 
 iterative non-linear Levenberg-Marquardt (L-M)
 algorithm to minimize the re-projection error by refining the values of
 coordsW, intrinsic, and extrinsic camera parameters.
 
 The L-M is an iterative non-linear optimization to minimize the 
 objective.  For bundle adjustment, the objective is the 
 re-projection error.
 L-M is guaranteed to converge to eventually find an improvement, 
 because an update with a sufficiently small magnitude and a negative scalar 
 product with the gradient is guaranteed to do so.
 
 This method exploits some of the properties of sparse matrices in the 
 block structure of the Jacobian by using the Schur complement to form
 reduced camera matrices which can be solved by Cholesky factoring and
 forward and backward substitution (halving the computation time for the
 parameter vector).
 Regarding the bundle adjustment as refinement for extrinsic parameters:
        <pre>
            However, several researchers have noted (Fitzgibbon and 
            Zisserman, 1998, Nistér, 2001, Pollefeys, 1999) that in the 
            application of camera tracking, performing bundle adjustment each 
            time a new frame has been added to the estimation can prevent the 
            tracking process from failing over time. 
            Thus, bundle adjustment can over time in a sequential estimation 
            process have a much more dramatic impact than mere accuracy 
            improvement, since it improves the initialization for future 
            estimates, which can ultimately enable success in cases that would 
            otherwise miserably fail.
        </pre>
     <pre>
     References:
     
     http://users.ics.forth.gr/~lourakis/sba/PRCV_colloq.pdf
     lecture by Lourakis  “Bundle adjustment gone public”
     
     Zhongnan Qu's master thesis, "Efficient Optimization for Robust Bundle 
     Adjustment", 2018 Technical University of Munich
     
     Chen, Chen, &amp; Wang 2019, "Bundle Adjustment Revisited"
     
     Engels, Stewenius, Nister 2006, “Bundle Adjustment Rules”
      
     Bill Triggs, Philip Mclauchlan, Richard Hartley, Andrew Fitzgibbon. 
     Bundle Adjustment – A Modern Synthesis. 
     International Workshop on Vision Algorithms, 
     Sep 2000, Corfu, Greece. pp.298–372, 
     10.1007/3-540-44480-7_21 . inria-00548290 

     T. Barfoot, et al., "Pose estimation using linearized rotations and 
     quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
         -- using the rotation and translation update details.
         -- one of the 2 examples is interesting for the problem of pose for
            a pair of stereo-images.  it also uses cholesky factoring of block
            sparse matrix structure.
           
     Tomasi 2007,CPS 296.1 Supplementary Lecture Notes, Duke University
     
     graph partitioning:
        https://cseweb.ucsd.edu/classes/fa04/cse252c/manmohan1.pdf
        recursive partitioning w/ elimination graph and vertex cut.
        
        Triggs et al. 2000, "Bundle Adjustment – A Modern Synthesis", Section 6
        
        Skeletal graphs for efficient structure from motion
        N Snavely, SM Seitz, R Szeliski - 2008
 
     Graph partitioning in this project:
        NormalizedCuts.java which uses the Fiedler vector of the Laplacian.
        UnweightedGraphCommunityFinder.java
        
     </pre>
     TODO: review and improve the derivatives.  need good test data.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsI</code> - the features observed in different images (in coordinates
 of the image reference frame).
 The format of coordsI is 3 X (nFeatures*nImages). Each row should
 have nFeatures of one image, followed by nFeatures of the next image,
       etc.  The first dimension is for the x,y, and z axes.
       Note that if a feature is not present in the image, that should be
       an entry in imageMissingFeatureMap.</dd>
<dd><code>coordsW</code> - the features in a world coordinate system.  The format is
 3 X nFeatures.  The first dimension is for the x,y, and z axes.</dd>
<dd><code>imageFeaturesMap</code> - an associative array holding the features
 in each image.  They key is the image number in coordsI
 which is j/nFeatures where j is the index of the 2nd dimension,
 that is coordsI[j].  The value is a set of feature numbers which are
 missing from the image.  The feature numbers correspond to the
 2nd dimension indexes in coordsW.</dd>
<dd><code>intr</code> - the intrinsic camera parameter matrices stacked along rows
 to make a tall double array of size [(mImages*3) X 3] where each image block is
 size 3X3.  Note that only the focus parameter is refined in this method.</dd>
<dd><code>extrRVecs</code> - the extrinsic camera parameter (Rodrigues) rotation vectors
 stacked along the 3 columns, that is the size is [mImages X 3].
 each image block is size 1X3.</dd>
<dd><code>extrTrans</code> - the extrinsic camera parameter translation vectors
 stacked along the 3 columns, that is the size is [nImages X 3] where
 nImages is coordsI[0].length/coordsW[0].length.  each array is size
 1X3.</dd>
<dd><code>kRadials</code> - a double array wherein each row holds the
 radial distortion coefficients k1 and k2 for an image.
 NOTE: current implementation accepts values of 0 for k1 and k2.</dd>
<dd><code>nMaxIter</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dd><code>useR2R4</code> - useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4 if true,
        else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calcReprojectionErrors(double[][],double[][],algorithms.matrix.BlockMatrixIsometric,double[][],double[][],double[][],boolean,boolean)">
<h3>calcReprojectionErrors</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">calcReprojectionErrors</span><wbr><span class="parameters">(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 algorithms.matrix.BlockMatrixIsometric&nbsp;intr,
 double[][]&nbsp;extrRVecs,
 double[][]&nbsp;extrTrans,
 double[][]&nbsp;kRadials,
 boolean&nbsp;useR2R4,
 boolean&nbsp;useBouguetForRodrigues)</span>
                                 throws <span class="exceptions"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a>,
no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsI</code> - </dd>
<dd><code>coordsW</code> - </dd>
<dd><code>intr</code> - </dd>
<dd><code>extrRVecs</code> - </dd>
<dd><code>extrTrans</code> - </dd>
<dd><code>kRadials</code> - </dd>
<dd><code>useR2R4</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateLMVectorsSparsely(double[][],double[][],gnu.trove.map.TIntObjectMap,algorithms.matrix.BlockMatrixIsometric,double[][],double[][],double[][],boolean,double[],double[],double[],double[],double[],double,double[],boolean)">
<h3>calculateLMVectorsSparsely</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">calculateLMVectorsSparsely</span><wbr><span class="parameters">(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 gnu.trove.map.TIntObjectMap&lt;gnu.trove.set.TIntSet&gt;&nbsp;imageFeaturesMap,
 algorithms.matrix.BlockMatrixIsometric&nbsp;intr,
 double[][]&nbsp;extrRVecs,
 double[][]&nbsp;extrTrans,
 double[][]&nbsp;kRadials,
 boolean&nbsp;useR2R4,
 double[]&nbsp;outDP,
 double[]&nbsp;outDC,
 double[]&nbsp;outGradP,
 double[]&nbsp;outGradC,
 double[]&nbsp;outFSqSum,
 double&nbsp;lambda,
 double[]&nbsp;outInitLambda,
 boolean&nbsp;useBouguetForRodrigues)</span>
                                   throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a>,
<a href="NaNException.html" title="class in algorithms.imageProcessing.transform">NaNException</a></span></div>
<div class="block">solve for bundle adjustment data structures needed by the Levenberg-Marquardt
 algorithm to refine the intrinsic and extrinsic camera parameters.
 The algorithms uses the sparse structure of the jacobian to reduce
 the computation time and memory needed.
 The code needs initial parameter estimates of intrinsic and extrinsic
 camera parameters (in intr, extrRot, kRadial, and extrTrans).
     The code returns results in outGradP, outGradC,
     outFSqSum, outDP, outDC for refined parameters
     and the gradient, objective and parameter update steps needed by
     code such as Levenberg-Marquardt.
     NOTE: the code does not update the intrinsic and extrinsic camera parameters, allowing
     the L-M algorithm to handle that.
     The runtime complexity is ~ O(nFeatures * mImages^2).
     Assumptions used in forming the partial derivatives of the intrinsic camera parameters
     are no skew, focal length along x is the same as focal length along y, square pixels.
     Cholesky decomposition is used with forward and back substitution
     to avoid inverting the reduced camera matrix
     and to half the runtime compared to L-U decomposition.
     Note that there can be more than one camera and should be 6 of more features per image
     (3 for rot, 3 for trans) and among those, need 3 per camera for the intrinsic parameters
     and 2 or more vantage points for the point parameters (no reference for these
     numbers, just a rough estimate from counting the number of unknowns).

     Also note that the code uses the Jacobian J = [J_P J_C] following
     Engels et al., which is reversed from the Lourakis Jacobian J = [J_c J_P].
     Qu Jacobian (and hence reduced camera matrix are consistent with Lourakis.
     See details in doc/bundle_adjustment.pdf
     <pre>
     References:

     additional information is present in directory doc as "bundle_adjustment.pdf"
     and "Levenberg-Marquardt_notes.pdf"

 http://users.ics.forth.gr/~lourakis/sba/PRCV_colloq.pdf
     lecture by Lourakis  “Bundle adjustment gone public”

     Engels, Stewenius, Nister 2006, “Bundle Adjustment Rules”

     Bill Triggs, Philip Mclauchlan, Richard Hartley, Andrew Fitzgibbon.
     Bundle Adjustment – A Modern Synthesis.
     International Workshop on Vision Algorithms,
     Sep 2000, Corfu, Greece. pp.298–372,
     10.1007/3-540-44480-7_21 . inria-00548290

     Zhongnan Qu's master thesis, "Efficient Optimization for Robust Bundle
     Adjustment", 2018 Technical University of Munich

     Chen, Chen, &amp; Wang 2019, "Bundle Adjustment Revisited"

     T. Barfoot, et al., "Pose estimation using linearized rotations and
     quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
     -- using the rotation and translation update details.
     -- one of the 2 examples is interesting for the problem of pose for
     a pair of stereo-images.  it also uses cholesky factoring of block
     sparse matrix structure.

     The partial derivatives are from Bouguet's Camera Calibration Toolbox.
     The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     and states that the source code is freely available.
     The github repositories with forked Bouguet Matlab code do not have license
     information.  Those references are
     https://github.com/fragofer/TOOLBOX_calib
     and
     https://github.com/hunt0r/Bouguet_cam_cal_toolbox
     and the code adapted from is compute_extrinsic_refine.m which depends upon other code from the toolbox.
     </pre>
     TODO: review and improve the derivatives here.  e.g. re-do porting of the Qu derivs...</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsI</code> - the features observed in different images (in coordinates
 of the image reference frame).  The different images may or may not be from the same camera.
 The format of coordsI is 3 X (nFeatures*nImages). Each row should
 have nFeatures of one image, followed by nFeatures of the next image,
    etc.  The first dimension is for the x,y, and z axes.
    Note that if a feature is not present in the image, that should be
    an entry in imageMissingFeatureMap.</dd>
<dd><code>coordsW</code> - the features in a world coordinate system.  The format is
 3 X nFeatures.  The first dimension is for the x,y, and z axes.</dd>
<dd><code>imageFeaturesMap</code> - an associative array holding the features
 present in each image.  They key is the image number in coordsI
 which is j/nFeatures where j is the index of the 2nd dimension,
 that is coordsI[j].  The value is a set of feature numbers which are
 missing from the image.  The feature numbers correspond to the
 2nd dimension indexes in coordsW.</dd>
<dd><code>intr</code> - the intrinsic camera parameter matrices stacked along rows
 to make a tall double array of size [(mImages*3) X 3] where each block is
 size 3X3.   Note that only the focus parameter is refined in this class.</dd>
<dd><code>extrRVecs</code> - the extrinsic camera parameter rotation euler angles
 stacked along the 3 columns, that is the size is nImages X 3 where
 nImages is coordsI[0].length/coordsW[0].length.  each array is size
 1X3.</dd>
<dd><code>extrTrans</code> - the extrinsic camera parameter translation vectors
 stacked along the 3 columns, that is the size is nImages X 3 where
 nImages is coordsI[0].length/coordsW[0].length.  each array is size
 1X3.</dd>
<dd><code>kRadials</code> - a double array wherein each row holds the
 radial distortion coefficients k1 and k2 for an image, so the total size is [nCameras X 2].
 NOTE: current implementation accepts values of 0 for k1 and k2.</dd>
<dd><code>useR2R4</code> - useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
    f(r) = 1 +k1*r^2 + k2*r^4 if true,
    else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dd><code>outDP</code> - an output array holding the update values for the point parameters.
 The length should be 3*nFeatures.</dd>
<dd><code>outDC</code> - an output array holding the update values for the camera parameters.
 The length should be 9*mImages.</dd>
<dd><code>outGradP</code> - an output array holding the gradient covector for point parameters
  (-J_P^T*(x-x_hat) as the summation of bij^T*fij).  The length should be 3 * number of features.
 This is used by the L-M algorithm to calculate the gain ratio and evaluate stopping criteria.</dd>
<dd><code>outGradC</code> - an output array holding the gradient covector for camera parameters
 (-J_C^T*(x-x_hat) as the summation of aij^T*fij).
 The length should be 9 times the number of images.
 This is used by the L-M algorithm to calculate the gain ratio and evaluate stopping criteria.</dd>
<dd><code>outFSqSum</code> - an output array holding the evaluation of the objective,
 that is the sum of squares of the observed feature - projected feature.
 It's the re-projection error.  NOTE that this evaluation is for the
 given parameters, not the given parameters plus the returned update steps
 (outDC and outDP).
 The length should be 1.</dd>
<dd><code>lambda</code> - the damping parameter.  upon first use, this is 0 and
 outInitLambda is not null so that the sparse Hessian is calculated without
 the damping term and is used to find the initial value of
 lambda which it places in outInitLambda.  upon all subsequent uses of
 this method, it's expected that lambda > 0 and outInitLambda is null.</dd>
<dd><code>outInitLambda</code> - when not null this is the output parameter holding
 the maximum of the diagonal of j^T*J.  the array has length 1.</dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
<dd><code><a href="NaNException.html" title="class in algorithms.imageProcessing.transform">NaNException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pdCpIJCIJ(double[],double[][],double,double,double[][])">
<h3>pdCpIJCIJ</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">pdCpIJCIJ</span><wbr><span class="parameters">(double[]&nbsp;xWCNI,
 double[][]&nbsp;intr,
 double&nbsp;k1,
 double&nbsp;k2,
 double[][]&nbsp;out)</span></div>
<div class="block">the partial derivative of the
 final 2D re-projected coordinates of the i-th feature point
 w.r.t. 2D coordinates of perspective projection of the i-th feature point.
 Defined in Qu 2018 eqn (3.12).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xWCNI</code> - a world point projected to the camera reference frame and
 normalized by it's last coordinate.
 xWCI = column i of coordsW transformed to camera coordinates; 
 xWCNI = xWCI/xWCI[2];</dd>
<dd><code>intr</code> - </dd>
<dd><code>k1</code> - radial distortion coefficient 1</dd>
<dd><code>k2</code> - radial distortion coefficient 2</dd>
<dd><code>out</code> - output array of size [2X2]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pdCIJXWIJ(double[],double[][])">
<h3>pdCIJXWIJ</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">pdCIJXWIJ</span><wbr><span class="parameters">(double[]&nbsp;xWCI,
 double[][]&nbsp;out)</span></div>
<div class="block">the partial derivative of the 2D coordinates of perspective projection 
 of the i-th feature point normalized, w.r.t. to the same not normalized.
 Defined in Qu 2018 eqn (3.16).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xWCI</code> - a world point projected to the camera reference frame.
 xWCI = column i of coordsW transformed to camera coordinates;</dd>
<dd><code>out</code> - output array of size [2X3]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pdCpIJYJ(double[],double[][],double,double,double[][])">
<h3>pdCpIJYJ</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">pdCpIJYJ</span><wbr><span class="parameters">(double[]&nbsp;xWCNI,
 double[][]&nbsp;intr,
 double&nbsp;k1,
 double&nbsp;k2,
 double[][]&nbsp;out)</span></div>
<div class="block">the partial derivative of the
 final 2D re-projected coordinates of the i-th feature point
 w.r.t. the intrinsic camera parameters.
 Defined in Qu 2018 eqn (3.10).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xWCNI</code> - a world point projected to the camera reference frame and
 normalized by it's last coordinate.
 xWCI = column i of coordsW transformed to camera coordinates; 
 xWCNI = xWCI/xWCI[2];</dd>
<dd><code>intr</code> - </dd>
<dd><code>k1</code> - radial distortion coefficient 1</dd>
<dd><code>k2</code> - radial distortion coefficient 2</dd>
<dd><code>out</code> - output array of size [2X3]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pdXWIJPhiJ(double[],double[],double[][])">
<h3>pdXWIJPhiJ</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">pdXWIJPhiJ</span><wbr><span class="parameters">(double[]&nbsp;xWI,
 double[]&nbsp;phi,
 double[][]&nbsp;out)</span></div>
<div class="block">the partial derivative of the
 final 2D re-projected coordinates of the i-th feature point
 w.r.t. 2D coordinates of perspective projection of the i-th feature point.
 Defined in Qu 2018 eqns (3.28 - 3.33).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xWI</code> - the 3-D coordinates of a world scene feature.</dd>
<dd><code>phi</code> - rotation angle vector of length 3 in units of radians</dd>
<dd><code>out</code> - output array of size [3X3]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aIJBIJ(double[],double[],double[][],double,double,double[],double[][],double[],algorithms.imageProcessing.transform.BundleAdjustment.AuxiliaryArrays,double[][],double[][])">
<h3>aIJBIJ</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">aIJBIJ</span><wbr><span class="parameters">(double[]&nbsp;xWI,
 double[]&nbsp;xWCI,
 double[][]&nbsp;intr,
 double&nbsp;k1,
 double&nbsp;k2,
 double[]&nbsp;rotAngles,
 double[][]&nbsp;rot,
 double[]&nbsp;trans,
 <a href="BundleAdjustment.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">BundleAdjustment.AuxiliaryArrays</a>&nbsp;aa,
 double[][]&nbsp;outAIJ,
 double[][]&nbsp;outBIJ)</span></div>
<div class="block">NOTE: dFdPhi and dFdT include a partial derivative that is in the image reference frame.

 NOTE: there may be a problem if using the homography matrix [r0 r1 t] to
 transform world scene to camera coordinates as the partial derivatives here
 are assuming the use of the 3rd column of rotation too, that is R * T.
 
     for aIJ creates dF/dCameraParams which are the 9 parameters of 
     extrinsic and intrinsic,
     where the 9 parameters are the Qu notation for the variables phi_j, t_j, y_j.
     for each image = 9*nImages elements (j index is used for images).
     for bIJ creates dF/dPointParams which are the 3 parameters of the world point position.
     for each feature = 3 * mFeatures elements (i index is used for features)
 Defined in Lourakis lecture slide 10.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xWI</code> - a world scene feature.
 xWI = column i of coordsW</dd>
<dd><code>xWCI</code> - xWI projected to the camera reference frame.
 xWCI = column i of coordsW transformed to camera coordinates, but not normalize;</dd>
<dd><code>intr</code> - </dd>
<dd><code>k1</code> - radial distortion coefficient 1</dd>
<dd><code>k2</code> - radial distortion coefficient 2
 //@param rot extrinsic camera parameter rotation matrix.</dd>
<dd><code>rotAngles</code> - [1 X 3] array holding euler rotation angles.</dd>
<dd><code>rot</code> - [3 X 3] rotation matrix which was created with
 Rotation.createRotationZYX(rotAngles...);</dd>
<dd><code>trans</code> - extrinsic camera parameter translation vector.</dd>
<dd><code>aa</code> - a group of arrays passed in by invoking code, re-used to avoid
 constructing more objects.  AuxiliaryArrays aa = AuxiliaryArrays().</dd>
<dd><code>outAIJ</code> - output array of size [2X9]</dd>
<dd><code>outBIJ</code> - output array of size [2X3]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="populateCameraProjectionHomography(double[][],double[],double[][])">
<h3>populateCameraProjectionHomography</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">populateCameraProjectionHomography</span><wbr><span class="parameters">(double[][]&nbsp;rot,
 double[]&nbsp;translation,
 double[][]&nbsp;outH)</span></div>
<div class="block">populate the homography matrix to transform world screen coordinates
 to projected 2D coordinates in the camera reference frame.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rot</code> - </dd>
<dd><code>translation</code> - </dd>
<dd><code>outH</code> - </dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="populateCameraProjectionHomography(double[][],double[],double[],boolean)">
<h3>populateCameraProjectionHomography</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">populateCameraProjectionHomography</span><wbr><span class="parameters">(double[][]&nbsp;rot,
 double[]&nbsp;translation,
 double[]&nbsp;outH,
 boolean&nbsp;useLeftHanded)</span></div>
<div class="block">populate the homography matrix to transform world screen coordinates
 to projected 2D coordinates in the camera reference frame.
 method follows Wetzstein, eqn 19.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rot</code> - </dd>
<dd><code>translation</code> - </dd>
<dd><code>outH</code> - </dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Wed Nov 09 18:45:58 PST 2022 -->
<title>Rotation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-11-09">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Rotation";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h2 title="Class Rotation" class="title">Class Rotation</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.imageProcessing.transform.Rotation</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">Rotation</span>
extends java.lang.Object</pre>
<div class="block">a utility class holding rotations associated with euler angles,
 quaternions, and angle-axis representations (using rodrigues formula for the later).
 
 a rotation matrix describes a transformation in euclidean space.  it is a
 member of  special orthogonal group SO(n) where n is usually 3, but can
 be 4 for quaternion rotation matrix.  It has the properties R^T = R^−1 and det(R) = +-1.
 <pre>
   det(R)=1 is a proper rotation matrix.  rotation angles are counterclockwise.
       it's a special orthogonal matrix and provides the
       defining matrix representation of the group of proper n-dimensional rotations, denoted
       by SO(n). http://scipp.ucsc.edu/~haber/ph251/rotreflect_17.pdf
   det(R)=-1 is an improper rotation matrix representing rotations that
       require mirrors.
       The most general improper rotation matrix is a product of a proper rotation by an
       angle θ about some axis nˆ and a mirror reflection through a plane that passes through
       the origin and is perpendicular to nˆ.  NOTE: nˆ is determined by
       the right hand rule.
 </pre>
 This Rotation.java class uses "active" rotations of vectors counterclockwise in a right-handed 
 coordinate system (y counterclockwise from x) by pre-multiplication 
 (R on the left). If any one of these is changed (such as rotating axes 
 instead of vectors, a "passive" transformation), then the inverse of the
 example matrix should be used, which coincides with its transpose.
 e.g. (A*B*C)^-1 = (C^-1) * (B^-1) * (A^-1).
 
 from: "Tutorial: Consistent Representations of and Conversions Between 3D Rotations"
   by Rowenhorst, Rollett, Rohrer, Groeber, Jackson, Konijnenberg, and De Graef.
   Modelling Simulation Mater. Sci. Eng.
 A rotation can be viewed as operating on the object, which is the 
 active interpretation, or operating on the reference frame, which is the 
 passive interpretation. 
 An active rotation transforms object coordinates to new coordinates in the 
 same reference frame; for the passive interpretation, the initial and final 
 reference frames are different.
 
 
 <b><ul>RIGHT HAND SYSTEM</ul></b>
 The equations below use a right hand system.
 The right hand system is consistent with methods in physics, engineering,
 and computer science in general.  The <b>Hamilton quaternion</b> is consistent
 with the right hand system and has format [scalar vector].
 The NASA 1977 publication and Szeliski 2010
    define a quaternion as (qw, qx, qy, qz) where qw is a scalar and
 [qx, qy, qz] is a vector.   That is the Hamilton Quaternion format.
 
 In contrast, Barfoot et al. define a quaternion as (qx, qy, qz, qw).
 One might need to transform some properties to quaternions and then modify 
 the placement of the scalar term in order
 to compare results with other "Hamilton" "Right hand" system results.
         
 <pre>
 R(q) = | (w^2 + x^2 - y^2 - z^2)  2(xy - wz)               2(xz + wy)               |
        | 2(xy + wz)               w^2 - x^2 + y^2 - z^2)   2(yz - wx)               |
        | 2(xz - wy)               2(yz + wx)               (w^2 - x^2 - y^2  + z^2) |
 rewritten 
 R(q) = | 1-2*(y^2 + z^2)   2(xy - zw)       2(xz + yw)      |
        | 2(xy + zw)        1-2(x^2 + z^2)   2(yz - xw)      |
        | 2(xz - yw)        2(yz + xw)       1-2(x^2 + y^2)  |
 </pre>
 Quaternions can be derived from the axis/angle representation through the 
 formula q = (v, w) = (sin(theta)*n_hat,cos(theta)),
 where n_hat and theta are the rotation axis and angle.
 
cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ | 
 
two ways that the skew matrix are expressed are transposed from one another:
 
 [v]_x = |  0  -z   y |   this one is used in MatrixUtil.skewSymmetric()
         |  z   0  -x |
         | -y   x   0 |
         
 [v]_x = |  0   z  -y | 
         | -z   0   x |
         |  y  -x   0 |
 
 Eigen, ROS, and Google Ceres use Hamilton convention.
  Also  Wolfram Mathematica, Matlab’s aerospace(!) and robotics toolbox, 
  Boost, GNU Octave, NASA’s SPICE.

Note that Shuster 1993 use rotation matrices that are transposed from the standard
 in createRotationZYX():
    
        about z-axis (yaw):           about the y-axis (pitch):    about x-axis (roll): 
            | cos φ    sin φ    0 |    |  cos ψ    0 -sin ψ |      |    1       0       0 |  
            |-sin φ    cos φ    0 |    |      0    1      0 |      |    0   cos θ   sin θ |  
            |     0        0    1 |    |  sin ψ    0  cos ψ |      |    0  -sin θ   cos θ | 
 
    The Shuster transposed matrices are not used in this class.
    
 <pre>
 Some references in the "right hand system":
 
 "Euler Angles and Quaternions and Transformations", NASA Mission Planning
  and Analysis Division, 1977, Shuttle Program.
  
  Szeleski 2010
  
  Shuster 1993, "A Survey of Attitude Representations"
    Journal of Astronautical Sciences, Vol 41, No. 4, Oct-Dec 1993, pp 439-517
    http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf
  
  "Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors"
   James Diebel, 2006
 </pre>
 
 <pre><b><ul>LEFT HAND SYSTEM</ul></b></pre>
 A left hand system, in contrast, is used by aerospace engineering and
 aerospace medicine to describe the z-axis as pointing downwards (in the 
 direction of gravity w.r.t. a geo-centric system.)
 
 Chapter 4, "Human Response to Acceleration" by Banks, Brinkly, Allnut, and Harding
    in "Fundamentals of Aerospace Medicine"
    Excerpt:
    "For example, the Advisory Group for Aerospace
    Research and Development (AGARD) standard for human
    acceleration differs from the AGARD standard for aircraft
    design (in which the z-acceleration axis is reversed and
    positive downward).
        ...consistent with the AGARD standard (1), the
    Table of Equivalents for Acceleration Terminology (2), the
    Aviation Space and Environmental Medicine Standard (3),
    and the majority of the Aerospace Medicine literature, the
    positive direction of each of these axes is here described by
    ‘‘the left-hand rule.’’   That is, the x-axis dimension is an arrow
     with the positive direction forward, the y-axis dimension has
    the positive direction rightward, and"
  
  <pre> 
 
 Regarding rotation axes and perspectives:
     https://en.wikipedia.org/wiki/Rotation_matrix#Ambiguities
     The coordinates of a point P may change due to either a rotation of the 
     coordinate system CS (alias), or a rotation of the point P (alibi). 
     In the latter case, the rotation of P also produces a rotation of the 
     vector v representing P. In other words, either P and v are fixed while 
     CS rotates (alias), or CS is fixed while P and v rotate (alibi). Any 
     given rotation can be legitimately described both ways, as vectors and 
     coordinate systems actually rotate with respect to each other, about the 
     same axis but in opposite directions. Throughout this article, we chose the 
     alibi approach to describe rotations. For instance, 
        R(theta)= | cos(theta)  -sin(theta) |
                  | sin(theta)   cos(theta) |
     represents a counterclockwise rotation of a vector v by an angle θ, or a 
     rotation of the coordinate system (CS) by the same angle but in the opposite direction 
     (i.e. clockwise). Alibi and alias transformations are also known as active 
     and passive transformations, respectively.
 
     Pre-multiplication or post-multiplication
         The same point P can be represented either by a column vector v or a 
         row vector w. Rotation matrices can either pre-multiply column vectors 
         (Rv), or post-multiply row vectors (wR). However, Rv produces a 
         rotation in the opposite direction with respect to wR. 
         Throughout this article, rotations produced on column vectors are 
         described by means of a pre-multiplication. To obtain exactly the same 
         rotation (i.e. the same final coordinates of point P), the equivalent 
         row vector must be post-multiplied by the transpose of R (i.e. wR^T).
 
 skew symmetric of vector v is [v]_x:
       |    0   -v[2]  v[1]  |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]    0    |
    
    e^(i*theta) = cos(theta) + i*sin(theta)
    
    exponential of a matrix is expanded via power series:  e^A = I + A + (higher order terms AA/2! + AAA/3!...)
    
    for A = | 0  -1 |
            | 1   0 |
    
    e^(A*t) = |  cos(t)  -sin(t)  |  through diagonalizing A
              |  sin(t)   cos(t)  |
    
    for A being skew symmetric: |  0  -z  y |
                                |  z   0 -x |
                                | -y   x  0 |
    e^(A*theta) = I + A*sin(theta) +A^2*(1 - cos(theta))
    
    
    R_axis = exp(-[e_axis]_x*theta_axis)
    
    R_x = exp(-[1,0,0]_x * theta_x) = exp( 0  0  0 )*theta_x )
                                           0  0  1
                                           0 -1  0
      
   terms used describing axes of rotation, attitute or orientation:
        heading, attitude, bank,
        pitch, yaw, roll,
        pan, tilt, roll
        
   A rotation can be represented by a rotation axis nˆ and an angle ω,
   or equivalently by a 3D vector ω = θ*nˆ
   to project vector v onto the axis nˆ:
      v_parallel = nˆ*(nˆ· v) = (nˆ*nˆ^T)*v and this is not affected by rotation
      v_perpendicular = v - v_parallel
                      = (I - nˆ*nˆ^T)*v
   can rotate v by 90 degrees using the cross product:
      nˆ cross v = [nˆ]_x * v
      where [nˆ]_x is the skewsymmetric matrix of nˆ

   can rotate v by 180 degrees:
      nˆ cross (nˆ cross v) = ([nˆ]_x)^2 * v = -v_perpendicular
   which shows that can also write
      v_parallel = (I + ([nˆ]_x)^2 * v)
      
 </pre>

 TODO: add a method to extract the quaternion rotation from a 4X4 rotation matrix.
 see Barfoot et al.
 see http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/

 <pre>
  also note that for optimization of rotation :
      prefer to update the rotation vectors and/or the rotation matrices.
      do not update the euler angles because eqn (28) of Barfoot et al. shows that an inverse term
      is not defined at singularities.
      do not extract euler angles or vector from a rotation matrix unless unavoidable because the
      extraction is ambiguous.
      the create rotation matrix from rotation vector or from euler angles is fine.
 </pre></div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Rotation.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">Rotation.AuxiliaryArrays</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Rotation</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applyRotationPerturbationToQuaternion(double%5B%5D,double%5B%5D)">applyRotationPerturbationToQuaternion</a></span>&#8203;(double[]&nbsp;theta,
                                     double[]&nbsp;dTheta)</code></th>
<td class="colLast">
<div class="block">apply perturbation dTheta to quaternion formed from euler rotation angles
 theta.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applySingularitySafeEulerAnglesPerturbationZYX(double%5B%5D,double%5B%5D)">applySingularitySafeEulerAnglesPerturbationZYX</a></span>&#8203;(double[]&nbsp;euler,
                                              double[]&nbsp;dEuler)</code></th>
<td class="colLast">
<div class="block">apply a perturbation in rotation angles to the rotation matrix created by
 the euler angles theta where the rotation matrix created is R_z*R_y*R_x.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applySingularitySafeRotationPerturbationQuaternion(double%5B%5D,double%5B%5D)">applySingularitySafeRotationPerturbationQuaternion</a></span>&#8203;(double[]&nbsp;theta,
                                                  double[]&nbsp;dTheta)</code></th>
<td class="colLast">
<div class="block">create a unit-length quaternion update of the quaternion formed
 from the euler rotation angles theta by the perturbation dTheta.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applySingularitySafeRotationVectorPerturbation(double%5B%5D,double%5B%5D%5B%5D)">applySingularitySafeRotationVectorPerturbation</a></span>&#8203;(double[]&nbsp;dRVector,
                                              double[][]&nbsp;rotation)</code></th>
<td class="colLast">
<div class="block">apply a perturbation in the rotation vector to a rotation matrix.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cay(double%5B%5D%5B%5D)">cay</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">
<div class="block">orthogonalize matrix R using skew parameters via Cayley's formula.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convertEulerAnglesToRodriguesVectorForZYX(double%5B%5D)">convertEulerAnglesToRodriguesVectorForZYX</a></span>&#8203;(double[]&nbsp;eulerAngles)</code></th>
<td class="colLast">
<div class="block">convert the euler rotation angles to the Rodrigues vector (angle and axis)
 with an expectation that the rotation matrix in between is created by
 the multiplication order R_z*R_y_R_x.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convertHamiltonToBarfootQuaternion(double%5B%5D)">convertHamiltonToBarfootQuaternion</a></span>&#8203;(double[]&nbsp;qHamilton)</code></th>
<td class="colLast">
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convertHamiltonToBarfootQuaternionInPlace(double%5B%5D)">convertHamiltonToBarfootQuaternionInPlace</a></span>&#8203;(double[]&nbsp;qHamilton)</code></th>
<td class="colLast">
<div class="block">convert the quaternion from [scalar vector] to [vector scalar] in-place.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createDeltaQ(double%5B%5D,double%5B%5D)">createDeltaQ</a></span>&#8203;(double[]&nbsp;theta,
            double[]&nbsp;dTheta)</code></th>
<td class="colLast">
<div class="block">create perturbation for a quaternion from a perturbation to euler
 rotation angles.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createHamiltonQuaternionZYX(double%5B%5D)">createHamiltonQuaternionZYX</a></span>&#8203;(double[]&nbsp;thetas)</code></th>
<td class="colLast">
<div class="block">calculate  the Hamilton quaternion which would be extracted from the
 rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createHamiltonQuaternionZYX(double,double%5B%5D)">createHamiltonQuaternionZYX</a></span>&#8203;(double&nbsp;angle,
                           double[]&nbsp;axis)</code></th>
<td class="colLast">
<div class="block">calculate  the Hamilton quaternion which would be extracted from the
 rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createIdentityQuaternion()">createIdentityQuaternion</a></span>()</code></th>
<td class="colLast">
<div class="block">given a quaternion, return the inverse</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createPitchRotationMatrix(double)">createPitchRotationMatrix</a></span>&#8203;(double&nbsp;angle)</code></th>
<td class="colLast">
<div class="block">create matrix for rotation about the Y-axis, a.k.a.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createPitchRotationMatrix(double,double%5B%5D%5B%5D)">createPitchRotationMatrix</a></span>&#8203;(double&nbsp;angle,
                         double[][]&nbsp;out)</code></th>
<td class="colLast">
<div class="block">create matrix for rotation about the Y-axis, a.k.a.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createQuaternionZYXFromEuler(double%5B%5D)">createQuaternionZYXFromEuler</a></span>&#8203;(double[]&nbsp;eulerXYZ)</code></th>
<td class="colLast">
<div class="block">create a rotation quaternion from Euler x, y, z angles.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRodriguesFormulaRotationMatrix(double%5B%5D)">createRodriguesFormulaRotationMatrix</a></span>&#8203;(double[]&nbsp;axis)</code></th>
<td class="colLast">
<div class="block">given axis as an array of rotations about x, y, and z, calculate the 
 rotation matrix.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRodriguesFormulaRotationMatrixTranspose(double%5B%5D)">createRodriguesFormulaRotationMatrixTranspose</a></span>&#8203;(double[]&nbsp;v)</code></th>
<td class="colLast">
<div class="block">given v as an array of rotations about x, y, and z, calculate the 
 transpose of the rotation matrix.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static <a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRodriguesRotationMatrixBouguet(double%5B%5D)">createRodriguesRotationMatrixBouguet</a></span>&#8203;(double[]&nbsp;in)</code></th>
<td class="colLast">
<div class="block">calculate the rotation matrix given the Rodrigues rotation vector.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRollRotationMatrix(double)">createRollRotationMatrix</a></span>&#8203;(double&nbsp;angle)</code></th>
<td class="colLast">
<div class="block">create matrix for rotation about the X-axis, a.k.a.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRollRotationMatrix(double,double%5B%5D%5B%5D)">createRollRotationMatrix</a></span>&#8203;(double&nbsp;angle,
                        double[][]&nbsp;out)</code></th>
<td class="colLast">
<div class="block">create matrix for rotation about the X-axis, a.k.a.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationFromQuaternion(double%5B%5D)">createRotationFromQuaternion</a></span>&#8203;(double[]&nbsp;theta)</code></th>
<td class="colLast">
<div class="block">create the rotation matrix from quaternions formed by the euler rotation
 angles theta.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationFromUnitLengthAngleAxis(double%5B%5D,double)">createRotationFromUnitLengthAngleAxis</a></span>&#8203;(double[]&nbsp;unitLengthAxis,
                                     double&nbsp;angle)</code></th>
<td class="colLast">
<div class="block">
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationMatrixFromQuaternion4(double%5B%5D)">createRotationMatrixFromQuaternion4</a></span>&#8203;(double[]&nbsp;quaternion)</code></th>
<td class="colLast">
<div class="block">create a [4x4] rotation matrix from the given quaternion.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationVector(double%5B%5D,double%5B%5D)">createRotationVector</a></span>&#8203;(double[]&nbsp;theta,
                    double[]&nbsp;dTheta)</code></th>
<td class="colLast">
<div class="block">create the rotation vector dPhi = S(theta) * dTheta</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationXYZ(double%5B%5D)">createRotationXYZ</a></span>&#8203;(double[]&nbsp;thetas)</code></th>
<td class="colLast">
<div class="block">given an array of euler rotation angles, return the rotation matrix
 as the rotations for x, y, z multiplied in that order.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationXYZ(double,double,double)">createRotationXYZ</a></span>&#8203;(double&nbsp;angleX,
                 double&nbsp;angleY,
                 double&nbsp;angleZ)</code></th>
<td class="colLast">
<div class="block">calculate R(angle_z, angle_y, angle_x) = R_x(angle_x)*R_y(angle_y)*R_z(angle_z).</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationZYX(double%5B%5D)">createRotationZYX</a></span>&#8203;(double[]&nbsp;thetas)</code></th>
<td class="colLast">
<div class="block">calculate  R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z)
 ,
 that is, given an array of rotation angles, return the rotation matrix
 as the rotations for z, y, x multiplied in that order.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRotationZYX(double%5B%5D,algorithms.imageProcessing.transform.Rotation.AuxiliaryArrays,double%5B%5D%5B%5D)">createRotationZYX</a></span>&#8203;(double[]&nbsp;thetas,
                 <a href="Rotation.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">Rotation.AuxiliaryArrays</a>&nbsp;aa,
                 double[][]&nbsp;out)</code></th>
<td class="colLast">
<div class="block">given an array of euler rotation angles, return the rotation matrix
 as the rotations for z, y, x multiplied in that order.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createUnitLengthQuaternionBarfoot(double%5B%5D,double)">createUnitLengthQuaternionBarfoot</a></span>&#8203;(double[]&nbsp;unitLengthAxis,
                                 double&nbsp;angle)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createUnitLengthQuaternionHamilton(double%5B%5D,double)">createUnitLengthQuaternionHamilton</a></span>&#8203;(double[]&nbsp;unitLengthAxis,
                                  double&nbsp;angle)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createYawRotationMatrix(double)">createYawRotationMatrix</a></span>&#8203;(double&nbsp;angle)</code></th>
<td class="colLast">
<div class="block">create matrix for rotation about the Z-axis, a.k.a.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createYawRotationMatrix(double,double%5B%5D%5B%5D)">createYawRotationMatrix</a></span>&#8203;(double&nbsp;angle,
                       double[][]&nbsp;out)</code></th>
<td class="colLast">
<div class="block">create matrix for rotation about the Z-axis, a.k.a.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#distanceBetweenQuaternions(double%5B%5D,double%5B%5D)">distanceBetweenQuaternions</a></span>&#8203;(double[]&nbsp;q1,
                          double[]&nbsp;q2)</code></th>
<td class="colLast">
<div class="block">calculate the distance metric between quaternions, using vector inner product</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#distanceUsingRigidBodyDisplacements(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)">distanceUsingRigidBodyDisplacements</a></span>&#8203;(double[][]&nbsp;r1,
                                   double[][]&nbsp;r2,
                                   boolean&nbsp;useFrobenius)</code></th>
<td class="colLast">
<div class="block">estimate the</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractRodriguesRotationVector(double%5B%5D%5B%5D)">extractRodriguesRotationVector</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">
<div class="block">another method to extract the Rodrigues vector (angle and axis)
 from the given
 rotation matrix.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static <a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractRodriguesRotationVectorBouguet(double%5B%5D%5B%5D)">extractRodriguesRotationVectorBouguet</a></span>&#8203;(double[][]&nbsp;in)</code></th>
<td class="colLast">
<div class="block">calculate the Rodrigues rotation vector from the given rotation matrix.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractRotationAxisFromZXY(double%5B%5D%5B%5D)">extractRotationAxisFromZXY</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">
<div class="block">extract the euler rotation angles from the given rotation matrix assumed
 to be a result of R_yxz = R_z(theta_z) * R_x(theta_x) * R_y(theta_y)
 (aka 2-1-3 angle set?).</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractThetaFromXYZ(double%5B%5D%5B%5D)">extractThetaFromXYZ</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractThetaFromXYZ(double%5B%5D%5B%5D,double%5B%5D)">extractThetaFromXYZ</a></span>&#8203;(double[][]&nbsp;r,
                   double[]&nbsp;out)</code></th>
<td class="colLast">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractThetaFromZYX(double%5B%5D%5B%5D)">extractThetaFromZYX</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_xyz =  R(theta_Z) * R(theta_Y) * R(theta_X).</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractThetaFromZYX(double%5B%5D%5B%5D,double%5B%5D)">extractThetaFromZYX</a></span>&#8203;(double[][]&nbsp;r,
                   double[]&nbsp;out)</code></th>
<td class="colLast">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R(theta_Z) * R(theta_Y) * R(theta_X).</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orthonormalizeUsingSkewCayley(double%5B%5D%5B%5D)">orthonormalizeUsingSkewCayley</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orthonormalizeUsingSVD(double%5B%5D%5B%5D)">orthonormalizeUsingSVD</a></span>&#8203;(double[][]&nbsp;r)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#procrustesAlgorithmForRotation(double%5B%5D%5B%5D,double%5B%5D%5B%5D)">procrustesAlgorithmForRotation</a></span>&#8203;(double[][]&nbsp;x1,
                              double[][]&nbsp;x2)</code></th>
<td class="colLast">
<div class="block">determine the rotation between measurements x1 and x2 when both datasets
 have the same center, that is, there is no translation between them,
 only rotation.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#quaternionConjugateOperator(double%5B%5D)">quaternionConjugateOperator</a></span>&#8203;(double[]&nbsp;quaternion)</code></th>
<td class="colLast">
<div class="block">given a quaternion, return the inverse
 (symbol is superscript -1).</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#quaternionLefthandCompoundOperator(double%5B%5D)">quaternionLefthandCompoundOperator</a></span>&#8203;(double[]&nbsp;quaternion)</code></th>
<td class="colLast">
<div class="block">given a quaternion of Barfoot format [vector scalar], form the left-hand compound operator
 (symbol is superscript +)</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#quaternionPrincipalAxisRotation(double,int)">quaternionPrincipalAxisRotation</a></span>&#8203;(double&nbsp;angle,
                               int&nbsp;principalAxis)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#quaternionRighthandCompoundOperator(double%5B%5D)">quaternionRighthandCompoundOperator</a></span>&#8203;(double[]&nbsp;quaternion)</code></th>
<td class="colLast">
<div class="block">given a quaternion, form the right-hand compound operator:
 (symbol is superscript ⨁)</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rotateAPointByQuaternion(double%5B%5D,double%5B%5D)">rotateAPointByQuaternion</a></span>&#8203;(double[]&nbsp;quaternion,
                        double[]&nbsp;v3)</code></th>
<td class="colLast">
<div class="block">rotate point p by the given quaternion.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rotateVectorByQuaternion4(double%5B%5D,double%5B%5D)">rotateVectorByQuaternion4</a></span>&#8203;(double[]&nbsp;quaternion,
                         double[]&nbsp;p)</code></th>
<td class="colLast">
<div class="block">rotate point p by the given quaternion.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rotationBetweenTwoDirections0(double%5B%5D,double%5B%5D)">rotationBetweenTwoDirections0</a></span>&#8203;(double[]&nbsp;v1,
                             double[]&nbsp;v2)</code></th>
<td class="colLast">
<div class="block">calculate the rotation needed to transform direction v1 to direction v2 using
 a quaternion.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rotationBetweenTwoDirections1(double%5B%5D,double%5B%5D)">rotationBetweenTwoDirections1</a></span>&#8203;(double[]&nbsp;v1,
                             double[]&nbsp;v2)</code></th>
<td class="colLast">
<div class="block">calculate the rotation needed to tranform direction v1 to direction v2 using
 Rodrigues formula.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sTheta(double%5B%5D)">sTheta</a></span>&#8203;(double[]&nbsp;theta)</code></th>
<td class="colLast">
<div class="block">calculate S_theta which is the matrix relating angular velocity to 
 rotation angle rates.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sTheta(double%5B%5D,double%5B%5D%5B%5D)">sTheta</a></span>&#8203;(double[]&nbsp;theta,
      double[][]&nbsp;output)</code></th>
<td class="colLast">
<div class="block">calculate S_theta which is the matrix relating angular velocity to 
 rotation angle rates.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Rotation</h4>
<pre>public&nbsp;Rotation()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="createRotationXYZ(double,double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationXYZ</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRotationXYZ&#8203;(double&nbsp;angleX,
                                           double&nbsp;angleY,
                                           double&nbsp;angleZ)</pre>
<div class="block">calculate R(angle_z, angle_y, angle_x) = R_x(angle_x)*R_y(angle_y)*R_z(angle_z).
 NOTE: this is not the normal convention.  You might want to use
 createRotationZYX().
 <pre>
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angleX</code> - angle of rotation about x-axis (roll) in units of radians.</dd>
<dd><code>angleY</code> - angle of rotation about y-axis (pitch) in units of radians.</dd>
<dd><code>angleZ</code> - angle of rotation about z-axis (yaw) in units of radians.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createRollRotationMatrix(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRollRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRollRotationMatrix&#8203;(double&nbsp;angle)</pre>
<div class="block">create matrix for rotation about the X-axis, a.k.a. roll.
       <pre>
       about x-axis (roll):       
       |    1       0       0 |  
       |    0   cos θ  -sin θ |  
       |    0   sin θ   cos θ | 
       </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - angle of rotation about x-axis (roll) in units of radians.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createRollRotationMatrix(double,double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRollRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;createRollRotationMatrix&#8203;(double&nbsp;angle,
                                            double[][]&nbsp;out)</pre>
<div class="block">create matrix for rotation about the X-axis, a.k.a. roll.
       <pre>
       about x-axis (roll):       
       |    1       0       0 |  
       |    0   cos θ  -sin θ |  
       |    0   sin θ   cos θ | 
       </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - angle of rotation about x-axis (roll) in units of radians.</dd>
<dd><code>out</code> - holds values for rotation matrix for roll.</dd>
</dl>
</li>
</ul>
<a id="createPitchRotationMatrix(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createPitchRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createPitchRotationMatrix&#8203;(double&nbsp;angle)</pre>
<div class="block">create matrix for rotation about the Y-axis, a.k.a. pitch.
      <pre>
      about the y-axis (pitch):
      |  cos ψ    0  sin ψ |
      |      0    1      0 |
      | -sin ψ    0  cos ψ |
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - angle of rotation about y-axis (pitch) in units of radians.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createPitchRotationMatrix(double,double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createPitchRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;createPitchRotationMatrix&#8203;(double&nbsp;angle,
                                             double[][]&nbsp;out)</pre>
<div class="block">create matrix for rotation about the Y-axis, a.k.a. pitch.
      <pre>
      about the y-axis (pitch):
      |  cos ψ    0  sin ψ |
      |      0    1      0 |
      | -sin ψ    0  cos ψ |
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - angle of rotation about y-axis (pitch) in units of radians.</dd>
<dd><code>out</code> - holds values for rotation matrix for pitch</dd>
</dl>
</li>
</ul>
<a id="createYawRotationMatrix(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createYawRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createYawRotationMatrix&#8203;(double&nbsp;angle)</pre>
<div class="block">create matrix for rotation about the Z-axis, a.k.a. yaw.
      <pre>
        about z-axis (yaw):          
            | cos φ   -sin φ    0 | 
            | sin φ    cos φ    0 | 
            |     0        0    1 | 
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - angle of rotation about z-axis (yaw) in units of radians.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createYawRotationMatrix(double,double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createYawRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;createYawRotationMatrix&#8203;(double&nbsp;angle,
                                           double[][]&nbsp;out)</pre>
<div class="block">create matrix for rotation about the Z-axis, a.k.a. yaw.
      <pre>
        about z-axis (yaw):          
            | cos φ   -sin φ    0 | 
            | sin φ    cos φ    0 | 
            |     0        0    1 | 
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - angle of rotation about z-axis (yaw) in units of radians.</dd>
<dd><code>out</code> - results for a rotation matrix for yaw.  size given to method 
 must be 3X3.</dd>
</dl>
</li>
</ul>
<a id="rotationBetweenTwoDirections0(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotationBetweenTwoDirections0</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;rotationBetweenTwoDirections0&#8203;(double[]&nbsp;v1,
                                                       double[]&nbsp;v2)</pre>
<div class="block">calculate the rotation needed to transform direction v1 to direction v2 using
 a quaternion.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v1</code> - </dd>
<dd><code>v2</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="rotationBetweenTwoDirections1(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotationBetweenTwoDirections1</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;rotationBetweenTwoDirections1&#8203;(double[]&nbsp;v1,
                                                       double[]&nbsp;v2)</pre>
<div class="block">calculate the rotation needed to tranform direction v1 to direction v2 using
 Rodrigues formula.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v1</code> - </dd>
<dd><code>v2</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createRodriguesFormulaRotationMatrix(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRodriguesFormulaRotationMatrix</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRodriguesFormulaRotationMatrix&#8203;(double[]&nbsp;axis)</pre>
<div class="block">given axis as an array of rotations about x, y, and z, calculate the 
 rotation matrix.  
 essentially, excepting a small angle correction:
     R^⊤ = cosθ*I + sinθ*[v]_× + (1−cosθ)*v*v^⊤
 
 NOTE: if computing the partial derivative of Rotation elsewhere, 
 can use d(R(ω)*v)/d(ω^T) = -[v]_x (see Equation (2.35) of Szeliski 2010).
 Also note that a + sign in front of the sinθ term is used for the
 passive system of rotations and these are used in
 dynamics, mathematics, and computer science, etc.  A - sign 
 in front of the sinθ term is used in aerospace engineering and medicine
 as the later use the "left hand rule" for coordinate axes.
 <pre>
 references:
    Dmitry Berenson https://github.com/robEllenberg/comps-plugins/blob/master/python/rodrigues.py
    Szeliski 2010 draft "Computer Vision: Algorithms and Applications"
    Rodriguez’s formula (Ayache 1989)
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>axis</code> - [1x3] array of axis of rotations about x, y, and z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>rotation matrix [3X3]</dd>
</dl>
</li>
</ul>
<a id="createRodriguesFormulaRotationMatrixTranspose(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRodriguesFormulaRotationMatrixTranspose</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRodriguesFormulaRotationMatrixTranspose&#8203;(double[]&nbsp;v)</pre>
<div class="block">given v as an array of rotations about x, y, and z, calculate the 
 transpose of the rotation matrix.
 It is the same as the rodrigues rotation matrix without transposition, 
 except that the sign in front of the sine term is negatvie.
 R^⊤ = cosθ*I − sinθ*[v]_× + (1−cosθ)*v*v^⊤
     
 <pre>
 references:
    Dmitry Berenson https://github.com/robEllenberg/comps-plugins/blob/master/python/rodrigues.py
    Szeliski 2010 draft "Computer Vision: Algorithms and Applications"
    Rodriguez’s formula (Ayache 1989)
 
    Metrics for 3D Rotations: Comparison and Analysis.
    Huynh 2009.
    J Math Imaging Vis (2009) 35: 155–164 DOI 10.1007/s10851-009-0161-2
    https://www.cs.cmu.edu/~cga/dynopt/readings/Rmetric.pdf
    (note that Huynh uses Hamilton quaternions.)
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - [1x3] array of rotations about x, y, and z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>rotation matrix [3X3]</dd>
</dl>
</li>
</ul>
<a id="extractRodriguesRotationVectorBouguet(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractRodriguesRotationVectorBouguet</h4>
<pre class="methodSignature">public static&nbsp;<a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a>&nbsp;extractRodriguesRotationVectorBouguet&#8203;(double[][]&nbsp;in)
                                                                        throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate the Rodrigues rotation vector from the given rotation matrix.
 The method is ported from github repositories holding the Bouguet Matlab Toolbox code, rodrigues.m.
      <pre>
      The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
      and states that the source code is freely available.
      The github repositories with the forked Bouguet Matlab code do not have license
      information.

      https://github.com/fragofer/TOOLBOX_calib
      and
      https://github.com/hunt0r/Bouguet_cam_cal_toolbox

      rodrigues.m includes the comment: Copyright (c) March 1993 -- Pietro Perona, CalTech, before a brief
      changelist by Bouguet.
      </pre>
      Note that this is an ambiguous task.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>in</code> - [3X3] rotation matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="createRodriguesRotationMatrixBouguet(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRodriguesRotationMatrixBouguet</h4>
<pre class="methodSignature">public static&nbsp;<a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a>&nbsp;createRodriguesRotationMatrixBouguet&#8203;(double[]&nbsp;in)</pre>
<div class="block">calculate the rotation matrix given the Rodrigues rotation vector.
 The method is ported from github repositories holding the Bouguet Matlab Toolbox code, rodrigues.m.
      <pre>
      The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
      and states that the source code is freely available.
      The github repositories with the forked Bouguet Matlab code do not have license
      information.

      https://github.com/fragofer/TOOLBOX_calib
      and
      https://github.com/hunt0r/Bouguet_cam_cal_toolbox

      rodrigues.m includes the comment: Copyright (c) March 1993 -- Pietro Perona, CalTech, before a brief
      changelist by Bouguet.

      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>in</code> - [3X1] rotation vector</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="procrustesAlgorithmForRotation(double[][],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>procrustesAlgorithmForRotation</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;procrustesAlgorithmForRotation&#8203;(double[][]&nbsp;x1,
                                                        double[][]&nbsp;x2)
                                                 throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">determine the rotation between measurements x1 and x2 when both datasets
 have the same center, that is, there is no translation between them,
 only rotation.
 (see Golub & van Loan "Matrix Computations" 11.12.4,
 Szeliski 2010, Sect 6.1.5).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x1</code> - a set of measurements having same center as x2, that is,
 there is no translation between them, only rotation.
 the expected format is nData X nDimensions.</dd>
<dd><code>x2</code> - another set of measurements having same center as x1, that is,
 there is no translation between them, only rotation.
 the expected format is nData X nDimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="extractRotationAxisFromZXY(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractRotationAxisFromZXY</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;extractRotationAxisFromZXY&#8203;(double[][]&nbsp;r)</pre>
<div class="block">extract the euler rotation angles from the given rotation matrix assumed
 to be a result of R_yxz = R_z(theta_z) * R_x(theta_x) * R_y(theta_y)
 (aka 2-1-3 angle set?).
 Note, this way of extracting of the angles is 
 ambiguous (there are more than one angle combination sets that will
       result in the same matrix).
     <pre>
     the method is from equation (37) from 
     lecture notes of Gordon Wetzstein at Stanford University,
     EE 267 Virtual Reality, "Course Notes: 6-DOF Pose Tracking with the VRduino",
     https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - rotation matrix assumed
 to be a result of R_yxz = R_z(theta_z)  * R_x(theta_x) * R_y(theta_y).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>theta_x, theta_y, theta_z
 which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</li>
</ul>
<a id="extractThetaFromZYX(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractThetaFromZYX</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;extractThetaFromZYX&#8203;(double[][]&nbsp;r)</pre>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_xyz =  R(theta_Z) * R(theta_Y) * R(theta_X).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of theta_x, theta_y, theta_z
 which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</li>
</ul>
<a id="extractThetaFromZYX(double[][],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractThetaFromZYX</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;extractThetaFromZYX&#8203;(double[][]&nbsp;r,
                                       double[]&nbsp;out)</pre>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R(theta_Z) * R(theta_Y) * R(theta_X).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - </dd>
<dd><code>out</code> - output variable to hold theta_x, theta_y, and theta_z,
 which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</li>
</ul>
<a id="extractThetaFromXYZ(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractThetaFromXYZ</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;extractThetaFromXYZ&#8203;(double[][]&nbsp;r)</pre>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>euler angles extracted from the rotation matrix under assumption
 that the rotation matrix was constructed with multiplication order
 R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
 theta_x, theta_y, and theta_z, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</li>
</ul>
<a id="extractThetaFromXYZ(double[][],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractThetaFromXYZ</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;extractThetaFromXYZ&#8203;(double[][]&nbsp;r,
                                       double[]&nbsp;out)</pre>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - </dd>
<dd><code>out</code> - output array of size 3 used to place euler angles extracted 
 from the rotation matrix under assumption
 that the rotation matrix was constructed with multiplication order
 R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</dd>
</dl>
</li>
</ul>
<a id="extractRodriguesRotationVector(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractRodriguesRotationVector</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;extractRodriguesRotationVector&#8203;(double[][]&nbsp;r)</pre>
<div class="block">another method to extract the Rodrigues vector (angle and axis)
 from the given
 rotation matrix.  it's an ambiguous task.

     <pre>
     the method is from  
     lecture notes of Pradit Mittrapiyanuruk at Perdue University,
     ECE 661 Robot Vision Laboratory,
     https://engineering.purdue.edu/kak/computervision/ECE661_Fall2012/homework/hw5_LM_handout.pdf
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - rotation matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Rodriques vector.  the axis and angle representation from this
 can be constructed as angle of rotation = r_vec/||r_vec|| and angle = ||r_vec||
 where r_vec is the rodrigues vector.</dd>
</dl>
</li>
</ul>
<a id="convertEulerAnglesToRodriguesVectorForZYX(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertEulerAnglesToRodriguesVectorForZYX</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;convertEulerAnglesToRodriguesVectorForZYX&#8203;(double[]&nbsp;eulerAngles)</pre>
<div class="block">convert the euler rotation angles to the Rodrigues vector (angle and axis)
 with an expectation that the rotation matrix in between is created by
 the multiplication order R_z*R_y_R_x.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>eulerAngles</code> - euler rotation angles as double[]{x, y, z}</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Rodriques vector.  the axis and angle representation from this
 can be constructed as angle of rotation = r_vec/||r_vec|| and angle = ||r_vec||
 where r_vec is the rodrigues vector.</dd>
</dl>
</li>
</ul>
<a id="distanceBetweenQuaternions(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceBetweenQuaternions</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;distanceBetweenQuaternions&#8203;(double[]&nbsp;q1,
                                                double[]&nbsp;q2)</pre>
<div class="block">calculate the distance metric between quaternions, using vector inner product
    <pre>
    eqn (19) of J Math Imaging Vis (2009) 35: 155–164 DOI 10.1007/s10851-009-0161-2
    Metrics for 3D Rotations: Comparison and Analysis Du Q. Huynh
    </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>q1</code> - a quaternion</dd>
<dd><code>q2</code> - another quaternion</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>distance metric between 2 quaternions.  the range of 
 values will be [0,π/2] (radians).</dd>
</dl>
</li>
</ul>
<a id="distanceUsingRigidBodyDisplacements(double[][],double[][],boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceUsingRigidBodyDisplacements</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;distanceUsingRigidBodyDisplacements&#8203;(double[][]&nbsp;r1,
                                                         double[][]&nbsp;r2,
                                                         boolean&nbsp;useFrobenius)
                                                  throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">estimate the
 <pre>
     reference:
     Huynh 2009, J Math Imaging Vis, 35, 155-164, eqn (21)
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r1</code> - a 3X3 rotation matrix</dd>
<dd><code>r2</code> - a 3X3 rotation matrix</dd>
<dd><code>useFrobenius</code> - if true, uses Frobenius norm internally, else uses the spectral norm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>return the distance defined as ∥ I − r1 * r2 ∥_F if useFrobenious is true.
 In that case the distance is within the range [0, 2sqrt(2)].
 If useFrobenious is false, the result is spectralNorm(I − r1 * r2) which results in a distance in the range [0, 2].</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="quaternionLefthandCompoundOperator(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>quaternionLefthandCompoundOperator</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;quaternionLefthandCompoundOperator&#8203;(double[]&nbsp;quaternion)</pre>
<div class="block">given a quaternion of Barfoot format [vector scalar], form the left-hand compound operator
 (symbol is superscript +)
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (2):
 given q = 4X1 column vector of [eps eta] where eta is the scalar,
 and "1" is a 3X3 identity matrix, also written as I_3.
 and [eps]_x is the skew-symetric matrix for vector eps.
 
 The left-hand compound operator is a 4X4 matrix:
 
 q^+ = [ eta*I_3-[eps]_x   eps ]  // | [3X3]  [3X1] |
       [ -eps^T           eta ]   // | [1X3]  [1X1] |
 
 multiplication of quaternions, u and v, which is typically written 
 as u ⊗ v may be written equivalently as either
         u^+ v or v^⨁ u,
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="quaternionRighthandCompoundOperator(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>quaternionRighthandCompoundOperator</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;quaternionRighthandCompoundOperator&#8203;(double[]&nbsp;quaternion)</pre>
<div class="block">given a quaternion, form the right-hand compound operator:
 (symbol is superscript ⨁)
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (2):
 given q = 4X1 column vector of [eps eta] where eta is the scalar,
 and "1" is a 3X3 identity matrix, also written as I_3.
 and [q]_x is the skew-symetric matrix for q.
 
 The right-hand compound operator is a 4X4 matrix:
 
 q^⨁ = [ eta*I_3+[q]_x   eps ]
        [ -eps^T          eta ]
 
 multiplication of quaternions, u and v, which is typically written 
 as u ⊗ v may be written equivalently as either
         u^+ v or v^⨁ u,
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>[4X4]</dd>
</dl>
</li>
</ul>
<a id="quaternionConjugateOperator(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>quaternionConjugateOperator</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;quaternionConjugateOperator&#8203;(double[]&nbsp;quaternion)</pre>
<div class="block">given a quaternion, return the inverse
 (symbol is superscript -1).
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (5):
 given q = 4X1 column vector of [eps eta] where eta is the scalar,
 
 the inverse is the column vector:
 
 q^-1 = [ -eps  eta ]
 
 </pre>
 <em>NOTE that if the quaternion is a unit-length quaternion, the conjugate
 operation is usually called the inverse operation.</em></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createIdentityQuaternion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createIdentityQuaternion</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createIdentityQuaternion()</pre>
<div class="block">given a quaternion, return the inverse
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049,
 near eqn (8): 
 
 creates identity element: [0 0 0 1]
 
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>4X1 column vector of [eps eta] where eta is the scalar, specifically
 [0, 0, 0, 1]</dd>
</dl>
</li>
</ul>
<a id="createRotationMatrixFromQuaternion4(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationMatrixFromQuaternion4</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRotationMatrixFromQuaternion4&#8203;(double[]&nbsp;quaternion)</pre>
<div class="block">create a [4x4] rotation matrix from the given quaternion.
     <pre>
       Note, the first [3X3] block is transposed compared to results 
           from Rotation.createRotationZYX(eulerAngles)
       where 
       double[] qHamilton = Rotation.createHamiltonQuaternionZYX(eulerAngles);
       double[] quaternion = Rotation.convertHamiltonToBarfootQuaternion(qHamilton);
      
     This method's results are consistent with Shuster 1993.
 The method follows Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (12):
 
  R = q^+ * q^(-1)^⨁ = q^(-1)^⨁ * q^+ = q^(⨁)^T * q^+
    
    = [ C   0 ]
      [ 0^T 1 ]
 where C is the canonical 3X3 rotation matrix.
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quaternion</code> - rotation as a [4X1] column vector of [eps eta] where eta is the scalar
                   (i.e. Barfoot format)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a 4x4 rotation matrix whose 3X3 block at [0:2, 0:2] is the rotation matrix.</dd>
</dl>
</li>
</ul>
<a id="rotateAPointByQuaternion(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotateAPointByQuaternion</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;rotateAPointByQuaternion&#8203;(double[]&nbsp;quaternion,
                                                double[]&nbsp;v3)</pre>
<div class="block">rotate point p by the given quaternion.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (11):
 
 v3 = [ p ]
      [ 0 ]
 
  rotated = q^+ * q^(-1)^⨁ * v3 = R*v3
 
  where R is the canonical 3X3 rotation matrix.
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar.</dd>
<dd><code>v3</code> - the point as 3 element array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="rotateVectorByQuaternion4(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotateVectorByQuaternion4</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;rotateVectorByQuaternion4&#8203;(double[]&nbsp;quaternion,
                                                 double[]&nbsp;p)</pre>
<div class="block">rotate point p by the given quaternion.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (11):
 
 v3 = [ p ]
      [ 0 ]
 
  rotated = q^+ * q^(-1)^⨁ * v3 = R*v3
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dd><code>p</code> - the vector as a 3 element array followed by a 0, = [4X1].</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="applySingularitySafeEulerAnglesPerturbationZYX(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applySingularitySafeEulerAnglesPerturbationZYX</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;applySingularitySafeEulerAnglesPerturbationZYX&#8203;(double[]&nbsp;euler,
                                                                        double[]&nbsp;dEuler)</pre>
<div class="block">apply a perturbation in rotation angles to the rotation matrix created by
 the euler angles theta where the rotation matrix created is R_z*R_y*R_x.
 To the first order, this is a constraint-sensitive approach, i.e.
 r*r^T = I for the perturbed matrix to first order as long as it was
 true for the given matrix r.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (25).
 
 "This update approach allows us to store and update the rotation as a 
 rotation matrix, thereby avoiding singularities and the need to restore 
 the constraint afterwards (i.e., constraint restoration is built in)."
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>euler</code> - euler angles</dd>
<dd><code>dEuler</code> - perturbation to apply to the euler angles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>resulting perturbed rotation matrix</dd>
</dl>
</li>
</ul>
<a id="applySingularitySafeRotationVectorPerturbation(double[],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applySingularitySafeRotationVectorPerturbation</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;applySingularitySafeRotationVectorPerturbation&#8203;(double[]&nbsp;dRVector,
                                                                        double[][]&nbsp;rotation)</pre>
<div class="block">apply a perturbation in the rotation vector to a rotation matrix.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (31).
 "This update approach allows us to store and update the rotation as a 
 rotation matrix, thereby avoiding singularities and the need to restore 
 the constraint afterwards (i.e., constraint restoration is built in).
 
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="sTheta(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sTheta</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;sTheta&#8203;(double[]&nbsp;theta)</pre>
<div class="block">calculate S_theta which is the matrix relating angular velocity to 
 rotation angle rates.  
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (21):
 calc C = 3X3 rotation matrix (often written as R)
 given array of euler rotation angles alpha, beta, gamma
 
 s_theta column 0 = C_gamma(theta[2]) * C_beta(theta[1]) * [1, 0, 0]^T
         column 1 = C_gamma(theta[2]) * [0, 1, 0]^T 
         column 2 = [0, 0, 1]^T
 
             C_gamma                        C_beta                            C_alpha
      cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
  theta[0] = angleX angle of rotation about x-axis (roll) in units of radians.
             can use createRollRotationMatrix(theta[0])
  theta[1] = angleY angle of rotation about y-axis (pitch) in units of radians.
             can use createPitchRotationMatrix(theta[1])
  theta[2] = angleZ angle of rotation about z-axis (yaw) in units of radians.
             can use createYawRotationMatrix(theta[2])
 
 see also, pp 479-480, eqn (285) of Shuster 1993, "A Survey of AttitudeRepresentations"
 http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf
 though the sign conventions of the sine terms are different
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler angles as representation of rotation matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>[3X3]</dd>
</dl>
</li>
</ul>
<a id="sTheta(double[],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sTheta</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;sTheta&#8203;(double[]&nbsp;theta,
                          double[][]&nbsp;output)</pre>
<div class="block">calculate S_theta which is the matrix relating angular velocity to 
 rotation angle rates.  
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (21):
 calc C = 3X3 rotation matrix (often written as R)
 given array of euler rotation angles  alpha, beta,gamma matrices
 
 s_theta column 0 = C_gamma(theta[2]) * C_beta(theta[1]) * [1, 0, 0]^T
         column 1 = C_gamma(theta[2]) * [0, 1, 0]^T 
         column 2 = [0, 0, 1]^T
 
             C_gamma                        C_beta                            C_alpha
          cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
  theta[0] = angleX angle of rotation about x-axis (roll) in units of radians.
             can use createRollRotationMatrix(theta[0])
  theta[1] = angleY angle of rotation about y-axis (pitch) in units of radians.
             can use createPitchRotationMatrix(theta[1])
  theta[2] = angleZ angle of rotation about z-axis (yaw) in units of radians.
             can use createYawRotationMatrix(theta[2])
 
 see also, pp 479-480, eqn (285) of Shuster 1993, "A Survey of AttitudeRepresentations"
 http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf
 though the matrices are transposed from these.
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler angles as representation of rotation matrix</dd>
<dd><code>output</code> - </dd>
</dl>
</li>
</ul>
<a id="createRotationZYX(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationZYX</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRotationZYX&#8203;(double[]&nbsp;thetas)</pre>
<div class="block">calculate  R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z)
 ,
 that is, given an array of rotation angles, return the rotation matrix
 as the rotations for z, y, x multiplied in that order.
 
 from https://en.wikipedia.org/wiki/Davenport_chained_rotations
 "Any extrinsic rotation is equivalent to an intrinsic rotation by the 
 same angles but with inverted order of elemental rotations, and vice 
 versa. For instance, the intrinsic rotations x-y’-z″ by angles α, β, γ 
 are equivalent to the extrinsic rotations z-y-x by angles γ, β, α."
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (18)
 
 where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
 

        = | (cos φ * cos ψ)   (-sin φ * cos θ + cos φ * sin ψ * sin θ)   (sin φ * sin θ + cos φ * sin ψ * cos θ)   |
          | (sin φ * cos ψ)   ( cos φ * cos θ + sin φ * sin ψ * sin θ)   (-cos φ * sin θ + sin φ * sin ψ * cos θ)  |
          | (-sin ψ)          ( cos ψ * sin θ )                          (cos ψ * cos θ)                           |
          
       =  | (cosZ * cosY)   (-sinZ * cosX + cosZ * sinY * sinX)   (sinZ * sinX + cosZ * sinY * cosX)   |
          | (sinZ * cosY)   ( cosZ * cosX + sinZ * sinY * sinX)   (-cosZ * sinX + sinZ * sinY * cosX)  |
          | (-sinY)          ( cosY * sinX )                       (cosY * cosX)                       |
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thetas</code> - euler angles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createRotationZYX(double[],algorithms.imageProcessing.transform.Rotation.AuxiliaryArrays,double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationZYX</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;createRotationZYX&#8203;(double[]&nbsp;thetas,
                                     <a href="Rotation.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">Rotation.AuxiliaryArrays</a>&nbsp;aa,
                                     double[][]&nbsp;out)</pre>
<div class="block">given an array of euler rotation angles, return the rotation matrix
 as the rotations for z, y, x multiplied in that order.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (18)
 
 where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thetas</code> - euler rotation angles</dd>
<dd><code>aa</code> - auxiliary arrays used for internal calculations.  they're
 meant to reduce object creation and are created by the invoking code.</dd>
<dd><code>out</code> - the output rotation matrix values.</dd>
</dl>
</li>
</ul>
<a id="createHamiltonQuaternionZYX(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createHamiltonQuaternionZYX</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createHamiltonQuaternionZYX&#8203;(double[]&nbsp;thetas)</pre>
<div class="block">calculate  the Hamilton quaternion which would be extracted from the
 rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).
 
 from https://en.wikipedia.org/wiki/Davenport_chained_rotations
 "Any extrinsic rotation is equivalent to an intrinsic rotation by the 
 same angles but with inverted order of elemental rotations, and vice 
 versa. For instance, the intrinsic rotations x-y’-z″ by angles α, β, γ 
 are equivalent to the extrinsic rotations z-y-x by angles γ, β, α."
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (18)
 
 where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
 

        = | (cos φ * cos ψ)   (-sin φ * cos θ + cos φ * sin ψ * sin θ)   (sin φ * sin θ + cos φ * sin ψ * cos θ)   |
          | (sin φ * cos ψ)   ( cos φ * cos θ + sin φ * sin ψ * sin θ)   (-cos φ * sin θ + sin φ * sin ψ * cos θ)  |
          | (-sin ψ)          ( cos ψ * sin θ )                          (cos ψ * cos θ)                           |
          
       =  | (cosZ * cosY)   (-sinZ * cosX + cosZ * sinY * sinX)   (sinZ * sinX + cosZ * sinY * cosX)   |
          | (sinZ * cosY)   ( cosZ * cosX + sinZ * sinY * sinX)   (-cosZ * sinX + sinZ * sinY * cosX)  |
          | (-sinY)          ( cosY * sinX )                       (cosY * cosX)                       |
           
     given angle theta and axis n:
         q = [scalar, vector] = [
             cos(theta/2), nx*sin(theta/2), ny*sin(theta/2), nz*sin(theta/2)];
          
     given euler angles:
         q1 =  sin(z/2)*sin(y/2)*sin(x/2) + cos(z/2)*cos(y/2)*cos(x/2)
         q2 = -sin(z/2)*sin(y/2)*cos(x/2) + sin(x/2)*cos(z/2)*cos(y/2)
         q3 =  sin(z/2)*sin(x/2)*cos(y/2) + sin(y/2)*cos(z/2)*cos(x/2)
         q4 =  sin(z/2)*cos(y/2)*cos(x/2) - sin(y/2)*sin(x/2)*cos(z/2)
     
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thetas</code> - euler rotation angles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createHamiltonQuaternionZYX(double,double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createHamiltonQuaternionZYX</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createHamiltonQuaternionZYX&#8203;(double&nbsp;angle,
                                                   double[]&nbsp;axis)</pre>
<div class="block">calculate  the Hamilton quaternion which would be extracted from the
 rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).
 
 from https://en.wikipedia.org/wiki/Davenport_chained_rotations
 "Any extrinsic rotation is equivalent to an intrinsic rotation by the 
 same angles but with inverted order of elemental rotations, and vice 
 versa. For instance, the intrinsic rotations x-y’-z″ by angles α, β, γ 
 are equivalent to the extrinsic rotations z-y-x by angles γ, β, α."
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (18)
 
 where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
 

        = | (cos φ * cos ψ)   (-sin φ * cos θ + cos φ * sin ψ * sin θ)   (sin φ * sin θ + cos φ * sin ψ * cos θ)   |
          | (sin φ * cos ψ)   ( cos φ * cos θ + sin φ * sin ψ * sin θ)   (-cos φ * sin θ + sin φ * sin ψ * cos θ)  |
          | (-sin ψ)          ( cos ψ * sin θ )                          (cos ψ * cos θ)                           |
          
       =  | (cosZ * cosY)   (-sinZ * cosX + cosZ * sinY * sinX)   (sinZ * sinX + cosZ * sinY * cosX)   |
          | (sinZ * cosY)   ( cosZ * cosX + sinZ * sinY * sinX)   (-cosZ * sinX + sinZ * sinY * cosX)  |
          | (-sinY)          ( cosY * sinX )                       (cosY * cosX)                       |
           
     given angle theta and axis n:
         q = [scalar, vector] = 
             [cos(theta/2), nx*sin(theta/2), ny*sin(theta/2), nz*sin(theta/2)];
          
     given euler angles:
         q1 =  sin(z/2)*sin(y/2)*sin(x/2) + cos(z/2)*cos(y/2)*cos(x/2)
         q2 = -sin(z/2)*sin(y/2)*cos(x/2) + sin(x/2)*cos(z/2)*cos(y/2)
         q3 =  sin(z/2)*sin(x/2)*cos(y/2) + sin(y/2)*cos(z/2)*cos(x/2)
         q4 =  sin(z/2)*cos(y/2)*cos(x/2) - sin(y/2)*sin(x/2)*cos(z/2)

     This is what is used in eqn (2.40) of "An Invitation to 3-D Vision",
     Ma, Soatto, Kosecka, and Sastry (MASKS).
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - </dd>
<dd><code>axis</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="convertHamiltonToBarfootQuaternionInPlace(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertHamiltonToBarfootQuaternionInPlace</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;convertHamiltonToBarfootQuaternionInPlace&#8203;(double[]&nbsp;qHamilton)</pre>
<div class="block">convert the quaternion from [scalar vector] to [vector scalar] in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>qHamilton</code> - quaternion of format [scalar  vector]</dd>
</dl>
</li>
</ul>
<a id="convertHamiltonToBarfootQuaternion(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertHamiltonToBarfootQuaternion</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;convertHamiltonToBarfootQuaternion&#8203;(double[]&nbsp;qHamilton)</pre>
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>qHamilton</code> - quaternion of format [scalar  vector]</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>convert the quaternion from [scalar vector] to [vector scalar]</dd>
</dl>
</li>
</ul>
<a id="createRotationXYZ(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationXYZ</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRotationXYZ&#8203;(double[]&nbsp;thetas)</pre>
<div class="block">given an array of euler rotation angles, return the rotation matrix
 as the rotations for x, y, z multiplied in that order.
 
     TODO: consider whether this should be using the Shuster equations
     as R_xyz = R_x(theta_x)*R_y(theta_y)*R_z(theta_z) which is transposed
     from the Z*Y*X operation.
      <pre>
      
      where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
         
      from Appendix A of 
        "Euler Angles and Quaternions and Transformations", NASA Mission Planning
         and Analysis Division, 1977, Shuttle Program.
         
      R_X(theta_X)*R_Y(theta_Y)*R_Z(theta_Z) 
        = |  cosY*cosZ                      -cosY*sinZ                    sinY       |
          |  sinX*sinY*cosZ + cosX*sinZ     -sinX*sinY*sinZ + cosX*cosZ   -sinX*cosY |
          |  -cosX*sinY*cosZ + sinX*sinZ     cosX*sinY*sinZ + sinX*cosZ   cosX*cosY  |
         
      </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thetas</code> - euler rotation angles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="createUnitLengthQuaternionBarfoot(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createUnitLengthQuaternionBarfoot</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createUnitLengthQuaternionBarfoot&#8203;(double[]&nbsp;unitLengthAxis,
                                                         double&nbsp;angle)</pre>
</li>
</ul>
<a id="createUnitLengthQuaternionHamilton(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createUnitLengthQuaternionHamilton</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createUnitLengthQuaternionHamilton&#8203;(double[]&nbsp;unitLengthAxis,
                                                          double&nbsp;angle)</pre>
</li>
</ul>
<a id="createRotationFromUnitLengthAngleAxis(double[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationFromUnitLengthAngleAxis</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRotationFromUnitLengthAngleAxis&#8203;(double[]&nbsp;unitLengthAxis,
                                                               double&nbsp;angle)</pre>
<div class="block"><pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (14)
     C(axis, angle) = cos(angle)*I + (1-cos(angle))*axis*axis^T - sin(angle)*[axis]_x

    
    satisfies unit-length constraint q^T*q = 1  (size [1X4]*[4X1]=[1X1].
    q^T*q = q_1^2 + q_2^2 + q_3^2 + q_4^2.
    </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>unitLengthAxis</code> - </dd>
<dd><code>angle</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="applyRotationPerturbationToQuaternion(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyRotationPerturbationToQuaternion</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;applyRotationPerturbationToQuaternion&#8203;(double[]&nbsp;theta,
                                                             double[]&nbsp;dTheta)</pre>
<div class="block">apply perturbation dTheta to quaternion formed from euler rotation angles
 theta.
 To the first order, this is a constraint-sensitive approach.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (45) and (44).
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler rotation angles</dd>
<dd><code>dTheta</code> - rotation perturbation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the resulting quaternion formed from theta and perturbed by dTheta.  [4X1]</dd>
</dl>
</li>
</ul>
<a id="quaternionPrincipalAxisRotation(double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>quaternionPrincipalAxisRotation</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;quaternionPrincipalAxisRotation&#8203;(double&nbsp;angle,
                                                       int&nbsp;principalAxis)</pre>
</li>
</ul>
<a id="createQuaternionZYXFromEuler(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createQuaternionZYXFromEuler</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createQuaternionZYXFromEuler&#8203;(double[]&nbsp;eulerXYZ)</pre>
<div class="block">create a rotation quaternion from Euler x, y, z angles.
 note that the rotation order of multiplication operations is z, y, x.
 
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (37)
     q(euler) = q_z(euler_z)^+ * q_y(euler_y)^+ + q_x(euler_x) 
 
     and principal axis rotations in eqn (35)
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>eulerXYZ</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>[4X1] quaternion rotation vector.</dd>
</dl>
</li>
</ul>
<a id="createRotationFromQuaternion(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationFromQuaternion</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createRotationFromQuaternion&#8203;(double[]&nbsp;theta)</pre>
<div class="block">create the rotation matrix from quaternions formed by the euler rotation
 angles theta.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (37)
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler rotation angles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>rotation matrix [3X3].</dd>
</dl>
</li>
</ul>
<a id="createRotationVector(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRotationVector</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;createRotationVector&#8203;(double[]&nbsp;theta,
                                            double[]&nbsp;dTheta)</pre>
<div class="block">create the rotation vector dPhi = S(theta) * dTheta
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 text under eqn (26)
    dPhi= S(theta) * dTheta
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler rotation angles</dd>
<dd><code>dTheta</code> - perturbation to apply to rotation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>dPhi= S(theta) * dTheta.  length is 3.</dd>
</dl>
</li>
</ul>
<a id="createDeltaQ(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDeltaQ</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;createDeltaQ&#8203;(double[]&nbsp;theta,
                                      double[]&nbsp;dTheta)</pre>
<div class="block">create perturbation for a quaternion from a perturbation to euler
 rotation angles.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 part of eqn (45) and text under (26).
   | dPhi |^⨁
   |   1  |
      where dPhi = S(theta) * dTheta 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler rotation angles</dd>
<dd><code>dTheta</code> - rotation perturbation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>perturbation for a quaternion.  [4X4].</dd>
</dl>
</li>
</ul>
<a id="applySingularitySafeRotationPerturbationQuaternion(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applySingularitySafeRotationPerturbationQuaternion</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;applySingularitySafeRotationPerturbationQuaternion&#8203;(double[]&nbsp;theta,
                                                                          double[]&nbsp;dTheta)</pre>
<div class="block">create a unit-length quaternion update of the quaternion formed
 from the euler rotation angles theta by the perturbation dTheta.
 To the first order, this is a constraint-sensitive approach.
 <pre>
 from Barfoot, Forbes, & Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (49)
    q(theta + perturbation) = q(dPhi)^⨁ * q(theta)
        where dPhi = S(theta) * dTheta
 
 "This update approach allows us to store and update the rotation as a 
 unit-length quaternion, thereby avoiding singularities and the need to 
 restore the constraint afterwards (i.e., constraint restoration is 
 built in)."
 
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theta</code> - euler rotation angles</dd>
<dd><code>dTheta</code> - perturbation to apply to rotation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>resulting quaternion from perturbation applied to quaternion 
 formed from theta euler angles.</dd>
</dl>
</li>
</ul>
<a id="orthonormalizeUsingSVD(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orthonormalizeUsingSVD</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;orthonormalizeUsingSVD&#8203;(double[][]&nbsp;r)
                                         throws no.uib.cipr.matrix.NotConvergedException</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="orthonormalizeUsingSkewCayley(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orthonormalizeUsingSkewCayley</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;orthonormalizeUsingSkewCayley&#8203;(double[][]&nbsp;r)
                                                throws no.uib.cipr.matrix.NotConvergedException</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="cay(double[][])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>cay</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;cay&#8203;(double[][]&nbsp;r)
                      throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">orthogonalize matrix R using skew parameters via Cayley's formula.
 (I - A)*(I + A)^-1</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - a rotation matrix (i.e. a skew symmetric matrix A^T = A^-1)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>

<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) on Tue Jul 29 11:59:29 PDT 2025 -->
<title>Rotation</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2025-07-29">
<meta name="description" content="declaration: package: algorithms.imageProcessing.transform, class: Rotation">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.7.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li>Field</li>
<li><a href="#constructor-summary">Constr</a></li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#constructor-detail">Constr</a></li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h1 title="Class Rotation" class="title">Class Rotation</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.imageProcessing.transform.Rotation</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">Rotation</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">a utility class holding rotations associated with euler angles,
 quaternions, and angle-axis representations (using rodrigues formula for the later).

 Note that this class focus is intrinsic and passive transformations.
 If one needs extrinsic operations, there are notes here, but it might be best to implement
 methods using Direct Cosine matrices.
 
 a rotation matrix describes a transformation in euclidean space.  it is a
 member of  special orthogonal group SO(n) where n is usually 3, but can
 be 4 for quaternion rotation matrix.  It has the properties R^T = R^−1 and det(R) = +-1.
 <pre>
   det(R)=1 is a proper rotation matrix.  rotation angles are counterclockwise.
       it's a special orthogonal matrix and provides the
       defining matrix representation of the group of proper n-dimensional rotations, denoted
       by SO(n). http://scipp.ucsc.edu/~haber/ph251/rotreflect_17.pdf
   det(R)=-1 is an improper rotation matrix representing rotations that
       require mirrors.
       The most general improper rotation matrix is a product of a proper rotation by an
       angle θ about some axis nˆ and a mirror reflection through a plane that passes through
       the origin and is perpendicular to nˆ.  NOTE: nˆ is determined by
       the right hand rule.
 </pre>
 This Rotation.java class uses "passive" Euler rotations of vectors counterclockwise in a right-handed
 coordinate system (y counterclockwise from x) by pre-multiplication 
 (R on the left) unless otherwise specified.
 If any one of these is changed (such as rotating axes
 instead of vectors, a "active" transformation), then the inverse of the
 example matrix should be used, which coincides with its transpose.
 e.g. (A*B*C)^-1 = (C^-1) * (B^-1) * (A^-1).

 see wikipedia article "Active and Passive Transformations"

 active rotations (a.k.a. alibi transformations):
     the reference frame stays fixed and the object of interest moves. The rotation is of the object being described.
     These are clockwise rotations (left hand system) of the object of interest about the fixed reference system origin .
     active rotations are the historical system used.

 passive rotations (a.k.a. alias transformations):
     the reference frame (coordinate system) is rotated and the object of interest stays fixed.
     These are counterclockwise rotations (right hand system) of the reference frame about its own
     origin while the object of interest says fixed.
     An example use is that from the perspective of being inside a plane - the inertial reference frame appears to move
     with the opposite rotation.  This system is used when we are describing the motion of the object we are in and
     controlling.

 an active rotation R(theta) is equivalent to the passive rotation R(-theta) which is R^T.

 active transformations are often used for multiple maneuvers of a body.

 <b><ul>RIGHT HAND SYSTEM</ul></b>
 The equations in this section use a right hand system (== passive transformations, CCW rotations of the object while
 reference frame is fixed).
 The right hand system is consistent with methods in physics, engineering,
 and computer science in general.  The <b>Hamilton quaternion</b> is consistent
 with the right hand system and has format [scalar vector].
 The NASA 1977 publication and Szeliski 2010
    define a quaternion as (qw, qx, qy, qz) where qw is a scalar and
 [qx, qy, qz] is a vector.   That is the Hamilton Quaternion format.
 
 In contrast, Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.)
 define a quaternion as (qx, qy, qz, qw), scalar last.
 One might need to transform some properties to quaternions and then modify 
 the placement of the scalar term in order
 to compare results with other "Hamilton" "Right hand" system results with scalar first format.
 The Barfoot equations use active left-hand rule system and a "scalar last" format.
         
 <pre>
 R(q) = | (w^2 + x^2 - y^2 - z^2)  2(xy - wz)               2(xz + wy)               |
        | 2(xy + wz)               w^2 - x^2 + y^2 - z^2)   2(yz - wx)               |
        | 2(xz - wy)               2(yz + wx)               (w^2 - x^2 - y^2  + z^2) |
 rewritten 
 R(q) = | 1-2*(y^2 + z^2)   2(xy - zw)       2(xz + yw)      |
        | 2(xy + zw)        1-2(x^2 + z^2)   2(yz - xw)      |
        | 2(xz - yw)        2(yz + xw)       1-2(x^2 + y^2)  |
 </pre>
 Quaternions can be derived from the axis/angle representation through the 
 formula q = (v, w) = (sin(theta)*n_hat,cos(theta)),
 where n_hat and theta are the rotation axis and angle.

 passive, CCW rotations (right hand system) of the reference frame about its own
 origin while the object of interest says fixed.
     rotation about z-axis (yaw):    about the y-axis (pitch):     about x-axis (roll):
                | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |
                | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |
                |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |
     Note that in the java methods below, the documentation should specify whether active or passive are used.

 applications of quaternions are intrinsic or extrinsic.

 intrinsic:
    apply transformation to the axis of the rotated coordinate reference frame (a.k.a. body frame).
    expresses F_w relative to F_b (F_b-&gt;F_w).
    vec_c = R_{b-&gt;c} * (R_{a-&gt;b} * vec_a) = R_{a-&gt;c} * vec_a
    The Barfoot et al. paper and book uses intrinsic.

 extrinsic:
    apply transformation to the axis in the World Coordinate reference frame.
    expresses F_b relative to F_w (F_w-&gt;F_b).
    Direct Cosine Matrices (DCM) used in extrinsic operations...

 The skew symmetric matrix (implemented in MatrixUtil.skewSymmetric(), is:
 [v]_x = |  0  -z   y |
         |  z   0  -x |
         | -y   x   0 |

 Its opposite is the anti-symmetric matrix and is equal to -1 * skewSymmetric:
 [[v]] = |  0   z  -y |
         | -z   0   x |
         |  y  -x   0 |

 From Shuster we have properties of the skew symmetric matrix (as -1 * anti-sym matrix [[v]]).
 <pre>
 let [u]_x be the skew symmetric of u and [v]_x be the skew-symmetric of v.
     where u and v are column vectors.

     -[u]_x * v = [v]_x * u

     -[u]_x * u = 0

     [u]_x = [ -[u]_x ]^T

     -[u]_x * -[v]_x = (u dot v) * I + v * u^T where '*' is matrix multiplication as usual.
     [u]_x * [v]_x = (u dot v) * I + v * u^T

     [u]_x * [v]_x - [v]_x * [u]_x = v * u^T - u*v^T = [u cross v]]_x

     u * v^T * -[w]_x + -[w]_x * v * u^T = -[u cross (v cross w)]_x
           where the later, triple cross product is used in making the Fundamental Matrix
           of photogrammetry, for example.
            implemented in MatrixUtil.tripleProduct() using a shorter form from Boas.
 </pre>

 Eigen, ROS, and Google Ceres use Hamilton convention (active, LH, CCW rotations of object in fixed reference frame).
  Also  Wolfram Mathematica, Matlab’s aerospace(!) and robotics toolbox, 
  Boost, GNU Octave, NASA’s SPICE.

Note that Shuster 1993 use the active, LH, CW rotations of the object while reference frame is fixed.
        about z-axis (yaw):           about the y-axis (pitch):    about x-axis (roll): 
            | cos φ    sin φ    0 |    |  cos ψ    0 -sin ψ |      |    1       0       0 |  
            |-sin φ    cos φ    0 |    |      0    1      0 |      |    0   cos θ   sin θ |  
            |     0        0    1 |    |  sin ψ    0  cos ψ |      |    0  -sin θ   cos θ |
 Note that in the java methods below, the documentation should specify whether active or passive are used.


 <pre>
 Some references in the right hand systems:

 "Euler Angles and Quaternions and Transformations", NASA Mission Planning
  and Analysis Division, 1977, Shuttle Program.

  Szeleski 2010

  Shuster 1993, "A Survey of Attitude Representations"
    Journal of Astronautical Sciences, Vol 41, No. 4, Oct-Dec 1993, pp 439-517
    http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf

  "Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors"
   James Diebel, 2006
 </pre>
 
 <pre><b><ul>LEFT HAND SYSTEM</ul></b></pre>
 A left hand system, in contrast, is used by aerospace engineering and
 aerospace medicine to describe the z-axis as pointing downwards (in the 
 direction of gravity w.r.t. a geo-centric system.)
 
 Chapter 4, "Human Response to Acceleration" by Banks, Brinkly, Allnut, and Harding
    in "Fundamentals of Aerospace Medicine"
    Excerpt:
    "For example, the Advisory Group for Aerospace
    Research and Development (AGARD) standard for human
    acceleration differs from the AGARD standard for aircraft
    design (in which the z-acceleration axis is reversed and
    positive downward).
        ...consistent with the AGARD standard (1), the
    Table of Equivalents for Acceleration Terminology (2), the
    Aviation Space and Environmental Medicine Standard (3),
    and the majority of the Aerospace Medicine literature, the
    positive direction of each of these axes is here described by
    ‘‘the left-hand rule.’’   That is, the x-axis dimension is an arrow
     with the positive direction forward, the y-axis dimension has
    the positive direction rightward, and"

  <pre>

 Rotations about the same axis are additive.

 Regarding rotation axes and perspectives:
     https://en.wikipedia.org/wiki/Rotation_matrix#Ambiguities
     The coordinates of a point P may change due to either a rotation of the 
     coordinate system CS (alias), or a rotation of the point P (alibi). 
     In the latter case, the rotation of P also produces a rotation of the 
     vector v representing P. In other words, either P and v are fixed while 
     CS rotates (alias), or CS is fixed while P and v rotate (alibi). Any 
     given rotation can be legitimately described both ways, as vectors and 
     coordinate systems actually rotate with respect to each other, about the 
     same axis but in opposite directions. Throughout this article, we chose the 
     alibi approach to describe rotations. For instance, 
        R(theta)= | cos(theta)  -sin(theta) |
                  | sin(theta)   cos(theta) |
     represents a counterclockwise rotation of a vector v by an angle θ, or a 
     rotation of the coordinate system (CS) by the same angle but in the opposite direction 
     (i.e. clockwise). Alibi and alias transformations are also known as active 
     and passive transformations, respectively.
 
     Pre-multiplication or post-multiplication
         The same point P can be represented either by a column vector v or a 
         row vector w. Rotation matrices can either pre-multiply column vectors 
         (Rv), or post-multiply row vectors (wR). However, Rv produces a 
         rotation in the opposite direction with respect to wR. 
         Throughout this article, rotations produced on column vectors are 
         described by means of a pre-multiplication. To obtain exactly the same 
         rotation (i.e. the same final coordinates of point P), the equivalent 
         row vector must be post-multiplied by the transpose of R (i.e. wR^T).

 skew symmetric of vector v is [v]_x:
       |    0   -v[2]  v[1]  |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]    0    |

    e^(i*theta) = cos(theta) + i*sin(theta)

    exponential of a matrix is expanded via power series:  e^A = I + A + (higher order terms AA/2! + AAA/3!...)

    for A = | 0  -1 |
            | 1   0 |

    e^(A*t) = |  cos(t)  -sin(t)  |  through diagonalizing A
              |  sin(t)   cos(t)  |

    for A being skew symmetric: |  0  -z  y |
                                |  z   0 -x |
                                | -y   x  0 |
    e^(A*theta) = I + A*sin(theta) +A^2*(1 - cos(theta))


    R_axis = exp(-[e_axis]_x*theta_axis)

    R_x = exp(-[1,0,0]_x * theta_x) = exp( 0  0  0 )*theta_x )
                                           0  0  1
                                           0 -1  0

   terms used describing axes of rotation, attitude or orientation:
        heading, attitude, bank,
        pitch, yaw, roll,
        pan, tilt, roll

   A rotation can be represented by a rotation axis nˆ and an angle ω,
   or equivalently by a 3D vector ω = θ*nˆ
   to project vector v onto the axis nˆ:
      v_parallel = nˆ*(nˆ· v) = (nˆ*nˆ^T)*v and this is not affected by rotation
      v_perpendicular = v - v_parallel
                      = (I - nˆ*nˆ^T)*v
   can rotate v by 90 degrees using the cross product:
      nˆ cross v = [nˆ]_x * v
      where [nˆ]_x is the skew-symmetric matrix of nˆ

   can rotate v by 180 degrees:
      nˆ cross (nˆ cross v) = ([nˆ]_x)^2 * v = -v_perpendicular
   which shows that can also write
      v_parallel = (I + ([nˆ]_x)^2 * v)

 examples transforming sequences:
     passive A(a)*B(b)*C(c)
     active A(-a)*B(-b)*C(-c)
                   = A(a)^T * B(b)^T * C(c)^T
                   = (C(c) * B(b) * C(c))^T

     intrinsic ABC = extrinsic CBA

     example:
        from scipy.spatial.transform import Rotation as R
        R.from_euler('XYZ', [-0.1, -0.2, -0.3]).as_matrix()
        array([[ 0.93629336,  0.28962948, -0.19866933],
               [-0.27509585,  0.95642509,  0.0978434 ],
               [ 0.21835066, -0.03695701,  0.97517033]])
        R.from_euler('xyz', [0.1, 0.2, 0.3]).inv().as_matrix()
        array([[ 0.93629336,  0.28962948, -0.19866933],
               [-0.27509585,  0.95642509,  0.0978434 ],
               [ 0.21835066, -0.03695701,  0.97517033]])
 </pre>

 see Barfoot et al.
 see http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/

 <pre>
  also note that for optimization of rotation :
      prefer to update the rotation vectors and/or the rotation matrices.
      do not update the euler angles because eqn (28) of Barfoot et al. shows that an inverse term
      is not defined at singularities.
      do not extract euler angles or vector from a rotation matrix unless unavoidable because the
      extraction is ambiguous.
      the create rotation matrix from rotation vector or from euler angles is fine.
 </pre></div>
<dl class="notes">
<dt>Author:</dt>
<dd>nichole</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="Rotation.AuxiliaryArrays.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">Rotation.AuxiliaryArrays</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static enum&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="Rotation.EulerSequence.html" class="type-name-link" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a></code></div>
<div class="col-last odd-row-color">
<div class="block">types of Euler rotation sequences implemented in this class for the Barfoot quaternion
 equations.</div>
</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="Rotation.RodriguesRotation.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="Rotation.RotationPerturbation.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="Rotation.RotationPerturbationMatrix.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbationMatrix</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="Rotation.RotationPerturbationQuaternion.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbationQuaternion</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">Rotation</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>protected static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#_applySingularitySafeRotationPerturbation(double%5B%5D%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">_applySingularitySafeRotationPerturbation</a><wbr>(double[][]&nbsp;rTheta,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Apply the perturbation dTheta to rotation matrix theta and
 return the perturbed rotation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#_extractRotationVectorFromQuaternionBarfoot(double%5B%5D)" class="member-name-link">_extractRotationVectorFromQuaternionBarfoot</a><wbr>(double[]&nbsp;q)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#_log(double%5B%5D)" class="member-name-link">_log</a><wbr>(double[]&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the quaternion logarithm in scalar last fomat and return result in scala last format.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#_quaternionDivide(double%5B%5D,double%5B%5D,boolean)" class="member-name-link">_quaternionDivide</a><wbr>(double[]&nbsp;q1,
 double[]&nbsp;q2,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate q1 divided by q2 for quaternions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Rotation.RotationPerturbation.html" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#applySingularitySafeRotationPerturbation(double%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence,boolean)" class="member-name-link">applySingularitySafeRotationPerturbation</a><wbr>(double[]&nbsp;theta0,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq,
 boolean&nbsp;returnQuaternion)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Apply a perturbation dTheta to the rotation matrix represented by euler angles theta0
 and return the result as a quaternion in Barfoot format or as a rotation matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Rotation.RotationPerturbation.html" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#applySingularitySafeRotationPerturbation(algorithms.imageProcessing.transform.Rotation.RotationPerturbation,double%5B%5D)" class="member-name-link">applySingularitySafeRotationPerturbation</a><wbr>(<a href="Rotation.RotationPerturbation.html" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a>&nbsp;state,
 double[]&nbsp;dTheta)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Apply a perturbation dTheta to the given rotation matrix or quaternion and return the updated perturbed data
 structure.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#cay(double%5B%5D%5B%5D)" class="member-name-link">cay</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">orthogonalize matrix R using skew parameters via Cayley's formula.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertQuaternionBarfootToHamilton(double%5B%5D)" class="member-name-link">convertQuaternionBarfootToHamilton</a><wbr>(double[]&nbsp;qBarfoot)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#convertQuaternionHamiltonToBarfoot(double%5B%5D)" class="member-name-link">convertQuaternionHamiltonToBarfoot</a><wbr>(double[]&nbsp;qHamilton)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createAngleAxisFromEulerAnglesXYZ(double%5B%5D,double%5B%5D)" class="member-name-link">createAngleAxisFromEulerAnglesXYZ</a><wbr>(double[]&nbsp;eulerXYZ,
 double[]&nbsp;outAxis)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the eulerXYZ angles to angle axis representation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createAngleAxisFromRotationVector(double%5B%5D,double%5B%5D)" class="member-name-link">createAngleAxisFromRotationVector</a><wbr>(double[]&nbsp;rV,
 double[]&nbsp;outRAxis)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createIdentityQuaternion()" class="member-name-link">createIdentityQuaternion</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">return the identity quaternion</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionBarfootFromAPoint(double%5B%5D)" class="member-name-link">createQuaternionBarfootFromAPoint</a><wbr>(double[]&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionBarfootFromEuler(double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">createQuaternionBarfootFromEuler</a><wbr>(double[]&nbsp;eulerXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create a rotation quaternion from Euler x, y, z angles.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionBarfootFromHamilton(double%5B%5D)" class="member-name-link">createQuaternionBarfootFromHamilton</a><wbr>(double[]&nbsp;qHamilton)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionHamiltonFromAngleAxis(double,double%5B%5D)" class="member-name-link">createQuaternionHamiltonFromAngleAxis</a><wbr>(double&nbsp;angle,
 double[]&nbsp;axis)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate  the Hamilton unit-length quaternion which would be extracted from the
 rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionHamiltonFromBarfoot(double%5B%5D)" class="member-name-link">createQuaternionHamiltonFromBarfoot</a><wbr>(double[]&nbsp;qBarfoot)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionUnitLengthBarfoot(double,double%5B%5D)" class="member-name-link">createQuaternionUnitLengthBarfoot</a><wbr>(double&nbsp;angle,
 double[]&nbsp;unitLengthAxis)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionUnitLengthBarfootFromEuler(double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">createQuaternionUnitLengthBarfootFromEuler</a><wbr>(double[]&nbsp;eulerAnglesXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionUnitLengthBarfootFromEulerXYZ(double%5B%5D)" class="member-name-link">createQuaternionUnitLengthBarfootFromEulerXYZ</a><wbr>(double[]&nbsp;eulerAngles)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createQuaternionUnitLengthBarfootFromRotationVector(double%5B%5D)" class="member-name-link">createQuaternionUnitLengthBarfootFromRotationVector</a><wbr>(double[]&nbsp;rotVec)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotation4FromQuaternion(double%5B%5D)" class="member-name-link">createRotation4FromQuaternion</a><wbr>(double[]&nbsp;quaternion)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create a [4x4] rotation matrix from the given quaternion.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationFromEulerAngles(double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">createRotationFromEulerAngles</a><wbr>(double[]&nbsp;eulerXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>protected static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationInfSmallPerturbation(double%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">createRotationInfSmallPerturbation</a><wbr>(double[]&nbsp;theta0,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">first term in RHS of eqn (30b) in Barfoot et al.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationPitch(double)" class="member-name-link">createRotationPitch</a><wbr>(double&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix for rotation about the Y-axis, a.k.a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationPitch(double,boolean)" class="member-name-link">createRotationPitch</a><wbr>(double&nbsp;angle,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationPitch(double,double%5B%5D%5B%5D)" class="member-name-link">createRotationPitch</a><wbr>(double&nbsp;angle,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix for rotation about the Y-axis, a.k.a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationRodriguesBouguet(double%5B%5D,boolean)" class="member-name-link">createRotationRodriguesBouguet</a><wbr>(double[]&nbsp;rotVec,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the rotation matrix given the Rodrigues rotation vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationRodriguesFormula(double%5B%5D,boolean)" class="member-name-link">createRotationRodriguesFormula</a><wbr>(double[]&nbsp;rotVec,
 boolean&nbsp;passive)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given rotVec as an array of rotations about x, y, and z, calculate the
 rotation matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationRodriguesFormula(double%5B%5D,double,boolean)" class="member-name-link">createRotationRodriguesFormula</a><wbr>(double[]&nbsp;axis,
 double&nbsp;angle,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create a rotation axis using the Rodrigues formula.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationRoll(double)" class="member-name-link">createRotationRoll</a><wbr>(double&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix for rotation about the X-axis, a.k.a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationRoll(double,boolean)" class="member-name-link">createRotationRoll</a><wbr>(double&nbsp;angle,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationRoll(double,double%5B%5D%5B%5D)" class="member-name-link">createRotationRoll</a><wbr>(double&nbsp;angle,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix for rotation about the X-axis, a.k.a.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationVectorBarfoot(double%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">createRotationVectorBarfoot</a><wbr>(double[]&nbsp;eulerAngles,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create the rotation vector dPhi = S(eulerAngles) * dTheta</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationVectorFromAngleAxis(double%5B%5D,double)" class="member-name-link">createRotationVectorFromAngleAxis</a><wbr>(double[]&nbsp;axis,
 double&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create rotation vector, given angle axis after making the angle axis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationVectorFromEulerAngles(double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">createRotationVectorFromEulerAngles</a><wbr>(double[]&nbsp;eulerXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationVectorFromEulerAnglesXYZ(double%5B%5D)" class="member-name-link">createRotationVectorFromEulerAnglesXYZ</a><wbr>(double[]&nbsp;euler)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the euler angles to angle axis representation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationXYZ(double,double,double)" class="member-name-link">createRotationXYZ</a><wbr>(double&nbsp;angleX,
 double&nbsp;angleY,
 double&nbsp;angleZ)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate R(angle_z, angle_y, angle_x) = R_x(angle_x)*R_y(angle_y)*R_z(angle_z).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationXYZ(double,double,double,boolean)" class="member-name-link">createRotationXYZ</a><wbr>(double&nbsp;angleX,
 double&nbsp;angleY,
 double&nbsp;angleZ,
 boolean&nbsp;passive)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationYaw(double)" class="member-name-link">createRotationYaw</a><wbr>(double&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix for rotation about the Z-axis, a.k.a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationYaw(double,boolean)" class="member-name-link">createRotationYaw</a><wbr>(double&nbsp;angle,
 boolean&nbsp;passive)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationYaw(double,double%5B%5D%5B%5D)" class="member-name-link">createRotationYaw</a><wbr>(double&nbsp;angle,
 double[][]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create matrix for rotation about the Z-axis, a.k.a.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationZYX(double,double,double)" class="member-name-link">createRotationZYX</a><wbr>(double&nbsp;eulerX,
 double&nbsp;eulerY,
 double&nbsp;eulerZ)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate  R_zyx = (R_z(theta_x)*R_y(theta_y))*R_x(theta_z)
 where theta_x = eulerZYX[0], theta_y=eulerZYX[1], theta_z=eulerZYX[2].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationZYX(double,double,double,boolean)" class="member-name-link">createRotationZYX</a><wbr>(double&nbsp;angleX,
 double&nbsp;angleY,
 double&nbsp;angleZ,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createRotationZYX(double,double,double,algorithms.imageProcessing.transform.Rotation.AuxiliaryArrays,double%5B%5D%5B%5D)" class="member-name-link">createRotationZYX</a><wbr>(double&nbsp;eulerX,
 double&nbsp;eulerY,
 double&nbsp;eulerZ,
 <a href="Rotation.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">Rotation.AuxiliaryArrays</a>&nbsp;aa,
 double[][]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate  R_zyx = (R_z(theta_x)*R_y(theta_y))*R_x(theta_z)
 where theta_x = thetas[0], theta_y=thetas[1], theta_z=thetas[2].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#distanceBetweenQuaternions(double%5B%5D,double%5B%5D)" class="member-name-link">distanceBetweenQuaternions</a><wbr>(double[]&nbsp;q1,
 double[]&nbsp;q2)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the distance metric between quaternions, using vector inner product</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#distanceUsingRigidBodyDisplacements(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">distanceUsingRigidBodyDisplacements</a><wbr>(double[][]&nbsp;r1,
 double[][]&nbsp;r2,
 boolean&nbsp;useFrobenius)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">estimate the</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractRotationAxisFromZXY(double%5B%5D%5B%5D)" class="member-name-link">extractRotationAxisFromZXY</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract the euler rotation angles from the given rotation matrix assumed
 to be a result of R_yxz = R_z(theta_z) * R_x(theta_x) * R_y(theta_y)
 (aka 2-1-3 angle set?).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractRotationVectorRodrigues(double%5B%5D%5B%5D)" class="member-name-link">extractRotationVectorRodrigues</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">another method to extract the Rodrigues vector (angle and axis)
 from the given
 rotation matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractRotationVectorRodriguesBouguet(double%5B%5D%5B%5D)" class="member-name-link">extractRotationVectorRodriguesBouguet</a><wbr>(double[][]&nbsp;rotation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the Rodrigues rotation vector from the given rotation matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractThetaFromXYZ(double%5B%5D%5B%5D)" class="member-name-link">extractThetaFromXYZ</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractThetaFromXYZ(double%5B%5D%5B%5D,boolean)" class="member-name-link">extractThetaFromXYZ</a><wbr>(double[][]&nbsp;r,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract the euler angles from the XYZ rotation matrix</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractThetaFromXYZ(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">extractThetaFromXYZ</a><wbr>(double[][]&nbsp;r,
 double[]&nbsp;out)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractThetaFromZYX(double%5B%5D%5B%5D)" class="member-name-link">extractThetaFromZYX</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_xyz =  R(theta_Z) * R(theta_Y) * R(theta_X)
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractThetaFromZYX(double%5B%5D%5B%5D,boolean)" class="member-name-link">extractThetaFromZYX</a><wbr>(double[][]&nbsp;r,
 boolean&nbsp;passive)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractThetaFromZYX(double%5B%5D%5B%5D,double%5B%5D)" class="member-name-link">extractThetaFromZYX</a><wbr>(double[][]&nbsp;r,
 double[]&nbsp;out)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R(theta_Z) * R(theta_Y) * R(theta_X).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#inverseQuaternionBarfoot(double%5B%5D)" class="member-name-link">inverseQuaternionBarfoot</a><wbr>(double[]&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">return the inverse of the quaternion (multiplies the vector portion by -1).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#makeUnitLengthAngleAxis(double,double%5B%5D)" class="member-name-link">makeUnitLengthAngleAxis</a><wbr>(double&nbsp;angle,
 double[]&nbsp;axis)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the axis, angle pair into unit length axis, angle pair.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#orthonormalizeUsingSkewCayley(double%5B%5D%5B%5D)" class="member-name-link">orthonormalizeUsingSkewCayley</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#orthonormalizeUsingSVD(double%5B%5D%5B%5D)" class="member-name-link">orthonormalizeUsingSVD</a><wbr>(double[][]&nbsp;r)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#procrustesAlgorithmForRotation(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">procrustesAlgorithmForRotation</a><wbr>(double[][]&nbsp;x1,
 double[][]&nbsp;x2)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">determine the rotation between measurements x1 and x2 when both datasets
 have the same center, that is, there is no translation between them,
 only rotation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionConjugateOperator(double%5B%5D)" class="member-name-link">quaternionConjugateOperator</a><wbr>(double[]&nbsp;quaternion)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a quaternion, return the inverse
 (symbol is superscript -1).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionGeodesicNorm(double%5B%5D,double%5B%5D)" class="member-name-link">quaternionGeodesicNorm</a><wbr>(double[]&nbsp;q0,
 double[]&nbsp;q1)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calc geodesic distance (shortest path along a great arc) between 2 unit-length quaternions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionLefthandCompoundOperator(double%5B%5D)" class="member-name-link">quaternionLefthandCompoundOperator</a><wbr>(double[]&nbsp;quaternion)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a quaternion of Barfoot format [vector scalar], form the left-hand compound operator
 (symbol is superscript +)</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionMultiply(double%5B%5D,double%5B%5D,boolean)" class="member-name-link">quaternionMultiply</a><wbr>(double[]&nbsp;q1,
 double[]&nbsp;q2,
 boolean&nbsp;passive)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">multiply quaternions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionPrincipalAxisRotation(double,int)" class="member-name-link">quaternionPrincipalAxisRotation</a><wbr>(double&nbsp;angle,
 int&nbsp;principalAxis)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionRighthandCompoundOperator(double%5B%5D)" class="member-name-link">quaternionRighthandCompoundOperator</a><wbr>(double[]&nbsp;quaternion)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a quaternion, form the right-hand compound operator:
 (symbol is superscript ⨁)</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#quaternionSlerp(double%5B%5D,double%5B%5D,double,boolean)" class="member-name-link">quaternionSlerp</a><wbr>(double[]&nbsp;q0,
 double[]&nbsp;q1,
 double&nbsp;angleFraction,
 boolean&nbsp;passive)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the rotation that is angleFraction of the distance between q0 and q1 using spherical linear
 interpolation (slerp).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rotateAPointByQuaternionBarfoot(double%5B%5D,double%5B%5D)" class="member-name-link">rotateAPointByQuaternionBarfoot</a><wbr>(double[]&nbsp;q,
 double[]&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">rotate a point x to a new frame</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rotateVectorByQuaternion4(double%5B%5D,double%5B%5D)" class="member-name-link">rotateVectorByQuaternion4</a><wbr>(double[]&nbsp;quaternion,
 double[]&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">rotate point p by the given quaternion.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#rotationBetweenTwoDirections0(double%5B%5D,double%5B%5D,boolean)" class="member-name-link">rotationBetweenTwoDirections0</a><wbr>(double[]&nbsp;v1,
 double[]&nbsp;v2,
 boolean&nbsp;passive)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the rotation needed to transform direction v1 to direction v2 using
 a quaternion.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sTheta(double%5B%5D,double%5B%5D%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">sTheta</a><wbr>(double[]&nbsp;eulerAngles,
 double[][]&nbsp;output,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate S_theta which is the matrix relating angular velocity to 
 rotation angle rates.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#sTheta(double%5B%5D,algorithms.imageProcessing.transform.Rotation.EulerSequence)" class="member-name-link">sTheta</a><wbr>(double[]&nbsp;eulerAngles,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate S_theta which is the matrix relating angular velocity to
 rotation angle rates.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>Rotation</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">Rotation</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="createRotationXYZ(double,double,double)">
<h3>createRotationXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationXYZ</span><wbr><span class="parameters">(double&nbsp;angleX,
 double&nbsp;angleY,
 double&nbsp;angleZ)</span></div>
<div class="block">calculate R(angle_z, angle_y, angle_x) = R_x(angle_x)*R_y(angle_y)*R_z(angle_z).
 The internal composition follows passive (right hand), CCW rotations
 with order of operations ((R(X) * R(Y)) * R(Z)), that is left to right,
 intrinsic composition.

 If the context is aeronautical, you may want to use createRotationZYX instead.

 <pre>
     This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angleX</code> - angle of rotation about x-axis (roll) in units of radians.</dd>
<dd><code>angleY</code> - angle of rotation about y-axis (pitch) in units of radians.</dd>
<dd><code>angleZ</code> - angle of rotation about z-axis (yaw) in units of radians.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationXYZ(double,double,double,boolean)">
<h3>createRotationXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationXYZ</span><wbr><span class="parameters">(double&nbsp;angleX,
 double&nbsp;angleY,
 double&nbsp;angleZ,
 boolean&nbsp;passive)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationZYX(double,double,double,boolean)">
<h3>createRotationZYX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationZYX</span><wbr><span class="parameters">(double&nbsp;angleX,
 double&nbsp;angleY,
 double&nbsp;angleZ,
 boolean&nbsp;passive)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationRoll(double)">
<h3>createRotationRoll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationRoll</span><wbr><span class="parameters">(double&nbsp;angle)</span></div>
<div class="block">create matrix for rotation about the X-axis, a.k.a. roll in passive system (right-hand system, CCW).
       <pre>
       about x-axis (roll):       
       |    1       0       0 |  
       |    0   cos θ  -sin θ |  
       |    0   sin θ   cos θ | 
       </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - angle of rotation about x-axis (roll) in units of radians.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationRoll(double,boolean)">
<h3>createRotationRoll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationRoll</span><wbr><span class="parameters">(double&nbsp;angle,
 boolean&nbsp;passive)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationRoll(double,double[][])">
<h3>createRotationRoll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">createRotationRoll</span><wbr><span class="parameters">(double&nbsp;angle,
 double[][]&nbsp;out)</span></div>
<div class="block">create matrix for rotation about the X-axis, a.k.a. roll.
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
       <pre>
       about x-axis (roll):       
       |    1       0       0 |  
       |    0   cos θ  -sin θ |  
       |    0   sin θ   cos θ | 
       </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - angle of rotation about x-axis (roll) in units of radians.</dd>
<dd><code>out</code> - holds values for rotation matrix for roll.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationPitch(double)">
<h3>createRotationPitch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationPitch</span><wbr><span class="parameters">(double&nbsp;angle)</span></div>
<div class="block">create matrix for rotation about the Y-axis, a.k.a. pitch in passive system (right-hand, CCW).
      <pre>
      about the y-axis (pitch):
      |  cos ψ    0  sin ψ |
      |      0    1      0 |
      | -sin ψ    0  cos ψ |
      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - angle of rotation about y-axis (pitch) in units of radians.  Euler notation
              uses the right-hand rule for rotations.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationPitch(double,boolean)">
<h3>createRotationPitch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationPitch</span><wbr><span class="parameters">(double&nbsp;angle,
 boolean&nbsp;passive)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationPitch(double,double[][])">
<h3>createRotationPitch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">createRotationPitch</span><wbr><span class="parameters">(double&nbsp;angle,
 double[][]&nbsp;out)</span></div>
<div class="block">create matrix for rotation about the Y-axis, a.k.a. pitch.
     This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
      <pre>
      about the y-axis (pitch):
      |  cos ψ    0  sin ψ |
      |      0    1      0 |
      | -sin ψ    0  cos ψ |
      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - angle of rotation about y-axis (pitch) in units of radians.</dd>
<dd><code>out</code> - holds values for rotation matrix for pitch</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationYaw(double)">
<h3>createRotationYaw</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationYaw</span><wbr><span class="parameters">(double&nbsp;angle)</span></div>
<div class="block">create matrix for rotation about the Z-axis, a.k.a. yaw in passive system (right-hand system, CCW).
      <pre>
        about z-axis (yaw):          
            | cos φ   -sin φ    0 | 
            | sin φ    cos φ    0 | 
            |     0        0    1 | 
      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - angle of rotation about z-axis (yaw) in units of radians.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationYaw(double,boolean)">
<h3>createRotationYaw</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationYaw</span><wbr><span class="parameters">(double&nbsp;angle,
 boolean&nbsp;passive)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationYaw(double,double[][])">
<h3>createRotationYaw</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">createRotationYaw</span><wbr><span class="parameters">(double&nbsp;angle,
 double[][]&nbsp;out)</span></div>
<div class="block">create matrix for rotation about the Z-axis, a.k.a. yaw.
     This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
      <pre>
        about z-axis (yaw):          
            | cos φ   -sin φ    0 | 
            | sin φ    cos φ    0 | 
            |     0        0    1 | 
      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - angle of rotation about z-axis (yaw) in units of radians.</dd>
<dd><code>out</code> - results for a rotation matrix for yaw.  size given to method 
 must be 3X3.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rotationBetweenTwoDirections0(double[],double[],boolean)">
<h3>rotationBetweenTwoDirections0</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">rotationBetweenTwoDirections0</span><wbr><span class="parameters">(double[]&nbsp;v1,
 double[]&nbsp;v2,
 boolean&nbsp;passive)</span></div>
<div class="block">calculate the rotation needed to transform direction v1 to direction v2 using
 a quaternion.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v1</code> - </dd>
<dd><code>v2</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createAngleAxisFromRotationVector(double[],double[])">
<h3>createAngleAxisFromRotationVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">createAngleAxisFromRotationVector</span><wbr><span class="parameters">(double[]&nbsp;rV,
 double[]&nbsp;outRAxis)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationVectorFromAngleAxis(double[],double)">
<h3>createRotationVectorFromAngleAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createRotationVectorFromAngleAxis</span><wbr><span class="parameters">(double[]&nbsp;axis,
 double&nbsp;angle)</span></div>
<div class="block">create rotation vector, given angle axis after making the angle axis.
 NOTE: for best results, make the angle axis pair unit length first, by using"
 angle = Rotation.makeUnitLengthAngleAxis(angle, axis);</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>axis</code> - </dd>
<dd><code>angle</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationVectorFromEulerAnglesXYZ(double[])">
<h3>createRotationVectorFromEulerAnglesXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createRotationVectorFromEulerAnglesXYZ</span><wbr><span class="parameters">(double[]&nbsp;euler)</span>
                                                       throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">convert the euler angles to angle axis representation.
 NOTE that the resulting vector is the angle axis times the angle, so you can calculate:
     <pre>
     angle = ||result||
     and
     axis = result//angle
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>euler</code> - euler angles for [x, y, z]</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationFromEulerAngles(double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>createRotationFromEulerAngles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationFromEulerAngles</span><wbr><span class="parameters">(double[]&nbsp;eulerXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
</section>
</li>
<li>
<section class="detail" id="createRotationVectorFromEulerAngles(double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>createRotationVectorFromEulerAngles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createRotationVectorFromEulerAngles</span><wbr><span class="parameters">(double[]&nbsp;eulerXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span>
                                                    throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createAngleAxisFromEulerAnglesXYZ(double[],double[])">
<h3>createAngleAxisFromEulerAnglesXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">createAngleAxisFromEulerAnglesXYZ</span><wbr><span class="parameters">(double[]&nbsp;eulerXYZ,
 double[]&nbsp;outAxis)</span>
                                                throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">convert the eulerXYZ angles to angle axis representation.
 NOTE that the resulting vector is the angle axis times the angle, so you can calculate:
     <pre>
     angle = ||result||
     and
     axis = result//angle
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>eulerXYZ</code> - eulerXYZ angles for [x, y, z]</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationRodriguesFormula(double[],double,boolean)">
<h3>createRotationRodriguesFormula</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationRodriguesFormula</span><wbr><span class="parameters">(double[]&nbsp;axis,
 double&nbsp;angle,
 boolean&nbsp;passive)</span></div>
<div class="block">create a rotation axis using the Rodrigues formula.  Note that internally,
 the unit-length angle axis pair is first calculated and then used in the Rodrigues formula.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>axis</code> - </dd>
<dd><code>angle</code> - </dd>
<dd><code>passive</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationRodriguesFormula(double[],boolean)">
<h3>createRotationRodriguesFormula</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationRodriguesFormula</span><wbr><span class="parameters">(double[]&nbsp;rotVec,
 boolean&nbsp;passive)</span></div>
<div class="block">given rotVec as an array of rotations about x, y, and z, calculate the
 rotation matrix.  
 essentially, excepting a small angle correction:
     R^⊤ = cosθ*I + sinθ*[rotVec]_× + (1−cosθ)*rotVec*rotVec^⊤

 NOTE: if computing the partial derivative of Rotation elsewhere, 
 can use d(R(ω)*rotVec)/d(ω^T) = -[rotVec]_x (see Equation (2.35) of Szeliski 2010).
 Also note that a + sign in front of the sine(θ) term is used for the
 "passive" system of rotations.
 <pre>
 references:
    Dmitry Berenson https://github.com/robEllenberg/comps-plugins/blob/master/python/rodrigues.py
    Szeliski 2010 draft "Computer Vision: Algorithms and Applications"
    Rodriguez’s formula (Ayache 1989)
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rotVec</code> - [1x3] array of rotVec of rotations about x, y, and z</dd>
<dd><code>passive</code> - if true uses passive right-hand system of CCW rotation, else uses active left-hand CW rotations</dd>
<dt>Returns:</dt>
<dd>rotation matrix [3X3]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractRotationVectorRodriguesBouguet(double[][])">
<h3>extractRotationVectorRodriguesBouguet</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></span>&nbsp;<span class="element-name">extractRotationVectorRodriguesBouguet</span><wbr><span class="parameters">(double[][]&nbsp;rotation)</span>
                                                                        throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the Rodrigues rotation vector from the given rotation matrix.
 The method is ported from github repositories holding the Bouguet Matlab Toolbox code, rodrigues.m.

      <pre>
      The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
      and states that the source code is freely available.
      The github repositories with the forked Bouguet Matlab code do not have license
      information.

      https://github.com/fragofer/TOOLBOX_calib
      and
      https://github.com/hunt0r/Bouguet_cam_cal_toolbox

      rodrigues.m includes the comment: Copyright (c) March 1993 -- Pietro Perona, CalTech, before a brief
      changelist by Bouguet.
      </pre>
      Note that this is an ambiguous task.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rotation</code> - [3X3] rotation matrix</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationRodriguesBouguet(double[],boolean)">
<h3>createRotationRodriguesBouguet</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Rotation.RodriguesRotation.html" title="class in algorithms.imageProcessing.transform">Rotation.RodriguesRotation</a></span>&nbsp;<span class="element-name">createRotationRodriguesBouguet</span><wbr><span class="parameters">(double[]&nbsp;rotVec,
 boolean&nbsp;passive)</span></div>
<div class="block">calculate the rotation matrix given the Rodrigues rotation vector.
 The method is ported from github repositories holding the Bouguet Matlab Toolbox code, rodrigues.m.

 this is using passive transformations.

      <pre>
      The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
      and states that the source code is freely available.
      The github repositories with the forked Bouguet Matlab code do not have license
      information.

      https://github.com/fragofer/TOOLBOX_calib
      and
      https://github.com/hunt0r/Bouguet_cam_cal_toolbox

      rodrigues.m includes the comment: Copyright (c) March 1993 -- Pietro Perona, CalTech, before a brief
      changelist by Bouguet.

      </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rotVec</code> - [3X1] rotation vector</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="procrustesAlgorithmForRotation(double[][],double[][])">
<h3>procrustesAlgorithmForRotation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">procrustesAlgorithmForRotation</span><wbr><span class="parameters">(double[][]&nbsp;x1,
 double[][]&nbsp;x2)</span>
                                                 throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">determine the rotation between measurements x1 and x2 when both datasets
 have the same center, that is, there is no translation between them,
 only rotation.
 (see Golub <span class="invalid-tag">invalid input: '&amp;'</span> van Loan "Matrix Computations" 11.12.4,
 Szeliski 2010, Sect 6.1.5).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x1</code> - a set of measurements having same center as x2, that is,
 there is no translation between them, only rotation.
 the expected format is nData X nDimensions.</dd>
<dd><code>x2</code> - another set of measurements having same center as x1, that is,
 there is no translation between them, only rotation.
 the expected format is nData X nDimensions.</dd>
<dt>Returns:</dt>
<dd>difference in rotation between x2 and x1.  this will be ~ the identity matrix for no difference.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractRotationAxisFromZXY(double[][])">
<h3>extractRotationAxisFromZXY</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractRotationAxisFromZXY</span><wbr><span class="parameters">(double[][]&nbsp;r)</span></div>
<div class="block">extract the euler rotation angles from the given rotation matrix assumed
 to be a result of R_yxz = R_z(theta_z) * R_x(theta_x) * R_y(theta_y)
 (aka 2-1-3 angle set?).
 Note, this way of extracting of the angles is 
 ambiguous (there are more than one angle combination sets that will
       result in the same matrix).
     <pre>
     the method is from equation (37) from 
     lecture notes of Gordon Wetzstein at Stanford University,
     EE 267 Virtual Reality, "Course Notes: 6-DOF Pose Tracking with the VRduino",
     https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf

     It uses the passive, right-hand, CCW transformations system.

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - rotation matrix assumed
 to be a result of R_yxz = R_z(theta_z)  * R_x(theta_x) * R_y(theta_y).</dd>
<dt>Returns:</dt>
<dd>theta_x, theta_y, theta_z
 which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractThetaFromZYX(double[][])">
<h3>extractThetaFromZYX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractThetaFromZYX</span><wbr><span class="parameters">(double[][]&nbsp;r)</span></div>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_xyz =  R(theta_Z) * R(theta_Y) * R(theta_X)
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - ZYX rotation matrix</dd>
<dt>Returns:</dt>
<dd>array of theta_x, theta_y, theta_z
 which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractThetaFromZYX(double[][],boolean)">
<h3>extractThetaFromZYX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractThetaFromZYX</span><wbr><span class="parameters">(double[][]&nbsp;r,
 boolean&nbsp;passive)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - ZYX rotation matrix</dd>
<dd><code>passive</code> - </dd>
<dt>Returns:</dt>
<dd>array of theta_x, theta_y, theta_z
     which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractThetaFromZYX(double[][],double[])">
<h3>extractThetaFromZYX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">extractThetaFromZYX</span><wbr><span class="parameters">(double[][]&nbsp;r,
 double[]&nbsp;out)</span></div>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R(theta_Z) * R(theta_Y) * R(theta_X).
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - </dd>
<dd><code>out</code> - output variable to hold theta_x, theta_y, and theta_z,
 which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractThetaFromXYZ(double[][])">
<h3>extractThetaFromXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractThetaFromXYZ</span><wbr><span class="parameters">(double[][]&nbsp;r)</span></div>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - </dd>
<dt>Returns:</dt>
<dd>euler [theta_X, theta_Y, theta_Z] angles extracted from the rotation matrix under assumption
 that the rotation matrix was constructed with multiplication order
 R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
 theta_x, theta_y, and theta_z, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractThetaFromXYZ(double[][],boolean)">
<h3>extractThetaFromXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractThetaFromXYZ</span><wbr><span class="parameters">(double[][]&nbsp;r,
 boolean&nbsp;passive)</span></div>
<div class="block">extract the euler angles from the XYZ rotation matrix</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - </dd>
<dd><code>passive</code> - </dd>
<dt>Returns:</dt>
<dd>Euler angles in order X, Y, Z</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractThetaFromXYZ(double[][],double[])">
<h3>extractThetaFromXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">extractThetaFromXYZ</span><wbr><span class="parameters">(double[][]&nbsp;r,
 double[]&nbsp;out)</span></div>
<div class="block">extract euler rotation angles from a rotation matrix which has been built following
 the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - </dd>
<dd><code>out</code> - output array of size 3 used to place euler angles extracted 
 from the rotation matrix under assumption
 that the rotation matrix was constructed with multiplication order
 R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="extractRotationVectorRodrigues(double[][])">
<h3>extractRotationVectorRodrigues</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">extractRotationVectorRodrigues</span><wbr><span class="parameters">(double[][]&nbsp;r)</span>
                                               throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">another method to extract the Rodrigues vector (angle and axis)
 from the given
 rotation matrix.  it's an ambiguous task.

 The rotations are by default passive transformations.

     <pre>
     the method is from  
     lecture notes of Pradit Mittrapiyanuruk at Perdue University,
     ECE 661 Robot Vision Laboratory,
     https://engineering.purdue.edu/kak/computervision/ECE661_Fall2012/homework/hw5_LM_handout.pdf
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - rotation matrix</dd>
<dt>Returns:</dt>
<dd>Rodriques vector.  the axis and angle representation from this
 can be constructed as angle of rotation = r_vec/||r_vec|| and angle = ||r_vec||
 where r_vec is the rodrigues vector.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="distanceBetweenQuaternions(double[],double[])">
<h3>distanceBetweenQuaternions</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">distanceBetweenQuaternions</span><wbr><span class="parameters">(double[]&nbsp;q1,
 double[]&nbsp;q2)</span></div>
<div class="block">calculate the distance metric between quaternions, using vector inner product
    <pre>
    eqn (19) of J Math Imaging Vis (2009) 35: 155–164 DOI 10.1007/s10851-009-0161-2
    Metrics for 3D Rotations: Comparison and Analysis Du Q. Huynh
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q1</code> - a quaternion</dd>
<dd><code>q2</code> - another quaternion</dd>
<dt>Returns:</dt>
<dd>distance metric between 2 quaternions.  the range of 
 values will be [0,π/2] (radians).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="distanceUsingRigidBodyDisplacements(double[][],double[][],boolean)">
<h3>distanceUsingRigidBodyDisplacements</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">distanceUsingRigidBodyDisplacements</span><wbr><span class="parameters">(double[][]&nbsp;r1,
 double[][]&nbsp;r2,
 boolean&nbsp;useFrobenius)</span>
                                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">estimate the
 <pre>
     reference:
     Huynh 2009, J Math Imaging Vis, 35, 155-164, eqn (21)
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r1</code> - a 3X3 rotation matrix</dd>
<dd><code>r2</code> - a 3X3 rotation matrix</dd>
<dd><code>useFrobenius</code> - if true, uses Frobenius norm internally, else uses the spectral norm.</dd>
<dt>Returns:</dt>
<dd>return the distance defined as ∥ I − r1 * r2 ∥_F if useFrobenius is true.
 In that case the distance is within the range [0, 2sqrt(2)].
 If useFrobenius is false, the result is spectralNorm(I − r1 * r2) which results in a distance in the range [0, 2].</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="quaternionLefthandCompoundOperator(double[])">
<h3>quaternionLefthandCompoundOperator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">quaternionLefthandCompoundOperator</span><wbr><span class="parameters">(double[]&nbsp;quaternion)</span></div>
<div class="block">given a quaternion of Barfoot format [vector scalar], form the left-hand compound operator
 (symbol is superscript +)
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (2):
 given q = 4X1 column vector of [eps eta] where eta is the scalar,
 and "1" is a 3X3 identity matrix, also written as I_3.
 and [eps]_x is the skew-symetric matrix for vector eps.
 
 The left-hand compound operator is a 4X4 matrix:
 
 q^+ = [ eta*I_3-[eps]_x   eps ]  // | [3X3]  [3X1] |
       [ -eps^T           eta ]   // | [1X3]  [1X1] |
 
 multiplication of quaternions, u and v, which is typically written 
 as u ⊗ v may be written equivalently as either
         u^+ v or v^⨁ u,
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="quaternionRighthandCompoundOperator(double[])">
<h3>quaternionRighthandCompoundOperator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">quaternionRighthandCompoundOperator</span><wbr><span class="parameters">(double[]&nbsp;quaternion)</span></div>
<div class="block">given a quaternion, form the right-hand compound operator:
 (symbol is superscript ⨁)
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (2):
 given q = 4X1 column vector of [eps eta] where eta is the scalar,
 and "1" is a 3X3 identity matrix, also written as I_3.
 and [q]_x is the skew-symetric matrix for q.
 
 The right-hand compound operator is a 4X4 matrix:
 
 q^⨁ = [ eta*I_3+[q]_x   eps ]
        [ -eps^T          eta ]
 
 multiplication of quaternions, u and v, which is typically written 
 as u ⊗ v may be written equivalently as either
         u^+ v or v^⨁ u,
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dt>Returns:</dt>
<dd>[4X4]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_quaternionDivide(double[],double[],boolean)">
<h3>_quaternionDivide</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">_quaternionDivide</span><wbr><span class="parameters">(double[]&nbsp;q1,
 double[]&nbsp;q2,
 boolean&nbsp;passive)</span></div>
<div class="block">calculate q1 divided by q2 for quaternions.
 The method implements q1 * q2.conjugate().
 Note that for the Barfoot system use passive = false;</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q1</code> - </dd>
<dd><code>q2</code> - </dd>
<dd><code>passive</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="quaternionSlerp(double[],double[],double,boolean)">
<h3>quaternionSlerp</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">quaternionSlerp</span><wbr><span class="parameters">(double[]&nbsp;q0,
 double[]&nbsp;q1,
 double&nbsp;angleFraction,
 boolean&nbsp;passive)</span></div>
<div class="block">calculate the rotation that is angleFraction of the distance between q0 and q1 using spherical linear
 interpolation (slerp).
     <pre>
     References:
     Szeliski, 2010, "Computer Vision: Algorithms and Applications", Algorithm 2.1
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q0</code> - </dd>
<dd><code>q1</code> - </dd>
<dd><code>angleFraction</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="quaternionGeodesicNorm(double[],double[])">
<h3>quaternionGeodesicNorm</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">quaternionGeodesicNorm</span><wbr><span class="parameters">(double[]&nbsp;q0,
 double[]&nbsp;q1)</span></div>
<div class="block">calc geodesic distance (shortest path along a great arc) between 2 unit-length quaternions.
 == half the angle subtended by q0 and q1 along a great arc of the S3 sphere
     <pre>
     references
     http://en.wikipedia.org/wiki/Quaternion

     https://github.com/KieranWynn/pyquaternion/blob/master/pyquaternion/quaternion.py#L800
     who use MIT license:
     https://github.com/KieranWynn/pyquaternion/blob/master/LICENSE.txt
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q0</code> - a unit-length quaternion with scalar last term (Barfoot quaternion)</dd>
<dd><code>q1</code> - a unit length quaternion with scalar last term (Barfoot quaternion)</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="_log(double[])">
<h3>_log</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">_log</span><wbr><span class="parameters">(double[]&nbsp;q)</span></div>
<div class="block">calculate the quaternion logarithm in scalar last fomat and return result in scala last format.
     <pre>
     reference:
     adapted from the pyquaternion project which uses MIT license.
     https://github.com/KieranWynn/pyquaternion/blob/master/LICENSE.txt
     who reference:
      [Source](https://math.stackexchange.com/questions/2552/the-logarithm-of-quaternion/2554#2554) for more details.
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - a quaternion in scalar last format</dd>
<dt>Returns:</dt>
<dd>A quaternion amount representing log(q) := (log(|q|), v/|v|acos(w/|q|))</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="quaternionConjugateOperator(double[])">
<h3>quaternionConjugateOperator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">quaternionConjugateOperator</span><wbr><span class="parameters">(double[]&nbsp;quaternion)</span></div>
<div class="block">given a quaternion, return the inverse
 (symbol is superscript -1).
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (5):
 given q = 4X1 column vector of [eps eta] where eta is the scalar,
 
 the inverse is the column vector:
 
 q^-1 = [ -eps  eta ]
 
 </pre>
 <em>NOTE that if the quaternion is a unit-length quaternion, the conjugate
 operation is usually called the inverse operation.</em></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="rotateAPointByQuaternionBarfoot(double[],double[])">
<h3>rotateAPointByQuaternionBarfoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">rotateAPointByQuaternionBarfoot</span><wbr><span class="parameters">(double[]&nbsp;q,
 double[]&nbsp;x)</span></div>
<div class="block">rotate a point x to a new frame
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

 eqn (11):

 v3 = [ p ]
      [ 0 ]

  rotated = q^+ * q^(-1)^⨁ * v3 = R*v3

  where R is the canonical 3X3 rotation matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - </dd>
<dd><code>x</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="quaternionMultiply(double[],double[],boolean)">
<h3>quaternionMultiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">quaternionMultiply</span><wbr><span class="parameters">(double[]&nbsp;q1,
 double[]&nbsp;q2,
 boolean&nbsp;passive)</span></div>
<div class="block">multiply quaternions.  Note for the Barfoot system, use passive = false</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q1</code> - </dd>
<dd><code>q2</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionBarfootFromAPoint(double[])">
<h3>createQuaternionBarfootFromAPoint</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionBarfootFromAPoint</span><wbr><span class="parameters">(double[]&nbsp;x)</span></div>
</section>
</li>
<li>
<section class="detail" id="inverseQuaternionBarfoot(double[])">
<h3>inverseQuaternionBarfoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">inverseQuaternionBarfoot</span><wbr><span class="parameters">(double[]&nbsp;q)</span></div>
<div class="block">return the inverse of the quaternion (multiplies the vector portion by -1).
 Note that for unit-length quaternions,Barfoot et al. refer to the conjugate as the inverse.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createIdentityQuaternion()">
<h3>createIdentityQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createIdentityQuaternion</span>()</div>
<div class="block">return the identity quaternion
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049,
 near eqn (8): 
 
 creates identity element: [0 0 0 1]
 
 </pre></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>4X1 column vector of [eps eta] where eta is the scalar, specifically
 [0, 0, 0, 1]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotation4FromQuaternion(double[])">
<h3>createRotation4FromQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotation4FromQuaternion</span><wbr><span class="parameters">(double[]&nbsp;quaternion)</span></div>
<div class="block">create a [4x4] rotation matrix from the given quaternion.
     <pre>
       Note, the first [3X3] block is transposed compared to results 
           from Rotation.createRotationZYX(eulerAngles)
       where 
       double[] qHamilton = Rotation.createQuaternionHamiltonFromAngleAxis(eulerAngles);
       double[] quaternion = Rotation.createQuaternionBarfootFromHamilton(qHamilton);

      Note that the Hamilton systems uses passive (right-hand) transformations and the Barfoot system uses active
      (left-hand) transformations, so this method uses active transformations.

     This method's results are consistent with Shuster 1993.
 The method follows Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

 eqn (12):
 
  R = q^+ * q^(-1)^⨁ = q^(-1)^⨁ * q^+ = q^(⨁)^T * q^+
    
    = [ C   0 ]
      [ 0^T 1 ]
 where C is the canonical 3X3 rotation matrix.
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>quaternion</code> - rotation as a [4X1] column vector of [eps eta] where eta is the scalar
                   (i.e. Barfoot format)</dd>
<dt>Returns:</dt>
<dd>a 4x4 rotation matrix whose 3X3 block at [0:2, 0:2] is the rotation matrix.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rotateVectorByQuaternion4(double[],double[])">
<h3>rotateVectorByQuaternion4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">rotateVectorByQuaternion4</span><wbr><span class="parameters">(double[]&nbsp;quaternion,
 double[]&nbsp;p)</span></div>
<div class="block">rotate point p by the given quaternion.
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (11):
 
 v3 = [ p ]
      [ 0 ]
 
  rotated = q^+ * q^(-1)^⨁ * v3 = R*v3
 
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>quaternion</code> - 4X1 column vector of [eps eta] where eta is the scalar</dd>
<dd><code>p</code> - the vector as a 3 element array followed by a 0, = [4X1].</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="sTheta(double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>sTheta</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">sTheta</span><wbr><span class="parameters">(double[]&nbsp;eulerAngles,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
<div class="block">calculate S_theta which is the matrix relating angular velocity to
 rotation angle rates.

     The method uses intrinsic, active transformations.

 TODO: consider overloading for more rotation sequences.
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

 eqn (21):
 calc C = 3X3 rotation matrix (often written as R)
 given array of euler rotation angles alpha, beta, gamma

 s_theta column 0 = C_gamma(eulerAngles[2]) * C_beta(eulerAngles[1]) * [1, 0, 0]^T
         column 1 = C_gamma(eulerAngles[2]) * [0, 1, 0]^T
         column 2 = [0, 0, 1]^T

             C_gamma                        C_beta                            C_alpha
      cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |
  eulerAngles[0] = angleX angle of rotation about x-axis (roll) in units of radians.
             can use createRotationRoll(eulerAngles[0])
  eulerAngles[1] = angleY angle of rotation about y-axis (pitch) in units of radians.
             can use createRotationPitch(eulerAngles[1])
  eulerAngles[2] = angleZ angle of rotation about z-axis (yaw) in units of radians.
             can use createRotationYaw(eulerAngles[2])

 see also, pp 479-480, eqn (285) of Shuster 1993, "A Survey of AttitudeRepresentations"
 http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf
 though the sign conventions of the sine terms are different

 </pre>
 This method uses active (left-hand system) transformations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>eulerAngles</code> - euler X,Y,Z angles as representation of rotation matrix</dd>
<dd><code>seq</code> - Euler sequence in use</dd>
<dt>Returns:</dt>
<dd>[3X3]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sTheta(double[],double[][],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>sTheta</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">sTheta</span><wbr><span class="parameters">(double[]&nbsp;eulerAngles,
 double[][]&nbsp;output,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
<div class="block">calculate S_theta which is the matrix relating angular velocity to 
 rotation angle rates.
 The method uses intrinsic, active transformations.

 TODO: consider overloading for more rotation sequences.

 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
       eqn (21)

     the book "State Estimation for Robotics", 2nd edition, by Barfoot
     page 271, eqn (7.51), (7.52):
 
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>eulerAngles</code> - euler angles as representation of rotation matrix</dd>
<dd><code>output</code> - </dd>
<dd><code>seq</code> - euler sequence in use</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationZYX(double,double,double)">
<h3>createRotationZYX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationZYX</span><wbr><span class="parameters">(double&nbsp;eulerX,
 double&nbsp;eulerY,
 double&nbsp;eulerZ)</span></div>
<div class="block">calculate  R_zyx = (R_z(theta_x)*R_y(theta_y))*R_x(theta_z)
 where theta_x = eulerZYX[0], theta_y=eulerZYX[1], theta_z=eulerZYX[2].
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
 This method uses "intrinsic" composition.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>R_zyx intrinsic</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationZYX(double,double,double,algorithms.imageProcessing.transform.Rotation.AuxiliaryArrays,double[][])">
<h3>createRotationZYX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">createRotationZYX</span><wbr><span class="parameters">(double&nbsp;eulerX,
 double&nbsp;eulerY,
 double&nbsp;eulerZ,
 <a href="Rotation.AuxiliaryArrays.html" title="class in algorithms.imageProcessing.transform">Rotation.AuxiliaryArrays</a>&nbsp;aa,
 double[][]&nbsp;out)</span></div>
<div class="block">calculate  R_zyx = (R_z(theta_x)*R_y(theta_y))*R_x(theta_z)
 where theta_x = thetas[0], theta_y=thetas[1], theta_z=thetas[2].
 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
 This method uses "intrinsic" composition.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>aa</code> - auxiliary arrays to use as space for intermediate calculations</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionHamiltonFromAngleAxis(double,double[])">
<h3>createQuaternionHamiltonFromAngleAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionHamiltonFromAngleAxis</span><wbr><span class="parameters">(double&nbsp;angle,
 double[]&nbsp;axis)</span></div>
<div class="block">calculate  the Hamilton unit-length quaternion which would be extracted from the
 rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).

 This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.

 from https://en.wikipedia.org/wiki/Davenport_chained_rotations
 "Any extrinsic rotation is equivalent to an intrinsic rotation by the 
 same angles but with inverted order of elemental rotations, and vice 
 versa. For instance, the intrinsic rotations x-y’-z″ by angles α, β, γ 
 are equivalent to the extrinsic rotations z-y-x by angles γ, β, α."
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (18)
 
 where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
 

        = | (cos φ * cos ψ)   (-sin φ * cos θ + cos φ * sin ψ * sin θ)   (sin φ * sin θ + cos φ * sin ψ * cos θ)   |
          | (sin φ * cos ψ)   ( cos φ * cos θ + sin φ * sin ψ * sin θ)   (-cos φ * sin θ + sin φ * sin ψ * cos θ)  |
          | (-sin ψ)          ( cos ψ * sin θ )                          (cos ψ * cos θ)                           |

       =  | (cosZ * cosY)   (-sinZ * cosX + cosZ * sinY * sinX)   (sinZ * sinX + cosZ * sinY * cosX)   |
          | (sinZ * cosY)   ( cosZ * cosX + sinZ * sinY * sinX)   (-cosZ * sinX + sinZ * sinY * cosX)  |
          | (-sinY)          ( cosY * sinX )                       (cosY * cosX)                       |

     given angle theta and axis n:
         q = [scalar, vector] = 
             [cos(theta/2), nx*sin(theta/2), ny*sin(theta/2), nz*sin(theta/2)];

     given euler angles:
         q1 =  sin(z/2)*sin(y/2)*sin(x/2) + cos(z/2)*cos(y/2)*cos(x/2)
         q2 = -sin(z/2)*sin(y/2)*cos(x/2) + sin(x/2)*cos(z/2)*cos(y/2)
         q3 =  sin(z/2)*sin(x/2)*cos(y/2) + sin(y/2)*cos(z/2)*cos(x/2)
         q4 =  sin(z/2)*cos(y/2)*cos(x/2) - sin(y/2)*sin(x/2)*cos(z/2)

     This is what is used in eqn (2.40) of "An Invitation to 3-D Vision",
     Ma, Soatto, Kosecka, and Sastry (MASKS).

     It is an intrinsic 'XYZ' format.
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - </dd>
<dd><code>axis</code> - </dd>
<dt>Returns:</dt>
<dd>the quaternion in format scalar as first term.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionBarfootFromHamilton(double[])">
<h3>createQuaternionBarfootFromHamilton</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionBarfootFromHamilton</span><wbr><span class="parameters">(double[]&nbsp;qHamilton)</span></div>
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].
 Barfoot uses intrinsic, active transformations with scalar last format.
 Hamilton uses intrinsic with scalar first format.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>qHamilton</code> - quaternion of format [scalar  vector]</dd>
<dt>Returns:</dt>
<dd>convert the quaternion from [scalar vector] to [vector scalar]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertQuaternionHamiltonToBarfoot(double[])">
<h3>convertQuaternionHamiltonToBarfoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">convertQuaternionHamiltonToBarfoot</span><wbr><span class="parameters">(double[]&nbsp;qHamilton)</span></div>
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].
 Barfoot uses intrinsic, active transformations with scalar last format.
 Hamilton uses intrinsic with scalar first format.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>qHamilton</code> - quaternion in Hamilton format that is converted to Barfoot format in place (modifying array)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertQuaternionBarfootToHamilton(double[])">
<h3>convertQuaternionBarfootToHamilton</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">convertQuaternionBarfootToHamilton</span><wbr><span class="parameters">(double[]&nbsp;qBarfoot)</span></div>
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].
 Barfoot uses intrinsic, active transformations with scalar last format.
 Hamilton uses intrinsic with scalar first format.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>qBarfoot</code> - quaternion in Barfoot format to be converted to Hamilton format in place (modifies array)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionHamiltonFromBarfoot(double[])">
<h3>createQuaternionHamiltonFromBarfoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionHamiltonFromBarfoot</span><wbr><span class="parameters">(double[]&nbsp;qBarfoot)</span></div>
<div class="block">convert the quaternion from [scalar vector] to [vector scalar].
 Barfoot uses intrinsic, active transformations with scalar last format.
 Hamilton uses intrinsic with scalar first format.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>qBarfoot</code> - quaternion of format [scalar  vector]</dd>
<dt>Returns:</dt>
<dd>convert the quaternion from [scalar vector] to [vector scalar]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionUnitLengthBarfoot(double,double[])">
<h3>createQuaternionUnitLengthBarfoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionUnitLengthBarfoot</span><wbr><span class="parameters">(double&nbsp;angle,
 double[]&nbsp;unitLengthAxis)</span></div>
</section>
</li>
<li>
<section class="detail" id="createQuaternionUnitLengthBarfootFromEulerXYZ(double[])">
<h3>createQuaternionUnitLengthBarfootFromEulerXYZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionUnitLengthBarfootFromEulerXYZ</span><wbr><span class="parameters">(double[]&nbsp;eulerAngles)</span>
                                                              throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionUnitLengthBarfootFromEuler(double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>createQuaternionUnitLengthBarfootFromEuler</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionUnitLengthBarfootFromEuler</span><wbr><span class="parameters">(double[]&nbsp;eulerAnglesXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span>
                                                           throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createQuaternionUnitLengthBarfootFromRotationVector(double[])">
<h3>createQuaternionUnitLengthBarfootFromRotationVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionUnitLengthBarfootFromRotationVector</span><wbr><span class="parameters">(double[]&nbsp;rotVec)</span></div>
</section>
</li>
<li>
<section class="detail" id="quaternionPrincipalAxisRotation(double,int)">
<h3>quaternionPrincipalAxisRotation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">quaternionPrincipalAxisRotation</span><wbr><span class="parameters">(double&nbsp;angle,
 int&nbsp;principalAxis)</span></div>
</section>
</li>
<li>
<section class="detail" id="createQuaternionBarfootFromEuler(double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>createQuaternionBarfootFromEuler</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createQuaternionBarfootFromEuler</span><wbr><span class="parameters">(double[]&nbsp;eulerXYZ,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
<div class="block">create a rotation quaternion from Euler x, y, z angles.
 note that the rotation order of multiplication operations is z, y, x.
 
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 eqn (37)
     q(euler) = q_z(euler_z)^+ * q_y(euler_y)^+ + q_x(euler_x) 
 
     and principal axis rotations in eqn (35)
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>eulerXYZ</code> - </dd>
<dt>Returns:</dt>
<dd>[4X1] quaternion rotation vector.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationVectorBarfoot(double[],double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>createRotationVectorBarfoot</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">createRotationVectorBarfoot</span><wbr><span class="parameters">(double[]&nbsp;eulerAngles,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
<div class="block">create the rotation vector dPhi = S(eulerAngles) * dTheta
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized 
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
 
 text under eqn (26)
    dPhi= S(eulerAngles) * dTheta
 
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>eulerAngles</code> - euler rotation angles</dd>
<dd><code>dTheta</code> - perturbation to apply to rotation</dd>
<dd><code>seq</code> - Euler sequence in use</dd>
<dt>Returns:</dt>
<dd>dPhi= S(eulerAngles) * dTheta.  length is 3.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applySingularitySafeRotationPerturbation(double[],double[],algorithms.imageProcessing.transform.Rotation.EulerSequence,boolean)">
<h3>applySingularitySafeRotationPerturbation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Rotation.RotationPerturbation.html" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a></span>&nbsp;<span class="element-name">applySingularitySafeRotationPerturbation</span><wbr><span class="parameters">(double[]&nbsp;theta0,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq,
 boolean&nbsp;returnQuaternion)</span>
                                                                              throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">Apply a perturbation dTheta to the rotation matrix represented by euler angles theta0
 and return the result as a quaternion in Barfoot format or as a rotation matrix.  The result also contains
 dPhi, the rotation vector, which can be used as an updatable state structure for future
 use that avoids the need to extract euler angles from a rotation quaternion or matrix.

 The scalar is the last term in the quaternion.  The rotation transformations are active and intrinsic.
     <pre>
     from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized
     rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

     rotation vector:
         dPhi = S(theta0) * dTheta

     eqn (29c)
          C(thetaResult) ~ C(theta0 + dTheta) ~ (I_3 - [dPhi]_x) * C(theta0)

     eqn (49)
        q(thetaResult) = q(theta0 + perturbation) = q(dPhi)^⨁ * q(theta0)

     "This update approach allows us to store and update the rotation as a
     unit-length quaternion, thereby avoiding singularities and the need to
     restore the constraint afterwards (i.e., constraint restoration is
     built in)."

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>theta0</code> - euler rotation angles used to define the rotation matrix that will
              be perturbed by dTheta.  The order of the angles in the array is X,Y,Z even
               if the seq used is not.
               In Barfoot paper eqn 26, this is theta with a bar over it.</dd>
<dd><code>dTheta</code> - the perturbation to apply to the rotation matrix as euler rotation angles
    must be small (cosine(dTheta[i]) ~ 1, sine(dTheta[i] ~ 0 or sine(dTheta[i])/i ~ 1).
     The order of the angles in the array is X,Y,Z even if the seq used is not.</dd>
<dd><code>seq</code> - Euler sequence</dd>
<dd><code>returnQuaternion</code> - if true, calculates the rotation quaternion and returns a datastructure holding it,
                         else if false, calculates the rotation matrix and returns a datastructure holding it.</dd>
<dt>Returns:</dt>
<dd>a data structure holding the resulting rotation matrix or quaternion, the EulerSequence, and the
 updatable rotation vector dPhi.  This returned data structure can be used in the overloaded
 applySingularitySafeRotationPerturbation.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applySingularitySafeRotationPerturbation(algorithms.imageProcessing.transform.Rotation.RotationPerturbation,double[])">
<h3>applySingularitySafeRotationPerturbation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Rotation.RotationPerturbation.html" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a></span>&nbsp;<span class="element-name">applySingularitySafeRotationPerturbation</span><wbr><span class="parameters">(<a href="Rotation.RotationPerturbation.html" title="class in algorithms.imageProcessing.transform">Rotation.RotationPerturbation</a>&nbsp;state,
 double[]&nbsp;dTheta)</span></div>
<div class="block">Apply a perturbation dTheta to the given rotation matrix or quaternion and return the updated perturbed data
 structure.

     <pre>
     from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized
     rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

     rotation vector:
         dPhi = S(theta0) * dTheta

     eqn (29c)
          C(thetaResult) ~ C(theta0 + dTheta) ~ (I_3 - [dPhi]_x) * C(theta0)

     eqn (49)
        q(thetaResult) = q(theta0 + perturbation) = q(dPhi)^⨁ * q(theta0)

     "This update approach allows us to store and update the rotation as a
     unit-length quaternion, thereby avoiding singularities and the need to
     restore the constraint afterwards (i.e., constraint restoration is
     built in)."

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>state</code> - data structure holding the current state rotation matrix or quaternion, the EulerSequence, and the
 current state updatable rotation vector dPhi.</dd>
<dd><code>dTheta</code> - the perturbation to apply to the rotation matrix as euler rotation angles
    must be small (cosine(dTheta[i]) ~ 1, sine(dTheta[i] ~ 0 or sine(dTheta[i])/i ~ 1).
     The order of the angles in the array is X,Y,Z even if the seq used is not.
     if the seq used is not.</dd>
<dt>Returns:</dt>
<dd>a data structure holding the resulting rotation matrix or quaternion, the EulerSequence, and the
 updatable rotation vector dPhi.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createRotationInfSmallPerturbation(double[],double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>createRotationInfSmallPerturbation</h3>
<div class="member-signature"><span class="modifiers">protected static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createRotationInfSmallPerturbation</span><wbr><span class="parameters">(double[]&nbsp;theta0,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
<div class="block">first term in RHS of eqn (30b) in Barfoot et al. paper.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>theta0</code> - euler angles representing current state.
  The order of the angles in the array is X,Y,Z even if the seq used is not.</dd>
<dd><code>dTheta</code> - euler angle perturbations.  The order of the angles in the array is X,Y,Z even if the seq used is not.</dd>
<dd><code>seq</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="_applySingularitySafeRotationPerturbation(double[][],double[],algorithms.imageProcessing.transform.Rotation.EulerSequence)">
<h3>_applySingularitySafeRotationPerturbation</h3>
<div class="member-signature"><span class="modifiers">protected static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">_applySingularitySafeRotationPerturbation</span><wbr><span class="parameters">(double[][]&nbsp;rTheta,
 double[]&nbsp;dTheta,
 <a href="Rotation.EulerSequence.html" title="enum class in algorithms.imageProcessing.transform">Rotation.EulerSequence</a>&nbsp;seq)</span></div>
<div class="block">Apply the perturbation dTheta to rotation matrix theta and
 return the perturbed rotation.
 The rotation transformations are active and intrinsic.
 <pre>
 from Barfoot, Forbes, <span class="invalid-tag">invalid input: '&amp;'</span> Furgale 2010, "Pose estimation using linearized
 rotations and quaternion algebra", Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

 eqn (26)
    C(theta2) ~ C(theta + dTheta) ~ (I_3 - [dPhi]_x) * C(theta)
    where C is for rotation matrix.

    (I_3 - [dPhi]_x) is effectively a rotation matrix, but is infinitesimally small.

 "This update approach allows us to store and update the rotation as a
 unit-length quaternion, thereby avoiding singularities and the need to
 restore the constraint afterwards (i.e., constraint restoration is
 built in)."

 </pre>
 NOTE: this method is not efficient, but is kept for use in tests.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>rTheta</code> - the current rotation matrix.  note that it should have been formed using intrinsic active ZYX.</dd>
<dd><code>dTheta</code> - the perturbation to apply to the rotation matrix as euler rotation angles
 must be small (cosine(dTheta[i]) ~ 1, sine(dTheta[i] ~ 0 or sine(dTheta[i])/i ~ 1).
               The order of the angles in the array is X,Y,Z even if the seq used is not.</dd>
<dt>Returns:</dt>
<dd>resulting quaternion from perturbation applied to quaternion
 formed from theta euler angles.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_extractRotationVectorFromQuaternionBarfoot(double[])">
<h3>_extractRotationVectorFromQuaternionBarfoot</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">_extractRotationVectorFromQuaternionBarfoot</span><wbr><span class="parameters">(double[]&nbsp;q)</span></div>
</section>
</li>
<li>
<section class="detail" id="orthonormalizeUsingSVD(double[][])">
<h3>orthonormalizeUsingSVD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">orthonormalizeUsingSVD</span><wbr><span class="parameters">(double[][]&nbsp;r)</span>
                                         throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="orthonormalizeUsingSkewCayley(double[][])">
<h3>orthonormalizeUsingSkewCayley</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">orthonormalizeUsingSkewCayley</span><wbr><span class="parameters">(double[][]&nbsp;r)</span>
                                                throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cay(double[][])">
<h3>cay</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">cay</span><wbr><span class="parameters">(double[][]&nbsp;r)</span>
                      throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">orthogonalize matrix R using skew parameters via Cayley's formula.
 (I - A)*(I + A)^-1</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>r</code> - a rotation matrix (i.e. a skew symmetric matrix A^T = A^-1)</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="makeUnitLengthAngleAxis(double,double[])">
<h3>makeUnitLengthAngleAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">makeUnitLengthAngleAxis</span><wbr><span class="parameters">(double&nbsp;angle,
 double[]&nbsp;axis)</span></div>
<div class="block">convert the axis, angle pair into unit length axis, angle pair.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>angle</code> - </dd>
<dd><code>axis</code> - input axis and output axis</dd>
<dt>Returns:</dt>
<dd>the angle</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Fri Sep 13 18:45:45 PDT 2024 -->
<title>EpipolarTransformer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-09-13">
<meta name="description" content="declaration: package: algorithms.imageProcessing.transform, class: EpipolarTransformer">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h1 title="Class EpipolarTransformer" class="title">Class EpipolarTransformer</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.imageProcessing.transform.EpipolarTransformer</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">EpipolarTransformer</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">class to solve for the epipolar and/or essential matrices and their epipoles for two images with stereo projection
 and apply the solution.

 the essential matrix contains information about the relative rotation between the 2 cameras and the direction of
 translation between the two cameras.

 The fundamental matrix contains information about the relative rotation between the 2 cameras, the direction of
 translation between the two cameras, and the intrinisc camera matrix.

 To recover scale one needs to use absolute orientation methods.

 <pre>
  The essential matrix is defined by the planes formed by the 3 vectors of optical centers of 2 cameras and the
  individual points X in 3D-space called world coordinate system (WCS).
  Each point X in 3-D space lies on a plane it forms with the optical centers.
  For each of those planes, the point X projected into image 1 is x1 and the point X projected into image 2 is x2.
  x1 and x2 can be described by the plane, and also by the rotation and translation between the cameras.
  let lambda1 and lambda2 be scale parameters.
  lambda1 * x2 = lambda2 * R * x1 + T.

  The translation vector is along the baseline between the 2 cameras.
  If we pre-multiply both sides by the skew symmetric matrix of T to give us the cross products:
     lambda1 * [T]_x * x2 = lambda2 * [T]_x * R * x1 + [T]_x * T
           T cross product with itself is 0.
     lambda1 * [T]_x * x2 = lambda2 * [T]_x * R * x1 + [T]_x * T
                          = lambda2 * [T]_x * R * x1 + 0
         vector T is from epipolar point e1 to epipolar point e2.
         vector x2 is from epipolar point e2 to x2.
         [T]_x * x2 is perpendicular to x2
         so then x2^T * [T]_x * x2 is 0.
         we can use that to simplify the equation further when we pre-multiply both sides by x2^T
     lambda1 * x2^T * [T]_x * x2 = lambda2 * x2^T * [T]_x * R * x1
                0 = lambda2 * x2^T * [T]_x * R * x1

     The essential matrix E is defined as [T]_x * R
         E = [T]_x * R
         x2^T * E * x1 = 0

     Epipolar plane is intersection of o1, o2, X where o1 = optical center for camera 1, o2 = same for camera 2.

     e1 and e2 are the projections of o1 and o2 into their images (and may exist outside of image bounds).

     each point x1, x2 has an epipolar line l1, l2, in its image that is the intersection of x1 with e1, and x2 with e2.

     e2^T * E = 0
     E * e1 = 0
     l2 = E * x1
     l1 = E^T * x2
     li^T * ei = 0
     li^T * xi = 0

 The fundamental matrix is the projective solution for transformation
 between 2 images of the same objects in pixel coordinates.

     E = K2^T * F * K1
     F = K^-T * E * K^-1
                  where K is the intrinsic camera matrix.
       = K^-T * [T]_x * R * K^-1  if det(K) ~ 1 else apply a scale factor too.

 Present below is the solution for having 7 matched points between images
 and the solution for having 8 or more matched points between the images.
 Both use numerical conditioning and recipes suggested by Hartley
 (see reference below).
 
 For the 8-point algorithm:
 IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, VOL. 19,
 NO. 6, JUNE 1997
 "In Defense of the Eight-Point Algorithm" by Richard Hartley

 The 8-point algorithm matrix represents epipolar geometry, and can be
 used with data from cameras whose characteristics are not known to solve
 up to the projective transformation.
 ...a simple transformation (translation and scaling) of the points in 
 the image before formulating the linear equations leads to an enormous 
 improvement in the condition of the problem and hence of the stability 
 of the result...

 Some definitions:
    vectors are treated as columns unless noted otherwise.
    vector as a row uses notation u^T.
    u^T*v represents the inner product (= dot product).  result is a scalar.
    u*v^T represents the outer product. result is a matrix.
    u_1 is the (x,y) points from image 1 and u_2 are the matched (x,y) points
        from image 2.

     Epipolar Plane:
        An epipolar plane is defined by the principal points o1, and o2 of the cameras and the point p.
     Epipoles:
         The projection of one camera center onto the other camera's image plane is an epipole.
         (the epipole can lie outside the image boundaries)
         in the Essential Matrix: e2 ~ T and e1 ~ R*T up to a scalar factor.
         e1 = right nullspace of FM = SVD(fm).V[*,2].
         e2 = left nullspace of FM = SVD(fm).U[*,2].
         e2^T*E = 0
         E*e1 = 0
     Epipolar line of p:
         intersection of the epipolar place of p with an image place is the epipolar line of p.
         l2 ~ E*x1
         l1 ~ E^T*x2

         l*e=0 for (l1,e1) and also (l2,e2)
         l^T*x=0 for (l1,x1) and also (l2,x2)

    the fundamental matrix is defined:
        u_2^T * F * u_1 = 0  
        where u are the x,y points in images _1 and _2
        and F is a 3 × 3 matrix of rank 2
        
    An explanation of the derivation of the fundamental matrix can be found in
    Zhengyou Zhang. "Determining the Epipolar Geometry and its Uncertainty: A
    Review". RR-2927, INRIA. 1996. ffinria-00073771
    equations (1) and (2) 
    
    u_1 = (x_1, y_1, 1)^T
    u_2 = (x_2, y_2, 1)^T
     
    u_1   = x_1_i    x_1_i+1  ...    
            y_1_i    y_1_i+1  ...
            1        1        ...
 
    u_2^T = x_2_i    y_2_i    1
            x_2_i+1  y_2_i+1  1
            ...      ...      ...

    x_1*x_2*F_1_1 + x_1*y_2*F_2_1 + x_1*F_3_1 + y_1*x_2*F_1_2 + y_1*y_2*F_2_2
        + y_1*F_3_2 + x_2*F_1_3 + y_2*F_2_3 + F_3_3 = 0

    A * f = 0

    where A = x_1*x_2, x_1*y_2, x_1, y_1*x_2, y_1*y_2, y_1, x_2, y_2, 1
             (which is each element of column 0 of u_1 dotted separately with
             row 0 of u2_T)
             A is nData X 9
    and f is a nine-vector (size 9X1) containing the entries of the matrix F
 
    To avoid the trivial scale, ||f|| = 1 where f is the norm of f

    the rank of A is 8, but noise and other errors make it 9.
    if A is longer than 8, the system is over-determined (over specified) and
    so must be solved using least squares.  the set may be over determined
    and not have a zero solution.

    we want the vector f that minimizes ||A*f|| subject to the constraint
    that ||f|| = f^T*f = 1

    the solution is the unit eigenvector corresponding to the smallest
    eigenvalue of A^T*A.

    Since A^T*A is positive semi-definite and symmetric, all of its eigenvectors
    are real and positive or zero.
    This eigenvector is what he calls the least eigenvector of A^T*A and
    it is found via the Jacobi algorithm or Singular Value Decomposition.
    NOTE:
        SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
        SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U

    The solved for matrix will in general not have rank 2 and needs to, so
    further corrections are necessary:
        matrix F is replaced by F' that minimizes the Frobenius norm
        ||F - F'|| subject to the condition det F' = 0.
        A convenient method of doing this is to use the Singular Value
        Decomposition (SVD).
           let F = U*D*V^T be the SVD of F, where D is diagonal matrix
           D = diag(r, s, t) satisfying r >= s >= t.
           let F' = U*diag(r, s, 0)*V^T.

 (1) Transforming the coordinates:

     Normalization for isotropic scaling.
     1) The points are translated so that their centroid is at
        the origin.
     2) The points are then scaled so that the average distance
        from the origin is equal to 2 .
     3) This transformation is applied to each of the two images independently.

     NOTE: if needed to use non-isotropic scaling (e.g. rectangular pixels, etc):
     transform the points so that
     1) Their centroid is at the origin.
     2) The principal moments are both equal to unity
      
     
     scaling the coordinate so that the homogeneous coordinates are on the 
     average equal to unity will improve the condition of the matrix A^T*A.
     I talso allows use of error calculations such as Sampson's.

 (2) build matrix A with the normalized x,y points

 (3) compute linear least square solution to the least eigenvector of f:
     solve A = U * D * V^T   for A*f = [..x...]*f = 0
     A has rank 8.  F has rank 2.
     calculate [U,D,V] from svd(A)

 (4) make the fundamental matrix have a rank of 2
     by performing a svd and then reconstructing with the two largest
     singular values (similar to dimensionality reduction)
         [U,D,V] = svd(F,0);
         F = U * diag([D(1,1) D(2,2) 0]) * V^T;

 (5) denormalize the fundamental matrix
     The related part of the normalization equation: inv(T_2) * F * inv(T_1)
     so denormalizing is:

         F = (T_2)^T * F * T_1

 (6) estimate the error in the fundamental matrix by calculating epipolar
     lines for points in image 1 and find their nearest points in image 2
     and measure the perpendicular distance from the epipolar line for
     those nearest points.
     NOTE: This is best done using normalized coordinates and fundamental matrix,
     after step (4) and before step (5).

For the 7-point algorithm:
references are:
  the the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img
from a version of http://www.robots.ox.ac.uk/~vgg/hzbook/code/ which is part
of the supplementary material for their book "Multiple View Geometry in Computer Vision
Second Edition"
   and Hartley, R. I. (1994a). Projective reconstruction and invariants from 
multiple images. PAMI, 16(10):1036–1041
   and Torr, P. H. S. and Murray, D. (1997). 
"The development and comparison of robust meth- ods for estimating the 
fundamental matrix. International Journal of Computer Vision", 24(3):271–300.

 The 7-point algorithm solves for the null space of the fundamental
 matrix and results in one or 3 solutions which can for some geometries
 be reduced to a single solution.
 The nullspace is where Ax=0 in reduced echelon, that is, the free variable rows.
 The normalization and denormalization steps before and following the solution,
 are the same as in the 8-point solution.

 this from comments in the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img:
   Solutions for the 7-points are pruned by requirement that
   scalars s in all equations s * cross(e1,u_1) == F*u_2 are positive.
   In case of multiple solutions, F has one dimension
   more such that F(:,:,n) is the n-th solution.

  note:
    because translation is not a linear transformation (see Strang Chap 7)
       one has to keep it as a separate transformation matrix when
       performing operations on a sequence of matrices such as inverse
       and transpose operations.

    translation matrix: inverse changes the signs of the translation elements,
        but not the diagonal

    rotation matrix: inverse is the transpose of rotation matrix.
     
    scaling matrix: inverse is performed on each element, that is, the reciprocal.

    (A*B*C)^-1 = (C^-1) * (B^-1) * (A^-1)

    also, when A * A^(-1) = I, one can use:
                    1
        A^(-1) =  ------ C^(T)  where C_ij = cofactor of a_ij
                   det A

  NOTE: the normalization suggested by Hartley is explored further in
  Chojnacki et al. 2003,  "Revisiting Hartley’s Normalized Eight-Point Algorithm"
  
  Some excerpts:
   
     xc is the centroid of x coordinates.
     yc is the centroid of y coordinates.
     s is the root mean square distance of (x-xc,y-yc) to origin divided by sqrt(2)
    
     u1_normalized = T1 * u1 
     u2_normalized = T2 * u2 

     denormalized F = T2^T * F_normalized * T1

     denormalized u1 = T1^-1 * u1_normalized and similar foru2

     FM_normalized = inverse(transpose(T2)) * FM * inverse(T1)

     denormalized FM = transpose(T2) * FM_normalized * T1 

     u2^T * FM * u1 = u2_normalized^T * FM_normalized * u1_normalized = residual
  
              | 1/s   0  0 |   | 1  0  -xc |   | 1/s    0   -xc/s |
          T = |  0  1/s  0 | * | 0  1  -yc | = |   0  1/s   -yc/s |
              |  0    0  1 |   | 0  0   1  |   |   0    0      1  |

                 | 1  0  xc |   | s  0   0 |   | s   0  xc |
          T^-1 = | 0  1  yc | * | 0  s   0 | = | 0   s  yc |
                 | 0  0   1 |   | 0  0   1 |   | 0   0   1 |
   
                        | 1  0  xc |   | s^2  0    0 |   | 1  0  0 |
          T^-1 * T^-T = | 0  1  yc | * | 0   s^2   0 | * | 0  1  0 |
                        | 0  0   1 |   | 0    0    1 |   | xc yc 1 |

                        | s^2 + xc^2   xc*yc       xc |
                      = | yc*xc        s^2 + yc^2  yc |
                        | xc           yc          1  |
        
                                  | s  0   0 |   | 1  0  0 |   |  s   0   0 |
        from that can see  T^-T = | 0  s   0 | * | 0  1  0 | = |  0   s   0 |
                                  | 0  0   1 |   | xc yc 1 |   | xc  yc   1 |
        
              |  1    0    0 |   | 1/s   0  0 |   |   1/s    0    0 |
        T^T = |  0    1    0 | * |  0  1/s  0 | = |     0   1/s   0 |
              |-xc  -yc    1 |   |  0    0  1 |   | -xc/s  -yc/s  1 |
        
                   ( | 1/s   0  0 | )^-1     |  1    0    0 |   |  s  0   0 |
        (T^T)^-1 = ( |  0  1/s  0 | )     *  |  0    1    0 | = |  0  s   0 |
                   ( |  0    0  1 | )        | xc   yc    1 |   | xc  yc  1 |
        
        can see that (T^-1)^T = (T^T)^-1        
 </pre>
 
 <pre>
    The plunder-dl scoring can be used for comparison between different models.
    for example, comparing results of the 7-point and 8-point 
    solutions or comparing 7-point projection to 6-point affine, etc.

    plunder-dl is from equation 33 of
    Torr, Zisserman, &amp; Maybank 1996, 
    “Robust Detection of Degenerate Configurations whilst Estimating 
    the Fundamental Matrix"
    https://www.robots.ox.ac.uk/~phst/Papers/CVIU97/m.ps.gz
     EQN 33: PL = DOF + (4*n_o + n_i dimension of model)
                   where n_i = number of inliers
                   n_o = number of outliers
                   DOF = 7 for this solver
    n=7               PL = DOF + 4*n_o + n_i* (model_dimension)
         ni=7, no=0   PL = 7   + 0     + 0 * md
         ni=5, no=2   PL = 7   + 8     + 8 * md
         ni=4, no=3   PL = 7   + 12    + 28 * md
    PLUNDER stands for Pick Least UNDEgenerate Randomly, Description Length

    For nPoints=8, model_dimension = 1.
    for nPoints=7 amd only 1 solution in the cubic constraints, model_dimension=2,
    else for nPoints=7, model_dimension = 3.
 </pre>
 <pre>
 A summary of epipolar geometry is in chapter 5 of 
 Ma, Soatto, Kosecká, and Sastry 2012, "An Invitation to 3-D Vision".
 
    e2 when normalized by 3rd coord is in coord space of left image and
       it is the location of the right camera center.
    e2 is the last column of svd.u
    e2 is the left nullspace of F
    (e2^T*F = 0  e2^T*E = 0)
      ==> e2~T  where T is translation and ~ is equality up to a scale factor

    e1 is the last row of svd.vt
    e1 is the right nullspace of F
    (F*e1 = 0  E*e1 = 0)
      ==> e1~R^T*T  where R is rotation and T is translation
    l2 = E*x1
    l1 = E^T*x2
    (x1^T*l1=0 and l1^T*e1=0)
    (x2^T*l2=0 and l2^T*e2=0)
 </pre>
 
 NOTE:
For "7-point" correspondences, consider implementing MLESAC.
     "MLESAC: A new robust estimator with application to estimating image geometry"
     by P. H. S. Torr and A. Zisserman
     1996 http://www.robots.ox.ac.uk/~vgg/publications/papers/torr00.pdf
 
 TODO: implement Nister's 5-point algorithm to determine the essential matrix 
 for the case where arguments are the camera intrinsic parameters and the correspondence.</div>
<dl class="notes">
<dt>Author:</dt>
<dd>nichole</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="EpipolarTransformer.NormalizationTransformations.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static class&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="EpipolarTransformer.NormalizedXY.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">EpipolarTransformer</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#calculateEpipolarProjection(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix,boolean)" class="member-name-link">calculateEpipolarProjection</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;leftXY,
 no.uib.cipr.matrix.DenseMatrix&nbsp;rightXY,
 boolean&nbsp;calibrated)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">calculate the epipolar projection for a set of 8 or more matched points.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#calculateEpipolarProjection2(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">calculateEpipolarProjection2</a><wbr>(double[][]&nbsp;leftXY,
 double[][]&nbsp;rightXY,
 boolean&nbsp;calibrated)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">calculate the epipolar projection.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;no.uib.cipr.matrix.DenseMatrix&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#calculateEpipolarProjectionFor7Points(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">calculateEpipolarProjectionFor7Points</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;leftXY,
 no.uib.cipr.matrix.DenseMatrix&nbsp;rightXY)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">calculate the epipolar projection for 7 correspondences and filter
 with a chirality check.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#calculateEpipolarProjectionUsing7Points(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">calculateEpipolarProjectionUsing7Points</a><wbr>(double[][]&nbsp;leftXY,
 double[][]&nbsp;rightXY)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">calculate the epipolar projection given 7 pairs of points.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculateEpipoles(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">calculateEpipoles</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;fundamentalMatrix)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the epipoles of the fundamental matrix and return them as
 an array with left epipole in column 0 and right epipole in column 1.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#createDesignMatrix(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">createDesignMatrix</a><wbr>(double[][]&nbsp;normXY1,
 double[][]&nbsp;normXY2)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">a = xLeft ⊗ xRight</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createEssentialFromFundamentalMatrix(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">createEssentialFromFundamentalMatrix</a><wbr>(double[][]&nbsp;k1,
 double[][]&nbsp;k2,
 double[][]&nbsp;fm)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the fundamental matrix into the essential matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createFundamentalFromEssentialMatrix(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">createFundamentalFromEssentialMatrix</a><wbr>(double[][]&nbsp;k1,
 double[][]&nbsp;k2,
 double[][]&nbsp;em)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">convert the essential matrix into the fundamental matrix using 
 F= K2^-T * E * K1^-1</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createKroneckerDesignMatrix(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">createKroneckerDesignMatrix</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;normXY1,
 no.uib.cipr.matrix.DenseMatrix&nbsp;normXY2)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">a = xLeft ⊗ xRight</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>protected static <a href="EpipolarTransformer.NormalizationTransformations.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#createScaleTranslationMatrices(double,double,double)" class="member-name-link">createScaleTranslationMatrices</a><wbr>(double&nbsp;scale,
 double&nbsp;centroidX,
 double&nbsp;centroidY)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">create 2 scale and translation matrices to normalize homogeneous 2D coordinates
 by multiplying on the left side, and to de-normalize the normalized
 coordinates by multiplying on the left side.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#denormalizeTheFundamentalMatrix(no.uib.cipr.matrix.DenseMatrix,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizationTransformations,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizationTransformations)" class="member-name-link">denormalizeTheFundamentalMatrix</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;normalizedFundamentalMatrix,
 <a href="EpipolarTransformer.NormalizationTransformations.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a>&nbsp;leftNT,
 <a href="EpipolarTransformer.NormalizationTransformations.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a>&nbsp;rightNT)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#denormalizeTheFundamentalMatrix(no.uib.cipr.matrix.DenseMatrix,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizedXY,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizedXY)" class="member-name-link">denormalizeTheFundamentalMatrix</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;normalizedFundamentalMatrix,
 <a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a>&nbsp;normalizedLeftXY,
 <a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a>&nbsp;normalizedRightXY)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#estimateToleranceForDOF1(double)" class="member-name-link">estimateToleranceForDOF1</a><wbr>(double&nbsp;standardDeviation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">if assume gaussian errors and chi-squared statistics, for 1 degree of 
 freedom (i.e.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#estimateToleranceForDOF2(double)" class="member-name-link">estimateToleranceForDOF2</a><wbr>(double&nbsp;standardDeviation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">if assume gaussian errors and chi-squared statistics, for 2 degree of freedom (i.e.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#estimateToleranceForDOF3(double)" class="member-name-link">estimateToleranceForDOF3</a><wbr>(double&nbsp;standardDeviation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">if assume gaussian errors and chi-squared statistics, for 2 degree of freedom (i.e.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractIndices(double%5B%5D%5B%5D,java.util.List)" class="member-name-link">extractIndices</a><wbr>(double[][]&nbsp;m,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html" title="class or interface in java.lang" class="external-link">Integer</a>&gt;&nbsp;inlierIndexes)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#extractIndices(no.uib.cipr.matrix.DenseMatrix,java.util.List)" class="member-name-link">extractIndices</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html" title="class or interface in java.lang" class="external-link">Integer</a>&gt;&nbsp;inlierIndexes)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>algorithms.util.PairIntArray</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getEpipolarLine(no.uib.cipr.matrix.DenseMatrix,int,int,int)" class="member-name-link">getEpipolarLine</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;epipolarLines,
 int&nbsp;imgWidth,
 int&nbsp;imgHeight,
 int&nbsp;pointNumber)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalize(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">normalize</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;xy)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unit standard normalize the x,y coordinates so that mean=0 and standard deviation = 1.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalizeUsingUnitStandard(double%5B%5D%5B%5D)" class="member-name-link">normalizeUsingUnitStandard</a><wbr>(double[][]&nbsp;xy)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">perform unit standard normalization of the points xy to result in a mean of 0 for xy and a standard deviation of 1,
     and return the mean of x, mean of y, st.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalizeUsingUnitStandard(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">normalizeUsingUnitStandard</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;xy)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unit standard normalize the x,y coordinates so that mean=0 and standard deviation = 1.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>no.uib.cipr.matrix.DenseMatrix</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#pFromF(no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">pFromF</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;f)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Determine the camera matrices of an image pair up to a scene 
 homography, given their fundamental matrix using algorithm
 of Hartley and Zisserman 2004.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) no.uib.cipr.matrix.DenseMatrix[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#solveFor7Point(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">solveFor7Point</a><wbr>(double[][]&nbsp;ff1,
 double[][]&nbsp;ff2)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>(package private) boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#validateSolution(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)" class="member-name-link">validateSolution</a><wbr>(no.uib.cipr.matrix.DenseMatrix&nbsp;fm,
 no.uib.cipr.matrix.DenseMatrix&nbsp;leftXY,
 no.uib.cipr.matrix.DenseMatrix&nbsp;rightXY)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">The validation of the 7-point algorithm follows source code adapted
 from this site and license:

 based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        "MATLAB Functions for Multiple View Geometry"

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files
 (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge,
 publish, distribute, sublicense, and/or sell copies of the Software,
 and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

        The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>EpipolarTransformer</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">EpipolarTransformer</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="calculateEpipolarProjection2(double[][],double[][],boolean)">
<h3>calculateEpipolarProjection2</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculateEpipolarProjection2</span><wbr><span class="parameters">(double[][]&nbsp;leftXY,
 double[][]&nbsp;rightXY,
 boolean&nbsp;calibrated)</span>
                                        throws <span class="exceptions"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">calculate the epipolar projection.  no normalizations and de-normalizations are handled internally.
 if the camera calibration is known, the essential matrix is returned.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>leftXY</code> - the left image coordinates of the feature correspondences</dd>
<dd><code>rightXY</code> - the right image coordinates of the feature correspondences</dd>
<dd><code>calibrated</code> - whether or not the camera calibration is known.  if true, the essential matrix is returned.</dd>
<dt>Returns:</dt>
<dd>the fundamental matrix (or essential matrix) of the epipolar projection, else null if SVD failed.</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateEpipolarProjectionUsing7Points(double[][],double[][])">
<h3>calculateEpipolarProjectionUsing7Points</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculateEpipolarProjectionUsing7Points</span><wbr><span class="parameters">(double[][]&nbsp;leftXY,
 double[][]&nbsp;rightXY)</span>
                                                   throws <span class="exceptions"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">calculate the epipolar projection given 7 pairs of points.  all normalizations and de-normalizations are handled internally.
 if the camera calibration is known, the essential matrix is returned.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>leftXY</code> - the left image coordinates of the feature correspondences</dd>
<dd><code>rightXY</code> - the right image coordinates of the feature correspondences</dd>
<dt>Returns:</dt>
<dd>the fundamental matrix (or essential matrix) of the epipolar projection.</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateEpipolarProjection(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix,boolean)">
<h3>calculateEpipolarProjection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">calculateEpipolarProjection</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;leftXY,
 no.uib.cipr.matrix.DenseMatrix&nbsp;rightXY,
 boolean&nbsp;calibrated)</span></div>
<div class="block">calculate the epipolar projection for a set of 8 or more matched points.
 NOTE that for best results, the method should be given unit standard
 normalized coordinates.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>leftXY</code> - left image correspondence in format of
 double array with x points on row 0, y points on row 1,
     and 1's on row 2.  the number of columns is the number of data points.</dd>
<dd><code>rightXY</code> - right image correspondence in format of
 double array with x points on row 0, y points on row 1,
     and 1's on row 2.  the number of columns is the number of data points.</dd>
<dd><code>calibrated</code> - if true, solves for the Essential Matrix, else solves for the
 Fundamental matrix.  The difference is only in the diagonal used for
 dimension reduction.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateEpipolarProjectionFor7Points(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)">
<h3>calculateEpipolarProjectionFor7Points</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;no.uib.cipr.matrix.DenseMatrix&gt;</span>&nbsp;<span class="element-name">calculateEpipolarProjectionFor7Points</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;leftXY,
 no.uib.cipr.matrix.DenseMatrix&nbsp;rightXY)</span></div>
<div class="block">calculate the epipolar projection for 7 correspondences and filter
 with a chirality check.  returns a list of the filtered solutions.
 NOTE that for best results, the method should be given unit standard
 normalized coordinates.
 references are:
        (1) the the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img
        from a version of http://www.robots.ox.ac.uk/~vgg/hzbook/code/ which is part
        of the supplementary material for their book "Multiple View Geometry in Computer Vision
        Second Edition"
        (2) Section IVa of Hartley, R. I. (1994a). Projective reconstruction and invariants from 
        multiple images. PAMI, 16(10):1036–1041
        (3) Torr, P. H. S. and Murray, D. (1997). 
        "The development and comparison of robust methods for estimating the 
        fundamental matrix. International Journal of Computer Vision", 24(3):271–300.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>leftXY</code> - </dd>
<dd><code>rightXY</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="validateSolution(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)">
<h3>validateSolution</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">validateSolution</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;fm,
 no.uib.cipr.matrix.DenseMatrix&nbsp;leftXY,
 no.uib.cipr.matrix.DenseMatrix&nbsp;rightXY)</span></div>
<div class="block">The validation of the 7-point algorithm follows source code adapted
 from this site and license:

 based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        "MATLAB Functions for Multiple View Geometry"

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files
 (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge,
 publish, distribute, sublicense, and/or sell copies of the Software,
 and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

        The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.

        The software is provided "as is", without warranty of any kind, express
 or implied, including but not limited to the warranties of
 merchantability, fitness for a particular purpose and noninfringement.
 In no event shall the authors or copyright holders be liable for any
 claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the
 software or the use or other dealings in the software.

       vgg_multiview/vgg_F_from_7pts_2img.m

       The method "signs_OK" validates the solution matrices:

        for i = 1:length(a)
          Fi = a(i)*FF{1} + (1-a(i))*FF{2};
          %for n = 1:7, disp(norm(x(:,n,1)'*Fi*x(:,n,2))), end  % test code
          if signs_OK(Fi,x1,x2)
            F = cat(3, F, Fi);
          end
        end

        return

        %%%%%%%%%%%%%%%%%%%%%%%%%

        % Checks sign consistence of F and x
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F');
        e1 = v(:,3);
        l1 = vgg_contreps(e1)*x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s>0) | all(s less than 0);
        return

    More on the subject is present in "Cheirality in Epipolar Geometry" by
    Werner &amp; Pajdla, 2000 regarding realizability of two images.
    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.9013&amp;rep=rep1&amp;type=pdf

    Very clear paper on cheirality:
 http://users.cecs.anu.edu.au/~hartley/Papers/cheiral/revision/cheiral.pdf
 The cheirality of a point is whether it lies in front of or behind a given
 camera.  It's used to  distinguish between four different possible scene
 reconstructions from two views.
 A transform is cheirality-reversing for a given point if it swaps the
 point from the front to the back of the camera, or vice-versa.
 Otherwise it is called cheirality-preserving.
 
 note: alternate spelling is chirality.</div>
</section>
</li>
<li>
<section class="detail" id="pFromF(no.uib.cipr.matrix.DenseMatrix)">
<h3>pFromF</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">pFromF</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;f)</span></div>
<div class="block">Determine the camera matrices of an image pair up to a scene 
 homography, given their fundamental matrix using algorithm
 of Hartley and Zisserman 2004.
 <pre>
 If x2'*F*x1 = 0 for any pair of image points x1 and x2,
         then the camera matrices of the image pair are 
         P1 = [I 0] (as 3x4 matrix) and P2 = vgg_P_from_F(F), up to a scene homography.
 </pre>
 algorithm follows source code for vgg_P_from_F.m 
 adapted from this site and license:

 based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        "MATLAB Functions for Multiple View Geometry"

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files
 (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge,
 publish, distribute, sublicense, and/or sell copies of the Software,
 and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

        The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.

        The software is provided "as is", without warranty of any kind, express
 or implied, including but not limited to the warranties of
 merchantability, fitness for a particular purpose and noninfringement.
 In no event shall the authors or copyright holders be liable for any
 claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the
 software or the use or other dealings in the software.

       
        %%%%%%%%%%%%%%%%%%%%%%%%%</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - fundamental matrix in format 3x3</dd>
<dt>Returns:</dt>
<dd>camera matrices in format 3x4</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveFor7Point(double[][],double[][])">
<h3>solveFor7Point</h3>
<div class="member-signature"><span class="return-type">no.uib.cipr.matrix.DenseMatrix[]</span>&nbsp;<span class="element-name">solveFor7Point</span><wbr><span class="parameters">(double[][]&nbsp;ff1,
 double[][]&nbsp;ff2)</span></div>
</section>
</li>
<li>
<section class="detail" id="denormalizeTheFundamentalMatrix(no.uib.cipr.matrix.DenseMatrix,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizedXY,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizedXY)">
<h3>denormalizeTheFundamentalMatrix</h3>
<div class="member-signature"><span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">denormalizeTheFundamentalMatrix</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;normalizedFundamentalMatrix,
 <a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a>&nbsp;normalizedLeftXY,
 <a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a>&nbsp;normalizedRightXY)</span></div>
</section>
</li>
<li>
<section class="detail" id="normalize(no.uib.cipr.matrix.DenseMatrix)">
<h3>normalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a></span>&nbsp;<span class="element-name">normalize</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;xy)</span></div>
<div class="block">Unit standard normalize the x,y coordinates so that mean=0 and standard deviation = 1.
     returns the transformation matrix and the normalized coordinates.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - the data to normalize</dd>
<dt>Returns:</dt>
<dd>the transformation matrix and the normalized coordinates</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalizeUsingUnitStandard(no.uib.cipr.matrix.DenseMatrix)">
<h3>normalizeUsingUnitStandard</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="EpipolarTransformer.NormalizedXY.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizedXY</a></span>&nbsp;<span class="element-name">normalizeUsingUnitStandard</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;xy)</span></div>
<div class="block">Unit standard normalize the x,y coordinates so that mean=0 and standard deviation = 1.
     returns the transformation matrix and the normalized coordinates.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - the data to normalize</dd>
<dt>Returns:</dt>
<dd>the transformation matrix and the normalized coordinates</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalizeUsingUnitStandard(double[][])">
<h3>normalizeUsingUnitStandard</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">normalizeUsingUnitStandard</span><wbr><span class="parameters">(double[][]&nbsp;xy)</span></div>
<div class="block">perform unit standard normalization of the points xy to result in a mean of 0 for xy and a standard deviation of 1,
     and return the mean of x, mean of y, st. dev of x and st dev of y.  note that no normalization is performed on the z coordinates.
     note that the normalization alters the input.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xy</code> - data points in format [3 X n].  e.g. xy[0][0] is x, xy[1][0] is y, xy[2][0] is z for point 0.</dd>
<dt>Returns:</dt>
<dd>mean of x, mean of y, st. dev of x and st dev of y</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createScaleTranslationMatrices(double,double,double)">
<h3>createScaleTranslationMatrices</h3>
<div class="member-signature"><span class="modifiers">protected static</span>&nbsp;<span class="return-type"><a href="EpipolarTransformer.NormalizationTransformations.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a></span>&nbsp;<span class="element-name">createScaleTranslationMatrices</span><wbr><span class="parameters">(double&nbsp;scale,
 double&nbsp;centroidX,
 double&nbsp;centroidY)</span></div>
<div class="block">create 2 scale and translation matrices to normalize homogeneous 2D coordinates
 by multiplying on the left side, and to de-normalize the normalized
 coordinates by multiplying on the left side.
 The normalization matrix transforms x by (x - centroidX)/scale and similarly transforms y.
 The de-normalization matrix can be used to multiply by scale and add the centroid.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>scale</code> - </dd>
<dd><code>centroidX</code> - </dd>
<dd><code>centroidY</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="denormalizeTheFundamentalMatrix(no.uib.cipr.matrix.DenseMatrix,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizationTransformations,algorithms.imageProcessing.transform.EpipolarTransformer.NormalizationTransformations)">
<h3>denormalizeTheFundamentalMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">denormalizeTheFundamentalMatrix</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;normalizedFundamentalMatrix,
 <a href="EpipolarTransformer.NormalizationTransformations.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a>&nbsp;leftNT,
 <a href="EpipolarTransformer.NormalizationTransformations.html" title="class in algorithms.imageProcessing.transform">EpipolarTransformer.NormalizationTransformations</a>&nbsp;rightNT)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>normalizedFundamentalMatrix</code> - the normalized fundamental matrix, that is the solution for
 the fundamental matrix using the normalized correspondence.</dd>
<dd><code>leftNT</code> - the transformations created for normalization and de-normalization
 of the left image coordinates.</dd>
<dd><code>rightNT</code> - the transformations created for normalization and de-normalization
 of the right image coordinates.</dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="createKroneckerDesignMatrix(no.uib.cipr.matrix.DenseMatrix,no.uib.cipr.matrix.DenseMatrix)">
<h3>createKroneckerDesignMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createKroneckerDesignMatrix</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;normXY1,
 no.uib.cipr.matrix.DenseMatrix&nbsp;normXY2)</span></div>
<div class="block">a = xLeft ⊗ xRight</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>normXY1</code> - a matrix of size 3 x nPoints, where 1st row is x,
 second is y.</dd>
<dd><code>normXY2</code> - a matrix of size 3 x nPoints, where 1st row is x,
 second is y.</dd>
<dt>Returns:</dt>
<dd>fundamental matrix of size [nPoints x 9]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createDesignMatrix(double[][],double[][])">
<h3>createDesignMatrix</h3>
<div class="member-signature"><span class="return-type">double[][]</span>&nbsp;<span class="element-name">createDesignMatrix</span><wbr><span class="parameters">(double[][]&nbsp;normXY1,
 double[][]&nbsp;normXY2)</span></div>
<div class="block">a = xLeft ⊗ xRight</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>normXY1</code> - a matrix of size 3 x nPoints, where 1st row is x,
 second is y.</dd>
<dd><code>normXY2</code> - a matrix of size 3 x nPoints, where 1st row is x,
 second is y.</dd>
<dt>Returns:</dt>
<dd>fundamental matrix of size [nPoints x 9]</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateEpipoles(no.uib.cipr.matrix.DenseMatrix)">
<h3>calculateEpipoles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculateEpipoles</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;fundamentalMatrix)</span></div>
<div class="block">calculate the epipoles of the fundamental matrix and return them as
 an array with left epipole in column 0 and right epipole in column 1.
Epipolar Plane:
       An epipolar plane is defined by the principal points o1, and o2 of the cameras and the point p.
    Epipoles:
       In the epipolar plane, the point where the camera principal point intersects it image is the
       epipole.  The location of the epipole in the other image can be thought of as the projection
       of the other camera center onto its image.
       (the epipole can lie outside the image boundaries).
       e1 = right nullspace of FM = SVD(fm).V[*,2].
       e2 = left nullspace of FM = SVD(fm).U[*,2].
         e2^T*E = 0.
         E*e1 = 0.
         this method returns e1 and e2 divided by their last columns.
         for the essential matrix: e2 ~ T and e1 ~ R*T up to a scalar factor.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fundamentalMatrix</code> - </dd>
<dt>Returns:</dt>
<dd>a matrix holding whose first row holds e1 and 2nd row holds e2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createEssentialFromFundamentalMatrix(double[][],double[][],double[][])">
<h3>createEssentialFromFundamentalMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createEssentialFromFundamentalMatrix</span><wbr><span class="parameters">(double[][]&nbsp;k1,
 double[][]&nbsp;k2,
 double[][]&nbsp;fm)</span>
                                                       throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">convert the fundamental matrix into the essential matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - camera 1 intrinsics matrix.</dd>
<dd><code>k2</code> - camera 2 intrinsics matrix.</dd>
<dd><code>fm</code> - the fundamental matrix in the reference frame of the original image space
 of pixel coordinates.</dd>
<dt>Returns:</dt>
<dd>the essential matrix in the reference frame of normalized image
 coordinates (origin is optical center of the image).</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createFundamentalFromEssentialMatrix(double[][],double[][],double[][])">
<h3>createFundamentalFromEssentialMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">createFundamentalFromEssentialMatrix</span><wbr><span class="parameters">(double[][]&nbsp;k1,
 double[][]&nbsp;k2,
 double[][]&nbsp;em)</span></div>
<div class="block">convert the essential matrix into the fundamental matrix using 
 F= K2^-T * E * K1^-1</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - camera 1 intrinsics matrix.</dd>
<dd><code>k2</code> - camera 2 intrinsics matrix.</dd>
<dd><code>em</code> - the essential matrix in the reference frame of normalized image
 coordinates (origin is optical center of the image)</dd>
<dt>Returns:</dt>
<dd>the fundamental matrix .</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getEpipolarLine(no.uib.cipr.matrix.DenseMatrix,int,int,int)">
<h3>getEpipolarLine</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">algorithms.util.PairIntArray</span>&nbsp;<span class="element-name">getEpipolarLine</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;epipolarLines,
 int&nbsp;imgWidth,
 int&nbsp;imgHeight,
 int&nbsp;pointNumber)</span></div>
</section>
</li>
<li>
<section class="detail" id="extractIndices(no.uib.cipr.matrix.DenseMatrix,java.util.List)">
<h3>extractIndices</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">no.uib.cipr.matrix.DenseMatrix</span>&nbsp;<span class="element-name">extractIndices</span><wbr><span class="parameters">(no.uib.cipr.matrix.DenseMatrix&nbsp;m,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html" title="class or interface in java.lang" class="external-link">Integer</a>&gt;&nbsp;inlierIndexes)</span></div>
</section>
</li>
<li>
<section class="detail" id="extractIndices(double[][],java.util.List)">
<h3>extractIndices</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">extractIndices</span><wbr><span class="parameters">(double[][]&nbsp;m,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html" title="class or interface in java.lang" class="external-link">Integer</a>&gt;&nbsp;inlierIndexes)</span></div>
</section>
</li>
<li>
<section class="detail" id="estimateToleranceForDOF1(double)">
<h3>estimateToleranceForDOF1</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">estimateToleranceForDOF1</span><wbr><span class="parameters">(double&nbsp;standardDeviation)</span></div>
<div class="block">if assume gaussian errors and chi-squared statistics, for 1 degree of 
 freedom (i.e. fitting a line, fundamental matrix, d^2 = 3.84*(st.dev^2)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>standardDeviation</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="estimateToleranceForDOF2(double)">
<h3>estimateToleranceForDOF2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">estimateToleranceForDOF2</span><wbr><span class="parameters">(double&nbsp;standardDeviation)</span></div>
<div class="block">if assume gaussian errors and chi-squared statistics, for 2 degree of freedom (i.e. fitting
 a line, fundamental matrix, d^2 = 5.99*(st.dev^2)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>standardDeviation</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="estimateToleranceForDOF3(double)">
<h3>estimateToleranceForDOF3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">estimateToleranceForDOF3</span><wbr><span class="parameters">(double&nbsp;standardDeviation)</span></div>
<div class="block">if assume gaussian errors and chi-squared statistics, for 2 degree of freedom (i.e. fitting
 a line, fundamental matrix, d^2 = 7.82*(st.dev^2)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>standardDeviation</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

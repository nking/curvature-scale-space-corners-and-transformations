<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Fri Sep 13 18:45:45 PDT 2024 -->
<title>CameraCalibration</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-09-13">
<meta name="description" content="declaration: package: algorithms.imageProcessing.transform, class: CameraCalibration">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h1 title="Class CameraCalibration" class="title">Class CameraCalibration</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.imageProcessing.transform.CameraCalibration</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">CameraCalibration</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">estimate the camera intrinsic and extrinsic parameters using 3 images
 or more of the same objects with different camera poses.
 Following the algorithm of Ma, Chen, &amp; Moore 2003 in 
 "Camera Calibration: a USU Implementation" available as a preprint
 at arXiv  https://arxiv.org/pdf/cs/0307072
 Note that Ma et al. 2003 algorithm is based upon Zhang 1999 
 "Flexible Camera Calibration By Viewing a Plane From Unknown Orientations"
 available at https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/zhan99.pdf
 
 <pre>
 "one image observed by a camera can provide 2 constraints about this cameraâ€™s 
 intrinsic parameters that are regarded to be unchanged here. 
 With 3 images observed by the same camera, 6 constraints are established and 
 we are able to recover the 5 intrinsic parameters. Once the intrinsic 
 parameters are known, we can estimate the extrinsic parameters, 
 the distortion coefficients (k1,k2), and put every initial guess of these 
 parameters into some nonlinear optimization routine to get the final estimations. 
 </pre>
 <pre>
   Note, if need to estimate the instrinsic camera for initial conditions, one can generally
   start with:
   MASKS Algorithm 11.6, step 1:
   Guess a calibration matrix K by choosing the optical center at the center of the image,
   assuming the pixels to be square, and guessing the focal length f. For example, for
   an image plane of size (Dx X Dy) pixels, a typical guess is
       | f O Dx/2
   K = | 0 f Dy/2
       | 0 0 1
   with f = k X Dx, where k is typically chosen in the interval [0.5, 2].
 </pre></div>
<dl class="notes">
<dt>Author:</dt>
<dd>nichole</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final double</code></div>
<div class="col-second even-row-color"><code><a href="#eps" class="member-name-link">eps</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final double</code></div>
<div class="col-second odd-row-color"><code><a href="#eps2" class="member-name-link">eps2</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">CameraCalibration</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#_solveForIntrinsicPlanar(double%5B%5D%5B%5D)" class="member-name-link">_solveForIntrinsicPlanar</a><wbr>(double[][]&nbsp;h)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">estimate the camera intrinsic parameters from the image homographies.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#addDimension1(double%5B%5D%5B%5D)" class="member-name-link">addDimension1</a><wbr>(double[][]&nbsp;a)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a matrix of length n, return same matrix with a row of 1s appended to it</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#applyRadialDistortion(double%5B%5D%5B%5D,double,double,boolean)" class="member-name-link">applyRadialDistortion</a><wbr>(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">apply radial distortion to distortion-free camera centered coordinates using 
    the algorithm of Ma, Chen &amp; Moore (which is Ma et al.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#applyRadialDistortion(double%5B%5D,double,double,boolean)" class="member-name-link">applyRadialDistortion</a><wbr>(double[]&nbsp;xCPt,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">apply radial distortion to distortion-free camera centered coordinates using 
    the algorithm of Ma, Chen &amp; Moore (which is Ma et al.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#applyRadialDistortion(double%5B%5D,double,double,boolean,double%5B%5D)" class="member-name-link">applyRadialDistortion</a><wbr>(double[]&nbsp;xCPt,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4,
 double[]&nbsp;outputDistorted)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">apply radial distortion to distortion-free camera centered coordinates using 
    the algorithm of Ma, Chen &amp; Moore (which is Ma et al.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculateProjected(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D,double%5B%5D)" class="member-name-link">calculateProjected</a><wbr>(double[][]&nbsp;coordsW,
 double[][]&nbsp;h,
 double[]&nbsp;u,
 double[]&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the projection of world features in coordsW by the
 homography h into the image plane, storing the results in ud and vd.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Camera.CameraMatrices.html" title="class in algorithms.imageProcessing.transform">Camera.CameraMatrices</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#estimateCamera3D(int,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">estimateCamera3D</a><wbr>(int&nbsp;n,
 double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useR2R4)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">estimate the intrinsic and extrinsic camera parameters.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Camera.CameraMatrices.html" title="class in algorithms.imageProcessing.transform">Camera.CameraMatrices</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#estimateCameraPlanar(int,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">estimateCameraPlanar</a><wbr>(int&nbsp;n,
 double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useR2R4)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">for a camera at rest and images taken of a geometric plane in motion,
 estimate the intrinsic and extrinsic camera parameters.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#removeRadialDistortion(double%5B%5D%5B%5D,double,double)" class="member-name-link">removeRadialDistortion</a><wbr>(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">remove radial distortion from image.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#removeRadialDistortion(double%5B%5D%5B%5D,double,double,boolean)" class="member-name-link">removeRadialDistortion</a><wbr>(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">remove radial distortion from image.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#removeRadialDistortion4(double%5B%5D%5B%5D,double,double)" class="member-name-link">removeRadialDistortion4</a><wbr>(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">remove radial distortion from image.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveFor8PointHomography(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">solveFor8PointHomography</a><wbr>(double[][]&nbsp;coordsC,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useNormConditioning)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">for a given set of feature coordinates in image reference frame and in
 world coordinate system, calculates the homography following the
 algorithm in Wetzstein "EE 267 Virtual Reality
 Course Notes: 6-DOF Pose Tracking with the VRduino".</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForExtrinsic(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D)" class="member-name-link">solveForExtrinsic</a><wbr>(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;kIntr,
 double[][]&nbsp;h)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">following Ma et al.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForExtrinsicPlanarWetzstein(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">solveForExtrinsicPlanarWetzstein</a><wbr>(double[][]&nbsp;coordsC,
 double[][]&nbsp;coordsW)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the camera rotation and translation given camera coordinates and world coordinates
     of features.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForExtrinsics(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,int)" class="member-name-link">solveForExtrinsics</a><wbr>(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;kIntr,
 double[][]&nbsp;h,
 int&nbsp;nImages)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForHomographies(double%5B%5D%5B%5D,double%5B%5D%5B%5D,int,int,boolean)" class="member-name-link">solveForHomographies</a><wbr>(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 int&nbsp;n,
 int&nbsp;nImages,
 boolean&nbsp;useNormConditioning)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForHomography(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">solveForHomography</a><wbr>(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useNormConditioning)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">for a given set of feature coordinates in image reference frame and in
 world coordinate system, calculates the homography following the 
 algorithm in Ma et al.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForHomographyBouget(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">solveForHomographyBouget</a><wbr>(double[][]&nbsp;x0,
 double[][]&nbsp;xW0)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">solve for the planar homography between world coordinate objects xW and the imaged objects' coordinates.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForIntrinsicPlanar(double%5B%5D%5B%5D)" class="member-name-link">solveForIntrinsicPlanar</a><wbr>(double[][]&nbsp;h)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">estimate the camera intrinsic parameters from the image homographies.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#solveForRadialDistortion(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Camera.CameraMatrices,boolean)" class="member-name-link">solveForRadialDistortion</a><wbr>(double[][]&nbsp;uvD,
 double[]&nbsp;u,
 double[]&nbsp;v,
 <a href="Camera.CameraMatrices.html" title="class in algorithms.imageProcessing.transform">Camera.CameraMatrices</a>&nbsp;cameraMatrices,
 boolean&nbsp;useR2R4)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="eps">
<h3>eps</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">eps</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#algorithms.imageProcessing.transform.CameraCalibration.eps">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="eps2">
<h3>eps2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">eps2</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#algorithms.imageProcessing.transform.CameraCalibration.eps2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>CameraCalibration</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">CameraCalibration</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="estimateCameraPlanar(int,double[][],double[][],boolean)">
<h3>estimateCameraPlanar</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Camera.CameraMatrices.html" title="class in algorithms.imageProcessing.transform">Camera.CameraMatrices</a></span>&nbsp;<span class="element-name">estimateCameraPlanar</span><wbr><span class="parameters">(int&nbsp;n,
 double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useR2R4)</span>
                                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></span></div>
<div class="block">for a camera at rest and images taken of a geometric plane in motion,
 estimate the intrinsic and extrinsic camera parameters.
     <pre>
     The method follows Zhang 1999 (
     Z. Zhang. A flexible new technique for camera calibration.
     IEEE Trans. Pattern Analysis and Machine Intelligence, 22(11):1330â€“1334, 2000.)
     and Zhang 2004, Chap 2 Camera Calibration
      in "Emerging Topics in Computer Vision" by Medioni &amp; Kang

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - n is the number of points in each image which is the
              same for all images.  n is number of features.</dd>
<dd><code>coordsI</code> - holds the homogenous image coordinates in pixels of
               features present in all images ordered in the same
               manner and paired with features in coordsW.
               It is a 2-dimensional double array of format
               3 X (N*n) where N is the number of images.
               the first row is the x coordinates, the second row
               is the y coordinates, and the third row is "1"'s.
               The columns hold each image in order and within each image's
               columns are the features presented in the same order in each image.
               In Table 1 of Ma, Chen, &amp; Moore 2003 "Camera Calibration"
               these are the (u_d, v_d) pairs.
    <pre>
    e.g. coordsI = [ [xim1[0], xim1[1], ...xim1[n-1], xim2[0], xim2[1],...xim2[n-1],..., ]
                    [yim1[0], yim1[1], ...yim1[n-1], yim2[0], yim2[1],...yim2[n-1],...]
                    [1, 1, ...1, 1, 1,...1,...]]
    </pre></dd>
<dd><code>coordsW</code> - holds the homogenous world coordinates of features, ordered
               by the same features in the images.
               the first row is the X coordinates, the second row
               is the Y coordinates, and the third row is 1's 
               (Z_w = 0, the scale factor is lost in the homography).
               It is a 2-dimensional double array of format
               3 X n</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
    f(r) = 1 +k1*r^2 + k2*r^4 if true,
    else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dt>Returns:</dt>
<dd>camera intrinsic parameters, extrinsic parameters, and radial
 distortion coefficients</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></code> - if there is an error in use of MPSolver during the
 removal of radial distortion, a generic exception is thrown with the
 error message from the MPSolve documentation.</dd>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="estimateCamera3D(int,double[][],double[][],boolean)">
<h3>estimateCamera3D</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Camera.CameraMatrices.html" title="class in algorithms.imageProcessing.transform">Camera.CameraMatrices</a></span>&nbsp;<span class="element-name">estimateCamera3D</span><wbr><span class="parameters">(int&nbsp;n,
 double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useR2R4)</span>
                                              throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></span></div>
<div class="block">estimate the intrinsic and extrinsic camera parameters.
     To refine the returned values, follow with PNP.solveForPose(...).
 The method uses double[] rVec = Rotation.extractRotationVectorRodrigues(r);
 to extract the included rotation vectors.
 TODO: this method could be overloaded to use an indicator variable for a feature presence in
 an image, etc.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - n is the number of points in each image which is the
    same for all images.  n is number of features.</dd>
<dd><code>coordsI</code> - holds the image coordinates in pixels of
    features present in all images ordered in the same
    manner and paired with features in coordsW.
    It is a 2-dimensional double array of format
    3 X (N*n) where N is the number of images.
    the first row is the x coordinates, the second row
    is the y coordinates, and the third row is "1"'s.
    The columns hold each image in order and within each image's
    columns are the features presented in the same order in each image.
    In Table 1 of Ma, Chen, &amp; Moore 2003 "Camera Calibration"
    these are the (u_d, v_d) pairs.</dd>
<dd><code>coordsW</code> - holds the world coordinates of features, ordered
    by the same features in the images.
    the first row is the X coordinates, the second row
    is the Y coordinates, and the third row is 1's
    (Z_w = 0, the scale factor is lost in the homography).
    It is a 2-dimensional double array of format
    3 X n</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
     f(r) = 1 +k1*r^2 + k2*r^4 if true,
     else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dt>Returns:</dt>
<dd>camera intrinsic parameters, extrinsic parameters, and radial
 distortion coefficients</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></code> - if there is an error in use of MPSolver during the
 removal of radial distortion, a generic exception is thrown with the
 error message from the MPSolve documentation.</dd>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addDimension1(double[][])">
<h3>addDimension1</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">addDimension1</span><wbr><span class="parameters">(double[][]&nbsp;a)</span></div>
<div class="block">given a matrix of length n, return same matrix with a row of 1s appended to it</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - </dd>
<dt>Returns:</dt>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForHomography(double[][],double[][],boolean)">
<h3>solveForHomography</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">solveForHomography</span><wbr><span class="parameters">(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useNormConditioning)</span>
                                     throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">for a given set of feature coordinates in image reference frame and in
 world coordinate system, calculates the homography following the 
 algorithm in Ma et al. 2003.
 scaleFactor * [u v 1] (col) = K * [r1  r2  t] (col) * [X_W  Y_W 1] (col).
 this is also in sect 2.4 of camera calibration book by zhang
 as homography between a model plane and its image (in camera calibration w/ 2d objects: plane based techniques).

 see also CameraPose.calculatePFromXXW(...)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsI</code> - holds the image coordinates in pixels of features present in image i as format [3 X nPoints].
                Only the first 2 dimensions are used, so if the 3rd dimension (z axis) is present, it is
                the responsibility of the invoker to have normalized the 1st 2 dimensions by the 3rd.</dd>
<dd><code>coordsW</code> - holds the world coordinates of features present in image 1 corresponding
               to the same features and order of coordsI_i as format [3 X nPoints].
                Only the first 2 dimensions are used, so if the 3rd dimension (z axis) is present, it is
                the responsibility of the invoker to have normalized the 1st 2 dimensions by the 3rd.</dd>
<dt>Returns:</dt>
<dd>the homography, projection matrix</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveFor8PointHomography(double[][],double[][],boolean)">
<h3>solveFor8PointHomography</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">solveFor8PointHomography</span><wbr><span class="parameters">(double[][]&nbsp;coordsC,
 double[][]&nbsp;coordsW,
 boolean&nbsp;useNormConditioning)</span>
                                           throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">for a given set of feature coordinates in image reference frame and in
 world coordinate system, calculates the homography following the
 algorithm in Wetzstein "EE 267 Virtual Reality
 Course Notes: 6-DOF Pose Tracking with the VRduino".

 This algorithm uses a passive right-hand transformation system.
 It flips the z-coordinate system so that observer is in the origin looking down the negative z axis towards
 the moving object.  The algorithm also sets h[2][2] to 1 in solving for pose.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsC</code> - holds the feature coordinates in camera reference frame image i as format [3 X nPoints].
                Only the first 2 dimensions are used, so if the 3rd dimension (z axis) is present, it is
                the responsibility of the invoker to have normalized the 1st 2 dimensions by the 3rd.
                Note that the method should work similarly if input is feature coordinates in image frame instead,
                but the -z should be considered afterward when using the homography.</dd>
<dd><code>coordsW</code> - holds the world coordinates of features present in image 1 corresponding
    to the same features and order of coordsC_i as format [3 X nPoints].
                Only the first 2 dimensions are used, so if the 3rd dimension (z axis) is present, it is
                the responsibility of the invoker to have normalized the 1st 2 dimensions by the 3rd.</dd>
<dt>Returns:</dt>
<dd>the homography, projection matrix</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForHomographyBouget(double[][],double[][])">
<h3>solveForHomographyBouget</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">solveForHomographyBouget</span><wbr><span class="parameters">(double[][]&nbsp;x0,
 double[][]&nbsp;xW0)</span>
                                           throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">solve for the planar homography between world coordinate objects xW and the imaged objects' coordinates.
 x ~ H*xW where "~" means equal up to a non zero scalar factor.

 this method is similar to solveForHomography(), but has additional normalization and a refinement step,
 all ported from github repositories holding the Bouguet Matlab Toolbox code.
 The Bouguet's toolbox web page implies that the source is freely available.
 The github repositories with the Bouguet Matlab code that the individual authors have modified do not have license
 information.  Those references are here and the method this is adapted from.
 <pre>
     http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     compute_homography.m in
     https://github.com/fragofer/TOOLBOX_calib
     and
     https://github.com/hunt0r/Bouguet_cam_cal_toolbox
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x0</code> - image coordinates</dd>
<dd><code>xW0</code> - world coordinates</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForIntrinsicPlanar(double[][])">
<h3>solveForIntrinsicPlanar</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a></span>&nbsp;<span class="element-name">solveForIntrinsicPlanar</span><wbr><span class="parameters">(double[][]&nbsp;h)</span>
                                                         throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">estimate the camera intrinsic parameters from the image homographies.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>h</code> - H as (3*NImages)x3 homography, projection matrices
              where each image homography is stacked row-wise</dd>
<dt>Returns:</dt>
<dd>the camera intrinsic parameters.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_solveForIntrinsicPlanar(double[][])">
<h3>_solveForIntrinsicPlanar</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a></span>&nbsp;<span class="element-name">_solveForIntrinsicPlanar</span><wbr><span class="parameters">(double[][]&nbsp;h)</span>
                                                          throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">estimate the camera intrinsic parameters from the image homographies.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>h</code> - H as (3*NImages)x3 homography, projection matrices
    where each image homography is stacked row-wise</dd>
<dt>Returns:</dt>
<dd>the camera intrinsic parameters.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForExtrinsic(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][])">
<h3>solveForExtrinsic</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></span>&nbsp;<span class="element-name">solveForExtrinsic</span><wbr><span class="parameters">(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;kIntr,
 double[][]&nbsp;h)</span>
                                                   throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">following Ma et al. 2003
 estimate the extrinsic parameters from the image of the absolute conic.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>kIntr</code> - camera intrinsic parameters</dd>
<dd><code>h</code> - homography for the projection for an image. at least 5 points should have been used
          to generate h.</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForExtrinsicPlanarWetzstein(double[][],double[][])">
<h3>solveForExtrinsicPlanarWetzstein</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></span>&nbsp;<span class="element-name">solveForExtrinsicPlanarWetzstein</span><wbr><span class="parameters">(double[][]&nbsp;coordsC,
 double[][]&nbsp;coordsW)</span>
                                                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">calculate the camera rotation and translation given camera coordinates and world coordinates
     of features.
     Note that coordsC = (intrinsicCamera)^-1 * coordsI where coordsI are the feature coordinates in
     the image frame in units of pixels.
 following Wetzstein "EE 267 Virtual Reality
      * Course Notes: 6-DOF Pose Tracking with the VRduino"
 estimate the extrinsic parameters from the features given positions in camera coordinates
 and WCS real world coordinates.

 The pose results can be improved by following it with use of non-linear Levenberg-Marquardt or
 other optimization method. see Appendix A of Wetzstein reference.

 Also, one can follow with radial distortion corrections.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsC</code> - holds the feature coordinates in camera reference frame image i as format [3 X nPoints].
                Only the first 2 dimensions are used, so if the 3rd dimension (z axis) is present, it is
                the responsibility of the invoker to have normalized the 1st 2 dimensions by the 3rd.
                Note that the method should work similarly if input is feature coordinates in image frame instead,
                but the -z should be considered afterward when using the homography.</dd>
<dd><code>coordsW</code> - holds the world coordinates of features present in image 1 corresponding
    to the same features and order of coordsC_i as format [3 X nPoints].
                Only the first 2 dimensions are used, so if the 3rd dimension (z axis) is present, it is
                the responsibility of the invoker to have normalized the 1st 2 dimensions by the 3rd.</dd>
<dt>Returns:</dt>
<dd>the pose, that is camera rotation and translation</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applyRadialDistortion(double[][],double,double,boolean)">
<h3>applyRadialDistortion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">applyRadialDistortion</span><wbr><span class="parameters">(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4)</span></div>
<div class="block">apply radial distortion to distortion-free camera centered coordinates using 
    the algorithm of Ma, Chen &amp; Moore (which is Ma et al. 2003) for the
    distortion function expressed as f(r) = 1 + k1*r + k2*r^2 (which is 
    equation #3 in Table 2 of Ma et al. 2004).
    In terms of the variables outlined below, the algorithm input is
    (x, y), k1, k2, and cameraIntrinsics and the output is (x_d, y_d).
    TODO: consider overloading this method to implement equation #4. 
    <pre>
    Ma, Chen &amp; Moore 2004, "Rational Radial Distortion Models of Camera Lenses 
    with Analytical Solution for Distortion Correction."
    International Journal of Information Acquisition Â· June 2004    
    
    defining variables:
        K            :  camera intrinsics matrix
        (u_d, v_d)   :  Distorted image point in pixel
        (u, v)       :  Distortion-free image point in pixel
        (x_d, y_d)   :  [x_d, y_d, 1]^T = K^âˆ’1[u_d, v_d, 1]^T
        (x, y)       :  [x, y, 1]^T = K^âˆ’1[u, v, 1]^T
        r_d          :  r_d^2 = x_d^2 + y_d^2
        r            :  r^2 = x^2 + y^2
        k1, k2, ...  :  Radial distortion coefficients

    and the projection equation variables:
    [X_c,Y_c,Z_c]^T denotes a point in the camera frame which is related to the 
        corresponding point 
    [X_w, Y_w, Z_w]^T in the world reference frame 
        by
    P_c = R P_w + t
    R is thr rotation matrix
    t is the translation vector
    
    lambda * [u] = K [R|t] [X_w] = K [X_c]
             [v]           [Y_w]     [Y_c]
             [1]           [Z_w]     [Z_c]
                           [1  ]
    
    ==> To Apply Radial Distortion, given coefficients k1, k2 and coordinates
      (eqn 7) r_d = r * f(r) = r*(1 + k1*r + k2*r^2 + k3*r^3 + ...)
      (eqn 8) using only 2 coeffs: f(r) = (1 + k1*r + k2*r^2)
    
      Ma et al. 2003 distortion model:
         x_d = x * f(r)
         y_d = y * f(r)
    
    ==> Radial Undistortion:
        solve for cubic roots
        https://en.wikipedia.org/wiki/Cubic_equation#Reduction_to_a_depressed_cubic
        though authors use Pearson's 1983 version of 
           Handbook of Applied Mathematics: Selected Results and Methods
    
        from k2*r^3 +k1*r^2 +r - r_d = 0
        solve 
           r_bar^3 + r_bar*p + q = 0
        where 
          r_bar = r + (a/3)
          a = k1/k2
          b = 1/k2
          c = âˆ’r_d/k2
          p = b âˆ’ (a^2/3)
          q = (2a^3)/27 âˆ’ ab/3 + c
        then use depressed cubic root to solve for r_bar.
        r = r_bar = (a/3)
    
        After r is determined, (u,v) can be calculated from (Eqn 5) which is
           u_d - u_0 = (uâˆ’u_0) * f(r)
           v_d âˆ’ v_0 = (vâˆ’v_0) * f(r)
          
    Useful reading is also:
    Drap et al, "An Exact Formula for Calculating Inverse Radial Lens Distortions"
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/
        Radial distortion is caused by the spherical shape of the lens, 
        whereas tangential distortion is caused by the decentering and 
        non-orthogonality of the lens components with respect to the 
        optical axis
        ...Barrel distortion can be physically present in small focal length 
        systems, while larger focal lengths can result in pincushion distortion 
        ...
        barrel distortion corresponds to a negative value of k1.
        pincushion distortion to a positive value of k1.
         
    NOTE that Drap et al. also apply the camera intrinsics, but they use a 
    focal length of "1".
 
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xC</code> - distortion-free camera centered coordinates.  format is 3XN where N is the
    number of points.
    In terms of Table 1 of Chen et al. 2004, this is a double array of (x, y).</dd>
<dd><code>k1</code> - first radial distortion coefficient</dd>
<dd><code>k2</code> - second radial distortion coefficient</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
    f(r) = 1 +k1*r^2 + k2*r^4 if true,
    else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dt>Returns:</dt>
<dd>distorted camera centered coordinates in format 3XN where N is
    the number of points.
    In terms of Table 1 of Chen et al. 2004, this is a double array of (x_d, y_d).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applyRadialDistortion(double[],double,double,boolean)">
<h3>applyRadialDistortion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">applyRadialDistortion</span><wbr><span class="parameters">(double[]&nbsp;xCPt,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4)</span></div>
<div class="block">apply radial distortion to distortion-free camera centered coordinates using 
    the algorithm of Ma, Chen &amp; Moore (which is Ma et al. 2003) for the
    distortion function expressed as f(r) = 1 + k1*r + k2*r^2 (which is 
    equation #3 in Table 2 of Ma et al. 2004).
    In terms of the variables outlined below, the algorithm input is
    (x, y), k1, k2, and cameraIntrinsics and the output is (x_d, y_d).
    TODO: consider overloading this method to implement equation #4. 
    <pre>
    Ma, Chen &amp; Moore 2004, "Rational Radial Distortion Models of Camera Lenses 
    with Analytical Solution for Distortion Correction."
    International Journal of Information Acquisition Â· June 2004    
    
    defining variables:
        K            :  camera intrinsics matrix
        (u_d, v_d)   :  Distorted image point in pixel
        (u, v)       :  Distortion-free image point in pixel
        (x_d, y_d)   :  [x_d, y_d, 1]^T = K^âˆ’1[u_d, v_d, 1]^T
        (x, y)       :  [x, y, 1]^T = K^âˆ’1[u, v, 1]^T
        r_d          :  r_d^2 = x_d^2 + y_d^2
        r            :  r^2 = x^2 + y^2
        k1, k2, ...  :  Radial distortion coefficients

    and the projection equation variables:
    [X_c,Y_c,Z_c]^T denotes a point in the camera frame which is related to the 
        corresponding point 
    [X_w, Y_w, Z_w]^T in the world reference frame 
        by
    P_c = R P_w + t
    R is thr rotation matrix
    t is the translation vector
    
    lambda * [u] = K [R|t] [X_w] = K [X_c]
             [v]           [Y_w]     [Y_c]
             [1]           [Z_w]     [Z_c]
                           [1  ]
    
    ==> To Apply Radial Distortion, given coefficients k1, k2 and coordinates
      (eqn 7) r_d = r * f(r) = r*(1 + k1*r + k2*r^2 + k3*r^3 + ...)
      (eqn 8) using only 2 coeffs: f(r) = (1 + k1*r + k2*r^2)
    
      Ma et al. 2003 distortion model:
         x_d = x * f(r)
         y_d = y * f(r)
    
    ==> Radial Undistortion:
        solve for cubic roots
        https://en.wikipedia.org/wiki/Cubic_equation#Reduction_to_a_depressed_cubic
        though authors use Pearson's 1983 version of 
           Handbook of Applied Mathematics: Selected Results and Methods
    
        from k2*r^3 +k1*r^2 +r - r_d = 0
        solve 
           r_bar^3 + r_bar*p + q = 0
        where 
          r_bar = r + (a/3)
          a = k1/k2
          b = 1/k2
          c = âˆ’r_d/k2
          p = b âˆ’ (a^2/3)
          q = (2a^3)/27 âˆ’ ab/3 + c
        then use depressed cubic root to solve for r_bar.
        r = r_bar = (a/3)
    
        After r is determined, (u,v) can be calculated from (Eqn 5) which is
           u_d - u_0 = (uâˆ’u_0) * f(r)
           v_d âˆ’ v_0 = (vâˆ’v_0) * f(r)
          
    Useful reading is also:
    Drap et al, "An Exact Formula for Calculating Inverse Radial Lens Distortions"
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/
        Radial distortion is caused by the spherical shape of the lens, 
        whereas tangential distortion is caused by the decentering and 
        non-orthogonality of the lens components with respect to the 
        optical axis
        ...Barrel distortion can be physically present in small focal length 
        systems, while larger focal lengths can result in pincushion distortion 
        ...
        barrel distortion corresponds to a negative value of k1.
        pincushion distortion to a positive value of k1.
         
    NOTE that Drap et al. also apply the camera intrinsics, but they use a 
    focal length of "1".
 
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xCPt</code> - distortion-free camera centered coordinates for a point.  The
    length is 3.
    In terms of Table 1 of Chen et al. 2004, this is a double array of (x, y).</dd>
<dd><code>k1</code> - first radial distortion coefficient</dd>
<dd><code>k2</code> - second radial distortion coefficient</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
    f(r) = 1 +k1*r^2 + k2*r^4 if true,
    else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dt>Returns:</dt>
<dd>distorted camera centered coordinates in format 3XN where N is
    the number of points.
    In terms of Table 1 of Chen et al. 2004, this is a double array of (x_d, y_d).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applyRadialDistortion(double[],double,double,boolean,double[])">
<h3>applyRadialDistortion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">applyRadialDistortion</span><wbr><span class="parameters">(double[]&nbsp;xCPt,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4,
 double[]&nbsp;outputDistorted)</span></div>
<div class="block">apply radial distortion to distortion-free camera centered coordinates using 
    the algorithm of Ma, Chen &amp; Moore (which is Ma et al. 2003) for the
    distortion function expressed as f(r) = 1 + k1*r + k2*r^2 (which is 
    equation #3 in Table 2 of Ma et al. 2004).
    In terms of the variables outlined below, the algorithm input is
    (x, y), k1, k2, and cameraIntrinsics and the output is (x_d, y_d).
    TODO: consider overloading this method to implement equation #4. 
    <pre>
    Ma, Chen &amp; Moore 2004, "Rational Radial Distortion Models of Camera Lenses 
    with Analytical Solution for Distortion Correction."
    International Journal of Information Acquisition Â· June 2004    
    
    defining variables:
        K            :  camera intrinsics matrix
        (u_d, v_d)   :  Distorted image point in pixel
        (u, v)       :  Distortion-free image point in pixel
        (x_d, y_d)   :  [x_d, y_d, 1]^T = K^âˆ’1[u_d, v_d, 1]^T
        (x, y)       :  [x, y, 1]^T = K^âˆ’1[u, v, 1]^T
        r_d          :  r_d^2 = x_d^2 + y_d^2
        r            :  r^2 = x^2 + y^2
        k1, k2, ...  :  Radial distortion coefficients

    and the projection equation variables:
    [X_c,Y_c,Z_c]^T denotes a point in the camera frame which is related to the 
        corresponding point 
    [X_w, Y_w, Z_w]^T in the world reference frame 
        by
    P_c = R P_w + t
    R is thr rotation matrix
    t is the translation vector
    
    lambda * [u] = K [R|t] [X_w] = K [X_c]
             [v]           [Y_w]     [Y_c]
             [1]           [Z_w]     [Z_c]
                           [1  ]
    
    ==> To Apply Radial Distortion, given coefficients k1, k2 and coordinates
      (eqn 7) r_d = r * f(r) = r*(1 + k1*r + k2*r^2 + k3*r^3 + ...)
      (eqn 8) using only 2 coeffs: f(r) = (1 + k1*r + k2*r^2)
    
      Ma et al. 2003 distortion model:
         x_d = x * f(r)
         y_d = y * f(r)
    
    ==> Radial Undistortion:
        solve for cubic roots
        https://en.wikipedia.org/wiki/Cubic_equation#Reduction_to_a_depressed_cubic
        though authors use Pearson's 1983 version of 
           Handbook of Applied Mathematics: Selected Results and Methods
    
        from k2*r^3 +k1*r^2 +r - r_d = 0
        solve 
           r_bar^3 + r_bar*p + q = 0
        where 
          r_bar = r + (a/3)
          a = k1/k2
          b = 1/k2
          c = âˆ’r_d/k2
          p = b âˆ’ (a^2/3)
          q = (2a^3)/27 âˆ’ ab/3 + c
        then use depressed cubic root to solve for r_bar.
        r = r_bar = (a/3)
    
        After r is determined, (u,v) can be calculated from (Eqn 5) which is
           u_d - u_0 = (uâˆ’u_0) * f(r)
           v_d âˆ’ v_0 = (vâˆ’v_0) * f(r)
          
    Useful reading is also:
    Drap et al, "An Exact Formula for Calculating Inverse Radial Lens Distortions"
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/
        Radial distortion is caused by the spherical shape of the lens, 
        whereas tangential distortion is caused by the decentering and 
        non-orthogonality of the lens components with respect to the 
        optical axis
        ...Barrel distortion can be physically present in small focal length 
        systems, while larger focal lengths can result in pincushion distortion 
        ...
        barrel distortion corresponds to a negative value of k1.
        pincushion distortion to a positive value of k1.
         
    NOTE that Drap et al. also apply the camera intrinsics, but they use a 
    focal length of "1".
 
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xCPt</code> - distortion-free camera centered coordinates for a point.  The
    length is 3.
    In terms of Table 1 of Chen et al. 2004, this is a double array of (x, y).</dd>
<dd><code>k1</code> - first radial distortion coefficient</dd>
<dd><code>k2</code> - second radial distortion coefficient</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
    f(r) = 1 +k1*r^2 + k2*r^4 if true,
    else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dd><code>outputDistorted</code> - distorted camera centered coordinates in format 3XN where N is
    the number of points.
    In terms of Table 1 of Chen et al. 2004, this is a double array of (x_d, y_d).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeRadialDistortion(double[][],double,double,boolean)">
<h3>removeRadialDistortion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">removeRadialDistortion</span><wbr><span class="parameters">(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2,
 boolean&nbsp;useR2R4)</span>
                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">remove radial distortion from image.
    The algorithm follows Ma, Chen, &amp; Moore 2004.
    In terms of the variables outlined in comments below, the algorithm input is
    distorted points as a double array of (x_d, x_d), and the radial distortion
    coefficients k1, k2.  The output is a double array of (x, y).
    Choices for the distortion function are models #3 and #4.
    <pre>
    Ma, Chen &amp; Moore 2004, "Rational Radial Distortion Models of Camera Lenses 
    with Analytical Solution for Distortion Correction."
    International Journal of Information Acquisition Â· June 2004    
    
    defining variables:
        K            :  camera intrinsics matrix
        (u_d, v_d)   :  Distorted image point in pixel
        (u, v)       :  Distortion-free image point in pixel
        (x_d, y_d)   :  [x_d, y_d, 1]^T = K^âˆ’1[u_d, v_d, 1]^T
        (x, y)       :  [x, y, 1]^T = K^âˆ’1[u, v, 1]^T
        r_d          :  r_d^2 = x_d^2 + y_d^2
        r            :  r^2 = x^2 + y^2
        k1, k2, ...  :  Radial distortion coefficients
      
    Useful reading is also:
    Drap et al, "An Exact Formula for Calculating Inverse Radial Lens Distortions"
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/
        Radial distortion is caused by the spherical shape of the lens, 
        whereas tangential distortion is caused by the decentering and 
        non-orthogonality of the lens components with respect to the 
        optical axis
        ...Barrel distortion can be physically present in small focal length 
        systems, while larger focal lengths can result in pincushion distortion 
        ...
        barrel distortion corresponds to a negative value of k1.
        pincushion distortion to a positive value of k1.
         
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xC</code> - distorted points in the camera reference frame, presumably 
    already center subtracted.  format is 3XN where N is the
    number of points.  These are (x_d, x_d) pairs in terms of Table 1 in Ma et al. 2004.</dd>
<dd><code>k1</code> - first radial distortion coefficient</dd>
<dd><code>k2</code> - second radial distortion coefficient</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4 if true,
        else use model #3 f(r) = 1 +k1*r + k2*r^2.
        note that if rCoeffs is null or empty, no radial distortion is removed.</dd>
<dt>Returns:</dt>
<dd>undistorted points in the camera reference frame.  Format is 3XN where N is the
    number of points.  These are (x, y) pairs in terms of Table 1 in Ma et al. 2004.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeRadialDistortion(double[][],double,double)">
<h3>removeRadialDistortion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">removeRadialDistortion</span><wbr><span class="parameters">(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2)</span>
                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">remove radial distortion from image.
    The algorithm follows Ma, Chen, &amp; Moore 2004 and is for model #3,
 f(r) = 1 + k1*r + k2*r^2.
    In terms of the variables outlined in comments below, the algorithm input is
    distorted points as a double array of (x_d, x_d), and the radial distortion
    coefficients k1, k2.  The output is a double array of (x, y).
    <pre>
    Ma, Chen &amp; Moore 2004, "Rational Radial Distortion Models of Camera Lenses 
    with Analytical Solution for Distortion Correction."
    International Journal of Information Acquisition Â· June 2004    
    
    defining variables:
        K            :  camera intrinsics matrix
        (u_d, v_d)   :  Distorted image point in pixel
        (u, v)       :  Distortion-free image point in pixel
        (x_d, y_d)   :  [x_d, y_d, 1]^T = K^âˆ’1[u_d, v_d, 1]^T
        (x, y)       :  [x, y, 1]^T = K^âˆ’1[u, v, 1]^T
        r_d          :  r_d^2 = x_d^2 + y_d^2
        r            :  r^2 = x^2 + y^2
        k1, k2, ...  :  Radial distortion coefficients
      
    Useful reading is also:
    Drap et al, "An Exact Formula for Calculating Inverse Radial Lens Distortions"
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/
        Radial distortion is caused by the spherical shape of the lens, 
        whereas tangential distortion is caused by the decentering and 
        non-orthogonality of the lens components with respect to the 
        optical axis
        ...Barrel distortion can be physically present in small focal length 
        systems, while larger focal lengths can result in pincushion distortion 
        ...
        barrel distortion corresponds to a negative value of k1.
        pincushion distortion to a positive value of k1.
    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xC</code> - distorted points in the camera reference frame, presumably 
    already center subtracted.  format is 3XN where N is the
    number of points.  These are (x_d, x_d) pairs in terms of Table 1 in Ma et al. 2004.</dd>
<dd><code>k1</code> - first radial distortion coefficient</dd>
<dd><code>k2</code> - second radial distortion coefficient</dd>
<dt>Returns:</dt>
<dd>undistorted points in the camera reference frame.  Format is 3XN where N is the
    number of points.  These are (x, y) pairs in terms of Table 1 in Ma et al. 2004.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeRadialDistortion4(double[][],double,double)">
<h3>removeRadialDistortion4</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">removeRadialDistortion4</span><wbr><span class="parameters">(double[][]&nbsp;xC,
 double&nbsp;k1,
 double&nbsp;k2)</span>
                                   throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">remove radial distortion from image.
    The algorithm follows Ma, Chen, &amp; Moore 2004 and is for model #4,
 f(r) = 1 + k1*r^2 + k2*r^4.
    In terms of the variables outlined in comments below, the algorithm input is
    distorted points as a double array of (x_d, x_d), and the radial distortion
    coefficients k1, k2.  The output is a double array of (x, y).
    <pre>
    Ma, Chen &amp; Moore 2004, "Rational Radial Distortion Models of Camera Lenses 
    with Analytical Solution for Distortion Correction."
    International Journal of Information Acquisition Â· June 2004    
    
    defining variables:
        K            :  camera intrinsics matrix
        (u_d, v_d)   :  Distorted image point in pixel
        (u, v)       :  Distortion-free image point in pixel
        (x_d, y_d)   :  [x_d, y_d, 1]^T = K^âˆ’1[u_d, v_d, 1]^T
        (x, y)       :  [x, y, 1]^T = K^âˆ’1[u, v, 1]^T
        r_d          :  r_d^2 = x_d^2 + y_d^2
        r            :  r^2 = x^2 + y^2
        k1, k2, ...  :  Radial distortion coefficients
      
    Useful reading is also:
    Drap et al, "An Exact Formula for Calculating Inverse Radial Lens Distortions"
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/
        Radial distortion is caused by the spherical shape of the lens, 
        whereas tangential distortion is caused by the decentering and 
        non-orthogonality of the lens components with respect to the 
        optical axis
        ...Barrel distortion can be physically present in small focal length 
        systems, while larger focal lengths can result in pincushion distortion 
        ...
        barrel distortion corresponds to a 
            negative value of k1.
            present in small focal length systems.
        pincushion distortion to a 
            positive value of k1.
            present in larger focal length systems

    </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xC</code> - distorted points in the camera reference frame, presumably 
    already center subtracted.  format is 3XN where N is the
    number of points.  These are (x_d, x_d) pairs in terms of Table 1 in Ma et al. 2004.</dd>
<dd><code>k1</code> - first radial distortion coefficient</dd>
<dd><code>k2</code> - second radial distortion coefficient</dd>
<dt>Returns:</dt>
<dd>undistorted points in the camera reference frame.  Format is 3XN where N is the
    number of points.  These are (x, y) pairs in terms of Table 1 in Ma et al. 2004.</dd>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculateProjected(double[][],double[][],double[],double[])">
<h3>calculateProjected</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">calculateProjected</span><wbr><span class="parameters">(double[][]&nbsp;coordsW,
 double[][]&nbsp;h,
 double[]&nbsp;u,
 double[]&nbsp;v)</span></div>
<div class="block">calculate the projection of world features in coordsW by the
 homography h into the image plane, storing the results in ud and vd.
 The method follows eqn (17) of Ma, Chen, &amp; Moore 2003 "Camera Calibration".</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>coordsW</code> - the coordinates of the features in world reference frame.
    size is 3 X n.</dd>
<dd><code>h</code> - the homography.  size is (nImages*3) X 3</dd>
<dd><code>u</code> - output projected image x coordinates for all images.
     length is (n*nImages).</dd>
<dd><code>v</code> - output projected image y coordinated for all images.
     length is  (n*nImages).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForRadialDistortion(double[][],double[],double[],algorithms.imageProcessing.transform.Camera.CameraMatrices,boolean)">
<h3>solveForRadialDistortion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">solveForRadialDistortion</span><wbr><span class="parameters">(double[][]&nbsp;uvD,
 double[]&nbsp;u,
 double[]&nbsp;v,
 <a href="Camera.CameraMatrices.html" title="class in algorithms.imageProcessing.transform">Camera.CameraMatrices</a>&nbsp;cameraMatrices,
 boolean&nbsp;useR2R4)</span>
                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>uvD</code> - (ud, vd) are the Real observed distorted image points.
 uvD holds the features in each image in pixel coordinates ordered 
 such that all features of one image are followed by all features
 of the next image.  the x-axis coordinates are in row 0.
 the y-axis coordinates are in row 1.  the third row is all 1's.
               It is a 2 dimensional double array of size
               3 X (N*n) where N is the number of images.
               In Table 1 of Ma, Chen, &amp; Moore 2003 "Camera Calibration"
               these are the (u_d, v_d) pairs.</dd>
<dd><code>u</code> - projections of the WCS feature x coordinates into the image
 reference frame.  array length is n*nImages</dd>
<dd><code>v</code> - projections of the WCS feature y coordinates into the image
 reference frame.  array length is n*nImages</dd>
<dd><code>cameraMatrices</code> - data structure holding the camera intrinsic parameters
 and the extrinsic parameter matrices for each image.</dd>
<dd><code>useR2R4</code> - use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
    f(r) = 1 +k1*r^2 + k2*r^4 if true,
    else use model #3 f(r) = 1 +k1*r + k2*r^2.</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></code> - if there is an error in use of MPSolver during the
 removal of radial distortion, a generic exception is thrown with the
 error message from the MPSolve documentation.</dd>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForHomographies(double[][],double[][],int,int,boolean)">
<h3>solveForHomographies</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">solveForHomographies</span><wbr><span class="parameters">(double[][]&nbsp;coordsI,
 double[][]&nbsp;coordsW,
 int&nbsp;n,
 int&nbsp;nImages,
 boolean&nbsp;useNormConditioning)</span>
                                throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="solveForExtrinsics(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],int)">
<h3>solveForExtrinsics</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&gt;</span>&nbsp;<span class="element-name">solveForExtrinsics</span><wbr><span class="parameters">(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;kIntr,
 double[][]&nbsp;h,
 int&nbsp;nImages)</span>
                                                          throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></span></div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html" title="class or interface in java.lang" class="external-link">Exception</a></code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

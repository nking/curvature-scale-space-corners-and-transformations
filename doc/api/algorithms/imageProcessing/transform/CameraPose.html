<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Fri Sep 13 18:45:45 PDT 2024 -->
<title>CameraPose</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-09-13">
<meta name="description" content="declaration: package: algorithms.imageProcessing.transform, class: CameraPose">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h1 title="Class CameraPose" class="title">Class CameraPose</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">algorithms.imageProcessing.transform.CameraPose</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">CameraPose</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">given a set of features in 1 image in image coordinates and world coordinate space,
 estimate the intrinsic and extrinsic camera parameters.
 This is also called "geometric camera calibration".

 TODO: write overloaded methods to use quaternion rotation.
 see
 T. Barfoot, et al., Pose estimation using linearized rotations and quaternion algebra,
 Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
 
 TODO: consider solving with M-estimators.
 see http://research.microsoft.com/en- us/um/people/zhang/INRIA/Publis/Tutorial-Estim/node24.html
   or robust MM-estimator, or Least trimmed squares (LTS)
 
 From Tumurbaatar, and Kim 2019, Sensors (Basel). 2019 Apr; 19(8): 1905.
 "Comparative Study of Relative-Pose Estimations from a Monocular Image 
 Sequence in Computer Vision and Photogrammetry"
 We show that homography-based approaches are more accurate than essential-matrix 
 or relative orientationâ€“based approaches under noisy conditions.</div>
<dl class="notes">
<dt>Author:</dt>
<dd>nichole</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="CameraPose.ProjectedPoints.html" class="type-name-link" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static double</code></div>
<div class="col-second even-row-color"><code><a href="#eps" class="member-name-link">eps</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">CameraPose</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#bouguetPoseInitNonPlanar(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">bouguetPoseInitNonPlanar</a><wbr>(double[][]&nbsp;xc,
 double[][]&nbsp;X,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#bouguetPoseInitPlanar(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D,no.uib.cipr.matrix.DenseMatrix,double%5B%5D,boolean)" class="member-name-link">bouguetPoseInitPlanar</a><wbr>(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 double[][]&nbsp;xc,
 double[][]&nbsp;X,
 no.uib.cipr.matrix.DenseMatrix&nbsp;vT,
 double[]&nbsp;XMean,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calc a rotation (ambiguous) and translation between the measurements of a point in the real world.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#bouguetPoseRefine(algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters,algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)" class="member-name-link">bouguetPoseRefine</a><wbr>(<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;init,
 <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 double[][]&nbsp;xi,
 double[][]&nbsp;X,
 boolean&nbsp;useBouguetsRodrigues)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#bouguetProjectPoints2(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,boolean)" class="member-name-link">bouguetProjectPoints2</a><wbr>(double[][]&nbsp;X,
 double[]&nbsp;om,
 double[]&nbsp;t,
 <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Projects a 3D structure onto the image plane.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>(package private) static <a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#bouguetRigidMotion(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,boolean)" class="member-name-link">bouguetRigidMotion</a><wbr>(double[][]&nbsp;X,
 double[]&nbsp;om,
 double[]&nbsp;T,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Computes the rigid motion transformation Y = R*X+T, where R = rodrigues(om).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculatePFromXXW(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">calculatePFromXXW</a><wbr>(double[][]&nbsp;x,
 double[][]&nbsp;X)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given a single image which has matched image positions x with real world positions X,
 estimate the camera matrix P using a camera model x = P * X and DLT.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Camera.CameraPoseParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraPoseParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculatePoseFromP(double%5B%5D%5B%5D)" class="member-name-link">calculatePoseFromP</a><wbr>(double[][]&nbsp;p)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given the camera projection matrix (i.e.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Camera.CameraPoseParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraPoseParameters</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculatePoseFromXXW(double%5B%5D%5B%5D,double%5B%5D%5B%5D)" class="member-name-link">calculatePoseFromXXW</a><wbr>(double[][]&nbsp;x,
 double[][]&nbsp;X)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">given an image and matched image features coordinates with real world coordinates, estimate the
 camera matrix intrinsic and extrinsic parameters using a pin-hole camera model.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#calculatePoseUsingBouguet(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean,boolean)" class="member-name-link">calculatePoseUsingBouguet</a><wbr>(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 double[][]&nbsp;x,
 double[][]&nbsp;X,
 boolean&nbsp;refine,
 boolean&nbsp;useBouguetForRodrigues)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">calculate the camera extrinsic parameters R and T, given a list of coordinates of objects in the world reference frame
 corresponding to a list of their coordinates in an image frame and given the camera intrinsic parameters.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="eps">
<h3>eps</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">eps</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>CameraPose</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">CameraPose</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="calculatePoseFromXXW(double[][],double[][])">
<h3>calculatePoseFromXXW</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Camera.CameraPoseParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraPoseParameters</a></span>&nbsp;<span class="element-name">calculatePoseFromXXW</span><wbr><span class="parameters">(double[][]&nbsp;x,
 double[][]&nbsp;X)</span>
                                                        throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">given an image and matched image features coordinates with real world coordinates, estimate the
 camera matrix intrinsic and extrinsic parameters using a pin-hole camera model.

 This is also known as estimating the Motion.
 This method uses DLT and should be followed by non-linear optimization
 to improve the parameter estimates.
     <pre>
      references:
        https://www.ipb.uni-bonn.de/html/teaching/msr2-2020/sse2-13-DLT.pdf
        slides from a lecture titled "Photogrammetry &amp; Robotics Lab,
         Camera Calibration: Direct Linear Transform" by Cyrill Stachniss
     see also http://www.ipb.uni-bonn.de/photogrammetry-i-ii/
     and
       Kitani lecture notes http://www.cs.cmu.edu/~16385/s17/Slides/11.3_Pose_Estimation.pdf
     </pre>
     <pre>

     Regarding translation, p3 is included in the results.  p3 is the last column in the projection
     matrix calculated internally.  (2) and (4) outlined below are what you should consider using
     to estimate the translation, depending upon your system's use of translate then rotate or vice versa.
         If the user is assuming translate then rotate: X_c = R * (X_wcs - t).
             (1) The projection matrix constructed would be [R | -R*t]
             where the last column is -R*t, R is rotation, t is translation,
             XW is object in real world coordinate frame, X_c is the object location seen in
             the camera reference frame.
             In this case, one would extract the translation
             using t = -1*(R^-1)*p3.  Note that when properly formed, R^-1 = R^T because rotation is orthogonal and unitary.
             (2) For the context of X_im = K * X_c, we have P = [K*R | -K*R*t]
             where K is the intrinsic parameter matrix for the camera.
             In this case, one would extract the translation
             using t = -1 * R^-1 * K^-1 * p3.
         If the user is assuming rotate then translate, X_c = R * X_wcs + t.
             (3) The projection matrix constructed would be [R | t].
             In this case, one would extract the translation
             using t = p3.
             (4) For the context of X_im = K * X_c, we have P = [K*R | K*t].
             In this case, one would extract the translation
             using t = K^-1 * p3.

     This method returns case (2) translation in the CameraExtrinsics field and assumes that x are given
     in image coordinates.

     see also CameraCalibration.solveForHomography(...)
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - the image coordinates of the features in pixels in format 3 X N where
 3 is for x, y, 1 rows, and N columns is the number of features.  At least 6 features are needed.
 NOTE x and X should both be distortion-free or both should be distorted.</dd>
<dd><code>X</code> - the world coordinates of the features in format 3 X N where
 3 is for x, y, 1 rows, and N columns is the number of features.  At least 6 features are needed.
 NOTE x and X should both be distortion-free or both should be distorted.</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculatePoseFromP(double[][])">
<h3>calculatePoseFromP</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Camera.CameraPoseParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraPoseParameters</a></span>&nbsp;<span class="element-name">calculatePoseFromP</span><wbr><span class="parameters">(double[][]&nbsp;p)</span>
                                                      throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">given the camera projection matrix (i.e. K*[R|t]), estimate the
 camera matrix intrinsic and extrinsic parameters using a pin-hole camera model.

 This is also known as estimating the Motion.
 This method uses DLT and should be followed by non-linear optimization
 to improve the parameter estimates.
     <pre>
     references:
     https://www.ipb.uni-bonn.de/html/teaching/msr2-2020/sse2-13-DLT.pdf
     slides from a lecture titled "Photogrammetry &amp; Robotics Lab,
     Camera Calibration: Direct Linear Transform" by Cyrill Stachniss
     see also http://www.ipb.uni-bonn.de/photogrammetry-i-ii/
     and
     Kitani lecture notes http://www.cs.cmu.edu/~16385/s17/Slides/11.3_Pose_Estimation.pdf

     Zhang, chap 2 of camera calibration book:
     https://people.cs.rutgers.edu/~elgammal/classes/cs534/lectures/CameraCalibration-book-chapter.pdf
     </pre>
     <pre>

     Regarding translation, p3 is included in the results.  p3 is the last column in the projection
     matrix calculated internally.  (2) and (4) outlined below are what you should consider using
     to estimate the translation, depending upon your system's use of translate then rotate or vice versa.
     If the user is assuming translate then rotate: X_c = R * (X_wcs - t).
     (1) The projection matrix constructed would be [R | -R*t]
     where the last column is -R*t, R is rotation, t is translation,
     XW is object in real world coordinate frame, X_c is the object location seen in
     the camera reference frame.
     In this case, one would extract the translation
     using t = -1*(R^-1)*p3.  Note that when properly formed, R^-1 = R^T because rotation is orthogonal and unitary.
     (2) For the context of X_im = K * X_c, we have P = [K*R | -K*R*t]
     where K is the intrinsic parameter matrix for the camera.
     In this case, one would extract the translation
     using t = -1 * R^-1 * K^-1 * p3.
     If the user is assuming rotate then translate, X_c = R * X_wcs + t.
     (3) The projection matrix constructed would be [R | t].
     In this case, one would extract the translation
     using t = p3.
     (4) For the context of X_im = K * X_c, we have P = [K*R | K*t].
     In this case, one would extract the translation
     using t = K^-1 * p3.

     This method returns case (2) translation in the CameraExtrinsics field and assumes that x are given
     in image coordinates.

     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p</code> - the camera projection matrix, i.e. K*[R|t] where K is the intrinsic camera matrix, R is rotation,
          matrix, t is translation vector.</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculatePFromXXW(double[][],double[][])">
<h3>calculatePFromXXW</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="element-name">calculatePFromXXW</span><wbr><span class="parameters">(double[][]&nbsp;x,
 double[][]&nbsp;X)</span>
                                    throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<div class="block">given a single image which has matched image positions x with real world positions X,
 estimate the camera matrix P using a camera model x = P * X and DLT.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - </dd>
<dd><code>X</code> - </dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculatePoseUsingBouguet(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][],boolean,boolean)">
<h3>calculatePoseUsingBouguet</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></span>&nbsp;<span class="element-name">calculatePoseUsingBouguet</span><wbr><span class="parameters">(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 double[][]&nbsp;x,
 double[][]&nbsp;X,
 boolean&nbsp;refine,
 boolean&nbsp;useBouguetForRodrigues)</span>
                                                                  throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">calculate the camera extrinsic parameters R and T, given a list of coordinates of objects in the world reference frame
 corresponding to a list of their coordinates in an image frame and given the camera intrinsic parameters.
 The method is ported from github repositories holding the Bouguet Matlab Toolbox code.
     <pre>
     The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     and states that the source code is freely available.
     The github repositories with forked Bouguet Matlab code do not have license
     information.  Those references are
     https://github.com/fragofer/TOOLBOX_calib
     and
     https://github.com/hunt0r/Bouguet_cam_cal_toolbox
     and the methods adapted from are
     compute_extrinsic_init.m, normalize_pixel.m, compute_homography.m,
     compute_extrinsic_refine.m,  project_points2.m, rigid_motion.m
     </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>intrinsics</code> - </dd>
<dd><code>x</code> - objects in image coordinate reference frame.  size [3Xn].  if given [2Xn], will stack a row of 1's onto it
          internally.</dd>
<dd><code>X</code> - objects in world coordinate reference frame.  size [3Xn]</dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bouguetProjectPoints2(double[][],double[],double[],algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,boolean)">
<h3>bouguetProjectPoints2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></span>&nbsp;<span class="element-name">bouguetProjectPoints2</span><wbr><span class="parameters">(double[][]&nbsp;X,
 double[]&nbsp;om,
 double[]&nbsp;t,
 <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 boolean&nbsp;useBouguetForRodrigues)</span></div>
<div class="block">Projects a 3D structure onto the image plane.
 Bouguet toolbox code project_points2.m</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>X</code> - 3D structure in the world coordinate frame (3xN matrix for N points)</dd>
<dd><code>om</code> - rotation vector (3x1 vector) between world coordinate frame and camera reference frame.</dd>
<dd><code>t</code> - translation vector (3x1 vector) between world coordinate frame and camera reference frame.</dd>
<dd><code>intrinsics</code> - camera intrinsic parameters</dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algorithms for Rodrigues rotation matrices and vectors</dd>
<dt>Returns:</dt>
<dd>[xp, dxpdom, dxpdT] where xp are the Projected pixel coordinates (2xN matrix for N points)
 dxpdom are the Derivatives of xp with respect to om ((2N)x3 matrix), and
 dxpdT are the derivatives of xp with respect to T ((2N)x3 matrix).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bouguetRigidMotion(double[][],double[],double[],boolean)">
<h3>bouguetRigidMotion</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></span>&nbsp;<span class="element-name">bouguetRigidMotion</span><wbr><span class="parameters">(double[][]&nbsp;X,
 double[]&nbsp;om,
 double[]&nbsp;T,
 boolean&nbsp;useBouguetForRodrigues)</span></div>
<div class="block">Computes the rigid motion transformation Y = R*X+T, where R = rodrigues(om).
 <pre>
     rigid_motion.m
     TODO: put other Bouguet toolbox references here
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>X</code> - </dd>
<dd><code>om</code> - </dd>
<dd><code>T</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt>Returns:</dt>
<dd>Y = R*X+T, where R = rodrigues(om).  returns
 Y: 3D coordinates of the structure points in the camera reference frame (3xN matrix for N points)
 %        dYdom: Derivative of Y with respect to om ((3N)x3 matrix)
 %        dYdT: Derivative of Y with respect to T ((3N)x3 matrix)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bouguetPoseRefine(algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters,algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][],boolean)">
<h3>bouguetPoseRefine</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></span>&nbsp;<span class="element-name">bouguetPoseRefine</span><wbr><span class="parameters">(<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;init,
 <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 double[][]&nbsp;xi,
 double[][]&nbsp;X,
 boolean&nbsp;useBouguetsRodrigues)</span>
                                                          throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>init</code> - </dd>
<dd><code>intrinsics</code> - </dd>
<dd><code>xi</code> - </dd>
<dd><code>X</code> - </dd>
<dd><code>useBouguetsRodrigues</code> - if true,uses the Bouguet algorithms for Rodrigues Rotation matrix and vector,
                             else, uses the other Rotation.java Rodrigues methods.
                             Recommend using false at this time.</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bouguetPoseInitPlanar(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][],no.uib.cipr.matrix.DenseMatrix,double[],boolean)">
<h3>bouguetPoseInitPlanar</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></span>&nbsp;<span class="element-name">bouguetPoseInitPlanar</span><wbr><span class="parameters">(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
 double[][]&nbsp;xc,
 double[][]&nbsp;X,
 no.uib.cipr.matrix.DenseMatrix&nbsp;vT,
 double[]&nbsp;XMean,
 boolean&nbsp;useBouguetForRodrigues)</span>
                                                       throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException,
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></span></div>
<div class="block">calc a rotation (ambiguous) and translation between the measurements of a point in the real world.
 the lists xC and X are correspondences of image and object.

 https://github.com/fragofer/TOOLBOX_calib/
 compute_extrinsic_init.m</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>intrinsics</code> - </dd>
<dd><code>xc</code> - objects in camera coordinates</dd>
<dd><code>X</code> - objects in real world coordinates</dd>
<dd><code>vT</code> - formed from the SVD of X (hence, the last column is orthogonal to X)</dd>
<dd><code>XMean</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/IOException.html" title="class or interface in java.io" class="external-link">IOException</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bouguetPoseInitNonPlanar(double[][],double[][],boolean)">
<h3>bouguetPoseInitNonPlanar</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></span>&nbsp;<span class="element-name">bouguetPoseInitNonPlanar</span><wbr><span class="parameters">(double[][]&nbsp;xc,
 double[][]&nbsp;X,
 boolean&nbsp;useBouguetForRodrigues)</span>
                                                          throws <span class="exceptions">no.uib.cipr.matrix.NotConvergedException</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>xc</code> - </dd>
<dd><code>X</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt>Returns:</dt>
<dt>Throws:</dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

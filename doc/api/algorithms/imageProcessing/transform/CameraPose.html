<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.14.1) on Sun Nov 12 11:51:47 PST 2023 -->
<title>CameraPose</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-11-12">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CameraPose";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">algorithms.imageProcessing.transform</a></div>
<h2 title="Class CameraPose" class="title">Class CameraPose</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.imageProcessing.transform.CameraPose</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">CameraPose</span>
extends java.lang.Object</pre>
<div class="block">given a set of features in image coordinates and world coordinate space with
  known camera intrinsic parameters, estimate the camera pose, that is
  extract the camera extrinsic parameters.
 <em>See also PNP.java when it's ready for use.</em>

 Recommended method to use: calculatePoseUsingBouguet(...)

 TODO: write overloaded methods to use quaternion rotation.
 see
 T. Barfoot, et al., Pose estimation using linearized rotations and quaternion algebra,
 Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
 
 TODO: consider solving with M-estimators.
 see http://research.microsoft.com/en- us/um/people/zhang/INRIA/Publis/Tutorial-Estim/node24.html
   or robust MM-estimator, or Least trimmed squares (LTS)
 
 From Tumurbaatar, and Kim 2019, Sensors (Basel). 2019 Apr; 19(8): 1905.
 "Comparative Study of Relative-Pose Estimations from a Monocular Image 
 Sequence in Computer Vision and Photogrammetry"
 We show that homography-based approaches are more accurate than essential-matrix 
 or relative orientationâ€“based approaches under noisy conditions.

 TODO: improve use of memory by reusing array references, use System.arrayCopy, etc.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>nichole</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#eps">eps</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">CameraPose</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>(package private) static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bouguetPoseInitNonPlanar(double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)">bouguetPoseInitNonPlanar</a></span>&#8203;(double[][]&nbsp;xc,
                        double[][]&nbsp;X,
                        boolean&nbsp;useBouguetForRodrigues)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>(package private) static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bouguetPoseInitPlanar(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D,no.uib.cipr.matrix.DenseMatrix,double%5B%5D,boolean)">bouguetPoseInitPlanar</a></span>&#8203;(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                     double[][]&nbsp;xc,
                     double[][]&nbsp;X,
                     no.uib.cipr.matrix.DenseMatrix&nbsp;vT,
                     double[]&nbsp;XMean,
                     boolean&nbsp;useBouguetForRodrigues)</code></th>
<td class="colLast">
<div class="block">calc a rotation (ambiguous) and translation between the measurements of a point in the real world.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bouguetPoseRefine(algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters,algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean)">bouguetPoseRefine</a></span>&#8203;(<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;init,
                 <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                 double[][]&nbsp;xi,
                 double[][]&nbsp;X,
                 boolean&nbsp;useBouguetsRodrigues)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bouguetProjectPoints2(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,boolean)">bouguetProjectPoints2</a></span>&#8203;(double[][]&nbsp;X,
                     double[]&nbsp;om,
                     double[]&nbsp;t,
                     <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                     boolean&nbsp;useBouguetForRodrigues)</code></th>
<td class="colLast">
<div class="block">Projects a 3D structure onto the image plane.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>(package private) static <a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bouguetRigidMotion(double%5B%5D%5B%5D,double%5B%5D,double%5B%5D,boolean)">bouguetRigidMotion</a></span>&#8203;(double[][]&nbsp;X,
                  double[]&nbsp;om,
                  double[]&nbsp;T,
                  boolean&nbsp;useBouguetForRodrigues)</code></th>
<td class="colLast">
<div class="block">Computes the rigid motion transformation Y = R*X+T, where R = rodrigues(om).</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#calculatePFromXXW(double%5B%5D%5B%5D,double%5B%5D%5B%5D)">calculatePFromXXW</a></span>&#8203;(double[][]&nbsp;x,
                 double[][]&nbsp;X)</code></th>
<td class="colLast">
<div class="block">calculate projection matrix P from x = P * X.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static <a href="Camera.CameraPoseParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraPoseParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#calculatePoseAndKUsingDLT(double%5B%5D%5B%5D,double%5B%5D%5B%5D)">calculatePoseAndKUsingDLT</a></span>&#8203;(double[][]&nbsp;x,
                         double[][]&nbsp;X)</code></th>
<td class="colLast">
<div class="block">NOT READY FOR USE.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#calculatePoseUsingBouguet(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D,boolean,boolean)">calculatePoseUsingBouguet</a></span>&#8203;(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                         double[][]&nbsp;x,
                         double[][]&nbsp;X,
                         boolean&nbsp;refine,
                         boolean&nbsp;useBouguetForRodrigues)</code></th>
<td class="colLast">
<div class="block">calculate the camera extrinsic parameters R and T, given a list of coordinates of objects in the world reference frame
 corresponding to a list of their coordinates in an image frame and given the camera intrinsic parameters.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#calculatePoseUsingCameraCalibration(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double%5B%5D%5B%5D,double%5B%5D%5B%5D)">calculatePoseUsingCameraCalibration</a></span>&#8203;(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                                   double[][]&nbsp;x,
                                   double[][]&nbsp;X)</code></th>
<td class="colLast">
<div class="block">given a set of features in image space and world coordinate space with
 known camera intrinsic parameters, estimate the camera pose, that is
 extract the camera extrinsic parameters.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="eps">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>eps</h4>
<pre>public static&nbsp;double eps</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CameraPose</h4>
<pre>public&nbsp;CameraPose()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="calculatePoseAndKUsingDLT(double[][],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculatePoseAndKUsingDLT</h4>
<pre class="methodSignature">public static&nbsp;<a href="Camera.CameraPoseParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraPoseParameters</a>&nbsp;calculatePoseAndKUsingDLT&#8203;(double[][]&nbsp;x,
                                                                    double[][]&nbsp;X)
                                                             throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">NOT READY FOR USE.
 TODO: correct this for normalizations.
 given a set of features in image space and world coordinate space,
 estimate the camera pose, that is
 extract the camera extrinsic parameters of rotation and translation and also the camera
 intrinsic parameters.
 This is also known as estimating the Motion.
 This method uses DLT and should be followed by non-linear optimization
 to improve the parameter estimates.
     <pre>
      references:
        https://www.ipb.uni-bonn.de/html/teaching/msr2-2020/sse2-13-DLT.pdf
        slides from a lecture titled "Photogrammetry & Robotics Lab,
         Camera Calibration: Direct Linear Transform" by Cyrill Stachniss
     see also http://www.ipb.uni-bonn.de/photogrammetry-i-ii/
     and
       Kitani lecture notes http://www.cs.cmu.edu/~16385/s17/Slides/11.3_Pose_Estimation.pdf
     </pre>
     <pre>
     While reading this, keep in mind that this method needs x in image reference frame (units os pixels).
     The case of camera coordinates is explained also, butshould be applied to calculatePoseUsingDLT().

     Regarding translation, p3 is included in the results.  p3 is the last column in the projection
     matrix calculated internally.  (2) and (4) outlined below are what you should consider using
     to estimate the translation, depending upon your system's use of translate then rotate or vice versa.
         If the user is assuming translate then rotate: X_c = R * (X_wcs - t).
             (1) The projection matrix constructed would be [R | -R*t]
             where the last column is -R*t, R is rotation, t is translation,
             XW is object in real world coordinate frame, X_c is the object location seen in
             the camera reference frame.
             In this case, one would extract the translation
             using t = -1*(R^-1)*p3.  Note that when properly formed, R^-1 = R^T because rotation is orthogonal and unitary.
             (2) For the context of X_im = K * X_c, we have P = [K*R | -K*R*t]
             where K is the intrinsic parameter matrix for the camera.
             In this case, one would extract the translation
             using t = -1 * R^-1 * K^-1 * p3.
         If the user is assuming rotate then translate, X_c = R * X_wcs + t.
             (3) The projection matrix constructed would be [R | t].
             In this case, one would extract the translation
             using t = p3.
             (4) For the context of X_im = K * X_c, we have P = [K*R | K*t].
             In this case, one would extract the translation
             using t = K^-1 * p3.

     This method returns case (2) translation in the CameraExtrinsics field and assumes that x are given
     in image coordinates.

     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - the image coordinates of the features in pixels in format 3 X N where
 3 is for x, y, 1 rows, and N columns is the number of features.  At least 6 features are needed.
 NOTE x and X should both be distortion-free or both should be distorted.</dd>
<dd><code>X</code> - the world coordinates of the features in format 3 X N where
 3 is for x, y, 1 rows, and N columns is the number of features.  At least 6 features are needed.
 NOTE x and X should both be distortion-free or both should be distorted.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="calculatePFromXXW(double[][],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculatePFromXXW</h4>
<pre class="methodSignature">public static&nbsp;double[][]&nbsp;calculatePFromXXW&#8203;(double[][]&nbsp;x,
                                           double[][]&nbsp;X)
                                    throws no.uib.cipr.matrix.NotConvergedException</pre>
<div class="block">calculate projection matrix P from x = P * X.
     <pre>
     x = P * X where x and X are homogeneous coordinates (normalized so that last item = 1).
             p11*X[0] + p12*X[1] + p13*X[2] + p14
     x[0] = -------------------------------------
             p31*X[0] + p32*X[1] + p32*X[2] + p34

             p21*X[0] + p22*X[1] + p23*X[2] + p24
     x[1] = -------------------------------------
             p31*X[0] + p32*X[1] + p32*X[2] + p34

     rewrite in terms of factoring p members for DLT:
     -p11*X[0] - p12*X[1] - p13*X[2] - p14                                       + x[0]*(p31*X[0] + p32*X[1] + p32*X[2] + p34) = 0
                                           -p21*X[0] - p22*X[1] - p23*X[2] - p24 + x[1]*(p31*X[0] + p32*X[1] + p32*X[2] + p34) = 0

    A =  [ -X[0], -X[1], -X[2], -1,   0,        0,    0,   0,  x[0]*X[0], x[0]*X[1], x[0]*X[2], x[0] ]   *  [p11, p12, p13, p14, p21, p22, ...]^T
         [ 0,      0,     0,  0,  -X[0], -X[1], -X[2], -1,  x[1]*X[0], x[1]*X[1], x[1]*X[2], x[1]    ]

      A * p = 0

     and svd for least squares fit.
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - coordinates in camera or image reference frame of the objects in X.  need at least 6 points</dd>
<dd><code>X</code> - coordinates of objects in world reference frame.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="calculatePoseUsingCameraCalibration(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculatePoseUsingCameraCalibration</h4>
<pre class="methodSignature">public static&nbsp;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;calculatePoseUsingCameraCalibration&#8203;(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                                                                                   double[][]&nbsp;x,
                                                                                   double[][]&nbsp;X)
                                                                            throws no.uib.cipr.matrix.NotConvergedException,
                                                                                   java.io.IOException</pre>
<div class="block">given a set of features in image space and world coordinate space with
 known camera intrinsic parameters, estimate the camera pose, that is
 extract the camera extrinsic parameters.
 calibrating the camera extrinsic parameters is a.k.a. 
 perspective-n-point-problem where n is the number of features (a.k.a. points).
 It's also called planar homography decomposition.
 This method uses planar homography DLT and should be followed by non-linear optimization
 to improve the parameter estimates.
 Note that the projective matrix assumed is P = [K*R|K*t] from  x_im = K * X_c = K * R * X_wcs + t.
     If you instead are using the convention x_im = K * X_c = K * R * (X_wcs - t),
     the projection matrix would contain P = [K*R | -K*R*t] and so to correct the translation to
     your convention, you can calculate t2 = -1 * pseudoInv(R) * t where t is the returned translation from this method.
 Note that for a proper rotation matrix that is orthogonal and unitary, one can use R^T for inv(R).
 <pre>
 references:
 Ma, Chen, & Moore 2003 "Camera Calibration: a USU Implementation"
 http://www.cs.cmu.edu/~16385/s17/Slides/11.3_Pose_Estimation.pdf
 Zhang 1999, "Flexible Camera Calibration By Viewing a Plane From Unknown Orientations"
 Szeliski 2010 draft of "Computer Vision: Algorithms and Applications"
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>intrinsics</code> - holds camera intrinsics information, including radial distortion parameters if any
                   and the radial distortion parameter type.</dd>
<dd><code>x</code> - the image coordinates of the features in format 3 X N where
 3 is for x, y, 1 rows, and N columns is the number of features.  At least 5 features are needed to
 calculate the extrinsic parameters.</dd>
<dd><code>X</code> - the world coordinates of the features in format 3 X N where
 3 is for x, y, 1 rows, and N columns is the number of features.  At least 5 features are needed to
 calculate the extrinsic parameters.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code>java.io.IOException</code></dd>
</dl>
</li>
</ul>
<a id="calculatePoseUsingBouguet(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][],boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculatePoseUsingBouguet</h4>
<pre class="methodSignature">public static&nbsp;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;calculatePoseUsingBouguet&#8203;(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                                                                         double[][]&nbsp;x,
                                                                         double[][]&nbsp;X,
                                                                         boolean&nbsp;refine,
                                                                         boolean&nbsp;useBouguetForRodrigues)
                                                                  throws no.uib.cipr.matrix.NotConvergedException,
                                                                         java.io.IOException</pre>
<div class="block">calculate the camera extrinsic parameters R and T, given a list of coordinates of objects in the world reference frame
 corresponding to a list of their coordinates in an image frame and given the camera intrinsic parameters.
 The method is ported from github repositories holding the Bouguet Matlab Toolbox code.
     <pre>
     The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     and states that the source code is freely available.
     The github repositories with forked Bouguet Matlab code do not have license
     information.  Those references are
     https://github.com/fragofer/TOOLBOX_calib
     and
     https://github.com/hunt0r/Bouguet_cam_cal_toolbox
     and the methods adapted from are
     compute_extrinsic_init.m, normalize_pixel.m, compute_homography.m,
     compute_extrinsic_refine.m,  project_points2.m, rigid_motion.m
     </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>intrinsics</code> - </dd>
<dd><code>x</code> - objects in image coordinate reference frame.  size [3Xn].  if given [2Xn], will stack a row of 1's onto it
          internally.</dd>
<dd><code>X</code> - objects in world coordinate reference frame.  size [3Xn]</dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code>java.io.IOException</code></dd>
</dl>
</li>
</ul>
<a id="bouguetProjectPoints2(double[][],double[],double[],algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bouguetProjectPoints2</h4>
<pre class="methodSignature">public static&nbsp;<a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a>&nbsp;bouguetProjectPoints2&#8203;(double[][]&nbsp;X,
                                                               double[]&nbsp;om,
                                                               double[]&nbsp;t,
                                                               <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                                                               boolean&nbsp;useBouguetForRodrigues)</pre>
<div class="block">Projects a 3D structure onto the image plane.
 Bouguet toolbox code project_points2.m</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>X</code> - 3D structure in the world coordinate frame (3xN matrix for N points)</dd>
<dd><code>om</code> - rotation vector (3x1 vector) between world coordinate frame and camera reference frame.</dd>
<dd><code>t</code> - translation vector (3x1 vector) between world coordinate frame and camera reference frame.</dd>
<dd><code>intrinsics</code> - camera intrinsic parameters</dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>[xp, dxpdom, dxpdT] where xp are the Projected pixel coordinates (2xN matrix for N points)
 dxpdom are the Derivatives of xp with respect to om ((2N)x3 matrix), and
 dxpdT are the derivatives of xp with respect to T ((2N)x3 matrix).</dd>
</dl>
</li>
</ul>
<a id="bouguetRigidMotion(double[][],double[],double[],boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bouguetRigidMotion</h4>
<pre class="methodSignature">static&nbsp;<a href="CameraPose.ProjectedPoints.html" title="class in algorithms.imageProcessing.transform">CameraPose.ProjectedPoints</a>&nbsp;bouguetRigidMotion&#8203;(double[][]&nbsp;X,
                                                     double[]&nbsp;om,
                                                     double[]&nbsp;T,
                                                     boolean&nbsp;useBouguetForRodrigues)</pre>
<div class="block">Computes the rigid motion transformation Y = R*X+T, where R = rodrigues(om).
 <pre>
     rigid_motion.m
     TODO: put other Bouguet toolbox references here
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>X</code> - </dd>
<dd><code>om</code> - </dd>
<dd><code>T</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Y = R*X+T, where R = rodrigues(om).  returns
 Y: 3D coordinates of the structure points in the camera reference frame (3xN matrix for N points)
 %        dYdom: Derivative of Y with respect to om ((3N)x3 matrix)
 %        dYdT: Derivative of Y with respect to T ((3N)x3 matrix)</dd>
</dl>
</li>
</ul>
<a id="bouguetPoseRefine(algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters,algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][],boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bouguetPoseRefine</h4>
<pre class="methodSignature">public static&nbsp;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;bouguetPoseRefine&#8203;(<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;init,
                                                                 <a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                                                                 double[][]&nbsp;xi,
                                                                 double[][]&nbsp;X,
                                                                 boolean&nbsp;useBouguetsRodrigues)
                                                          throws no.uib.cipr.matrix.NotConvergedException</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>init</code> - </dd>
<dd><code>intrinsics</code> - </dd>
<dd><code>xi</code> - </dd>
<dd><code>X</code> - </dd>
<dd><code>useBouguetsRodrigues</code> - if true,uses the Bouguet algorithms for Rodrigues Rotation matrix and vector,
                             else, uses the other Rotation.java Rodrigues methods.
                             Recommend using false at this time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
<a id="bouguetPoseInitPlanar(algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters,double[][],double[][],no.uib.cipr.matrix.DenseMatrix,double[],boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bouguetPoseInitPlanar</h4>
<pre class="methodSignature">static&nbsp;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;bouguetPoseInitPlanar&#8203;(<a href="Camera.CameraIntrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraIntrinsicParameters</a>&nbsp;intrinsics,
                                                              double[][]&nbsp;xc,
                                                              double[][]&nbsp;X,
                                                              no.uib.cipr.matrix.DenseMatrix&nbsp;vT,
                                                              double[]&nbsp;XMean,
                                                              boolean&nbsp;useBouguetForRodrigues)
                                                       throws no.uib.cipr.matrix.NotConvergedException,
                                                              java.io.IOException</pre>
<div class="block">calc a rotation (ambiguous) and translation between the measurements of a point in the real world.
 the lists xC and X are correspondences of image and object.

 https://github.com/fragofer/TOOLBOX_calib/
 compute_extrinsic_init.m</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>intrinsics</code> - </dd>
<dd><code>xc</code> - objects in camera coordinates</dd>
<dd><code>X</code> - objects in real world coordinates</dd>
<dd><code>vT</code> - formed from the SVD of X (hence, the last column is orthogonal to X)</dd>
<dd><code>XMean</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
<dd><code>java.io.IOException</code></dd>
</dl>
</li>
</ul>
<a id="bouguetPoseInitNonPlanar(double[][],double[][],boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>bouguetPoseInitNonPlanar</h4>
<pre class="methodSignature">static&nbsp;<a href="Camera.CameraExtrinsicParameters.html" title="class in algorithms.imageProcessing.transform">Camera.CameraExtrinsicParameters</a>&nbsp;bouguetPoseInitNonPlanar&#8203;(double[][]&nbsp;xc,
                                                                 double[][]&nbsp;X,
                                                                 boolean&nbsp;useBouguetForRodrigues)
                                                          throws no.uib.cipr.matrix.NotConvergedException</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xc</code> - </dd>
<dd><code>X</code> - </dd>
<dd><code>useBouguetForRodrigues</code> - if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>no.uib.cipr.matrix.NotConvergedException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>

========================================================================
Story: Determine scale w/ blob perimeters and corners
 
    summary: The current implementation of scale calculation uses scale 
      space image contours of the blob perimeters to find matching 
      points and hence scale, but it is vulnerable to differences in the 
      contours between images, for example, due to a large bump or 
      occulusion.  An alternate method is needed to use the same blob 
      perimeters, but corners instead of inflection points and contours.  
      Both methods should be available for use after the changes, but 
      the new algorithm will be the default.
      (see the end of docs/contours.pdf)

    time estimate: 
        minimum: 
        maximum: 

    amount of time used: 

    state of completion: in design phase

    comments regarding state:

    comments:
        refactoring code associated with the current calculations is
        necessary before the new algorithm to assert that the 
        abstraction is correct.

---------------------------------------------------------------------
Task 1:
    goal: Refactor the current BlobScaleFinder and associated classes
       to make the current algorithm available as an alternative choice,
       but the default will be the current algorithm when implemented.
      
    details:  

       BlobScaleFinder:
           should be abstracted to IBlobScaleFinder
               public TransformationParameters solveForScale(
                   ISegmentedImageHelper img1Helper, SegmentationType type1,
                   boolean useBinned1,
                   ISegmentedImageHelper img2Helper, SegmentationType type2,
                   boolean useBinned2,
                   float[] outputScaleRotTransXYStDev)
               public void setToDebug()
           with concrete implmentations:
               BlobContoursScaleFinder
                  is given all content from BlobScaleFinder
               BlobCornersScaleFinder
       
       SegmentedImageHelper:
          should be abstracted to an interface ISegmentedImageHelper, and AbstractSegmentedImageHelper
              
          ISegmentedImageHelper:
              public void applySegmentation(SegmentationType type, boolean applyToBinnedImage) 
                  throws IOException, NoSuchAlgorithmException;
              public void generatePerimeterPointsOfInterest(
                  SegmentationType type, boolean applyToBinnedImage)

          AbstractSegmentedImageHelper:
              should contain all except contour methods and members from existing SegmentedImageHelper

          SegmentedImageBlobContourHelper
          SegmentedImageBlobCornerHelper

       BlobScaleFinderWrapper:
          should be changed to use contours or corners.
          if choice is contours, SegmentedImageBlobContourHelper is constructed and BlobContoursScaleFinder is
              used, else the corner implementations.

       Adapt tests to the changes.

    time estimate: < half day
  
    amount of time used: 

    state of completion:

    comments:
       Later, could consider to implement the service provider interface for contour inflection
       points or corners as choices... It's not the goal of the overall project currently to 
           always provide a choice.
       see $JDK_HOME/docs/technotes/guides/jar/jar.html#Service_Provider 
              
---------------------------------------------------------------------
Task 2:
    goal: Need ability to make corners given just a curve rather than  
        an image.

    details:  
       The existing class CurvatureScaleSpaceCornerDetector should
           move the corner making portion to a separate class.
           The content that needs to be encapsulated is all
           within method 
               Map<PairIntArray, Map<SIGMA, ScaleSpaceCurve> > maps =
                   findCornersInScaleSpaceMaps(edges, useOutdoorMode, corners);

           changes in method:
              member variables need to be passed in as arguments:
                  enableJaggedLineCorrections
                  doStoreCornerRegions
                  edgeCornerRegionMap
                  factorIncreaseForCurvatureMinimum

           new class for moved method and member variable settings: 
               CSSCornerMaker

        Adapt tests to the changes.

    time estimate:  minimum couple of hours, maximum 1 day.
  
    amount of time used: 

    state of completion:

    comments:
              
---------------------------------------------------------------------
Task 3:
    goal: Implement the content for classes for corners specified in 
        Task 1 and add new tests for them, excepting the corner
        matching algorithm which has its own task 4.

    details:  
        Implement:
           BlobCornersScaleFinder
               public TransformationParameters solveForScale(
                   ISegmentedImageHelper img1Helper, SegmentationType type1,
                   boolean useBinned1,
                   ISegmentedImageHelper img2Helper, SegmentationType type2,
                   boolean useBinned2,
                   float[] outputScaleRotTransXYStDev)

           SegmentedImageBlobCornerHelper
               public void generatePerimeterPointsOfInterest(
                   SegmentationType type, boolean applyToBinnedImage)

       BlobScaleFinderWrapper:
          should be changed to use contours by default

       CSSClosedCurveCornerMatcher:    
       Implement combining the blob perimeter corner matching results
        to find the best points that should be used for the euclidean
        transformation calculation.

           (1) compare each from list of blob perimeters of image 1 
               to those in image 2
               -- if the number of corners in current curve1 is very different
                  in the current curve2, log them and discard, do not try to match
               -- use ClosedCurveCornerMatcher to match the points in curve1 w/ curve2.
                  -- the results should be comparable to all other for the same
                     curve1 to find the best 2 solutions for curve1
           (2) with a map of the top 2 best solutions for each curve1, find the
               best consistent answers among the solutions.

       paused here... 
          with the contours, was able to adjust all costs to same
          reference frame, then use bipartite matching between the curve1, curve2 
          pairings for the highest number of matchings for lowest cost.
          then removed solutions that had rotation very different from best solution(s).
          add the solutions with similar params to the best solution, making
          the largest set possible of matched points.
          this is then given to the class which pairs the points and solves
          for euclidean transformation.

           (3)

    time estimate: 
  
    amount of time used: 

    state of completion:

    comments:
              
---------------------------------------------------------------------
Task 4:
    goal: Implement the blob perimeter corner matching algorithm.

    details:  
        Create new class ClosedCurveCornerMatcher.

        The class will have an algorithm similar to the Mokhtarian and
        Macworth min cost search for matching contour peaks, but 
        instead of scale space contours, it will use the closed
        curve's corners and feature descriptors.

        The cost and penalty have to be adjusted to using SSD of feature
        instead of sigma of peak.

        The contour algorithm used as a reference, the properties of
        strongest peak in the contours of an edge.  That sigma was
        used to calculate a penalty for matches of solutions that
        start with smaller sigma contours.
           For corners and feature descriptors, the equivalent should
           be some measure of best matched singly or best matchable
             -- considering the smallest error for a feature (where 
                error is the descriptor's auto-correlation SSD).
             -- considering the corner w/ the largest curvature magnitude.
                
                  X_dot(t,o~) * Y_dot_dot(t,o~) - Y_dot(t,o~) * X_dot_dot(t,o~) 
        k(t,o~) = -------------------------------------------------------------
                                 (X_dot^2(t,o~) + Y_dotY^2(t,o~))^1.5

    needs to be edited here after cost decisions are made

           (1) Determine the strongest reference point for curve1.
               Find the best match to it in curve2 (O(N)).
           (2) Choose the next strongest reference point at large
               distance from the first point.
               Find the best match to it in curve2 (O(N)).
           (3) Estimate the euclidean transformation from the pairs
               of points.
           (4) Apply the transformation to the next strongest reference
               point in curve1 and find the predicted point in curve2.
               The cost should be calculated as the difference between
               the predicted point in curve2 and the closest point.
                   the characteristics to go into the cost should be
                      the distance between predicted and found squared,
                      and the SSD of the feature.
                      (curvature is affected by skew, so cannot be used
                      as a predicted value to be found on the other curve
                      if skew or projection effects are a possibility).
                     
                      The closest match to predicted should be the smallest
                      SSD within a tolerance of the predicted location x,y,
                      where a match is only if the SSD is smaller than its
                      error.
 
                      The cost of the match is the distance from the 
                      predicted (x,y).

                      If there is no match, the cost should be high or infinite.
                         If the 2 starter points solution were correct, but the
                         chosen point to predict a point in curve2 were not
                         present in curve2 at all (due to occlusion, etc),
                         re-trying the solution on another point would be
                         a good idea.
                         However, the same correct solution would be possible
                         from another set of points too.

                      A node in the minCost heap is created for this
                      solution starter which now has 3 matched points,
                      transformation parameters, and a cost.

               The pattern for trying pairs of points:

               If one knew that that best SSD match of a point in curve1 to
               point in curve2 were true for at least 2 points in the curves,
               then one could use a pattern of solution starter points of
                  pt 1 = curve1[0] w/ best SSD match in curve2
                  pt 2 = curve1[1] w/ best SSD match in curve2
                  written as (pt1, pt2) for one solution starter
                             (pt1, pt3) for another solution starter
                             (pt1, pt4)  ""
                             (pt2, pt3)  ""
                             (pt2, pt4)  ""
                             (pt3, pt4)  ""
                             which is n!/(k!(n-k)!) where n=4 and k=2 is 6 solution starters
                             since k is always 2, can rewrite as n*(n-1)/2.

                An improvement to the  n!/(k!(n-k)!) would be to try all matches just for
                the first point in the two points needed in the solution.
                    The number of starter solutions would be  n*n*(n-1)/2 
                    which would be 24 for an example of 4 corners in both curves.
                    The chances of finding the correct solution are much higher.
                    It requires that only one point in the corners common to both curves
                    be a true match for it's best SSD match in curve 2.

                A more thorough pattern guaranteed to find the best solution
                would try every possible combination of curve1[0] with curve2[i] and the
                same for the 2nd point, trying all combinations of pairs.
                That would be n^3*(n-1)/2 number of solutions which becomes large
                very quickly even for a small number of points and has redundant solutions
                among them.  It would be 96 for having 4 corners in both curves
               

                It looks like a limit decided by error and runtime should be chosen to
                decide between the n*(n-1)/2. starter points and the n*n*(n-1)/2. starter points.
                      for n = 5  -->  10 vs 50
                      for n = 10 -->  45 vs 450
                      for n = 15 -->  105 vs 1575
                      for n = 25 -->  300 vs 7500
                Since the corners are already high gradient in intensities, can expect that the
                feature descriptors are somewhat unique so an assumption that the best match
                is correct for at least 2 out of n is not bad for n > 10.
       
                Note, that if needed, an improvement on the minimum approach of n*(n-1)/2 would
                be a set number of best SSD matches for a point, that is the top 2 SSD matches
                are tried instead of the top 1.  The factor would be applied to both points in
                the starter points, so for top 2, would have 4 times more, which is 2 * n*(n-1).

                It looks like a good approach to the first draft would be to use the
                n*(n-1)/2 starter pattern when both curves have number of corners > 10,
                else if number of corners is <= 10, should use the n*n*(n-1)/2 pattern.
   
                     
           (5) Using the pattern decided in (4), create all starter solutions and apply each to
               a strong curvature point in curve 1 (preferably not near the starter points) 
               to estimate the cost as mentioned above.
                   This is the initialization of the min cost heap.

           (6) The solution is continued by extracting the min cost node
               until the current min cost node has no more matchable points.
               
               For each extract min cost node,
                  the next strongest curvature point in its solution not yet included is
                  chosen and the best match is found to it.
                  The cost is calculated and the node is inserted into the heap.

            NOTE: need to consider and revise the cost, especially for no matches within a 
                  tolerance of predicted location...
                  the problem is unmatched points due to occlusion or noise, etc.
                  Those points should probably be given a high cost when unmatched rather than
                  infinite cost or ignored.  infinite cost would result in all solutions being
                  lost.  ignored means that a total possible result for smaller number of
                  matching points could be a better result than a larger number of correct 
                  matching points.
                  --> so the cost of unmatched has to be derived.
                  --> and whether a penalty is needed for starting a solution with a corner 
                      that is not the strongest corner in the curve.  I think the penalty is not
                      needed here.
               
    time estimate: 
  
    amount of time used: 

    state of completion:

    comments:
              
---------------------------------------------------------------------

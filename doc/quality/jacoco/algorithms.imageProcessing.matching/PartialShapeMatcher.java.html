<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartialShapeMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.matching</a> &gt; <span class="el_source">PartialShapeMatcher.java</span></div><h1>PartialShapeMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.matching;

import algorithms.QuickSort;
import algorithms.compGeometry.LinesAndAngles;
import algorithms.imageProcessing.SummedColumnTable;
import algorithms.imageProcessing.features.RANSACEuclideanSolver;
import algorithms.imageProcessing.features.RANSACSolver;
import algorithms.imageProcessing.transform.EpipolarTransformationFit;
import algorithms.imageProcessing.transform.EuclideanTransformationFit;
import algorithms.imageProcessing.transform.MatchedPointsTransformationCalculator;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.search.KNearestNeighbors;
import algorithms.util.CorrespondencePlotter;
import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import gnu.trove.iterator.TObjectFloatIterator;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TDoubleArrayList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TObjectFloatMap;
import gnu.trove.map.TObjectIntMap;
import gnu.trove.map.hash.TObjectFloatHashMap;
import gnu.trove.map.hash.TObjectIntHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.edu.princeton.cs.algs4.Interval;
import thirdparty.edu.princeton.cs.algs4.IntervalRangeSearch;

/**
&lt;pre&gt;
based upon algorithm in paper
 &quot;Efficient Partial Shape Matching
    of Outer Contours: by Donoser
  
     - called IS-Match, integral shape match
     - a silhouette of ordered points are sampled
         making it an &quot;order preserved assignment problem&quot;.
       - a chord angle descriptor is local and global and
         is invariant to similarity transformations.
       - the method returns partial sub matches
         so works with articulated data and occluded shapes
       - uses an efficient integral image based matching algorithm
       - the multi-objective optimization uses principles of
         Paretto efficiency, defined with the fraction of the
         total matched and the summed differences of angles.
       - the final result returned is the sequences and
         the total fraction matched and summed absolute differences,
         instead of the Salukwadze distance of a Paretto frontier.

       * point sampling:
         (a) same number of points over each contour
             - can handle similarity transforms.
               disadvantage is that it is less able to
               handle occlusion or extraneous shapes in
               the shape.
               using the euclidean option works around this.
             - 
               to use in this mode:
                   setToUseSameNumberOfPoints()
                      and the number of points can be set 
                      using dp, with nSample = min(p.n, q.n)/dp
                      and
                   overrideSamplingDistance(dp)
               and optionally:
                   setToUseEuclidean()
         (b) OR, equidistant points (default)
             - can handle occlusion.
               disadvantage in matching when there are
               scale differences between the shapes is
               handled in part by an internal euclidean
               projection.
             - the default sampling of pixels is 3.
               this can be changed using
                   overrideSamplingDistance(dp)
               unit test using dp of 1 and 2 work well

       Note: in the code here I use summed columns instead of summed areas.
       Also note that I've added options for euclidean transformations
       as evaluation for best solution and have added the ability to use
       RANSAC to remove outliers from the best solution.
  
       The runtime complexity for building the integral
       image is O(n*m*n) where m and n are the number of sampled
       points on the input shapes.

       The runtime complexity for the search of the
       integral image of summed differences and analysis,
       are longer than the paper algorithm because n1 reads of
       the n1Xn1 chord differenve matrix are made,
       resulting in a total runtime complexity of
       n2 * O(n1^3).  The increase in accuracy here is useful for articulated
       matches (see scissors test).
       
       Note that &lt;em&gt;PartialShapeMatcher2.java&lt;/em&gt; is the version of the code
       which uses the summed area table as suggested by the paper,
       instead of summed area columns for speed at cost of some accuracy,
       resulting in a runtime complexity of
       n2 * (O(n1 * lg2(n1)).
 &lt;/pre&gt;
 &lt;em&gt;NOTE: You may need to pre-process the shape points
     for example, smooth the boundary.&lt;/em&gt;
 &lt;pre&gt;
     This method:  
        PairIntArray p = imageProcessor
            .extractSmoothedOrderedBoundary()
        uses a Gaussian smoothing of 1 sigma,
  &lt;/pre&gt;
  @author nichole
 */
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">public class PartialShapeMatcher {</span>

    /**
     * in sampling the boundaries of the shapes, one can
     * choose to use the same number for each (which can result
     * in very different spacings for different sized curves)
     * or one can choose a set distance between sampling
     * points.
     * dp is the set distance between sampling points.
       The authors of the paper use 3 as an example.
     */
<span class="fc" id="L134">    protected int dp = 3;</span>

<span class="fc" id="L136">    private boolean useSameNumberOfPoints = false;</span>
    
<span class="fc" id="L138">    private boolean performEuclidTrans = false;</span>

<span class="fc" id="L140">    private boolean useRANSAC = false;</span>
    
<span class="fc" id="L142">    private float pixTolerance = 20;</span>

    // 10 degrees is 0.1745 radians
    // for a fit to a line, consider 1E-9
<span class="fc" id="L146">    private float thresh = 1.f;//(float)(Math.PI/180.) * 10.f;</span>

<span class="fc" id="L148">    private int minLength = 7;//3;</span>
    
<span class="fc" id="L150">    private int maxLength = -1;</span>
    
<span class="fc" id="L152">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L154">    private boolean debug = false;</span>

    /**
     * storing the difference order matrix as pToQ or qToP for re-reading later
     * if user specifies storeMatrix=true.
     * also present here are the parameters associated w/ storedMatrix needed to
     * read it.
     */
<span class="fc" id="L162">    private boolean pToQ = true;</span>
<span class="fc" id="L163">    private boolean storeMatrix = false;</span>
<span class="fc" id="L164">    private float[][][] storedMatrix = null;</span>
<span class="fc" id="L165">    private int storePDp = 1;</span>
<span class="fc" id="L166">    private int storeQDp = 1;</span>
<span class="fc" id="L167">    private EpipolarTransformationFit storedEpipolarFit = null;</span>
   
    /**
     * set this to store the difference matrix and scale information in order
     * to read more from the matrix later.
     */
    public void overrideToStoreMatrix() {
<span class="nc" id="L174">        storeMatrix = true;</span>
<span class="nc" id="L175">    }</span>
    
    /**
     * turn on the euclidean transformation to evaluate the best
     * initial answers.
     * NOTE: this needs to be improved.  might need to be combined with
     * a lower threshold.
     */
    public void setToUseEuclidean() {
<span class="fc" id="L184">        performEuclidTrans = true;</span>
<span class="fc" id="L185">    }</span>
    
    public void setToRemoveOutliers() {
<span class="fc" id="L188">        useRANSAC = true;</span>
<span class="fc" id="L189">    }</span>
    
    /**
     * override the threshold for using a chord differernce value
     * for the average value.   
     * By default it is set to 1.
     * @param t 
     */
    public void _overrideToThreshhold(float t) {
<span class="fc" id="L198">        this.thresh = t;</span>
<span class="fc" id="L199">    }</span>
    
    /**
     * override the default minimum length of 7.
     * @param length 
     */
    public void overrideMinimumLength(int length) {
<span class="fc" id="L206">        this.minLength = length;</span>
<span class="fc" id="L207">    }</span>
    
    /**
     * override the default maximum length of n1 - 1.
     * @param length 
     */
    public void overrideMaximumLength(int length) {
<span class="nc" id="L214">        this.maxLength = length;</span>
<span class="nc" id="L215">    }</span>

    /**
    if this is set, the same number of points
    are used to sample both shapes.
    The number of points is min(p.n, q.n)/dp.
    You can change dp from the default of
    3 by using the method overrideSamplingDistance(dp).
    */
    public void setToUseSameNumberOfPoints() {
<span class="fc" id="L225">        useSameNumberOfPoints = true;</span>
<span class="fc" id="L226">    }</span>

    /**
     * the default sampling distance is 3.  use this method to override it.
     * @param d 
     */
    public void overrideSamplingDistance(int d) {
<span class="fc" id="L233">        this.dp = d;</span>
<span class="fc" id="L234">    }</span>

    /**
     * use this to enable the debug log comments and plots
     */
    public void setToDebug() {
<span class="nc" id="L240">        debug = true;</span>
<span class="nc" id="L241">        log.setLevel(Level.FINE);</span>
<span class="nc" id="L242">    }</span>

    /**
      A shape is defined as the clockwise ordered sequence
      of points P_1...P_N
      and the shape to match has points Q_1...Q_N.
      The spacings used within this method are equidistant
      unless changed using method setToUseSameNumberOfPoints().
      The default spacing is 3, 
      so override that if a different number
      is needed.
      
     &lt;em&gt;NOTE: You may need to pre-process the shape points
     for example, smooth the boundary.&lt;/em&gt;
     &lt;pre&gt;
     This method:  
        PairIntArray p = imageProcessor
            .extractSmoothedOrderedBoundary()
        uses a Gaussian smoothing of 2 sigma,
        but a smaller sigma can be specified.
      &lt;/pre&gt;
     @param p
     @param q
     * @return 
    */
    public Result match(PairIntArray p, PairIntArray q) {

<span class="fc" id="L269">        log.info(&quot;p.n=&quot; + p.getN() + &quot; q.n=&quot; + q.getN()</span>
            + &quot; useSameNumberOfPoints=&quot; + useSameNumberOfPoints
            + &quot; dp=&quot; + dp);

<span class="pc bpc" id="L273" title="2 of 4 branches missed.">        if (p.getN() &lt; 2 || q.getN() &lt; 2) {</span>
<span class="nc" id="L274">            throw new IllegalArgumentException(&quot;p and q must &quot;</span>
            + &quot; have at least dp*2 points = &quot; + (dp * 2));
        }

<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (useSameNumberOfPoints) {</span>
<span class="fc" id="L279">            return matchSameNumber(p, q);</span>
        }
                
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (dp == 1) {</span>
<span class="fc" id="L283">            return match0(p, q);</span>
        }
     
<span class="fc" id="L286">        PairIntArray pSub = new PairIntArray(p.getN()/dp);</span>
<span class="fc" id="L287">        PairIntArray qSub = new PairIntArray(q.getN()/dp);</span>
    
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (int i = 0; i &lt; p.getN(); i += dp) {</span>
<span class="fc" id="L290">            pSub.add(p.getX(i), p.getY(i));</span>
        }
        
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; q.getN(); i += dp) {</span>
<span class="fc" id="L294">            qSub.add(q.getX(i), q.getY(i));</span>
        }
        
<span class="fc" id="L297">        log.info(&quot;pSub.n=&quot; + pSub.getN() + &quot; qSub.n=&quot; + qSub.getN());</span>
        
<span class="fc" id="L299">        Result rSub = match0(pSub, qSub);</span>
        
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (rSub == null) {</span>
<span class="nc" id="L302">            return null;</span>
        } 
        
        // -- put results back into frame of p and q --
          
        // TODO: consider an option to further match the
        // points between correspondence if dp &gt; 1
      
<span class="fc" id="L310">        Result r = new Result(p.getN(), q.getN(), rSub.getOriginalN1());</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (int i = 0; i &lt; rSub.idx1s.size(); ++i) {</span>
<span class="fc" id="L313">            int idx1 = rSub.idx1s.get(i);</span>
<span class="fc" id="L314">            int idx2 = rSub.idx2s.get(i);</span>
<span class="fc" id="L315">            idx1 *= dp;</span>
<span class="fc" id="L316">            idx2 *= dp;</span>
<span class="fc" id="L317">            r.idx1s.add(idx1);</span>
<span class="fc" id="L318">            r.idx2s.add(idx2);</span>
        }
<span class="pc bpc" id="L320" title="3 of 4 branches missed.">        assert(assertIndexesWithinBounds(r, p.getN(), q.getN()));</span>
<span class="fc" id="L321">        r.chordDiffSum = rSub.chordDiffSum;</span>
<span class="fc" id="L322">        r.distSum = rSub.distSum;</span>
        
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (storeMatrix) {</span>
<span class="nc" id="L325">            storePDp = dp;</span>
<span class="nc" id="L326">            storeQDp = dp;</span>
        }
        
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (rSub.getTransformationParameters() != null) {</span>
       
            /*
            transX = xt0 -
                (xc*scale + (((x0-xc)*scale*math.cos(theta))
                + ((y0-yc)*scale*math.sin(theta)))

            transY = yt0 -
                (yc*scale + ((-(x0-xc)*scale*math.sin(theta))
                + ((y0-yc)*scale*math.cos(theta)))            
            */
            
            // translation increases by scale factor change, dp
            // rotation shouldn't change
            // scale changes by factor dp
            
<span class="fc" id="L345">            TransformationParameters params = rSub.getTransformationParameters().copy();</span>
<span class="fc" id="L346">            params.setScale(params.getScale());</span>
<span class="fc" id="L347">            params.setTranslationX(params.getTranslationX());</span>
<span class="fc" id="L348">            params.setTranslationY(params.getTranslationY());</span>
<span class="fc" id="L349">            r.setTransformationParameters(params);</span>
            
        }
        
<span class="fc" id="L353">        return r;</span>
    }

    private TDoubleList calculateChordDiffsSameNumber(PairIntArray p, 
        PairIntArray q, PairIntArray matchedIndexes) {
        
<span class="nc" id="L359">        log.fine(&quot;p.n=&quot; + p.getN() + &quot; q.n=&quot; + q.getN());</span>

<span class="nc bnc" id="L361" title="All 4 branches missed.">        if (p.getN() &lt; 2 || q.getN() &lt; 2) {</span>
<span class="nc" id="L362">            throw new IllegalArgumentException(&quot;p and q must &quot;</span>
            + &quot; have at least dp*2 points = &quot; + (dp * 2));
        }

<span class="nc" id="L366">        int nSampl = Math.min(p.getN(), q.getN())/dp;</span>

<span class="nc" id="L368">        PairIntArray pSub = new PairIntArray(nSampl);</span>
<span class="nc" id="L369">        PairIntArray qSub = new PairIntArray(nSampl);</span>
<span class="nc" id="L370">        PairIntArray idxsSub = new PairIntArray(nSampl);</span>
        
<span class="nc" id="L372">        int pDp = p.getN()/nSampl;</span>
<span class="nc" id="L373">        int qDp = q.getN()/nSampl;</span>
    
<span class="nc bnc" id="L375" title="All 2 branches missed.">        for (int i = 0; i &lt; p.getN(); i += pDp) {</span>
<span class="nc" id="L376">            pSub.add(p.getX(i), p.getY(i));</span>
        }
        
<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (int i = 0; i &lt; q.getN(); i += qDp) {</span>
<span class="nc" id="L380">            qSub.add(q.getX(i), q.getY(i));</span>
        }
        
<span class="nc bnc" id="L383" title="All 2 branches missed.">        for (int i = 0; i &lt; idxsSub.getN(); ++i) {</span>
<span class="nc" id="L384">            int idx1 = matchedIndexes.getX(i)/pDp;</span>
<span class="nc" id="L385">            int idx2 = matchedIndexes.getY(i)/qDp;</span>
<span class="nc" id="L386">            idxsSub.add(idx1, idx2);</span>
        }
        
<span class="nc" id="L389">        log.fine(&quot;pSub.n=&quot; + pSub.getN() + &quot; qSub.n=&quot; + qSub.getN());</span>
    
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (storeMatrix) {</span>
<span class="nc" id="L392">            storePDp = pDp;</span>
<span class="nc" id="L393">            storeQDp = qDp;</span>
        }
        
<span class="nc" id="L396">        TDoubleList chordDiffs = calculateChordDiffs0(pSub, qSub, idxsSub);</span>
        
<span class="nc" id="L398">        return chordDiffs;</span>
    }
    
    private Result matchSameNumber(PairIntArray p, PairIntArray q) {

<span class="fc" id="L403">        log.fine(&quot;p.n=&quot; + p.getN() + &quot; q.n=&quot; + q.getN());</span>

<span class="pc bpc" id="L405" title="2 of 4 branches missed.">        if (p.getN() &lt; 2 || q.getN() &lt; 2) {</span>
<span class="nc" id="L406">            throw new IllegalArgumentException(&quot;p and q must &quot;</span>
            + &quot; have at least dp*2 points = &quot; + (dp * 2));
        }

<span class="fc" id="L410">        int nSampl = Math.min(p.getN(), q.getN())/dp;</span>

<span class="fc" id="L412">        PairIntArray pSub = new PairIntArray(nSampl);</span>
<span class="fc" id="L413">        PairIntArray qSub = new PairIntArray(nSampl);</span>

<span class="fc" id="L415">        int pDp = p.getN()/nSampl;</span>
<span class="fc" id="L416">        int qDp = q.getN()/nSampl;</span>
    
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (int i = 0; i &lt; p.getN(); i += pDp) {</span>
<span class="fc" id="L419">            pSub.add(p.getX(i), p.getY(i));</span>
        }
        
<span class="fc bfc" id="L422" title="All 2 branches covered.">        for (int i = 0; i &lt; q.getN(); i += qDp) {</span>
<span class="fc" id="L423">            qSub.add(q.getX(i), q.getY(i));</span>
        }
        
<span class="fc" id="L426">        log.fine(&quot;pSub.n=&quot; + pSub.getN() + &quot; qSub.n=&quot; + qSub.getN());</span>
    
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (storeMatrix) {</span>
<span class="nc" id="L429">            storePDp = pDp;</span>
<span class="nc" id="L430">            storeQDp = qDp;</span>
        }
        
<span class="fc" id="L433">        Result rSub = match0(pSub, qSub);</span>
        
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (rSub == null) {</span>
<span class="nc" id="L436">            return null;</span>
        }
        
        // -- put results back into frame of p and q --
          
        // unrealistic value to ensure it's not used.
<span class="fc" id="L442">        int offset = Integer.MAX_VALUE;</span>

<span class="fc" id="L444">        Result r = new Result(p.getN(), q.getN(), rSub.getOriginalN1());</span>
            
<span class="fc bfc" id="L446" title="All 2 branches covered.">        for (int i = 0; i &lt; rSub.idx1s.size(); ++i) {</span>
<span class="fc" id="L447">            int idx1 = rSub.idx1s.get(i);</span>
<span class="fc" id="L448">            int idx2 = rSub.idx2s.get(i);</span>
<span class="fc" id="L449">            idx1 *= pDp;</span>
<span class="fc" id="L450">            idx2 *= qDp;</span>
<span class="fc" id="L451">            r.idx1s.add(idx1);</span>
<span class="fc" id="L452">            r.idx2s.add(idx2);</span>
        }
<span class="fc" id="L454">        r.chordDiffSum = rSub.chordDiffSum;</span>
        
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (rSub.getTransformationParameters() != null) {</span>
            
            /*
            two different scale factors need to be applied to the
                parameters, pDp and qDp.
            
            transX = xt0 -
                (xc*scale + (((x0-xc)*scale*math.cos(theta))
                + ((y0-yc)*scale*math.sin(theta)))

            transY = yt0 -
                (yc*scale + ((-(x0-xc)*scale*math.sin(theta))
                + ((y0-yc)*scale*math.cos(theta)))            
            
            if use 0,0 for origin, the equations simplify to:
                transX = xt0 - (x0*scale)
                transY = yt0 - (y0*scale)
            
            transforming x0,y0 by qDp and xt0,yt0 by pDp:                 
                new transX = (xt0 * pDp) - (x0 * qDp * scale)
                new transY = (yt0 * pDp) - (y0 * qDp * scale)
            
            looks like need to recalc transformation
            */
            
<span class="fc" id="L481">            PairIntArray left = new PairIntArray(r.idx1s.size());</span>
<span class="fc" id="L482">            PairIntArray right = new PairIntArray(r.idx2s.size());</span>
<span class="pc bpc" id="L483" title="3 of 4 branches missed.">            assert(r.idx1s.size() == r.idx2s.size());</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            for (int i = 0; i &lt; r.idx1s.size(); ++i) {</span>
<span class="fc" id="L485">                int idx = r.idx1s.get(i);</span>
<span class="fc" id="L486">                left.add(p.getX(idx), p.getY(idx));</span>
<span class="fc" id="L487">                idx = r.idx2s.get(i);</span>
<span class="fc" id="L488">                right.add(q.getX(idx), q.getY(idx));</span>
            }
            
<span class="fc" id="L491">            MatchedPointsTransformationCalculator tc = </span>
                new MatchedPointsTransformationCalculator();
            
<span class="fc" id="L494">            TransformationParameters params = tc.calulateEuclideanWithoutFilter(</span>
                left, right, 0, 0);
            
<span class="fc" id="L497">            r.setTransformationParameters(params);            </span>
        
<span class="fc" id="L499">            r.distSum = rSub.distSum;</span>
        }

<span class="fc" id="L502">        return r;</span>
    }
    
    private TDoubleList calculateChordDiffs0(PairIntArray p, PairIntArray q,
        PairIntArray matchedIndexes) {
        
<span class="nc bnc" id="L508" title="All 4 branches missed.">        if (p == null || p.getN() &lt; 2) {</span>
<span class="nc" id="L509">            throw new IllegalArgumentException(&quot;p must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="nc bnc" id="L513" title="All 4 branches missed.">        if (q == null || q.getN() &lt; 2) {</span>
<span class="nc" id="L514">            throw new IllegalArgumentException(&quot;q must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
        // --- make difference matrices ---

        //md[0:n2-1][0:n1-1][0:n1-1]
        float[][][] md;
        TDoubleList chordDiffs;
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (p.getN() &lt;= q.getN()) {</span>
<span class="nc" id="L524">            md = createDifferenceMatrices(p, q);</span>
<span class="nc" id="L525">            chordDiffs = extractChordDiffs(md, p.getN(), q.getN(),</span>
                matchedIndexes);
        } else {
<span class="nc" id="L528">            md = createDifferenceMatrices(q, p);</span>
<span class="nc" id="L529">            PairIntArray revMatchedIndexes = reverseXY(matchedIndexes);</span>
<span class="nc" id="L530">            chordDiffs = extractChordDiffs(md, q.getN(), p.getN(),</span>
                revMatchedIndexes);
<span class="nc" id="L532">            pToQ = false;</span>
        }
        
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (storeMatrix) {</span>
<span class="nc" id="L536">            storedMatrix = md;</span>
        }

<span class="nc" id="L539">        return chordDiffs;</span>
    }
    
    private Result match0(PairIntArray p, PairIntArray q) {

<span class="pc bpc" id="L544" title="2 of 4 branches missed.">        if (p == null || p.getN() &lt; 2) {</span>
<span class="nc" id="L545">            throw new IllegalArgumentException(&quot;p must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="pc bpc" id="L549" title="2 of 4 branches missed.">        if (q == null || q.getN() &lt; 2) {</span>
<span class="nc" id="L550">            throw new IllegalArgumentException(&quot;q must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
        // --- make difference matrices ---

        //md[0:n2-1][0:n1-1][0:n1-1]
        float[][][] md;
        Result r;
<span class="fc bfc" id="L559" title="All 2 branches covered.">        if (p.getN() &lt;= q.getN()) {</span>
<span class="fc" id="L560">            md = createDifferenceMatrices(p, q);</span>
<span class="fc" id="L561">            applySummedColumnTableConversion(md);</span>
<span class="fc" id="L562">            r = match0(md, p, q);</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (r != null) {</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L565">                    System.out.println(&quot;not transposed&quot;);</span>
                }
<span class="pc bpc" id="L567" title="3 of 4 branches missed.">                assert(assertIndexesWithinBounds(r, p.getN(), q.getN()));</span>
            }
        } else {
<span class="fc" id="L570">            md = createDifferenceMatrices(q, p);</span>
<span class="fc" id="L571">            applySummedColumnTableConversion(md);</span>
<span class="fc" id="L572">            r = match0(md, q, p);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            if (r != null) {</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L575">                    System.out.println(&quot;transpose&quot;);</span>
                }
<span class="fc" id="L577">                r = r.transpose();</span>
<span class="pc bpc" id="L578" title="3 of 4 branches missed.">                assert(assertIndexesWithinBounds(r, p.getN(), q.getN()));</span>
            }
<span class="fc" id="L580">            pToQ = false;</span>
        }
        
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (storeMatrix) {</span>
<span class="nc" id="L584">            storedMatrix = md;</span>
        }

<span class="fc" id="L587">        return r;</span>
    }
        
    private Result match0(float[][][] md, PairIntArray p, PairIntArray q) {

<span class="pc bpc" id="L592" title="2 of 4 branches missed.">        if (p == null || p.getN() &lt; 2) {</span>
<span class="nc" id="L593">            throw new IllegalArgumentException(&quot;p must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="pc bpc" id="L597" title="2 of 4 branches missed.">        if (q == null || q.getN() &lt; 2) {</span>
<span class="nc" id="L598">            throw new IllegalArgumentException(&quot;q must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (p.getN() &gt; q.getN()) {</span>
<span class="nc" id="L603">            throw new IllegalArgumentException(</span>
            &quot;q.n must be &gt;= p.n&quot;);
        }
        
<span class="fc" id="L607">        int n1 = p.getN();</span>
<span class="fc" id="L608">        int n2 = q.getN();</span>

        /*
        This method will return results for a local
        solution to create the point correspondence list.

        Note that the local best could be two different
        kinds of models, so might write two
        different methods for the results.
        (1) the assumption of same object but with some
            amount of occlusion and maybe additional
            shapes present due to segmentation not being
            able to isolate the object completely.
        (2) the assumption of same object but with
           some parts being differently oriented, for
           an example, the scissors opened versus closed in unit tests.
           The occlusion should be handled for this one too.

        For the multi-objective optimization cost,
        need the sum of differences of chords and the fraction
        of the whole to calculate the Salukwdze distance 
        of the Paretto frontier.
        */
        
<span class="fc" id="L632">        List&lt;SR&gt; minima = findMinima(md, n1, n2);</span>
        
<span class="fc" id="L634">        int topK = 100;</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if (minima.size() &lt; topK) {</span>
<span class="fc" id="L636">            topK = minima.size();</span>
        }
        
<span class="fc" id="L639">        minima = minima.subList(0, topK);</span>

<span class="pc bpc" id="L641" title="2 of 4 branches missed.">        if (minima == null || minima.isEmpty()) {</span>
<span class="nc" id="L642">            return null;</span>
        }
      
<span class="fc bfc" id="L645" title="All 2 branches covered.">        if (performEuclidTrans) {</span>

            // solve for transformation, add points near projection,
            // return sorted solutions, best is at top.
            // note that RANSAC has been used to remove outliers
            // from the already matched points when there are enough points to use it

            // the added points from the transformation
<span class="fc" id="L653">            List&lt;PairIntArray&gt; addedPoints = new ArrayList&lt;PairIntArray&gt;(topK);</span>
                
<span class="fc" id="L655">            List&lt;Result&gt; results = transformAndEvaluate(minima, p, q,</span>
                md, pixTolerance, topK, addedPoints);

<span class="pc bpc" id="L658" title="2 of 4 branches missed.">            if (results == null || results.isEmpty()) {</span>
<span class="nc" id="L659">                return null;</span>
            }
            
<span class="fc bfc" id="L662" title="All 2 branches covered.">            for (int i = 0; i &lt; results.size(); ++i) {</span>
<span class="fc" id="L663">                Result result = results.get(i);</span>
<span class="fc" id="L664">                populateWithChordDiffs(result, md, p.getN(), q.getN());</span>
<span class="fc" id="L665">                log.fine(&quot;calc'ed chords: &quot; + result.toStringAbbrev());</span>
<span class="pc bpc" id="L666" title="3 of 4 branches missed.">                assert(assertIndexesWithinBounds(result, p.getN(), q.getN()));</span>
            }

            // need to decide between using the total chord diff sum
            //   and hence the max of all of those when calculating
            //    the salukwzde distance
            //   or need to use the average chord diff sum for each result
            //    and the maximum of those
            // choosing the later here, just as did in previous sorting of
            // intervals.

<span class="fc" id="L677">            double maxChordAvg = Double.MIN_VALUE;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">            for (Result r : results) {</span>
<span class="fc" id="L679">                double d = r.chordDiffSum/(double)r.getNumberOfMatches();</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                if (d &gt; maxChordAvg) {</span>
<span class="fc" id="L681">                    maxChordAvg = d;</span>
                }
<span class="fc" id="L683">            }</span>
<span class="fc" id="L684">            float[] avgCosts = new float[results.size()];</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            for (int i = 0; i &lt; results.size(); ++i) {</span>
<span class="fc" id="L686">                Result r = results.get(i);</span>
<span class="fc" id="L687">                float n = r.getNumberOfMatches();</span>
<span class="fc" id="L688">                double avgD = r.chordDiffSum/n;</span>
<span class="fc" id="L689">                float f = 1.f - (n/(float)n1);</span>
<span class="fc" id="L690">                double d = avgD/maxChordAvg;</span>
<span class="fc" id="L691">                float s = (float) (f * f + d * d);</span>
<span class="fc" id="L692">                avgCosts[i] = s;</span>
            }
<span class="fc" id="L694">            QuickSort.sortBy1stArg(avgCosts, results, 0, results.size() - 1);            </span>
            
<span class="fc" id="L696">            return results.get(0);</span>

        } else {
        
            // NOT YET FINISHED
            
            //TODO: for articulated, may want to consider an option here
            //   where a partial interval is rejected if more than the endpoints
            //   are trimmed.  currently, the interval, if not entirely within
            //   an unmatched and consistent range, is filtered to the subset of 
            //   the interval which does fit.

<span class="fc" id="L708">            OrderedClosedCurveCorrespondence occ = </span>
                new OrderedClosedCurveCorrespondence();
        
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L712">                occ.dbg1 = p;</span>
<span class="nc" id="L713">                occ.dbg2 = q;</span>
<span class="nc" id="L714">                occ.dp = dp;</span>
<span class="nc" id="L715">                occ.setToDebug();</span>
            }
            
<span class="fc" id="L718">            occ.setMinimumLength(minLength);</span>

<span class="fc" id="L720">            occ.addIntervals(minima, n1, n2);</span>

<span class="fc" id="L722">            List&lt;SR&gt; results = occ.getResultsAsList();</span>

<span class="fc" id="L724">            Result best = new Result(n1, n2, n1);</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            for (int i = 0; i &lt; results.size(); ++i) {</span>

<span class="fc" id="L727">                SR sr = results.get(i);</span>

<span class="fc bfc" id="L729" title="All 2 branches covered.">                for (int idx1 = sr.startIdx1; idx1 &lt;= sr.stopIdx1; ++idx1) {</span>
<span class="fc" id="L730">                    int idx2 = idx1 + sr.offsetIdx2;</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                    if (idx2 &gt; (n2 - 1)) {</span>
<span class="fc" id="L732">                        idx2 -= n2;</span>
                    }
<span class="fc" id="L734">                    best.idx1s.add(idx1);</span>
<span class="fc" id="L735">                    best.idx2s.add(idx2);</span>
                }
                
<span class="fc" id="L738">                best.chordDiffSum += sr.diffChordSum;</span>
            }
            
<span class="fc bfc" id="L741" title="All 2 branches covered.">            if (useRANSAC) {</span>
<span class="pc bpc" id="L742" title="2 of 4 branches missed.">                if (best != null &amp;&amp; best.idx1s.size() &gt;= 7) {</span>
<span class="fc" id="L743">                    improveWithRANSAC(best, p, q, md, n1, n2);</span>
                }
            }

<span class="fc" id="L747">            return best;</span>
        }        
    }
    
    /**
     * as an alternative to finding the best correspondence between two
     * shapes, instead, given the correspondence, sum the chord differences.
     * The same instance variables such as the point spacing are used here
     * too.
     * @param p
     * @param q
     * @param matchedIndexes
     * @return 
     */
    public double calculateChordDiffSums(PairIntArray p, PairIntArray q,
        PairIntArray matchedIndexes) {
       
<span class="nc" id="L764">        TDoubleList diffs = calculateChordDiffs(p, q, matchedIndexes);</span>
        
<span class="nc" id="L766">        double sum = 0;</span>
        
<span class="nc bnc" id="L768" title="All 2 branches missed.">        for (int i = 0; i &lt; diffs.size(); ++i) {</span>
<span class="nc" id="L769">            sum += diffs.get(i);</span>
        }
       
<span class="nc" id="L772">        return sum;</span>
    }
    
    /**
     * as an alternative to finding the best correspondence between two
     * shapes, instead, given the correspondence, sum the chord differences.
     * The same instance variables such as the point spacing are used here
     * too.
     * @param p
     * @param q
     * @param matchedIndexes
     * @return 
     */
    public TDoubleList calculateChordDiffs(PairIntArray p, PairIntArray q,
        PairIntArray matchedIndexes) {
       
        //TODO: edit method to find sequential intervals
        //  in matchedIndexes
        //  then extract that sum from the chord diff matrix.
        //  NOTE: chord diff matrix needs to be changed to
        //  use summed columns or summed area
        
<span class="nc" id="L794">        log.info(&quot;p.n=&quot; + p.getN() + &quot; q.n=&quot; + q.getN()</span>
            + &quot; useSameNumberOfPoints=&quot; + useSameNumberOfPoints
            + &quot; dp=&quot; + dp);

<span class="nc bnc" id="L798" title="All 4 branches missed.">        if (p.getN() &lt; 2 || q.getN() &lt; 2) {</span>
<span class="nc" id="L799">            throw new IllegalArgumentException(&quot;p and q must &quot;</span>
            + &quot; have at least dp*2 points = &quot; + (dp * 2));
        }

<span class="nc bnc" id="L803" title="All 2 branches missed.">        if (useSameNumberOfPoints) {</span>
<span class="nc" id="L804">            return calculateChordDiffsSameNumber(p, q, matchedIndexes);</span>
        }
                
<span class="nc bnc" id="L807" title="All 2 branches missed.">        if (dp == 1) {</span>
<span class="nc" id="L808">            return calculateChordDiffs0(p, q, matchedIndexes);</span>
        }
     
<span class="nc" id="L811">        PairIntArray pSub = new PairIntArray(p.getN()/dp);</span>
<span class="nc" id="L812">        PairIntArray qSub = new PairIntArray(q.getN()/dp);</span>
<span class="nc" id="L813">        PairIntArray idxsSub = new PairIntArray(pSub.getN());</span>
        
<span class="nc bnc" id="L815" title="All 2 branches missed.">        for (int i = 0; i &lt; p.getN(); i += dp) {</span>
<span class="nc" id="L816">            pSub.add(p.getX(i), p.getY(i));</span>
        }
        
<span class="nc bnc" id="L819" title="All 2 branches missed.">        for (int i = 0; i &lt; q.getN(); i += dp) {</span>
<span class="nc" id="L820">            qSub.add(q.getX(i), q.getY(i));</span>
        }
        
<span class="nc bnc" id="L823" title="All 2 branches missed.">        for (int i = 0; i &lt; matchedIndexes.getN(); ++i) {</span>
<span class="nc" id="L824">            int idx1 = matchedIndexes.getX(i)/dp;</span>
<span class="nc" id="L825">            int idx2 = matchedIndexes.getY(i)/dp;</span>
<span class="nc" id="L826">            idxsSub.add(idx1, idx2);</span>
        }
        
<span class="nc" id="L829">        log.info(&quot;pSub.n=&quot; + pSub.getN() + &quot; qSub.n=&quot; + qSub.getN());</span>
        
<span class="nc" id="L831">        return calculateChordDiffs0(pSub, qSub, idxsSub);</span>
    }

    private List&lt;SR&gt; findMinima(float[][][] md, int n1, int n2) {

        //q.n is &gt;= p.n, that is n2 &gt;= n1
            
        // reading over a range of window sizes to keep the 
        // sum/nPix below thresh and keeping the mincost solutions.

        // find the intervals of contiguous minima and assign 
        // curve indexes to the largest segments.
        // (note that the objective formula for the cost
        // is the Salukwzde distance).

<span class="fc" id="L846">        List&lt;SR&gt; allResults = new ArrayList&lt;SR&gt;();</span>
        
<span class="fc" id="L848">        Interval&lt;Integer&gt; interval = null;</span>
        
        // this is learned from the first search at offset=0
<span class="fc" id="L851">        double maxChordSum = Double.MIN_VALUE;</span>
<span class="fc" id="L852">        float[] outC = new float[2];</span>
        double ds1, ds2;
                
        /*
            MXM              NXN
                         30 31 32 33
         20 21 22        20 21 22 23
         10 11 12        10 11 12 13
         00 01 02        00 01 02 03   p_i_j - q_i_j

                         01 02 03 00
         20 21 22        31 32 33 30
         10 11 12        21 22 23 20
         00 01 02        11 12 13 10  p_i_j - q_(i+1)_(j+1)

                         12 13 10 11
         20 21 22        02 03 00 01
         10 11 12        32 33 30 31
         00 01 02        22 23 20 21  p_i_j - q_(i+2)_(j+2)

                         23 20 21 22
         20 21 22        13 10 11 12
         10 11 12        03 00 01 02
         00 01 02        33 30 31 32  p_i_j - q_(i+3)_(j+3)
        */
           
        // runtime complexity is n2 * O(n1^3)
<span class="fc bfc" id="L879" title="All 2 branches covered.">        for (int offset = 0; offset &lt; md.length; offset++) {</span>
            
<span class="fc" id="L881">            float[][] a = md[offset];</span>

<span class="fc" id="L883">            List&lt;Interval&lt;Integer&gt;&gt; outputIntervals = new ArrayList&lt;Interval&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L884">            List&lt;SR&gt; outputValues = new ArrayList&lt;SR&gt;();</span>
            
            // runtime complexity is O(n^3)
<span class="fc" id="L887">            search(a, outputIntervals, outputValues, offset);</span>
            
<span class="fc bfc" id="L889" title="All 2 branches covered.">            if (outputValues.isEmpty()) {</span>
<span class="fc" id="L890">                continue;</span>
            }
            
<span class="fc bfc" id="L893" title="All 2 branches covered.">            if (maxChordSum == Double.MIN_VALUE) {</span>
<span class="fc" id="L894">                maxChordSum = findMaxDiffChordSum(outputValues);</span>
            }
            
            // the intervals are in the reference frame of p and of q shifted by
            // offset.
                        
<span class="fc" id="L900">            allResults.addAll(outputValues);</span>
        }
        
<span class="fc bfc" id="L903" title="All 2 branches covered.">        for (SR sr: allResults) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            if (sr.maxChordSum &gt; maxChordSum) {</span>
<span class="fc" id="L905">                maxChordSum = sr.maxChordSum;</span>
            }
<span class="fc" id="L907">        }</span>
        
<span class="fc bfc" id="L909" title="All 2 branches covered.">        for (SR sr: allResults) {</span>
<span class="fc" id="L910">            sr.maxChordSum = maxChordSum;</span>
<span class="fc" id="L911">        }</span>
        
        // sort by salukwzde distance
<span class="fc" id="L914">        Collections.sort(allResults, new SRComparator());</span>
        
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L917">            System.out.println(&quot;nIntervals to proces=&quot; + allResults.size());</span>
        }
        
<span class="fc" id="L920">        return allResults;</span>
        
    }
    
    private double calcSalukDist(double compChord, double maxChord,
        int length, int maxMatchable) {
<span class="nc" id="L926">        double d = compChord/maxChord;</span>
<span class="nc" id="L927">        double f = 1. - ((double)length/(double)maxMatchable);</span>
<span class="nc" id="L928">        return f*f + d*d;</span>
    }

    private Result smallNumberEuclidean(SR sr, PairIntArray p, PairIntArray q, 
        float pixTol, PairIntArray outputAddedPoints) {

<span class="nc" id="L934">        int len = sr.mLen;</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (len &lt; 2) {</span>
<span class="nc" id="L936">            return null;</span>
        }
        
<span class="nc" id="L939">        PairIntArray leftXY = new PairIntArray(len);</span>
<span class="nc" id="L940">        PairIntArray rightXY = new PairIntArray(len);</span>
<span class="nc" id="L941">        PairIntArray leftUnmatchedXY = new PairIntArray(p.getN() - len);</span>
<span class="nc" id="L942">        PairIntArray rightUnmatchedXY = new PairIntArray(q.getN() - len);</span>

<span class="nc" id="L944">        populatePointArrays(sr, p, q, leftXY, rightXY,</span>
            leftUnmatchedXY, rightUnmatchedXY);

        
<span class="nc" id="L948">        MatchedPointsTransformationCalculator tc = </span>
            new MatchedPointsTransformationCalculator();        
                
        // NOTE: could use the method which removes outliers also, but the
        //    the contiguous points in sr are a single unit essentially
        
<span class="nc" id="L954">        TransformationParameters params = tc.calulateEuclideanWithoutFilter(</span>
            leftXY, rightXY, 0, 0);
        
<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L958">            return null;</span>
        }
        
        // since this class is using equidistant
        // points on shape boundary, need to compare
        // for same scale.
<span class="nc bnc" id="L964" title="All 4 branches missed.">        if (params.getScale() &lt; 0.9 || params.getScale() &gt; 1.1) {</span>
<span class="nc" id="L965">            log.fine(&quot;WARNING: &quot; +</span>
                &quot; euclidean transformation scale: &quot;  + params);
        }
        
        // ---- apply transformation -----
<span class="nc" id="L970">        Result result = applyTransformation(params, p, q,</span>
            leftXY, rightXY, leftUnmatchedXY, rightUnmatchedXY, 
            pixTol, outputAddedPoints);
    
<span class="nc bnc" id="L974" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L975">            String debugTag = Integer.toString(MiscDebug.getCurrentTimeFormatted());</span>
            try {
<span class="nc" id="L977">                CorrespondencePlotter plotter = new CorrespondencePlotter(p, q);</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">                for (int i = 0; i &lt; result.getNumberOfMatches(); ++i) {</span>
<span class="nc" id="L979">                    int idx1 = result.getIdx1(i);</span>
<span class="nc" id="L980">                    int idx2 = result.getIdx2(i);</span>
<span class="nc" id="L981">                    int x1 = p.getX(idx1);</span>
<span class="nc" id="L982">                    int y1 = p.getY(idx1);</span>
<span class="nc" id="L983">                    int x2 = q.getX(idx2);</span>
<span class="nc" id="L984">                    int y2 = q.getY(idx2);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                    if ((i % 4) == 0) {</span>
<span class="nc" id="L986">                        plotter.drawLineInAlternatingColors(</span>
                            x1, y1, x2, y2, 0);
                    }
                }
<span class="nc" id="L990">                String filePath = plotter.writeImage(&quot;_&quot;</span>
                    + &quot;_debug4_&quot; + debugTag);
<span class="nc" id="L992">            } catch (Throwable t) {</span>
<span class="nc" id="L993">            }</span>
        }
        
<span class="nc" id="L996">        return result;</span>
    }
    
    private Result applyTransformation(TransformationParameters params,
        PairIntArray p, PairIntArray q,
        PairIntArray leftXY, PairIntArray rightXY,
        PairIntArray leftUnmatchedXY, PairIntArray rightUnmatchedXY, 
        float pixTol, PairIntArray outputAddedPoints) {
        
<span class="fc" id="L1005">        Transformer transformer = new Transformer();</span>
<span class="fc" id="L1006">        PairIntArray leftTr = transformer.applyTransformation(</span>
            params, leftUnmatchedXY);
<span class="fc" id="L1008">        PairIntArray leftTr0 = transformer.applyTransformation(</span>
            params, leftXY);

<span class="fc" id="L1011">        String debugTag = Integer.toString(MiscDebug.getCurrentTimeFormatted());</span>
        if (false &amp;&amp; debug) {
            try {
                CorrespondencePlotter plotter = new CorrespondencePlotter(p, q);
                for (int i = 0; i &lt; leftXY.getN(); ++i) {
                    int x1 = leftXY.getX(i);
                    int y1 = leftXY.getY(i);
                    int x2 = rightXY.getX(i);
                    int y2 = rightXY.getY(i);
                    if ((i % 5) == 0) {
                        plotter.drawLineInAlternatingColors(x1, y1,
                            x2, y2, 0);
                    }
                }
                String filePath = plotter.writeImage(&quot;_&quot;
                    + &quot;_debug1_&quot; + debugTag);
                plotter = new CorrespondencePlotter(p, q);
                for (int i = 0; i &lt; leftXY.getN(); ++i) {
                    int x1 = leftXY.getX(i);
                    int y1 = leftXY.getY(i);
                    int x2 = leftTr0.getX(i);
                    int y2 = leftTr0.getY(i);
                    if ((i % 5) == 0) {
                        plotter.drawLine(x1, y1, x2, y2,
                            255, 0, 0, 0);
                    }
                }
                filePath = plotter.writeImage(&quot;_&quot;
                    + &quot;_debug2_&quot; + debugTag);

                plotter = new CorrespondencePlotter(p, q);
                for (int i = 0; i &lt; leftUnmatchedXY.getN(); ++i) {
                    int x1 = leftUnmatchedXY.getX(i);
                    int y1 = leftUnmatchedXY.getY(i);
                    int x2 = leftTr.getX(i);
                    int y2 = leftTr.getY(i);
                    if ((i % 5) == 0) {
                        plotter.drawLine(x1, y1, x2, y2,
                            255, 0, 0, 0);
                    }
                }

                filePath = plotter.writeImage(&quot;_&quot;
                    + &quot;_debug3_&quot; + debugTag);
            } catch (Throwable t) {
            }
        }

<span class="fc" id="L1059">        log.fine(debugTag + &quot; params=&quot; + params);</span>

        // find the best matches to the unmatched in q

        // optimal is currently hungarian, but
        //     may replace w/ another bipartite matcher
        //     in future.  using greey instead of optimal for now

        //boolean useOptimal = false;

        TObjectFloatMap&lt;PairInt&gt; idxMap;
        //if (useOptimal) {
        //    idxMap = optimalMatch(leftTr, rightUnmatched,
        //        pixTol);
        //} else {
<span class="fc" id="L1074">            idxMap = nearestMatch(leftTr, rightUnmatchedXY, pixTol);</span>
        //}

<span class="fc" id="L1077">        log.fine(debugTag + &quot;transformation nearest matches=&quot; +</span>
<span class="fc" id="L1078">            idxMap.size());</span>

        /*
        combine results from leftXY-rightXY
        with idxMap where idxMap is
            idx1, idx2 of leftTr and rightUnmatched, resp.
                          left
        */

<span class="fc" id="L1087">        TObjectIntMap&lt;PairInt&gt; pPoints = Misc.createPointIndexMap(p);</span>
<span class="fc" id="L1088">        TObjectIntMap&lt;PairInt&gt; qPoints = Misc.createPointIndexMap(q);</span>

<span class="fc" id="L1090">        Result result = new Result(p.getN(), q.getN(), p.getN());</span>
<span class="fc" id="L1091">            result.setTransformationParameters(params);</span>
        
<span class="fc" id="L1093">        TObjectFloatIterator&lt;PairInt&gt; iter = idxMap.iterator();</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">        for (int i = 0; i &lt; idxMap.size(); ++i) {</span>
<span class="nc" id="L1095">            iter.advance();</span>
<span class="nc" id="L1096">            PairInt idxIdx = iter.key();</span>
<span class="nc" id="L1097">            float dist = iter.value();</span>
<span class="nc" id="L1098">            PairInt ell = new PairInt(</span>
<span class="nc" id="L1099">                leftUnmatchedXY.getX(idxIdx.getX()),</span>
<span class="nc" id="L1100">                leftUnmatchedXY.getY(idxIdx.getX())</span>
            );
<span class="nc" id="L1102">            int pIdx = pPoints.get(ell);</span>
<span class="nc bnc" id="L1103" title="All 4 branches missed.">            assert(pIdx &gt; -1);</span>
<span class="nc" id="L1104">            PairInt ar = new PairInt(</span>
<span class="nc" id="L1105">                rightUnmatchedXY.getX(idxIdx.getY()),</span>
<span class="nc" id="L1106">                rightUnmatchedXY.getY(idxIdx.getY())</span>
            );
<span class="nc" id="L1108">            int qIdx = qPoints.get(ar);</span>
<span class="nc bnc" id="L1109" title="All 4 branches missed.">            assert(qIdx &gt; -1);</span>

<span class="nc" id="L1111">            result.insert(pIdx, qIdx, dist);</span>

<span class="nc" id="L1113">            outputAddedPoints.add(pIdx, qIdx);</span>
        }

<span class="fc bfc" id="L1116" title="All 2 branches covered.">        for (int i = 0; i &lt; rightXY.getN(); ++i) {</span>
<span class="fc" id="L1117">            int diffX = leftTr0.getX(i) - rightXY.getX(i);</span>
<span class="fc" id="L1118">            int diffY = leftTr0.getY(i) - rightXY.getY(i);</span>
<span class="fc" id="L1119">            float dist = (float)Math.sqrt(diffX * diffX +</span>
                diffY * diffY);

<span class="fc" id="L1122">            PairInt ell = new PairInt(leftXY.getX(i), leftXY.getY(i));</span>
<span class="fc" id="L1123">            int pIdx = pPoints.get(ell);</span>
<span class="pc bpc" id="L1124" title="3 of 4 branches missed.">            assert(pIdx &gt; -1);</span>

<span class="fc" id="L1126">            PairInt ar = new PairInt(rightXY.getX(i), rightXY.getY(i));</span>
<span class="fc" id="L1127">            int qIdx = qPoints.get(ar);</span>
<span class="pc bpc" id="L1128" title="3 of 4 branches missed.">            assert(qIdx &gt; -1);</span>

<span class="fc" id="L1130">            result.insert(pIdx, qIdx, dist);</span>
        }

<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">        if (debug) {</span>
            try {
<span class="nc" id="L1135">                CorrespondencePlotter plotter = new CorrespondencePlotter(p, q);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                for (int i = 0; i &lt; result.getNumberOfMatches(); ++i) {</span>
<span class="nc" id="L1137">                    int idx1 = result.getIdx1(i);</span>
<span class="nc" id="L1138">                    int idx2 = result.getIdx2(i);</span>
<span class="nc" id="L1139">                    int x1 = p.getX(idx1);</span>
<span class="nc" id="L1140">                    int y1 = p.getY(idx1);</span>
<span class="nc" id="L1141">                    int x2 = q.getX(idx2);</span>
<span class="nc" id="L1142">                    int y2 = q.getY(idx2);</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">                    if ((i % 4) == 0) {</span>
<span class="nc" id="L1144">                        plotter.drawLineInAlternatingColors(</span>
                            x1, y1, x2, y2, 0);
                    }
                }
<span class="nc" id="L1148">                String filePath = plotter.writeImage(&quot;_&quot;</span>
                    + &quot;_debug4_&quot; + debugTag);
<span class="nc" id="L1150">            } catch (Throwable t) {</span>
<span class="nc" id="L1151">            }</span>
        }

<span class="fc" id="L1154">        return result;</span>
    }
    
    private TObjectFloatMap&lt;PairInt&gt; nearestMatch(
        PairIntArray xy1, PairIntArray xy2,
        double tolerance) {

<span class="fc" id="L1161">        KNearestNeighbors knn = null;</span>

<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">        if (xy1.getN() &gt; 3) {</span>
<span class="nc" id="L1164">            knn = new KNearestNeighbors(</span>
<span class="nc" id="L1165">                xy2.getX(), xy2.getY());</span>
        }

<span class="fc" id="L1168">        int k = 3;</span>

<span class="fc" id="L1170">        TObjectIntMap&lt;PairInt&gt; indexMap2 =</span>
<span class="fc" id="L1171">            Misc.createPointIndexMap(xy2);</span>

<span class="fc" id="L1173">        float[] dist = new float[3*xy1.getN()];</span>
<span class="fc" id="L1174">        int[] idx2s = new int[dist.length];</span>
<span class="fc" id="L1175">        int[] idx1s = new int[dist.length];</span>
<span class="fc" id="L1176">        int count = 0;</span>
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">        for (int i = 0; i &lt; xy1.getN(); ++i) {</span>
<span class="nc" id="L1178">            int x = xy1.getX(i);</span>
<span class="nc" id="L1179">            int y = xy1.getY(i);</span>
<span class="nc" id="L1180">            List&lt;PairFloat&gt; nearest = null;</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">            if (knn != null) {</span>
<span class="nc" id="L1182">                nearest = knn.findNearest(k, x, y, (float)tolerance);</span>
            } else {
<span class="nc" id="L1184">                nearest = kNearestBruteForce(k, x, y,</span>
                    (float)tolerance, xy2);
            }
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            if (nearest == null) {</span>
<span class="nc" id="L1188">                continue;</span>
            }
            // note nearest has already been filtered by tolerance
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            for (PairFloat p : nearest) {</span>
<span class="nc" id="L1192">                int x2 = Math.round(p.getX());</span>
<span class="nc" id="L1193">                int y2 = Math.round(p.getY());</span>
<span class="nc" id="L1194">                double d = Math.sqrt(</span>
<span class="nc" id="L1195">                    distanceSqEucl(x, y, x2, y2));</span>
<span class="nc" id="L1196">                dist[count] = (float)d;</span>
<span class="nc" id="L1197">                idx1s[count] = i;</span>
<span class="nc" id="L1198">                idx2s[count] = indexMap2.get(new PairInt(x2, y2));</span>
<span class="nc" id="L1199">                count++;</span>
<span class="nc" id="L1200">            }</span>
        }

<span class="fc" id="L1203">        idx1s = Arrays.copyOf(idx1s, count);</span>
<span class="fc" id="L1204">        idx2s = Arrays.copyOf(idx2s, count);</span>
<span class="fc" id="L1205">        dist = Arrays.copyOf(dist, count);</span>
<span class="fc" id="L1206">        int[] ilu = new int[count];</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L1208">            ilu[i] = i;</span>
        }
<span class="fc" id="L1210">        QuickSort.sortBy1stArg(dist, ilu);</span>

<span class="fc" id="L1212">        TIntSet a1 = new TIntHashSet();</span>
<span class="fc" id="L1213">        TIntSet a2 = new TIntHashSet();</span>

<span class="fc" id="L1215">        TObjectFloatMap&lt;PairInt&gt; costMap =</span>
            new TObjectFloatHashMap&lt;PairInt&gt;();

<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">        for (int i = 0; i &lt; dist.length; ++i) {</span>
<span class="nc" id="L1219">            int idx = ilu[i];</span>
<span class="nc" id="L1220">            int idx1 = idx1s[idx];</span>
<span class="nc" id="L1221">            int idx2 = idx2s[idx];</span>
<span class="nc bnc" id="L1222" title="All 4 branches missed.">            if (a1.contains(idx1) || a2.contains(idx2)) {</span>
<span class="nc" id="L1223">                continue;</span>
            }
<span class="nc" id="L1225">            PairInt p = new PairInt(idx1, idx2);</span>
<span class="nc" id="L1226">            costMap.put(p, dist[i]);</span>
<span class="nc" id="L1227">            a1.add(idx1);</span>
<span class="nc" id="L1228">            a2.add(idx2);</span>
        }

<span class="fc" id="L1231">        return costMap;</span>
    }

    private boolean assertIndexesWithinBounds(Result result, 
        int n1, int n2) {
        
<span class="nc bnc" id="L1237" title="All 2 branches missed.">        for (int i = 0; i &lt; result.idx1s.size(); ++i) {</span>
<span class="nc" id="L1238">            int idx1 = result.idx1s.get(i);</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">            if (idx1 &gt;= n1) {</span>
<span class="nc" id="L1240">                return false;</span>
            }
<span class="nc" id="L1242">            int idx2 = result.idx2s.get(i);</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            if (idx2 &gt;= n2) {</span>
<span class="nc" id="L1244">                return false;</span>
            }
        }
        
<span class="nc" id="L1248">        return true;</span>
    }

    private double findMaxChordDiff(List&lt;Result&gt; results) {

<span class="nc" id="L1253">        double max = Double.MIN_VALUE;</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">        for (Result r : results) {</span>
<span class="nc" id="L1255">            double d = r.chordDiffSum;</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            if (d &gt; max) {</span>
<span class="nc" id="L1257">                max = d;</span>
            }
<span class="nc" id="L1259">        }</span>
<span class="nc" id="L1260">        return max;</span>
    }

    private void improveWithRANSAC(Result best, PairIntArray p, PairIntArray q, 
        float[][][] md, int n1, int n2) {
        
<span class="fc" id="L1266">        int n = best.getNumberOfMatches();</span>
        
<span class="fc" id="L1268">        TObjectIntMap&lt;PairInt&gt; pPointIndexMap = new TObjectIntHashMap&lt;PairInt&gt;();</span>
        
<span class="fc" id="L1270">        PairIntArray matchedLeftXY = new PairIntArray(n);</span>
<span class="fc" id="L1271">        PairIntArray matchedRightXY = new PairIntArray(n);</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1273">            int idx1 = best.idx1s.get(i);</span>
<span class="fc" id="L1274">            int idx2 = best.idx2s.get(i);</span>
<span class="fc" id="L1275">            matchedLeftXY.add(p.getX(idx1), p.getY(idx1));</span>
<span class="fc" id="L1276">            matchedRightXY.add(q.getX(idx2), q.getY(idx2));</span>
<span class="fc" id="L1277">            pPointIndexMap.put(new PairInt(p.getX(idx1), p.getY(idx1)), i);</span>
        }
        
<span class="fc" id="L1280">        PairIntArray outputLeftXY = new PairIntArray();</span>
<span class="fc" id="L1281">        PairIntArray outputRightXY = new PairIntArray();</span>
        
<span class="fc" id="L1283">        RANSACSolver solver = new RANSACSolver();</span>

<span class="fc" id="L1285">        double tolerance = 4;</span>
        
<span class="fc" id="L1287">        EpipolarTransformationFit fit = solver.calculateEpipolarProjection(</span>
            matchedLeftXY, matchedRightXY, outputLeftXY, outputRightXY,
            tolerance);

<span class="pc bpc" id="L1291" title="1 of 2 branches missed.">        if (storeMatrix) {</span>
<span class="nc" id="L1292">            storedEpipolarFit = fit;</span>
        }
        
<span class="fc bfc" id="L1295" title="All 2 branches covered.">        if (outputLeftXY.getN() &lt; matchedLeftXY.getN()) {</span>
<span class="fc" id="L1296">            int nOut = outputLeftXY.getN();</span>
<span class="fc" id="L1297">            TIntSet present = new TIntHashSet();</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">            for (int i = 0; i &lt; nOut; ++i) {</span>
<span class="fc" id="L1299">                PairInt p1 = new PairInt(outputLeftXY.getX(i),</span>
<span class="fc" id="L1300">                    outputLeftXY.getY(i));</span>
<span class="fc" id="L1301">                int lIdx = pPointIndexMap.get(p1);</span>
<span class="fc" id="L1302">                present.add(lIdx);</span>
            }
            // remove best indexes not in final output
<span class="fc bfc" id="L1305" title="All 2 branches covered.">            for (int ii = (n - 1); ii &gt; -1; --ii) {</span>
<span class="fc bfc" id="L1306" title="All 2 branches covered.">                if (!present.contains(ii)) {</span>
<span class="fc" id="L1307">                    best.idx1s.removeAt(ii);</span>
<span class="fc" id="L1308">                    best.idx2s.removeAt(ii);</span>
                }
            }
            
            //TODO: consider adding nearest neighbor unmatched within bounds
            
<span class="fc" id="L1314">            populateWithChordDiffs(best, md, n1, n2);</span>
        }       
<span class="fc" id="L1316">    }</span>

    private PairIntArray reverseXY(PairIntArray matchedIndexes) {

<span class="nc" id="L1320">        int n = matchedIndexes.getN();</span>
        
<span class="nc" id="L1322">        PairIntArray r = new PairIntArray(n);</span>
        
<span class="nc bnc" id="L1324" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L1325">            r.add(matchedIndexes.getY(i),</span>
<span class="nc" id="L1326">                matchedIndexes.getX(i));</span>
        }
        
<span class="nc" id="L1329">        return r;</span>
    }
    
    private double findMaxDiffChordSum(List&lt;SR&gt; list) {
<span class="fc" id="L1333">        double max = Double.MIN_VALUE;</span>
<span class="fc bfc" id="L1334" title="All 2 branches covered.">        for (SR sr : list) {</span>
<span class="fc" id="L1335">            double v = sr.maxChordSum;</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">            if (v &gt; max) {</span>
<span class="fc" id="L1337">                max = v;</span>
            }
<span class="fc" id="L1339">        }</span>
<span class="fc" id="L1340">        return max;</span>
    }

    /**
     * search the difference chord sum matrix a for minimum Salukwzde cost
     * and put results in outputIntervals and the sum of the chord differences
     * in outputValues.
     * runtime complexity is currently O(n1^3).
     * @param a
     * @param outputIntervals
     * @param outputValues 
     */
    private void search(float[][] a, List&lt;Interval&lt;Integer&gt;&gt; outputIntervals,
        List&lt;SR&gt; outputValues, int offset) {
    
        //q.n is &gt;= p.n, that is, n2 &gt;= n1
<span class="fc" id="L1356">        int n1 = a.length;</span>
<span class="fc" id="L1357">        int n2 = a[0].length;</span>

        // storing the interval of consecutive indexes, each below threshold,
        //   and storing as the value, the key to entry in intervalMap
<span class="fc" id="L1361">        IntervalRangeSearch&lt;Integer, SR&gt; rangeSearch =</span>
            new IntervalRangeSearch&lt;Integer, SR&gt;();

<span class="fc" id="L1364">        Interval&lt;Integer&gt; interval = null;</span>

<span class="fc" id="L1366">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
 
<span class="fc" id="L1368">        double maxChordSum = Double.MIN_VALUE;</span>

<span class="fc" id="L1370">        float[] outC = new float[2];</span>
        int stop, start;
        
<span class="fc" id="L1373">        SummedColumnTable sct = new SummedColumnTable();</span>
        
<span class="fc" id="L1375">        int rUpper = n1 - 1;</span>
<span class="pc bpc" id="L1376" title="3 of 4 branches missed.">        if (maxLength &gt; -1 &amp;&amp; maxLength &lt; (rUpper)) {</span>
<span class="nc" id="L1377">            rUpper = maxLength;</span>
        }
        
        // using row major notation of a[row][col]
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        for (int r = rUpper; r &gt;= minLength; --r) {</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">            for (int row = 0; row &lt; n1; ++row) {</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">                for (int col = 0; col &lt; n1; col += r) {</span>
<span class="fc" id="L1384">                    stop = col + r;</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">                    if (stop &gt; (n1 - 1)) {</span>
<span class="fc" id="L1386">                        stop = n1 - 1;</span>
                    }
<span class="fc" id="L1388">                     start = col;</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">                    if (stop == start) {</span>
                        // do not store single index matches
<span class="fc" id="L1391">                        continue;</span>
                    }

<span class="fc" id="L1394">                    int ni = stop - start + 1;</span>
<span class="fc bfc" id="L1395" title="All 2 branches covered.">                    if (ni &lt; minLength) {</span>
<span class="fc" id="L1396">                        continue;</span>
                    }
<span class="fc" id="L1398">                    sct.extractWindowInColumn(a, col, stop, row, outC);</span>
<span class="pc bpc" id="L1399" title="1 of 2 branches missed.">                    if (outC[1] &lt; 1) {</span>
<span class="nc" id="L1400">                        continue;</span>
                    }
<span class="fc" id="L1402">                    float d = outC[0]/outC[1];</span>
<span class="pc bpc" id="L1403" title="3 of 4 branches missed.">                    if (debug &amp;&amp; ((col % 50) == 0)) {</span>
<span class="nc" id="L1404">                        System.out.println(&quot;interval &quot; + d + </span>
                        &quot; sr=&quot; + col + &quot; : &quot; + stop + &quot; off=&quot; + offset 
                        + &quot; Len=&quot; + (stop - col + 1));
                        //System.out.println(String.format(
                        //&quot;len=%d i=%d d=%.2f&quot;, (stop - j + 1), i, d));
                    }
<span class="fc bfc" id="L1410" title="All 2 branches covered.">                    if (d &gt; thresh) {</span>
<span class="fc" id="L1411">                        continue;</span>
                    }
<span class="fc bfc" id="L1413" title="All 2 branches covered.">                    if (d &gt; maxChordSum) {</span>
<span class="fc" id="L1414">                        maxChordSum = d;</span>
                    }

<span class="fc" id="L1417">                    interval =  new Interval&lt;Integer&gt;(start, stop);</span>
<span class="fc" id="L1418">                    PairInt s = new PairInt(start, stop);</span>
<span class="fc bfc" id="L1419" title="All 2 branches covered.">                    if (added.contains(s)) {</span>
<span class="fc" id="L1420">                        continue;</span>
                    }

                    //a, col, stop, row, outC
<span class="fc" id="L1424">                    SR sr = new SR();</span>
<span class="fc" id="L1425">                    sr.startIdx1 = col;</span>
<span class="fc" id="L1426">                    sr.stopIdx1 = stop;</span>
<span class="fc" id="L1427">                    sr.offsetIdx2 = offset;</span>
<span class="fc" id="L1428">                    sr.row = row;</span>
<span class="fc" id="L1429">                    sr.diffChordSum = d;</span>
<span class="fc" id="L1430">                    sr.setChordSumNeedsUpdate(false);</span>
<span class="fc" id="L1431">                    sr.maxChordSum = maxChordSum;</span>
<span class="fc" id="L1432">                    sr.mLen = ni;</span>
<span class="fc" id="L1433">                    sr.nMax = n1; // n1 &lt;= n2</span>
                
<span class="fc" id="L1435">                    boolean didIns = rangeSearch.putIfLessThan(interval, sr, sr);</span>

<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">                    if (debug) {</span>
<span class="nc" id="L1438">                        System.out.println(&quot;interval: &quot; + d + </span>
                            &quot; sr=&quot; + col + &quot; : &quot; + stop 
                            + &quot; off=&quot; + offset + &quot; row=&quot; + row 
                            + &quot; Len=&quot; + (stop - col + 1)
                            + &quot; didIns=&quot; + didIns 
                            + &quot; (maxCh=&quot; + sr.maxChordSum
                            + &quot; sd=&quot; + 
<span class="nc" id="L1445">                            sr.calcSalukDist());</span>
                    }
                    
<span class="fc" id="L1448">                    added.add(s);</span>
                }
            } // end loop j
        } // end r
                
<span class="fc" id="L1453">        rangeSearch.getAllIntervals(outputIntervals, outputValues);</span>
    
<span class="pc bpc" id="L1455" title="3 of 4 branches missed.">        assert(outputIntervals.size() == outputValues.size());</span>
<span class="fc" id="L1456">    }</span>

    /**
     * create the matrices of differences between p
     * and q.  Note that the matrix differences are
     * absolute differences.
     * index0 is rotations of q,  index1 is p.n, index2 is q.n
      returns a[0:q.n-1][0:p.n-1][0:p.n-1]
    */
    protected float[][][] createDifferenceMatrices(
        PairIntArray p, PairIntArray q) {

<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">        if (p.getN() &gt; q.getN()) {</span>
<span class="nc" id="L1469">            throw new IllegalArgumentException(</span>
            &quot;q.n must be &gt;= p.n&quot;);
        }

        /*
        | a_1_1...a_1_N |
        | a_2_1...a_2_N |
               ...
        | a_N_1...a_N_N |
           elements on the diagonal are zero

           to shift to different first point as reference,
           can shift down k-1 rows and left k-1 columns.
        */
        
        //TODO: look into Toeplitz matrix and cyclic matrix

        //log.fine(&quot;a1:&quot;);
<span class="fc" id="L1487">        float[][] a1 = createDescriptorMatrix(p, p.getN());</span>

        //log.fine(&quot;a2:&quot;);
<span class="fc" id="L1490">        float[][] a2 = createDescriptorMatrix(q, q.getN());</span>

        /*
         make difference matrices.
            there will be N A_2 matrices in which each
            is shifted left and up by 1 (or some other value).

            M_D^n = A_1(1:M,1:M) - A_2(n:n+M-1,n:n+M-1)
                shifting A_2 by 0 through N covering all
                orientation angles.
        */

        /*
            MXM              NXN
                         30 31 32 33
         20 21 22        20 21 22 23
         10 11 12        10 11 12 13
         00 01 02        00 01 02 03   p_i_j - q_i_j

                         01 02 03 00
         20 21 22        31 32 33 30
         10 11 12        21 22 23 20
         00 01 02        11 12 13 10  p_i_j - q_(i+1)_(j+1)

                         12 13 10 11
         20 21 22        02 03 00 01
         10 11 12        32 33 30 31
         00 01 02        22 23 20 21  p_i_j - q_(i+2)_(j+2)

                         23 20 21 22
         20 21 22        13 10 11 12
         10 11 12        03 00 01 02
         00 01 02        33 30 31 32  p_i_j - q_(i+3)_(j+3)
        */

        // --- make difference matrices ---
<span class="fc" id="L1526">        int n1 = p.getN();</span>
<span class="fc" id="L1527">        int n2 = q.getN();</span>
<span class="fc" id="L1528">        float[][][] md = new float[n2][][];</span>
<span class="fc" id="L1529">        float[][] prevA2Shifted = null;</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">        for (int i = 0; i &lt; n2; ++i) {</span>
            float[][] shifted2;
<span class="fc bfc" id="L1532" title="All 2 branches covered.">            if (prevA2Shifted == null) {</span>
<span class="fc" id="L1533">                shifted2 = copy(a2);</span>
            } else {
                // shifts by 1 to left and up by 1
<span class="fc" id="L1536">                rotate(prevA2Shifted);</span>
<span class="fc" id="L1537">                shifted2 = prevA2Shifted;</span>
            }
            // NOTE: absolute values are stored.
            //M_D^n = A_1(1:M,1:M) - A_2(n:n+M-1,n:n+M-1)
<span class="fc" id="L1541">            md[i] = subtract(a1, shifted2);</span>
<span class="pc bpc" id="L1542" title="3 of 4 branches missed.">            assert(md[i].length == n1);</span>
<span class="pc bpc" id="L1543" title="3 of 4 branches missed.">            assert(md[i][0].length == n1);</span>
<span class="fc" id="L1544">            prevA2Shifted = shifted2;</span>
        }
       
        //print(&quot;differences:&quot;, md);

<span class="fc" id="L1549">        return md;</span>
    }

    /**
     given the shape points for p and q,
     create a matrix of descriptors, describing the difference
     in chord angles.

     The chord descriptor is invariant to translation, rotation,
     and scale:
       - a chord is a line joining 2 region points
       - uses the relative orientation between 2 chords
         angle a_i_j is from chord P_i_P_j to reference
         point P_i
         to another sampled point and chord P_j_P_(j-d) and P_j

         d is the number of points before j in the sequence of points P.

         a_i_j is the angle between the 2 chords P_i_P_j and P_j_P_(j-d)
    */
    protected float[][] createDescriptorMatrix(PairIntArray p, int n) {
        
<span class="fc" id="L1571">        int dp1 = 1;</span>

<span class="fc" id="L1573">        float[][] a = new float[n][];</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1575">            a[i] = new float[n];</span>
        }

        /*
             P1      Pmid

                  P2
        */

<span class="fc" id="L1584">        log.fine(&quot;n=&quot; + n);</span>

<span class="fc bfc" id="L1586" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n; ++i1) {</span>
<span class="fc" id="L1587">            int start = i1 + 1 + dp1;</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">            for (int ii = start; ii &lt; (start + n - 1 - dp1); ++ii) {</span>
<span class="fc" id="L1589">                int i2 = ii;</span>

<span class="fc" id="L1591">                int imid = i2 - dp1;</span>
                // wrap around
<span class="fc bfc" id="L1593" title="All 2 branches covered.">                if (imid &gt; (n - 1)) {</span>
<span class="fc" id="L1594">                    imid -= n;</span>
                }

                // wrap around
<span class="fc bfc" id="L1598" title="All 2 branches covered.">                if (i2 &gt; (n - 1)) {</span>
<span class="fc" id="L1599">                    i2 -= n;</span>
                }

                //log.fine(&quot;i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2);

<span class="fc" id="L1604">                double angleA = LinesAndAngles.calcAngle(</span>
                //double angleA = LinesAndAngles.calcClockwiseAngle(
<span class="fc" id="L1606">                    p.getX(i1), p.getY(i1),</span>
<span class="fc" id="L1607">                    p.getX(i2), p.getY(i2),</span>
<span class="fc" id="L1608">                    p.getX(imid), p.getY(imid)</span>
                );
                
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">                if (Double.isNaN(angleA)) {</span>
<span class="nc bnc" id="L1612" title="All 4 branches missed.">                    if (i2 &lt; i1 &amp;&amp; i1 &lt; imid) {</span>
<span class="nc" id="L1613">                        angleA = LinesAndAngles.calcAngle(</span>
                        //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="nc" id="L1615">                            p.getX(i2), p.getY(i2),</span>
<span class="nc" id="L1616">                            p.getX(i1), p.getY(i1),</span>
<span class="nc" id="L1617">                            p.getX(imid), p.getY(imid));</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                        if (Double.isNaN(angleA)) {</span>
<span class="nc" id="L1619">                            angleA = LinesAndAngles.calcAngle(</span>
                            //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="nc" id="L1621">                                p.getX(i2), p.getY(i2),</span>
<span class="nc" id="L1622">                                p.getX(i1), p.getY(i1),</span>
<span class="nc" id="L1623">                                p.getX(imid), p.getY(imid));</span>
                        }
                    } else {
                       // System.out.println(
                       // &quot;SKIP i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2);
                        continue;
                    }
                }

                /*
                String str = String.format(
                    &quot;[%d](%d,%d) [%d](%d,%d) [%d](%d,%d) a=%.4f&quot;,
                    i1, p.getX(i1), p.getY(i1),
                    i2, p.getX(i2), p.getY(i2),
                    imid, p.getX(imid), p.getY(imid),
                    (float) angleA * 180. / Math.PI);
                log.fine(str);
                */

<span class="fc" id="L1642">                a[i1][i2] = (float)angleA;</span>
                
<span class="fc bfc" id="L1644" title="All 2 branches covered.">                if (i2 == (i1 + 2)) {</span>
                    // fill in missing point, assume same value
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">                    if (a[i1][i2] == a[i1][ii]) {</span>
<span class="fc" id="L1647">                        a[i1][i1 + 1] = a[i1][i2];</span>
                    }
                }
            }
        }

<span class="fc" id="L1653">        return a;</span>
    }

    protected int distanceSqEucl(int x1, int y1, int x2, int y2) {
<span class="nc" id="L1657">        int diffX = x1 - x2;</span>
<span class="nc" id="L1658">        int diffY = y1 - y2;</span>
<span class="nc" id="L1659">        return (diffX * diffX + diffY * diffY);</span>
    }

    private float[][] copy(float[][] a) {
<span class="fc" id="L1663">        float[][] a2 = new float[a.length][];</span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">        for (int i = 0; i &lt; a2.length; ++i) {</span>
<span class="fc" id="L1665">            a2[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }
<span class="fc" id="L1667">        return a2;</span>
    }

    private void rotate(float[][] prevShifted) {

         // shift x left by 1 first
<span class="fc bfc" id="L1673" title="All 2 branches covered.">         for (int y = 0; y &lt; prevShifted[0].length; ++y) {</span>
<span class="fc" id="L1674">             float tmp0 = prevShifted[0][y];</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">             for (int x = 0; x &lt; (prevShifted.length- 1); ++x){</span>
<span class="fc" id="L1676">                 prevShifted[x][y] = prevShifted[x + 1][y];</span>
             }
<span class="fc" id="L1678">             prevShifted[prevShifted.length - 1][y] = tmp0;</span>
         }

         // shift y down by 1
<span class="fc bfc" id="L1682" title="All 2 branches covered.">         for (int x = 0; x &lt; prevShifted.length; ++x) {</span>
<span class="fc" id="L1683">             float tmp0 = prevShifted[x][0];</span>
<span class="fc bfc" id="L1684" title="All 2 branches covered.">             for (int y = 0; y &lt; (prevShifted[x].length - 1); ++y){</span>
<span class="fc" id="L1685">                 prevShifted[x][y] = prevShifted[x][y + 1];</span>
             }
<span class="fc" id="L1687">             prevShifted[x][prevShifted[x].length - 1] = tmp0;</span>
         }
<span class="fc" id="L1689">    }</span>

    /**
     * subtract the portion of a2 that is same size as
     * a1 from a1.
     * @param a1
     * @param a2
     * @return
     */
    private float[][] subtract(float[][] a1, float[][] a2) {

        /*
         MXM     NXN
                 20 21 22
         10 11   10 11 12
         00 01   00 01 02

                 01 02 00
         10 11   21 22 20
         00 01   11 12 10

                 12 10 11
         10 11   02 00 01
         00 01   22 20 21

        subtracting only the MXM portion
        */

<span class="pc bpc" id="L1717" title="3 of 4 branches missed.">        assert(a1.length == a1[0].length);</span>
<span class="pc bpc" id="L1718" title="3 of 4 branches missed.">        assert(a2.length == a2[0].length);</span>

<span class="fc" id="L1720">        int n1 = a1.length;</span>
<span class="fc" id="L1721">        int n2 = a2.length;</span>

<span class="pc bpc" id="L1723" title="3 of 4 branches missed.">        assert(n1 &lt;= n2);</span>

<span class="fc" id="L1725">        float[][] output = new float[n1][];</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L1727">            output[i] = new float[n1];</span>
<span class="fc bfc" id="L1728" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L1729">                float v = a1[i][j] - a2[i][j];</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">                if (v &lt; 0) {</span>
<span class="fc" id="L1731">                    v *= -1;</span>
                }
<span class="fc" id="L1733">                output[i][j] = v;</span>
            }
        }

<span class="fc" id="L1737">        return output;</span>
    }
    
    protected void applySummedColumnTableConversion(float[][][] md) {
<span class="fc bfc" id="L1741" title="All 2 branches covered.">        for (int i = 0; i &lt; md.length; ++i) {</span>
<span class="fc" id="L1742">            applySummedColumnTableConversion(md[i]);</span>
        }
<span class="fc" id="L1744">    }</span>

    protected void applySummedColumnTableConversion(float[][] mdI) {

<span class="fc" id="L1748">        int w = mdI.length;</span>
<span class="fc" id="L1749">        int h = mdI[0].length;</span>
        
        // sum along columns, that is a[i][*]
<span class="fc bfc" id="L1752" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">                if (j &gt; 0) {</span>
<span class="fc" id="L1755">                    mdI[i][j] += mdI[i][j - 1];</span>
                }
            }
        }
<span class="fc" id="L1759">    }</span>

    private List&lt;PairFloat&gt; kNearestBruteForce(
        int k, int x, int y, float tolerance,
        PairIntArray xy2) {

<span class="nc" id="L1765">        int nn = 0;</span>
<span class="nc" id="L1766">        float[] dist = new float[xy2.getN()];</span>
<span class="nc" id="L1767">        int[] indexes = new int[xy2.getN()];</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">        for (int i = 0; i &lt; xy2.getN(); ++i) {</span>
<span class="nc" id="L1769">            int diffX = xy2.getX(i) - x;</span>
<span class="nc" id="L1770">            int diffY = xy2.getY(i) - y;</span>
<span class="nc" id="L1771">            dist[i] = (float) Math.sqrt(</span>
                diffX * diffX + diffY * diffY);
<span class="nc bnc" id="L1773" title="All 2 branches missed.">            if (dist[i] &lt;= tolerance) {</span>
<span class="nc" id="L1774">                nn++;</span>
            }
<span class="nc" id="L1776">            indexes[i] = i;</span>
        }

<span class="nc bnc" id="L1779" title="All 2 branches missed.">        if (nn == 0) {</span>
<span class="nc" id="L1780">            return null;</span>
        }

<span class="nc" id="L1783">        QuickSort.sortBy1stArg(dist, indexes);</span>

<span class="nc bnc" id="L1785" title="All 2 branches missed.">        if (k &lt; nn) {</span>
<span class="nc" id="L1786">            nn = k;</span>
        }

<span class="nc" id="L1789">        List&lt;PairFloat&gt; list = new ArrayList&lt;PairFloat&gt;(nn);</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        for (int i = 0; i &lt; nn; ++i) {</span>
<span class="nc" id="L1791">            int idx = indexes[i];</span>
<span class="nc" id="L1792">            int x2 = xy2.getX(idx);</span>
<span class="nc" id="L1793">            int y2 = xy2.getY(idx);</span>
<span class="nc" id="L1794">            PairFloat p = new PairFloat(x2, y2);</span>
<span class="nc" id="L1795">            list.add(p);</span>
        }

<span class="nc" id="L1798">        return list;</span>
    }

    public static class Result {
        protected double distSum = 0;
        protected double chordDiffSum = 0;
        protected boolean chordsNeedUpdates = true;
        protected TransformationParameters params = null;
        // indexes for the correspondence from shape 1
        protected TIntList idx1s = new TIntArrayList();
        // indexes for the correspondence from shape 2
        protected TIntList idx2s = new TIntArrayList();
        // if articulated search, this contains a segment number
        //   for each gap filled with contiguous correspondence.
        protected final int n1;
        protected final int n2;
        protected final int origN1;
        protected Object[] data = null;
        public Result(int n1, int n2, int origN1) {
            this.n1 = n1;
            this.n2 = n2;
            this.origN1 = origN1;
        }
        
        public void insert(int idx1, int idx2, float dist) {
            idx1s.add(idx1);
            idx2s.add(idx2);
            distSum += dist;
        }

        public int getIdx1(int index) {
            return idx1s.get(index);
        }
        public int getIdx2(int index) {
            return idx2s.get(index);
        }

        public int getNumberOfMatches() {
            return idx1s.size();
        }

        public float getFractionOfWhole() {
            return (float)idx1s.size()/(float)origN1;
        }

        protected double getNormalizedChordDiff(double maxChordSum) {
            double d = chordDiffSum/maxChordSum;
            return d;
        }
        
        public double getChordDiffSum() {
            return chordDiffSum;
        }

        void addToChordDifferenceSum(float diff) {
            chordDiffSum += diff;
        }

        public int getOriginalN1() {
            return origN1;
        }
        
        public Object[] getData() {
            return data;
        }
        
        public void setData(Object[] theData) {
            this.data = theData;
        }
        
        public void setTransformationParameters(TransformationParameters
            euclidParams) {
            this.params = euclidParams;
        }
        
        public TransformationParameters getTransformationParameters() {
            return params;
        }
        
        // NOTE: need to complete this for some cases such as
        // same number of points sampling.
        public double getDistSum() {
            return distSum;
        }
        
        protected boolean assertIndexesWithinBounds() {
            for (int i = 0; i &lt; idx1s.size(); ++i) {
                int idx1 = idx1s.get(i);
                if (idx1 &gt;= n1) {
                    return false;
                }
                int idx2 = idx2s.get(i);
                if (idx2 &gt;= n2) {
                    return false;
                }
            }
            return true;
        }

        /**
         * reverse the mappings from list 1 to list 2
         * to the reference frame of list 2 to list 1.
         * @return
         */
        public Result transpose() {

            assert(assertIndexesWithinBounds());
            
            Result t = new Result(n2, n1, n1);
            t.idx1s.addAll(idx2s);
            t.idx2s.addAll(idx1s);
            t.distSum = distSum;
            t.chordDiffSum = chordDiffSum;
            t.data = data;
            
            assert(t.assertIndexesWithinBounds());
            
            if (params != null) {
                MatchedPointsTransformationCalculator tc =
                    new MatchedPointsTransformationCalculator();
                TransformationParameters params2 = 
                    tc.swapReferenceFrames(params);
                t.setTransformationParameters(params2);
            }

            return t;
        }

        @Override
        public String toString() {

            StringBuilder sb = new StringBuilder();
            sb.append(String.format(
                &quot;nMatched=%d frac=%.4f distSum=%.4f dChordSum=%.4f&quot;,
                idx1s.size(), getFractionOfWhole(),
                (float)distSum, (float)chordDiffSum));
            if (params != null) {
                sb.append(&quot;\nparams=&quot;).append(params.toString());
            }
            sb.append(&quot;\n&quot;);

            for (int i = 0; i &lt; idx1s.size(); ++i) {
                sb.append(String.format(&quot;%d (%d, %d)\n&quot;,
                    i, idx1s.get(i), idx2s.get(i)));
            }

            return sb.toString();
        }

        public String toStringAbbrev() {

            StringBuilder sb = new StringBuilder();
            sb.append(String.format(
                &quot;nMatched=%d frac=%.4f dChordSum=%.4f distSum=%.4f &quot;,
                idx1s.size(), getFractionOfWhole(),
                (float)chordDiffSum, (float)distSum));

            return sb.toString();
        }
    }

    private List&lt;Result&gt; transformAndEvaluate(
        List&lt;SR&gt; intervals, PairIntArray p, PairIntArray q,
        float[][][] md, float pixTol, int topK,
        List&lt;PairIntArray&gt; addedPointLists) {

<span class="pc bpc" id="L1964" title="1 of 2 branches missed.">        if (intervals.size() == 0) {</span>
<span class="nc" id="L1965">            return null;</span>
        }

<span class="fc" id="L1968">        List&lt;Result&gt; results = new ArrayList&lt;Result&gt;(topK);</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        for (int i = 0; i &lt; topK; ++i) {</span>
            
<span class="fc" id="L1971">            SR sr = intervals.get(i);</span>
            
            //System.out.println(&quot;srLen=&quot; + sr.mLen);
            
<span class="fc" id="L1975">            PairIntArray added = new PairIntArray();</span>
<span class="fc" id="L1976">            Result result = null;</span>
            
<span class="pc bpc" id="L1978" title="1 of 2 branches missed.">            if (sr.mLen &lt; 7) {</span>
                //too few for the RANSAC algorithm
<span class="nc" id="L1980">                result = smallNumberEuclidean(sr, p, q, pixTol, added);</span>
            } else { 
<span class="fc" id="L1982">                result = addByTransformation(sr, p, q, pixTol, added);</span>
            }
            
<span class="pc bpc" id="L1985" title="1 of 2 branches missed.">            if (result != null) {</span>
<span class="pc bpc" id="L1986" title="3 of 4 branches missed.">                assert(assertIndexesWithinBounds(result, p.getN(), q.getN()));</span>
<span class="fc" id="L1987">                results.add(result);</span>
<span class="fc" id="L1988">                addedPointLists.add(added);</span>
            }
        }

<span class="pc bpc" id="L1992" title="1 of 2 branches missed.">        if (results.isEmpty()) {</span>
<span class="nc" id="L1993">            return null;</span>
        }
        
        { //DEBUG, recalc the saluk score to see if top has changed
            //TODO:   
        }
     
<span class="fc" id="L2000">        return results;</span>
    }
    
    /**
     * 
     * @param result
     * @param md
     * @param n1
     * @param n2 
     */
    private void populateWithChordDiffs(Result result,
        float[][][] md, int n1, int n2) {
       
<span class="pc bpc" id="L2013" title="3 of 4 branches missed.">        assert(md[0][0].length == n1);</span>
        
        //md[0:n2-1][0:n1-1][0:n1-1]
        
        // NOTE: this update method doesn't efficiently use the summed column
        //    structure of md, so will consider changing
        //    the intermediate results to remain as SR intervals,
        //    even if the interval is a single pixel.
        //    and this argument receives a list of SR instead of a Result

<span class="fc" id="L2023">        result.chordDiffSum = 0;</span>
        
<span class="fc" id="L2025">        SummedColumnTable sct = new SummedColumnTable();</span>
<span class="fc" id="L2026">        float[] output = new float[2];</span>
<span class="fc" id="L2027">        int row = 0;</span>
<span class="fc" id="L2028">        int offset = 0;</span>
        int idx1, idx2;
        
<span class="fc bfc" id="L2031" title="All 2 branches covered.">        for (int i = 0; i &lt; result.getNumberOfMatches(); ++i) {</span>
            
            // reading 1 pixel at a time...not ideal compared to the smaller
            //  cost over the best interval that it was extracted from
            
<span class="fc" id="L2036">            idx1 = result.getIdx1(i);</span>
<span class="fc" id="L2037">            idx2 = result.getIdx2(i);</span>
 
<span class="fc" id="L2039">            offset = 0;</span>

<span class="fc bfc" id="L2041" title="All 2 branches covered.">            if (idx2 &gt; (n1 - 2)) {</span>
                // idx2 is outside of the default row 0 of md[0] array, so
                // need to calculate the offset.
                
                // if within bounds, will add 4 to the offset to get the pixel
                // away from bounds
                                
<span class="pc bpc" id="L2048" title="1 of 2 branches missed.">                if (((idx2 - (n1 - 2)) + 4) &lt; (n1 - 2)) {</span>
<span class="fc" id="L2049">                    offset = (idx2 - (n1 - 2)) + 4;</span>
                } else {
<span class="nc" id="L2051">                    offset = (idx2 - (n1 - 2));</span>
                }
<span class="fc" id="L2053">                idx2 -= offset;</span>
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">                if (idx2 &lt; 0) {</span>
<span class="nc" id="L2055">                    offset = idx2 - (n1 - 2);</span>
<span class="nc" id="L2056">                    idx2 -= offset;</span>
                }
            }
           
<span class="fc" id="L2060">            sct.extractWindowInColumn(md[offset], idx2, idx2 + 1, idx1, output);</span>
            
<span class="fc" id="L2062">            float d = output[0]/output[1];</span>
          
<span class="fc" id="L2064">            result.chordDiffSum += d;</span>
        }
        
<span class="fc" id="L2067">        result.chordsNeedUpdates = false;</span>
<span class="fc" id="L2068">    }</span>

    /**
     * given a chord difference matrix which does not use summed columns
     * nor summed area, extract the chord differences of the matched indexes.
     * @param md
     * @param n1
     * @param n2 
     * @param matchedIndexes
     */
    private TDoubleList extractChordDiffs(float[][][] md, int n1, int n2,
        PairIntArray matchedIndexes) {
       
<span class="nc bnc" id="L2081" title="All 4 branches missed.">        assert(md[0][0].length == n1);</span>
<span class="nc bnc" id="L2082" title="All 4 branches missed.">        assert(md.length == n2);</span>
<span class="nc bnc" id="L2083" title="All 4 branches missed.">        assert(md[0].length == n1);</span>
        
        //md[0:n2-1][0:n1-1][0:n1-1]
        
<span class="nc" id="L2087">        TDoubleList chordDiffs = new TDoubleArrayList();</span>
        
<span class="nc" id="L2089">        int offset = 0;</span>
        int idx1, idx2;
        
        /*
            MXM              NXN
                         30 31 32 33
         20 21 22        20 21 22 23
         10 11 12        10 11 12 13
         00 01 02        00 01 02 03   p_i_j - q_i_j

                         01 02 03 00
         20 21 22        31 32 33 30
         10 11 12        21 22 23 20
         00 01 02        11 12 13 10  p_i_j - q_(i+1)_(j+1)

                         12 13 10 11
         20 21 22        02 03 00 01
         10 11 12        32 33 30 31
         00 01 02        22 23 20 21  p_i_j - q_(i+2)_(j+2)

                         23 20 21 22
         20 21 22        13 10 11 12
         10 11 12        03 00 01 02
         00 01 02        33 30 31 32  p_i_j - q_(i+3)_(j+3)
        */

<span class="nc bnc" id="L2115" title="All 2 branches missed.">        for (int i = 0; i &lt; matchedIndexes.getN(); ++i) {</span>
            
<span class="nc" id="L2117">            idx1 = matchedIndexes.getX(i);</span>
<span class="nc" id="L2118">            idx2 = matchedIndexes.getY(i);</span>
 
            // idx2 is at column 0 when offset=idx2.
            // since n2 &gt;= n1, offset should be within bounds for tht offset.
            // but the diagonals are 0, so choosing a position
            // at least a few pixels away from bounds.
<span class="nc" id="L2124">            offset = 0;</span>

<span class="nc bnc" id="L2126" title="All 2 branches missed.">            if (idx2 &gt; (n1 - 2)) {</span>
                // idx2 is outside of the default row 0 of md[0] array, so
                // need to calculate the offset.
                
                // if within bounds, will add 4 to the offset to get the pixel
                // away from bounds
                                
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                if (((idx2 - (n1 - 2)) + 4) &lt; (n1 - 2)) {</span>
<span class="nc" id="L2134">                    offset = (idx2 - (n1 - 2)) + 4;</span>
                } else {
<span class="nc" id="L2136">                    offset = (idx2 - (n1 - 2));</span>
                }
<span class="nc" id="L2138">                idx2 -= offset;</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">                if (idx2 &lt; 0) {</span>
<span class="nc" id="L2140">                    offset = idx2 - (n1 - 2);</span>
<span class="nc" id="L2141">                    idx2 -= offset;</span>
                }
            }
                        
<span class="nc" id="L2145">            chordDiffs.add(md[offset][idx1][idx2]);</span>
        }
        
<span class="nc" id="L2148">        return chordDiffs;</span>
    }

    protected void populatePointArrays(SR sr, PairIntArray p, PairIntArray q,
        PairIntArray pOut, PairIntArray qOut,
        PairIntArray pUnmatchedOut, PairIntArray qUnmatchedOut) {

<span class="fc" id="L2155">        int offset = sr.offsetIdx2;</span>
<span class="fc" id="L2156">        int len = sr.mLen;</span>

<span class="fc" id="L2158">        int n1 = p.getN();</span>
<span class="fc" id="L2159">        int n2 = q.getN();</span>

<span class="fc" id="L2161">        TIntSet pIdxs = new TIntHashSet();</span>
<span class="fc" id="L2162">        TIntSet qIdxs = new TIntHashSet();</span>

<span class="fc bfc" id="L2164" title="All 2 branches covered.">        for (int i = 0; i &lt; len; ++i) {</span>

<span class="fc" id="L2166">            int pIdx = i;</span>
<span class="pc bpc" id="L2167" title="3 of 4 branches missed.">            assert(pIdx &lt; n1);</span>

<span class="fc" id="L2169">            pIdxs.add(pIdx);</span>
<span class="fc" id="L2170">            pOut.add(p.getX(pIdx), p.getY(pIdx));</span>

<span class="fc" id="L2172">            int qIdx = pIdx + offset;</span>
<span class="fc bfc" id="L2173" title="All 2 branches covered.">            if (qIdx &gt;= n2) {</span>
<span class="fc" id="L2174">                qIdx -= n2;</span>
            }
            
<span class="fc" id="L2177">            qIdxs.add(qIdx);</span>
<span class="fc" id="L2178">            qOut.add(q.getX(qIdx), q.getY(qIdx));</span>
        }

<span class="pc bpc" id="L2181" title="3 of 4 branches missed.">        assert(pOut.getN() == len);</span>
<span class="pc bpc" id="L2182" title="3 of 4 branches missed.">        assert(qOut.getN() == len);</span>

        // -- populate unmatched p ----
<span class="fc bfc" id="L2185" title="All 2 branches covered.">        for (int i = 0; i &lt; p.getN(); ++i) {</span>
<span class="pc bpc" id="L2186" title="1 of 2 branches missed.">            if (!pIdxs.contains(i)) {</span>
<span class="nc" id="L2187">                pUnmatchedOut.add(p.getX(i), p.getY(i));</span>
            }
        }
        
<span class="fc bfc" id="L2191" title="All 2 branches covered.">        for (int i = 0; i &lt; q.getN(); ++i) {</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">            if (!qIdxs.contains(i)) {</span>
<span class="fc" id="L2193">                qUnmatchedOut.add(q.getX(i), q.getY(i));</span>
            }
        }
        
<span class="pc bpc" id="L2197" title="3 of 4 branches missed.">        assert(pUnmatchedOut.getN() + pOut.getN() == p.getN());</span>
<span class="pc bpc" id="L2198" title="3 of 4 branches missed.">        assert(qUnmatchedOut.getN() + qOut.getN() == q.getN());</span>
<span class="fc" id="L2199">    }</span>
    
    private Result addByTransformation(SR sr, PairIntArray p, PairIntArray q,
        float pixTol, PairIntArray outputAddedPoints) {

<span class="fc" id="L2204">        int len = sr.mLen;</span>
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">        if (len &lt; 2) {</span>
<span class="nc" id="L2206">            return null;</span>
        }
        
<span class="fc" id="L2209">        PairIntArray leftXY = new PairIntArray(len);</span>
<span class="fc" id="L2210">        PairIntArray rightXY = new PairIntArray(len);</span>
<span class="fc" id="L2211">        PairIntArray leftUnmatchedXY = new PairIntArray(p.getN() - len);</span>
<span class="fc" id="L2212">        PairIntArray rightUnmatchedXY = new PairIntArray(q.getN() - len);</span>

<span class="fc" id="L2214">        populatePointArrays(sr, p, q, leftXY, rightXY,</span>
            leftUnmatchedXY, rightUnmatchedXY);

<span class="fc" id="L2217">        log.fine(&quot; lft.n=&quot; + leftXY.getN()</span>
<span class="fc" id="L2218">            + &quot; rgt.n=&quot; + rightXY.getN());</span>

<span class="fc" id="L2220">        return addByTransformation(p, q,</span>
            leftXY, rightXY, leftUnmatchedXY, rightUnmatchedXY,
            pixTol, outputAddedPoints);
    }
    
    private Result addByTransformation(
        PairIntArray p, PairIntArray q,
        PairIntArray left, PairIntArray right,
        PairIntArray leftUnmatched, PairIntArray rightUnmatched,
        float pixTol, PairIntArray outAddedPoints) {

<span class="fc" id="L2231">        String debugTag = &quot;offset=&quot; + Integer.toString(</span>
<span class="fc" id="L2232">            MiscDebug.getCurrentTimeFormatted());</span>

<span class="fc" id="L2234">        PairIntArray outLeft = new PairIntArray(left.getN());</span>
<span class="fc" id="L2235">        PairIntArray outRight = new PairIntArray(left.getN());</span>
        
<span class="fc" id="L2237">        RANSACEuclideanSolver euclid =</span>
            new RANSACEuclideanSolver();
<span class="fc" id="L2239">        EuclideanTransformationFit fit = euclid.calculateEuclideanTransformation(</span>
            left, right, outLeft, outRight, 5);

<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">        TransformationParameters params = (fit != null) ?</span>
<span class="pc" id="L2243">            fit.getTransformationParameters() : null;</span>

<span class="pc bpc" id="L2245" title="1 of 2 branches missed.">        if (params == null) {</span>
            //TODO: reconsider whether to package up
            // the given sequence s and return it here
<span class="nc" id="L2248">            log.fine(debugTag + &quot; no euclidean fit&quot;);</span>
<span class="nc" id="L2249">            return null;</span>
        }

        // since this class is using equidistant
        // points on shape boundary, need to compare
        // for same scale.
<span class="fc bfc" id="L2255" title="All 4 branches covered.">        if (params.getScale() &lt; 0.9 || params.getScale() &gt; 1.1) {</span>
<span class="fc" id="L2256">            log.fine(&quot;WARNING: &quot; + debugTag +</span>
                &quot; euclidean transformation scale: &quot;  + params);
        }
<span class="fc" id="L2259">        left = outLeft;</span>
<span class="fc" id="L2260">        right = outRight;</span>

<span class="fc" id="L2262">        log.fine(debugTag + &quot; partial fit=&quot; + fit.toString()</span>
            + &quot; params=&quot; + params
<span class="fc" id="L2264">            + &quot; reset left.n=&quot; + left.getN()</span>
<span class="fc" id="L2265">            + &quot; right.n=&quot; + right.getN());</span>

<span class="fc" id="L2267">        log.fine(&quot;dp=&quot; + dp + &quot; pixTol=&quot; + pixTol);</span>

        // ---- apply transformation -----
<span class="fc" id="L2270">        Result result = applyTransformation(params, p, q,</span>
            left, right, leftUnmatched, rightUnmatched, 
            pixTol, outAddedPoints);
        
<span class="fc" id="L2274">        return result;        </span>
    }

     private void print(String label, float[][][] a) {
<span class="nc bnc" id="L2278" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L2279">            print(label + &quot; off &quot; + i, a[i]);</span>
        }
<span class="nc" id="L2281">    }</span>

    private void print(String label, float[][] a) {

<span class="nc" id="L2285">        StringBuilder sb = new StringBuilder(label);</span>
<span class="nc" id="L2286">        sb.append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L2288" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L2289">            sb.append(String.format(&quot;row %3d: &quot;, i));</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">            for (int j = 0; j &lt; a[i].length; ++j) {</span>
<span class="nc" id="L2291">                sb.append(String.format(&quot; %.2f,&quot;, a[i][j]));</span>
            }
<span class="nc" id="L2293">            log.fine(sb.toString());</span>
<span class="nc" id="L2294">            System.out.println(sb.toString());</span>
<span class="nc" id="L2295">            sb.delete(0, sb.length());</span>
        }
<span class="nc" id="L2297">    }</span>
                    
    public float readStoredMatrix(int pIdx, int qIdx) {
        
<span class="nc bnc" id="L2301" title="All 2 branches missed.">        if (storedMatrix == null) {</span>
<span class="nc" id="L2302">            throw new IllegalStateException(</span>
                &quot;need to use overrideToStoreMatrix() before match(...)&quot;);
        }
      
<span class="nc" id="L2306">        SummedColumnTable sct = new SummedColumnTable();</span>
        
<span class="nc" id="L2308">        float[] output = new float[2];</span>
<span class="nc" id="L2309">        int row = 0;</span>
        int idx1, idx2;
        
<span class="nc bnc" id="L2312" title="All 2 branches missed.">        if (pToQ) {</span>
<span class="nc" id="L2313">            idx1 = pIdx/storePDp;</span>
<span class="nc" id="L2314">            idx2 = qIdx/storeQDp;</span>
        } else {
<span class="nc" id="L2316">            idx1 = qIdx/storeQDp;</span>
<span class="nc" id="L2317">            idx2 = pIdx/storePDp;</span>
        }
        
<span class="nc" id="L2320">        int n1 = storedMatrix[0].length;</span>
        
<span class="nc" id="L2322">        int offset = 0;</span>
   
        //NOTE: this is not the same as reading a block w.r.t. the original
        //   offset that was used

<span class="nc bnc" id="L2327" title="All 2 branches missed.">        if (idx2 &gt; (n1 - 1)) {</span>
            // idx2 is outside of the default row 0 of md[0] array, so
            // need to calculate the offset.

            // if within bounds, will add 4 to the offset to get the pixel
            // away from bounds

<span class="nc" id="L2334">            offset = (idx2 - (n1 - 1)) + 4;</span>
<span class="nc" id="L2335">            idx2 -= offset;</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">            if (idx2 &lt; 0) {</span>
<span class="nc" id="L2337">                offset = idx2 - (n1 - 1);</span>
<span class="nc" id="L2338">                idx2 -= offset;</span>
            }
        }

<span class="nc" id="L2342">        sct.extractWindowInColumn(storedMatrix[offset], idx1, idx2, row, </span>
            output);

<span class="nc" id="L2345">        float d = output[0]/output[1];</span>
            
<span class="nc" id="L2347">        return d;</span>
    }
    
    /**
     * calculate the chord difference between point (pX, pY) and point
     * (qX, qY) with respect to the corresponding reference points from
     * their reference frames (where the reference points are matched to
     * one another, respectively in the other frames).
     * NOTE: for more accurate results, should pass in a list of 
     * correspondences in p and q and then calc chord diff of 
     * (pX, pY) and point (qX, qY) with avg or lin regr and outlier removal.
     * @param pXRef1
     * @param pYRef1
     * @param pXRef2
     * @param pYRef2
     * @param pX
     * @param pY
     * @param qXRef1
     * @param qYRef1
     * @param qXRef2
     * @param qYRef2
     * @param qX
     * @param qY
     * @return 
     */
    public float calculateAChordDifference(int pXRef1, int pYRef1,
        int pXRef2, int pYRef2, int pX, int pY,
        int qXRef1, int qYRef1,
        int qXRef2, int qYRef2, int qX, int qY
        ) {
       
<span class="nc" id="L2378">        double angleA1 = LinesAndAngles.calcAngle(</span>
            pXRef1, pYRef1, pX, pY, pXRef2, pYRef2
        );
<span class="nc bnc" id="L2381" title="All 4 branches missed.">        assert(!Double.isNaN(angleA1));</span>
           
<span class="nc" id="L2383">        double angleA2 = LinesAndAngles.calcAngle(</span>
            qXRef1, qYRef1, qX, qY, qXRef2, qYRef2
        );
<span class="nc bnc" id="L2386" title="All 4 branches missed.">        assert(!Double.isNaN(angleA2));</span>
        
<span class="nc" id="L2388">        double v = angleA1 - angleA2;</span>
<span class="nc bnc" id="L2389" title="All 2 branches missed.">        if (v &lt; 0) {</span>
<span class="nc" id="L2390">            v *= -1;</span>
        }
        
<span class="nc" id="L2393">        return (float)v;</span>
    }
    
    public EpipolarTransformationFit getStoredEpipolarFit() {
<span class="nc bnc" id="L2397" title="All 2 branches missed.">        if (this.storedEpipolarFit == null) {</span>
<span class="nc" id="L2398">            throw new IllegalStateException(</span>
                &quot;need to use overrideToStoreMatrix() before match(...) &quot;
                    + &quot; and do not set to use euclidean&quot;);
        }
<span class="nc" id="L2402">        return storedEpipolarFit;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
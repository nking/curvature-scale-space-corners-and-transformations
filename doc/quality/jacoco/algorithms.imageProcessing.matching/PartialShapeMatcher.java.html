<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartialShapeMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.matching</a> &gt; <span class="el_source">PartialShapeMatcher.java</span></div><h1>PartialShapeMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.matching;

import algorithms.compGeometry.LinesAndAngles;
import algorithms.imageProcessing.SummedAreaTable;
import algorithms.misc.MiscMath;
import algorithms.signalProcessing.CurveResampler;
import algorithms.util.CorrespondencePlotter;
import algorithms.util.PairFloatArray;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonAndPointPlotter;

import java.io.IOException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
&lt;pre&gt;
based upon algorithm in paper
 &quot;Efficient Partial Shape Matching
    of Outer Contours: by Donoser
  
     - called IS-Match, integral shape match
     - finds the best matching segments between 2 closed curves.
     - NOTE: to find the for a query and multiple targets, use the
       ...editing here to consider vector embedding approaches...
     - a silhouette of ordered points are sampled
         making it an &quot;order preserved assignment problem&quot;.
       - a chord angle descriptor is local and global and
         is invariant to similarity transformations.
       - the method returns partial sub matches
         so works with articulated data and occluded shapes
       - uses an efficient integral image based matching algorithm
       - the multi-objective optimization uses principles of
         Paretto efficiency, defined with the fraction of the
         total matched and the summed differences of angles.
       - the final result returned is the sequences and
         the total fraction matched and summed absolute differences,
         using the Salukwadze distance of a Paretto frontier.

       * point sampling:
         For best results, the curves should have at least 30 points.
         (a) same number of points over each contour
             - can handle similarity transforms.
               disadvantage is that it is less able to
               handle occlusion or extraneous shapes in
               the shape.
               using the euclidean option works around this.
             - 
               to use in this mode:
                   setToUseSameNumberOfPoints()
                      and the number of points can be set 
                      using dp, with nSample = min(p.n, q.n)/dp
                      and
                   overrideSamplingDistance(dp)
               and optionally:
                   setToUseEuclidean()
         (b) OR, equidistant points (default)
             - can handle occlusion.
               disadvantage in matching when there are
               scale differences between the shapes is
               handled in part by an internal euclidean
               projection.
             - the default sampling of pixels is 3.
               this can be changed using
                   overrideSamplingDistance(dp)
               unit test using dp of 1 and 2 work well

       The runtime complexity for building the integral
       image is O(n*m*n) where m and n are the number of sampled
       points on the reduced input shapes.  The reduced size is the size after any transformations like
       resampling.

       The runtime complexity for the search depends upon the search choice:
          FAST: r.t.c. O(M*N*log(topK)).  this is the default.
          ALL_BLOCK_SIZES: r.t.c. O(M*N*DR * log(topK)).
          EXHAUSTIVE: the largest r.t.c. is exponential from recursively assembling all full curve matches
              composed of different block sizes and different number of gaps.  for 1 GB RAM max heap,
              one should use this only if number of points in the curve is around 20 or less.  If you have
              more RAM, use jvm args to set heap size min and max higher and then you'll have a higher point
              limit.  This is interesting for identifying the best complete partial matches of the two curves.

       &lt;emph&gt;The runtime complexity for the search of the
       integral image of summed differences and analysis,
       is n2 * (O(n1 * lg2(n1))&lt;/emph&gt; where n1 and n2 are the number of points
       in the 2 shapes after the spacing has been considered.
       
       The algorithm runtime complexity could be reduced more, but with
       more loss in accuracy by selecting a discrete number of diagonal read 
       block sizes.
       For instance, if wanted to read only a single block size of
       n1/10, the total runtime complexity would be approx n2 * n1/10.
       (and in this case, could build the summed difference chord matrix
       smaller and more quickly than O(n2 * n1 * n1) before that.
       Essentially, would use summed column table and the rows would
       only be offsets of n1/10 so the total runtime complexity for building
       would be O(n1*(n1/10)) and reads would be smaller...it's effectively
       the result of comparing the 2 curves at offets of n1/10 intervals which
       would give fast but very rough results that would not handle articultion 
       well if at all.)
 &lt;/pre&gt;
 
 &lt;em&gt;NOTE: You may need to pre-process the shape points
     for example, smooth the boundary.&lt;/em&gt;
 &lt;pre&gt;
     This method:  
        PairIntArray p = imageProcessor
            .extractSmoothedOrderedBoundary()
        uses a Gaussian smoothing of 1 sigma,
  &lt;/pre&gt;
  @author nichole
 */
<span class="fc" id="L113">public class PartialShapeMatcher {</span>

    public static final float TWO_PI = (float)(2.*Math.PI);

    // the range of difference from TWO_PI for which an angle will be considered 0.
    public static final float ZERO_TOL = 0.00001f;

    /**
     * in sampling the boundaries of the shapes, one can
     * choose to use the same number for each (which can result
     * in very different spacings for different sized curves)
     * or one can choose a set distance between sampling
     * points.
     * dp is the set distance between sampling points.
       The authors of the paper use 3 as an example.

     The use of dp in this code is not well tested and could be improved.
    */
<span class="fc" id="L131">    protected int dp = 1;</span>

<span class="fc" id="L133">    private boolean useSameNumberOfPoints = false;</span>

    // 10 degrees is 0.1745 radians
    // for a fit to a line, consider 1E-9
<span class="fc" id="L137">    private float thresh = 1.f;//(float)(Math.PI/180.) * 10.f;</span>

<span class="fc" id="L139">    private boolean overrideMinLength = false;</span>
<span class="fc" id="L140">    private final int DEFAULT_MIN_LENGTH = 7;</span>
<span class="fc" id="L141">    private int minLength = 7;</span>

<span class="fc" id="L143">    private int topK = 1;</span>

    /**
     * FAST: r.t.c. O(M*N*log(topK)).  this is the default.
     * ALL_BLOCK_SIZES: O(M*N*DR*log(topK))
     * EXHAUSTIVE: the largest r.t.c. from recursively assembling all full curve matches
     * composed of different block sizes and different number of gaps.  for 1 GB RAM max heap,
     * one should use this only if number of points in the curve is around 20 or less.  If you have
     * more RAM, use jvm args to set heap size min and max higher and then you'll have a higher point
     * limit.
     */
    private static enum SEARCH {
        FAST, ALL_BLOCK_SIZES,
        EXHAUSTIVE
    }
<span class="fc" id="L158">    private SEARCH search = SEARCH.FAST;</span>

<span class="fc" id="L160">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L162">    private boolean debug = false;</span>

    /**
     * override the threshold for using a chord difference value
     * for the average value.   
     * By default the threshhold is set to 1.
     * @param t  threshhold to use
     */
    public void _overrideToThreshhold(float t) {
<span class="fc" id="L171">        this.thresh = t;</span>
<span class="fc" id="L172">    }</span>
    
    /**
     * override the default minimum length of 7.
     * @param length minimum length to use in matching blocks
     */
    public void overrideMinimumLength(int length) {
<span class="nc" id="L179">        this.minLength = length;</span>
<span class="nc" id="L180">        this.overrideMinLength = true;</span>
<span class="nc" id="L181">    }</span>
    
    /**
    if this is set, the same number of points
    are used to sample both shapes.
    The number of points is min(p.n, q.n)/dp.
    You can change dp from the default of
    3 by using the method overrideSamplingDistance(dp).
    */
    public void setToUseSameNumberOfPoints() {
<span class="fc" id="L191">        useSameNumberOfPoints = true;</span>
<span class="fc" id="L192">    }</span>

    /**
     * the default sampling distance is 1.  use this method to override it.
     * @param d set the sampling distance between points to use for curves.
     */
    public void overrideSamplingDistance(int d) {
<span class="fc" id="L199">        this.dp = d;</span>
<span class="fc" id="L200">    }</span>

    /**
     * change from the default fast search of r.t.c. O(M*N) to an ALL_BLOCK_SIZES search
     * with r.t.c. roughly  O(M*N*R*DR) where the block size R spans from the minimumLength (default 7) to
     * the maximum length N and uses a delta R that is log(N).
     */
    public void overrideToSearchAllBlockSizes(){
<span class="nc" id="L208">        this.search = SEARCH.ALL_BLOCK_SIZES;</span>
<span class="nc" id="L209">    }</span>

    /**
     * change from the default fast search of r.t.c. O(M*N) to an exhaustive search which has
     * the largest r.t.c. from recursively assembling all full curve matches
     * composed of different block sizes and different number of gaps.  for 1 GB RAM max heap,
     * one should use this only if number of points in the curve is around 20 or less.  If you have
     * more RAM, use jvm args to increase heap size min and max higher and then you'll have a higher point
     * limit than 20.
     */
    public void overrideToSearchExhaustive(){
<span class="nc" id="L220">        this.search = SEARCH.EXHAUSTIVE;</span>
<span class="nc" id="L221">    }</span>

    /**
     * return topK results.  By default topK is 1.
     * @param k the number of results to return
     */
    public void overrideTopK(int k) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (k &lt; 0) {</span>
<span class="nc" id="L229">            throw new IllegalArgumentException(&quot;k must be &gt;= 1&quot;);</span>
        }
<span class="nc" id="L231">        topK = k;</span>
<span class="nc" id="L232">    }</span>

    /**
     * use this to enable the debug log comments and plots
     */
    public void setToDebug() {
<span class="nc" id="L238">        debug = true;</span>
<span class="nc" id="L239">        log.setLevel(Level.FINE);</span>
<span class="nc" id="L240">    }</span>

    /**
      A shape is defined as the clockwise ordered sequence
      of points P_1...P_N
      and the shape to match has points Q_1...Q_N.
      The spacings used within this method are equidistant
      unless changed using method setToUseSameNumberOfPoints().
      The default spacing is 3, 
      so override that if a different number
      is needed.
      
     &lt;em&gt;NOTE: You may need to pre-process the shape points
     for example, smooth the boundary.&lt;/em&gt;
     &lt;pre&gt;
     This method:  
        PairIntArray p = imageProcessor
            .extractSmoothedOrderedBoundary()
        uses a Gaussian smoothing of 2 sigma,
        but a smaller sigma can be specified.
      &lt;/pre&gt;
     temporarily using exhaustive search.
     @param p a closed curve to match to q.  note that the format expects that start == stop point.
     @param q a closed curve to match to p.  Note that the format expects that start == stop point.
     @return the matched intervals.
    */
    public List&lt;Match.Points&gt; match(PairFloatArray p, PairFloatArray q) throws Exception {

        // p and q now require first point == last point in order for the curve resampling to succeed.
        // the descriptors, however, exclude the last point when it equals the first point,
        // so are 1 shorter than curve length in both dimensions

<span class="fc" id="L272">        log.info(&quot;p.n=&quot; + p.getN() + &quot; q.n=&quot; + q.getN()</span>
            + &quot; useSameNumberOfPoints=&quot; + useSameNumberOfPoints
            + &quot; dp=&quot; + dp);

<span class="pc bpc" id="L276" title="2 of 4 branches missed.">        if (p.getN() &lt; 2 || q.getN() &lt; 2) {</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;p and q must &quot;</span>
            + &quot; have at least dp*2 points = &quot; + (dp * 2));
        }
        
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">        if ((p.getN()/dp) &lt; 30 || (q.getN()/dp) &lt; 30) {</span>
<span class="fc" id="L282">            log.warning(&quot;WARNING: consider overriding dp to set it to 1 because these are small curves&quot;);</span>
        }

<span class="fc" id="L285">        final int n1 = p.getN();</span>
<span class="fc" id="L286">        final int n2 = q.getN();</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">        boolean interchange = n2 &lt; n1;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (interchange) {</span>
<span class="fc" id="L290">            PairFloatArray tmp = p;</span>
<span class="fc" id="L291">            p = q;</span>
<span class="fc" id="L292">            q = p;</span>
        }

        //p.n &lt;= q.n

        // resample if needed:
<span class="fc" id="L298">        PairFloatArray p2 = null;</span>

<span class="pc bpc" id="L300" title="1 of 4 branches missed.">        if (useSameNumberOfPoints &amp;&amp; n1 != n2) {</span>
<span class="fc" id="L301">            float[][] pxy = new float[2][p.getN()];</span>
<span class="fc" id="L302">            pxy[0] = Arrays.copyOf(p.getX(), p.getN());</span>
<span class="fc" id="L303">            pxy[1] = Arrays.copyOf(p.getY(), p.getN());</span>
<span class="fc" id="L304">            float[][] xyOut = CurveResampler.resample(pxy, n2);</span>
<span class="fc" id="L305">            p2 = new PairFloatArray();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            for (int i = 0; i &lt; xyOut[0].length; ++i) {</span>
<span class="fc" id="L307">                p2.add(xyOut[0][i], xyOut[1][i]);</span>
            }
        }

<span class="fc" id="L311">        PairFloatArray pSub = null;</span>
<span class="fc" id="L312">        PairFloatArray qSub = null;</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (dp &gt; 1) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            PairFloatArray tmpP = (p2 != null) ?  p2 : p;</span>
<span class="nc" id="L315">            pSub = new PairFloatArray(tmpP.getN()/dp);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            for (int i = 0; i &lt; tmpP.getN(); i += dp) {</span>
<span class="nc" id="L317">                pSub.add(tmpP.getX(i), tmpP.getY(i));</span>
            }
<span class="nc" id="L319">            qSub = new PairFloatArray(q.getN()/dp);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            for (int i = 0; i &lt; q.getN(); i += dp) {</span>
<span class="nc" id="L321">                qSub.add(q.getX(i), q.getY(i));</span>
            }
<span class="nc" id="L323">        } else {</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">            pSub = (p2 != null) ?  p2 : p;</span>
<span class="fc" id="L325">            qSub = q;</span>
        }

<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (!overrideMinLength) {</span>
<span class="fc" id="L329">            this.minLength = Math.max(DEFAULT_MIN_LENGTH, (int)Math.round(0.1*Math.max(pSub.getN(), qSub.getN())));</span>
        }

<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L333">            long ts = System.nanoTime();</span>
<span class="nc" id="L334">            log.info(String.format(&quot;ts=%d, pSub.n=%d, qSub.n=%d, minLength=%d\n&quot;, ts, pSub.getN(), qSub.getN(), minLength));</span>
<span class="nc" id="L335">            plot(pSub, &quot;p_&quot;+ts);</span>
<span class="nc" id="L336">            plot(qSub, &quot;q_&quot;+ts);</span>
        }

<span class="fc" id="L339">        List&lt;Match.Points&gt; pointsList = match0(pSub, qSub);</span>

<span class="pc bpc" id="L341" title="3 of 4 branches missed.">        if (debug &amp;&amp; !pointsList.isEmpty()) {</span>
<span class="nc" id="L342">            long ts = System.nanoTime();</span>
<span class="nc" id="L343">            plotResults(pointsList, pSub, qSub, 4, ts + &quot;_corres_&quot;, false);</span>
        }

        // transform results back into original reference frames p and q

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (dp &gt; 1) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            for (Match.Points points : pointsList) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                for (int i = 0; i &lt; points.pIdxs.length; ++i) {</span>
<span class="nc" id="L351">                    points.pIdxs[i] = Math.round(points.pIdxs[i]/(float)dp);</span>
<span class="nc" id="L352">                    points.qIdxs[i] = Math.round(points.qIdxs[i]/(float)dp);</span>
                }
<span class="nc" id="L354">            }</span>
        }

<span class="pc bpc" id="L357" title="1 of 4 branches missed.">        if (useSameNumberOfPoints &amp;&amp; n1 != n2) {</span>
            // multiply by n1 and divide by n2
<span class="fc" id="L359">            float factor = (n1 - 1.f)/(n2 - 1.f);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (interchange) {</span>
<span class="fc" id="L361">                factor = 1.f/factor;</span>
            }
<span class="fc bfc" id="L363" title="All 2 branches covered.">            for (int i = 0; i &lt; pointsList.size(); ++i) {</span>
<span class="fc" id="L364">                Match.Points points = pointsList.get(i);</span>
                //pIdxs are w.r.t. p2 reference frame
<span class="fc bfc" id="L366" title="All 2 branches covered.">                for (int j = 0; j &lt; points.pIdxs.length; ++j) {</span>
<span class="fc" id="L367">                    int idx = Math.round(points.pIdxs[j]*factor);</span>
                    //TODO: this could be improved
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">                    if (!interchange &amp;&amp; idx &gt;= n1){</span>
<span class="nc" id="L370">                        idx = n1 - 1;</span>
<span class="pc bpc" id="L371" title="1 of 4 branches missed.">                    } else if (interchange &amp;&amp; idx &gt;= n2){</span>
<span class="nc" id="L372">                        idx = n2 - 1;</span>
                    }
<span class="fc" id="L374">                    points.pIdxs[j] = idx;</span>
                }
            }
        }

        // if there is a sequential mapping of same point in p, drop all but the first.
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (int i = 0; i &lt; pointsList.size(); ++i) {</span>
<span class="fc" id="L381">            Match.Points points = pointsList.get(i);</span>
<span class="fc" id="L382">            int prev = points.pIdxs[0];</span>
<span class="fc" id="L383">            int idx = 1;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            for (int j = 1; j &lt; points.pIdxs.length; ++j) {</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                if (points.pIdxs[j] != prev) {</span>
<span class="fc" id="L386">                    points.pIdxs[idx] = points.pIdxs[j];</span>
<span class="fc" id="L387">                    points.qIdxs[idx] = points.qIdxs[j];</span>
<span class="fc" id="L388">                    ++idx;</span>
                }
<span class="fc" id="L390">                prev = points.pIdxs[j];</span>
            }
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (idx &lt; points.pIdxs.length) {</span>
<span class="fc" id="L393">                points.pIdxs = Arrays.copyOf(points.pIdxs, idx);</span>
<span class="fc" id="L394">                points.qIdxs = Arrays.copyOf(points.qIdxs, idx);</span>
            }
        }

<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (interchange) {</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">            for (int i = 0; i &lt; pointsList.size(); ++i) {</span>
<span class="fc" id="L400">                Match.Points points = pointsList.get(i);</span>
                //pIdxs are w.r.t. p2 reference frame
<span class="fc" id="L402">                int[] tmp = points.pIdxs;</span>
<span class="fc" id="L403">                points.pIdxs = points.qIdxs;</span>
<span class="fc" id="L404">                points.qIdxs = tmp;</span>
            }
        }

<span class="fc" id="L408">        return pointsList;</span>
    }

    private List&lt;Match.Points&gt; match0(PairFloatArray p, PairFloatArray q) throws Exception {

<span class="pc bpc" id="L413" title="2 of 4 branches missed.">        if (p == null || p.getN() &lt; 2) {</span>
<span class="nc" id="L414">            throw new IllegalArgumentException(&quot;p must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="pc bpc" id="L418" title="2 of 4 branches missed.">        if (q == null || q.getN() &lt; 2) {</span>
<span class="nc" id="L419">            throw new IllegalArgumentException(&quot;q must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
        // --- make difference matrices ---
        //md[0:n2-1][0:n1-1][0:n1-1]
<span class="pc bnc" id="L425" title="All 2 branches missed.">        assert(p.getN() &lt;= q.getN());</span>
<span class="fc" id="L426">        float[][][] md = createDifferenceMatrices(p, q);</span>
<span class="fc" id="L427">        applySummedAreaTableConversion(md);</span>
<span class="fc" id="L428">        List&lt;Match.Points&gt; points = match0(md, p, q);</span>

<span class="fc" id="L430">        return points;</span>
    }

    private List&lt;Match.Points&gt; match0(float[][][] md, PairFloatArray p, PairFloatArray q) throws Exception {

<span class="pc bpc" id="L435" title="2 of 4 branches missed.">        if (p == null || p.getN() &lt; 2) {</span>
<span class="nc" id="L436">            throw new IllegalArgumentException(&quot;p must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="pc bpc" id="L440" title="2 of 4 branches missed.">        if (q == null || q.getN() &lt; 2) {</span>
<span class="nc" id="L441">            throw new IllegalArgumentException(&quot;q must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }
        
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (p.getN() &gt; q.getN()) {</span>
<span class="nc" id="L446">            throw new IllegalArgumentException(</span>
            &quot;q.n must be &gt;= p.n&quot;);
        }
        
<span class="fc" id="L450">        int n1 = p.getN();</span>
<span class="fc" id="L451">        int n2 = q.getN();</span>

        /*
        This method will return results for a local
        solution to create the point correspondence list.

        Note that the local best could be two different
        kinds of models, so might write two
        different methods for the results.
        (1) the assumption of same object but with some
            amount of occlusion and maybe additional
            shapes present due to segmentation not being
            able to isolate the object completely.
        (2) the assumption of same object but with
           some parts being differently oriented, for
           an example, the scissors opened versus closed in unit tests.
           The occlusion should be handled for this one too.

        For the multi-objective optimization cost,
        need the sum of differences of chords and the fraction
        of the whole to calculate the Salukwdze distance 
        of the Paretto frontier.
        */
<span class="fc" id="L474">        List&lt;Match&gt; matches = findMinima(md, n1, n2);</span>

<span class="fc" id="L476">        List&lt;Match.Points&gt; points = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (Match m : matches) {</span>
<span class="fc" id="L478">            points.add(new Match.Points(m));</span>
<span class="fc" id="L479">        }</span>

<span class="fc" id="L481">        return points;</span>
    }

    /**
     *
     * @param md the M X N X N integral sum of chord differences following the paper.
     * @param n1 the number of points in closed curve 1
     * @param n2 the number of points in closed curve 2
     * @return the best matching of curve 1 to curve 2 for each offset chord diff image.
     * The offset diff images are md[offset].  Note that the variable maxChordSum has been updated in each.
     * @throws Exception
     */
    private List&lt;Match&gt; findMinima(float[][][] md, int n1, int n2) throws Exception {

        //q.n is &gt;= p.n, that is n2 &gt;= n1
        
        //md[0:n2-1][0:n1-1][0:n1-1]

<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (n2 &lt; n1) {</span>
<span class="nc" id="L500">            throw new IllegalArgumentException(&quot;n2 must be &gt;= n1&quot;);</span>
        }        
        
        // reading over a range of window sizes to keep the 
        // sum/nPix below thresh and keeping the mincost solutions.

        // find the intervals of contiguous minima and assign 
        // curve indexes to the largest segments.
        // (note that the objective formula for the cost
        // is the Salukwzde distance).

        /*
            MXM              NXN
                         30 31 32 33
         20 21 22        20 21 22 23
         10 11 12        10 11 12 13
         00 01 02        00 01 02 03   p_i_j - q_i_j

                         01 02 03 00
         20 21 22        31 32 33 30
         10 11 12        21 22 23 20
         00 01 02        11 12 13 10  p_i_j - q_(i+1)_(j+1)

                         12 13 10 11
         20 21 22        02 03 00 01
         10 11 12        32 33 30 31
         00 01 02        22 23 20 21  p_i_j - q_(i+2)_(j+2)

                         23 20 21 22
         20 21 22        13 10 11 12
         10 11 12        03 00 01 02
         00 01 02        33 30 31 32  p_i_j - q_(i+3)_(j+3)
        
        md[0:n2-1][0:n1-1][0:n1-1]
        */

<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (search.equals(SEARCH.FAST)) {</span>
<span class="fc" id="L537">            return fastMinimaSearch(md);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        } else if (search.equals(SEARCH.ALL_BLOCK_SIZES)) {</span>
<span class="nc" id="L539">            return allBlockSizesMinimaSearch(md, n1, n2);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        } else if (search.equals(SEARCH.EXHAUSTIVE)) {</span>
<span class="nc" id="L541">            return exhaustiveMinimaSearch(md, n1, n2);</span>
        } else {
<span class="nc" id="L543">            throw new IllegalStateException(String.format(&quot;%s not implemented\n&quot;, search));</span>
        }
    }

    /**
     * find the closest matches using a linear block search.
     * the r.t.c. for the search is O(N*M) and the sort is O(M*N*log(topK))
     * so the total r.t.c. is O(M*N*log(topK)).
     * @param md
     * @return the topK best matches
     * @throws Exception
     */
    private List&lt;Match&gt; fastMinimaSearch(float[][][] md) throws Exception {

<span class="fc" id="L557">        List&lt;Match&gt; candidates = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L559">        int M = md.length;</span>
<span class="fc" id="L560">        int N = md[0].length;</span>

<span class="fc" id="L562">        SummedAreaTable st = new SummedAreaTable();</span>
<span class="fc" id="L563">        float[] outC = new float[2];</span>
        float weight;

        Match curM;
<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (int offset = 0; offset &lt; M; ++offset) {</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">            for (int iDiag = 0; iDiag &lt; N; ++iDiag) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                if (N - iDiag &lt; minLength) {</span>
<span class="fc" id="L570">                    break;</span>
                }
<span class="fc" id="L572">                st.extractWindowFromSummedAreaTable(md[offset], iDiag, N - 1, iDiag, N - 1, outC);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                if (outC[1] &lt; 1) {</span>
<span class="nc" id="L574">                    continue;</span>
                }
<span class="fc" id="L576">                weight = outC[0] / outC[1];</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">                if (weight &gt; thresh) {</span>
<span class="fc" id="L578">                    continue;</span>
                }
<span class="fc" id="L580">                curM = new Match(N);</span>
<span class="fc" id="L581">                curM.add(iDiag, offset, N - iDiag, weight, 0);</span>
<span class="fc" id="L582">                candidates.add(curM);</span>
            }
        }

<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (candidates.isEmpty()) {</span>
<span class="nc" id="L587">            return candidates;</span>
        }

        // set maxChordSum in all
<span class="fc" id="L591">        double maxChordSum = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">        for (Match m : candidates) {</span>
<span class="fc" id="L593">            maxChordSum = Math.max(maxChordSum, m.diffChordSum);</span>
<span class="fc" id="L594">        }</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        for (Match m : candidates) {</span>
<span class="fc" id="L596">            m.maxChordSum = maxChordSum;</span>
<span class="fc" id="L597">        }</span>

        // heap w/ restricted size to reduce comparisons to M*N*log(topK)
<span class="fc" id="L600">        TreeSet&lt;Match&gt; tree = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (Match m : candidates){</span>
<span class="fc" id="L602">            tree.add(m);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">            if (tree.size() &gt; topK) {</span>
<span class="fc" id="L604">                tree.pollLast();</span>
            }
<span class="fc" id="L606">        }</span>
<span class="fc" id="L607">        candidates = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">        for (Match m : tree) {</span>
<span class="fc" id="L609">            candidates.add(m);</span>
<span class="fc" id="L610">        }</span>

<span class="fc" id="L612">        return candidates;</span>
    }

    private List&lt;Match&gt; allBlockSizesMinimaSearch(float[][][] md, int n1, int n2) throws Exception {
<span class="nc" id="L616">        List&lt;Match&gt; candidates = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L618">        int M = md.length;</span>
<span class="nc" id="L619">        int N = md[0].length;</span>

<span class="nc" id="L621">        SummedAreaTable st = new SummedAreaTable();</span>
<span class="nc" id="L622">        float[] outC = new float[2];</span>
        float weight;

        // block sizes from minLength to N.
        // dR is the number of block sizes.  setting that to log(n).  consider fewer.
<span class="nc" id="L627">        int nIntervals = Math.max(1, (int)(Math.log(N)/Math.log(2)));</span>
<span class="nc" id="L628">        int dR = Math.max(1, (N - minLength)/nIntervals);</span>
<span class="nc" id="L629">        System.out.printf(&quot;df = %d\n&quot;, dR);</span>

        Match curM;
<span class="nc bnc" id="L632" title="All 2 branches missed.">        for (int offset = 0; offset &lt; M; ++offset) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            for (int iDiag = 0; iDiag &lt; N; ++iDiag) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                for (int r = minLength; r &lt; N; r += dR) {</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                    if (iDiag + r - 1 &gt;= N) {</span>
<span class="nc" id="L636">                        break;</span>
                    }
<span class="nc" id="L638">                    st.extractWindowFromSummedAreaTable(md[offset], iDiag, iDiag + r - 1, iDiag, iDiag + r - 1, outC);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                    if (outC[1] &lt; 1) {</span>
<span class="nc" id="L640">                        continue;</span>
                    }
<span class="nc" id="L642">                    weight = outC[0] / outC[1];</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                    if (weight &gt; thresh) {</span>
<span class="nc" id="L644">                        continue;</span>
                    }
<span class="nc" id="L646">                    curM = new Match(N);</span>
<span class="nc" id="L647">                    curM.add(iDiag, offset, r, weight, 0);</span>
<span class="nc" id="L648">                    candidates.add(curM);</span>
                }
            }
        }

<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (candidates.isEmpty()) {</span>
<span class="nc" id="L654">            return candidates;</span>
        }

        // set maxChordSum in all
<span class="nc" id="L658">        double maxChordSum = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">        for (Match m : candidates) {</span>
<span class="nc" id="L660">            maxChordSum = Math.max(maxChordSum, m.diffChordSum);</span>
<span class="nc" id="L661">        }</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (Match m : candidates) {</span>
<span class="nc" id="L663">            m.maxChordSum = maxChordSum;</span>
<span class="nc" id="L664">        }</span>

<span class="nc" id="L666">        TreeSet&lt;Match&gt; tree = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">        for (Match m : candidates){</span>
<span class="nc" id="L668">            tree.add(m);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (tree.size() &gt; topK) {</span>
<span class="nc" id="L670">                tree.pollLast();</span>
            }
<span class="nc" id="L672">        }</span>
<span class="nc" id="L673">        candidates = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">        for (Match m : tree) {</span>
<span class="nc" id="L675">            candidates.add(m);</span>
<span class="nc" id="L676">        }</span>

<span class="nc" id="L678">        return candidates;</span>
    }

    private List&lt;Match&gt; exhaustiveMinimaSearch(float[][][] md, int n1, int n2) throws Exception {

        // starting another approach.
        // for each position on A1 diagonal i,
        //    make combinations of blocks with same position on next offset images
        //    etc, sequentially matching or skipping and moving onto next offset image.
        // a recursion can fill all of these combinations.
        // then can use salukwdze comparator to find best among them.
<span class="nc" id="L689">        int N = md[0].length;</span>
<span class="nc" id="L690">        double nIntervals = Math.log(N)/Math.log(2);</span>
<span class="nc" id="L691">        nIntervals = 1;</span>
<span class="nc" id="L692">        int dR = (int)Math.ceil((float)(N - minLength)/nIntervals);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (dR == 0) {</span>
<span class="nc" id="L694">            dR = 1;</span>
        }

<span class="nc" id="L697">        int rUpper = N;</span>
<span class="nc" id="L698">        int nR = ((N - minLength)/dR) + 1;</span>
<span class="nc" id="L699">        List&lt;Match&gt; candidates = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L701">        System.out.printf(&quot;\nnR=%d, dR=%d\n&quot;, nR, dR);</span>

        // n*m* log(n)
<span class="nc" id="L704">        recursion(md, 0, rUpper, minLength, dR, candidates, new Match(N),</span>
                new SummedAreaTable(), new float[2], 0);

<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L708">            Set&lt;Match&gt; unique = new HashSet&lt;&gt;(candidates);</span>
<span class="nc" id="L709">            System.out.printf(&quot;n=%d, nR=%d, nCandidates=%d, nUnique=%d\n&quot;, N, nR, candidates.size(), unique.size());</span>
        }

<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (candidates.isEmpty()) {</span>
<span class="nc" id="L713">            return candidates;</span>
        }

        // set maxChordSum in all
<span class="nc" id="L717">        double maxChordSum = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        for (Match m : candidates) {</span>
<span class="nc" id="L719">            maxChordSum = Math.max(maxChordSum, m.diffChordSum);</span>
<span class="nc" id="L720">        }</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">        for (Match m : candidates) {</span>
<span class="nc" id="L722">            m.maxChordSum = maxChordSum;</span>
<span class="nc" id="L723">        }</span>

<span class="nc" id="L725">        TreeSet&lt;Match&gt; tree = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        for (Match m : candidates){</span>
<span class="nc" id="L727">            tree.add(m);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (tree.size() &gt; topK) {</span>
<span class="nc" id="L729">                tree.pollLast();</span>
            }
<span class="nc" id="L731">        }</span>
<span class="nc" id="L732">        candidates = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        for (Match m : tree) {</span>
<span class="nc" id="L734">            candidates.add(m);</span>
<span class="nc" id="L735">        }</span>

<span class="nc" id="L737">        return candidates;</span>
    }

    private void recursion(float[][][] md, int iDiag, int r, final int rMin, final int dR, List&lt;Match&gt; out,
        Match curM, final SummedAreaTable st, final float[] outC, int rangeNum) {

<span class="nc" id="L743">        int n = md[0].length;</span>
        // base case:  end of the diagonal.
        // store current match
        // reduce block size and start from top of diagonal again
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (iDiag + r &gt; n) {</span>
            // end state.  store copy, and reset state if possible
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (curM.mLen &gt; 0) {</span>
<span class="nc" id="L750">                out.add(curM.copy());</span>
            }
<span class="nc" id="L752">            r -= dR;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (r &lt; rMin) {</span>
<span class="nc" id="L754">                return;</span>
            }
<span class="nc" id="L756">            iDiag = 0;</span>
<span class="nc" id="L757">            curM = new Match(curM.N);</span>
<span class="nc" id="L758">            rangeNum = 0;</span>
        }

        // uses implicit backtracking to save memory

        // skip i.
        // there will be more than one curM that ends as all skipped
<span class="nc" id="L765">        recursion(md, iDiag + 1, r, rMin, dR, out, curM, st, outC, rangeNum);</span>

        float weight;
<span class="nc bnc" id="L768" title="All 2 branches missed.">        for (int offset = 0; offset &lt; md.length; ++offset) {</span>
<span class="nc" id="L769">            st.extractWindowFromSummedAreaTable(md[offset], iDiag, iDiag + r-1, iDiag, iDiag + r-1, outC);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (outC[1] &lt; 1) {</span>
<span class="nc" id="L771">                continue;</span>
            }
<span class="nc" id="L773">            weight = outC[0]/outC[1];</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">            if (weight &gt; thresh) {</span>
<span class="nc" id="L775">                continue;</span>
            }
            //consider that we should not go to the next point on the diagonal which is iDiag+r because
            //    it being adjacent means that a larger block starting at higher index should have covered
            //        this case.  in other words, by skipping 1, we avoid adjacent blocks on the diagonal
            //        that were already covered by previous larger block match.
<span class="nc" id="L781">            curM.add(iDiag, offset, r, weight, rangeNum);</span>
<span class="nc" id="L782">            recursion(md, iDiag + r + 1, r, rMin, dR, out, curM, st, outC, rangeNum + 1);</span>
        }
<span class="nc" id="L784">    }</span>

    /**
     * create the matrices of differences between p
     * and q.  Note that the matrix differences are
     * absolute differences.
     * index0 is rotations of q,  index1 is p.n, index2 is q.n
      returns a[0:q.n-1][0:p.n-1][0:p.n-1]
    */
    protected float[][][] createDifferenceMatrices(PairFloatArray p, PairFloatArray q) {

<span class="pc bpc" id="L795" title="1 of 2 branches missed.">        if (p.getN() &gt; q.getN()) {</span>
<span class="nc" id="L796">            throw new IllegalArgumentException(</span>
            &quot;q.n must be &gt;= p.n&quot;);
        }

        /*
        | a_1_1...a_1_N |
        | a_2_1...a_2_N |
               ...
        | a_N_1...a_N_N |
           elements on the diagonal are zero

           to shift to different first point as reference,
           can shift down k-1 rows and left k-1 columns.
        */

        //log.fine(&quot;a1:&quot;);
<span class="fc" id="L812">        float[][] a1 = createDescriptorMatrix(p);</span>

        //log.fine(&quot;a2:&quot;);
<span class="fc" id="L815">        float[][] a2 = createDescriptorMatrix(q);</span>

        /*
         make difference matrices.
            there will be N A_2 matrices in which each
            is shifted left and up by 1 (or some other value).

            M_D^n = A_1(1:M,1:M) - A_2(n:n+M-1,n:n+M-1)
                shifting A_2 by 0 through N covering all
                orientation angles.
        */

        /*
            MXM              NXN
                         30 31 32 33
         20 21 22        20 21 22 23
         10 11 12        10 11 12 13
         00 01 02        00 01 02 03   p_i_j - q_i_j

                         01 02 03 00
         20 21 22        31 32 33 30
         10 11 12        21 22 23 20
         00 01 02        11 12 13 10  p_i_j - q_(i+1)_(j+1)

                         12 13 10 11
         20 21 22        02 03 00 01
         10 11 12        32 33 30 31
         00 01 02        22 23 20 21  p_i_j - q_(i+2)_(j+2)

                         23 20 21 22
         20 21 22        13 10 11 12
         10 11 12        03 00 01 02
         00 01 02        33 30 31 32  p_i_j - q_(i+3)_(j+3)
        */
        
        //TODO: look into Toeplitz matrix and cyclic matrix

        // --- make difference matrices ---
<span class="fc" id="L853">        int n1 = a1.length;</span>
<span class="fc" id="L854">        int n2 = a2.length;</span>
<span class="fc" id="L855">        float[][][] md = new float[n2][][];</span>
<span class="fc" id="L856">        float[][] prevA2Shifted = null;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">        for (int i = 0; i &lt; n2; ++i) {</span>
            float[][] shifted2;
<span class="fc bfc" id="L859" title="All 2 branches covered.">            if (prevA2Shifted == null) {</span>
<span class="fc" id="L860">                shifted2 = copy(a2);</span>
            } else {
                // shifts by 1 to left and up by 1
<span class="fc" id="L863">                rotate(prevA2Shifted);</span>
<span class="fc" id="L864">                shifted2 = prevA2Shifted;</span>
            }
            // NOTE: absolute values are stored.
            //M_D^n = A_1(1:M,1:M) - A_2(n:n+M-1,n:n+M-1)
<span class="fc" id="L868">            md[i] = subtract(a1, shifted2);</span>
<span class="pc bnc" id="L869" title="All 2 branches missed.">            assert(md[i].length == n1);</span>
<span class="pc bnc" id="L870" title="All 2 branches missed.">            assert(md[i][0].length == n1);</span>
<span class="fc" id="L871">            prevA2Shifted = shifted2;</span>
        }
       
        //print(&quot;differences:&quot;, md);

<span class="fc" id="L876">        return md;</span>
    }

    /**
     given the shape points for p and q,
     create a matrix of descriptors, describing the difference
     in chord angles.

     The chord descriptor is invariant to translation, rotation,
     and scale:
       - a chord is a line joining 2 region points
       - uses the relative orientation between 2 chords
         angle a_i_j is from chord P_i_P_j to reference
         point P_i
         to another sampled point and chord P_j_P_(j-d) and P_j

         d is the number of points before j in the sequence of points P.

         a_i_j is the angle between the 2 chords P_i_P_j and P_j_P_(j-d)

     r.t.c. is O(n^2)
    */
    public static float[][] createDescriptorMatrix(PairFloatArray p) {

<span class="fc" id="L900">        int n = p.getN();</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        if (Math.abs(p.getX(0) - p.getX(n-1)) &lt; 1E-6 &amp;&amp;</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">                Math.abs(p.getY(0) - p.getY(n-1)) &lt; 1E-6) {</span>
            // excluding the last point because its the same as the first
<span class="fc" id="L904">            --n;</span>
        }

<span class="fc" id="L907">        int dp1 = 1;</span>

<span class="fc" id="L909">        float[][] a = new float[n][];</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L911">            a[i] = new float[n];</span>
        }

        /*
             P1      Pmid

                  P2
        */

        //log.fine(&quot;n=&quot; + n);

<span class="fc bfc" id="L922" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n; ++i1) {</span>
<span class="fc" id="L923">            int start = i1 + 1 + dp1;</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">            for (int ii = start; ii &lt; (start + n - 1 - dp1); ++ii) {</span>
<span class="fc" id="L925">                int i2 = ii;</span>

<span class="fc" id="L927">                int imid = i2 - dp1;</span>
                // wrap around
<span class="fc bfc" id="L929" title="All 2 branches covered.">                if (imid &gt; (n - 1)) {</span>
<span class="fc" id="L930">                    imid -= n;</span>
                }

                // wrap around
<span class="fc bfc" id="L934" title="All 2 branches covered.">                if (i2 &gt; (n - 1)) {</span>
<span class="fc" id="L935">                    i2 -= n;</span>
                }

                //log.fine(&quot;i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2);

                //double angleA = LinesAndAngles.calcAngle(
<span class="fc" id="L941">                double angleA = LinesAndAngles.calcClockwiseAngle(</span>
<span class="fc" id="L942">                    p.getX(i1), p.getY(i1),</span>
<span class="fc" id="L943">                    p.getX(i2), p.getY(i2),</span>
<span class="fc" id="L944">                    p.getX(imid), p.getY(imid)</span>
                );
                
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">                if (Double.isNaN(angleA)) {</span>
<span class="nc bnc" id="L948" title="All 4 branches missed.">                    if (i2 &lt; i1 &amp;&amp; i1 &lt; imid) {</span>
<span class="nc" id="L949">                        angleA = LinesAndAngles.calcAngle(</span>
                        //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="nc" id="L951">                            p.getX(i2), p.getY(i2),</span>
<span class="nc" id="L952">                            p.getX(i1), p.getY(i1),</span>
<span class="nc" id="L953">                            p.getX(imid), p.getY(imid));</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                        if (Double.isNaN(angleA)) {</span>
<span class="nc" id="L955">                            angleA = LinesAndAngles.calcAngle(</span>
                            //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="nc" id="L957">                                p.getX(i2), p.getY(i2),</span>
<span class="nc" id="L958">                                p.getX(i1), p.getY(i1),</span>
<span class="nc" id="L959">                                p.getX(imid), p.getY(imid));</span>
                        }
                    } else {
                       // System.out.println(
                       // &quot;SKIP i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2);
                        continue;
                    }
                }

<span class="fc" id="L968">                float angleAF = (float)angleA;</span>

                /*
                String str = String.format(
                    &quot;[%d](%d,%d) [%d](%d,%d) [%d](%d,%d) a=%.4f&quot;,
                    i1, p.getX(i1), p.getY(i1),
                    i2, p.getX(i2), p.getY(i2),
                    imid, p.getX(imid), p.getY(imid),
                    (float) angleA * 180. / Math.PI);
                log.fine(str);
                */

<span class="fc bfc" id="L980" title="All 2 branches covered.">                if (angleAF &gt;= TWO_PI) {// rounding errors from int to float and double</span>
<span class="fc" id="L981">                    angleAF -= TWO_PI;</span>
                }
<span class="fc bfc" id="L983" title="All 2 branches covered.">                if (Math.abs(angleAF - TWO_PI) &lt; ZERO_TOL) {</span>
<span class="fc" id="L984">                    angleAF = 0.f;</span>
                }

<span class="fc" id="L987">                a[i1][i2] = angleAF;</span>
                
<span class="fc bfc" id="L989" title="All 2 branches covered.">                if (i2 == (i1 + 2)) {</span>
                    // fill in missing point, assume same value
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">                    if (a[i1][i2] == a[i1][ii]) {</span>
<span class="fc" id="L992">                        a[i1][i1 + 1] = a[i1][i2];</span>
                    }
                }
            }
        }

<span class="fc" id="L998">        return a;</span>
    }

    private float[][] copy(float[][] a) {
<span class="fc" id="L1002">        float[][] a2 = new float[a.length][];</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        for (int i = 0; i &lt; a2.length; ++i) {</span>
<span class="fc" id="L1004">            a2[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }
<span class="fc" id="L1006">        return a2;</span>
    }

    public static void rotate(float[][] prevShifted) {

         // shift x left by 1 first
<span class="fc bfc" id="L1012" title="All 2 branches covered.">         for (int y = 0; y &lt; prevShifted[0].length; ++y) {</span>
<span class="fc" id="L1013">             float tmp0 = prevShifted[0][y];</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">             for (int x = 0; x &lt; (prevShifted.length- 1); ++x){</span>
<span class="fc" id="L1015">                 prevShifted[x][y] = prevShifted[x + 1][y];</span>
             }
<span class="fc" id="L1017">             prevShifted[prevShifted.length - 1][y] = tmp0;</span>
         }

         // shift y down by 1
<span class="fc bfc" id="L1021" title="All 2 branches covered.">         for (int x = 0; x &lt; prevShifted.length; ++x) {</span>
<span class="fc" id="L1022">             float tmp0 = prevShifted[x][0];</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">             for (int y = 0; y &lt; (prevShifted[x].length - 1); ++y){</span>
<span class="fc" id="L1024">                 prevShifted[x][y] = prevShifted[x][y + 1];</span>
             }
<span class="fc" id="L1026">             prevShifted[x][prevShifted[x].length - 1] = tmp0;</span>
         }
<span class="fc" id="L1028">    }</span>

    /**
     * subtract the portion of a2 that is same size as
     * a1 from a1.
     * @param a1
     * @param a2
     * @return
     */
    private float[][] subtract(float[][] a1, float[][] a2) {

        /*
         MXM     NXN
                 20 21 22
         10 11   10 11 12
         00 01   00 01 02

                 01 02 00
         10 11   21 22 20
         00 01   11 12 10

                 12 10 11
         10 11   02 00 01
         00 01   22 20 21

        subtracting only the MXM portion
        */

<span class="pc bnc" id="L1056" title="All 2 branches missed.">        assert(a1.length == a1[0].length);</span>
<span class="pc bnc" id="L1057" title="All 2 branches missed.">        assert(a2.length == a2[0].length);</span>

<span class="fc" id="L1059">        int n1 = a1.length;</span>
<span class="fc" id="L1060">        int n2 = a2.length;</span>

<span class="pc bnc" id="L1062" title="All 2 branches missed.">        assert(n1 &lt;= n2);</span>

<span class="fc" id="L1064">        float[][] output = new float[n1][];</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L1066">            output[i] = new float[n1];</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L1068">                float v = Math.abs(a1[i][j] - a2[i][j]);</span>
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">                if (Math.abs(TWO_PI - v) &lt; ZERO_TOL) {</span>
<span class="nc" id="L1070">                    v = 0.f;</span>
                }
<span class="fc" id="L1072">                output[i][j] = v;</span>
            }
        }

<span class="fc" id="L1076">        return output;</span>
    }
    
    protected void applySummedAreaTableConversion(float[][][] md) {
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        for (float[][] floats : md) {</span>
<span class="fc" id="L1081">            applySummedAreaTableConversion(floats);</span>
        }
<span class="fc" id="L1083">    }</span>

    protected void applySummedAreaTableConversion(float[][] mdI) {

<span class="fc" id="L1087">        int w = mdI.length;</span>
<span class="fc" id="L1088">        int h = mdI[0].length;</span>
        
        // sum along columns, that is a[i][*]
<span class="fc bfc" id="L1091" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc bfc" id="L1093" title="All 4 branches covered.">                if (i &gt; 0 &amp;&amp; j &gt; 0) {</span>
<span class="fc" id="L1094">                    mdI[i][j] += (mdI[i - 1][j] + mdI[i][j - 1]</span>
                        - mdI[i - 1][j - 1]);
<span class="fc bfc" id="L1096" title="All 2 branches covered.">                } else if (i &gt; 0) {</span>
<span class="fc" id="L1097">                    mdI[i][j] += mdI[i - 1][j];</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">                } else if (j &gt; 0) {</span>
<span class="fc" id="L1099">                    mdI[i][j] += mdI[i][j - 1];</span>
                }
            }
        }
<span class="fc" id="L1103">    }</span>

    private void print(String label, float[][] a) {

<span class="nc" id="L1107">        StringBuilder sb = new StringBuilder(label);</span>
<span class="nc" id="L1108">        sb.append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L1110" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L1111">            sb.append(String.format(&quot;row %3d: &quot;, i));</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            for (int j = 0; j &lt; a[i].length; ++j) {</span>
<span class="nc" id="L1113">                sb.append(String.format(&quot; %.2f,&quot;, a[i][j]));</span>
            }
<span class="nc" id="L1115">            log.fine(sb.toString());</span>
<span class="nc" id="L1116">            System.out.println(sb.toString());</span>
<span class="nc" id="L1117">            sb.delete(0, sb.length());</span>
        }
<span class="nc" id="L1119">    }</span>

    private String plot(PairFloatArray p, String fileLabel) throws Exception {

<span class="nc" id="L1123">        float[] x = Arrays.copyOf(p.getX(), p.getN());</span>
<span class="nc" id="L1124">        float[] y = Arrays.copyOf(p.getY(), p.getN());</span>
<span class="nc" id="L1125">        float xMax = MiscMath.findMax(x) + 1;</span>
<span class="nc" id="L1126">        float yMax = MiscMath.findMax(y) + 1;</span>

<span class="nc" id="L1128">        PolygonAndPointPlotter plot = new PolygonAndPointPlotter();</span>

<span class="nc" id="L1130">        plot.addPlot(0, xMax, 0, yMax,</span>
                x, y, x, y, &quot;&quot;);

<span class="nc" id="L1133">        return plot.writeFile(fileLabel);</span>
    }

    private List&lt;String&gt; plotResults(List&lt;Match.Points&gt; results, PairFloatArray p, PairFloatArray q,
                                     int spacing, String fileSuffix, boolean printIndexes) {
<span class="nc" id="L1138">        List&lt;String&gt; writtenFiles = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1140">        PairIntArray pInt = new PairIntArray();</span>
<span class="nc" id="L1141">        PairIntArray qInt = new PairIntArray();</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        for (int i = 0; i &lt; p.getN(); ++i) {</span>
<span class="nc" id="L1143">            pInt.add(Math.round(p.getX(i)), Math.round(p.getY(i)));</span>
        }
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        for (int i = 0; i &lt; q.getN(); ++i) {</span>
<span class="nc" id="L1146">            qInt.add(Math.round(q.getX(i)), Math.round(q.getY(i)));</span>
        }

        try {
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            for (int i = 0; i &lt; results.size(); ++i) {</span>
<span class="nc" id="L1151">                CorrespondencePlotter plotter = new CorrespondencePlotter(pInt, qInt);</span>
<span class="nc" id="L1152">                Match.Points result = results.get(i);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                for (int ii = 0; ii &lt; result.pIdxs.length; ii += spacing) {</span>
<span class="nc" id="L1154">                    int idx1 = result.pIdxs[ii];</span>
<span class="nc" id="L1155">                    int idx2 = result.qIdxs[ii];</span>
<span class="nc" id="L1156">                    int x1 = pInt.getX(idx1);</span>
<span class="nc" id="L1157">                    int y1 = pInt.getY(idx1);</span>
<span class="nc" id="L1158">                    int x2 = qInt.getX(idx2);</span>
<span class="nc" id="L1159">                    int y2 = qInt.getY(idx2);</span>

<span class="nc bnc" id="L1161" title="All 2 branches missed.">                    if (printIndexes) {</span>
<span class="nc" id="L1162">                        System.out.println(String.format(</span>
<span class="nc" id="L1163">                                &quot;(%d, %d) &lt;=&gt; (%d, %d)&quot;, x1, y1, x2, y2));</span>
                    }

<span class="nc" id="L1166">                    plotter.drawLineInAlternatingColors(x1, y1, x2, y2, 0);</span>
                }
<span class="nc" id="L1168">                String filePath = plotter.writeImage(String.format(&quot;_%s_%d&quot;, fileSuffix, i));</span>
<span class="nc" id="L1169">                writtenFiles.add(filePath);</span>
            }
<span class="nc" id="L1171">        } catch (IOException ex) {</span>
<span class="nc" id="L1172">            log.severe(ex.getMessage());</span>
<span class="nc" id="L1173">        }</span>
<span class="nc" id="L1174">        return writtenFiles;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>
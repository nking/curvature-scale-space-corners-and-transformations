<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LineFinder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.matching</a> &gt; <span class="el_source">LineFinder.java</span></div><h1>LineFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.matching;

import algorithms.compGeometry.LinesAndAngles;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.imageProcessing.SummedColumnTable;
import algorithms.misc.MiscMath;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.TwoDFloatArray;
import gnu.trove.map.TIntFloatMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntFloatHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.edu.princeton.cs.algs4.Interval;
import thirdparty.edu.princeton.cs.algs4.IntervalRangeSearch;

/**
NOTE: NOT READY FOR USE YET... still testing.

a class for finding lines in a closed shape of clockwise ordered
points.

Note that comments are present throughout the code that can be followed
to add options specific to different use cases.  the algorithm is currently
tailored for use with LinesFinder and VanishingPoints to find lines in
image segmentation boundaries.  The code could be edited to work on
ordered edges.  The code could also be edited to find line patterns
precisely for specific rendered spatial aliasing patterns (&quot;jaggles&quot;).

Internally, the chord difference descriptor matrix is adapted from
PartialShapeMatcher.java which was made following the paper
&quot;Efficient Partial Shape Matching of Outer Contours&quot; by Donoser

The differences in chords of the implied second shape, a line is always pi,
so edits are present specific to a one dimensional value instead of a closed
curve.
Also, the summed table of the chord differences is only along columns.

@author nichole
*/
<span class="fc" id="L50">public class LineFinder {</span>

    /**
      dp is the set distance between sampling points.
      The authors of the paper use 3 as an example.
    */
<span class="fc" id="L56">    protected int dp = 1;</span>

    // 10 degrees is 0.1745 radians
    // for a fit to a horizontal or vertical line only, 
    // consider 1E-7
<span class="fc" id="L61">    private float thresh = 0.17f;//0.3f;      </span>
    
    // this one is a rough limit to the total chord diff
    // sum over a found line segment.
<span class="fc" id="L65">    private float thresh3 = 3;//10;</span>

    //NOTE: for staircase roofs like house_color.png has, 
    //   increasing thresh to 0.4 and thresh3 to 15 finds the
    //   remaining lines
    
<span class="fc" id="L71">    private int minLength = 10;</span>
    
<span class="fc" id="L73">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L75">    private boolean debug = false;</span>

<span class="fc" id="L77">    private int lastCol = -1;</span>
<span class="fc" id="L78">    private int lastRow = -1;</span>
    
<span class="fc" id="L80">    private boolean useHighResolution = false;</span>
    
    /**
     * this option reduces the thresholds and compares the curves to up
     * to 46 different line aliasing patterns (depending upon line length).
     * The threshold and total thresholds are reduced to:
     * (add changes here)
     * so if a different threshold is needed, one can re-set those after
     * invoking this method.
     */
    //public void overrideToUseHighResolution() {
    //    useHighResolution = true;
    //}
    
    /**
     * override the threshold for using a chord difference value
     * to this limit for the chord sum diff / number of pixels. 
     * By default it is set to 0.17f;
     * Note, to find only horizontal or vertical lines, use a
     * very small threshold such as 1e-7.
      NOTE: for staircase roofs like house_color.png has, 
      increasing thresh to 0.4 nd thresh3 to 15 finds the
      remaining lines
     * @param t
     */
    public void _overrideToThreshold(float t) {
<span class="fc" id="L106">        this.thresh = t;</span>
<span class="fc" id="L107">    }</span>
    
    /**
      change the limit of the total chord difference
      sum over a found line segment.
      The default is 3.
      NOTE: for staircase roofs like house_color.png has, 
      increasing thresh to 0.4 nd thresh3 to 15 finds the
      remaining lines
     * @param t 
     */
    public void _overrideToTotalThreshold(float t) {
<span class="fc" id="L119">        thresh3 = t;</span>
<span class="fc" id="L120">    }</span>
    
    /**
     * set the minimum line length to length.  Note that the
     * default value is 3.
     * Note that this cannot be set to a value smaller than 2.
     * 
     * @param length 
     */
    public void overrideMinimumLineLength(int length) {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (length &lt; 2) {</span>
<span class="nc" id="L131">            throw new IllegalArgumentException(&quot;length must be &gt;= 2&quot;);</span>
        }
<span class="fc" id="L133">        this.minLength = length;</span>
<span class="fc" id="L134">    }</span>

    /**
     * override the sampling distance along the boundary which is by default
     * set to 1.  If a larger value is used, the curve is sampled at
     * the given spacing, and the results are interpolated as filled in
     * between a sampled range.
     * @param d
     */
    public void overrideSamplingDistance(int d) {
<span class="nc" id="L144">        this.dp = d;</span>
<span class="nc" id="L145">    }</span>
    
    /**
     * if this is set, vertical lines found at polar radius 0 and width from
     * origin are removed and so are horizontal lines found at polar radius
     * and height from origin.
     */
    public void setToRemoveBorderLines(int lastColumn, int lastRow) {
<span class="nc" id="L153">        this.lastCol = lastColumn;</span>
<span class="nc" id="L154">        this.lastRow = lastRow;</span>
<span class="nc" id="L155">    }</span>

    public void setToDebug() {
<span class="nc" id="L158">        debug = true;</span>
<span class="nc" id="L159">        log.setLevel(Level.FINE);</span>
<span class="nc" id="L160">    }</span>

    /**
      NOT READY FOR USE... still testing...

      Find lines in the clockwise ordered set of points p.
      Note that p is expected to be a closed curve.
      
      The algorithm may actually work for open curves too,
      but the matching of points across an expected wrap
      around of last to first point would add artificial 
      matching statistics that affect the results.
      NOTE: the code could be altered for edge logic, that
      is, to add an infinitely large difference of chords
      to the boundary when the first and last points are
      not adjacent, but that is not current logic in this
      algorithm at this time...
      TODO: add such an option and logic.
      
      A shape is defined as the clockwise ordered sequence
      of points P_1...P_N.
      The spacings used within this method are equidistant
      The default spacing is 1,
      so override that if a different number
      is needed.

     &lt;em&gt;NOTE: You may need to pre-process the shape points
     for example, smooth the boundary.&lt;/em&gt;
     &lt;pre&gt;
     Gaussian smoothing of 2 sigma or related options for smaller:
        PairIntArray p = imageProcessor
            .extractSmoothedOrderedBoundary()
      &lt;/pre&gt;
     @param p
    */
    public LineResult match(PairIntArray p) throws GrahamScanTooFewPointsException {

<span class="fc" id="L197">        log.fine(&quot;p.n=&quot; + p.getN());</span>

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (p.getN() &lt; 2) {</span>
<span class="nc" id="L200">            throw new IllegalArgumentException(&quot;p must &quot;</span>
            + &quot; have at least dp*2 points = &quot; + (dp * 2));
        }

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (dp == 1) {</span>
<span class="fc" id="L205">            return match0(p);</span>
        }

<span class="nc" id="L208">        PairIntArray pSub = new PairIntArray(p.getN()/dp);</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (int i = 0; i &lt; p.getN(); i += dp) {</span>
<span class="nc" id="L211">            pSub.add(p.getX(i), p.getY(i));</span>
        }

<span class="nc" id="L214">        log.fine(&quot;pSub.n=&quot; + pSub.getN());</span>

<span class="nc" id="L216">        LineResult rSub = match0(pSub);</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (rSub == null) {</span>
<span class="nc" id="L219">            return null;</span>
        }

        // -- put results back into frame of p --

<span class="nc" id="L224">        LineResult r = new LineResult();</span>

<span class="nc" id="L226">        List&lt;PairInt&gt; lr = rSub.getLineIndexRanges();</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">        for (int i = 0; i &lt; lr.size(); ++i) {</span>
<span class="nc" id="L229">            PairInt startStop = lr.get(i);</span>
<span class="nc" id="L230">            int len = startStop.getY() - startStop.getX() + 1;</span>
<span class="nc" id="L231">            len *= dp;</span>
<span class="nc" id="L232">            int x = startStop.getX() * dp;</span>
<span class="nc" id="L233">            int y = x + len - 1;</span>
<span class="nc" id="L234">            r.addLineRange(new PairInt(x, y));</span>
        }

<span class="nc" id="L237">        return r;</span>
    }

    private LineResult match0(PairIntArray p) throws GrahamScanTooFewPointsException {

<span class="pc bpc" id="L242" title="2 of 4 branches missed.">        if (p == null || p.getN() &lt; 2) {</span>
<span class="nc" id="L243">            throw new IllegalArgumentException(&quot;p must have at &quot;</span>
                + &quot;least 2 points&quot;);
        }

        // --- make difference matrix ---

        //md[0:n1-1][0:n1-1]
<span class="fc" id="L250">        int n1 = p.getN();</span>
        
<span class="fc" id="L252">        int sz = MiscMath.calculateObjectSize(p);</span>
        
        // ---- read the difference matrix to find minimum cost assignments ----
        
        // reading over a range of window sizes to keep the sum/nPix below thresh
        // and keeping the mincost solutions.

        // find the intervals of contiguous 0s and assign curve indexes to the
        // largest segments.
        // (note that the 0s are the values below threshold, effectively
        //  0 by user request, and that the objective formula for the cost
        //  is the Salukwzde distance).

        /*
        reading each row
           read start and stop cols of values &lt; threshold
           and store each as an interval.
           if intersects with existing interval, compare 
              cost and keep the one that is smallest cost 
              in the interval tree
        */

<span class="fc" id="L274">        IntervalRangeSearch&lt;Integer, Integer&gt; rangeSearch = search(p);</span>

        // merge the results with the combined if they do not clash
        // read out the intervals and if all are matched or nearly all, break
        // ---- retrieve the intervals from range tree, trimming to unique -----
<span class="fc" id="L279">        List&lt;Interval&lt;Integer&gt;&gt; list = rangeSearch.getAllIntervals();</span>

<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L282">            System.out.println(&quot;nIntervals=&quot; + list.size());</span>
        }

<span class="fc" id="L285">        int nMatched = 0;</span>

<span class="fc" id="L287">        TIntSet existing = new TIntHashSet();</span>
<span class="fc" id="L288">        TIntSet junctions = new TIntHashSet();</span>

<span class="fc" id="L290">        LineResult result = new LineResult();</span>
        
        int start, stop;
        
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (Interval&lt;Integer&gt; interval2 : list) {</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L296">                System.out.println(&quot;interval2=&quot; + interval2);</span>
            }
            // correct for the interval start being +1
<span class="fc" id="L299">            start = interval2.min() - 1;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (existing.contains(start)) {</span>
<span class="fc" id="L301">                junctions.add(start);</span>
<span class="fc" id="L302">    System.out.println(&quot;junction: &quot; + p.getX(start) + &quot; , &quot; + p.getY(start));</span>
<span class="fc" id="L303">                start++;</span>
            }
<span class="fc" id="L305">            stop = interval2.max();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (existing.contains(stop)) {</span>
<span class="fc" id="L307">                junctions.add(stop);</span>
<span class="fc" id="L308">    System.out.println(&quot;junction: &quot; + p.getX(stop) + &quot; , &quot; + p.getY(stop));</span>
<span class="fc" id="L309">                stop--;</span>
            }
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L312">                System.out.println(&quot;*** final: &quot; + </span>
<span class="nc" id="L313">                    String.format(&quot; (%d,%d) to (%d,%d) &quot;,</span>
<span class="nc" id="L314">                    p.getX(interval2.min()),</span>
<span class="nc" id="L315">                    p.getY(interval2.min()),</span>
<span class="nc" id="L316">                    p.getX(interval2.max()),</span>
<span class="nc" id="L317">                    p.getY(interval2.max()))</span>
                    + &quot; similar to? &quot; + 
<span class="nc" id="L319">                    String.format(&quot; (%d,%d) to (%d,%d) &quot;,</span>
<span class="nc" id="L320">                    p.getX(start), p.getY(start),</span>
<span class="nc" id="L321">                    p.getX(stop), p.getY(stop))</span>
                );
            }
<span class="fc" id="L324">            PairInt s = new PairInt(start, stop);</span>
<span class="fc" id="L325">            result.addLineRange(s);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            for (int i = start; i &lt;= stop; ++i) {</span>
<span class="fc" id="L327">                existing.add(i);</span>
<span class="fc" id="L328">                nMatched++;</span>
            }
<span class="fc" id="L330">        }</span>

        //System.out.println(&quot;nRanges=&quot; + result.lineIndexRanges.size());
        
<span class="fc" id="L334">        result.junctionIndexes = junctions;</span>

<span class="fc" id="L336">        return result;</span>
    }
    
    private IntervalRangeSearch&lt;Integer, Integer&gt; search(PairIntArray p) {
        
<span class="fc" id="L341">        TwoDFloatArray[] mds = createSummedDifferences(p);</span>
      
        // key = map size at put, value = interval
<span class="fc" id="L344">        TIntObjectMap&lt;Interval&lt;Integer&gt;&gt; intervalMap =</span>
            new TIntObjectHashMap&lt;Interval&lt;Integer&gt;&gt;();

        // key = key of intervalMap.  item = chord diff sum
<span class="fc" id="L348">        TIntFloatMap chordMap = new TIntFloatHashMap();</span>

        // storing the interval of consecutive indexes, each below threshold,
        //   and storing as the value, the key to entry in intervalMap
<span class="fc" id="L352">        IntervalRangeSearch&lt;Integer, Integer&gt; rangeSearch =</span>
            new IntervalRangeSearch&lt;Integer, Integer&gt;();
        
<span class="fc" id="L355">        Interval&lt;Integer&gt; interval = null;</span>

<span class="fc" id="L357">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L359">        double maxChordSum = Double.MIN_VALUE;</span>

<span class="fc" id="L361">        float[] outC = new float[2];</span>
        int stop, start;
<span class="fc" id="L363">        int mdLen = mds[0].a[0].length;</span>
        
<span class="fc" id="L365">        SummedColumnTable smt = new SummedColumnTable();</span>
        
<span class="fc bfc" id="L367" title="All 2 branches covered.">        for (int a2i = 0; a2i &lt; mds.length; ++a2i) {</span>
            
<span class="fc" id="L369">            float[][] md = mds[a2i].a;</span>
            
<span class="fc bfc" id="L371" title="All 2 branches covered.">            for (int jRange = (mdLen - 1); jRange &gt;= minLength; --jRange) {</span>

<span class="fc bfc" id="L373" title="All 2 branches covered.">                for (int i = 0; i &lt; md.length; ++i) {</span>

<span class="fc bfc" id="L375" title="All 2 branches covered.">                    for (int j = 0; j &lt; mdLen; j += jRange) {</span>

<span class="fc" id="L377">                        stop = j + jRange;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                        if (stop &gt; (mdLen - 1)) {</span>
<span class="fc" id="L379">                            stop = mdLen - 1;</span>
                        }
                        
<span class="fc" id="L382">                        int x0 = p.getX(j);</span>
<span class="fc" id="L383">                        int y0 = p.getY(j);</span>
<span class="fc" id="L384">                        int x1 = p.getX(stop);</span>
<span class="fc" id="L385">                        int y1 = p.getY(stop);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                        if (lastCol &gt; -1) {</span>
<span class="nc bnc" id="L387" title="All 16 branches missed.">                            if ((x0 &lt; 3) || (x0 &gt; (lastCol - 3)) || </span>
                                (y0 &lt; 3) || (y0 &gt; (lastRow - 3)) ||
                                (x1 &lt; 3) || (x1 &gt; (lastCol - 3)) ||
                                (y1 &lt; 3) || (y1 &gt; (lastRow - 3))) {
<span class="nc" id="L391">                                continue;</span>
                            }
                        }

<span class="fc" id="L395">                        smt.extractWindowInColumn(md, j, stop, i, outC);</span>

<span class="pc bpc" id="L397" title="1 of 2 branches missed.">                        if (outC[1] &lt; 1) {</span>
<span class="nc" id="L398">                            continue;</span>
                        }
                        
<span class="fc" id="L401">                        float d = outC[0]/outC[1];</span>
        
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                        if (debug) {</span>
                            //System.out.println(String.format(
                            //&quot;len=%d i=%d d=%.2f&quot;, (stop - j + 1), i, d));
                        }

<span class="pc bpc" id="L408" title="1 of 4 branches missed.">                        if (d &gt; thresh || outC[0] &gt; thresh3) {</span>
<span class="nc" id="L409">                            continue;</span>
                        }
<span class="fc bfc" id="L411" title="All 2 branches covered.">                        if (d &gt; maxChordSum) {</span>
<span class="fc" id="L412">                            maxChordSum = d;</span>
                        }

                        // to prevent two intersecting lines from being merged
                        // into one, will use a start interval one
                        // index higher, and correct for it later.
                        // also, not storing single index matches

<span class="fc" id="L420">                        start = j + 1;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                        if (start &gt; (mdLen - 1)) {</span>
<span class="fc" id="L422">                            start = (mdLen - 1);</span>
                        }

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                        if (stop &lt; start) {</span>
                            // do not store single index matches
<span class="nc" id="L427">                            continue;</span>
                        }
                        
<span class="fc" id="L430">                        x0 = p.getX(start);</span>
<span class="fc" id="L431">                        y0 = p.getY(start);</span>

<span class="fc" id="L433">                        int ni = stop - start + 2;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                        if (ni &lt; minLength) {</span>
<span class="fc" id="L435">                            continue;</span>
                        }

<span class="fc" id="L438">                        interval =  new Interval&lt;Integer&gt;(start, stop);</span>
<span class="fc" id="L439">                        PairInt s = new PairInt(start, stop);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">                        if (added.contains(s)) {</span>
<span class="fc" id="L441">                            continue;</span>
                        }
                        
<span class="fc" id="L444">                        int sz = intervalMap.size();</span>
<span class="fc" id="L445">                        Integer szI = Integer.valueOf(sz);</span>

                        // store it in range search
<span class="fc" id="L448">                        Integer existing = rangeSearch.put(interval, szI);</span>

                        // store current interval in associated maps
<span class="fc" id="L451">                        intervalMap.put(szI, interval);</span>
<span class="fc" id="L452">                        chordMap.put(sz, d);</span>
<span class="fc" id="L453">                        added.add(s);</span>

<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                        if (debug) {</span>
<span class="nc" id="L456">                            float avgN = (float)(maxChordSum * outC[1]);</span>
<span class="nc" id="L457">                            System.out.println(&quot;  adding &quot; + interval </span>
<span class="nc" id="L458">                                + String.format(</span>
                                &quot; d=%.2f (%d,%d) (%d,%d)  cs=%.2f avg*N=%.2f&quot;, 
<span class="nc" id="L460">                                d, x0, y0, x1, y1, outC[0], avgN));</span>
                        }

<span class="fc bfc" id="L463" title="All 2 branches covered.">                        if (existing != null) {</span>
                            // clashes with existing, so make sure the lowest cost
                            // remains in range tree
<span class="fc" id="L466">                            Interval&lt;Integer&gt; comp = intervalMap.get(existing);</span>
                            
<span class="fc" id="L468">                            double compChord = chordMap.get(existing.intValue());</span>
<span class="fc" id="L469">                            int nc = comp.max().intValue() - comp.min().intValue() + 2;</span>

<span class="fc" id="L471">                            double compSD = calcSalukDist(compChord, maxChordSum,</span>
                                nc, md.length);

<span class="fc" id="L474">                            double currentSD = calcSalukDist(d, maxChordSum,</span>
                                ni, md.length);

<span class="fc bfc" id="L477" title="All 2 branches covered.">                            if (compSD &lt; currentSD) {</span>
<span class="fc" id="L478">                                Integer rmvd0 = rangeSearch.remove(interval);</span>
<span class="pc bnc" id="L479" title="All 2 branches missed.">                                assert(rmvd0 != null);</span>
                                //re-insert existing interval
<span class="fc" id="L481">                                Integer rmvd = rangeSearch.put(comp, existing);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                                if (rmvd != null) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                                    if (debug) {</span>
<span class="nc" id="L484">                                        System.out.println(&quot;  conflict w. removal. &quot; </span>
                                            + &quot; re-ins existing=&quot; + comp +
<span class="nc" id="L486">                                            &quot;  but removed=&quot; + intervalMap.get(rmvd));</span>
                                    }
                                }
                            }
                        }
                    }
                } // end loop j
            } // end jRange
        }
        
<span class="fc" id="L496">        return rangeSearch;</span>
    }

    /**
     * create the matrices of differences between p
     * and q.  Note that the matrix differences are
     * absolute differences.
      returns a[0:p.n-1][0:p.n-1]
    */
    protected float[][] createDifferenceMatrices(
        float[][] a1, int lineIndex) {
             
        /*
        TODO:
        note, this section of the code was designed to create 
        line patterns including spatially aliased lines
        with the global goal being to use a small threshold and precisely
        find line patterns.
        
        Note that found that using
        a straight line (lineIndex==0) and increasing the threshold gave better
        results for first tests, but this should be revisited more
        robustly to explore runtimes and accuracy one day with a
        larger number of aliased line patters (the line patterns
        would be those produced by integer effects of a line rendered for
        polar angles from 0 to 45 degrees fpr the number of points
        p.n.  If p is a short closed curve, then many of the 46 line
        patterns might be identical within that length so a table of
        pre-processed pattern indexes for a length could be made to 
        improve the runtime in that case in this alternate code).
        */
        
<span class="fc" id="L528">        int n1 = a1.length;</span>

        //log.fine(&quot;a2:&quot;);
<span class="fc" id="L531">        float[][] a2 = null;</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (lineIndex == 0) {</span>
<span class="fc" id="L533">            a2 = createLineDescriptorMatrix(n1);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        } else if (lineIndex == 1) {</span>
            // line pattern: 2 horiz, up one level, then 2 horiz...
            //     - -
            // - -
<span class="nc" id="L538">            PairIntArray q = createLine2(n1);</span>
<span class="nc" id="L539">            a2 = createDescriptorMatrix(q, n1);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        } else if (lineIndex == 2) {</span>
            // line pattern: 3 horiz, up one level, then 3 horiz...
<span class="nc" id="L542">            PairIntArray q = createLine4(n1);</span>
<span class="nc" id="L543">            a2 = createDescriptorMatrix(q, n1);</span>
        }
        
        /*
            MXM              &lt;XM
         20 21 22        20 21 22
         10 11 12        10 11 12
         00 01 02        00 01 02   p_i_j - q_i_j
        */

        // --- make difference matrices ---
<span class="fc" id="L554">        int n2 = n1;</span>
<span class="fc" id="L555">        float[][] md = copy(a2);</span>
        // NOTE: absolute values are stored.
        //M_D^n = A_1(1:M,1:M) - A_2(n:n+M-1,n:n+M-1)
<span class="fc" id="L558">        md = subtract(a1, md);</span>

<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (debug) {</span>
            //print(&quot;a1&quot;, a1);
            //print(&quot;a2&quot;, a2);
            //print(&quot;diff matrix&quot;, md);
        }

<span class="fc" id="L566">        return md;</span>
    }

    protected float[][] createLineDescriptorMatrix(int n) {

<span class="fc" id="L571">        float[][] a = new float[n][];</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L573">            a[i] = new float[n];</span>
<span class="fc" id="L574">            Arrays.fill(a[i], (float)Math.PI);</span>
            // diagonal is zero
<span class="fc" id="L576">            a[i][i] = 0;</span>
        }

<span class="fc" id="L579">        return a;</span>
    }

    /**
     given the shape points for p and q,
     create a matrix of descriptors, describing the difference
     in chord angles.

     The chord descriptor is invariant to translation, rotation,
     and scale:
       - a chord is a line joining 2 region points
       - uses the relative orientation between 2 chords
         angle a_i_j is from chord P_i_P_j to reference
         point P_i
         to another sampled point and chord P_j_P_(j-d) and P_j

         d is the number of points before j in the sequence of points P.

         a_i_j is the angle between the 2 chords P_i_P_j and P_j_P_(j-d)
        
        | a_1_1...a_1_N |
        | a_2_1...a_2_N |
               ...
        | a_N_1...a_N_N |
           elements on the diagonal are zero

           to shift to different first point as reference,
           can shift down k-1 rows and left k-1 columns.
    */
    protected float[][] createDescriptorMatrix(PairIntArray p, int n) {

<span class="fc" id="L610">        int dp1 = 1;</span>

<span class="fc" id="L612">        float[][] a = new float[n][];</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L614">            a[i] = new float[n];</span>
        }

        /*
             P1      Pmid

                  P2
        */

<span class="fc" id="L623">        log.fine(&quot;n=&quot; + n);</span>

<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n; ++i1) {</span>
<span class="fc" id="L626">            int start = i1 + 1 + dp1;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">            for (int ii = start; ii &lt; (start + n - 1 - dp1); ++ii) {</span>
<span class="fc" id="L628">                int i2 = ii;</span>

<span class="fc" id="L630">                int imid = i2 - dp1;</span>
                // wrap around
<span class="fc bfc" id="L632" title="All 2 branches covered.">                if (imid &gt; (n - 1)) {</span>
<span class="fc" id="L633">                    imid -= n;</span>
                }

                // wrap around
<span class="fc bfc" id="L637" title="All 2 branches covered.">                if (i2 &gt; (n - 1)) {</span>
<span class="fc" id="L638">                    i2 -= n;</span>
                }
                
                //log.fine(&quot;i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2);

                double 
                    //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="fc" id="L645">                    angleA = LinesAndAngles.calcAngle(</span>
<span class="fc" id="L646">                    p.getX(i1), p.getY(i1),</span>
<span class="fc" id="L647">                    p.getX(i2), p.getY(i2),</span>
<span class="fc" id="L648">                    p.getX(imid), p.getY(imid)</span>
                );

                // TODO revisit this
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">                if (Double.isNaN(angleA)) {</span>
<span class="nc bnc" id="L653" title="All 4 branches missed.">                    if (i2 &lt; i1 &amp;&amp; i1 &lt; imid) {</span>
                        //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="nc" id="L655">                        angleA = LinesAndAngles.calcAngle(    </span>
<span class="nc" id="L656">                            p.getX(i2), p.getY(i2),</span>
<span class="nc" id="L657">                            p.getX(i1), p.getY(i1),</span>
<span class="nc" id="L658">                            p.getX(imid), p.getY(imid));</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                        if (Double.isNaN(angleA)) {</span>
                            //angleA = LinesAndAngles.calcClockwiseAngle(
<span class="nc" id="L661">                            angleA = LinesAndAngles.calcAngle(</span>
<span class="nc" id="L662">                                p.getX(i2), p.getY(i2),</span>
<span class="nc" id="L663">                                p.getX(i1), p.getY(i1),</span>
<span class="nc" id="L664">                                p.getX(imid), p.getY(imid));</span>
                        }
                    } else {
<span class="nc" id="L667">                        System.out.println(</span>
                        &quot;SKIP i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2);
<span class="nc" id="L669">                        continue;</span>
                    }
                }

                //System.out.println(&quot;i1=&quot; + i1 + &quot; imid=&quot; + imid + &quot; i2=&quot; + i2 +
                //    &quot;  angleA=&quot; + angleA);
          
<span class="fc" id="L676">                a[i1][i2] = (float)angleA;</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">                if (i2 == (i1 + 2)) {</span>
                    // fill in missing point, assume same value
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                    if (a[i1][i2] == a[i1][ii]) {</span>
<span class="fc" id="L681">                        a[i1][i1 + 1] = a[i1][i2];</span>
                    }
                }
            }
        }

<span class="fc" id="L687">        return a;</span>
    }
    
    protected int distanceSqEucl(int x1, int y1, int x2, int y2) {
<span class="nc" id="L691">        int diffX = x1 - x2;</span>
<span class="nc" id="L692">        int diffY = y1 - y2;</span>
<span class="nc" id="L693">        return (diffX * diffX + diffY * diffY);</span>
    }

    private float[][] copy(float[][] a) {
<span class="fc" id="L697">        float[][] a2 = new float[a.length][];</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        for (int i = 0; i &lt; a2.length; ++i) {</span>
<span class="fc" id="L699">            a2[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }
<span class="fc" id="L701">        return a2;</span>
    }

    /**
     * subtract the portion of a2 that is same size as
     * a1 from a1.
     * @param a1
     * @param a2
     * @return
     */
    private float[][] subtract(float[][] a1, float[][] a2) {

        /*
         MXM     NXN
                 20 21 22
         10 11   10 11 12
         00 01   00 01 02

                 01 02 00
         10 11   21 22 20
         00 01   11 12 10

                 12 10 11
         10 11   02 00 01
         00 01   22 20 21

        subtracting only the MXM portion
        */

<span class="pc bnc" id="L730" title="All 2 branches missed.">        assert(a1.length == a1[0].length);</span>
<span class="pc bnc" id="L731" title="All 2 branches missed.">        assert(a2.length == a2[0].length);</span>

<span class="fc" id="L733">        int n1 = a1.length;</span>
<span class="fc" id="L734">        int n2 = a2.length;</span>

<span class="pc bnc" id="L736" title="All 2 branches missed.">        assert(n1 &lt;= n2);</span>

<span class="fc" id="L738">        float[][] output = new float[n1][];</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L740">            output[i] = new float[n1];</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L742">                float v = a1[i][j] - a2[i][j];</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">                if (v &lt; 0) {</span>
<span class="fc" id="L744">                    v *= -1;</span>
                }
<span class="fc" id="L746">                output[i][j] = v;</span>
            }
        }

<span class="fc" id="L750">        return output;</span>
    }

    private void print(String label, float[][][] a) {
<span class="nc bnc" id="L754" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L755">            print(label + &quot; off &quot; + i, a[i]);</span>
        }
<span class="nc" id="L757">    }</span>

    private void print(String label, float[][] a) {

<span class="nc" id="L761">        StringBuilder sb = new StringBuilder(label);</span>
<span class="nc" id="L762">        sb.append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L765">            sb.append(String.format(&quot;row %3d: &quot;, i));</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            for (int j = 0; j &lt; a[i].length; ++j) {</span>
<span class="nc" id="L767">                sb.append(String.format(&quot; %.2f,&quot;, a[i][j]));</span>
            }
<span class="nc" id="L769">            log.fine(sb.toString());</span>
<span class="nc" id="L770">            System.out.println(sb.toString());</span>
<span class="nc" id="L771">            sb.delete(0, sb.length());</span>
        }
<span class="nc" id="L773">    }</span>

    private double calcSalukDist(double compChord, double maxChord,
        int length, int maxLength) {

        //NOTE: compChord is the (chordSum/length)
        
<span class="fc" id="L780">        double d = compChord/maxChord;</span>
<span class="fc" id="L781">        double f = 1. - ((double)length/(double)maxLength);</span>
<span class="fc" id="L782">        return f*f + d*d;</span>
    }

    @SuppressWarnings({&quot;fallthrough&quot;})
    private PairIntArray createLine2(int n1) {

        /*
            - -
        - - 
        */
<span class="nc" id="L792">        PairIntArray q = new PairIntArray(n1);</span>
<span class="nc" id="L793">        int prevX = 0;</span>
<span class="nc" id="L794">        int prevY = 0;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            switch (i % 2) {</span>
                case 0:
<span class="nc" id="L798">                    prevY++;</span>
                default:
<span class="nc" id="L800">                    prevX++;</span>
                    break;
            }
<span class="nc" id="L803">            q.add(prevX, prevY);</span>
        }
<span class="nc" id="L805">        return q;</span>
    }
    
    @SuppressWarnings({&quot;fallthrough&quot;})
    private PairIntArray createLine4(int n1) {

        /*
              - - -
        - - - 
        */
<span class="nc" id="L815">        PairIntArray q = new PairIntArray(n1);</span>
<span class="nc" id="L816">        int prevX = 0;</span>
<span class="nc" id="L817">        int prevY = 0;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            switch (i % 3) {</span>
                case 0:
<span class="nc" id="L821">                    prevY++;</span>
                default:
<span class="nc" id="L823">                    prevX++;</span>
                    break;
            }
<span class="nc" id="L826">            q.add(prevX, prevY);</span>
        }
<span class="nc" id="L828">        return q;</span>
    }

    private PairIntArray createLine3(int n1) {

        /*
              - -
          - -
        - 
        */
<span class="nc" id="L838">        PairIntArray q = createLine2(n1);</span>
<span class="nc" id="L839">        q.rotateLeft(-1);</span>
<span class="nc" id="L840">        return q;</span>
    }
    
    private PairIntArray createLine5(int n1) {
<span class="nc" id="L844">        PairIntArray q = createLine4(n1);</span>
<span class="nc" id="L845">        q.rotateLeft(-1);</span>
<span class="nc" id="L846">        return q;</span>
    }
    
    private PairIntArray createLine6(int n1) {
<span class="nc" id="L850">        PairIntArray q = createLine4(n1);</span>
<span class="nc" id="L851">        q.rotateLeft(-2);</span>
<span class="nc" id="L852">        return q;</span>
    }

    private TwoDFloatArray[] createSummedDifferences(PairIntArray p) {
        
        //log.fine(&quot;a1:&quot;);
<span class="fc" id="L858">        float[][] a1 = createDescriptorMatrix(p, p.getN());</span>

<span class="fc" id="L860">        int na2 = 1;//3;</span>
        
<span class="fc" id="L862">        TwoDFloatArray[] mds = new TwoDFloatArray[na2];</span>
        
<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (int a2i = 0; a2i &lt; na2; ++a2i) {</span>
<span class="fc" id="L865">            float[][] md = createDifferenceMatrices(a1, a2i);</span>
            //convert to summed column table
<span class="fc" id="L867">            SummedColumnTable smt = new SummedColumnTable();</span>
<span class="fc" id="L868">            mds[a2i] = new TwoDFloatArray(smt.create(md));</span>
        }      
        
<span class="fc" id="L871">        return mds;</span>
    }

    public static class LineResult {

        List&lt;PairInt&gt; lineIndexRanges = new ArrayList&lt;PairInt&gt;();

        TIntSet junctionIndexes = null;
        
        public LineResult() {
        }

        /**
         * add start and stop index ranges for a found line segment
         * @param startStop
         */
        public void addLineRange(PairInt startStop) {
            lineIndexRanges.add(startStop);
        }

        public List&lt;PairInt&gt; getLineIndexRanges() {
            return lineIndexRanges;
        }
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MSERMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.matching</a> &gt; <span class="el_source">MSERMatcher.java</span></div><h1>MSERMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.matching;

import algorithms.FixedSizeSortedVector;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.features.CorrespondenceList;
import algorithms.imageProcessing.features.HOGRegionsManager;
import algorithms.imageProcessing.features.HOGsManager;
import algorithms.imageProcessing.features.ObjectMatcher.Settings;
import algorithms.imageProcessing.features.mser.Canonicalizer;
import algorithms.imageProcessing.features.mser.Canonicalizer.CRegion;
import algorithms.packing.Intersection2DPacking;
import algorithms.util.PairInt;
import algorithms.util.PixelHelper;
import algorithms.util.QuadInt;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.iterator.TLongIterator;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TLongSet;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A class to match objects as regions defined by MSER.
 * The matching method uses Histograms of Oriented Gradients (HOGs).
 *
 * @author nichole
 */
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">public class MSERMatcher {</span>

<span class="fc" id="L37">    private boolean debug = false;</span>
    
<span class="fc" id="L39">    private int N_PIX_PER_CELL_DIM = 3;</span>
<span class="fc" id="L40">    private int N_CELLS_PER_BLOCK_DIM = 3;</span>
<span class="fc" id="L41">    private int N_ANGLE_BINS = 9;</span>
<span class="fc" id="L42">    private int N_HIST_BINS = 12;</span>
    
<span class="fc" id="L44">    private static float eps = 0.000001f;</span>

    public void setToDebug() {
<span class="nc" id="L47">        debug = true;</span>
<span class="nc" id="L48">    }</span>
    
    /**
     * This method is a work in progress.  
     * It uses Histogram of Oriented Gradients, histograms of 
     * images of cie luv converted to the polar angle, and
     * histograms of greyscale intensity to find the object in
     * regionPoints0 in the MSER regions of regionPoints1.
     * 
     * The method uses a cell size for the histograms and the results
     * are sensitive to that.
     * The input images have been pre-processed in several ways.
     * The images are binned down with preserved aspect ratios to an image 
     * size such that the largest of width or height is 256 or smaller.
     * 
     * Then ObjectMatcher.findObject12 is used.
     * ObjectMatcher.findObject12 creates the polar theta images and
     * then looks at the general black, white or other characteristics
     * of the template object in dataset0 to determine which MSER 
     * methods should be used (MSER has a positive and negative image 
     * search and several parameters that affect the threshold of the
     * results).
     * The dataset1 MSER regions are filtered to remove those very 
     * different in color than the template object.
     * Both MSER regions are then filtered to keep the strongest mser
     * when there are overlapping mser regions.
     * The results given to this method here are 3 or so mser for dataset0
     * and about 40 or less MSER for dataset1.
     * 
     * The sensitivity of ObjectMatcher.findObject12 and this method to image 
     * resolution and size mean that use of this method should probably be 
     * wrapped in a class that handles resolution and size logic in 
     * pre-processing steps.
     * Note that there may also be some color filter properties that would
     * need to change for extreme cases.
     * 
     * @param pyrRGB0
     * @param pyrPT0
     * @param regionPoints0
     * @param pyrRGB1
     * @param pyrPT1
     * @param regionPoints1
     * @param settings
     * @return 
     */
    public List&lt;CorrespondenceList&gt; matchObject0(
        CMODE clrMode0,
        List&lt;List&lt;GreyscaleImage&gt;&gt; pyrRGB0, List&lt;GreyscaleImage&gt; pyrPT0, 
        TIntObjectMap&lt;Canonicalizer.RegionPoints&gt; regionPoints0, 
        List&lt;List&lt;GreyscaleImage&gt;&gt; pyrRGB1, List&lt;GreyscaleImage&gt; pyrPT1, 
        TIntObjectMap&lt;Canonicalizer.RegionPoints&gt; regionPoints1, 
        Settings settings) {
            
<span class="fc" id="L101">        TIntObjectMap&lt;HOGRegionsManager&gt; hogsMap0 </span>
            = new TIntObjectHashMap&lt;HOGRegionsManager&gt;();
<span class="fc" id="L103">        TIntObjectMap&lt;HOGRegionsManager&gt; hogsMap1 </span>
            = new TIntObjectHashMap&lt;HOGRegionsManager&gt;();

        // a reference to the regions, is same as what the HOGRegions etc hold
<span class="fc" id="L107">        List&lt;TIntObjectMap&lt;CRegion&gt;&gt; cRegionsList0 = createList(pyrRGB0.size());</span>
<span class="fc" id="L108">        List&lt;TIntObjectMap&lt;CRegion&gt;&gt; cRegionsList1 = createList(pyrRGB1.size());</span>
               
<span class="fc" id="L110">        int n0 = pyrPT0.size();</span>
<span class="fc" id="L111">        int n1 = pyrPT1.size();</span>

<span class="fc" id="L113">        int w0 = pyrPT0.get(0).getWidth();</span>
<span class="fc" id="L114">        int h0 = pyrPT0.get(0).getHeight();</span>
<span class="fc" id="L115">        int w1 = pyrPT1.get(0).getWidth();</span>
<span class="fc" id="L116">        int h1 = pyrPT1.get(0).getHeight();</span>
              
<span class="fc" id="L118">        float sizeFactor = 1.2f;//2;//1.2f;</span>

<span class="fc" id="L120">        FixedSizeSortedVector&lt;Obj&gt; bestOverallA =</span>
            //new FixedSizeSortedVector&lt;Obj&gt;(100, Obj.class);
            new FixedSizeSortedVector&lt;Obj&gt;(n0, Obj.class);
           
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (int pyrIdx0 = 0; pyrIdx0 &lt; n0; ++pyrIdx0) {</span>

<span class="fc" id="L126">            GreyscaleImage gsI0 = combineImages(pyrRGB0.get(pyrIdx0));</span>
<span class="fc" id="L127">            GreyscaleImage ptI0 = pyrPT0.get(pyrIdx0);</span>

<span class="fc" id="L129">            int w0_i = ptI0.getWidth();</span>
<span class="fc" id="L130">            int h0_i = ptI0.getHeight();</span>
<span class="pc bpc" id="L131" title="3 of 4 branches missed.">            assert(gsI0.getWidth() == w0_i);</span>
<span class="pc bpc" id="L132" title="3 of 4 branches missed.">            assert(gsI0.getHeight() == h0_i);</span>
<span class="fc" id="L133">            float scale0 = (</span>
                ((float) w0 / (float) w0_i)
                + ((float) h0 / (float) h0_i)) / 2.f;

<span class="fc" id="L137">            TIntObjectMap&lt;CRegion&gt; regions0 = cRegionsList0.get(pyrIdx0);</span>
            
            // instantiate and cache hogs0 if doesn't exist
<span class="fc" id="L140">            HOGRegionsManager hogsMgr0 = getOrCreate(hogsMap0, regions0, </span>
                w0_i, h0_i, pyrIdx0);
            
<span class="pc bpc" id="L143" title="3 of 4 branches missed.">            assert(regionPoints0.size() &gt; 0);</span>
            
<span class="fc" id="L145">            hogsMgr0.populateRegionsIfNeeded(</span>
                regionPoints0, scale0, hogsMgr0, gsI0, ptI0);
            
<span class="fc" id="L148">            int nr0 = regions0.size();</span>
<span class="pc bpc" id="L149" title="3 of 4 branches missed.">            assert(nr0 &gt; 0);</span>
            
<span class="fc" id="L151">            FixedSizeSortedVector&lt;Obj&gt; bestPerOctave =</span>
                //new FixedSizeSortedVector&lt;Obj&gt;(2, Obj.class);
                new FixedSizeSortedVector&lt;Obj&gt;(1, Obj.class);
            
<span class="fc" id="L155">            int maxArea0 = getLargestArea(regions0);</span>
            
<span class="fc bfc" id="L157" title="All 2 branches covered.">            for (int pyrIdx1 = 0; pyrIdx1 &lt; n1; ++pyrIdx1) {</span>

<span class="fc" id="L159">                GreyscaleImage gsI1 = combineImages(pyrRGB1.get(pyrIdx1));</span>
<span class="fc" id="L160">                GreyscaleImage ptI1 = pyrPT1.get(pyrIdx1);</span>

<span class="fc" id="L162">                int w1_i = ptI1.getWidth();</span>
<span class="fc" id="L163">                int h1_i = ptI1.getHeight();</span>
<span class="fc" id="L164">                float scale1 = (((float) w1 / (float) w1_i)</span>
                    + ((float) h1 / (float) h1_i)) / 2.f;

<span class="fc" id="L167">                TIntObjectMap&lt;CRegion&gt; regions1 = cRegionsList1.get(pyrIdx1);</span>
                
                // instantiate and cache hogs0 if doesn't exist
                // instantiate and cache hogs0 if doesn't exist
<span class="fc" id="L171">                HOGRegionsManager hogsMgr1 = getOrCreate(hogsMap1, regions1, </span>
                    w1_i, h1_i, pyrIdx1);
            
<span class="fc" id="L174">                hogsMgr1.populateRegionsIfNeeded(</span>
                    regionPoints1, scale1, hogsMgr1, gsI1, ptI1);
                
<span class="fc" id="L177">                int nr1 = regions1.size();</span>
<span class="pc bpc" id="L178" title="3 of 4 branches missed.">                assert(nr1 &gt; 0);</span>
                 
<span class="fc" id="L180">                TIntObjectIterator&lt;CRegion&gt; iter0 = regions0.iterator();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                for (int i0 = 0; i0 &lt; nr0; ++i0) {</span>
                    
<span class="fc" id="L183">                    iter0.advance();</span>
                    
<span class="fc" id="L185">                    int rIdx0 = iter0.key();</span>
                    
<span class="fc" id="L187">                    CRegion cr0 = iter0.value();</span>
      
<span class="fc" id="L189">                    int sz0 = calculateObjectSizeByAvgDist(</span>
                        cr0.ellipseParams.xC, cr0.ellipseParams.yC,
<span class="fc" id="L191">                        cr0.getPixelCoords(), w0_i );</span>

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                    if (sz0 == 0) {</span>
<span class="nc" id="L194">                        continue;</span>
                    }
                    
                    /*
                    CMODE cmode0 = CMODE.determineColorMode(
                        pyrRGB0.get(pyrIdx0).get(0),
                        pyrRGB0.get(pyrIdx0).get(1), pyrRGB0.get(pyrIdx0).get(2),
                        cr0.offsetsToOrigCoords.values());
                    CMODE cmodeLUV0 = CMODE.determinePolarThetaMode(ptI0, 
                        cr0.offsetsToOrigCoords.values());
                    System.out.println(&quot;cmode0=&quot; + cmode0.name() + &quot;, &quot; + 
                        cmodeLUV0);
                    */
                    
                    //int area0_full = csr0.get(0).get(rIdx0).offsetsToOrigCoords.size();
<span class="fc" id="L209">                    TIntObjectIterator&lt;CRegion&gt; iter1 = regions1.iterator();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                    for (int i1 = 0; i1 &lt; nr1; ++i1) {</span>
                        
<span class="fc" id="L212">                        iter1.advance();</span>
                        
                        // because these regions were made w/ hog orientations,
                        // there may be multiple regions with the same 
                        // original rIdx1 stored as cr.dataIdx, but having
                        // a different rIdx1 here.
                        // so cr.dataIdx is used below for the identity to keep
                        // the best match for the cr.dataIdx (== original rIdx)
<span class="fc" id="L220">                        int rIdx1 = iter1.key();</span>
<span class="fc" id="L221">                        CRegion cr1 = iter1.value();</span>

<span class="fc" id="L223">                        int sz1 = calculateObjectSizeByAvgDist(</span>
                            cr1.ellipseParams.xC, cr1.ellipseParams.yC,
<span class="fc" id="L225">                            cr1.getPixelCoords(), w1_i);</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                        if (sz1 == 0) {</span>
<span class="nc" id="L228">                            continue;</span>
                        }
                        
                        /*
                        int xp0 = -1; int yp0 = -1; int xp1 = -1; int yp1 = -1;
                        if (debug) {
                            float scale00 = (((float) w0 / (float) w0_i) + ((float) h0 / (float) h0_i)) / 2.f;
                            float scale01 = (((float) w1 / (float) w1_i) + ((float) h1 / (float) h1_i)) / 2.f;                
                            xp0 = (int)Math.round(scale00 * cr0.ellipseParams.xC);
                            yp0 = (int)Math.round(scale00 * cr0.ellipseParams.yC);
                            xp1 = (int)Math.round(scale01 * cr1.ellipseParams.xC);
                            yp1 = (int)Math.round(scale01 * cr1.ellipseParams.yC);
                        }*/
                        
                        // size filter
<span class="fc bfc" id="L243" title="All 8 branches covered.">                        if ((sz1 &gt; sz0 &amp;&amp; ((sz1 / sz0) &gt; sizeFactor))</span>
                            || (sz0 &gt; sz1 &amp;&amp; ((sz0 / sz1) &gt; sizeFactor))) {
                            
                            //System.out.format(
                            //    &quot;  REMOVING (%d,%d) where sz0=%d sz1=%d\n&quot;,
                            //    xp1, yp1, sz0, sz1);
                            
<span class="fc" id="L250">                            continue;</span>
                        }
                                                   
<span class="fc" id="L253">                        Intersection2DPacking ip = new Intersection2DPacking();</span>
<span class="fc" id="L254">                        Set&lt;PairInt&gt; intersectingOffsetKeys = ip.intersection(</span>
<span class="fc" id="L255">                            cr0.getOffsetKeys(), cr1.getOffsetKeys());</span>
<span class="fc" id="L256">                        Set&lt;PairInt&gt; offsets0 = ip.naiveStripPacking(</span>
                            intersectingOffsetKeys, N_PIX_PER_CELL_DIM);
                        
                        //DEBUG
                        /*{
                            Image tmp = gsI1.copyToColorGreyscale();
                            for (Entry&lt;PairInt, PairInt&gt; entry : 
                                cr1.getOffsetsToOrigCoords().entrySet()) {
                                ImageIOHelper.addPointToImage(entry.getValue().getX(),
                                    entry.getValue().getY(), tmp,
                                    1, 255, 0, 0);
                            };
                            MiscDebug.writeImage(tmp, &quot;_DBG_&quot; 
                                + pyrIdx0 + &quot;_&quot; + i0 + &quot;__&quot; + pyrIdx1 + &quot;_&quot; + i1);
                        }
                        {
                            System.out.println(&quot;intersectionKeys.size=&quot; +
                                intersectingOffsetKeys.size() + 
                                &quot; offsets0.size=&quot; + offsets0.size());
                            
                            for (PairInt p : offsets0) {
                                assert(intersectingOffsetKeys.contains(p));
                            }
                        }*/

<span class="fc" id="L281">                        Obj obj = calculateHOGCosts(offsets0, intersectingOffsetKeys.size(), </span>
                            hogsMgr0, cr0, scale0, rIdx0, pyrIdx0,
                            hogsMgr1, cr1, scale1, rIdx1, pyrIdx1);
                        
<span class="fc bfc" id="L285" title="All 2 branches covered.">                        if (obj == null) {</span>
<span class="fc" id="L286">                            continue;</span>
                        }
<span class="fc" id="L288">                        boolean added = bestPerOctave.add(obj);</span>
                        
<span class="fc" id="L290">                        int x0 = Math.round(scale0 * obj.cr0.ellipseParams.xC);</span>
<span class="fc" id="L291">                        int y0 = Math.round(scale0 * obj.cr0.ellipseParams.yC);</span>
<span class="fc" id="L292">                        int x1 = Math.round(scale1 * obj.cr1.ellipseParams.xC);</span>
<span class="fc" id="L293">                        int y1 = Math.round(scale1 * obj.cr1.ellipseParams.yC);</span>

                        //NOTE: may need to consider the best match
                        //  for each rIdx, that is, consider multiple 
                        //  orientations for a region rather than keeping
                        //  the best orienation for a region only
                        
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">                        if (debug) {</span>

                            String arrow;
<span class="nc bnc" id="L303" title="All 2 branches missed.">                            if (added) {</span>
<span class="nc" id="L304">                                arrow = &quot;==&gt;&quot;;</span>
                            } else {
<span class="nc" id="L306">                                arrow = &quot;   &quot;;</span>
                            }
<span class="nc" id="L308">                            System.out.format(</span>
                            &quot;%s octave %d %d] %s (%d,%d;%d) best: %.4f (%d,%d;%d) [%.3f,%.3f,%.3f,%.3f,%.3f] n=%d\n&quot;,
<span class="nc" id="L310">                            settings.getDebugLabel(), pyrIdx0, pyrIdx1,</span>
<span class="nc" id="L311">                            arrow, x1, y1, obj.cr1.hogOrientation,</span>
<span class="nc" id="L312">                            (float) obj.cost, x0, y0, </span>
<span class="nc" id="L313">                            obj.cr0.hogOrientation,</span>
<span class="nc" id="L314">                            (float) obj.costs[0], (float) obj.costs[1], </span>
<span class="nc" id="L315">                            (float) obj.costs[2], (float) obj.costs[3], </span>
<span class="nc" id="L316">                            (float) obj.costs[4], </span>
<span class="nc" id="L317">                            obj.nMatched</span>
                            );
                        }
                    }
                }
            } // end over dataset1 octaves
            
            // temporarily print the best of each octave0 to look at 
            //    scale biases
<span class="fc bfc" id="L326" title="All 2 branches covered.">            for (int k = 0; k &lt; bestPerOctave.getNumberOfItems(); ++k) {</span>
<span class="fc" id="L327">                Obj obj0 = bestPerOctave.getArray()[k];                               </span>
<span class="fc" id="L328">                bestOverallA.add(obj0);</span>
            }
        }
       
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (bestOverallA.getNumberOfItems() == 0) {</span>
<span class="nc" id="L333">            return null;</span>
        }
        // re-calculating fraction of whole:
<span class="fc" id="L336">        int maxN = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        for (int i = 0; i &lt; bestOverallA.getNumberOfItems(); ++i) {</span>
<span class="fc" id="L338">            Obj objB = bestOverallA.getArray()[i];</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (objB.nMatched &gt; maxN) {</span>
<span class="fc" id="L340">                maxN = objB.nMatched;</span>
            }
        }
        
<span class="fc" id="L344">        Map&lt;QuadInt, Obj&gt; bestCombined = new HashMap&lt;QuadInt, Obj&gt;();        </span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for (int i = 0; i &lt; bestOverallA.getNumberOfItems(); ++i) {</span>
<span class="fc" id="L346">            Obj objB = bestOverallA.getArray()[i];</span>
            
<span class="fc" id="L348">            double f = 1. - (objB.nMatched/(double)maxN);</span>
<span class="fc" id="L349">            objB.cost = (float) Math.sqrt(</span>
                objB.costs[0] * objB.costs[0]
                //+ 2. * f * f
                + f * f
                + objB.costs[1] * objB.costs[1]
                + objB.costs[2] * objB.costs[2]
            );         
                        
<span class="fc" id="L357">            int imgIdx0 = objB.imgIdx0;</span>
<span class="fc" id="L358">            int imgIdx1 = objB.imgIdx1;</span>
<span class="fc" id="L359">            GreyscaleImage gsI0 = pyrRGB0.get(imgIdx0).get(1);</span>
<span class="fc" id="L360">            GreyscaleImage gsI1 = pyrRGB1.get(imgIdx1).get(1);            </span>
<span class="fc" id="L361">            int w0_i = gsI0.getWidth();</span>
<span class="fc" id="L362">            int h0_i = gsI0.getHeight();</span>
<span class="fc" id="L363">            float scale0 = (((float)w0/(float)w0_i) + ((float)h0/(float)h0_i))/2.f;</span>
<span class="fc" id="L364">            int w1_i = gsI1.getWidth();</span>
<span class="fc" id="L365">            int h1_i = gsI1.getHeight();</span>
<span class="fc" id="L366">            float scale1 = (((float)w1/(float)w1_i) + ((float)h1/(float)h1_i))/2.f;</span>
<span class="fc" id="L367">            int x0 = Math.round(scale0 * objB.cr0.ellipseParams.xC);</span>
<span class="fc" id="L368">            int y0 = Math.round(scale0 * objB.cr0.ellipseParams.yC);</span>
<span class="fc" id="L369">            int x1 = Math.round(scale1 * objB.cr1.ellipseParams.xC);</span>
<span class="fc" id="L370">            int y1 = Math.round(scale1 * objB.cr1.ellipseParams.yC);</span>
<span class="fc" id="L371">            QuadInt q = new QuadInt(x0, y0, x1, y1);</span>
<span class="fc" id="L372">            Obj existing = bestCombined.get(q);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (existing != null) {</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (existing.cost &gt; objB.cost){</span>
<span class="fc" id="L375">                    bestCombined.put(q, objB);</span>
                }
            } else {
<span class="fc" id="L378">                bestCombined.put(q, objB);</span>
            }
            
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (debug) {</span>
                //hogCost, f, hcptHgsCost, f0, f1, costHCPT, costHGS
<span class="nc" id="L383">                String lbl = &quot;_&quot; + objB.imgIdx0 + &quot;_&quot; + objB.imgIdx1 + &quot;_&quot;</span>
                    + objB.r0Idx + &quot;_&quot; + objB.r1Idx;
<span class="nc" id="L385">                System.out.format(</span>
                    &quot;_final) %s %d (%d,%d) best: %.4f (%d,%d) %s [%.3f,%.3f,%.3f,%.3f,%.3f] n=%d\n&quot;,
<span class="nc" id="L387">                    settings.getDebugLabel(), i, x1, y1,</span>
<span class="nc" id="L388">                    (float) objB.cost, x0, y0, lbl,</span>
<span class="nc" id="L389">                    (float) objB.costs[0], (float) objB.costs[1],</span>
<span class="nc" id="L390">                    (float) objB.costs[2], (float) objB.costs[3],</span>
<span class="nc" id="L391">                    (float) objB.costs[4],</span>
<span class="nc" id="L392">                    objB.nMatched</span>
                );    
            }
        }
        
<span class="fc" id="L397">        List&lt;Obj&gt; bestOverall = new ArrayList&lt;Obj&gt;();</span>
<span class="fc" id="L398">        bestOverall.addAll(bestCombined.values());</span>
<span class="fc" id="L399">        Collections.sort(bestOverall, new CostComparator());</span>
                
<span class="fc" id="L401">        Set&lt;PairInt&gt; pairs = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L402">        List&lt;CorrespondenceList&gt; out = new ArrayList&lt;CorrespondenceList&gt;();</span>
        
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (int i = 0; i &lt; bestOverall.size(); ++i) {</span>
            
<span class="fc" id="L406">            List&lt;QuadInt&gt; qs = new ArrayList&lt;QuadInt&gt;();</span>
            
<span class="fc" id="L408">            Obj obj = bestOverall.get(i);</span>
            
<span class="fc" id="L410">            PairInt pair = new PairInt(obj.r0Idx, obj.r1Idx);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">            if (!pairs.add(pair)) {</span>
<span class="fc" id="L412">                continue;</span>
            }
            
<span class="fc" id="L415">            int imgIdx0 = obj.imgIdx0;</span>
<span class="fc" id="L416">            int imgIdx1 = obj.imgIdx1;</span>
            
<span class="fc" id="L418">            GreyscaleImage gsI0 = pyrRGB0.get(imgIdx0).get(1);</span>
<span class="fc" id="L419">            GreyscaleImage gsI1 = pyrRGB1.get(imgIdx1).get(1);</span>
            
            float scale0, scale1;
<span class="fc" id="L422">            int w0_i = gsI0.getWidth();</span>
<span class="fc" id="L423">            int h0_i = gsI0.getHeight();</span>
<span class="fc" id="L424">            scale0 = (((float)w0/(float)w0_i) + ((float)h0/(float)h0_i))/2.f;</span>

<span class="fc" id="L426">            int w1_i = gsI1.getWidth();</span>
<span class="fc" id="L427">            int h1_i = gsI1.getHeight();</span>
<span class="fc" id="L428">            scale1 = (((float)w1/(float)w1_i) + ((float)h1/(float)h1_i))/2.f;                </span>
            
            // NOTE: for now, just mser centers,
            // but should fill out more than this, including centroid of points
            
<span class="fc" id="L433">            int x0 = Math.round(scale0 * obj.cr0.ellipseParams.xC);</span>
<span class="fc" id="L434">            int y0 = Math.round(scale0 * obj.cr0.ellipseParams.yC);</span>
<span class="fc" id="L435">            int x1 = Math.round(scale1 * obj.cr1.ellipseParams.xC);</span>
<span class="fc" id="L436">            int y1 = Math.round(scale1 * obj.cr1.ellipseParams.yC);</span>
<span class="fc" id="L437">            QuadInt q = new QuadInt(x0, y0, x1, y1);</span>
<span class="fc" id="L438">            qs.add(q);</span>
            
<span class="fc" id="L440">            CorrespondenceList cor = new CorrespondenceList(qs);</span>
<span class="fc" id="L441">            out.add(cor);</span>
            
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            if (debug) {</span>
                //hogCost, f, hcptHgsCost, f0, f1, costHCPT, costHGS
<span class="nc" id="L445">                String lbl = &quot;_&quot; + obj.imgIdx0 + &quot;_&quot; + obj.imgIdx1 + &quot;_&quot;</span>
                    + obj.r0Idx + &quot;_&quot; + obj.r1Idx;
<span class="nc" id="L447">                System.out.format(</span>
                    &quot;final) %s %d (%d,%d) best: %.4f (%d,%d) %s [%.3f,%.3f,%.3f,%.3f,%.3f] n=%d\n&quot;,
<span class="nc" id="L449">                    settings.getDebugLabel(), i, x1, y1,</span>
<span class="nc" id="L450">                    (float) obj.cost, x0, y0, lbl,</span>
<span class="nc" id="L451">                    (float) obj.costs[0], (float) obj.costs[1],</span>
<span class="nc" id="L452">                    (float) obj.costs[2], (float) obj.costs[3],</span>
<span class="nc" id="L453">                    (float) obj.costs[4],</span>
<span class="nc" id="L454">                    obj.nMatched</span>
                );               
            }
        }
            
<span class="fc" id="L459">        return out;</span>
    }
   
    
    private GreyscaleImage combineImages(List&lt;GreyscaleImage&gt; rgb) {

<span class="fc" id="L465">        GreyscaleImage r = rgb.get(0);</span>
<span class="fc" id="L466">        GreyscaleImage g = rgb.get(1);</span>
<span class="fc" id="L467">        GreyscaleImage b = rgb.get(2);</span>

<span class="pc bpc" id="L469" title="2 of 4 branches missed.">        if (r.getWidth() != g.getWidth() || r.getWidth() != b.getWidth() ||</span>
<span class="pc bpc" id="L470" title="2 of 4 branches missed.">            r.getHeight() != g.getHeight() || r.getHeight() != b.getHeight()) {</span>
<span class="nc" id="L471">            throw new IllegalArgumentException(&quot;r, g, and b must have same&quot;</span>
                + &quot; width and height&quot;);
        }

<span class="fc" id="L475">        int w = r.getWidth();</span>
<span class="fc" id="L476">        int h = r.getHeight();</span>

<span class="fc" id="L478">        GreyscaleImage comb = new GreyscaleImage(w, h, r.getType());</span>

<span class="fc bfc" id="L480" title="All 2 branches covered.">        for (int i = 0; i &lt; r.getNPixels(); ++i) {</span>
<span class="fc" id="L481">            float v0 = r.getValue(i);</span>
<span class="fc" id="L482">            float v1 = g.getValue(i);</span>
<span class="fc" id="L483">            float v2 = b.getValue(i);</span>
<span class="fc" id="L484">            float avg = (v0 + v1 + v2)/3.f;</span>

<span class="fc" id="L486">            comb.setValue(i, Math.round(avg));</span>
        }

<span class="fc" id="L489">        return comb;</span>
    }

    private int calculateObjectSizeByAvgDist(int x, int y, 
        TLongSet pixCoords, int imageWidth) {

<span class="fc" id="L495">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L496">        int[] xy = new int[2];</span>
        
<span class="fc" id="L498">        TLongIterator iter = pixCoords.iterator();</span>
        
<span class="fc" id="L500">        int sumD = 0;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L502">            long pix = iter.next();</span>
<span class="fc" id="L503">            ph.toPixelCoords(pix, imageWidth, xy);</span>
<span class="fc" id="L504">            int diffX = xy[0] - x;</span>
<span class="fc" id="L505">            int diffY = xy[1] - y;</span>
<span class="fc" id="L506">            sumD += (diffX * diffX + diffY * diffY);</span>
<span class="fc" id="L507">        }</span>
<span class="fc" id="L508">        sumD = (int)Math.ceil(Math.sqrt((double)sumD/(double)pixCoords.size()));</span>
        
<span class="fc" id="L510">        return sumD;</span>
    }
    
    //double[]{sumHOG, sumHCPT, sumHGS, f0, f1, intersectionCount, area0, area1};
    private double[] sumHOGCost(Set&lt;PairInt&gt; offsets0, int intersectionCount,
        HOGRegionsManager hogMgr0, CRegion cr0, 
        HOGRegionsManager hogMgr1, CRegion cr1) {
                
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        if (offsets0.isEmpty()) {</span>
<span class="nc" id="L519">            return null;</span>
        }

<span class="pc bpc" id="L522" title="3 of 4 branches missed.">        assert(cr0.dataIdx != -1);</span>
<span class="pc bpc" id="L523" title="3 of 4 branches missed.">        assert(cr1.dataIdx != -1);</span>
        
<span class="fc" id="L525">        int orientation0 = cr0.hogOrientation;</span>
<span class="fc" id="L526">        int orientation1 = cr1.hogOrientation;</span>
        
<span class="fc" id="L528">        Map&lt;PairInt, PairInt&gt; offsetMap1 = cr1.getOffsetsToOrigCoords();</span>

<span class="fc" id="L530">        double sumHOG = 0;</span>
<span class="fc" id="L531">        double sumHCPT = 0;</span>
<span class="fc" id="L532">        double sumHGS = 0;</span>
        
<span class="fc" id="L534">        int[] h0 = new int[N_ANGLE_BINS];</span>
<span class="fc" id="L535">        int[] h1 = new int[h0.length];</span>
        
<span class="fc" id="L537">        int[] ha0 = new int[N_HIST_BINS];</span>
<span class="fc" id="L538">        int[] ha1 = new int[ha0.length];</span>
        float intersection;
        // key = transformed offsets, value = coords in image ref frame,
        // so, can compare dataset0 and dataset1 points with same
        //  keys
    
<span class="fc" id="L544">        int count = 0;</span>
        
<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (PairInt pOffset0 : offsets0) {</span>
            
<span class="fc" id="L548">            PairInt xy1 = offsetMap1.get(pOffset0);</span>

<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            if (xy1 == null) {</span>
<span class="nc" id="L551">                continue;</span>
            }

<span class="fc" id="L554">            PairInt xy0 = cr0.getOffsetsToOrigCoords().get(pOffset0);</span>
<span class="pc bpc" id="L555" title="3 of 4 branches missed.">            assert(xy0 != null);</span>
            
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">            if (!hogMgr0.extractBlockHOG(cr0.dataIdx, xy0.getX(), xy0.getY(), h0)) {</span>
<span class="nc" id="L558">                continue;</span>
            }
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">            if (!hogMgr1.extractBlockHOG(cr1.dataIdx, xy1.getX(), xy1.getY(), h1)) {</span>
<span class="nc" id="L561">                continue;</span>
            }
            // 1.0 is perfect similarity
<span class="fc" id="L564">            intersection = hogMgr0.intersection(h0, orientation0, </span>
                h1, orientation1);
<span class="fc" id="L566">            sumHOG += (intersection * intersection);</span>
            
<span class="fc" id="L568">            hogMgr0.extractBlockHCPT(cr0.dataIdx, xy0.getX(), xy0.getY(), ha0);</span>
<span class="fc" id="L569">            hogMgr1.extractBlockHCPT(cr1.dataIdx, xy1.getX(), xy1.getY(), ha1);</span>
            // 1.0 is perfect similarity
<span class="fc" id="L571">            intersection = hogMgr0.intersection(ha0, ha1);</span>
<span class="fc" id="L572">            sumHCPT += (intersection * intersection);</span>
            
<span class="fc" id="L574">            hogMgr0.extractBlockHGS(cr0.dataIdx, xy0.getX(), xy0.getY(), ha0);</span>
<span class="fc" id="L575">            hogMgr1.extractBlockHGS(cr1.dataIdx, xy1.getX(), xy1.getY(), ha1);</span>
            // 1.0 is perfect similarity
<span class="fc" id="L577">            intersection = hogMgr0.intersection(ha0, ha1);</span>
<span class="fc" id="L578">            sumHGS += (intersection * intersection);</span>
            
<span class="fc" id="L580">            count++;</span>
<span class="fc" id="L581">        }</span>
        
<span class="fc" id="L583">        sumHOG /= (double)count;</span>
<span class="fc" id="L584">        sumHOG = Math.sqrt(sumHOG);</span>
        
<span class="fc" id="L586">        sumHCPT /= (double)count;</span>
<span class="fc" id="L587">        sumHCPT = Math.sqrt(sumHCPT);</span>
        
<span class="fc" id="L589">        sumHGS /= (double)count;</span>
<span class="fc" id="L590">        sumHGS = Math.sqrt(sumHGS);</span>
        
<span class="fc" id="L592">        double area1 = cr1.getOffsetsToOrigCoords().size() + eps;</span>
<span class="fc" id="L593">        double f1 = 1. - ((double) intersectionCount / area1);</span>
        
<span class="fc" id="L595">        double area0 = cr0.getOffsetsToOrigCoords().size() + eps;</span>
<span class="fc" id="L596">        double f0 = 1. - ((double) intersectionCount / area0);</span>
        
<span class="fc" id="L598">        return new double[]{sumHOG, sumHCPT, sumHGS, f0, f1, intersectionCount, area0, area1};</span>
    }
    
    private double[] _sumHOGCost(Set&lt;PairInt&gt; offsets0, int intersectionCount,
        HOGsManager _hogMgr0, CRegion cr0, 
        HOGsManager _hogMgr1, CRegion cr1) {
                
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (offsets0.isEmpty()) {</span>
<span class="nc" id="L606">            return null;</span>
        }

<span class="nc bnc" id="L609" title="All 4 branches missed.">        assert(cr0.dataIdx != -1);</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">        assert(cr1.dataIdx != -1);</span>
        
<span class="nc" id="L612">        int orientation0 = cr0.hogOrientation;</span>
<span class="nc" id="L613">        int orientation1 = cr1.hogOrientation;</span>
        
<span class="nc" id="L615">        Map&lt;PairInt, PairInt&gt; offsetMap1 = cr1.getOffsetsToOrigCoords();</span>

<span class="nc" id="L617">        double sumHOG = 0;</span>
<span class="nc" id="L618">        double sumHCPT = 0;</span>
<span class="nc" id="L619">        double sumHGS = 0;</span>
        
<span class="nc" id="L621">        int[] h0 = new int[N_ANGLE_BINS];</span>
<span class="nc" id="L622">        int[] h1 = new int[h0.length];</span>
        
<span class="nc" id="L624">        int[] ha0 = new int[N_HIST_BINS];</span>
<span class="nc" id="L625">        int[] ha1 = new int[ha0.length];</span>
        float intersection;
        // key = transformed offsets, value = coords in image ref frame,
        // so, can compare dataset0 and dataset1 points with same
        //  keys
    
<span class="nc" id="L631">        int count = 0;</span>
        
<span class="nc bnc" id="L633" title="All 2 branches missed.">        for (PairInt pOffset0 : offsets0) {</span>
            
<span class="nc" id="L635">            PairInt xy1 = offsetMap1.get(pOffset0);</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (xy1 == null) {</span>
<span class="nc" id="L638">                continue;</span>
            }

<span class="nc" id="L641">            PairInt xy0 = cr0.getOffsetsToOrigCoords().get(pOffset0);</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">            assert(xy0 != null);</span>
            
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (!_hogMgr0.extractBlockHOG(xy0.getX(), xy0.getY(), h0)) {</span>
<span class="nc" id="L645">                continue;</span>
            }
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (!_hogMgr1.extractBlockHOG(xy1.getX(), xy1.getY(), h1)) {</span>
<span class="nc" id="L648">                continue;</span>
            }
            // 1.0 is perfect similarity
<span class="nc" id="L651">            intersection = _hogMgr0.intersection(h0, orientation0, </span>
                h1, orientation1);
<span class="nc" id="L653">            sumHOG += (intersection * intersection);</span>
            
<span class="nc" id="L655">            _hogMgr0.extractBlockHCPT(xy0.getX(), xy0.getY(), ha0);</span>
<span class="nc" id="L656">            _hogMgr1.extractBlockHCPT(xy1.getX(), xy1.getY(), ha1);</span>
            // 1.0 is perfect similarity
<span class="nc" id="L658">            intersection = _hogMgr0.intersection(ha0, ha1);</span>
<span class="nc" id="L659">            sumHCPT += (intersection * intersection);</span>
            
<span class="nc" id="L661">            _hogMgr0.extractBlockHGS(xy0.getX(), xy0.getY(), ha0);</span>
<span class="nc" id="L662">            _hogMgr1.extractBlockHGS(xy1.getX(), xy1.getY(), ha1);</span>
            // 1.0 is perfect similarity
<span class="nc" id="L664">            intersection = _hogMgr0.intersection(ha0, ha1);</span>
<span class="nc" id="L665">            sumHGS += (intersection * intersection);</span>
            
<span class="nc" id="L667">            count++;</span>
<span class="nc" id="L668">        }</span>
        
<span class="nc" id="L670">        sumHOG /= (double)count;</span>
<span class="nc" id="L671">        sumHOG = Math.sqrt(sumHOG);</span>
        
<span class="nc" id="L673">        sumHCPT /= (double)count;</span>
<span class="nc" id="L674">        sumHCPT = Math.sqrt(sumHCPT);</span>
        
<span class="nc" id="L676">        sumHGS /= (double)count;</span>
<span class="nc" id="L677">        sumHGS = Math.sqrt(sumHGS);</span>
        
<span class="nc" id="L679">        double area1 = cr1.getOffsetsToOrigCoords().size() + eps;</span>
<span class="nc" id="L680">        double f1 = 1. - ((double) intersectionCount / area1);</span>
        
<span class="nc" id="L682">        double area0 = cr0.getOffsetsToOrigCoords().size() + eps;</span>
<span class="nc" id="L683">        double f0 = 1. - ((double) intersectionCount / area0);</span>
        
<span class="nc" id="L685">        return new double[]{sumHOG, sumHCPT, sumHGS, f0, f1, intersectionCount, </span>
            area0, area1};
    }
    
    private HOGRegionsManager getOrCreate(
        TIntObjectMap&lt;HOGRegionsManager&gt; hogsMap, 
        TIntObjectMap&lt;CRegion&gt; cRegions, 
        int imageWidth, int imageHeight, int idx) {
        
<span class="fc" id="L694">        HOGRegionsManager hogs = hogsMap.get(idx);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (hogs != null) {</span>
<span class="fc" id="L696">            return hogs;</span>
        }
        
<span class="fc" id="L699">        hogs = new HOGRegionsManager(cRegions, </span>
            imageWidth, imageHeight, 
            N_CELLS_PER_BLOCK_DIM, N_PIX_PER_CELL_DIM, N_ANGLE_BINS, N_HIST_BINS);
        
<span class="fc" id="L703">        hogsMap.put(idx, hogs);</span>
        
<span class="fc" id="L705">        return hogs;</span>
    }

    private int getLargestArea(TIntObjectMap&lt;CRegion&gt; regions) {
<span class="fc" id="L709">        int area = Integer.MIN_VALUE;    </span>
    
<span class="fc" id="L711">        TIntObjectIterator&lt;CRegion&gt; iter = regions.iterator();</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">        for (int i = 0; i &lt; regions.size(); ++i) {</span>
<span class="fc" id="L713">            iter.advance();</span>
<span class="fc" id="L714">            CRegion cr = iter.value();</span>
<span class="fc" id="L715">            int n = cr.getOffsetsToOrigCoords().size();</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            if (n &gt; area) {</span>
<span class="fc" id="L717">                area = n;</span>
            }
        }
<span class="fc" id="L720">        return area;</span>
    }

    private List&lt;TIntObjectMap&lt;CRegion&gt;&gt; createList(int n) {
<span class="fc" id="L724">        List&lt;TIntObjectMap&lt;CRegion&gt;&gt; out = new ArrayList&lt;TIntObjectMap&lt;CRegion&gt;&gt;();</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L726">            out.add(new TIntObjectHashMap&lt;CRegion&gt;());</span>
        }
<span class="fc" id="L728">        return out;</span>
    }

    private Obj calculateHOGCosts(Set&lt;PairInt&gt; offsets0, int intersectionCount, 
        HOGRegionsManager hogsMgr0, CRegion cr0, float scale0, int rIdx0, int pyrIdx0, 
        HOGRegionsManager hogsMgr1, CRegion cr1, float scale1, int rIdx1, int pyrIdx1) {
        
        //double[]{sumHOG, sumHCPT, sumHGS, f0, f1, 
        //   intersectionCount, area0, area1};      
<span class="fc" id="L737">        double[] hogCosts = sumHOGCost(</span>
            offsets0, intersectionCount, 
            hogsMgr0, cr0, hogsMgr1, cr1);
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (hogCosts == null) {</span>
<span class="nc" id="L741">            return null;</span>
        }
<span class="fc" id="L743">        double hogCost = 1. - hogCosts[0];</span>
<span class="fc" id="L744">        double hcptCost = 1. - hogCosts[1];</span>
<span class="fc" id="L745">        double hgsCost = 1. - hogCosts[2];</span>

        // 1 - fraction of whole (is coverage expressed as a cost)
<span class="fc" id="L748">        double f0 = Math.max(0, hogCosts[3]);</span>
<span class="fc" id="L749">        double f1 = Math.max(0, hogCosts[4]);</span>
<span class="fc bfc" id="L750" title="All 4 branches covered.">        if (f0 &gt; 0.85 || f1 &gt; 0.85) {</span>
<span class="fc" id="L751">            return null;</span>
        }
<span class="fc" id="L753">        double f = (f0 + f1)/2;</span>

<span class="fc" id="L755">        double cost = (float) Math.sqrt(</span>
            hogCost * hogCost
            //+ 2. * f * f
            + f * f
            + hcptCost * hcptCost
            //+ hgsCost * hgsCost
        );

<span class="fc" id="L763">        Obj obj = new Obj();</span>
<span class="fc" id="L764">        obj.cr0 = cr0;</span>
<span class="fc" id="L765">        obj.cr1 = cr1;</span>
<span class="fc" id="L766">        obj.r0Idx = rIdx0;</span>
<span class="fc" id="L767">        obj.r1Idx = rIdx1;</span>
<span class="fc" id="L768">        obj.imgIdx0 = pyrIdx0;</span>
<span class="fc" id="L769">        obj.imgIdx1 = pyrIdx1;</span>
<span class="fc" id="L770">        obj.nMatched = (int) hogCosts[5];</span>
<span class="fc" id="L771">        obj.costs = new double[]{</span>
            hogCost, hcptCost, hgsCost, f0, f1 
        };
<span class="fc" id="L774">        obj.cost = cost;</span>
<span class="fc" id="L775">        obj.f = f;</span>

<span class="fc" id="L777">        return obj;</span>
    }

    private Obj _calculateHOGCosts(Set&lt;PairInt&gt; offsets0, int intersectionCount, 
        HOGsManager _hogsMgr0, CRegion cr0, float scale0, int rIdx0, int pyrIdx0, 
        HOGsManager _hogsMgr1, CRegion cr1, float scale1, int rIdx1, int pyrIdx1) {
        
        //double[]{sumHOG, sumHCPT, sumHGS, f0, f1, 
        //   intersectionCount, area0, area1};      
<span class="nc" id="L786">        double[] hogCosts = _sumHOGCost(</span>
            offsets0, intersectionCount, 
            _hogsMgr0, cr0, _hogsMgr1, cr1);
<span class="nc bnc" id="L789" title="All 2 branches missed.">        if (hogCosts == null) {</span>
<span class="nc" id="L790">            return null;</span>
        }
<span class="nc" id="L792">        double hogCost = 1. - hogCosts[0];</span>
<span class="nc" id="L793">        double hcptCost = 1. - hogCosts[1];</span>
<span class="nc" id="L794">        double hgsCost = 1. - hogCosts[2];</span>

        // 1 - fraction of whole (is coverage expressed as a cost)
<span class="nc" id="L797">        double f0 = Math.max(0, hogCosts[3]);</span>
<span class="nc" id="L798">        double f1 = Math.max(0, hogCosts[4]);</span>
<span class="nc bnc" id="L799" title="All 4 branches missed.">        if (f0 &gt; 0.85 || f1 &gt; 0.85) {</span>
<span class="nc" id="L800">            return null;</span>
        }
<span class="nc" id="L802">        double f = (f0 + f1)/2;</span>

<span class="nc" id="L804">        double cost = (float) Math.sqrt(</span>
            hogCost * hogCost
            //+ 2. * f * f
            + f * f
            + hcptCost * hcptCost
            //+ hgsCost * hgsCost
        );

<span class="nc" id="L812">        Obj obj = new Obj();</span>
<span class="nc" id="L813">        obj.cr0 = cr0;</span>
<span class="nc" id="L814">        obj.cr1 = cr1;</span>
<span class="nc" id="L815">        obj.r0Idx = rIdx0;</span>
<span class="nc" id="L816">        obj.r1Idx = rIdx1;</span>
<span class="nc" id="L817">        obj.imgIdx0 = pyrIdx0;</span>
<span class="nc" id="L818">        obj.imgIdx1 = pyrIdx1;</span>
<span class="nc" id="L819">        obj.nMatched = (int) hogCosts[5];</span>
<span class="nc" id="L820">        obj.costs = new double[]{</span>
            hogCost, hcptCost, hgsCost, f0, f1 
        };
<span class="nc" id="L823">        obj.cost = cost;</span>
<span class="nc" id="L824">        obj.f = f;</span>

<span class="nc" id="L826">        return obj;</span>
    }

    private static class CostComparator implements Comparator&lt;Obj&gt; {
        public CostComparator() {
        }
        @Override
        public int compare(Obj o1, Obj o2) {
            return o1.compareTo(o2);
        }
    }

    /* NOTE: recalculating this worsens the solutions.
    Using the MSER originally determined ellipse parameters has better
    results for the small number of tests here
    private void recalcOrientationAndTrans(HOGs hogs, 
        TIntObjectMap&lt;CRegion&gt; regions, GreyscaleImage gsImg, float scale) {
        
        MiscellaneousCurveHelper ch = new MiscellaneousCurveHelper();
        
        TIntObjectIterator&lt;CRegion&gt; iter = regions.iterator();
        for (int i = 0; i &lt; regions.size(); ++i) {
            iter.advance();
            int rIdx = iter.key();
            CRegion cr = iter.value();
            
            int orientation = hogs.calculateDominantOrientation(
                cr.offsetsToOrigCoords.values());

            Collection&lt;PairInt&gt; xyp = cr.offsetsToOrigCoords.values();
            
            PairIntArray xy = Misc.convertWithoutOrder(xyp);
            
            PairInt xyCen = ch.calculateXYCentroids2(xyp);
            
            cr.ellipseParams.orientation = Math.PI * orientation/180.;
            cr.ellipseParams.xC = xyCen.getX();
            cr.ellipseParams.yC = xyCen.getY();
            
            Map&lt;PairInt, PairInt&gt; offsetToOrigMap = 
                Canonicalizer.createOffsetToOrigMap(
                xyCen.getX(), xyCen.getY(), 
                xy, gsImg.getWidth(), gsImg.getHeight(), orientation);
        
            cr.offsetsToOrigCoords = offsetToOrigMap;
        }
    }
    */  

    private class Obj implements Comparable&lt;Obj&gt;{
        CRegion cr0;
        CRegion cr1;
        int imgIdx0;
        int imgIdx1;
        int nMatched;
        double cost = Double.MAX_VALUE;
        double[] costs;
        double f;
                
        // might not be populatated:
        int r0Idx = -1;
        int r1Idx = -1;

        @Override
        public int compareTo(Obj other) {
            if (cost &lt; other.cost) {
                return -1;
            } else if (cost &gt; other.cost) {
                return 1;
            }
            if (nMatched &gt; other.nMatched) {
                return -1;
            } else if (nMatched &lt; other.nMatched) {
                return 1;
            }
            // NOTE: may revise this.  wanting to choose smallest scale
            //   or smaller fraction of whole
            if (imgIdx0 &lt; other.imgIdx0 &amp;&amp; imgIdx1 &lt; other.imgIdx1) {
                return -1;
            } else if (imgIdx0 &gt; other.imgIdx0 &amp;&amp; imgIdx1 &gt; other.imgIdx1) {
                return 1;
            }
            return 0;
        }
    }

    public static int distance(PairInt p1, PairInt p2) {
<span class="nc" id="L913">        int diffX = p1.getX() - p2.getX();</span>
<span class="nc" id="L914">        int diffY = p1.getY() - p2.getY();</span>
<span class="nc" id="L915">        return (int) Math.sqrt(diffX * diffX + diffY * diffY);</span>
    }

    public static int distance(float x0, float y0, float x1, float y1) {
<span class="nc" id="L919">        float diffX = x0 - x1;</span>
<span class="nc" id="L920">        float diffY = y0 - y1;</span>
<span class="nc" id="L921">        return (int) Math.sqrt(diffX * diffX + diffY * diffY);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShapeFinder2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.matching</a> &gt; <span class="el_source">ShapeFinder2.java</span></div><h1>ShapeFinder2.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.matching;

import algorithms.imageProcessing.ImageProcessor;
import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.imageProcessing.SIGMA;
import algorithms.util.PairIntArray;
import gnu.trove.map.TIntObjectMap;
import java.util.List;
import algorithms.imageProcessing.matching.PartialShapeMatcher.Result;
import algorithms.misc.Misc;
import algorithms.util.OneDIntArray;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.map.TIntDoubleMap;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TObjectIntMap;
import gnu.trove.map.hash.TIntDoubleHashMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TObjectIntHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * NOTE: not ready for use.   was an experiment before segmentation
 * was improved with MSER and before started using HOGs.
 * This will be re-done with the better segmentation and then
 * the better segmentation + HOGs, HCPT, color histograms, etc.
 * The current MSER matcher uses everything except shape.
 * 
 * uses PartialShapeMatcher and search patterns to
 * find the best fitting match between a
 * group of adjacent segmented cells
 * to a template shape.  Any additional information
 * that helps limit the search should be done before
 * this stage and included or excluded in the
 * adjacency map.
 *
 * Also note that the class uses internal cache which requires single
 * threaded use of this class.
 *
 * @author nichole
 */
<span class="nc bnc" id="L53" title="All 2 branches missed.">public class ShapeFinder2 {</span>

    // partial shape matcher sampling distance
<span class="nc" id="L56">    private final int dp = 1;</span>
<span class="nc" id="L57">    private final boolean useSameNSampl = false;</span>

    private final PairIntArray bounds1;
    private final float scale1;
    private final float sz1;
    private final TIntObjectMap&lt;Set&lt;PairInt&gt;&gt; mapOfSets2;
    private final float scale2;
    private final Map&lt;OneDIntArray, PairIntArray&gt; keyBoundsMap;

    private final TObjectIntMap&lt;PairInt&gt; pointIndexes2Map;
    private final TIntObjectMap&lt;TIntSet&gt; adj2Map;

    private final int xMax1;
    private final int yMax1;
    private final int xMax2;
    private final int yMax2;

<span class="nc" id="L74">    private SIGMA sigma = SIGMA.ZEROPOINTFIVE;</span>

    /**
     * NOT READY FOR USE.
     *
     * note that this is the data of one image in pyramid1 compared to the data
     * in one image of pyramid2 and it is assumed that one such pair will have
     * template and true match of nearly the same scale.
     * On other words, this instance of ShapeFinder might not hold the true
     * match at same scale, but another instance (holding other scles of the
     * pyramids) should if the true match is
     * present.
     *
     * @param bounds1 clockwise ordered boundaries of template object.
     * @param ch1 1-D color histogram of template object
     * @param scale1 a bookkeeping number for the octave downsampling scale factor
     * with respect to the complete pyramid1.
     * @param mapOfSets2 labeled point sets of dataset2 to be searched for template
     * @param scale2 a bookkeeping number for the octave downsampling scale factor
     * with respect to the complete pyramid2.
     * @param keyIndexMap an in/out variable for use in combination wtth
     * indexBoundsMap to cache the clockwise boundaries of aggregated adjacent
     * labeled cells.
     * The key = sorted keys of mapOfSets2, value = the lookup key for
     * indexBoundsMap,
     * @param indexBoundsMap an in/out variable for use in combination wtth
     * keyIndexMap to cache the clockwise boundaries of aggregated adjacent
     * labeled cells.
     * The key = the lookup key from keyIndexMap, value = clockwise ordered
     * bounding points of the aggregated sets of labels from the key in
     * indexBoundsMap,
     */
    public ShapeFinder2(PairIntArray bounds1, float scale1, float sz1,
        int xMax1, int yMax1,
        TIntObjectMap&lt;Set&lt;PairInt&gt;&gt; mapOfSets2,
        float scale2, 
        Map&lt;OneDIntArray, PairIntArray&gt; keyBoundsMap,
<span class="nc" id="L111">        int xMax2, int yMax2) {</span>

<span class="nc" id="L113">        this.bounds1 = bounds1;</span>
<span class="nc" id="L114">        this.scale1 = scale1;</span>
<span class="nc" id="L115">        this.sz1 = sz1;</span>
<span class="nc" id="L116">        this.mapOfSets2 = mapOfSets2;</span>
<span class="nc" id="L117">        this.scale2 = scale2;</span>
<span class="nc" id="L118">        this.keyBoundsMap = keyBoundsMap;</span>
<span class="nc" id="L119">        this.xMax1 = xMax1;</span>
<span class="nc" id="L120">        this.yMax1 = yMax1;</span>
<span class="nc" id="L121">        this.xMax2 = xMax2;</span>
<span class="nc" id="L122">        this.yMax2 = yMax2;</span>

<span class="nc" id="L124">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="nc" id="L126">        this.pointIndexes2Map = new TObjectIntHashMap&lt;PairInt&gt;();</span>
        
<span class="nc" id="L128">        TIntObjectIterator&lt;Set&lt;PairInt&gt;&gt; iter = mapOfSets2.iterator();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (int i = 0; i &lt; mapOfSets2.size(); ++i) {</span>
<span class="nc" id="L130">            iter.advance();</span>
<span class="nc" id="L131">            int segIdx = iter.key();</span>
<span class="nc" id="L132">            Set&lt;PairInt&gt; set = iter.value();</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L134">                pointIndexes2Map.put(p, segIdx);</span>
<span class="nc" id="L135">            }</span>
        }

<span class="nc" id="L138">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L139">        int[] dys = Misc.dy8;</span>
<span class="nc" id="L140">        this.adj2Map = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
<span class="nc" id="L142">        iter = mapOfSets2.iterator();</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        for (int i = 0; i &lt; mapOfSets2.size(); ++i) {</span>
<span class="nc" id="L144">            iter.advance();</span>
<span class="nc" id="L145">            int segIdx = iter.key();</span>
<span class="nc" id="L146">            Set&lt;PairInt&gt; set = iter.value();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L148">                int x = p.getX();</span>
<span class="nc" id="L149">                int y = p.getY();</span>
                // find adjacent labels that are not idx1
<span class="nc bnc" id="L151" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L152">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L153">                    int y2 = y + dys[k];</span>
<span class="nc" id="L154">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc" id="L155">                    int segIdx2 = pointIndexes2Map.get(p2);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                    if (segIdx2 == segIdx) {</span>
<span class="nc" id="L157">                        continue;</span>
                    }
<span class="nc" id="L159">                    TIntSet set2 = adj2Map.get(segIdx);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                    if (set2 == null) {</span>
<span class="nc" id="L161">                        set2 = new TIntHashSet();</span>
<span class="nc" id="L162">                        adj2Map.put(segIdx, set2);</span>
                    }
<span class="nc" id="L164">                    set2.add(segIdx2);</span>
                }
<span class="nc" id="L166">            }</span>
        }
<span class="nc" id="L168">    }</span>

    /**
     * NOT READY FOR USE.
     * uses PartialShapeMatcher and search patterns to
     * find the best fitting match between a
     * group of adjacent segmented cells
     * to a template shape.
     *
     * Editing this now... the code no longer checks for a restricted 
     * distance or size in aggregating the labeled regions - it's up
     * to the user to filter the input sets given to this instance
     * themselves for those purposes.
     * 
     * The runtime is dependent upon which of the 3 search
     * patterns is kept in the end, so that will be
     * filled in here after implementation and testing.
     *
     * @return
     */
    public ShapeFinderResult findAggregated() {
       
<span class="nc" id="L190">        ShapeFinderResult sr = multiSourceBFS();</span>

<span class="nc" id="L192">        return sr;</span>
    }

    /**
     * NOT READY FOR USE.
     * uses PartialShapeMatcher and search patterns to
     * find the best fitting match between a
     * group of adjacent segmented cells
     * to a template shape.
     *
     * Editing this now... the code no longer checks for a restricted 
     * distance or size in aggregating the labeled regions - it's up
     * to the user to filter the input sets given to this instance
     * themselves for those purposes.
     * 
     * The runtime is dependent upon which of the 3 search
     * patterns is kept in the end, so that will be
     * filled in here after implementation and testing.
     *
     * @return
     */
    public ShapeFinderResult findAggregated(int srcIdx) {
       
<span class="nc" id="L215">        System.out.println(&quot;searching &quot; + mapOfSets2.size() + &quot; labeled regions&quot;);</span>
        
<span class="nc" id="L217">        Map&lt;OneDIntArray, ShapeFinderResult&gt; cacheResults</span>
            = new HashMap&lt;OneDIntArray, ShapeFinderResult&gt;();

<span class="nc" id="L220">        TIntSet idxs = new TIntHashSet();</span>

<span class="nc" id="L222">        long t0 = System.currentTimeMillis();</span>
        
<span class="nc" id="L224">        double[] maxChordAvgDiff = new double[]{matchSingly(cacheResults, idxs)};</span>
        
<span class="nc" id="L226">        ShapeFinderResult sr = bfs(srcIdx, cacheResults, idxs, maxChordAvgDiff);</span>

<span class="nc" id="L228">        long t1 = System.currentTimeMillis();</span>
        
<span class="nc" id="L230">        System.out.println(&quot;a single bfs took &quot; + ((t1 - t0)/1000) + &quot; seconds&quot;);</span>
        
<span class="nc" id="L232">        return sr;</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;})
    private ShapeFinderResult aggregateAndMatch(ShapeFinderResult rIK,
        ShapeFinderResult rKJ) {

        // -- either might be null but not both
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (rIK == null) {</span>
<span class="nc" id="L241">            return rKJ;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        } else if (rKJ == null) {</span>
<span class="nc" id="L243">            return rIK;</span>
        }

        // if both have same keys, assert same results and return one of them
<span class="nc" id="L247">        int[] l1 = rIK.labels2;</span>
<span class="nc" id="L248">        int[] l2 = rKJ.labels2;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (Arrays.equals(l1, l2)) {</span>
            // TODO: assert same content
<span class="nc" id="L251">            return rIK;</span>
        }

        // -- check that the two have at least one adjacent set between them
<span class="nc" id="L255">        boolean foundAdj = false;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        for (int i = 0; i &lt; l1.length; ++i) {</span>
<span class="nc" id="L257">            int idx1 = l1[i];</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            for (int j = 0; j &lt; l2.length; ++j) {</span>
<span class="nc" id="L259">                int idx2 = l2[j];</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">                if (this.adj2Map.containsKey(idx1) &amp;&amp; adj2Map.get(idx1).contains(idx2)) {</span>
<span class="nc" id="L261">                    foundAdj = true;</span>
<span class="nc" id="L262">                    break;</span>
                }
            }
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (foundAdj) {</span>
<span class="nc" id="L266">                break;</span>
            }
        }
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (!foundAdj) {</span>
<span class="nc" id="L270">            return null;</span>
        }

<span class="nc" id="L273">        TIntSet combIdxs = new TIntHashSet(l1.length + l2.length);</span>
<span class="nc" id="L274">        combIdxs.addAll(l1);</span>
<span class="nc" id="L275">        combIdxs.addAll(l2);</span>

<span class="nc" id="L277">        OneDIntArray keysI = new OneDIntArray(</span>
<span class="nc" id="L278">            combIdxs.toArray(new int[combIdxs.size()]));</span>
<span class="nc" id="L279">        Arrays.sort(keysI.a);</span>

        PairIntArray boundsI;
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (keyBoundsMap.containsKey(keysI)) {</span>
<span class="nc" id="L283">            boundsI = keyBoundsMap.get(keysI);</span>
        } else {
<span class="nc" id="L285">            Set&lt;PairInt&gt; combSet = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L286">            TIntIterator iter = combIdxs.iterator();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L288">                int idx = iter.next();</span>
<span class="nc" id="L289">                combSet.addAll(this.mapOfSets2.get(idx));</span>
<span class="nc" id="L290">            }</span>
<span class="nc" id="L291">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L292">            boundsI = imageProcessor.extractSmoothedOrderedBoundary(</span>
                new HashSet&lt;PairInt&gt;(combSet), sigma, xMax2 + 1, yMax2 + 1);
<span class="nc" id="L294">            keyBoundsMap.put(keysI, boundsI);</span>
        }

<span class="nc" id="L297">        PartialShapeMatcher matcher = new PartialShapeMatcher();</span>
<span class="nc" id="L298">        matcher.overrideSamplingDistance(dp);</span>
<span class="nc" id="L299">        matcher._overrideToThreshhold(0.2f);</span>
<span class="nc" id="L300">        matcher.setToRemoveOutliers();</span>
        //matcher.setToDebug();
<span class="nc" id="L302">        PartialShapeMatcher.Result r = matcher.match(bounds1, boundsI);</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L305">            return null;</span>
        }

<span class="nc" id="L308">        ShapeFinderResult sr = new ShapeFinderResult(r, bounds1, boundsI,</span>
            keysI.a);

<span class="nc" id="L311">        return sr;</span>
    }

    private ShapeFinderResult multiSourceBFS() {

        // -- make a cache of search results to resuse
        // -- launch a BFS search from each label2 set.

<span class="nc" id="L319">        System.out.println(&quot;searching &quot; + mapOfSets2.size() + &quot; labeled regions&quot;);</span>
        
<span class="nc" id="L321">        Map&lt;OneDIntArray, ShapeFinderResult&gt; cacheResults</span>
            = new HashMap&lt;OneDIntArray, ShapeFinderResult&gt;();

<span class="nc" id="L324">        TIntSet idxs = new TIntHashSet();</span>

<span class="nc" id="L326">        long t0 = System.currentTimeMillis();</span>
        
<span class="nc" id="L328">        double[] maxChordAvgDiff = new double[]{matchSingly(cacheResults, idxs)};</span>
        
<span class="nc" id="L330">        long t1 = System.currentTimeMillis();</span>
        
<span class="nc" id="L332">        System.out.println(&quot;matchSingly took &quot; + ((t1 - t0)/1000) + &quot; seconds&quot;);</span>
        
<span class="nc" id="L334">        TIntIterator iter = idxs.iterator();</span>

<span class="nc" id="L336">        List&lt;ShapeFinderResult&gt; results = new ArrayList&lt;ShapeFinderResult&gt;();</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L340">            int label = iter.next();</span>

<span class="nc" id="L342">            t0 = System.currentTimeMillis();</span>
            
<span class="nc" id="L344">            ShapeFinderResult sr = bfs(label, cacheResults, idxs, maxChordAvgDiff);</span>

<span class="nc" id="L346">            t1 = System.currentTimeMillis();</span>
        
<span class="nc" id="L348">            System.out.println(&quot;a single bfs took &quot; + ((t1 - t0)/1000) + &quot; seconds&quot;);</span>
        
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (sr != null) {</span>
<span class="nc" id="L351">                results.add(sr);               </span>
            }
<span class="nc" id="L353">        }</span>

<span class="nc" id="L355">        ShapeFinderResult minCostR = null;</span>
<span class="nc" id="L356">        double minCost = Double.MAX_VALUE;</span>
       
<span class="nc bnc" id="L358" title="All 2 branches missed.">        for (ShapeFinderResult r : results) {</span>
                        
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (r == null) {</span>
<span class="nc" id="L361">                continue;</span>
            }
<span class="nc" id="L363">            double sd = calcCost(r, maxChordAvgDiff[0]);</span>
        
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (sd &lt; minCost) {</span>
<span class="nc" id="L366">                minCost = sd;</span>
<span class="nc" id="L367">                minCostR = r;</span>
            }
<span class="nc" id="L369">        }</span>

<span class="nc" id="L371">        return minCostR;</span>
    }

    // run partial shape matcher on individual sets, store the labels and 
    // results and return the maximum chord diff avg 
    @SuppressWarnings({&quot;unchecked&quot;})
    private double matchSingly(Map&lt;OneDIntArray, ShapeFinderResult&gt; 
        cacheResults, TIntSet outIdxs) {

<span class="nc" id="L380">        double maxAvgDiffChord = Double.MIN_VALUE;</span>

<span class="nc" id="L382">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
<span class="nc" id="L384">        TIntObjectIterator&lt;Set&lt;PairInt&gt;&gt; iter = mapOfSets2.iterator();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        for (int i = 0; i &lt; mapOfSets2.size(); ++i) {</span>
            
<span class="nc" id="L387">            iter.advance();</span>
            
<span class="nc" id="L389">            int label = iter.key();</span>

<span class="nc" id="L391">            OneDIntArray keysI = new OneDIntArray(new int[]{label});</span>
            PairIntArray boundsI;
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (keyBoundsMap.containsKey(keysI)) {</span>
<span class="nc" id="L394">                boundsI = keyBoundsMap.get(keysI);</span>
            } else {
<span class="nc" id="L396">                Set&lt;PairInt&gt; set1 = iter.value();</span>
<span class="nc" id="L397">                boundsI = imageProcessor.extractSmoothedOrderedBoundary(</span>
                    new HashSet&lt;PairInt&gt;(set1), sigma, xMax2 + 1, yMax2 + 1);
<span class="nc" id="L399">                keyBoundsMap.put(keysI, boundsI);</span>
            }
            
<span class="nc" id="L402">            PartialShapeMatcher matcher = new PartialShapeMatcher();</span>
<span class="nc" id="L403">            matcher.overrideSamplingDistance(dp);</span>
<span class="nc" id="L404">            matcher._overrideToThreshhold(0.2f);</span>
<span class="nc" id="L405">            matcher.setToRemoveOutliers();</span>
            //matcher.setToDebug();
<span class="nc" id="L407">            PartialShapeMatcher.Result r = matcher.match(bounds1, boundsI);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (r == null) {                </span>
<span class="nc" id="L409">                continue;</span>
            }
            
<span class="nc" id="L412">            outIdxs.add(label);</span>

<span class="nc" id="L414">            double avgCD = r.getChordDiffSum() / (double) r.getNumberOfMatches();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (avgCD &gt; maxAvgDiffChord) {</span>
<span class="nc" id="L416">                maxAvgDiffChord = avgCD;</span>
            }
            
<span class="nc" id="L419">            ShapeFinderResult sr = new ShapeFinderResult(r, bounds1, boundsI,</span>
                keysI.a);
            
<span class="nc" id="L422">            cacheResults.put(keysI, sr);</span>
        }

<span class="nc" id="L425">        return maxAvgDiffChord;</span>
    }

    private ShapeFinderResult bfs(int srcIdx, Map&lt;OneDIntArray, 
        ShapeFinderResult&gt; cacheResults, TIntSet idxs, 
        double[] maxChordAvgDiff) {

<span class="nc" id="L432">        OneDIntArray srcKeys = new OneDIntArray(new int[]{srcIdx});</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (!cacheResults.containsKey(srcKeys)) {</span>
<span class="nc" id="L434">            return null;</span>
        }

<span class="nc" id="L437">        int n = mapOfSets2.size();</span>
        
        // key = label (a.k.a. segIdx), value = cost
<span class="nc" id="L440">        TIntDoubleMap dist = new TIntDoubleHashMap(n);</span>
<span class="nc" id="L441">        TIntObjectIterator&lt;Set&lt;PairInt&gt;&gt; iter0 = mapOfSets2.iterator();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L443">            iter0.advance();;</span>
<span class="nc" id="L444">            dist.put(iter0.key(), Double.MAX_VALUE);</span>
        }
        
        // key = label (a.k.a. segIdx), value = state of visit
        // 0 = white, 1 = grey, 2 = visited
<span class="nc" id="L449">        TIntIntMap visited = new TIntIntHashMap(n);</span>
<span class="nc" id="L450">        visited.put(srcIdx, 1);</span>
        
<span class="nc" id="L452">        TIntObjectMap&lt;ShapeFinderResult&gt; results = new </span>
            TIntObjectHashMap&lt;ShapeFinderResult&gt;(n);
        
<span class="nc" id="L455">        results.put(srcIdx, cacheResults.get(srcKeys));</span>
<span class="nc" id="L456">        dist.put(srcIdx, calcCost(results.get(srcIdx), maxChordAvgDiff[0]));</span>
           
        // make a FIFO queue.
<span class="nc" id="L459">        ArrayDeque&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</span>

<span class="nc" id="L461">        queue.add(Integer.valueOf(srcIdx));</span>

<span class="nc" id="L463">        double mc = maxChordAvgDiff[0];</span>

<span class="nc" id="L465">double sumDeltaT = 0;</span>
<span class="nc" id="L466">int nDeltaT = 0;</span>
<span class="nc" id="L467">long t = System.currentTimeMillis();</span>
<span class="nc" id="L468">double sumDeltaT2 = 0;</span>
<span class="nc" id="L469">int nDeltaT2 = 0;</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">        while (!queue.isEmpty()) {</span>

<span class="nc" id="L473">            Integer uIndex = queue.pop();</span>
<span class="nc" id="L474">            int uIdx = uIndex.intValue();</span>
           
<span class="nc" id="L476">            TIntSet adjSet = adj2Map.get(uIdx);</span>
            
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (adjSet == null) {</span>
<span class="nc" id="L479">                continue;</span>
            }
            
<span class="nc" id="L482">            System.out.println(&quot;  =&gt; pop &quot; + uIdx + &quot; which has key=&quot; +</span>
<span class="nc" id="L483">                Arrays.toString(results.get(uIdx).labels2));</span>

<span class="nc" id="L485">            TIntIterator iter = adjSet.iterator();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L487">                int vIdx = iter.next();</span>
           
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (!idxs.contains(vIdx)) {</span>
<span class="nc" id="L490">                    continue;</span>
                }
<span class="nc bnc" id="L492" title="All 4 branches missed.">                if (visited.containsKey(vIdx) &amp;&amp; visited.get(vIdx) == 2) {</span>
<span class="nc" id="L493">                    continue;</span>
                }
<span class="nc bnc" id="L495" title="All 2 branches missed.">                if (results.containsKey(vIdx) &amp;&amp; </span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                    (Arrays.binarySearch(results.get(vIdx).labels2, uIdx) &gt; -1)</span>
                    ) {
<span class="nc" id="L498">                    continue;</span>
                }
           
<span class="nc bnc" id="L501" title="All 4 branches missed.">                assert(results.containsKey(uIdx));</span>
                
<span class="nc" id="L503">                ShapeFinderResult rV = results.get(vIdx);</span>
<span class="nc" id="L504">                double sdV = dist.get(vIdx);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (Double.isNaN(sdV)) {</span>
<span class="nc" id="L506">                    continue;</span>
                }
                
<span class="nc bnc" id="L509" title="All 2 branches missed.">                if (rV == null) {</span>
<span class="nc" id="L510">                    OneDIntArray vKeys = new OneDIntArray(new int[]{vIdx});</span>
<span class="nc" id="L511">                    rV = cacheResults.get(vKeys);</span>
                }
               
<span class="nc" id="L514">                System.out.println(&quot;  =&gt; agg  u with v=&quot; + vIdx </span>
                    + &quot; which has key=&quot; +
<span class="nc" id="L516">                    Arrays.toString(rV.labels2));</span>
               
<span class="nc" id="L518">long t2 = System.currentTimeMillis();                </span>
                
<span class="nc" id="L520">                ShapeFinderResult uPlusV = aggregateAndMatch(results.get(uIdx), rV);</span>
                
<span class="nc" id="L522">long t2_2 = System.currentTimeMillis();</span>
<span class="nc" id="L523">nDeltaT2++;</span>
<span class="nc" id="L524">sumDeltaT2 += ((double)t2_2 - (double)t2) / 1000.;</span>
<span class="nc" id="L525">t = t2_2;</span>
                
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (uPlusV == null) {</span>
<span class="nc" id="L528">                    continue;</span>
                }
                
                // store results in cache
<span class="nc" id="L532">                OneDIntArray uvKeys = new OneDIntArray(</span>
<span class="nc" id="L533">                    Arrays.copyOf(uPlusV.labels2, uPlusV.labels2.length));</span>
<span class="nc" id="L534">                cacheResults.put(uvKeys, uPlusV);</span>
                
<span class="nc" id="L536">                double sdUPlusV = calcCost(uPlusV, maxChordAvgDiff[0]);</span>
        
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (Double.isNaN(sdUPlusV)) {</span>
<span class="nc" id="L539">                    continue;</span>
                }
                
<span class="nc" id="L542">                System.out.println(&quot;  =&gt; sdUPlusV=&quot; + sdUPlusV + &quot; sdV=&quot; + sdV);</span>
                    
                //visited[vIdx] = 1;
<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (sdUPlusV &lt; sdV) {</span>
                    
<span class="nc" id="L547">                    dist.put(vIdx, sdUPlusV);</span>
<span class="nc" id="L548">                    results.put(vIdx, uPlusV);</span>
<span class="nc" id="L549">                    queue.add(Integer.valueOf(vIdx));</span>
                    
                    // update the maxes 
<span class="nc" id="L552">                    double avgCD = uPlusV.getChordDiffSum() / </span>
<span class="nc" id="L553">                        (double) uPlusV.getNumberOfMatches();</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    if (avgCD &gt; mc) {</span>
<span class="nc" id="L555">                        mc = avgCD;</span>
                    }
                }
<span class="nc" id="L558">            }</span>
        
<span class="nc" id="L560">            visited.put(uIdx, 2);</span>
            
<span class="nc" id="L562">long t_2 = System.currentTimeMillis();</span>
<span class="nc" id="L563">nDeltaT++;</span>
<span class="nc" id="L564">sumDeltaT += ((double)t_2 - (double)t) / 1000.;</span>
<span class="nc" id="L565">t = t_2;</span>
<span class="nc" id="L566">        }</span>
        
<span class="nc" id="L568">System.out.println(&quot;avg loop iteration = &quot; + (sumDeltaT/nDeltaT) + &quot; sec&quot;);</span>

<span class="nc" id="L570">System.out.println(&quot;avg agg srch within loop iteration = &quot; + (sumDeltaT2/nDeltaT2) + &quot; sec&quot;);</span>

        // re-do costs, and update max var
<span class="nc" id="L573">        maxChordAvgDiff[0] = mc;</span>

<span class="nc" id="L575">        ShapeFinderResult minCostR = null;</span>
<span class="nc" id="L576">        double minCost = Double.MAX_VALUE;</span>
        
<span class="nc" id="L578">        TIntObjectIterator&lt;ShapeFinderResult&gt; iter2 = results.iterator();</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        for (int i = 0; i &lt; results.size(); ++i) {</span>
<span class="nc" id="L580">            iter2.advance();</span>
<span class="nc" id="L581">            ShapeFinderResult r = iter2.value();</span>
           
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (r == null) {</span>
<span class="nc" id="L584">                continue;</span>
            }
<span class="nc" id="L586">            double sd = calcCost(r, maxChordAvgDiff[0]);</span>
       
<span class="nc bnc" id="L588" title="All 2 branches missed.">            if (Double.isNaN(sd)) {</span>
<span class="nc" id="L589">                continue;</span>
            }
            
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (sd &lt; minCost) {</span>
<span class="nc" id="L593">                minCost = sd;</span>
<span class="nc" id="L594">                minCostR = r;</span>
            }
        }
<span class="nc bnc" id="L597" title="All 2 branches missed.">if (minCostR != null) {</span>
<span class="nc" id="L598">ShapeFinderResult r = minCostR;</span>
<span class="nc" id="L599">int nb1 = Math.round((float) r.bounds1.getN() / (float) dp);</span>
<span class="nc" id="L600">float np = r.getNumberOfMatches();</span>
<span class="nc" id="L601">int lGap = maxNumberOfGaps(r.bounds1, r)/dp;</span>
<span class="nc" id="L602">float gCountComp = (float)lGap/(float)nb1;</span>

<span class="nc" id="L604">System.out.println(&quot;min: cost=&quot; + minCost + &quot; count=&quot; + np + </span>
<span class="nc" id="L605">&quot; chordAvg=&quot; + ((float) r.getChordDiffSum() / np) +</span>
&quot; gapAvg=&quot; + gCountComp);
}
<span class="nc" id="L608">        return minCostR;</span>
    }

    private double calcCost(ShapeFinderResult r, double maxAvgDiffChord) {
        
<span class="nc" id="L613">        int nb1 = Math.round((float) r.bounds1.getN() / (float) dp);</span>

<span class="nc" id="L615">        float np = r.getNumberOfMatches();</span>

<span class="nc" id="L617">        float countComp = 1.0F - (np / (float) nb1);</span>
<span class="nc" id="L618">        double chordComp = ((float) r.getChordDiffSum() / np) / maxAvgDiffChord;</span>

<span class="nc" id="L620">        int lGap = maxNumberOfGaps(r.bounds1, r)/dp;</span>
<span class="nc" id="L621">        float gCountComp = (float)lGap/(float)nb1;</span>

        // these should be squared
<span class="nc" id="L624">        double sd = chordComp*chordComp + countComp*countComp + gCountComp*gCountComp;</span>
        
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (Double.isNaN(sd)) {</span>
<span class="nc" id="L627">            System.out.println(&quot;NaN: nb1=&quot; + nb1 + &quot; np=&quot; + np</span>
<span class="nc" id="L628">                + &quot; chordsum=&quot; + r.getChordDiffSum() + </span>
                &quot; countComp=&quot; + countComp + &quot; gCountComp=&quot; + gCountComp);
        }
        
<span class="nc" id="L632">        r.contextCost = sd;</span>
        
<span class="nc" id="L634">        return sd;</span>
    }

    public static class ShapeFinderResult extends Result {

        protected final PairIntArray bounds1;
        protected final PairIntArray bounds2;
        
        /**
         * cost calculated in the result's context of max chord diff avg and
         * max number of matchable.
         * Note that this value may be the square sum and not
         * the square root of the square sums (that's the case for
         * use throughout ShapeFinder2.java)
         */
        protected double contextCost = Double.MAX_VALUE;
        
        /**
         * a list of sorted labels, bounds2 is the boundary of the combined 
         * regions in labels2
         */
        protected final int[] labels2;

        public ShapeFinderResult(Result r, PairIntArray bounds1,
            PairIntArray bounds2, int[] keys) {

            super(r.n1, r.n2, r.getOriginalN1());

            this.bounds1 = bounds1;
            this.bounds2 = bounds2;
            this.chordDiffSum = r.chordDiffSum;
            this.chordsNeedUpdates = r.chordsNeedUpdates;
            this.idx1s = r.idx1s;
            this.idx2s = r.idx2s;
            this.params = r.params;
            this.data = r.data;
            this.labels2 = keys;
        }

        public ShapeFinderResult(int n1, int n2, int offset, PairIntArray bounds1,
            PairIntArray bounds2, int[] keys) {

            super(n1, n2, offset);

            this.bounds1 = bounds1;
            this.bounds2 = bounds2;
            this.labels2 = keys;
        }

        public ShapeFinderResult(int n1, int n2, int nOriginal,
            int offset, PairIntArray bounds1,
            PairIntArray bounds2, int[] keys) {

            super(n1, n2, nOriginal);

            this.bounds1 = bounds1;
            this.bounds2 = bounds2;
            this.labels2 = keys;
        }
        
        public double getContextCost() {
            return contextCost;
        }

        @Override
        public String toString() {
            String str = super.toString();
            str = str + &quot; contextCost=&quot; + contextCost;
            return str;
        }
        
        
    }

    // sorted so that all X of same Y are first, then all X of larger Y
    private class XYSort implements Comparator&lt;PairInt&gt; {

        @Override
        public int compare(PairInt o1, PairInt o2) {

            int comp = Integer.compare(o1.getY(), o2.getY());
            if (comp != 0) {
                return comp;
            }
            comp = Integer.compare(o1.getX(), o2.getX());
            return comp;
        }

    }
    
    private int maxNumberOfGaps(PairIntArray bounds,
        PartialShapeMatcher.Result r) {

<span class="nc" id="L727">        TIntSet mIdxs = new TIntHashSet(r.getNumberOfMatches());</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        for (int i = 0; i &lt; r.getNumberOfMatches(); ++i) {</span>
<span class="nc" id="L729">            mIdxs.add(r.getIdx1(i));</span>
        }

<span class="nc" id="L732">        int maxGapStartIdx = -1;</span>
<span class="nc" id="L733">        int maxGap = 0;</span>
<span class="nc" id="L734">        int cStartIdx = -1;</span>
<span class="nc" id="L735">        int cGap = 0;</span>

        // handling for startIdx of 0 to check for wraparound
        // of gap at end of block
<span class="nc" id="L739">        int gap0 = 0;</span>

<span class="nc bnc" id="L741" title="All 2 branches missed.">        for (int i = 0; i &lt; bounds.getN(); ++i) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (!mIdxs.contains(i)) {</span>
                // is a gap
<span class="nc bnc" id="L744" title="All 2 branches missed.">                if (cStartIdx == -1) {</span>
<span class="nc" id="L745">                    cStartIdx = i;</span>
                }
<span class="nc" id="L747">                cGap++;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                if (i == (bounds.getN() - 1)) {</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                    if (gap0 &gt; 0) {</span>
                        // 0 1 2 3 4 5
                        // g g     g g
                        // gap0=2
                        // cGap=2 cStartIdx=4
<span class="nc bnc" id="L754" title="All 2 branches missed.">                        if (cStartIdx &gt; (gap0 - 1)) {</span>
<span class="nc" id="L755">                            gap0 += cGap;</span>
                        }
                    }
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    if (cGap &gt; maxGap) {</span>
<span class="nc" id="L759">                        maxGap = cGap;</span>
<span class="nc" id="L760">                        maxGapStartIdx = cStartIdx;</span>
                    }
<span class="nc bnc" id="L762" title="All 2 branches missed.">                    if (gap0 &gt; maxGap) {</span>
<span class="nc" id="L763">                        maxGap = gap0;</span>
<span class="nc" id="L764">                        maxGapStartIdx = 0;</span>
                    }
                }
            } else {
                // is not a gap
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (cStartIdx &gt; -1) {</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                    if (cGap &gt; maxGap) {</span>
<span class="nc" id="L771">                        maxGap = cGap;</span>
<span class="nc" id="L772">                        maxGapStartIdx = cStartIdx;</span>
                    }
<span class="nc bnc" id="L774" title="All 2 branches missed.">                    if (cStartIdx == 0) {</span>
<span class="nc" id="L775">                        gap0 = cGap;</span>
                    }
<span class="nc" id="L777">                    cStartIdx = -1;</span>
<span class="nc" id="L778">                    cGap = 0;</span>
                }
            }
        }

<span class="nc" id="L783">        return maxGap;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ButterflySectionFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">ButterflySectionFinder.java</span></div><h1>ButterflySectionFinder.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.misc.Misc;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 *
 * @author nichole
 */
<span class="fc" id="L17">public class ButterflySectionFinder {</span>
    
    /**
     * Find sections of the closed curve that are two pixels wide and separate
     * loops in the curve:
     * &lt;pre&gt;
     * for example:         #  #
     *    #  #  #         #     #
     *  #         #  #  #      #
     *   #   #  # #  #  #  #  #
     * &lt;/pre&gt;
     * These sections are thinned to width of '1' by the line thinner,
     * so need to be restored afterwards or prevented from being removed.
     * @param closedCurve
     * @return list of points that are part of the 2 pixel width patterns in
     * a curve where the curve closes, but is still connected.
     */
    public List&lt;Set&lt;PairInt&gt;&gt; findButterflySections(PairIntArray closedCurve) {
        
<span class="fc" id="L36">        Set&lt;PairInt&gt; points = Misc.convert(closedCurve);</span>
        
<span class="fc" id="L38">        List&lt;Set&lt;PairInt&gt;&gt; sections = findButterflySectionsLarge(closedCurve, </span>
            points);

<span class="fc" id="L41">        List&lt;Set&lt;PairInt&gt;&gt; sectionsSmall = findButterflySectionsSmall(</span>
            closedCurve, points);
        
<span class="pc bpc" id="L44" title="1 of 4 branches missed.">        if (sections == null &amp;&amp; sectionsSmall == null) {</span>
<span class="nc" id="L45">            return null;</span>
<span class="pc bpc" id="L46" title="1 of 4 branches missed.">        } else if (sections == null &amp;&amp; sectionsSmall != null) {</span>
<span class="fc" id="L47">            return sectionsSmall;</span>
<span class="pc bpc" id="L48" title="2 of 4 branches missed.">        } else if (sections != null &amp;&amp; sectionsSmall == null) {</span>
<span class="nc" id="L49">            return sections;</span>
<span class="pc bpc" id="L50" title="2 of 4 branches missed.">        } else if (sections != null &amp;&amp; sectionsSmall != null) {</span>
<span class="fc" id="L51">            sections.addAll(sectionsSmall);</span>
        }
        
<span class="fc" id="L54">        return sections;</span>
    }

     /**
     * Find sections of the closed curve that are two pixels wide and separate
     * loops in the curve:
     * &lt;pre&gt;
     * for example:         #  #
     *    #  #  #         #     #
     *  #         #  #  #      #
     *   #   #  # #  #  #  #  #
     * &lt;/pre&gt;
     * These sections are thinned to width of '1' by the line thinner,
     * so need to be restored afterwards or prevented from being removed.
     * @param closedCurve
     * @param points
     * @return list of points that are part of the 2 pixel width patterns in
     * a curve where the curve closes, but is still connected.
     */
    protected List&lt;Set&lt;PairInt&gt;&gt; findButterflySectionsLarge(PairIntArray 
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L76">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L78">        List&lt;LinkedList&lt;Segment&gt;&gt; candidateSections = new ArrayList&lt;LinkedList&lt;Segment&gt;&gt;();</span>

<span class="fc" id="L80">        LinkedList&lt;Segment&gt; currentList = null;</span>

<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); ++i) {</span>

<span class="fc" id="L84">            int x = closedCurve.getX(i);</span>
<span class="fc" id="L85">            int y = closedCurve.getY(i);</span>
            
<span class="fc" id="L87">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);</span>

            // scanning for segments
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (neighbors.size() != 5) {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (currentList != null) {</span>
<span class="fc" id="L92">                    candidateSections.add(currentList);</span>
<span class="fc" id="L93">                    currentList = null;</span>
                }
                continue;
            }

<span class="fc" id="L98">            Segment segment = checkSegmentPatterns(x, y, neighbors);</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (segment == null) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                if (currentList != null) {</span>
<span class="fc" id="L102">                    candidateSections.add(currentList);</span>
<span class="fc" id="L103">                    currentList = null;</span>
                }
                continue;
            }

<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (currentList == null) {</span>
<span class="fc" id="L109">                currentList = new LinkedList&lt;Segment&gt;();</span>
            }
<span class="fc" id="L111">            currentList.add(segment);</span>
        }

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (currentList != null) {</span>
<span class="nc" id="L115">            candidateSections.add(currentList);</span>
        }

<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (candidateSections.isEmpty()) {</span>
<span class="fc" id="L119">            return null;</span>
        }

<span class="fc" id="L122">        Set&lt;PairInt&gt; exclude = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        for (LinkedList&lt;Segment&gt; section : candidateSections) {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (Segment segment : section) {</span>
<span class="fc" id="L125">                exclude.add(segment.p0);</span>
<span class="fc" id="L126">                exclude.add(segment.p1);</span>
<span class="fc" id="L127">                exclude.add(segment.p2);</span>
<span class="fc" id="L128">                exclude.add(segment.p3);</span>
<span class="fc" id="L129">            }</span>
<span class="fc" id="L130">        }</span>

<span class="fc" id="L132">        List&lt;Set&lt;PairInt&gt;&gt; output = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

        // -- scan for endpoints --
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (LinkedList&lt;Segment&gt; section : candidateSections) {</span>

<span class="fc" id="L137">            boolean checkFirstSegment = true;</span>
            
<span class="fc" id="L139">            Set&lt;PairInt&gt; endPoints = checkForAdjacentEndpoints(points, section,</span>
                exclude, checkFirstSegment);

<span class="pc bpc" id="L142" title="1 of 4 branches missed.">            if (endPoints == null || endPoints.isEmpty()) {</span>
<span class="nc" id="L143">                continue;</span>
            }

<span class="fc" id="L146">            Set&lt;PairInt&gt; exclude2 = new HashSet&lt;PairInt&gt;(exclude);</span>
<span class="fc" id="L147">            exclude2.addAll(endPoints);</span>

<span class="fc" id="L149">            Set&lt;PairInt&gt; endPoints2 = checkForAdjacentEndpoints(points,</span>
                section, exclude2, checkFirstSegment);

<span class="pc bpc" id="L152" title="1 of 4 branches missed.">            if (endPoints2 == null || endPoints2.isEmpty()) {</span>
<span class="nc" id="L153">                continue;</span>
            }

            // add all section and endpoints to a set to add to output
<span class="fc" id="L157">            Set&lt;PairInt&gt; allPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L158">            allPoints.addAll(endPoints);</span>
<span class="fc" id="L159">            allPoints.addAll(endPoints2);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            for (Segment segment : section) {</span>
<span class="fc" id="L161">                allPoints.add(segment.p0);</span>
<span class="fc" id="L162">                allPoints.add(segment.p1);</span>
<span class="fc" id="L163">                allPoints.add(segment.p2);</span>
<span class="fc" id="L164">                allPoints.add(segment.p3);</span>
<span class="fc" id="L165">            }</span>

<span class="fc" id="L167">            output.add(allPoints);</span>
<span class="fc" id="L168">        }</span>

<span class="fc" id="L170">        return output;</span>

        /*
        endpoints for vert:
                       #           #
            # .      = - .      -  - .
          - - .  or  - - .  or     # .
            #          #

        endpoints for horiz:
                -        - -       -
              # - #    # - - #   # - #
              . .        . .       . .

        endpoints for diag:

            -  #             -  #               -  #
            -    .        -  -  .            #  -  .
            #  .   .      #  .    .          -  .    .
                 .              .                  .

        The sections of line which are 2 pixels wide and 1 further from the
        endpoint have 3 non-point neighbors each and 5 point set neighbors
        An area limit further constrains the geometry.
        For sections matching the patterns below, could consider storing
        the pattern for each pix as 'v', 'h', or 'd'...not an apparent use for
        that yet though.

        Segment patterns between endpoints:
                       4
           -  -  -  -  3
           .  #  #  .  2
           .  #  #  .  1
           -  -  -  -  0
        0  1  2  3  4

                        4
           -  .  .  -   3
           -  #  #  -   2
           -  #  #  -   1
           -  .  .  -   0
        0  1  2  3  4

           # # - -   3
           - # # - - 2
           - - # #   1
           - - - - - 0
        0  1 2 3 4 5

        data structures:
           linked lists of found pattern points as segments with
           specialization of each segment as VertSegment, HorizSegment,
              UUdiagsegment, ULdiagsegment



        Scan the line,
           if a point fits one of the 4 segment patterns (4th is diag transformed by x=-x),
           add it to a group and add the remaining pts fitting the pattern to a stack
           -- traverse the stack adding contiguous points to the group that fit the
              pattern.
           -- note where the first point in the pattern started, because
              when there are no more contiguous pattern matching points,
              the scan will continue at the next point after that first,
              but will skip those already added to a group.

        When the scan for groups has finished,
             for each group, need to apply the above endpoint patterns to see
             if the candidate segment is surrounded by 2 endpoints.

             test all candidate group points as adjacent to potential endpoints.

             When a match is found, have to exclude all of the matching pattern
             from the oppossing endpoint tests.

             This is the smallest pattern which will match that suggestion:
              - - - -
            # # @ # #
          - - # @ # -
            # - - - #
             The '@'s are the candidate group points.  The #'s are points
             matching endoint patterns.

             The found endpoints for one end, the left for example, would
             be excluded from a search for matching to the other endpoints.

        Note that this pattern and variants of it as very short sections and
        endpoints should be scanned after the above to find the shortest
        butterfly segments.
              - -
            # # @ #
          - - # @ -
            # - - #
        
          #  
            #
              # # #
        # # #
              # # #

        For each segment group which has 2 matching endpoints, those should
        be stored as butterfly sections in a set.  Each one of those
        should be passed back in a list as the return of this method.

        runtime complexity is linear in the number of points in the given
        closed curve.
        */

    }
    
    protected List&lt;Set&lt;PairInt&gt;&gt; findButterflySectionsSmall(PairIntArray 
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L283">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L285">        List&lt;Set&lt;PairInt&gt;&gt; output = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();    </span>

<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); ++i) {</span>

<span class="fc" id="L289">            int x = closedCurve.getX(i);</span>
<span class="fc" id="L290">            int y = closedCurve.getY(i);</span>
            
<span class="fc" id="L292">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);</span>

            // scanning for segments
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (neighbors.size() != 3) {</span>
<span class="fc" id="L296">                continue;</span>
            }
                            
<span class="fc" id="L299">            Segment segment = checkZigZagSegmentPattern(x, y, points);</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">            if (segment == null) {</span>
<span class="fc" id="L302">                continue;</span>
            }

            /*
            Each of the 4 segment points needs at least one neighbor that is 
            not one of the 4 points in the zig zap and all of their neighbors 
            cannot be adjacent to any of the other neighbors.
            */
          
<span class="fc" id="L311">            Set&lt;PairInt&gt; endPoints = checkForZigZagEndPoints(points, segment);</span>
                
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">            if (endPoints == null || endPoints.isEmpty()) {</span>
<span class="nc" id="L314">                continue;</span>
            }
            
            // add all section and endpoints to a set to add to output
<span class="fc" id="L318">            Set&lt;PairInt&gt; allPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L319">            allPoints.addAll(endPoints);</span>
<span class="fc" id="L320">            allPoints.add(segment.p0);</span>
<span class="fc" id="L321">            allPoints.add(segment.p1);</span>
<span class="fc" id="L322">            allPoints.add(segment.p2);</span>
<span class="fc" id="L323">            allPoints.add(segment.p3);</span>

<span class="fc" id="L325">            output.add(allPoints);</span>
        }

<span class="fc" id="L328">        return output;</span>
    }

    private Segment checkSegmentPatterns(final int x, final int y, 
        Set&lt;PairInt&gt; neighbors) {

<span class="fc" id="L334">        Segment segment = checkVertSegmentPattern(x, y, neighbors);</span>
        
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (segment != null) {</span>
<span class="fc" id="L337">            return segment;</span>
        }
        
<span class="fc" id="L340">        segment = checkHorizSegmentPattern(x, y, neighbors);</span>
        
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (segment != null) {</span>
<span class="fc" id="L343">            return segment;</span>
        }
        
<span class="fc" id="L346">        segment = checkDiagSegmentPattern(x, y, neighbors);</span>
        
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (segment != null) {</span>
<span class="nc" id="L349">            return segment;</span>
        }
        
<span class="fc" id="L352">        return null;</span>
    }

    private void swapYDirection(Pattern pattern) {
        // ----- change the sign of y  -----
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L358">            p.setY(-1 * p.getY());</span>
<span class="fc" id="L359">        }</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L361">            p.setY(-1 * p.getY());</span>
<span class="fc" id="L362">        }</span>
<span class="fc" id="L363">    }</span>
    
    private void swapXDirection(Pattern pattern) {
        // ----- change the sign of x  -----
<span class="fc bfc" id="L367" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L368">            p.setX(-1 * p.getX());</span>
<span class="fc" id="L369">        }</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L371">            p.setX(-1 * p.getX());</span>
<span class="fc" id="L372">        }</span>
<span class="fc" id="L373">    }</span>

    private Set&lt;PairInt&gt; checkForAdjacentEndpoints(Set&lt;PairInt&gt; points,
        LinkedList&lt;Segment&gt; section, Set&lt;PairInt&gt; exclude, 
        boolean checkFirstSegment) {
        
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        Segment segment = checkFirstSegment ? section.getFirst() : </span>
<span class="pc" id="L380">            section.getLast();</span>
                        
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (segment instanceof VertSegment) {</span>
<span class="fc" id="L383">            return checkForAdjacentEndpointsForVertSegment(points, section, </span>
                exclude, checkFirstSegment);
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        } else if (segment instanceof HorizSegment) {</span>
<span class="fc" id="L386">            return checkForAdjacentEndpointsForHorizSegment(points, section, </span>
                exclude, checkFirstSegment);
<span class="nc bnc" id="L388" title="All 2 branches missed.">        } else if (segment instanceof UUDiagSegment) {</span>
<span class="nc" id="L389">            return checkForAdjacentEndpointsForUUDiagSegment(points, section, </span>
                exclude, checkFirstSegment);
        }
        
<span class="nc" id="L393">        return null;</span>
        
        /*endpoints for horiz:
                       #           #
            # .        - .       - - .
          - - .  or  - - .  or     # .
            #          #

        endpoints for vert:
                -        - -       -
              # - #    # - - #   # - #
              . .        . .       . .

        endpoints for diag:

            -  #             -  #               -  #
            -    .        -  -  .            #  -  .
            #  .   .      #  .    .          -  .    .
                 .              .                  .
        */
        
    }

    private Set&lt;PairInt&gt; checkForAdjacentEndpointsForVertSegment(
        Set&lt;PairInt&gt; points, LinkedList&lt;Segment&gt; section, Set&lt;PairInt&gt; exclude, 
        boolean checkFirstSegment) {
        
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        VertSegment segment = checkFirstSegment ? (VertSegment)section.getFirst() :</span>
<span class="pc" id="L421">            (VertSegment)section.getLast();</span>
                
        /*endpoints for vert:
                -        - -       -
              # - #    # - - #   # - #
              . .        . .       . .
        */
       
<span class="fc" id="L429">        Set&lt;PairInt&gt; endPoints = findEndPointsVertPatterns(points, segment,</span>
            exclude);
        
<span class="fc" id="L432">        return endPoints;</span>
    }

    private Set&lt;PairInt&gt; findEndPointsVertPatterns(Set&lt;PairInt&gt; points, 
        VertSegment segment, Set&lt;PairInt&gt; exclude) {
        
<span class="fc" id="L438">        int x0 = segment.p0.getX();</span>
<span class="fc" id="L439">        int y0 = segment.p0.getY();</span>
        
<span class="fc" id="L441">        Pattern[] patterns = new Pattern[] {</span>
<span class="fc" id="L442">            getEndPointsVertPattern1(), getEndPointsVertPattern1Opp(),</span>
<span class="fc" id="L443">            getEndPointsVertPattern2(), getEndPointsVertPattern2Opp(),</span>
<span class="fc" id="L444">            getEndPointsVertPattern3(), getEndPointsVertPattern3Opp()</span>
        };
        
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (Pattern pattern : patterns) {</span>
<span class="fc" id="L448">            boolean found = true;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L450">                PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">                if (points.contains(p2) || exclude.contains(p2)) {</span>
<span class="fc" id="L452">                    found = false;</span>
<span class="fc" id="L453">                    break;</span>
                }
<span class="fc" id="L455">            }</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (found) {</span>
<span class="fc" id="L457">                Set&lt;PairInt&gt; endPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L459">                    PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">                    if (segment.contains(p2)) {</span>
<span class="fc" id="L461">                        continue;</span>
                    }
<span class="fc bfc" id="L463" title="All 4 branches covered.">                    if (exclude.contains(p2) || !points.contains(p2)) {</span>
<span class="fc" id="L464">                        found = false;</span>
<span class="fc" id="L465">                        break;</span>
                    }
<span class="fc" id="L467">                    endPoints.add(p2);</span>
<span class="fc" id="L468">                }</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                if (found) {</span>
<span class="fc" id="L470">                    return endPoints;</span>
                }
            }
        }        
<span class="fc" id="L474">        return null;</span>
    }
    
    private Pattern getEndPointsVertPattern1() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -      -4
              #  -  #   -3
           -  .  .  -   -2
           -  2  1  -   -1
           -  3  0  -    0
                        
          -2 -1  0  1
        */
<span class="fc" id="L489">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L490">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L491">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L493">        pattern.ones.add(new PairInt(0, -2)); pattern.ones.add(new PairInt(-1, -2));</span>
<span class="fc" id="L494">        pattern.ones.add(new PairInt(1, -3)); pattern.ones.add(new PairInt(-1, -3));</span>
        
<span class="fc" id="L496">        pattern.zeroes.add(new PairInt(-2, -2)); pattern.zeroes.add(new PairInt(1, -2));</span>
<span class="fc" id="L497">        pattern.zeroes.add(new PairInt(0, -3)); pattern.zeroes.add(new PairInt(0, -4));</span>
<span class="fc" id="L498">        return pattern;</span>
    }
    
    private Pattern getEndPointsVertPattern1Opp() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
                            
           -  2  1  -    1
           -  3  0  -    0
           -  .  .  -   -1
              #  -  #   -2
                 -      -3
          -2 -1  0  1
        */
<span class="fc" id="L512">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L513">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L514">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L516">        pattern.ones.add(new PairInt(-1, -1)); pattern.ones.add(new PairInt(-1, -2)); </span>
<span class="fc" id="L517">        pattern.ones.add(new PairInt(0, -1));</span>
<span class="fc" id="L518">        pattern.ones.add(new PairInt(1, -2));</span>
        
<span class="fc" id="L520">        pattern.zeroes.add(new PairInt(-2, -1)); </span>
<span class="fc" id="L521">        pattern.zeroes.add(new PairInt(0, -2)); pattern.zeroes.add(new PairInt(0, -3));</span>
<span class="fc" id="L522">        pattern.zeroes.add(new PairInt(1, -1));</span>
<span class="fc" id="L523">        return pattern;</span>
    }
    
    private Pattern getEndPointsVertPattern2() {
        
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
              -  -      -4
           #  -  -  #   -3
           -  .  .  -   -2
           -  2  1  -   -1
           -  3  0  -    0
                        
          -2 -1  0  1
        */
        
<span class="fc" id="L540">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L541">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L542">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L544">        pattern.ones.add(new PairInt(-1, -2)); pattern.ones.add(new PairInt(0, -2));</span>
<span class="fc" id="L545">        pattern.ones.add(new PairInt(-2, -3)); pattern.ones.add(new PairInt(1, -3));</span>
        
<span class="fc" id="L547">        pattern.zeroes.add(new PairInt(-2, -2)); pattern.zeroes.add(new PairInt(1, -2));</span>
<span class="fc" id="L548">        pattern.zeroes.add(new PairInt(-1, -3)); pattern.zeroes.add(new PairInt(-1, -4));</span>
<span class="fc" id="L549">        pattern.zeroes.add(new PairInt(0, -3)); pattern.zeroes.add(new PairInt(0, -4));</span>
        
<span class="fc" id="L551">        return pattern;</span>
    }
    
    private Pattern getEndPointsVertPattern2Opp() {
        
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
           -  2  1  -    1
           -  3  0  -    0
           -  .  .  -   -1
           #  -  -  #   -2
              -  -      -3
          -2 -1  0  1
        */
     
<span class="fc" id="L567">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L568">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L569">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L571">        pattern.ones.add(new PairInt(-2, -2)); </span>
<span class="fc" id="L572">        pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L573">        pattern.ones.add(new PairInt(0, -1)); </span>
<span class="fc" id="L574">        pattern.ones.add(new PairInt(1, -2));</span>
        
<span class="fc" id="L576">        pattern.zeroes.add(new PairInt(-2, -1)); </span>
<span class="fc" id="L577">        pattern.zeroes.add(new PairInt(-1, -2)); pattern.zeroes.add(new PairInt(-1, -3));</span>
<span class="fc" id="L578">        pattern.zeroes.add(new PairInt(0, -3)); pattern.zeroes.add(new PairInt(0, -2));</span>
        
<span class="fc" id="L580">        return pattern;</span>
    }

    private Pattern getEndPointsVertPattern3() {
        
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
                
                 -      -4
              #  -  #   -3
           -  .  .  -   -2
           -  2  1  -   -1
           -  3  0  -    0
                        
          -2 -1  0  1
       
        */
        
<span class="fc" id="L598">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L599">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L600">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L602">        pattern.ones.add(new PairInt(-1, -2)); pattern.ones.add(new PairInt(1, -3));</span>
<span class="fc" id="L603">        pattern.ones.add(new PairInt(0, -2));</span>
<span class="fc" id="L604">        pattern.ones.add(new PairInt(1, -3)); </span>
        
<span class="fc" id="L606">        pattern.zeroes.add(new PairInt(-2, -2)); </span>
<span class="fc" id="L607">        pattern.zeroes.add(new PairInt(0, -3)); pattern.zeroes.add(new PairInt(0, -4));</span>
<span class="fc" id="L608">        pattern.zeroes.add(new PairInt(1, -2)); </span>
        
<span class="fc" id="L610">        return pattern;</span>
    }
    
    private Pattern getEndPointsVertPattern3Opp() {
        
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
                                 
           -  2  1  -    1
           -  3  0  -    0
           -  .  .  -   -1
              #  -  #   -2
                 -      -3
          -2 -1  0  1
        */
        
<span class="fc" id="L626">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L627">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L628">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L630">        pattern.ones.add(new PairInt(-1, -1)); pattern.ones.add(new PairInt(-1, -2));</span>
<span class="fc" id="L631">        pattern.ones.add(new PairInt(0, -1)); </span>
<span class="fc" id="L632">        pattern.ones.add(new PairInt(1, -2));</span>
        
<span class="fc" id="L634">        pattern.zeroes.add(new PairInt(-2, -1)); </span>
<span class="fc" id="L635">        pattern.zeroes.add(new PairInt(0, -2)); pattern.zeroes.add(new PairInt(0, -3));</span>
<span class="fc" id="L636">        pattern.zeroes.add(new PairInt(1, -1));</span>
        
<span class="fc" id="L638">        return pattern;</span>
    }
    
    private Set&lt;PairInt&gt; checkForAdjacentEndpointsForHorizSegment(
        Set&lt;PairInt&gt; points, LinkedList&lt;Segment&gt; section, Set&lt;PairInt&gt; exclude, 
        boolean checkFirstSegment) {
        
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        HorizSegment segment = checkFirstSegment ? (HorizSegment)section.getFirst() :</span>
<span class="pc" id="L646">            (HorizSegment)section.getLast();</span>
                
<span class="fc" id="L648">        Set&lt;PairInt&gt; endPoints = findEndPointsHorizPatterns(points, segment,</span>
            exclude);
        
<span class="fc" id="L651">        return endPoints;</span>
    }
    
    private Set&lt;PairInt&gt; findEndPointsHorizPatterns(Set&lt;PairInt&gt; points, 
        HorizSegment segment, Set&lt;PairInt&gt; exclude) {
        
<span class="fc" id="L657">        int x0 = segment.p0.getX();</span>
<span class="fc" id="L658">        int y0 = segment.p0.getY();</span>
        
<span class="fc" id="L660">        Pattern[] patterns = new Pattern[] {</span>
<span class="fc" id="L661">            getEndPointsHorizPattern1(), getEndPointsHorizPattern1Opp(),</span>
<span class="fc" id="L662">            getEndPointsHorizPattern2(), getEndPointsHorizPattern2Opp(),</span>
<span class="fc" id="L663">            getEndPointsHorizPattern3(), getEndPointsHorizPattern3Opp()</span>
        };
        
<span class="fc bfc" id="L666" title="All 2 branches covered.">        for (Pattern pattern : patterns) {</span>
<span class="fc" id="L667">            boolean found = true;</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L669">                PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="pc bpc" id="L670" title="1 of 4 branches missed.">                if (points.contains(p2) || exclude.contains(p2)) {</span>
<span class="fc" id="L671">                    found = false;</span>
<span class="fc" id="L672">                    break;</span>
                }
<span class="fc" id="L674">            }</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (found) {</span>
<span class="fc" id="L676">                Set&lt;PairInt&gt; endPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">                for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L678">                    PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">                    if (segment.contains(p2)) {</span>
<span class="fc" id="L680">                        continue;</span>
                    }
<span class="fc bfc" id="L682" title="All 4 branches covered.">                    if (exclude.contains(p2) || !points.contains(p2)) {</span>
<span class="fc" id="L683">                        found = false;</span>
<span class="fc" id="L684">                        break;</span>
                    }
<span class="fc" id="L686">                    endPoints.add(p2);</span>
<span class="fc" id="L687">                }</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">                if (found) {</span>
<span class="fc" id="L689">                    return endPoints;</span>
                }
            }
        }        
<span class="fc" id="L693">        return null;</span>
    }
    
    private Pattern getEndPointsHorizPattern1() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -  -       -2
              .  2  1  .  #    -1
              .  3  0  .  -  -  0
                 -  -  -  #     1
             -2 -1  0  1  2  3
        */
<span class="fc" id="L706">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L707">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L708">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
    
<span class="fc" id="L710">        pattern.ones.add(new PairInt(1, 0)); pattern.ones.add(new PairInt(1, -1));</span>
<span class="fc" id="L711">        pattern.ones.add(new PairInt(2, 1)); pattern.ones.add(new PairInt(2, -1));</span>
        
<span class="fc" id="L713">        pattern.zeroes.add(new PairInt(1, 1)); pattern.zeroes.add(new PairInt(1, -2));</span>
<span class="fc" id="L714">        pattern.zeroes.add(new PairInt(2, 0)); </span>
<span class="fc" id="L715">        pattern.zeroes.add(new PairInt(3, 0));</span>
        
<span class="fc" id="L717">        return pattern;</span>
    }
    
    private Pattern getEndPointsHorizPattern1Opp() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -  -       -2
              .  2  1  .  #    -1
              .  3  0  .  -  -  0
                 -  -  -  #     1
              2  1  0 -1 -2 -3
        */
<span class="fc" id="L730">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L731">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L732">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
     
<span class="fc" id="L734">        pattern.ones.add(new PairInt(-1, 0)); pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L735">        pattern.ones.add(new PairInt(-2, 1)); pattern.ones.add(new PairInt(-2, -1));</span>
        
<span class="fc" id="L737">        pattern.zeroes.add(new PairInt(-1, 1)); pattern.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L738">        pattern.zeroes.add(new PairInt(-2, 0)); pattern.zeroes.add(new PairInt(-3, 0));</span>
        
<span class="fc" id="L740">        return pattern;</span>
    }
   
    private Pattern getEndPointsHorizPattern2() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -  -  #    -2
              .  2  1  .  -    -1
              .  3  0  .  -  -  0
                 -  -  -  #     1
             -2 -1  0  1  2  3
        */
<span class="fc" id="L753">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L754">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L755">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
     
<span class="fc" id="L757">        pattern.ones.add(new PairInt(1, 0)); pattern.ones.add(new PairInt(1, -1));</span>
<span class="fc" id="L758">        pattern.ones.add(new PairInt(2, 1)); pattern.ones.add(new PairInt(2, -2));</span>
        
<span class="fc" id="L760">        pattern.zeroes.add(new PairInt(1, 1)); pattern.zeroes.add(new PairInt(1, -2));</span>
<span class="fc" id="L761">        pattern.zeroes.add(new PairInt(2, 0)); pattern.zeroes.add(new PairInt(2, -1));</span>
<span class="fc" id="L762">        pattern.zeroes.add(new PairInt(3, 0));</span>
        
<span class="fc" id="L764">        return pattern;</span>
    }
     
    private Pattern getEndPointsHorizPattern2Opp() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -  -  #    -2
              .  2  1  .  -    -1
              .  3  0  .  -  -  0
                 -  -  -  #     1
              2  1  0 -1 -2 -3
        */
<span class="fc" id="L777">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L778">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L779">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
    
<span class="fc" id="L781">        pattern.ones.add(new PairInt(-1, 0)); pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L782">        pattern.ones.add(new PairInt(-2, 1)); pattern.ones.add(new PairInt(-2, -2));</span>
        
<span class="fc" id="L784">        pattern.zeroes.add(new PairInt(-1, 1)); pattern.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L785">        pattern.zeroes.add(new PairInt(-2, 0)); pattern.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L786">        pattern.zeroes.add(new PairInt(-3, 0));</span>
        
<span class="fc" id="L788">        return pattern;</span>
    }
 
    private Pattern getEndPointsHorizPattern3() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -  -  #    -2
              .  2  1  .  -  - -1
              .  3  0  .  #     0
                 -  -  -        1
             -2 -1  0  1  2  3
        */
<span class="fc" id="L801">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L802">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L803">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
    
<span class="fc" id="L805">        pattern.ones.add(new PairInt(1, 0)); pattern.ones.add(new PairInt(1, -1));</span>
<span class="fc" id="L806">        pattern.ones.add(new PairInt(2, 0)); pattern.ones.add(new PairInt(2, -2));</span>
        
<span class="fc" id="L808">        pattern.zeroes.add(new PairInt(1, 1)); pattern.zeroes.add(new PairInt(1, -2));</span>
<span class="fc" id="L809">        pattern.zeroes.add(new PairInt(2, -1)); pattern.zeroes.add(new PairInt(3, -1));</span>
        
<span class="fc" id="L811">        return pattern;</span>
    }
    
    private Pattern getEndPointsHorizPattern3Opp() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -  -  #     -2
              .  2  1  .  -  -  -1
              .  3  0  .  #      0
                 -  -  -         1
              2  1  0 -1 -2 -3
        */
<span class="fc" id="L824">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L825">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L826">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
    
<span class="fc" id="L828">        pattern.ones.add(new PairInt(-1, 0)); pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L829">        pattern.ones.add(new PairInt(-2, 0)); pattern.ones.add(new PairInt(-2, -2));</span>
        
<span class="fc" id="L831">        pattern.zeroes.add(new PairInt(-1, 1)); pattern.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L832">        pattern.zeroes.add(new PairInt(-2, -1)); pattern.zeroes.add(new PairInt(-3, -1));</span>
        
<span class="fc" id="L834">        return pattern;</span>
    }
    
    private Set&lt;PairInt&gt; checkForAdjacentEndpointsForUUDiagSegment(
        Set&lt;PairInt&gt; points, LinkedList&lt;Segment&gt; section, Set&lt;PairInt&gt; exclude, 
        boolean checkFirstSegment) {
        
<span class="nc bnc" id="L841" title="All 2 branches missed.">        UUDiagSegment segment = checkFirstSegment ? (UUDiagSegment)section.getFirst() :</span>
<span class="nc" id="L842">            (UUDiagSegment)section.getLast();</span>
                
<span class="nc" id="L844">        Set&lt;PairInt&gt; endPoints = findEndPointsUUDiagPatterns(points, segment,</span>
            exclude);
        
<span class="nc" id="L847">        return endPoints;</span>
    }
    
    private Set&lt;PairInt&gt; findEndPointsUUDiagPatterns(Set&lt;PairInt&gt; points, 
        UUDiagSegment segment, Set&lt;PairInt&gt; exclude) {
        
<span class="nc" id="L853">        int x0 = segment.p0.getX();</span>
<span class="nc" id="L854">        int y0 = segment.p0.getY();</span>
        
<span class="nc" id="L856">        Pattern[] patterns = new Pattern[] {</span>
<span class="nc" id="L857">            getEndPointsUUDiagPattern1(), getEndPointsULDiagPattern1(),</span>
<span class="nc" id="L858">            getEndPointsUUDiagPattern2(), getEndPointsULDiagPattern2(),</span>
<span class="nc" id="L859">            getEndPointsUUDiagPattern3(), getEndPointsULDiagPattern3()</span>
        };
        
<span class="nc bnc" id="L862" title="All 2 branches missed.">        for (Pattern pattern : patterns) {</span>
<span class="nc" id="L863">            boolean found = true;</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            for (PairInt p : pattern.zeroes) {</span>
<span class="nc" id="L865">                PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="nc bnc" id="L866" title="All 4 branches missed.">                if (points.contains(p2) || exclude.contains(p2)) {</span>
<span class="nc" id="L867">                    found = false;</span>
<span class="nc" id="L868">                    break;</span>
                }
<span class="nc" id="L870">            }</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (found) {</span>
<span class="nc" id="L872">                Set&lt;PairInt&gt; endPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                for (PairInt p : pattern.ones) {</span>
<span class="nc" id="L874">                    PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
                    //TODO: check this segment test with tests
<span class="nc bnc" id="L876" title="All 2 branches missed.">                    if (segment.contains(p2)) {</span>
<span class="nc" id="L877">                        continue;</span>
                    }
<span class="nc bnc" id="L879" title="All 4 branches missed.">                    if (exclude.contains(p2) || !points.contains(p2)) {</span>
<span class="nc" id="L880">                        found = false;</span>
<span class="nc" id="L881">                        break;</span>
                    }
<span class="nc" id="L883">                    endPoints.add(p2);</span>
<span class="nc" id="L884">                }</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L886">                    return endPoints;</span>
                }
            }
        }        
<span class="nc" id="L890">        return null;</span>
    }
    
    private Pattern getEndPointsUUDiagPattern1() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                -  -          -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0
             -  .  -           1
                -  #           2
        
         -3 -2 -1  0  1
        */
<span class="nc" id="L905">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L906">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L907">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
    
<span class="nc" id="L909">        pattern.ones.add(new PairInt(-1, 1)); </span>
<span class="nc" id="L910">        pattern.ones.add(new PairInt(0, 2));</span>
<span class="nc" id="L911">        pattern.ones.add(new PairInt(1, 0));</span>
        
<span class="nc" id="L913">        pattern.zeroes.add(new PairInt(-1, 1));</span>
<span class="nc" id="L914">        pattern.zeroes.add(new PairInt(0, 1)); </span>
<span class="nc" id="L915">        pattern.zeroes.add(new PairInt(0, -1));</span>
        
<span class="nc" id="L917">        return pattern;</span>
    }
    
    private Pattern getEndPointsULDiagPattern1() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.        
        
                -  -          -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0
             -  .  -  -        1
                -  #           2
        
          3  2  1  0  -1
        */
<span class="nc" id="L932">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L933">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L934">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L936">        pattern.ones.add(new PairInt(1, 1)); </span>
<span class="nc" id="L937">        pattern.ones.add(new PairInt(0, 2));</span>
<span class="nc" id="L938">        pattern.ones.add(new PairInt(-1, 0));</span>
        
<span class="nc" id="L940">        pattern.zeroes.add(new PairInt(1, 2)); </span>
<span class="nc" id="L941">        pattern.zeroes.add(new PairInt(0, 1)); pattern.zeroes.add(new PairInt(0, -1));</span>
<span class="nc" id="L942">        pattern.zeroes.add(new PairInt(-1, 1)); </span>
        
<span class="nc" id="L944">        return pattern;</span>
    }
    
    private Pattern getEndPointsUUDiagPattern2() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
                -  -          -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0
             -  .  -           1
                #  -           2
        
         -3 -2 -1  0  1
        */
<span class="nc" id="L958">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L959">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L960">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L962">        pattern.ones.add(new PairInt(-1, 2)); pattern.ones.add(new PairInt(-1, 1));</span>
        
<span class="nc" id="L964">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 1)); pattern.zeroes.add(new PairInt(0, 1));</span>
        
<span class="nc" id="L966">        return pattern;</span>
    }
    
    private Pattern getEndPointsULDiagPattern2() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                 -  -         -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0
             -  .  -  -        1
                #  -           2
        
          3  2  1  0 -1
        */
<span class="nc" id="L981">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L982">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L983">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
   
<span class="nc" id="L985">        pattern.ones.add(new PairInt(1, 2)); pattern.ones.add(new PairInt(1, 1));</span>
<span class="nc" id="L986">        pattern.ones.add(new PairInt(-1, 0));</span>
        
<span class="nc" id="L988">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 1)); pattern.zeroes.add(new PairInt(0, -1));</span>
<span class="nc" id="L989">        pattern.zeroes.add(new PairInt(-1, 1)); pattern.zeroes.add(new PairInt(-1, -1)); </span>
        
<span class="nc" id="L991">        return pattern;</span>
    }
    
    private Pattern getEndPointsUUDiagPattern3() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                -  -          -2
          -  2  1  -          -1
          -  -  3 .0  -        0
             -  .  -  #        1
                #  -           2
        
         -3 -2 -1  0  1
        */
<span class="nc" id="L1006">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L1007">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1008">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
   
<span class="nc" id="L1010">        pattern.ones.add(new PairInt(-1, 2)); pattern.ones.add(new PairInt(-1, 1));</span>
<span class="nc" id="L1011">        pattern.ones.add(new PairInt(1, 1));</span>
       
<span class="nc" id="L1013">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 1)); pattern.zeroes.add(new PairInt(0, -1));</span>
<span class="nc" id="L1014">        pattern.zeroes.add(new PairInt(1, 0)); </span>
        
<span class="nc" id="L1016">        return pattern;</span>
    }
    
    private Pattern getEndPointsULDiagPattern3() {
        /* the pattern returned is relative to 
        position '0', just like the other patterns.
        
                -  -          -2
          -  2  1  -          -1
          -  -  3 .0  -        0
             -  .  -  #        1
                #  -           2
        
          3  2  1  0 -1
        */
<span class="nc" id="L1031">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L1032">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1033">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>
    
<span class="nc" id="L1035">        pattern.ones.add(new PairInt(1, 2)); pattern.ones.add(new PairInt(1, 1));</span>
<span class="nc" id="L1036">        pattern.ones.add(new PairInt(-1, 1));</span>
        
<span class="nc" id="L1038">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 1)); pattern.zeroes.add(new PairInt(0, -1));</span>
<span class="nc" id="L1039">        pattern.zeroes.add(new PairInt(-1, 0));</span>
        
<span class="nc" id="L1041">        return pattern;</span>
    }

    private Set&lt;PairInt&gt; checkForZigZagEndPoints(Set&lt;PairInt&gt; points, 
        Segment segment) {
        
        /*Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.*/
        
<span class="fc" id="L1051">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L1053">        List&lt;Set&lt;PairInt&gt;&gt; listOfNeighbors = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="fc" id="L1054">        Set&lt;PairInt&gt; segmentPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1055">        segmentPoints.add(segment.p0);</span>
<span class="fc" id="L1056">        segmentPoints.add(segment.p1);</span>
<span class="fc" id="L1057">        segmentPoints.add(segment.p2);</span>
<span class="fc" id="L1058">        segmentPoints.add(segment.p3);</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        for (PairInt p : segmentPoints) {</span>
<span class="fc" id="L1060">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(p.getX(), </span>
<span class="fc" id="L1061">                p.getY(), points);</span>
<span class="fc" id="L1062">            neighbors.removeAll(segmentPoints);</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">            if (neighbors.size() != 1) {</span>
<span class="fc" id="L1064">                return null;</span>
            }
<span class="fc" id="L1066">            listOfNeighbors.add(neighbors);</span>
<span class="fc" id="L1067">        }</span>
        // assert that each in list has no members adjacent to any other members
        // TODO: could use a data structure that uses spatial indexing to make 
        // this faster, but there are not very many points per 4 sets to compare...
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {</span>
<span class="fc" id="L1072">            Set&lt;PairInt&gt; setI = listOfNeighbors.get(i);</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">            for (PairInt pI : setI) {</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">                for (int j = (i + 1); j &lt; listOfNeighbors.size(); ++j) {</span>
<span class="fc" id="L1075">                    Set&lt;PairInt&gt; setJ = listOfNeighbors.get(j);</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                    for (PairInt pJ : setJ) {</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">                        if (areAdjacent(pI, pJ)) {</span>
<span class="fc" id="L1078">                            return null;</span>
                        }
<span class="fc" id="L1080">                    }</span>
                }
<span class="fc" id="L1082">            }</span>
        }
        // if arrive here, all neighbor sets have at least one point and none
        // are adjacent to points in a different set.
<span class="fc" id="L1086">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : listOfNeighbors) {</span>
<span class="fc" id="L1088">            output.addAll(set);</span>
<span class="fc" id="L1089">        }</span>
<span class="fc" id="L1090">        return output;</span>
    }
    
    private boolean areAdjacent(PairInt p0, PairInt p1) {
<span class="fc" id="L1094">        int diffX = Math.abs(p0.getX() - p1.getX());</span>
<span class="fc" id="L1095">        int diffY = Math.abs(p0.getY() - p1.getY());</span>
<span class="fc bfc" id="L1096" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L1097">            return true;</span>
        }
<span class="fc" id="L1099">        return false;</span>
    }
    
    /*
    may change these classes to have ordered points or to specify the
    indexes of points that are the connections, that is the '.'s in sketches
    below.
    */
    public static class Segment {
        // the 4 points matching the segment as 0, 1, 2, 3 in the subclasses
        PairInt p0;
        PairInt p1;
        PairInt p2;
        PairInt p3;
        boolean contains(PairInt p) {
            if (p0.equals(p)) {
                return true;
            } else if (p1.equals(p)) {
                return true;
            } else if (p2.equals(p)) {
                return true;
            } else if (p3.equals(p)) {
                return true;
            }
            return false;
        }
    }
    
    public static class VertSegment extends Segment {
        /*    .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
              .  .       1
          -2 -1  0  1
        */
    }
    public static class HorizSegment extends Segment {
        /*    -  -      -2
           .  2  1  .   -1
           .  3  0  .    0
              -  -       1
          -2 -1  0  1
        */
    }
    public static class UUDiagSegment extends Segment {
        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
         -3 -2 -1  0  1
        */
    }
    public static class ULDiagSegment extends Segment {
        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
          3  2  1  0 -1
        */
    }
    public static class ZigZagSegment extends Segment {
        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
                   -  3       1

         -3 -2 -1  0  1
        */
    }

<span class="fc" id="L1170">    public static class Pattern {</span>
        Set&lt;PairInt&gt; ones;
        Set&lt;PairInt&gt; zeroes;
    }

    protected Pattern getVertSegmentPattern() {

        /*    .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
              .  .       1
          -2 -1  0  1
        */
<span class="fc" id="L1183">        Pattern pr = new Pattern();</span>
<span class="fc" id="L1184">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1185">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1187">        pr.zeroes.add(new PairInt(-2, 0)); pr.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L1188">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -1));</span>

<span class="fc" id="L1190">        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L1191">        pr.ones.add(new PairInt(0, -1));</span>

<span class="fc" id="L1193">        return pr;</span>
    }
    
    protected Pattern getHorizSegmentPattern() {

        /*    -  -      -2
           .  2  1  .   -1
           .  3  0  .    0
              -  -       1
          -2 -1  0  1
        */
<span class="fc" id="L1204">        Pattern pr = new Pattern();</span>
<span class="fc" id="L1205">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1206">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1208">        pr.zeroes.add(new PairInt(-1, 1)); pr.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L1209">        pr.zeroes.add(new PairInt(0, 1)); pr.zeroes.add(new PairInt(0, -2));</span>

<span class="fc" id="L1211">        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L1212">        pr.ones.add(new PairInt(1, 0)); pr.ones.add(new PairInt(1, -1));</span>

<span class="fc" id="L1214">        return pr;</span>
    }
    
    protected Pattern getUUDiagSegmentPattern() {

        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
         -3 -2 -1  0  1
        */
<span class="fc" id="L1225">        Pattern pr = new Pattern();</span>
<span class="fc" id="L1226">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1227">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1229">        pr.zeroes.add(new PairInt(-3, 0)); pr.zeroes.add(new PairInt(-3, -1));</span>
<span class="fc" id="L1230">        pr.zeroes.add(new PairInt(-2, 1)); pr.zeroes.add(new PairInt(-2, 0));</span>
<span class="fc" id="L1231">        pr.zeroes.add(new PairInt(-1, 1)); pr.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L1232">        pr.zeroes.add(new PairInt(0, -1)); pr.zeroes.add(new PairInt(0, -2));</span>
<span class="fc" id="L1233">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -1));</span>

<span class="fc" id="L1235">        pr.ones.add(new PairInt(-2, -1)); </span>
<span class="fc" id="L1236">        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));</span>

<span class="fc" id="L1238">        return pr;</span>
    }

    protected Pattern getZigZagSegmentPattern() {

        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
                   -  3       1
                       
         -3 -2 -1  0  1
        
        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
<span class="fc" id="L1255">        Pattern pr = new Pattern();</span>
<span class="fc" id="L1256">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1257">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1259">        pr.zeroes.add(new PairInt(0, 1)); pr.zeroes.add(new PairInt(0, -1));</span>
<span class="fc" id="L1260">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -2));</span>

<span class="fc" id="L1262">        pr.ones.add(new PairInt(0, -2));</span>
<span class="fc" id="L1263">        pr.ones.add(new PairInt(1, 1)); pr.ones.add(new PairInt(1, -1));</span>

<span class="fc" id="L1265">        return pr;</span>
    }
    
    private Segment checkVertSegmentPattern(int x, int y, Set&lt;PairInt&gt; neighbors) {

        /*    .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
              .  .       1
          -2 -1  0  1
        */
        
<span class="fc" id="L1277">        Pattern pattern = getVertSegmentPattern();</span>
        
<span class="fc" id="L1279">        boolean matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
        
<span class="fc bfc" id="L1281" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L1282">            VertSegment segment = new VertSegment();</span>
<span class="fc" id="L1283">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1284">            segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L1285">            segment.p2 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L1286">            segment.p3 = new PairInt(x - 1, y);</span>
            
<span class="fc" id="L1288">            return segment;</span>
        }
        
<span class="fc" id="L1291">        swapYDirection(pattern);</span>
        
<span class="fc" id="L1293">        matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
        
        /*    .  .       2
           -  2  1  -    1
           -  3  0  -    0
              .  .      -1
          -2 -1  0  1
        */
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L1302">            VertSegment segment = new VertSegment();</span>
<span class="fc" id="L1303">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1304">            segment.p1 = new PairInt(x, y + 1);</span>
<span class="fc" id="L1305">            segment.p2 = new PairInt(x - 1, y + 1);</span>
<span class="fc" id="L1306">            segment.p3 = new PairInt(x - 1, y);</span>
<span class="fc" id="L1307">            return segment;</span>
        }
        
<span class="fc" id="L1310">        return null;</span>
    }
    
    private Segment checkHorizSegmentPattern(int x, int y, Set&lt;PairInt&gt; neighbors) {

        /*    -  -      -2
           .  2  1  .   -1
           .  3  0  .    0
              -  -       1
          -2 -1  0  1
        */
        
<span class="fc" id="L1322">        Pattern pattern = getHorizSegmentPattern();</span>
        
<span class="fc" id="L1324">        boolean matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
        
<span class="fc bfc" id="L1326" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L1327">            HorizSegment segment = new HorizSegment();</span>
<span class="fc" id="L1328">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1329">            segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L1330">            segment.p2 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L1331">            segment.p3 = new PairInt(x - 1, y);</span>
            
<span class="fc" id="L1333">            return segment;</span>
        }
        
<span class="fc" id="L1336">        swapXDirection(pattern);</span>
        
<span class="fc" id="L1338">        matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
        
        /*    -  -      -2
           .  2  1  .   -1
           .  3  0  .    0
              -  -       1
           2  1  0 -1
        */
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L1347">            HorizSegment segment = new HorizSegment();</span>
<span class="fc" id="L1348">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1349">            segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L1350">            segment.p2 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L1351">            segment.p3 = new PairInt(x + 1, y);</span>
            
<span class="fc" id="L1353">            return segment;</span>
        }
        
<span class="fc" id="L1356">        return null;</span>
    }
    
    private Segment checkDiagSegmentPattern(int x, int y, Set&lt;PairInt&gt; neighbors) {

<span class="fc" id="L1361">        Pattern pattern = getUUDiagSegmentPattern();</span>
        
<span class="fc" id="L1363">        boolean matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
        
        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
         -3 -2 -1  0  1
        */
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">        if (matchesPattern) {</span>
<span class="nc" id="L1372">            UUDiagSegment segment = new UUDiagSegment();</span>
<span class="nc" id="L1373">            segment.p0 = new PairInt(x, y);</span>
<span class="nc" id="L1374">            segment.p1 = new PairInt(x - 1, y - 1);</span>
<span class="nc" id="L1375">            segment.p2 = new PairInt(x - 2, y - 1);</span>
<span class="nc" id="L1376">            segment.p3 = new PairInt(x - 1, y);</span>
            
<span class="nc" id="L1378">            return segment;</span>
        }
        
<span class="fc" id="L1381">        swapXDirection(pattern);</span>
        
<span class="fc" id="L1383">        matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
        
        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
          3  2  1  0 -1
        */
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">        if (matchesPattern) {</span>
<span class="nc" id="L1392">            ULDiagSegment segment = new ULDiagSegment();</span>
<span class="nc" id="L1393">            segment.p0 = new PairInt(x, y);</span>
<span class="nc" id="L1394">            segment.p1 = new PairInt(x + 1, y - 1);</span>
<span class="nc" id="L1395">            segment.p2 = new PairInt(x + 2, y - 1);</span>
<span class="nc" id="L1396">            segment.p3 = new PairInt(x + 1, y);</span>
            
<span class="nc" id="L1398">            return segment;</span>
        }
        
<span class="fc" id="L1401">        return null;</span>
    }
    
    private Segment checkZigZagSegmentPattern(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L1406">        Pattern pattern = getZigZagSegmentPattern();</span>
        
<span class="fc" id="L1408">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>
        
        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
                   -  3       1
                       
         -3 -2 -1  0  1
        */
<span class="fc bfc" id="L1418" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L1419">            ZigZagSegment segment = new ZigZagSegment();</span>
<span class="fc" id="L1420">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1421">            segment.p1 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L1422">            segment.p2 = new PairInt(x, y - 2);</span>
<span class="fc" id="L1423">            segment.p3 = new PairInt(x + 1, y + 1);</span>
            
<span class="fc" id="L1425">            return segment;</span>
        }
        
<span class="fc" id="L1428">        swapXDirection(pattern);</span>
        
<span class="fc" id="L1430">        matchesPattern = matchesPattern(x, y, points, pattern);</span>
        
        /*
                -  2      -2
                1  -      -1
                -  0       0
                3  -       1
                       
         -3 -2 -1  0  1
        */
<span class="fc bfc" id="L1440" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L1441">            ZigZagSegment segment = new ZigZagSegment();</span>
<span class="fc" id="L1442">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1443">            segment.p1 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L1444">            segment.p2 = new PairInt(x, y - 2);</span>
<span class="fc" id="L1445">            segment.p3 = new PairInt(x - 1, y + 1);</span>
            
<span class="fc" id="L1447">            return segment;</span>
        }
        
<span class="fc" id="L1450">        return null;</span>
    }
    
    private boolean matchesPattern(final int x, final int y, Set&lt;PairInt&gt; neighbors, 
        Pattern pattern) {
                                                
<span class="fc bfc" id="L1456" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L1457">            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">            if (neighbors.contains(p2)) {</span>
<span class="fc" id="L1459">                return false;</span>
            }
<span class="fc" id="L1461">        }</span>
<span class="fc bfc" id="L1462" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L1463">            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">            if (!neighbors.contains(p2)) {</span>
<span class="fc" id="L1465">                return false;</span>
            }
<span class="fc" id="L1467">        }</span>
<span class="fc" id="L1468">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ButterflySectionFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">ButterflySectionFinder.java</span></div><h1>ButterflySectionFinder.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.misc.Misc;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L19" title="1 of 2 branches missed.">public class ButterflySectionFinder {</span>

    /**
     * Find sections of the closed curve that are two pixels wide and separate
     * loops in the curve:
     * &lt;pre&gt;
     * for example:         #  #
     *    #  #  #         #     #
     *  #         #  #  #      #
     *   #   #  # #  #  #  #  #
     * &lt;/pre&gt;
     * These sections are thinned to width of '1' by the line thinner,
     * so need to be restored afterwards or prevented from being removed.
     * @param closedCurve
     * @return list of points that are part of the 2 pixel width patterns in
     * a curve where the curve closes, but is still connected.
     */
    public List&lt;Routes&gt; findButterflySections(PairIntArray closedCurve) {

<span class="fc" id="L38">        Set&lt;PairInt&gt; points = Misc.convert(closedCurve);</span>

<span class="fc" id="L40">        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();</span>

<span class="fc" id="L42">        List&lt;Routes&gt; sections = findButterflySectionsLarge(closedCurve,</span>
            points);

<span class="fc bfc" id="L45" title="All 4 branches covered.">        if (sections != null &amp;&amp; !sections.isEmpty()) {</span>
<span class="fc" id="L46">            output.addAll(sections);</span>
        }

<span class="fc" id="L49">        List&lt;Routes&gt; sectionsSmall = findButterflySectionsSmall(closedCurve,</span>
            points);

<span class="pc bpc" id="L52" title="1 of 4 branches missed.">        if (sectionsSmall != null &amp;&amp; !sectionsSmall.isEmpty()) {</span>
<span class="fc" id="L53">            output.addAll(sectionsSmall);</span>
        }

<span class="fc" id="L56">        setNullEndpoints(output);</span>

<span class="fc" id="L58">        return output;</span>
    }

     /**
     * Find sections of the closed curve that are two pixels wide and separate
     * loops in the curve:
     * &lt;pre&gt;
     * for example:         #  #
     *    #  #  #         #     #
     *  #         #  #  #      #
     *   #   #  # #  #  #  #  #
     * &lt;/pre&gt;
     * These sections are thinned to width of '1' by the line thinner,
     * so need to be restored afterwards or prevented from being removed.
     * @param closedCurve
     * @param points
     * @return list of points that are part of the 2 pixel width patterns in
     * a curve where the curve closes, but is still connected.
     */
    protected List&lt;Routes&gt; findButterflySectionsLarge(PairIntArray
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L80">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L82">        List&lt;LinkedList&lt;Segment&gt;&gt; candidateSections = new ArrayList&lt;LinkedList&lt;Segment&gt;&gt;();</span>

<span class="fc" id="L84">        LinkedList&lt;Segment&gt; currentList = null;</span>

<span class="fc bfc" id="L86" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); ++i) {</span>

<span class="fc" id="L88">            int x = closedCurve.getX(i);</span>
<span class="fc" id="L89">            int y = closedCurve.getY(i);</span>

<span class="fc" id="L91">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);</span>

            // scanning for segments
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (neighbors.size() != 5) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                if (currentList != null) {</span>
<span class="fc" id="L96">                    candidateSections.add(currentList);</span>
<span class="fc" id="L97">                    currentList = null;</span>
                }
                continue;
            }

<span class="fc" id="L102">            Segment segment = checkSegmentPatterns(x, y, neighbors);</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">            if (segment == null) {</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                if (currentList != null) {</span>
<span class="nc" id="L106">                    candidateSections.add(currentList);</span>
<span class="nc" id="L107">                    currentList = null;</span>
                }
                continue;
            }

<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (currentList == null) {</span>
<span class="fc" id="L113">                currentList = new LinkedList&lt;Segment&gt;();</span>
            }

<span class="fc" id="L116">            currentList.add(segment);</span>
        }

<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (currentList != null) {</span>
<span class="nc" id="L120">            candidateSections.add(currentList);</span>
        }

<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (candidateSections.isEmpty()) {</span>
<span class="fc" id="L124">            return null;</span>
        }

        //TODO: correct for wrap around of section from end of curve to beginning

<span class="fc" id="L129">        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();</span>

        // -- scan for endpoints --
<span class="fc bfc" id="L132" title="All 2 branches covered.">        for (LinkedList&lt;Segment&gt; section : candidateSections) {</span>

<span class="fc" id="L134">            Routes routes = checkForAdjacentEndpoints(points, section);</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (routes == null) {</span>
<span class="fc" id="L137">                continue;</span>
            }

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            if (section.size() &gt; 1) {</span>

<span class="nc" id="L142">                routes = checkForAdjacentEndpoints(points, section, routes);</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">                if (routes == null) {</span>
<span class="nc" id="L145">                    continue;</span>
                }
            }

<span class="fc" id="L149">            output.add(routes);</span>
<span class="fc" id="L150">        }</span>

<span class="fc" id="L152">        return output;</span>

        /*
        endpoints for vert:
                       #           #
            # .      = - .      -  - .
          - - .  or  - - .  or     # .
            #          #

        endpoints for horiz:
                -        - -       -
              # - #    # - - #   # - #
              . .        . .       . .

        endpoints for diag:

            -  #             -  #               -  #
            -    .        -  -  .            #  -  .
            #  .   .      #  .    .          -  .    .
                 .              .                  .

        The sections of line which are 2 pixels wide and 1 further from the
        endpoint have 3 non-point neighbors each and 5 point set neighbors
        An area limit further constrains the geometry.
        For sections matching the patterns below, could consider storing
        the pattern for each pix as 'v', 'h', or 'd'...not an apparent use for
        that yet though.

        Segment patterns between endpoints:
                       4
           -  -  -  -  3
           .  #  #  .  2
           .  #  #  .  1
           -  -  -  -  0
        0  1  2  3  4

                        4
           -  .  .  -   3
           -  #  #  -   2
           -  #  #  -   1
           -  .  .  -   0
        0  1  2  3  4

           # # - -   3
           - # # - - 2
           - - # #   1
           - - - - - 0
        0  1 2 3 4 5

        data structures:
           linked lists of found pattern points as segments with
           specialization of each segment as VertSegment, HorizSegment,
              UUdiagsegment, ULdiagsegment



        Scan the line,
           if a point fits one of the 4 segment patterns (4th is diag transformed by x=-x),
           add it to a group and add the remaining pts fitting the pattern to a stack
           -- traverse the stack adding contiguous points to the group that fit the
              pattern.
           -- note where the first point in the pattern started, because
              when there are no more contiguous pattern matching points,
              the scan will continue at the next point after that first,
              but will skip those already added to a group.

        When the scan for groups has finished,
             for each group, need to apply the above endpoint patterns to see
             if the candidate segment is surrounded by 2 endpoints.

             test all candidate group points as adjacent to potential endpoints.

             When a match is found, have to exclude all of the matching pattern
             from the oppossing endpoint tests.

             This is the smallest pattern which will match that suggestion:
              - - - -
            # # @ # #
          - - # @ # -
            # - - - #
             The '@'s are the candidate group points.  The #'s are points
             matching endoint patterns.

             The found endpoints for one end, the left for example, would
             be excluded from a search for matching to the other endpoints.

        Note that this pattern and variants of it as very short sections and
        endpoints should be scanned after the above to find the shortest
        butterfly segments.
              - -
            # # @ #
          - - # @ -
            # - - #

          #
            #
              # # #
        # # #
              # # #

        For each segment group which has 2 matching endpoints, those should
        be stored as butterfly sections in a set.  Each one of those
        should be passed back in a list as the return of this method.

        runtime complexity is linear in the number of points in the given
        closed curve.
        */

    }

    protected List&lt;Routes&gt; findButterflySectionsSmall(PairIntArray
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L265">        List&lt;Routes&gt; routesList = findButterflySectionsSmallZigZag(closedCurve,</span>
            points);

<span class="pc bpc" id="L268" title="1 of 4 branches missed.">        if (routesList != null &amp;&amp; !routesList.isEmpty()) {</span>
<span class="fc" id="L269">            return routesList;</span>
        }

<span class="fc" id="L272">        routesList = findButterflySectionsSmallDiagZigZag(closedCurve,</span>
            points);

<span class="fc" id="L275">        return routesList;</span>
    }

    protected List&lt;Routes&gt; findButterflySectionsSmallZigZag(PairIntArray
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L281">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L283">        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); ++i) {</span>

<span class="fc" id="L287">            int x = closedCurve.getX(i);</span>
<span class="fc" id="L288">            int y = closedCurve.getY(i);</span>

<span class="fc" id="L290">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);</span>

            // scanning for segments
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (neighbors.size() != 3) {</span>
<span class="fc" id="L294">                continue;</span>
            }

<span class="fc" id="L297">            Segment segment = checkZigZagSegmentPattern(x, y, points);</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (segment == null) {</span>
<span class="fc" id="L300">                segment = checkZigZag2SegmentPattern(x, y, points);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                if (segment == null) {</span>
<span class="fc" id="L302">                    continue;</span>
                }
            }

            /*
            Each of the 4 segment points needs at least one neighbor that is
            not one of the 4 points in the zig zap and all of their neighbors
            cannot be adjacent to any of the other neighbors.
            */

<span class="fc" id="L312">            Set&lt;PairInt&gt; endPoints = checkForZigZagEndPoints(points, segment);</span>

<span class="pc bpc" id="L314" title="1 of 4 branches missed.">            if (endPoints == null || endPoints.isEmpty()) {</span>
<span class="nc" id="L315">                continue;</span>
            }

<span class="fc" id="L318">            ZigZagSegmentRoutes routes = parseZigZag(segment, endPoints);</span>

<span class="fc" id="L320">            output.add(routes);</span>
        }

<span class="fc" id="L323">        return output;</span>
    }

    protected List&lt;Routes&gt; findButterflySectionsSmallDiagZigZag(PairIntArray
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L329">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L331">        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); ++i) {</span>

<span class="fc" id="L335">            int x = closedCurve.getX(i);</span>
<span class="fc" id="L336">            int y = closedCurve.getY(i);</span>

<span class="fc" id="L338">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);</span>

            //TODO: one point in this pattern has 3 neigbhors, so may need to change this

            // scanning for segments
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (neighbors.size() != 4) {</span>
<span class="fc" id="L344">                continue;</span>
            }

<span class="fc" id="L347">            Segment segment = checkDiagZigZagSegmentPattern(x, y, points);</span>

<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (segment == null) {</span>
<span class="fc" id="L350">                segment = checkDiagZigZag2SegmentPattern(x, y, points);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (segment == null) {</span>
<span class="fc" id="L352">                    continue;</span>
                }
            }

            /*
            Each of the 4 segment points needs at least one neighbor that is
            not one of the 4 points in the zig zap and all of their neighbors
            cannot be adjacent to any of the other neighbors.
            */

<span class="fc" id="L362">            Set&lt;PairInt&gt; endPoints = checkForZigZagEndPoints(points, segment);</span>

<span class="pc bpc" id="L364" title="1 of 4 branches missed.">            if (endPoints == null || endPoints.isEmpty()) {</span>
<span class="nc" id="L365">                continue;</span>
            }

<span class="fc" id="L368">            ZigZagSegmentRoutes routes = parseDiagZigZag(segment, endPoints);</span>

<span class="fc" id="L370">            output.add(routes);</span>
        }

<span class="fc" id="L373">        return output;</span>
    }

    private Segment checkSegmentPatterns(final int x, final int y,
        Set&lt;PairInt&gt; neighbors) {

<span class="fc" id="L379">        boolean useVert = true;</span>

<span class="fc" id="L381">        Segment segment = checkVertHorizSegmentPattern(x, y, neighbors, useVert);</span>

<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (segment != null) {</span>
<span class="fc" id="L384">            return segment;</span>
        }

<span class="fc" id="L387">        useVert = false;</span>

<span class="fc" id="L389">        segment = checkVertHorizSegmentPattern(x, y, neighbors, useVert);</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (segment != null) {</span>
<span class="fc" id="L392">            return segment;</span>
        }

<span class="fc" id="L395">        segment = checkDiagSegmentPattern(x, y, neighbors);</span>

<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (segment != null) {</span>
<span class="nc" id="L398">            return segment;</span>
        }

<span class="fc" id="L401">        return null;</span>
    }

    private void swapYDirection(Pattern pattern) {
        // ----- change the sign of y  -----
<span class="fc bfc" id="L406" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L407">            p.setY(-1 * p.getY());</span>
<span class="fc" id="L408">        }</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L410">            p.setY(-1 * p.getY());</span>
<span class="fc" id="L411">        }</span>
<span class="fc" id="L412">    }</span>

    private void swapXDirection(Pattern pattern) {
        // ----- change the sign of x  -----
<span class="fc bfc" id="L416" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L417">            p.setX(-1 * p.getX());</span>
<span class="fc" id="L418">        }</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L420">            p.setX(-1 * p.getX());</span>
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">    }</span>

    private Routes checkForAdjacentEndpoints(Set&lt;PairInt&gt; points,
        LinkedList&lt;Segment&gt; section) {

        // the list of segments was built from a closed curve

<span class="fc" id="L429">        Segment firstSegment = section.getFirst();</span>

<span class="fc" id="L431">        Routes routes = null;</span>

<span class="fc" id="L433">        boolean checkFirstSegment = true;</span>

<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (firstSegment instanceof VertSegment) {</span>

<span class="fc" id="L437">            boolean useVertical = true;</span>

<span class="fc" id="L439">            routes = findEndPointsVertHorizPatterns(points, routes, firstSegment,</span>
                useVertical);

<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        } else if (firstSegment instanceof HorizSegment) {</span>

<span class="fc" id="L444">            boolean useVertical = false;</span>

<span class="fc" id="L446">            routes = findEndPointsVertHorizPatterns(points, routes, firstSegment,</span>
                useVertical);

<span class="pc bnc" id="L449" title="All 2 branches missed.">        } else if (firstSegment instanceof UUDiagSegment) {</span>

<span class="nc" id="L451">            routes = findEndPointsDiagPatterns(points, routes,</span>
                (UUDiagSegment)firstSegment);
        }

<span class="fc bfc" id="L455" title="All 2 branches covered.">        if (routes == null) {</span>
<span class="fc" id="L456">            return routes;</span>
        }

<span class="pc bpc" id="L459" title="2 of 4 branches missed.">        if (checkFirstSegment &amp;&amp; (section.size() &gt; 1)) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (int i = 1; i &lt; section.size(); ++i) {</span>

<span class="nc" id="L462">                Segment segment = section.get(i);</span>

                // add node to routes
<span class="nc" id="L465">                addSegmentToRoutes(routes, segment);</span>
            }
        }

<span class="fc" id="L469">        return routes;</span>
    }

    private Routes findEndPointsVertHorizPatterns(Set&lt;PairInt&gt; points,
        Routes routes, Segment segment, boolean useVert) {

<span class="fc" id="L475">        int x0 = segment.p0.getX();</span>
<span class="fc" id="L476">        int y0 = segment.p0.getY();</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; ++i) {</span>
            Pattern pattern;
<span class="pc bpc" id="L480" title="1 of 7 branches missed.">            switch(i) {</span>
                case 0:
<span class="fc" id="L482">                    pattern = getEndPointsVertPattern1();</span>
<span class="fc" id="L483">                    break;</span>
                case 1:
<span class="fc" id="L485">                    pattern = getEndPointsVertPattern1Opp();</span>
<span class="fc" id="L486">                    break;</span>
                case 2:
<span class="fc" id="L488">                    pattern = getEndPointsVertPattern2();</span>
<span class="fc" id="L489">                    break;</span>
                case 3:
<span class="fc" id="L491">                    pattern = getEndPointsVertPattern2Opp();</span>
<span class="fc" id="L492">                    break;</span>
                case 4:
<span class="fc" id="L494">                    pattern = getEndPointsVertPattern3();</span>
<span class="fc" id="L495">                    break;</span>
                case 5:
<span class="fc" id="L497">                    pattern = getEndPointsVertPattern3Opp();</span>
<span class="fc" id="L498">                    break;</span>
                default:
<span class="nc" id="L500">                    return null;</span>
            }
<span class="fc bfc" id="L502" title="All 2 branches covered.">            if (!useVert) {</span>
<span class="fc" id="L503">                rotatePattern(pattern, -0.5*Math.PI);</span>
            }
<span class="fc" id="L505">            boolean found = true;</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">            for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L507">                PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                if (points.contains(p2)) {</span>
<span class="fc" id="L509">                    found = false;</span>
<span class="fc" id="L510">                    break;</span>
                }
<span class="fc" id="L512">            }</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">            if (found) {</span>
<span class="fc" id="L514">                Set&lt;PairInt&gt; endPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L516">                    PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                    if (segment.contains(p2)) {</span>
<span class="fc" id="L518">                        continue;</span>
                    }
<span class="fc bfc" id="L520" title="All 2 branches covered.">                    if (!points.contains(p2)) {</span>
<span class="fc" id="L521">                        found = false;</span>
<span class="fc" id="L522">                        break;</span>
                    }
<span class="fc" id="L524">                    endPoints.add(p2);</span>
<span class="fc" id="L525">                }</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                if (found) {</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                    if (routes == null) {</span>
<span class="fc" id="L528">                        routes = createRoute(segment, x0, y0);</span>
                    }
<span class="pc bpc" id="L530" title="1 of 3 branches missed.">                    switch(i) {</span>
                        case 0:
                        case 2:
                        case 4:
<span class="fc" id="L534">                            addEndpointsForHorizVertPatternForward(x0, y0,</span>
                                pattern, routes, endPoints, useVert);
<span class="fc" id="L536">                            break;</span>
                        case 1:
                        case 3:
                        case 5:
<span class="fc" id="L540">                            addEndpointsForHorizVertPatternOppos(x0, y0,</span>
                                pattern, routes, endPoints, useVert);
<span class="fc" id="L542">                            break;</span>
                        default:
<span class="nc" id="L544">                            return null;</span>
                    }
                }
            }
        }
<span class="fc" id="L549">        return routes;</span>
    }

    private Pattern getEndPointsVertPattern1() {
        /* the pattern returned is relative to
        position '0', just like the other patterns.

        searching for .'s and #'s
                        -2
           -  2  1  -   -1
           -  3  0  -    0
           -  .  .  -    1
              #  -  #    2
                 -       3
          -2 -1  0  1
        */
<span class="fc" id="L565">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L566">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L567">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

        // '.' intermediate points
<span class="fc" id="L570">        pattern.ones.add(new PairInt(-1, 1));</span>
<span class="fc" id="L571">        pattern.ones.add(new PairInt(0, 1));</span>

        // '#' end points
<span class="fc" id="L574">        PairInt t1 = new PairInt(-1, 2);</span>
<span class="fc" id="L575">        pattern.ones.add(t1);</span>
<span class="fc" id="L576">        PairInt t0 = new PairInt(1, 2);</span>
<span class="fc" id="L577">        pattern.ones.add(t0);</span>
<span class="fc" id="L578">        pattern.ep0 = t0;</span>
<span class="fc" id="L579">        pattern.ones.add(t1);</span>
<span class="fc" id="L580">        pattern.ep1 = t1;</span>

<span class="fc" id="L582">        pattern.zeroes.add(new PairInt(-2, 1)); pattern.zeroes.add(new PairInt(1, 1));</span>
<span class="fc" id="L583">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 3));</span>
<span class="fc" id="L584">        return pattern;</span>
    }

    private Pattern getEndPointsVertPattern1Opp() {
        /* the pattern returned is relative to
        position '0', just like the other patterns.

                 -      -3
              #  -  #   -2
           -  .  .  -   -1
           -  3  0  -    0
           -  2  1  -    1

          -2 -1  0  1
        */
<span class="fc" id="L599">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L600">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L601">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

        // '.' intermediate points
<span class="fc" id="L604">        pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L605">        pattern.ones.add(new PairInt(0, -1));</span>

<span class="fc" id="L607">        PairInt t1 = new PairInt(-1, -2);</span>
<span class="fc" id="L608">        pattern.ones.add(t1);</span>
<span class="fc" id="L609">        pattern.ep1 = t1;</span>
<span class="fc" id="L610">        PairInt t0 = new PairInt(1, -2);</span>
<span class="fc" id="L611">        pattern.ones.add(t0);</span>
<span class="fc" id="L612">        pattern.ep0 = t0;</span>

<span class="fc" id="L614">        pattern.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L615">        pattern.zeroes.add(new PairInt(0, -2)); pattern.zeroes.add(new PairInt(0, -3));</span>
<span class="fc" id="L616">        pattern.zeroes.add(new PairInt(1, -1));</span>
<span class="fc" id="L617">        return pattern;</span>
    }

    private Pattern getEndPointsVertPattern2() {

        /* the pattern returned is relative to
        position '0', just like the other patterns.

        searching for .'s and #'s
                        -2
           -  2  1  -   -1
           -  3  0  -    0
           -  .  .  -    1
           #  -  -  #    2
              -  -       3
          -2 -1  0  1
        */
<span class="fc" id="L634">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L635">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L636">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

        // '.' intermediate points
<span class="fc" id="L639">        pattern.ones.add(new PairInt(-1, 1));</span>
<span class="fc" id="L640">        pattern.ones.add(new PairInt(0, 1));</span>

        // '#' end points
<span class="fc" id="L643">        PairInt t1 = new PairInt(-2, 2);</span>
<span class="fc" id="L644">        pattern.ones.add(t1);</span>
<span class="fc" id="L645">        PairInt t0 = new PairInt(1, 2);</span>
<span class="fc" id="L646">        pattern.ones.add(t0);</span>
<span class="fc" id="L647">        pattern.ep1 = t1;</span>
<span class="fc" id="L648">        pattern.ep0 = t0;</span>

<span class="fc" id="L650">        pattern.zeroes.add(new PairInt(-2, 1)); pattern.zeroes.add(new PairInt(1, 1));</span>
<span class="fc" id="L651">        pattern.zeroes.add(new PairInt(-1, 2)); pattern.zeroes.add(new PairInt(-1, 3));</span>
<span class="fc" id="L652">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 3));</span>

<span class="fc" id="L654">        return pattern;</span>
    }

    private Pattern getEndPointsVertPattern2Opp() {

        /* the pattern returned is relative to
        position '0', just like the other patterns.

              -  -      -3
           #  -  -  #   -2
           -  .  .  -   -1
           -  3  0  -    0
           -  2  1  -    1

          -2 -1  0  1

        */

<span class="fc" id="L672">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L673">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L674">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

        // '.' intermediate points
<span class="fc" id="L677">        pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L678">        pattern.ones.add(new PairInt(0, -1));</span>

        // '#' end points
<span class="fc" id="L681">        PairInt t1 = new PairInt(-2, -2);</span>
<span class="fc" id="L682">        PairInt t0 = new PairInt(1, -2);</span>
<span class="fc" id="L683">        pattern.ones.add(t1);</span>
<span class="fc" id="L684">        pattern.ones.add(t0);</span>
<span class="fc" id="L685">        pattern.ep0 = t0;</span>
<span class="fc" id="L686">        pattern.ep1 = t1;</span>

<span class="fc" id="L688">        pattern.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L689">        pattern.zeroes.add(new PairInt(-1, -2)); pattern.zeroes.add(new PairInt(-1, -3));</span>
<span class="fc" id="L690">        pattern.zeroes.add(new PairInt(0, -3)); pattern.zeroes.add(new PairInt(0, -2));</span>

<span class="fc" id="L692">        return pattern;</span>
    }

    private Pattern getEndPointsVertPattern3() {

        /* the pattern returned is relative to
        position '0', just like the other patterns.

        searching for .'s and #'s
                        -2
           -  2  1  -   -1
           -  3  0  -    0
           -  .  .  -    1
           #  -  #       2
              -          3
          -2 -1  0  1
        */

<span class="fc" id="L710">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L711">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L712">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L714">        pattern.zeroes.add(new PairInt(-2, 1));</span>
<span class="fc" id="L715">        pattern.zeroes.add(new PairInt(-1, 2));</span>
<span class="fc" id="L716">        pattern.zeroes.add(new PairInt(-1, 3));</span>
<span class="fc" id="L717">        pattern.zeroes.add(new PairInt(1, 1));</span>

        // '.' intermediate points
<span class="fc" id="L720">        pattern.ones.add(new PairInt(-1, 1));</span>
<span class="fc" id="L721">        pattern.ones.add(new PairInt(0, 1));</span>
        // '#' end points
<span class="fc" id="L723">        PairInt t1 = new PairInt(-2, 2);</span>
<span class="fc" id="L724">        pattern.ones.add(t1);</span>
<span class="fc" id="L725">        PairInt t0 = new PairInt(0, 2);</span>
<span class="fc" id="L726">        pattern.ones.add(t0);</span>
<span class="fc" id="L727">        pattern.ep1 = t1;</span>
<span class="fc" id="L728">        pattern.ep0 = t0;</span>

<span class="fc" id="L730">        return pattern;</span>
    }

    private Pattern getEndPointsVertPattern3Opp() {

        /* the pattern returned is relative to
        position '0', just like the other patterns.
              -         -3
           #  -  #      -2
           -  .  .  -   -1
           -  3  0  -    0
           -  2  1  -    1

          -2 -1  0  1
        */

<span class="fc" id="L746">        Pattern pattern = new Pattern();</span>
<span class="fc" id="L747">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L748">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

        // '.' intermediate points
<span class="fc" id="L751">        pattern.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L752">        pattern.ones.add(new PairInt(0, -1));</span>

        // '#' end points
<span class="fc" id="L755">        PairInt t1 = new PairInt(-2, -2);</span>
<span class="fc" id="L756">        PairInt t0 = new PairInt(0, -2);</span>
<span class="fc" id="L757">        pattern.ones.add(t1);</span>
<span class="fc" id="L758">        pattern.ones.add(t0);</span>
<span class="fc" id="L759">        pattern.ep0 = t0;</span>
<span class="fc" id="L760">        pattern.ep1 = t1;</span>

<span class="fc" id="L762">        pattern.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L763">        pattern.zeroes.add(new PairInt(-1, -2)); pattern.zeroes.add(new PairInt(-1, -3));</span>
<span class="fc" id="L764">        pattern.zeroes.add(new PairInt(1, -1));</span>

<span class="fc" id="L766">        return pattern;</span>
    }

    private Routes findEndPointsDiagPatterns(Set&lt;PairInt&gt; points,
        Routes routes, UUDiagSegment segment) {

<span class="nc" id="L772">        int x0 = segment.p0.getX();</span>
<span class="nc" id="L773">        int y0 = segment.p0.getY();</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; ++i) {</span>
            Pattern pattern;
<span class="nc bnc" id="L777" title="All 7 branches missed.">            switch(i) {</span>
                case 0:
<span class="nc" id="L779">                    pattern = getEndPointsUUDiagPattern1();</span>
<span class="nc" id="L780">                    break;</span>
                case 1:
<span class="nc" id="L782">                    pattern = getEndPointsUUDiagPattern1();</span>
<span class="nc" id="L783">                    rotatePattern(pattern, -0.5*Math.PI);</span>
<span class="nc" id="L784">                    break;</span>
                case 2:
<span class="nc" id="L786">                    pattern = getEndPointsUUDiagPattern2();</span>
<span class="nc" id="L787">                    break;</span>
                case 3:
<span class="nc" id="L789">                    pattern = getEndPointsUUDiagPattern2();</span>
<span class="nc" id="L790">                    rotatePattern(pattern, -0.5*Math.PI);</span>
<span class="nc" id="L791">                    break;</span>
                case 4:
<span class="nc" id="L793">                    pattern = getEndPointsUUDiagPattern3();</span>
<span class="nc" id="L794">                    break;</span>
                case 5:
<span class="nc" id="L796">                    pattern = getEndPointsUUDiagPattern3();</span>
<span class="nc" id="L797">                    rotatePattern(pattern, -0.5*Math.PI);</span>
<span class="nc" id="L798">                    break;</span>
                default:
<span class="nc" id="L800">                    return null;</span>
            }
<span class="nc" id="L802">            boolean found = true;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">            for (PairInt p : pattern.zeroes) {</span>
<span class="nc" id="L804">                PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                if (points.contains(p2)) {</span>
<span class="nc" id="L806">                    found = false;</span>
<span class="nc" id="L807">                    break;</span>
                }
<span class="nc" id="L809">            }</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (found) {</span>
<span class="nc" id="L811">                Set&lt;PairInt&gt; endPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                for (PairInt p : pattern.ones) {</span>
<span class="nc" id="L813">                    PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
                    //TODO: check this segment test with tests
<span class="nc bnc" id="L815" title="All 2 branches missed.">                    if (segment.contains(p2)) {</span>
<span class="nc" id="L816">                        continue;</span>
                    }
<span class="nc bnc" id="L818" title="All 2 branches missed.">                    if (!points.contains(p2)) {</span>
<span class="nc" id="L819">                        found = false;</span>
<span class="nc" id="L820">                        break;</span>
                    }
<span class="nc" id="L822">                    endPoints.add(p2);</span>
<span class="nc" id="L823">                }</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                if (found) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                    if (routes == null) {</span>
<span class="nc" id="L826">                        routes = createRoute(segment, x0, y0);</span>
                    }
<span class="nc bnc" id="L828" title="All 3 branches missed.">                    switch(i) {</span>
                        case 0:
                        case 2:
                        case 4:
<span class="nc" id="L832">                            addEndpointsForUUDiagPattern(x0, y0,</span>
                                pattern, routes, endPoints);
<span class="nc" id="L834">                            break;</span>
                        case 1:
                        case 3:
                        case 5:
<span class="nc" id="L838">                            addEndpointsForULDiagPattern(x0, y0,</span>
                                pattern, routes, endPoints);
<span class="nc" id="L840">                            break;</span>
                        default:
<span class="nc" id="L842">                            return null;</span>
                    }
                }
            }
        }
<span class="nc" id="L847">        return routes;</span>
    }

    private Pattern getEndPointsUUDiagPattern1() {
        /* the pattern returned is relative to
        position '0', just like the other patterns.

                -  -          -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0   &lt;--# is route0 end endpoint
             -  .  -           1
                -  #           2   &lt;--# is route1 start endpoint

         -3 -2 -1  0  1
        */
<span class="nc" id="L862">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L863">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L864">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L866">        pattern.zeroes.add(new PairInt(-1, 1));</span>
<span class="nc" id="L867">        pattern.zeroes.add(new PairInt(0, 1));</span>
<span class="nc" id="L868">        pattern.zeroes.add(new PairInt(0, -1));</span>

<span class="nc" id="L870">        pattern.ones.add(new PairInt(-1, 1));</span>
<span class="nc" id="L871">        PairInt t1 = new PairInt(0, 2);</span>
<span class="nc" id="L872">        pattern.ones.add(t1);</span>
<span class="nc" id="L873">        PairInt t0 = new PairInt(1, 0);</span>
<span class="nc" id="L874">        pattern.ones.add(t0);</span>
<span class="nc" id="L875">        pattern.ep1 = t1;</span>
<span class="nc" id="L876">        pattern.ep0 = t0;</span>

<span class="nc" id="L878">        return pattern;</span>
    }

    private Pattern getEndPointsUUDiagPattern2() {
        /* the pattern returned is relative to
        position '0', just like the other patterns.
                -  -          -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0
             -  .  -           1
                #  -           2

         -3 -2 -1  0  1
        */
<span class="nc" id="L892">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L893">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L894">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L896">        pattern.zeroes.add(new PairInt(0, 2));</span>
<span class="nc" id="L897">        pattern.zeroes.add(new PairInt(0, 1));</span>
<span class="nc" id="L898">        pattern.zeroes.add(new PairInt(0, 1));</span>

<span class="nc" id="L900">        pattern.ones.add(new PairInt(-1, 1));</span>
<span class="nc" id="L901">        PairInt t1 = new PairInt(-1, 2);</span>
<span class="nc" id="L902">        pattern.ones.add(t1);</span>
<span class="nc" id="L903">        PairInt t0 = new PairInt(1, 0);</span>
<span class="nc" id="L904">        pattern.ones.add(t0);</span>
<span class="nc" id="L905">        pattern.ep0 = t0;</span>
<span class="nc" id="L906">        pattern.ep1 = t1;</span>

<span class="nc" id="L908">        return pattern;</span>
    }

    private Pattern getEndPointsUUDiagPattern3() {
        /* the pattern returned is relative to
        position '0', just like the other patterns.

                -  -          -2
          -  2  1  -          -1
          -  -  3 .0  -        0
             -  .  -  #        1
                #  -           2

         -3 -2 -1  0  1
        */
<span class="nc" id="L923">        Pattern pattern = new Pattern();</span>
<span class="nc" id="L924">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L925">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L927">        pattern.ones.add(new PairInt(-1, 1));</span>
<span class="nc" id="L928">        PairInt t1 = new PairInt(-1, 2);</span>
<span class="nc" id="L929">        pattern.ones.add(t1);</span>
<span class="nc" id="L930">        PairInt t0 = new PairInt(1, 1);</span>
<span class="nc" id="L931">        pattern.ones.add(t0);</span>
<span class="nc" id="L932">        pattern.ep0 = t0;</span>
<span class="nc" id="L933">        pattern.ep1 = t1;</span>

<span class="nc" id="L935">        pattern.zeroes.add(new PairInt(0, 2));</span>
<span class="nc" id="L936">        pattern.zeroes.add(new PairInt(0, 1));</span>
<span class="nc" id="L937">        pattern.zeroes.add(new PairInt(0, -1));</span>
<span class="nc" id="L938">        pattern.zeroes.add(new PairInt(1, 0));</span>

<span class="nc" id="L940">        return pattern;</span>
    }

    private Set&lt;PairInt&gt; checkForZigZagEndPoints(Set&lt;PairInt&gt; points,
        Segment segment) {

        /*Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.*/

<span class="fc" id="L950">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L952">        Set&lt;Integer&gt; indexesWithMoreThanOneNeighbor = new HashSet&lt;Integer&gt;();</span>

<span class="fc" id="L954">        List&lt;Set&lt;PairInt&gt;&gt; listOfNeighbors = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="fc" id="L955">        Set&lt;PairInt&gt; segmentPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L956">        segmentPoints.add(segment.p0);</span>
<span class="fc" id="L957">        segmentPoints.add(segment.p1);</span>
<span class="fc" id="L958">        segmentPoints.add(segment.p2);</span>
<span class="fc" id="L959">        segmentPoints.add(segment.p3);</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="fc" id="L961">            PairInt p = null;</span>
<span class="fc bfc" id="L962" title="All 4 branches covered.">            switch(i) {</span>
                case 0:
<span class="fc" id="L964">                    p = segment.p0;</span>
<span class="fc" id="L965">                    break;</span>
                case 1:
<span class="fc" id="L967">                    p = segment.p1;</span>
<span class="fc" id="L968">                    break;</span>
                case 2:
<span class="fc" id="L970">                    p = segment.p2;</span>
<span class="fc" id="L971">                    break;</span>
                default:
<span class="fc" id="L973">                    p = segment.p3;</span>
                    break;
            }
<span class="fc" id="L976">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(p.getX(),</span>
<span class="fc" id="L977">                p.getY(), points);</span>
<span class="fc" id="L978">            neighbors.removeAll(segmentPoints);</span>
<span class="fc bfc" id="L979" title="All 4 branches covered.">            if (!((neighbors.size() == 1) || (neighbors.size() == 2))) {</span>
<span class="fc" id="L980">                return null;</span>
            }
<span class="fc bfc" id="L982" title="All 2 branches covered.">            if (neighbors.size() &gt; 1) {</span>
<span class="fc" id="L983">                indexesWithMoreThanOneNeighbor.add(</span>
<span class="fc" id="L984">                    Integer.valueOf(listOfNeighbors.size()));</span>
            }
<span class="fc" id="L986">            listOfNeighbors.add(neighbors);</span>
        }

        /* for this kind of junction, some points share a neighbor.
        need to reduce the neighbor lists to unique members
        */
<span class="fc bfc" id="L992" title="All 2 branches covered.">        for (Integer index : indexesWithMoreThanOneNeighbor) {</span>
<span class="fc" id="L993">            int idx = index.intValue();</span>
<span class="fc" id="L994">            Set&lt;PairInt&gt; neighborSet = listOfNeighbors.get(idx);</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">            for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {</span>
<span class="fc" id="L996">                Integer index2 = Integer.valueOf(i);</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">                if (indexesWithMoreThanOneNeighbor.contains(index2)) {</span>
<span class="fc" id="L998">                    continue;</span>
                }
<span class="fc" id="L1000">                PairInt p2 = listOfNeighbors.get(index2.intValue()).iterator().next();</span>
<span class="fc" id="L1001">                neighborSet.remove(p2);</span>
            }
<span class="fc" id="L1003">        }</span>

        // assert that each in list has no members adjacent to any other members
        // TODO: could use a data structure that uses spatial indexing to make
        // this faster, but there are not very many points per 4 sets to compare...
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {</span>
<span class="fc" id="L1009">            Set&lt;PairInt&gt; setI = listOfNeighbors.get(i);</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            for (PairInt pI : setI) {</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                for (int j = (i + 1); j &lt; listOfNeighbors.size(); ++j) {</span>
<span class="fc" id="L1012">                    Set&lt;PairInt&gt; setJ = listOfNeighbors.get(j);</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                    for (PairInt pJ : setJ) {</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">                        if (areAdjacent(pI, pJ)) {</span>
<span class="fc" id="L1015">                            return null;</span>
                        }
<span class="fc" id="L1017">                    }</span>
                }
<span class="fc" id="L1019">            }</span>
        }
     
        // if arrive here, all neighbor sets have at least one point and none
        // are adjacent to points in a different set.
        
        // if there are more than one per set, we only want to keep the
        // closest to make a clear route with.
        // TODO: revisit this decision w/ further testing
        
<span class="fc" id="L1029">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">        for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {</span>
<span class="fc" id="L1031">            Set&lt;PairInt&gt; set = listOfNeighbors.get(i);</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">            if (set.size() &gt; 0) {</span>
<span class="fc" id="L1033">                PairInt p = null;</span>
<span class="fc bfc" id="L1034" title="All 4 branches covered.">                switch(i) {</span>
                    case 0:
<span class="fc" id="L1036">                        p = segment.p0;</span>
<span class="fc" id="L1037">                        break;</span>
                    case 1:
<span class="fc" id="L1039">                        p = segment.p1;</span>
<span class="fc" id="L1040">                        break;</span>
                    case 2:
<span class="fc" id="L1042">                        p = segment.p2;</span>
<span class="fc" id="L1043">                        break;</span>
                    default:
<span class="fc" id="L1045">                        p = segment.p3;</span>
                        break;
                }
<span class="fc" id="L1048">                int minDistSq = Integer.MAX_VALUE;</span>
<span class="fc" id="L1049">                PairInt minDistP = null;</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                for (PairInt p2 : set) {</span>
<span class="fc" id="L1051">                    int distSq = distSq(p, p2);</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">                    if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L1053">                        minDistSq = distSq;</span>
<span class="fc" id="L1054">                        minDistP = p2;</span>
                    }
<span class="fc" id="L1056">                }</span>
<span class="fc" id="L1057">                set.clear();</span>
<span class="fc" id="L1058">                set.add(minDistP);</span>
            }
<span class="fc" id="L1060">            output.addAll(set);</span>
        }
<span class="fc" id="L1062">        return output;</span>
    }

    private boolean areAdjacent(PairInt p0, PairInt p1) {
<span class="fc" id="L1066">        int diffX = Math.abs(p0.getX() - p1.getX());</span>
<span class="fc" id="L1067">        int diffY = Math.abs(p0.getY() - p1.getY());</span>
<span class="fc bfc" id="L1068" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L1069">            return true;</span>
        }
<span class="fc" id="L1071">        return false;</span>
    }

    protected void rotatePattern(Pattern pattern, double theta) {

<span class="fc" id="L1076">        double sine = Math.sin(theta);</span>
<span class="fc" id="L1077">        double cosine = Math.cos(theta);</span>

<span class="fc bfc" id="L1079" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L1080">            int x = p.getX();</span>
<span class="fc" id="L1081">            int y = p.getY();</span>
<span class="fc" id="L1082">            int xt = (int)Math.round(((x*cosine) + (y*sine)));</span>
<span class="fc" id="L1083">            int yt = (int)Math.round(((-x*sine) + (y*cosine)));</span>
<span class="fc" id="L1084">            p.setX(xt);</span>
<span class="fc" id="L1085">            p.setY(yt);</span>
<span class="fc" id="L1086">        }</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L1088">            int x = p.getX();</span>
<span class="fc" id="L1089">            int y = p.getY();</span>
<span class="fc" id="L1090">            int xt = (int)Math.round(((x*cosine) + (y*sine)));</span>
<span class="fc" id="L1091">            int yt = (int)Math.round(((-x*sine) + (y*cosine)));</span>
<span class="fc" id="L1092">            p.setX(xt);</span>
<span class="fc" id="L1093">            p.setY(yt);</span>
<span class="fc" id="L1094">        }</span>
<span class="fc" id="L1095">    }</span>

    private Routes createRoute(Segment segment, int x0, int y0) {

        /*
             VertSegment              swapY VertSegment
              .     .        -2
           -  2     1:E0 -   -1         .     .         -1    E0 marks endpoint 0 and the
           -  3:E1  0:E0..    0      -  3     0:E0  -    0       start of route 0.
              .     .         1      -  2:E1  1     -    1       which incr w/ incr y.
                                        .     .          2    route 1 starts at E1 and incr w/ decr y
          -2 -1     0    1          -2 -1     0     1

            HorizSegment              swap HorizSegment
                 -    -       -2          -    -         -2
              .  3E1  2    .  -1       .  2:E1 3     .   -1    route1 incr w/ incr x
              .  0  1:E0 .   0       .  1    0:E0  .    0      route0 incr w/ decr x
                 -    -        1          -    -          1
             -1  0    1    2          -2 -1    0     1


                 UUDiagSegment                ULDiagSegment
                    -  -      -2                    2      -2
              -  2  1  -  -   -1                 3  1      -1
              -  -  3  0  -    0                 0          0
                 -  -          1                            1
             -3 -2 -1  0  1                 -1   0  1  2

               E0 is '1', and route0         E0 is '1', and route0
                  continues with             continues with
                  point '0'                  point '0'
               E1 is '3', and route1         E1 is '3', and route1
                  continues with '2'            continues with '2'
        */

<span class="fc bfc" id="L1130" title="All 2 branches covered.">        if (segment instanceof VertSegment) {</span>
<span class="fc" id="L1131">            Routes routes = new Routes();</span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">            if (segment.p1.equals(new PairInt(x0, y0 - 1))) {</span>
<span class="pc bpc" id="L1133" title="3 of 4 branches missed.">                assert(segment.p2.equals(new PairInt(x0 - 1, y0 - 1)));</span>
<span class="pc bpc" id="L1134" title="3 of 4 branches missed.">                assert(segment.p3.equals(new PairInt(x0 - 1, y0)));</span>
<span class="fc" id="L1135">                routes.route0.add(segment.p1);</span>
<span class="fc" id="L1136">                routes.route0.add(segment.p0);</span>
<span class="fc" id="L1137">                routes.route1.add(segment.p3);</span>
<span class="fc" id="L1138">                routes.route1.add(segment.p2);</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            } else if (segment.p1.equals(new PairInt(x0, y0 + 1))) {</span>
<span class="nc bnc" id="L1140" title="All 4 branches missed.">                assert(segment.p2.equals(new PairInt(x0 - 1, y0 + 1)));</span>
<span class="nc bnc" id="L1141" title="All 4 branches missed.">                assert(segment.p3.equals(new PairInt(x0 - 1, y0)));</span>
<span class="nc" id="L1142">                routes.route0.add(segment.p0);</span>
<span class="nc" id="L1143">                routes.route0.add(segment.p1);</span>
<span class="nc" id="L1144">                routes.route1.add(segment.p2);</span>
<span class="nc" id="L1145">                routes.route1.add(segment.p3);</span>
            } else {
<span class="nc" id="L1147">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="fc" id="L1149">            return routes;</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">        } else if (segment instanceof HorizSegment) {</span>
<span class="fc" id="L1151">            Routes routes = new Routes();</span>
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">            if (segment.p1.equals(new PairInt(x0 + 1, y0))) {</span>
<span class="pc bpc" id="L1153" title="3 of 4 branches missed.">                assert(segment.p2.equals(new PairInt(x0 + 1, y0 - 1)));</span>
<span class="pc bpc" id="L1154" title="3 of 4 branches missed.">                assert(segment.p3.equals(new PairInt(x0, y0 - 1)));</span>
<span class="fc" id="L1155">                routes.route0.add(segment.p1);</span>
<span class="fc" id="L1156">                routes.route0.add(segment.p0);</span>
<span class="fc" id="L1157">                routes.route1.add(segment.p3);</span>
<span class="fc" id="L1158">                routes.route1.add(segment.p2);</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            } else if (segment.p1.equals(new PairInt(x0 - 1, y0))) {</span>
<span class="nc bnc" id="L1160" title="All 4 branches missed.">                assert(segment.p2.equals(new PairInt(x0 - 1, y0 - 1)));</span>
<span class="nc bnc" id="L1161" title="All 4 branches missed.">                assert(segment.p3.equals(new PairInt(x0, y0 - 1)));</span>
<span class="nc" id="L1162">                routes.route0.add(segment.p0);</span>
<span class="nc" id="L1163">                routes.route0.add(segment.p1);</span>
<span class="nc" id="L1164">                routes.route1.add(segment.p2);</span>
<span class="nc" id="L1165">                routes.route1.add(segment.p3);</span>
            } else {
<span class="nc" id="L1167">                throw new IllegalStateException(&quot;error in algorithm!&quot;);</span>
            }
<span class="fc" id="L1169">            return routes;</span>

<span class="nc bnc" id="L1171" title="All 4 branches missed.">        } else if ((segment instanceof UUDiagSegment) || (segment instanceof ULDiagSegment)) {</span>
<span class="nc" id="L1172">            Routes routes = new Routes();</span>
<span class="nc" id="L1173">            routes.route0.add(segment.p1);</span>
<span class="nc" id="L1174">            routes.route0.add(segment.p0);</span>
<span class="nc" id="L1175">            routes.route1.add(segment.p3);</span>
<span class="nc" id="L1176">            routes.route1.add(segment.p2);</span>
<span class="nc" id="L1177">            return routes;</span>
        } else {
<span class="nc" id="L1179">            throw new IllegalStateException(&quot;error in algorithm: &quot; +</span>
<span class="nc" id="L1180">                &quot; segment not handled:&quot; + segment.getClass().getSimpleName());</span>
        }
    }

    private void addEndpointsForHorizVertPatternForward(final int x0,
        final int y0, Pattern pattern, final Routes routes,
        Set&lt;PairInt&gt; endPoints, boolean useVert) {

<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">        if (endPoints.size() &lt; 2) {</span>
<span class="nc" id="L1189">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="pc bpc" id="L1191" title="3 of 4 branches missed.">        assert(routes.ep0End == null);</span>
<span class="pc bpc" id="L1192" title="3 of 4 branches missed.">        assert(routes.ep1 == null);</span>

<span class="fc bfc" id="L1194" title="All 2 branches covered.">        if (useVert) {</span>
            /*
               endPointsVertPattern1, for example
                     R0
                     \/
                            -2
               -  2  1  -   -1
               -  3  0  -    0
               -  .  .  -    1
                  #  -  #    2
                     -       3
                 /\
                 R1
              -2 -1  0  1
            */
<span class="pc bpc" id="L1209" title="3 of 4 branches missed.">            assert(pattern.ep0 != null);</span>
<span class="fc" id="L1210">            PairInt tI = new PairInt(x0, y0 + 1);</span>
<span class="fc" id="L1211">            PairInt tE = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1213">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
            // tI might have been added as a segment already
<span class="pc bpc" id="L1216" title="3 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute0().contains(tI)) {</span>
<span class="nc" id="L1217">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
            // if tI is in route already, has to be last in route, or 2nd to
            //     last if tE is already present too
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">            if (routes.getRoute0().isEmpty()) {</span>
<span class="nc" id="L1222">                routes.route0.add(tI);</span>
<span class="nc" id="L1223">                routes.route0.add(tE);</span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">            } else if (routes.getRoute0().size() &gt; 1) {</span>
<span class="fc" id="L1225">                PairInt[] secondToLastAndLast = getSecondToLastAndLast(</span>
<span class="fc" id="L1226">                    routes.getRoute0().iterator());</span>
<span class="pc bpc" id="L1227" title="3 of 4 branches missed.">                if (secondToLastAndLast[0].equals(tI) &amp;&amp; secondToLastAndLast[1].equals(tE)) {</span>
                    // no need to add either to route
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">                } else if (secondToLastAndLast[1].equals(tI)) {</span>
<span class="nc" id="L1230">                    routes.route0.add(tE);</span>
                } else {
<span class="fc" id="L1232">                    routes.route0.add(tI);</span>
<span class="fc" id="L1233">                    routes.route0.add(tE);</span>
                }
            }
<span class="fc" id="L1236">            routes.ep0End = tE;</span>

            /*
               endPointsVertPattern1, for example
                            -2
               -  2  1  -   -1
               -  3  0  -    0
               -  .  .  -    1
                  #  -  #    2
                     -       3
                 /\
                 R1
              -2 -1  0  1
            */
<span class="pc bpc" id="L1250" title="3 of 4 branches missed.">            assert(pattern.ep1 != null);</span>
<span class="fc" id="L1251">            tI = new PairInt(x0 - 1, y0 + 1);</span>
<span class="fc" id="L1252">            tE = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());</span>
<span class="pc bpc" id="L1253" title="3 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute1().contains(tI)) {</span>
<span class="nc" id="L1254">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1257">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">            if (routes.getRoute1().isEmpty()) {</span>
<span class="nc" id="L1260">                routes.route1.add(tE);</span>
<span class="nc" id="L1261">                routes.route1.add(tI);</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">            } else if (routes.getRoute1().size() &gt; 1) {</span>

<span class="fc" id="L1264">                Iterator&lt;PairInt&gt; iter1 = routes.getRoute1().iterator();</span>
<span class="fc" id="L1265">                PairInt r1 = iter1.next();</span>
<span class="fc" id="L1266">                PairInt r2 = iter1.next();</span>
<span class="pc bpc" id="L1267" title="3 of 4 branches missed.">                if (r1.equals(tE) &amp;&amp; r2.equals(tI)) {</span>
                    // no need to add to route
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">                } else if (r1.equals(tI)) {</span>
<span class="nc" id="L1270">                    LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1271">                    tmpR1.add(tE);</span>
<span class="nc" id="L1272">                    tmpR1.addAll(routes.route1);</span>
<span class="nc" id="L1273">                    routes.route1 = tmpR1;</span>
<span class="nc" id="L1274">                } else {</span>
<span class="fc" id="L1275">                    LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1276">                    tmpR1.add(tE);</span>
<span class="fc" id="L1277">                    tmpR1.add(tI);</span>
<span class="fc" id="L1278">                    tmpR1.addAll(routes.route1);</span>
<span class="fc" id="L1279">                    routes.route1 = tmpR1;</span>
                }

            } // will never be just one point in a route
<span class="fc" id="L1283">            routes.ep1 = tE;</span>

<span class="fc" id="L1285">        } else {</span>
            /*
                endPointsHorizPattern1
                      -  -  -   -2
            R1--&gt; #   .  3  2   -1  --&gt;R1 ends
              -   -   .  0  1    0
            R0&lt;-- #   -  -  -    1  &lt;--R0 starts
                                 2
                                 3
             -3  -2  -1  0  1
            */
<span class="pc bpc" id="L1296" title="3 of 4 branches missed.">            assert(pattern.ep0 != null);</span>
<span class="fc" id="L1297">            PairInt tE = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="fc" id="L1298">            PairInt tI = new PairInt(x0 - 1, y0);</span>
<span class="pc bpc" id="L1299" title="3 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute0().contains(tI)) {</span>
<span class="nc" id="L1300">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1303">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">            if (routes.getRoute0().isEmpty()) {</span>
                //TODO: revisit the logic. each route is probably always size &gt;= 2
<span class="nc" id="L1307">                routes.route0.add(tI);</span>
<span class="nc" id="L1308">                routes.route0.add(tE);</span>
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">            } else if (routes.getRoute0().size() &gt; 1) {</span>
<span class="fc" id="L1310">                PairInt[] secondToLastAndLast = getSecondToLastAndLast(</span>
<span class="fc" id="L1311">                    routes.getRoute0().iterator());</span>
<span class="pc bpc" id="L1312" title="3 of 4 branches missed.">                if (secondToLastAndLast[0].equals(tI) &amp;&amp; secondToLastAndLast[1].equals(tE)) {</span>
                    // no need to add either to route
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">                } else if (secondToLastAndLast[1].equals(tI)) {</span>
<span class="nc" id="L1315">                    routes.route0.add(tE);</span>
                } else {
<span class="fc" id="L1317">                    routes.route0.add(tI);</span>
<span class="fc" id="L1318">                    routes.route0.add(tE);</span>
                }
            }
<span class="fc" id="L1321">            routes.ep0End = tE;</span>

            /*
                endPointsHorizPattern1
                      -  -  -   -2
            R1--&gt; #   .  3  2   -1  --&gt;R1 ends
              -   -   .  0  1    0
            R0&lt;-- #   -  -  -    1  &lt;--R0 starts
                                 2
                                 3
             -3  -2  -1  0  1
            */
<span class="pc bpc" id="L1333" title="3 of 4 branches missed.">            assert(pattern.ep1 != null);</span>
<span class="fc" id="L1334">            tE = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());</span>
<span class="fc" id="L1335">            tI = new PairInt(x0 - 1, y0 - 1);</span>
<span class="pc bpc" id="L1336" title="3 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute1().contains(tI)) {</span>
<span class="nc" id="L1337">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1340">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">            if (routes.getRoute1().isEmpty()) {</span>
<span class="nc" id="L1343">                routes.route1.add(tE);</span>
<span class="nc" id="L1344">                routes.route1.add(tI);</span>
<span class="pc bpc" id="L1345" title="1 of 2 branches missed.">            } else if (routes.getRoute1().size() &gt; 1) {</span>

<span class="fc" id="L1347">                Iterator&lt;PairInt&gt; iter1 = routes.getRoute1().iterator();</span>
<span class="fc" id="L1348">                PairInt r1 = iter1.next();</span>
<span class="fc" id="L1349">                PairInt r2 = iter1.next();</span>
<span class="pc bpc" id="L1350" title="3 of 4 branches missed.">                if (r1.equals(tE) &amp;&amp; r2.equals(tI)) {</span>
                    // no need to add to route
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">                } else if (r1.equals(tI)) {</span>
<span class="nc" id="L1353">                    LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1354">                    tmpR1.add(tE);</span>
<span class="nc" id="L1355">                    tmpR1.addAll(routes.route1);</span>
<span class="nc" id="L1356">                    routes.route1 = tmpR1;</span>
<span class="nc" id="L1357">                } else {</span>
<span class="fc" id="L1358">                    LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1359">                    tmpR1.add(tE);</span>
<span class="fc" id="L1360">                    tmpR1.add(tI);</span>
<span class="fc" id="L1361">                    tmpR1.addAll(routes.route1);</span>
<span class="fc" id="L1362">                    routes.route1 = tmpR1;</span>
                }

            } // will never be just one point in a route
<span class="fc" id="L1366">            routes.ep1 = tE;</span>

        }
<span class="fc" id="L1369">    }</span>

    private void addEndpointsForHorizVertPatternOppos(int x0, int y0,
        Pattern pattern, Routes routes, Set&lt;PairInt&gt; endPoints, boolean useVert) {

<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">        if (endPoints.size() &lt; 2) {</span>
<span class="nc" id="L1375">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="pc bpc" id="L1377" title="3 of 4 branches missed.">        assert(routes.ep0 == null);</span>
<span class="pc bpc" id="L1378" title="3 of 4 branches missed.">        assert(routes.ep1End == null);</span>

<span class="fc bfc" id="L1380" title="All 2 branches covered.">        if (useVert) {</span>
            /*
               getEndPointsVertPattern1Opp, for example
                 R1    R0
                 /\    \/
                     -      -3
                  #  -  #   -2
               -  .  .  -   -1
               -  3  0  -    0
               -  2  1  -    1

              -2 -1  0  1
            */
<span class="pc bpc" id="L1393" title="3 of 4 branches missed.">            assert(pattern.ep0 != null);</span>
<span class="fc" id="L1394">            PairInt tE = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="fc" id="L1395">            PairInt tI = new PairInt(x0, y0 - 1);</span>
<span class="pc bpc" id="L1396" title="2 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute0().contains(tI)) {</span>
<span class="nc" id="L1397">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1399" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1400">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">            if (routes.getRoute0().isEmpty()) {</span>
<span class="nc" id="L1403">                routes.route0.add(tE);</span>
<span class="nc" id="L1404">                routes.route0.add(tI);</span>
<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">            } else if (routes.getRoute0().size() &gt; 1) {</span>
<span class="fc" id="L1406">                Iterator&lt;PairInt&gt; iter0 = routes.getRoute0().iterator();</span>
<span class="fc" id="L1407">                PairInt r1 = iter0.next();</span>
<span class="fc" id="L1408">                PairInt r2 = iter0.next();</span>
<span class="pc bpc" id="L1409" title="3 of 4 branches missed.">                if (r1.equals(tE) &amp;&amp; r2.equals(tI)) {</span>
                    // no need to add to route
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">                } else if (r1.equals(tI)) {</span>
<span class="fc" id="L1412">                    LinkedHashSet&lt;PairInt&gt; tmpR0 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1413">                    tmpR0.add(tE);</span>
<span class="fc" id="L1414">                    tmpR0.addAll(routes.route0);</span>
<span class="fc" id="L1415">                    routes.route0 = tmpR0;</span>
<span class="fc" id="L1416">                } else {</span>
<span class="nc" id="L1417">                    LinkedHashSet&lt;PairInt&gt; tmpR0 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1418">                    tmpR0.add(tE);</span>
<span class="nc" id="L1419">                    tmpR0.add(tI);</span>
<span class="nc" id="L1420">                    tmpR0.addAll(routes.route0);</span>
<span class="nc" id="L1421">                    routes.route0 = tmpR0;</span>
                }
            }
<span class="fc" id="L1424">            routes.ep0 = tE;</span>

<span class="pc bpc" id="L1426" title="3 of 4 branches missed.">            assert(pattern.ep1 != null);</span>
<span class="fc" id="L1427">            tE = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());</span>
<span class="fc" id="L1428">            tI = new PairInt(x0 - 1, y0 - 1);</span>
<span class="pc bpc" id="L1429" title="2 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute1().contains(tI)) {</span>
<span class="nc" id="L1430">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1433">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">            if (routes.getRoute1().isEmpty()) {</span>
                //TODO: revisit the logic. each route is probably always size &gt;= 2
<span class="nc" id="L1437">                routes.route1.add(tI);</span>
<span class="nc" id="L1438">                routes.route1.add(tE);</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">            } else if (routes.getRoute1().size() &gt; 1) {</span>
<span class="fc" id="L1440">                PairInt[] secondToLastAndLast = getSecondToLastAndLast(</span>
<span class="fc" id="L1441">                    routes.getRoute1().iterator());</span>
<span class="pc bpc" id="L1442" title="3 of 4 branches missed.">                if (secondToLastAndLast[0].equals(tI) &amp;&amp; secondToLastAndLast[1].equals(tE)) {</span>
                    // no need to add either to route
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">                } else if (secondToLastAndLast[1].equals(tI)) {</span>
<span class="fc" id="L1445">                    routes.route1.add(tE);</span>
                } else {
<span class="nc" id="L1447">                    routes.route1.add(tI);</span>
<span class="nc" id="L1448">                    routes.route1.add(tE);</span>
                }
            }
<span class="fc" id="L1451">            routes.ep1End = tE;</span>

<span class="fc" id="L1453">        } else {</span>
            /*
               getEndPoints Horiz Pattern1Opp
                              -3
                              -2
                  2  3  .  #  -1  --&gt;R1 ends
                  1  0  .      0
                           #   1  &lt;--R0 starts

              -2 -1  0  1  2
            */
<span class="pc bpc" id="L1464" title="3 of 4 branches missed.">            assert(pattern.ep0 != null);</span>
<span class="fc" id="L1465">            PairInt tE = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="fc" id="L1466">            PairInt tI = new PairInt(x0 + 1, y0);</span>
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1468">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
            // tI might have been added as a segment already
<span class="pc bpc" id="L1471" title="2 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute0().contains(tI)) {</span>
<span class="nc" id="L1472">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1474" title="1 of 2 branches missed.">            if (routes.getRoute0().isEmpty()) {</span>
<span class="nc" id="L1475">                routes.route0.add(tE);</span>
<span class="nc" id="L1476">                routes.route0.add(tI);</span>
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">            } else if (routes.getRoute0().size() &gt; 1) {</span>
<span class="fc" id="L1478">                Iterator&lt;PairInt&gt; iter0 = routes.getRoute0().iterator();</span>
<span class="fc" id="L1479">                PairInt r1 = iter0.next();</span>
<span class="fc" id="L1480">                PairInt r2 = iter0.next();</span>
<span class="pc bpc" id="L1481" title="3 of 4 branches missed.">                if (r1.equals(tE) &amp;&amp; r2.equals(tI)) {</span>
                    // no need to add to route
<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">                } else if (r1.equals(tI)) {</span>
<span class="fc" id="L1484">                    LinkedHashSet&lt;PairInt&gt; tmpR0 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1485">                    tmpR0.add(tE);</span>
<span class="fc" id="L1486">                    tmpR0.addAll(routes.route0);</span>
<span class="fc" id="L1487">                    routes.route0 = tmpR0;</span>
<span class="fc" id="L1488">                } else {</span>
<span class="nc" id="L1489">                    LinkedHashSet&lt;PairInt&gt; tmpR0 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1490">                    tmpR0.add(tE);</span>
<span class="nc" id="L1491">                    tmpR0.add(tI);</span>
<span class="nc" id="L1492">                    tmpR0.addAll(routes.route0);</span>
<span class="nc" id="L1493">                    routes.route0 = tmpR0;</span>
                }
            }
<span class="fc" id="L1496">            routes.ep0 = tE;</span>

<span class="pc bpc" id="L1498" title="3 of 4 branches missed.">            assert(pattern.ep1 != null);</span>
<span class="fc" id="L1499">            tE = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());</span>
<span class="fc" id="L1500">            tI = new PairInt(x0 + 1, y0 - 1);</span>
<span class="pc bpc" id="L1501" title="2 of 4 branches missed.">            if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute1().contains(tI)) {</span>
<span class="nc" id="L1502">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">            if (!endPoints.contains(tE)) {</span>
<span class="nc" id="L1505">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
            /*
               getEndPoints Horiz Pattern1Opp
                              -3
                              -2
                  2  3  .  #  -1  --&gt;R1 ends
                  1  0  .      0
                           #   1  &lt;--R0 starts

              -2 -1  0  1  2
            */
            // if tI is in route already, has to be last in route, or 2nd to
            //     last if tE is already present too
<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">            if (!routes.getRoute1().contains(tI)) {</span>
<span class="nc" id="L1520">                routes.route1.add(tI);</span>
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">            } else if (routes.getRoute1().size() &gt; 1) {</span>
<span class="fc" id="L1522">                PairInt[] secondToLastAndLast = getSecondToLastAndLast(</span>
<span class="fc" id="L1523">                    routes.getRoute1().iterator());</span>
<span class="pc bpc" id="L1524" title="3 of 4 branches missed.">                if (secondToLastAndLast[0].equals(tI) &amp;&amp; secondToLastAndLast[1].equals(tE)) {</span>
                    // no need to add either to route
<span class="pc bpc" id="L1526" title="1 of 2 branches missed.">                } else if (secondToLastAndLast[1].equals(tI)) {</span>
<span class="fc" id="L1527">                    routes.route1.add(tE);</span>
                } else {
<span class="nc" id="L1529">                    routes.route1.add(tI);</span>
<span class="nc" id="L1530">                    routes.route1.add(tE);</span>
                }
            }
<span class="fc" id="L1533">            routes.ep1End = tE;</span>
        }
<span class="fc" id="L1535">    }</span>

    private void addEndpointsForUUDiagPattern(final int x0, final int y0,
        final Pattern pattern, Routes routes, Set&lt;PairInt&gt; endPoints) {

<span class="nc bnc" id="L1540" title="All 2 branches missed.">        if (endPoints.size() &lt; 3) {</span>
<span class="nc" id="L1541">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc bnc" id="L1543" title="All 4 branches missed.">        assert(routes.ep0End == null);</span>
<span class="nc bnc" id="L1544" title="All 4 branches missed.">        assert(routes.ep1 == null);</span>

        /*
           UUDiagPattern1, for example
                -  -          -2
          -  2  1  -  -       -1
          -  -  3 .0  #        0    &lt;--# is route0 end endpoint
             -  .  -           1
                -  #           2    &lt;--# is route1 start endpoint

         -3 -2 -1  0  1
        */
<span class="nc bnc" id="L1556" title="All 4 branches missed.">        assert(pattern.ep0 != null);</span>
<span class="nc bnc" id="L1557" title="All 4 branches missed.">        assert(pattern.ep1 != null);</span>

<span class="nc" id="L1559">        PairInt tI = new PairInt(x0 - 1, y0 + 1);</span>
<span class="nc" id="L1560">        PairInt tE0 = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="nc" id="L1561">        PairInt tE1 = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());</span>
<span class="nc bnc" id="L1562" title="All 4 branches missed.">        if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute0().contains(tI)) {</span>
<span class="nc" id="L1563">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc bnc" id="L1565" title="All 4 branches missed.">        if (!endPoints.contains(tE0) || !endPoints.contains(tE1)) {</span>
<span class="nc" id="L1566">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc bnc" id="L1568" title="All 2 branches missed.">        if (routes.getRoute0().isEmpty()) {</span>
<span class="nc" id="L1569">            routes.route0.add(tE0);</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">        } else if (routes.getRoute0().size() &gt; 1) {</span>
<span class="nc" id="L1571">            PairInt[] secondToLastAndLast = getSecondToLastAndLast(</span>
<span class="nc" id="L1572">                routes.getRoute0().iterator());</span>
<span class="nc bnc" id="L1573" title="All 2 branches missed.">            if (secondToLastAndLast[1].equals(tE0)) {</span>
                // no need to add either to route
            } else {
<span class="nc" id="L1576">                routes.route0.add(tE0);</span>
            }
        }
<span class="nc" id="L1579">        routes.ep0End = tE0;</span>

<span class="nc bnc" id="L1581" title="All 2 branches missed.">        if (routes.getRoute1().isEmpty()) {</span>
<span class="nc" id="L1582">            routes.route1.add(tE1);</span>
<span class="nc" id="L1583">            routes.route1.add(tI);</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">        } else if (routes.getRoute1().size() &gt; 1) {</span>
<span class="nc" id="L1585">            Iterator&lt;PairInt&gt; iter1 = routes.getRoute1().iterator();</span>
<span class="nc" id="L1586">            PairInt r1 = iter1.next();</span>
<span class="nc" id="L1587">            PairInt r2 = iter1.next();</span>
<span class="nc bnc" id="L1588" title="All 4 branches missed.">            if (r1.equals(tE1) &amp;&amp; r2.equals(tI)) {</span>
                // no need to add to route
<span class="nc bnc" id="L1590" title="All 2 branches missed.">            } else if (r1.equals(tI)) {</span>
<span class="nc" id="L1591">                LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1592">                tmpR1.add(tE1);</span>
<span class="nc" id="L1593">                tmpR1.addAll(routes.route1);</span>
<span class="nc" id="L1594">                routes.route1 = tmpR1;</span>
<span class="nc" id="L1595">            } else {</span>
<span class="nc" id="L1596">                LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1597">                tmpR1.add(tE1);</span>
<span class="nc" id="L1598">                tmpR1.add(tI);</span>
<span class="nc" id="L1599">                tmpR1.addAll(routes.route1);</span>
<span class="nc" id="L1600">                routes.route1 = tmpR1;</span>
            }
        }
<span class="nc" id="L1603">        routes.ep1 = tE1;</span>
<span class="nc" id="L1604">    }</span>

    private void addEndpointsForULDiagPattern(int x0, int y0,
        Pattern pattern, Routes routes, Set&lt;PairInt&gt; endPoints) {

<span class="nc bnc" id="L1609" title="All 2 branches missed.">        if (endPoints.size() &lt; 3) {</span>
<span class="nc" id="L1610">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc bnc" id="L1612" title="All 4 branches missed.">        assert(routes.ep0End == null);</span>
<span class="nc bnc" id="L1613" title="All 4 branches missed.">        assert(routes.ep1 == null);</span>

        /*
           ULDiagPattern1, for example
                      2       -2
                .  3  1       -1
             #     0           0    &lt;--# is route1 start endpoint
                   #           1    &lt;--# is route0 end endpoint
                               2

         -3 -2 -1  0  1
        */
<span class="nc bnc" id="L1625" title="All 4 branches missed.">        assert(pattern.ep0 != null);</span>
<span class="nc bnc" id="L1626" title="All 4 branches missed.">        assert(pattern.ep1 != null);</span>

<span class="nc" id="L1628">        PairInt tI = new PairInt(x0 - 1, y0 - 1);</span>
<span class="nc" id="L1629">        PairInt tE0 = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="nc" id="L1630">        PairInt tE1 = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());</span>
<span class="nc bnc" id="L1631" title="All 4 branches missed.">        if (!endPoints.contains(tI) &amp;&amp; !routes.getRoute0().contains(tI)) {</span>
<span class="nc" id="L1632">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc bnc" id="L1634" title="All 4 branches missed.">        if (!endPoints.contains(tE0) || !endPoints.contains(tE1)) {</span>
<span class="nc" id="L1635">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc bnc" id="L1637" title="All 2 branches missed.">        if (routes.getRoute0().isEmpty()) {</span>
<span class="nc" id="L1638">            routes.route0.add(tE0);</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        } else if (routes.getRoute0().size() &gt; 1) {</span>
<span class="nc" id="L1640">            PairInt[] secondToLastAndLast = getSecondToLastAndLast(</span>
<span class="nc" id="L1641">                routes.getRoute0().iterator());</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            if (secondToLastAndLast[1].equals(tE0)) {</span>
                // no need to add either to route
            } else {
<span class="nc" id="L1645">                routes.route0.add(tE0);</span>
            }
        }
<span class="nc" id="L1648">        routes.ep0End = tE0;</span>

<span class="nc bnc" id="L1650" title="All 2 branches missed.">        if (routes.getRoute1().isEmpty()) {</span>
<span class="nc" id="L1651">            routes.route1.add(tE1);</span>
<span class="nc" id="L1652">            routes.route1.add(tI);</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">        } else if (routes.getRoute1().size() &gt; 1) {</span>
<span class="nc" id="L1654">            Iterator&lt;PairInt&gt; iter1 = routes.getRoute1().iterator();</span>
<span class="nc" id="L1655">            PairInt r1 = iter1.next();</span>
<span class="nc" id="L1656">            PairInt r2 = iter1.next();</span>
<span class="nc bnc" id="L1657" title="All 4 branches missed.">            if (r1.equals(tE1) &amp;&amp; r2.equals(tI)) {</span>
                // no need to add to route
<span class="nc bnc" id="L1659" title="All 2 branches missed.">            } else if (r1.equals(tI)) {</span>
<span class="nc" id="L1660">                LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1661">                tmpR1.add(tE1);</span>
<span class="nc" id="L1662">                tmpR1.addAll(routes.route1);</span>
<span class="nc" id="L1663">                routes.route1 = tmpR1;</span>
<span class="nc" id="L1664">            } else {</span>
<span class="nc" id="L1665">                LinkedHashSet&lt;PairInt&gt; tmpR1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1666">                tmpR1.add(tE1);</span>
<span class="nc" id="L1667">                tmpR1.add(tI);</span>
<span class="nc" id="L1668">                tmpR1.addAll(routes.route1);</span>
<span class="nc" id="L1669">                routes.route1 = tmpR1;</span>
            }
        }
<span class="nc" id="L1672">        routes.ep1 = tE1;</span>

<span class="nc" id="L1674">    }</span>

    private Routes checkForAdjacentEndpoints(Set&lt;PairInt&gt; points,
        LinkedList&lt;Segment&gt; section, Routes routes) {

        // the list of segments was built from a closed curve

<span class="nc" id="L1681">        Segment lastSegment = section.getLast();</span>

<span class="nc bnc" id="L1683" title="All 2 branches missed.">        if (lastSegment instanceof VertSegment) {</span>

<span class="nc" id="L1685">            boolean useVertical = true;</span>

<span class="nc" id="L1687">            routes = findEndPointsVertHorizPatterns(points, routes, lastSegment,</span>
                useVertical);

<span class="nc bnc" id="L1690" title="All 2 branches missed.">        } else if (lastSegment instanceof HorizSegment) {</span>

<span class="nc" id="L1692">            boolean useVertical = false;</span>

<span class="nc" id="L1694">            routes = findEndPointsVertHorizPatterns(points, routes, lastSegment,</span>
                useVertical);

<span class="nc bnc" id="L1697" title="All 2 branches missed.">        } else if (lastSegment instanceof UUDiagSegment) {</span>

<span class="nc" id="L1699">            routes = findEndPointsDiagPatterns(points, routes,</span>
                (UUDiagSegment)lastSegment);
        }

<span class="nc" id="L1703">        return routes;</span>
    }

    private void addSegmentToRoutes(Routes routes, Segment segment) {

<span class="nc bnc" id="L1708" title="All 2 branches missed.">        if (segment instanceof VertSegment) {</span>
<span class="nc" id="L1709">            addVertSegmentToRoutes(routes, (VertSegment)segment);</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">        } else if (segment instanceof HorizSegment) {</span>
<span class="nc" id="L1711">            addHorizSegmentToRoutes(routes, (HorizSegment)segment);</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        } else if (segment instanceof UUDiagSegment) {</span>
<span class="nc" id="L1713">            addUUDiagSegmentToRoutes(routes, (UUDiagSegment)segment);</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        } else if (segment instanceof ULDiagSegment) {</span>
<span class="nc" id="L1715">            addUUDiagSegmentToRoutes(routes, (ULDiagSegment)segment);</span>
        }

<span class="nc" id="L1718">    }</span>

    private void addVertSegmentToRoutes(Routes routes, VertSegment segment) {

<span class="nc bnc" id="L1722" title="All 4 branches missed.">        assert(!routes.route0.isEmpty());</span>
<span class="nc bnc" id="L1723" title="All 4 branches missed.">        assert(!routes.route1.isEmpty());</span>

        // -------- add to routes0 -------------------------
<span class="nc" id="L1726">        PairInt[] r0FirstLastNodes = getFirstAndLast(routes.route0.iterator());</span>

<span class="nc" id="L1728">        double p0MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1729">        int p0MinIdx = -1;</span>
<span class="nc" id="L1730">        double p1MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1731">        int p1MinIdx = -1;</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">        for (int i = 0; i &lt; r0FirstLastNodes.length; ++i) {</span>
<span class="nc" id="L1733">            PairInt r0 = r0FirstLastNodes[i];</span>
<span class="nc" id="L1734">            int distSq = distSq(segment.p0, r0);</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">            if (distSq &lt; p0MinDistSq) {</span>
<span class="nc" id="L1736">                p0MinDistSq = distSq;</span>
<span class="nc" id="L1737">                p0MinIdx = i;</span>
            }
<span class="nc" id="L1739">            distSq = distSq(segment.p1, r0);</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            if (distSq &lt; p1MinDistSq) {</span>
<span class="nc" id="L1741">                p1MinDistSq = distSq;</span>
<span class="nc" id="L1742">                p1MinIdx = i;</span>
            }
        }

<span class="nc bnc" id="L1746" title="All 2 branches missed.">        if (segment.p1.getY() &lt; segment.p0.getY()) {</span>

            /*      VertSegment

                       R0
                       \/
                  .     .        -2
               -  2     1:E0 -   -1
               -  3:E1  0    -    0
                  .     .         1

              -2 -1     0    1

                  /\
                  R1
            */
<span class="nc bnc" id="L1762" title="All 2 branches missed.">            if (!(segment.p2.getY() &lt; segment.p3.getY())) {</span>
<span class="nc" id="L1763">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L1765" title="All 2 branches missed.">            if (p0MinDistSq &lt; p1MinDistSq) {</span>
                /*
                1
                0
                [*]
                [*]
                E0end
                */
<span class="nc bnc" id="L1773" title="All 2 branches missed.">                if (p0MinIdx != 0) {</span>
<span class="nc" id="L1774">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1776" title="All 2 branches missed.">                if (routes.ep0 != null) {</span>
<span class="nc" id="L1777">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1779">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1780">                tmp.add(segment.p1);</span>
<span class="nc" id="L1781">                tmp.add(segment.p0);</span>
<span class="nc" id="L1782">                tmp.addAll(routes.route0);</span>
<span class="nc" id="L1783">                routes.route0 = tmp;</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">            } else if (p1MinDistSq &lt; p0MinDistSq) {</span>
                /*
                E0
                [*]
                [*]
                1
                0
                */
<span class="nc bnc" id="L1792" title="All 2 branches missed.">                if (p1MinIdx != 1) {</span>
<span class="nc" id="L1793">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1795" title="All 2 branches missed.">                if (routes.ep0End != null) {</span>
<span class="nc" id="L1796">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1798">                routes.route0.add(segment.p1);</span>
<span class="nc" id="L1799">                routes.route0.add(segment.p0);</span>
            } else {
<span class="nc" id="L1801">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }

<span class="nc bnc" id="L1804" title="All 2 branches missed.">        } else if (segment.p0.getY() &lt; segment.p1.getY()) {</span>

            /*   swapped VertSegment
                        R0
                        \/
                   .     .         -1    E0 marks endpoint 0 and the
                -  3     0:E0  -    0       start of route 0.
                -  2:E1  1     -    1       which incr w/ incr y.
                   .     .          2    route 1 starts at E1 and incr w/ decr y
               -2 -1     0     1

                  /\
                  R1
            */

<span class="nc bnc" id="L1819" title="All 2 branches missed.">            if (!(segment.p3.getY() &lt; segment.p2.getY())) {</span>
<span class="nc" id="L1820">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            if (p0MinDistSq &lt; p1MinDistSq) {</span>
                /*
                E0
                [*]
                [*]
                0
                1
                */
<span class="nc bnc" id="L1830" title="All 2 branches missed.">                if (p0MinIdx != 1) {</span>
<span class="nc" id="L1831">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1833" title="All 2 branches missed.">                if (routes.ep0End != null) {</span>
<span class="nc" id="L1834">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1836">                routes.route0.add(segment.p0);</span>
<span class="nc" id="L1837">                routes.route0.add(segment.p1);</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">            } else if (p1MinDistSq &lt; p0MinDistSq) {</span>
                /*
                0
                1
                [*]
                [*]
                E0end
                */
<span class="nc bnc" id="L1846" title="All 2 branches missed.">                if (p1MinIdx != 0) {</span>
<span class="nc" id="L1847">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1849" title="All 2 branches missed.">                if (routes.ep0 != null) {</span>
<span class="nc" id="L1850">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1852">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1853">                tmp.add(segment.p0);</span>
<span class="nc" id="L1854">                tmp.add(segment.p1);</span>
<span class="nc" id="L1855">                tmp.addAll(routes.route0);</span>
<span class="nc" id="L1856">                routes.route0 = tmp;</span>
<span class="nc" id="L1857">            } else {</span>
<span class="nc" id="L1858">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }

        } else {
<span class="nc" id="L1862">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }

        // ------------ add to routes1 -----------------
        /*   VertSegment              swapY VertSegment
              .     .        -2
           -  2     1:E0 -   -1         .     .         -1    E0 marks endpoint 0 and the
           -  3:E1  0    -    0      -  3     0:E0  -    0       start of route 0.
              .     .         1      -  2:E1  1     -    1       which incr w/ incr y.
                                        .     .          2    route 1 starts at E1 and incr w/ decr y
          -2 -1     0    1          -2 -1     0     1
        */
<span class="nc" id="L1874">        PairInt[] r1FirstLastNodes = getFirstAndLast(routes.route1.iterator());</span>
<span class="nc" id="L1875">        double p2MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1876">        int p2MinIdx = -1;</span>
<span class="nc" id="L1877">        double p3MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1878">        int p3MinIdx = -1;</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        for (int i = 0; i &lt; r1FirstLastNodes.length; ++i) {</span>
<span class="nc" id="L1880">            PairInt r1 = r1FirstLastNodes[i];</span>
<span class="nc" id="L1881">            int distSq = distSq(segment.p2, r1);</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">            if (distSq &lt; p2MinDistSq) {</span>
<span class="nc" id="L1883">                p2MinDistSq = distSq;</span>
<span class="nc" id="L1884">                p2MinIdx = i;</span>
            }
<span class="nc" id="L1886">            distSq = distSq(segment.p3, r1);</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">            if (distSq &lt; p3MinDistSq) {</span>
<span class="nc" id="L1888">                p3MinDistSq = distSq;</span>
<span class="nc" id="L1889">                p3MinIdx = i;</span>
            }
        }

<span class="nc bnc" id="L1893" title="All 2 branches missed.">        if (segment.p2.getY() &lt; segment.p3.getY()) {</span>

            /*      VertSegment

                       R0
                       \/
                  .     .        -2
               -  2     1:E0 -   -1
               -  3:E1  0    -    0
                  .     .         1

              -2 -1     0    1

                  /\
                  R1
            */
<span class="nc bnc" id="L1909" title="All 2 branches missed.">            if (!(segment.p1.getY() &lt; segment.p0.getY())) {</span>
<span class="nc" id="L1910">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L1912" title="All 2 branches missed.">            if (p3MinDistSq &lt; p2MinDistSq) {</span>
                /*
                2
                3
                [*]
                [*]
                E1
                */
<span class="nc bnc" id="L1920" title="All 2 branches missed.">                if (p3MinIdx != 1) {</span>
<span class="nc" id="L1921">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1923" title="All 2 branches missed.">                if (routes.ep1End != null) {</span>
<span class="nc" id="L1924">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1926">                routes.route1.add(segment.p3);</span>
<span class="nc" id="L1927">                routes.route1.add(segment.p2);</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">            } else if (p2MinDistSq &lt; p3MinDistSq) {</span>
                /*
                E1end
                [*]
                [*]
                2
                3
                */
<span class="nc bnc" id="L1936" title="All 2 branches missed.">                if (p2MinIdx != 0) {</span>
<span class="nc" id="L1937">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">                if (routes.ep1 != null) {</span>
<span class="nc" id="L1940">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1942">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1943">                tmp.add(segment.p3);</span>
<span class="nc" id="L1944">                tmp.add(segment.p2);</span>
<span class="nc" id="L1945">                tmp.addAll(routes.route1);</span>
<span class="nc" id="L1946">                routes.route1 = tmp;</span>
<span class="nc" id="L1947">            } else {</span>
<span class="nc" id="L1948">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }

<span class="nc bnc" id="L1951" title="All 2 branches missed.">        } else if (segment.p3.getY() &lt; segment.p2.getY()) {</span>

            /*   swapped VertSegment
                        R0
                        \/
                   .     .         -1    E0 marks endpoint 0 and the
                -  3     0:E0  -    0       start of route 0.
                -  2:E1  1     -    1       which incr w/ incr y.
                   .     .          2    route 1 starts at E1 and incr w/ decr y
               -2 -1     0     1

                  /\
                  R1
            */
<span class="nc bnc" id="L1965" title="All 2 branches missed.">            if (!(segment.p0.getY() &lt; segment.p1.getY())) {</span>
<span class="nc" id="L1966">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L1968" title="All 2 branches missed.">            if (p3MinDistSq &lt; p2MinDistSq) {</span>
                /*
                E1end
                [*]
                [*]
                3
                2
                */
<span class="nc bnc" id="L1976" title="All 2 branches missed.">                if (p3MinIdx != 0) {</span>
<span class="nc" id="L1977">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1979" title="All 2 branches missed.">                if (routes.ep1 != null) {</span>
<span class="nc" id="L1980">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L1982">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1983">                tmp.add(segment.p2);</span>
<span class="nc" id="L1984">                tmp.add(segment.p3);</span>
<span class="nc" id="L1985">                tmp.addAll(routes.route1);</span>
<span class="nc" id="L1986">                routes.route1 = tmp;</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">            } else if (p2MinDistSq &lt; p3MinDistSq) {</span>
                /*
                3
                2
                [*]
                [*]
                E1
                */
<span class="nc bnc" id="L1995" title="All 2 branches missed.">                if (p2MinIdx != 1) {</span>
<span class="nc" id="L1996">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L1998" title="All 2 branches missed.">                if (routes.ep1End != null) {</span>
<span class="nc" id="L1999">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L2001">                routes.route1.add(segment.p2);</span>
<span class="nc" id="L2002">                routes.route1.add(segment.p3);</span>
            } else {
<span class="nc" id="L2004">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }

        } else {
<span class="nc" id="L2008">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc" id="L2010">    }</span>

    private void addHorizSegmentToRoutes(Routes routes, HorizSegment segment) {

<span class="nc bnc" id="L2014" title="All 4 branches missed.">        assert(!routes.route0.isEmpty());</span>
<span class="nc bnc" id="L2015" title="All 4 branches missed.">        assert(!routes.route1.isEmpty());</span>

        /*             HorizSegment              swap HorizSegment
                       -    -       -2          -    -         -2
        R0 &gt;        .  3:E0 2    .  -1       .  2:E0 3     .   -1    route0 incr w/ incr x
        R1 &lt;        .  0    1:E1 .   0       .  1    0:E1  .    0    route1 incr w/ decr x
                       -    -        1          -    -          1
                   -1  0    1    2          -2 -1    0     1
        */
        // -------- add to routes0 -------------------------
<span class="nc" id="L2025">        PairInt[] r0FirstLastNodes = getFirstAndLast(routes.route0.iterator());</span>

<span class="nc" id="L2027">        double p3MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2028">        int p3MinIdx = -1;</span>
<span class="nc" id="L2029">        double p2MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2030">        int p2MinIdx = -1;</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">        for (int i = 0; i &lt; r0FirstLastNodes.length; ++i) {</span>
<span class="nc" id="L2032">            PairInt r0 = r0FirstLastNodes[i];</span>
<span class="nc" id="L2033">            int distSq = distSq(segment.p3, r0);</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">            if (distSq &lt; p3MinDistSq) {</span>
<span class="nc" id="L2035">                p3MinDistSq = distSq;</span>
<span class="nc" id="L2036">                p3MinIdx = i;</span>
            }
<span class="nc" id="L2038">            distSq = distSq(segment.p2, r0);</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">            if (distSq &lt; p2MinDistSq) {</span>
<span class="nc" id="L2040">                p2MinDistSq = distSq;</span>
<span class="nc" id="L2041">                p2MinIdx = i;</span>
            }
        }

<span class="nc bnc" id="L2045" title="All 2 branches missed.">        if (segment.p3.getX() &lt; segment.p2.getX()) {</span>
            /*             HorizSegment
                           -    -       -2
            R0 &gt;        .  3:E0 2    .  -1
            R1 &lt;        .  0    1:E1 .   0
                           -    -        1
                       -1  0    1    2
            */
<span class="nc bnc" id="L2053" title="All 2 branches missed.">            if (!(segment.p1.getX() &gt; segment.p0.getX())) {</span>
<span class="nc" id="L2054">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2056" title="All 2 branches missed.">            if (p3MinDistSq &lt; p2MinDistSq) {</span>
<span class="nc bnc" id="L2057" title="All 2 branches missed.">                if (p3MinIdx != 1) {</span>
<span class="nc" id="L2058">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
                //R0: E0 [*][*]  3 2   append '3' '2' to end of route0
<span class="nc bnc" id="L2061" title="All 2 branches missed.">                if (routes.ep0End != null) {</span>
<span class="nc" id="L2062">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L2064">                routes.route0.add(segment.p3);</span>
<span class="nc" id="L2065">                routes.route0.add(segment.p2);</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">            } else if (p3MinDistSq &gt; p2MinDistSq) {</span>
<span class="nc bnc" id="L2067" title="All 2 branches missed.">                if (p2MinIdx != 0) {</span>
<span class="nc" id="L2068">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                if (routes.ep0 != null) {</span>
<span class="nc" id="L2071">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
                //R0: 3  2  [*][*] E0end insert '3' '2' to beginning of route0
<span class="nc" id="L2074">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2075">                tmp.add(segment.p3);</span>
<span class="nc" id="L2076">                tmp.add(segment.p2);</span>
<span class="nc" id="L2077">                tmp.addAll(routes.route0);</span>
<span class="nc" id="L2078">                routes.route0 = tmp;</span>
<span class="nc" id="L2079">            } else {</span>
<span class="nc" id="L2080">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2082" title="All 2 branches missed.">        } else if (segment.p3.getX() &gt; segment.p2.getX()) {</span>

            /*           swapped HorizSegment
                          -    -         -2
            R0 &gt;       .  2:E0 3     .   -1    route0 incr w/ incr x
            R1 &lt;       .  1    0:E1  .    0    route1 incr w/ decr x
                          -    -          1
                         -2    -1    0    1
            */
<span class="nc bnc" id="L2091" title="All 2 branches missed.">            if (!(segment.p0.getX() &gt; segment.p1.getX())) {</span>
<span class="nc" id="L2092">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            if (p3MinDistSq &lt; p2MinDistSq) {</span>
<span class="nc bnc" id="L2095" title="All 2 branches missed.">                if (p3MinIdx != 0) {</span>
<span class="nc" id="L2096">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2098" title="All 2 branches missed.">                if (routes.ep0 != null) {</span>
<span class="nc" id="L2099">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
                //R0    '2' '3' [*] [*] E0end insert '2' '3' at beginning of route0
<span class="nc" id="L2102">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2103">                tmp.add(segment.p2);</span>
<span class="nc" id="L2104">                tmp.add(segment.p3);</span>
<span class="nc" id="L2105">                tmp.addAll(routes.route0);</span>
<span class="nc" id="L2106">                routes.route0 = tmp;</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">            } else if (p3MinDistSq &gt; p2MinDistSq) {</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">                if (p2MinIdx != 1) {</span>
<span class="nc" id="L2109">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2111" title="All 2 branches missed.">                if (routes.ep0End != null) {</span>
<span class="nc" id="L2112">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
                //R0 E0 [*] [*] '2' '3'  append '2' '3' to end of route0
<span class="nc" id="L2115">                routes.route0.add(segment.p2);</span>
<span class="nc" id="L2116">                routes.route0.add(segment.p3);</span>
            } else {
<span class="nc" id="L2118">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
        } else {
<span class="nc" id="L2121">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }

        /*             HorizSegment              swap HorizSegment
                       -    -       -2          -    -         -2
        R0 &gt;        .  3:E0 2    .  -1       .  2:E0 3     .   -1    route0 incr w/ incr x
        R1 &lt;        .  0    1:E1 .   0       .  1    0:E1  .    0    route1 incr w/ decr x
                       -    -        1          -    -          1
                   -1  0    1    2          -2 -1    0     1
        */
        // -------- add to routes1 -------------------------
<span class="nc" id="L2132">        PairInt[] r1FirstLastNodes = getFirstAndLast(routes.route1.iterator());</span>

<span class="nc" id="L2134">        double p0MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2135">        int p0MinIdx = -1;</span>
<span class="nc" id="L2136">        double p1MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2137">        int p1MinIdx = -1;</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">        for (int i = 0; i &lt; r1FirstLastNodes.length; ++i) {</span>
<span class="nc" id="L2139">            PairInt r1 = r1FirstLastNodes[i];</span>
<span class="nc" id="L2140">            int distSq = distSq(segment.p0, r1);</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">            if (distSq &lt; p0MinDistSq) {</span>
<span class="nc" id="L2142">                p0MinDistSq = distSq;</span>
<span class="nc" id="L2143">                p0MinIdx = i;</span>
            }
<span class="nc" id="L2145">            distSq = distSq(segment.p1, r1);</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            if (distSq &lt; p1MinDistSq) {</span>
<span class="nc" id="L2147">                p1MinDistSq = distSq;</span>
<span class="nc" id="L2148">                p1MinIdx = i;</span>
            }
        }

<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (segment.p0.getX() &lt; segment.p1.getX()) {</span>
            /*             HorizSegment
                           -    -       -2
            R0 &gt;        .  3:E0 2    .  -1
            R1 &lt;        .  0    1:E1 .   0
                           -    -        1
                       -1  0    1    2
            */
<span class="nc bnc" id="L2160" title="All 2 branches missed.">            if (!(segment.p3.getX() &lt; segment.p2.getX())) {</span>
<span class="nc" id="L2161">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2163" title="All 2 branches missed.">            if (p0MinDistSq &lt; p1MinDistSq) {</span>
                // R1 &lt;  E1End [*] [*] '0' '1'    &lt;---- direction of increase
<span class="nc bnc" id="L2165" title="All 2 branches missed.">                if (p0MinIdx != 0) {</span>
<span class="nc" id="L2166">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2168" title="All 2 branches missed.">                if (routes.ep1 != null) {</span>
<span class="nc" id="L2169">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L2171">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2172">                tmp.add(segment.p0);</span>
<span class="nc" id="L2173">                tmp.add(segment.p1);</span>
<span class="nc" id="L2174">                tmp.addAll(routes.route1);</span>
<span class="nc" id="L2175">                routes.route1 = tmp;</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            } else if (p1MinDistSq &lt; p0MinDistSq) {</span>
                // R1 &lt;   '0' '1'  [*] [*] E1  &lt;---- direction of increase
<span class="nc bnc" id="L2178" title="All 2 branches missed.">                if (p1MinIdx != 1) {</span>
<span class="nc" id="L2179">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2181" title="All 2 branches missed.">                if (routes.ep1End != null) {</span>
<span class="nc" id="L2182">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L2184">                routes.route1.add(segment.p1);</span>
<span class="nc" id="L2185">                routes.route1.add(segment.p0);</span>
            } else {
<span class="nc" id="L2187">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2189" title="All 2 branches missed.">        } else if (segment.p1.getX() &lt; segment.p0.getX()) {</span>
            /*           swapped HorizSegment
                          -    -         -2
            R0 &gt;       .  2:E0 3     .   -1    route0 incr w/ incr x
            R1 &lt;       .  1    0:E1  .    0    route1 incr w/ decr x
                          -    -          1
                         -2    -1    0    1
            */
<span class="nc bnc" id="L2197" title="All 2 branches missed.">            if (!(segment.p2.getX() &lt; segment.p3.getX())) {</span>
<span class="nc" id="L2198">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2200" title="All 2 branches missed.">            if (p0MinDistSq &lt; p1MinDistSq) {</span>
                // R1 &lt;   '1' '0'  [*] [*] E1 &lt;---- direction of increase
<span class="nc bnc" id="L2202" title="All 2 branches missed.">                if (p0MinIdx != 1) {</span>
<span class="nc" id="L2203">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                if (routes.ep1End != null) {</span>
<span class="nc" id="L2206">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L2208">                routes.route1.add(segment.p0);</span>
<span class="nc" id="L2209">                routes.route1.add(segment.p1);</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">            } else if (p1MinDistSq &lt; p0MinDistSq) {</span>
                // R1 &lt;  E1end [*] [*] '1' '0'  &lt;---- direction of increase
<span class="nc bnc" id="L2212" title="All 2 branches missed.">                if (p1MinIdx != 0) {</span>
<span class="nc" id="L2213">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc bnc" id="L2215" title="All 2 branches missed.">                if (routes.ep1 != null) {</span>
<span class="nc" id="L2216">                    throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
                }
<span class="nc" id="L2218">                LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2219">                tmp.add(segment.p1);</span>
<span class="nc" id="L2220">                tmp.add(segment.p0);</span>
<span class="nc" id="L2221">                tmp.addAll(routes.route1);</span>
<span class="nc" id="L2222">                routes.route1 = tmp;</span>
<span class="nc" id="L2223">            } else {</span>
<span class="nc" id="L2224">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
        } else {
<span class="nc" id="L2227">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc" id="L2229">    }</span>

    protected PairInt[] getFirstAndLast(Iterator&lt;PairInt&gt; iter) {
<span class="fc" id="L2232">        PairInt firstNode = null;</span>
<span class="fc" id="L2233">        PairInt lastNode = null;</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc bfc" id="L2235" title="All 2 branches covered.">            if (firstNode == null) {</span>
<span class="fc" id="L2236">                firstNode = iter.next();</span>
            } else {
<span class="fc" id="L2238">                lastNode = iter.next();</span>
            }
        }
<span class="fc" id="L2241">        return new PairInt[]{firstNode, lastNode};</span>
    }

    protected PairInt[] getSecondToLastAndLast(Iterator&lt;PairInt&gt; iter) {
<span class="fc" id="L2245">        PairInt secondToLastNode = null;</span>
<span class="fc" id="L2246">        PairInt lastNode = null;</span>
<span class="fc bfc" id="L2247" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2248">            PairInt n0 = iter.next();</span>
<span class="fc bfc" id="L2249" title="All 2 branches covered.">            if (iter.hasNext()) {</span>
<span class="fc" id="L2250">                secondToLastNode = n0;</span>
<span class="fc" id="L2251">                lastNode = iter.next();</span>
            } else {
<span class="fc" id="L2253">                secondToLastNode = lastNode;</span>
<span class="fc" id="L2254">                lastNode = n0;</span>
            }
<span class="fc" id="L2256">        }</span>
<span class="fc" id="L2257">        return new PairInt[]{secondToLastNode, lastNode};</span>
    }

    private void addUUDiagSegmentToRoutes(Routes routes, DiagSegment
        segment) {

<span class="nc bnc" id="L2263" title="All 4 branches missed.">        assert(!routes.route0.isEmpty());</span>
<span class="nc bnc" id="L2264" title="All 4 branches missed.">        assert(!routes.route1.isEmpty());</span>

        /*      UUDiagSegment
                    -  -      -2
              -  2  1  -  -   -1
              -  -  3  0  -    0
                 -  -          1
             -3 -2 -1  0  1

               E0 is '1', and route0
                  continues with
                  point '0'
               E1 is '3', and route1
                  continues with '2'
        */

        // ------- add to route0 ---------
<span class="nc" id="L2281">        PairInt[] r0FirstLastNodes = getFirstAndLast(routes.route0.iterator());</span>

<span class="nc" id="L2283">        double p0MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2284">        int p0MinIdx = -1;</span>
<span class="nc" id="L2285">        double p1MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2286">        int p1MinIdx = -1;</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">        for (int i = 0; i &lt; r0FirstLastNodes.length; ++i) {</span>
<span class="nc" id="L2288">            PairInt r0 = r0FirstLastNodes[i];</span>
<span class="nc" id="L2289">            int distSq = distSq(segment.p0, r0);</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">            if (distSq &lt; p0MinDistSq) {</span>
<span class="nc" id="L2291">                p0MinDistSq = distSq;</span>
<span class="nc" id="L2292">                p0MinIdx = i;</span>
            }
<span class="nc" id="L2294">            distSq = distSq(segment.p1, r0);</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">            if (distSq &lt; p1MinDistSq) {</span>
<span class="nc" id="L2296">                p1MinDistSq = distSq;</span>
<span class="nc" id="L2297">                p1MinIdx = i;</span>
            }
        }

<span class="nc bnc" id="L2301" title="All 2 branches missed.">        if (p1MinDistSq &lt; p0MinDistSq) {</span>
            /*
            E0
            [*]
            [*]
            '1'
            '0'
            */
<span class="nc bnc" id="L2309" title="All 2 branches missed.">            if (p1MinIdx != 1) {</span>
<span class="nc" id="L2310">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2312" title="All 2 branches missed.">            if (routes.ep0End != null) {</span>
<span class="nc" id="L2313">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc" id="L2315">            routes.route0.add(segment.p1);</span>
<span class="nc" id="L2316">            routes.route0.add(segment.p0);</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">        } else if (p0MinDistSq &lt; p1MinDistSq) {</span>
            /*
            '1'
            '0'
            [*]
            [*]
            E0end
            */
<span class="nc bnc" id="L2325" title="All 2 branches missed.">            if (p0MinIdx != 0) {</span>
<span class="nc" id="L2326">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2328" title="All 2 branches missed.">            if (routes.ep0 != null) {</span>
<span class="nc" id="L2329">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc" id="L2331">            LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2332">            tmp.add(segment.p1);</span>
<span class="nc" id="L2333">            tmp.add(segment.p0);</span>
<span class="nc" id="L2334">            tmp.addAll(routes.route0);</span>
<span class="nc" id="L2335">            routes.route0 = tmp;</span>
<span class="nc" id="L2336">        } else {</span>
<span class="nc" id="L2337">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }

        // ------ add to route1 ------------
<span class="nc" id="L2341">        PairInt[] r1FirstLastNodes = getFirstAndLast(routes.route1.iterator());</span>
<span class="nc" id="L2342">        double p2MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2343">        int p2MinIdx = -1;</span>
<span class="nc" id="L2344">        double p3MinDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2345">        int p3MinIdx = -1;</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">        for (int i = 0; i &lt; r1FirstLastNodes.length; ++i) {</span>
<span class="nc" id="L2347">            PairInt r1 = r1FirstLastNodes[i];</span>
<span class="nc" id="L2348">            int distSq = distSq(segment.p2, r1);</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            if (distSq &lt; p2MinDistSq) {</span>
<span class="nc" id="L2350">                p2MinDistSq = distSq;</span>
<span class="nc" id="L2351">                p2MinIdx = i;</span>
            }
<span class="nc" id="L2353">            distSq = distSq(segment.p3, r1);</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">            if (distSq &lt; p3MinDistSq) {</span>
<span class="nc" id="L2355">                p3MinDistSq = distSq;</span>
<span class="nc" id="L2356">                p3MinIdx = i;</span>
            }
        }

<span class="nc bnc" id="L2360" title="All 2 branches missed.">        if (p2MinDistSq &lt; p3MinDistSq) {</span>
            /*
            E1end
            [*]
            [*]
            '2'
            '3'
            */
<span class="nc bnc" id="L2368" title="All 2 branches missed.">            if (p2MinIdx != 0) {</span>
<span class="nc" id="L2369">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2371" title="All 2 branches missed.">            if (routes.ep1 != null) {</span>
<span class="nc" id="L2372">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc" id="L2374">            LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2375">            tmp.add(segment.p3);</span>
<span class="nc" id="L2376">            tmp.add(segment.p2);</span>
<span class="nc" id="L2377">            tmp.addAll(routes.route1);</span>
<span class="nc" id="L2378">            routes.route1 = tmp;</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">        } else if (p3MinDistSq &lt; p2MinDistSq) {</span>
            /*
            '2'
            '3'
            [*]
            [*]
            E1
            */
<span class="nc bnc" id="L2387" title="All 2 branches missed.">            if (p3MinIdx != 1) {</span>
<span class="nc" id="L2388">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc bnc" id="L2390" title="All 2 branches missed.">            if (routes.ep1End != null) {</span>
<span class="nc" id="L2391">                throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
            }
<span class="nc" id="L2393">            routes.route1.add(segment.p3);</span>
<span class="nc" id="L2394">            routes.route1.add(segment.p2);</span>
        } else {
<span class="nc" id="L2396">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="nc" id="L2398">    }</span>

    private ZigZagSegmentRoutes parseZigZag(Segment segment, Set&lt;PairInt&gt; endPoints) {

<span class="pc bpc" id="L2402" title="1 of 4 branches missed.">        if (!(segment instanceof ZigZagSegment) &amp;&amp;</span>
            !(segment instanceof ZigZagSegment2)) {
<span class="nc" id="L2404">            throw new IllegalArgumentException(</span>
            &quot;segment type must be ZigZagSegment or ZigZagSegment2&quot;);
        }

<span class="pc bpc" id="L2408" title="1 of 2 branches missed.">        if (endPoints.size() != 4) {</span>
<span class="nc" id="L2409">            throw new IllegalStateException(&quot;endPoints must be size 4&quot;);</span>
        }

<span class="fc" id="L2412">        ZigZagSegmentRoutes routes = null;</span>

<span class="fc bfc" id="L2414" title="All 2 branches covered.">        if (segment instanceof ZigZagSegment) {</span>
<span class="fc bfc" id="L2415" title="All 2 branches covered.">            if (segment.p2.getX() &lt; segment.p1.getX()) {</span>

                /*
                       E0
                           2  -            -2
                           -  1 .  E0end   -1
                  E1end  . 0  -             0
                           -  3             1
                                 E1
                 -3 -2 -1  0  1
                */

                // '1' and '2' on one route and '0' and '3' on another.
                // add the endpoints before and after

<span class="fc" id="L2430">                routes = new ZigZagSegmentRoutes();</span>

<span class="fc" id="L2432">                routes.ep1 = findClosestTo(segment.p3, endPoints);</span>
<span class="fc" id="L2433">                routes.route1.add(routes.ep1);</span>
<span class="fc" id="L2434">                routes.route1.add(segment.p3);</span>
<span class="fc" id="L2435">                routes.route1.add(segment.p0);</span>
<span class="fc" id="L2436">                routes.ep1End = findClosestTo(segment.p0, endPoints);</span>
<span class="fc" id="L2437">                routes.route1.add(routes.ep1End);</span>

<span class="fc" id="L2439">                routes.ep0 = findClosestTo(segment.p2, endPoints);</span>
<span class="fc" id="L2440">                routes.route0.add(routes.ep0);</span>
<span class="fc" id="L2441">                routes.route0.add(segment.p2);</span>
<span class="fc" id="L2442">                routes.route0.add(segment.p1);</span>
<span class="fc" id="L2443">                routes.ep0End = findClosestTo(segment.p1, endPoints);</span>
<span class="fc" id="L2444">                routes.route0.add(routes.ep0End);</span>

            } else {

                /*            E0end
                        -  2          -2
                 E0   . 1  -          -1
                        -  0 . E1      0
                        3  -           1
                  E1end
                 -3 -2 -1  0  1
                */
                // '1' and '2' on one route and '0' and '3' on another.
                // add the endpoints before and after

<span class="fc" id="L2459">                routes = new ZigZagSegmentRoutes();</span>

<span class="fc" id="L2461">                routes.ep0 = findClosestTo(segment.p1, endPoints);</span>
<span class="fc" id="L2462">                routes.route0.add(routes.ep0);</span>
<span class="fc" id="L2463">                routes.route0.add(segment.p1);</span>
<span class="fc" id="L2464">                routes.route0.add(segment.p2);</span>
<span class="fc" id="L2465">                routes.ep0End = findClosestTo(segment.p2, endPoints);</span>
<span class="fc" id="L2466">                routes.route0.add(routes.ep0End);</span>

<span class="fc" id="L2468">                routes.ep1 = findClosestTo(segment.p0, endPoints);</span>
<span class="fc" id="L2469">                routes.route1.add(routes.ep1);</span>
<span class="fc" id="L2470">                routes.route1.add(segment.p0);</span>
<span class="fc" id="L2471">                routes.route1.add(segment.p3);</span>
<span class="fc" id="L2472">                routes.ep1End = findClosestTo(segment.p3, endPoints);</span>
<span class="fc" id="L2473">                routes.route1.add(routes.ep1End);</span>

            }
        } else {
<span class="fc bfc" id="L2477" title="All 2 branches covered.">            if (segment.p0.getY() &lt; segment.p1.getY()) {</span>

                /*      E1end     E0
                           .            -1
                        -  0  -  3       0
                        1  -  2  -       1
                     E1       .  E0end   2
                 -3 -2 -1  0  1  2  3
                */
                // '1' and '0' on one route and '2' and '3' on another.
                // add the endpoints before and after

<span class="fc" id="L2489">                routes = new ZigZagSegmentRoutes();</span>

<span class="fc" id="L2491">                routes.ep0 = findClosestTo(segment.p3, endPoints);</span>
<span class="fc" id="L2492">                routes.route0.add(routes.ep0);</span>
<span class="fc" id="L2493">                routes.route0.add(segment.p3);</span>
<span class="fc" id="L2494">                routes.route0.add(segment.p2);</span>
<span class="fc" id="L2495">                routes.ep0End = findClosestTo(segment.p2, endPoints);</span>
<span class="fc" id="L2496">                routes.route0.add(routes.ep0End);</span>

<span class="fc" id="L2498">                routes.ep1 = findClosestTo(segment.p1, endPoints);</span>
<span class="fc" id="L2499">                routes.route1.add(routes.ep1);</span>
<span class="fc" id="L2500">                routes.route1.add(segment.p1);</span>
<span class="fc" id="L2501">                routes.route1.add(segment.p0);</span>
<span class="fc" id="L2502">                routes.ep1End = findClosestTo(segment.p0, endPoints);</span>
<span class="fc" id="L2503">                routes.route1.add(routes.ep1End);</span>

            } else {

                /*
                    E1end    E0
                              .         -2
                        1  -  2  -      -1
                        -  0  -  3       0
                        E1 .    E0end    1
                                         2
                 -3 -2 -1  0  1  2  3
                */
                // '1' and '0' on one route and '2' and '3' on another.
                // add the endpoints before and after

<span class="fc" id="L2519">                routes = new ZigZagSegmentRoutes();</span>

<span class="fc" id="L2521">                routes.ep0 = findClosestTo(segment.p2, endPoints);</span>
<span class="fc" id="L2522">                routes.route0.add(routes.ep0);</span>
<span class="fc" id="L2523">                routes.route0.add(segment.p2);</span>
<span class="fc" id="L2524">                routes.route0.add(segment.p3);</span>
<span class="fc" id="L2525">                routes.ep0End = findClosestTo(segment.p3, endPoints);</span>
<span class="fc" id="L2526">                routes.route0.add(routes.ep0End);</span>

<span class="fc" id="L2528">                routes.ep1 = findClosestTo(segment.p0, endPoints);</span>
<span class="fc" id="L2529">                routes.route1.add(routes.ep1);</span>
<span class="fc" id="L2530">                routes.route1.add(segment.p0);</span>
<span class="fc" id="L2531">                routes.route1.add(segment.p1);</span>
<span class="fc" id="L2532">                routes.ep1End = findClosestTo(segment.p1, endPoints);</span>
<span class="fc" id="L2533">                routes.route1.add(routes.ep1End);</span>
            }
        }

<span class="fc" id="L2537">        return routes;</span>
    }

    private ZigZagSegmentRoutes parseDiagZigZag(Segment segment, Set&lt;PairInt&gt; endPoints) {

<span class="pc bpc" id="L2542" title="1 of 4 branches missed.">        if (!(segment instanceof DiagZigZagSegment) &amp;&amp;</span>
            !(segment instanceof DiagZigZagSegment2)) {
<span class="nc" id="L2544">            throw new IllegalArgumentException(</span>
            &quot;segment type must be DiagZigZagSegment or DiagZigZagSegment2&quot;);
        }

<span class="pc bpc" id="L2548" title="1 of 2 branches missed.">        if (endPoints.size() != 4) {</span>
<span class="nc" id="L2549">            throw new IllegalStateException(&quot;endPoints must be size 4&quot;);</span>
        }

<span class="fc" id="L2552">        Set&lt;PairInt&gt; cpEndPoints = new HashSet&lt;PairInt&gt;(endPoints);</span>

<span class="fc" id="L2554">        ZigZagSegmentRoutes routes = null;</span>

        /*  first pattern is shown.  The others are consistent w/ different
        locations.
                      E0           -2
              E1end 3  1  -        -1
                    -  0  2  E0end  0
                      E1  -         1

             -3 -2 -1  0  1
        */

        // '1' and '2' on one route and '0' and '3' on another.
        // add the endpoints before and after

<span class="fc" id="L2569">        routes = new ZigZagSegmentRoutes();</span>

<span class="fc" id="L2571">        routes.ep1 = findClosestTo(segment.p0, cpEndPoints);</span>
<span class="fc" id="L2572">        routes.route1.add(routes.ep1);</span>
<span class="fc" id="L2573">        routes.route1.add(segment.p0);</span>
<span class="fc" id="L2574">        routes.route1.add(segment.p3);</span>
<span class="fc" id="L2575">        cpEndPoints.remove(routes.ep1);</span>
<span class="fc" id="L2576">        routes.ep1End = findClosestTo(segment.p3, cpEndPoints);</span>
<span class="fc" id="L2577">        routes.route1.add(routes.ep1End);</span>

<span class="fc" id="L2579">        routes.ep0 = findClosestTo(segment.p1, cpEndPoints);</span>
<span class="fc" id="L2580">        routes.route0.add(routes.ep0);</span>
<span class="fc" id="L2581">        routes.route0.add(segment.p1);</span>
<span class="fc" id="L2582">        routes.route0.add(segment.p2);</span>
<span class="fc" id="L2583">        cpEndPoints.remove(routes.ep0);</span>
<span class="fc" id="L2584">        routes.ep0End = findClosestTo(segment.p2, cpEndPoints);</span>
<span class="fc" id="L2585">        routes.route0.add(routes.ep0End);</span>

<span class="fc" id="L2587">        return routes;</span>
    }

    private PairInt findClosestTo(PairInt p0, Set&lt;PairInt&gt; points) {

<span class="fc" id="L2592">        PairInt pt = null;</span>
<span class="fc" id="L2593">        int minDistSq = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L2594" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L2595">            int distSq = distSq(p, p0);</span>
<span class="fc bfc" id="L2596" title="All 2 branches covered.">            if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L2597">                minDistSq = distSq;</span>
<span class="fc" id="L2598">                pt = p;</span>
            }
<span class="fc" id="L2600">        }</span>

<span class="fc" id="L2602">        return pt;</span>
    }

    private void setNullEndpoints(Routes routes) {

<span class="pc bpc" id="L2607" title="1 of 2 branches missed.">        if (!routes.getRoute0().isEmpty()) {</span>
<span class="fc bfc" id="L2608" title="All 2 branches covered.">            if (routes.getEP0() == null) {</span>
<span class="fc" id="L2609">                routes.ep0 = routes.getRoute0().iterator().next();</span>
            }
<span class="pc bpc" id="L2611" title="1 of 2 branches missed.">            if (routes.getEP0End() == null) {</span>
<span class="nc" id="L2612">                PairInt[] a = getFirstAndLast(routes.getRoute0().iterator());</span>
<span class="nc" id="L2613">                routes.ep0End = a[1];</span>
            }
        }

<span class="pc bpc" id="L2617" title="1 of 2 branches missed.">        if (!routes.getRoute1().isEmpty()) {</span>
<span class="pc bpc" id="L2618" title="1 of 2 branches missed.">            if (routes.getEP1() == null) {</span>
<span class="nc" id="L2619">                routes.ep1 = routes.getRoute1().iterator().next();</span>
            }
<span class="fc bfc" id="L2621" title="All 2 branches covered.">            if (routes.getEP1End() == null) {</span>
<span class="fc" id="L2622">                PairInt[] a = getFirstAndLast(routes.getRoute1().iterator());</span>
<span class="fc" id="L2623">                routes.ep1End = a[1];</span>
            }
        }
<span class="fc" id="L2626">    }</span>

    private void setNullEndpoints(List&lt;Routes&gt; routesList) {

<span class="fc bfc" id="L2630" title="All 2 branches covered.">        for (Routes routes : routesList) {</span>
<span class="fc" id="L2631">            setNullEndpoints(routes);</span>
<span class="fc" id="L2632">        }</span>
<span class="fc" id="L2633">    }</span>

    private Segment checkDiagZigZagSegmentPattern(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L2637">        Pattern pattern = getDiagZigZagSegmentPattern();</span>

<span class="fc" id="L2639">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
        3, 0 are one route and 2, 1 are the other
                -            -2
                3  1  -      -1
                -  0  2       0
                      -       1

         -3 -2 -1  0  1
        */
<span class="fc bfc" id="L2650" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L2651">            DiagZigZagSegment segment = new DiagZigZagSegment();</span>
<span class="fc" id="L2652">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L2653">            segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L2654">            segment.p2 = new PairInt(x + 1, y);</span>
<span class="fc" id="L2655">            segment.p3 = new PairInt(x - 1, y - 1);</span>

<span class="fc" id="L2657">            return segment;</span>
        }

<span class="fc" id="L2660">        swapXDirection(pattern);</span>

<span class="fc" id="L2662">        matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
        3, 0 are one route and 2, 1 are the other
                      -      -2
                -  1  3      -1
                2  0  -       0
                -             1

         -3 -2 -1  0  1
        */
<span class="fc bfc" id="L2673" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L2674">            DiagZigZagSegment segment = new DiagZigZagSegment();</span>
<span class="fc" id="L2675">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L2676">            segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L2677">            segment.p2 = new PairInt(x - 1, y);</span>
<span class="fc" id="L2678">            segment.p3 = new PairInt(x + 1, y - 1);</span>

<span class="fc" id="L2680">            return segment;</span>
        }

<span class="fc" id="L2683">        return null;</span>
    }

    private Segment checkDiagZigZag2SegmentPattern(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L2688">        Pattern pattern = getDiagZigZag2SegmentPattern();</span>

<span class="fc" id="L2690">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
        3, 0 are one route and 2, 1 are the other
                             -2
                   -  3  -   -1
                   0  1       0
                -  2  -       1

         -3 -2 -1  0  1  2
        */
<span class="fc bfc" id="L2701" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L2702">            DiagZigZagSegment2 segment = new DiagZigZagSegment2();</span>
<span class="fc" id="L2703">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L2704">            segment.p1 = new PairInt(x + 1, y);</span>
<span class="fc" id="L2705">            segment.p2 = new PairInt(x, y + 1);</span>
<span class="fc" id="L2706">            segment.p3 = new PairInt(x + 1, y - 1);</span>

<span class="fc" id="L2708">            return segment;</span>
        }

<span class="fc" id="L2711">        swapYDirection(pattern);</span>

<span class="fc" id="L2713">        matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
        3, 0 are one route and 2, 1 are the other
                             -2
                -  2  -      -1
                   0  1       0
                   -  3  -    1

         -3 -2 -1  0  1  2
        */
<span class="fc bfc" id="L2724" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L2725">            DiagZigZagSegment2 segment = new DiagZigZagSegment2();</span>
<span class="fc" id="L2726">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L2727">            segment.p1 = new PairInt(x + 1, y);</span>
<span class="fc" id="L2728">            segment.p2 = new PairInt(x, y - 1);</span>
<span class="fc" id="L2729">            segment.p3 = new PairInt(x + 1, y + 1);</span>

<span class="fc" id="L2731">            return segment;</span>
        }

<span class="fc" id="L2734">        return null;</span>
    }

    /*
    may change these classes to have ordered points or to specify the
    indexes of points that are the connections, that is the '.'s in sketches
    below.
    */
    public static class Segment {
        // the 4 points matching the segment as 0, 1, 2, 3 in the subclasses
        PairInt p0;
        PairInt p1;
        PairInt p2;
        PairInt p3;
        boolean contains(PairInt p) {
            if (p0.equals(p)) {
                return true;
            } else if (p1.equals(p)) {
                return true;
            } else if (p2.equals(p)) {
                return true;
            } else if (p3.equals(p)) {
                return true;
            }
            return false;
        }
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;p0=&quot;).append(p0.toString())
                .append(&quot; p1=&quot;).append(p1.toString())
                .append(&quot; p2=&quot;).append(p2.toString())
                .append(&quot; p3=&quot;).append(p3.toString());
            return sb.toString();
        }
        public void filterOutContaining(Set&lt;PairInt&gt; points) {
            points.remove(p0);
            points.remove(p1);
            points.remove(p2);
            points.remove(p3);
        }
    }

    public static class VertSegment extends Segment {
    }
    public static class HorizSegment extends Segment {
    }
    public static class DiagSegment extends Segment {
    }
    public static class UUDiagSegment extends DiagSegment {
    }
    public static class ULDiagSegment extends DiagSegment {
    }
    public static class ZigZagSegment extends Segment {
    }
    public static class ZigZagSegment2 extends Segment {
    }
    public static class DiagZigZagSegment extends Segment {
    }
    public static class DiagZigZagSegment2 extends Segment {
    }

    public static class Pattern {
        Set&lt;PairInt&gt; ones;
        Set&lt;PairInt&gt; zeroes;
        /*
        an endpoint in route0.  can be null
        */
        PairInt ep0 = null;
        /*
        an endpoint in route1.  can be null
        */
        PairInt ep1 = null;
    }

    protected Pattern getVertSegmentPattern() {

        /*    .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
              .  .       1
          -2 -1  0  1
        */
<span class="fc" id="L2817">        Pattern pr = new Pattern();</span>
<span class="fc" id="L2818">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2819">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2821">        pr.zeroes.add(new PairInt(-2, 0)); pr.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L2822">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -1));</span>

<span class="fc" id="L2824">        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L2825">        pr.ones.add(new PairInt(0, -1));</span>

<span class="fc" id="L2827">        return pr;</span>
    }

    protected Pattern getUUDiagSegmentPattern() {

        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
         -3 -2 -1  0  1
        */
<span class="fc" id="L2838">        Pattern pr = new Pattern();</span>
<span class="fc" id="L2839">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2840">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2842">        pr.zeroes.add(new PairInt(-3, 0)); pr.zeroes.add(new PairInt(-3, -1));</span>
<span class="fc" id="L2843">        pr.zeroes.add(new PairInt(-2, 1)); pr.zeroes.add(new PairInt(-2, 0));</span>
<span class="fc" id="L2844">        pr.zeroes.add(new PairInt(-1, 1)); pr.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L2845">        pr.zeroes.add(new PairInt(0, -1)); pr.zeroes.add(new PairInt(0, -2));</span>
<span class="fc" id="L2846">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -1));</span>

<span class="fc" id="L2848">        pr.ones.add(new PairInt(-2, -1));</span>
<span class="fc" id="L2849">        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));</span>

<span class="fc" id="L2851">        return pr;</span>
    }

    protected Pattern getZigZagSegmentPattern() {

        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
                   -  3       1

         -3 -2 -1  0  1

        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
<span class="fc" id="L2868">        Pattern pr = new Pattern();</span>
<span class="fc" id="L2869">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2870">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2872">        pr.zeroes.add(new PairInt(0, 1)); pr.zeroes.add(new PairInt(0, -1));</span>
<span class="fc" id="L2873">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -2));</span>

<span class="fc" id="L2875">        pr.ones.add(new PairInt(0, -2));</span>
<span class="fc" id="L2876">        pr.ones.add(new PairInt(1, 1)); pr.ones.add(new PairInt(1, -1));</span>

<span class="fc" id="L2878">        return pr;</span>
    }

    protected Pattern getZigZag2SegmentPattern() {

        /*
                   .            -1
                -  0  -  3       0
                1  -  2  -       1
                      .          2
         -3 -2 -1  0  1  2  3

        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
<span class="fc" id="L2894">        Pattern pr = new Pattern();</span>
<span class="fc" id="L2895">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2896">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2898">        pr.zeroes.add(new PairInt(-1, 0));</span>
<span class="fc" id="L2899">        pr.zeroes.add(new PairInt(0, 1));</span>
<span class="fc" id="L2900">        pr.zeroes.add(new PairInt(1, 0));</span>
<span class="fc" id="L2901">        pr.zeroes.add(new PairInt(2, 1));</span>

<span class="fc" id="L2903">        pr.ones.add(new PairInt(-1, 1));</span>
<span class="fc" id="L2904">        pr.ones.add(new PairInt(0, 0)); pr.ones.add(new PairInt(0, -1));</span>
<span class="fc" id="L2905">        pr.ones.add(new PairInt(1, 1)); pr.ones.add(new PairInt(1, 2));</span>
<span class="fc" id="L2906">        pr.ones.add(new PairInt(2, 0));</span>

<span class="fc" id="L2908">        return pr;</span>
    }

    protected Pattern getDiagZigZagSegmentPattern() {

        /*
        3, 0 are one route and 2, 1 are the other
                -            -2
                3  1  -      -1
                -  0  2       0
                      -       1

         -3 -2 -1  0  1

        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
<span class="fc" id="L2926">        Pattern pr = new Pattern();</span>
<span class="fc" id="L2927">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2928">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2930">        pr.zeroes.add(new PairInt(-1, 0)); pr.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L2931">        pr.zeroes.add(new PairInt(1, 1)); pr.zeroes.add(new PairInt(1, -1));</span>

<span class="fc" id="L2933">        pr.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L2934">        pr.ones.add(new PairInt(0, -1));</span>
<span class="fc" id="L2935">        pr.ones.add(new PairInt(1, 0));</span>

<span class="fc" id="L2937">        return pr;</span>
    }

    protected Pattern getDiagZigZag2SegmentPattern() {

        /*
        3, 0 are one route and 2, 1 are the other
                             -2
                   -  3  -   -1
                   0  1       0
                -  2  -       1

         -3 -2 -1  0  1  2

        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
<span class="fc" id="L2955">        Pattern pr = new Pattern();</span>
<span class="fc" id="L2956">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2957">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2959">        pr.zeroes.add(new PairInt(-1, 1));</span>
<span class="fc" id="L2960">        pr.zeroes.add(new PairInt(0, -1));</span>
<span class="fc" id="L2961">        pr.zeroes.add(new PairInt(1, 1));</span>
<span class="fc" id="L2962">        pr.zeroes.add(new PairInt(2, -1));</span>

<span class="fc" id="L2964">        pr.ones.add(new PairInt(0, 1));</span>
<span class="fc" id="L2965">        pr.ones.add(new PairInt(1, 0));  pr.ones.add(new PairInt(1, -1));</span>

<span class="fc" id="L2967">        return pr;</span>
    }

    private Segment checkVertHorizSegmentPattern(int x, int y,
        Set&lt;PairInt&gt; neighbors, boolean useVertical) {

        /*
            VertSegment         swapY VertSegment
              .  .      -2
           -  2  1  -   -1         .  .      -1
           -  3  0  -    0      -  3  0  -    0
              .  .       1      -  2  1  -    1
                                   .  .       2
          -2 -1  0  1          -2 -1  0  1

            HorizSegment        swap HorizSegment
                 -  -     -2       -  -      -2
              .  3  2  .  -1    .  2  3  .   -1
              .  0  1  .   0    .  1  0  .    0
                 -  -      1       -  -       1
             -1  0  1  2       -2 -1  0  1
        */

<span class="fc" id="L2990">        Pattern pattern = getVertSegmentPattern();</span>

<span class="fc bfc" id="L2992" title="All 2 branches covered.">        if (!useVertical) {</span>
<span class="fc" id="L2993">            rotatePattern(pattern, -0.5*Math.PI);</span>
        }

<span class="fc" id="L2996">        boolean matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>

<span class="fc bfc" id="L2998" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc bfc" id="L2999" title="All 2 branches covered.">            if (useVertical) {</span>
<span class="fc" id="L3000">                VertSegment segment = new VertSegment();</span>
<span class="fc" id="L3001">                segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3002">                segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L3003">                segment.p2 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L3004">                segment.p3 = new PairInt(x - 1, y);</span>
<span class="fc" id="L3005">                return segment;</span>
            } else {
<span class="fc" id="L3007">                HorizSegment segment = new HorizSegment();</span>
<span class="fc" id="L3008">                segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3009">                segment.p1 = new PairInt(x + 1, y);</span>
<span class="fc" id="L3010">                segment.p2 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L3011">                segment.p3 = new PairInt(x, y - 1);</span>
<span class="fc" id="L3012">                return segment;</span>
            }
        }

<span class="fc bfc" id="L3016" title="All 2 branches covered.">        if (useVertical) {</span>
<span class="fc" id="L3017">            swapYDirection(pattern);</span>
        } else {
<span class="fc" id="L3019">            pattern = getVertSegmentPattern();</span>
<span class="fc" id="L3020">            swapYDirection(pattern);</span>
<span class="fc" id="L3021">            rotatePattern(pattern, -0.5*Math.PI);</span>
        }

<span class="fc" id="L3024">        matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>

<span class="fc bfc" id="L3026" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc bfc" id="L3027" title="All 2 branches covered.">            if (useVertical) {</span>
<span class="fc" id="L3028">                VertSegment segment = new VertSegment();</span>
<span class="fc" id="L3029">                segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3030">                segment.p1 = new PairInt(x, y + 1);</span>
<span class="fc" id="L3031">                segment.p2 = new PairInt(x - 1, y + 1);</span>
<span class="fc" id="L3032">                segment.p3 = new PairInt(x - 1, y);</span>
<span class="fc" id="L3033">                return segment;</span>
            } else {
<span class="fc" id="L3035">                HorizSegment segment = new HorizSegment();</span>
<span class="fc" id="L3036">                segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3037">                segment.p1 = new PairInt(x - 1, y);</span>
<span class="fc" id="L3038">                segment.p2 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L3039">                segment.p3 = new PairInt(x, y - 1);</span>
<span class="fc" id="L3040">                return segment;</span>
            }
        }

<span class="fc" id="L3044">        return null;</span>
    }

    private Segment checkDiagSegmentPattern(int x, int y, Set&lt;PairInt&gt; neighbors) {

<span class="fc" id="L3049">        Pattern pattern = getUUDiagSegmentPattern();</span>

<span class="fc" id="L3051">        boolean matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>

        /*      -  -      -2
          -  2  1  -  -   -1
          -  -  3  0  -    0
             -  -          1
         -3 -2 -1  0  1
        */
<span class="pc bpc" id="L3059" title="1 of 2 branches missed.">        if (matchesPattern) {</span>
<span class="nc" id="L3060">            UUDiagSegment segment = new UUDiagSegment();</span>
<span class="nc" id="L3061">            segment.p0 = new PairInt(x, y);</span>
<span class="nc" id="L3062">            segment.p1 = new PairInt(x - 1, y - 1);</span>
<span class="nc" id="L3063">            segment.p2 = new PairInt(x - 2, y - 1);</span>
<span class="nc" id="L3064">            segment.p3 = new PairInt(x - 1, y);</span>

<span class="nc" id="L3066">            return segment;</span>
        }

<span class="fc" id="L3069">        rotatePattern(pattern, -0.5*Math.PI);</span>

<span class="fc" id="L3071">        matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>

        /*
                      2         -2
                   3  1         -1
                   0             0
                                 1
         -3 -2 -1  0  1  2  3
        */
<span class="pc bpc" id="L3080" title="1 of 2 branches missed.">        if (matchesPattern) {</span>
<span class="nc" id="L3081">            ULDiagSegment segment = new ULDiagSegment();</span>
<span class="nc" id="L3082">            segment.p0 = new PairInt(x, y);</span>
<span class="nc" id="L3083">            segment.p1 = new PairInt(x + 1, y - 1);</span>
<span class="nc" id="L3084">            segment.p2 = new PairInt(x + 1, y - 2);</span>
<span class="nc" id="L3085">            segment.p3 = new PairInt(x, y - 1);</span>

<span class="nc" id="L3087">            return segment;</span>
        }

<span class="fc" id="L3090">        return null;</span>
    }

    private ZigZagSegment checkZigZagSegmentPattern(int x, int y,
        Set&lt;PairInt&gt; points) {

<span class="fc" id="L3096">        Pattern pattern = getZigZagSegmentPattern();</span>

<span class="fc" id="L3098">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
                   -  3       1

         -3 -2 -1  0  1
        */
<span class="fc bfc" id="L3108" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L3109">            ZigZagSegment segment = new ZigZagSegment();</span>
<span class="fc" id="L3110">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3111">            segment.p1 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L3112">            segment.p2 = new PairInt(x, y - 2);</span>
<span class="fc" id="L3113">            segment.p3 = new PairInt(x + 1, y + 1);</span>

<span class="fc" id="L3115">            return segment;</span>
        }

<span class="fc" id="L3118">        swapXDirection(pattern);</span>

<span class="fc" id="L3120">        matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
                -  2      -2
                1  -      -1
                -  0       0
                3  -       1

         -3 -2 -1  0  1
        */
<span class="fc bfc" id="L3130" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L3131">            ZigZagSegment segment = new ZigZagSegment();</span>
<span class="fc" id="L3132">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3133">            segment.p1 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L3134">            segment.p2 = new PairInt(x, y - 2);</span>
<span class="fc" id="L3135">            segment.p3 = new PairInt(x - 1, y + 1);</span>

<span class="fc" id="L3137">            return segment;</span>
        }

<span class="fc" id="L3140">        return null;</span>
    }

    private ZigZagSegment2 checkZigZag2SegmentPattern(int x, int y,
        Set&lt;PairInt&gt; points) {

<span class="fc" id="L3146">        Pattern pattern = getZigZag2SegmentPattern();</span>

<span class="fc" id="L3148">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
                   .            -1
                -  0  -  3       0
                1  -  2  -       1
                      .          2
         -3 -2 -1  0  1  2  3
        */
<span class="fc bfc" id="L3157" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L3158">            ZigZagSegment2 segment = new ZigZagSegment2();</span>
<span class="fc" id="L3159">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3160">            segment.p1 = new PairInt(x - 1, y + 1);</span>
<span class="fc" id="L3161">            segment.p2 = new PairInt(x + 1, y + 1);</span>
<span class="fc" id="L3162">            segment.p3 = new PairInt(x + 2, y);</span>

<span class="fc" id="L3164">            return segment;</span>
        }

<span class="fc" id="L3167">        swapYDirection(pattern);</span>

<span class="fc" id="L3169">        matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*            .         -2
                1  -  2  -      -1
                -  0  -  3       0
                   .             1
                                 2
         -3 -2 -1  0  1  2  3
        */
<span class="fc bfc" id="L3178" title="All 2 branches covered.">        if (matchesPattern) {</span>
<span class="fc" id="L3179">            ZigZagSegment2 segment = new ZigZagSegment2();</span>
<span class="fc" id="L3180">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L3181">            segment.p1 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L3182">            segment.p2 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L3183">            segment.p3 = new PairInt(x + 2, y);</span>

<span class="fc" id="L3185">            return segment;</span>
        }

<span class="fc" id="L3188">        return null;</span>
    }
    
    protected int distSq(PairInt p0, PairInt p1) {
<span class="fc" id="L3192">        int diffX = p0.getX() - p1.getX();</span>
<span class="fc" id="L3193">        int diffY = p0.getY() - p1.getY();</span>
<span class="fc" id="L3194">        int distSq = (diffX * diffX) + (diffY * diffY);</span>
<span class="fc" id="L3195">        return distSq;</span>
    }

    private boolean matchesPattern(final int x, final int y, Set&lt;PairInt&gt; neighbors,
        Pattern pattern) {

<span class="fc bfc" id="L3201" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L3202">            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());</span>
<span class="fc bfc" id="L3203" title="All 2 branches covered.">            if (neighbors.contains(p2)) {</span>
<span class="fc" id="L3204">                return false;</span>
            }
<span class="fc" id="L3206">        }</span>
<span class="fc bfc" id="L3207" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L3208">            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());</span>
<span class="fc bfc" id="L3209" title="All 2 branches covered.">            if (!neighbors.contains(p2)) {</span>
<span class="fc" id="L3210">                return false;</span>
            }
<span class="fc" id="L3212">        }</span>
<span class="fc" id="L3213">        return true;</span>
    }

    /**
     * route0 and route1 are the two routes in opposite directions for a section
     * in a closed curve with a junction. route0 and route1 do not cross and are
     * populated to help populate the curve so that the points are traversed in
     * opposite directions.
     */
    public static class Routes {
        PairInt ep0 = null;
        PairInt ep1 = null;
        PairInt ep0End = null;
        PairInt ep1End = null;
        //route0, route1 need to be searchable but ordered.
        LinkedHashSet&lt;PairInt&gt; route0 = new LinkedHashSet&lt;PairInt&gt;();
        LinkedHashSet&lt;PairInt&gt; route1 = new LinkedHashSet&lt;PairInt&gt;();
        public LinkedHashSet&lt;PairInt&gt; getRoute0() {
            return route0;
        }
        public LinkedHashSet&lt;PairInt&gt; getRoute1() {
            return route1;
        }
        public PairInt getEP0() {
            return ep0;
        }
        public PairInt getEP0End() {
            return ep0End;
        }
        public PairInt getEP1() {
            return ep1;
        }
        public PairInt getEP1End() {
            return ep1End;
        }
        public void applyOffsets(final int xOffset, final int yOffset) {
            if (ep0 != null) {
                ep0 = new PairInt(ep0.getX() + xOffset, ep0.getY() + yOffset);
            }
            if (ep0End != null) {
                ep0End = new PairInt(ep0End.getX() + xOffset, ep0End.getY() + yOffset);
            }
            if (ep1 != null) {
                ep1 = new PairInt(ep1.getX() + xOffset, ep1.getY() + yOffset);
            }
            if (ep1End != null) {
                ep1End = new PairInt(ep1End.getX() + xOffset, ep1End.getY() + yOffset);
            }

            LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();
            Iterator&lt;PairInt&gt; iter = this.route0.iterator();
            while (iter.hasNext()) {
                PairInt p = iter.next();
                tmp.add(new PairInt(p.getX() + xOffset, p.getY() + yOffset));
            }
            route0 = tmp;

            tmp = new LinkedHashSet&lt;PairInt&gt;();
            iter = this.route1.iterator();
            while (iter.hasNext()) {
                PairInt p = iter.next();
                tmp.add(new PairInt(p.getX() + xOffset, p.getY() + yOffset));
            }
            route1 = tmp;
        }
    }
    public static class VertSegmentRoutes extends Routes {
    }
    public static class HorizSegmentRoutes extends Routes {
    }
    public static class UUDiagSegmentRoutes extends Routes {
    }
<span class="fc" id="L3285">    public static class ZigZagSegmentRoutes extends Routes {</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
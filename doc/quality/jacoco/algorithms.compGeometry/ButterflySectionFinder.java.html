<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ButterflySectionFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">ButterflySectionFinder.java</span></div><h1>ButterflySectionFinder.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.misc.Misc;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">public class ButterflySectionFinder {</span>

    /**
     * Find sections of the closed curve that are two pixels wide and separate
     * loops in the curve:
     * &lt;pre&gt;
     * for example:         #  #
     *    #  #  #         #     #
     *  #         #  #  #      #
     *   #   #  # #  #  #  #  #
     * &lt;/pre&gt;
     * These sections are thinned to width of '1' by the line thinner,
     * so need to be restored afterwards or prevented from being removed.
     * @param closedCurve
     * @return list of points that are part of the 2 pixel width patterns in
     * a curve where the curve closes, but is still connected.
     */
    public List&lt;Routes&gt; findButterflySections(PairIntArray closedCurve) {

<span class="fc" id="L40">        Set&lt;PairInt&gt; points = Misc.convert(closedCurve);</span>

<span class="fc" id="L42">        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();</span>

<span class="fc" id="L44">        List&lt;Routes&gt; sections = findButterflySectionsLarge(closedCurve,</span>
            points);

<span class="fc bfc" id="L47" title="All 4 branches covered.">        if (sections != null &amp;&amp; !sections.isEmpty()) {</span>
<span class="fc" id="L48">            output.addAll(sections);</span>
        }

<span class="fc" id="L51">        List&lt;Routes&gt; sectionsSmall = findButterflySectionsSmall(closedCurve,</span>
            points);

<span class="pc bpc" id="L54" title="1 of 4 branches missed.">        if (sectionsSmall != null &amp;&amp; !sectionsSmall.isEmpty()) {</span>
<span class="fc" id="L55">            output.addAll(sectionsSmall);</span>
        }

<span class="fc" id="L58">        setNullEndpoints(output);</span>

<span class="fc" id="L60">        return output;</span>
    }

     /**
     * Find sections of the closed curve that are two pixels wide and separate
     * loops in the curve:
     * &lt;pre&gt;
     * for example:         #  #
     *    #  #  #         #     #
     *  #         #  #  #      #
     *   #   #  # #  #  #  #  #
     * &lt;/pre&gt;
     * These sections are thinned to width of '1' by the line thinner,
     * so need to be restored afterwards or prevented from being removed.
     * @param closedCurve
     * @param points
     * @return list of points that are part of the 2 pixel width patterns in
     * a curve where the curve closes, but is still connected.
     */
    protected List&lt;Routes&gt; findButterflySectionsLarge(PairIntArray
        closedCurve, Set&lt;PairInt&gt; points) {

<span class="fc" id="L82">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L84">        List&lt;LinkedList&lt;Segment&gt;&gt; candidateSections = new ArrayList&lt;LinkedList&lt;Segment&gt;&gt;();</span>

<span class="fc" id="L86">        LinkedList&lt;Segment&gt; currentList = null;</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); ++i) {</span>

<span class="fc" id="L90">            int x = closedCurve.getX(i);</span>
<span class="fc" id="L91">            int y = closedCurve.getY(i);</span>

<span class="fc" id="L93">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);</span>

            // 3 for large diagonal patterns, else 4 or 5
<span class="fc bfc" id="L96" title="All 4 branches covered.">            if ((neighbors.size() &lt; 3) || (neighbors.size() &gt; 5)) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">                if (currentList != null) {</span>
<span class="fc" id="L98">                    candidateSections.add(currentList);</span>
<span class="fc" id="L99">                    currentList = null;</span>
                }
                continue;
            }

<span class="fc" id="L104">            Segment segment = checkSegmentPatterns(x, y, points, neighbors);</span>

            // cannot have a segment touching the image boundaries, though
            // that may need to change
<span class="fc bfc" id="L108" title="All 4 branches covered.">            if ((segment != null) &amp;&amp; isOnImageBoundaries(segment)) {</span>
<span class="fc" id="L109">                segment = null;</span>
            }
            
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (segment == null) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                Segment[] wSegments = checkWideDiagSegments(x, y, points);</span>
<span class="fc" id="L114">                if (wSegments != null) {</span>
<span class="fc" id="L115">                    assert(wSegments.length == 2);</span>
                    assert(wSegments[0] != null);
                    assert(wSegments[1] != null);
                    boolean[] alreadyAdded = new boolean[2];
                    if (currentList != null) {
<span class="fc bfc" id="L120" title="All 2 branches covered.">                        for (int ii = 0; ii &lt; 2; ++ii) {</span>
<span class="fc" id="L121">                        if (currentList.contains(wSegments[ii])) {</span>
                            alreadyAdded[ii] = true;
                        }
<span class="fc" id="L124">                    }</span>
                    -- check recent if any segments in candidateSections
                       are the same as each added section before adding it:
<span class="fc bfc" id="L127" title="All 2 branches covered.">                       -- add each segment to candidateSections as a separate</span>
<span class="fc" id="L128">                          list (so that the merge method orders them correctly</span>
                          w.r.t. other segments
                }
<span class="fc bfc" id="L131" title="All 2 branches covered.">            }</span>
<span class="fc" id="L132">            </span>
            if (segment == null) {
                if (currentList != null) {
<span class="fc" id="L135">                    candidateSections.add(currentList);</span>
                    currentList = null;
<span class="fc" id="L137">                }</span>
                continue;
            }
<span class="fc bfc" id="L140" title="All 2 branches covered."></span>
            if (currentList == null) {
<span class="fc" id="L142">                currentList = new LinkedList&lt;Segment&gt;();</span>
            }
<span class="fc bfc" id="L144" title="All 2 branches covered."></span>
<span class="fc" id="L145">            currentList.add(segment);</span>
        }

<span class="fc" id="L148">        if (currentList != null) {</span>
<span class="fc" id="L149">            candidateSections.add(currentList);</span>
        }
<span class="fc" id="L151"></span>
        if (candidateSections.isEmpty()) {
            return null;
        }

        mergeIfAdjacent(candidateSections);
        
        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();

        // -- scan for endpoints --
        for (LinkedList&lt;Segment&gt; section : candidateSections) {

            Routes routes = checkForAdjacentEndpoints(points, section);

            if (routes == null) {
                continue;
            }

            output.add(routes);
        }

        return output;

        /*
        endpoints for vert:
                       #           #
            # .      = - .      -  - .
          - - .  or  - - .  or     # .
            #          #

        endpoints for horiz:
                -        - -       -
              # - #    # - - #   # - #
              . .        . .       . .

        endpoints for diag:

            -  #             -  #               -  #
            -    .        -  -  .            #  -  .
            #  .   .      #  .    .          -  .    .
                 .              .                  .

        The sections of line which are 2 pixels wide and 1 further from the
        endpoint have 3 non-point neighbors each and 5 point set neighbors
        An area limit further constrains the geometry.
        For sections matching the patterns below, could consider storing
        the pattern for each pix as 'v', 'h', or 'd'...not an apparent use for
        that yet though.

        Segment patterns between endpoints:
                       4
           -  -  -  -  3
           .  #  #  .  2
           .  #  #  .  1
           -  -  -  -  0
        0  1  2  3  4

                        4
           -  .  .  -   3
           -  #  #  -   2
           -  #  #  -   1
           -  .  .  -   0
        0  1  2  3  4

           # # - -   3
           - # # - - 2
           - - # #   1
           - - - - - 0
        0  1 2 3 4 5

        data structures:
           linked lists of found pattern points as segments with
           specialization of each segment as VertSegment, HorizSegment,
              UUdiagsegment, ULdiagsegment



        Scan the line,
           if a point fits one of the 4 segment patterns (4th is diag transformed by x=-x),
           add it to a group and add the remaining pts fitting the pattern to a stack
           -- traverse the stack adding contiguous points to the group that fit the
              pattern.
           -- note where the first point in the pattern started, because
              when there are no more contiguous pattern matching points,
              the scan will continue at the next point after that first,
              but will skip those already added to a group.

        When the scan for groups has finished,
             for each group, need to apply the above endpoint patterns to see
             if the candidate segment is surrounded by 2 endpoints.

             test all candidate group points as adjacent to potential endpoints.

             When a match is found, have to exclude all of the matching pattern
             from the oppossing endpoint tests.

             This is the smallest pattern which will match that suggestion:
              - - - -
            # # @ # #
          - - # @ # -
            # - - - #
             The '@'s are the candidate group points.  The #'s are points
             matching endoint patterns.

             The found endpoints for one end, the left for example, would
             be excluded from a search for matching to the other endpoints.

        Note that this pattern and variants of it as very short sections and
        endpoints should be scanned after the above to find the shortest
        butterfly segments.
              - -
            # # @ #
          - - # @ -
<span class="fc" id="L264">            # - - #</span>

          #
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">            #</span>
<span class="fc" id="L268">              # # #</span>
        # # #
              # # #
<span class="fc" id="L271"></span>
        For each segment group which has 2 matching endpoints, those should
        be stored as butterfly sections in a set.  Each one of those
<span class="fc" id="L274">        should be passed back in a list as the return of this method.</span>

        runtime complexity is linear in the number of points in the given
        closed curve.
        */

<span class="fc" id="L280">    }</span>

<span class="fc" id="L282">    protected List&lt;Routes&gt; findButterflySectionsSmall(PairIntArray</span>
        closedCurve, Set&lt;PairInt&gt; points) {
<span class="fc bfc" id="L284" title="All 2 branches covered."></span>
        List&lt;Routes&gt; routesList = findButterflySectionsSmallZigZag(closedCurve,
<span class="fc" id="L286">            points);</span>
<span class="fc" id="L287"></span>
        if (routesList != null &amp;&amp; !routesList.isEmpty()) {
<span class="fc" id="L289">            return routesList;</span>
        }

<span class="fc bfc" id="L292" title="All 2 branches covered.">        routesList = findButterflySectionsSmallDiagZigZag(closedCurve,</span>
<span class="fc" id="L293">            points);</span>

        return routesList;
<span class="fc" id="L296">    }</span>

<span class="fc bfc" id="L298" title="All 2 branches covered.">    protected List&lt;Routes&gt; findButterflySectionsSmallZigZag(PairIntArray</span>
<span class="fc" id="L299">        closedCurve, Set&lt;PairInt&gt; points) {</span>
<span class="fc bfc" id="L300" title="All 2 branches covered."></span>
<span class="fc" id="L301">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();

        for (int i = 0; i &lt; closedCurve.getN(); ++i) {

            int x = closedCurve.getX(i);
            int y = closedCurve.getY(i);

            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);
<span class="fc" id="L311"></span>
            // scanning for segments
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">            if (neighbors.size() != 3) {</span>
<span class="nc" id="L314">                continue;</span>
            }

<span class="fc" id="L317">            Segment segment = checkZigZagSegmentPattern(x, y, points);</span>

<span class="fc" id="L319">            if (segment == null) {</span>
                segment = checkZigZag2SegmentPattern(x, y, points);
                if (segment == null) {
<span class="fc" id="L322">                    continue;</span>
                }
            }

            /*
            Each of the 4 segment points needs at least one neighbor that is
<span class="fc" id="L328">            not one of the 4 points in the zig zap and all of their neighbors</span>
            cannot be adjacent to any of the other neighbors.
<span class="fc" id="L330">            */</span>

<span class="fc bfc" id="L332" title="All 2 branches covered.">            Set&lt;PairInt&gt; endPoints = checkForZigZagEndPoints(points, segment);</span>

<span class="fc" id="L334">            if (endPoints == null || endPoints.isEmpty()) {</span>
<span class="fc" id="L335">                continue;</span>
            }
<span class="fc" id="L337"></span>
            ZigZagSegmentRoutes routes = parseZigZag(segment, endPoints);

            output.add(routes);
        }
<span class="fc bfc" id="L342" title="All 2 branches covered."></span>
<span class="fc" id="L343">        return output;</span>
    }

<span class="fc" id="L346">    protected List&lt;Routes&gt; findButterflySectionsSmallDiagZigZag(PairIntArray</span>
        closedCurve, Set&lt;PairInt&gt; points) {
<span class="fc bfc" id="L348" title="All 2 branches covered."></span>
<span class="fc" id="L349">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered."></span>
<span class="fc" id="L351">        List&lt;Routes&gt; output = new ArrayList&lt;Routes&gt;();</span>

        for (int i = 0; i &lt; closedCurve.getN(); ++i) {

            int x = closedCurve.getX(i);
            int y = closedCurve.getY(i);

            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(x, y, points);

            //TODO: one point in this pattern has 3 neigbhors, so may need to change this
<span class="fc" id="L361"></span>
            // scanning for segments
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">            if (neighbors.size() != 4) {</span>
<span class="nc" id="L364">                continue;</span>
            }

<span class="fc" id="L367">            Segment segment = checkDiagZigZagSegmentPattern(x, y, points);</span>

<span class="fc" id="L369">            if (segment == null) {</span>
                segment = checkDiagZigZag2SegmentPattern(x, y, points);
                if (segment == null) {
<span class="fc" id="L372">                    continue;</span>
                }
            }

            /*
            Each of the 4 segment points needs at least one neighbor that is
<span class="fc" id="L378">            not one of the 4 points in the zig zap and all of their neighbors</span>
            cannot be adjacent to any of the other neighbors.
<span class="fc" id="L380">            */</span>

<span class="fc bfc" id="L382" title="All 2 branches covered.">            Set&lt;PairInt&gt; endPoints = checkForZigZagEndPoints(points, segment);</span>
<span class="fc" id="L383"></span>
            if (endPoints == null || endPoints.isEmpty()) {
                continue;
<span class="fc" id="L386">            }</span>

<span class="fc" id="L388">            ZigZagSegmentRoutes routes = parseDiagZigZag(segment, endPoints);</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">            output.add(routes);</span>
<span class="fc" id="L391">        }</span>

        return output;
<span class="fc" id="L394">    }</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">    private Segment checkSegmentPatterns(final int x, final int y,</span>
<span class="fc" id="L397">        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; neighbors) {</span>

        boolean useVert = true;
<span class="fc" id="L400"></span>
        Segment segment = checkVertHorizSegmentPattern(x, y, neighbors, useVert);

        if (segment != null) {
            return segment;
<span class="fc bfc" id="L405" title="All 2 branches covered.">        }</span>
<span class="fc" id="L406"></span>
<span class="fc" id="L407">        useVert = false;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered."></span>
<span class="fc" id="L409">        segment = checkVertHorizSegmentPattern(x, y, neighbors, useVert);</span>
<span class="fc" id="L410"></span>
<span class="fc" id="L411">        if (segment != null) {</span>
            return segment;
        }

<span class="fc bfc" id="L415" title="All 2 branches covered.">        segment = checkDiagSegmentPattern(x, y, points, neighbors);</span>
<span class="fc" id="L416"></span>
<span class="fc" id="L417">        if (segment != null) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            return segment;</span>
<span class="fc" id="L419">        }</span>
<span class="fc" id="L420">                </span>
<span class="fc" id="L421">        return null;</span>
    }

    private void swapYDirection(Pattern pattern) {
        // ----- change the sign of y  -----
        for (PairInt p : pattern.zeroes) {
            p.setY(-1 * p.getY());
<span class="fc" id="L428">        }</span>
        for (PairInt p : pattern.ones) {
<span class="fc bfc" id="L430" title="All 2 branches covered.">            p.setY(-1 * p.getY());</span>
        }
<span class="fc bfc" id="L432" title="All 2 branches covered.">    }</span>
<span class="fc" id="L433"></span>
    private void swapXDirection(Pattern pattern) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">        // ----- change the sign of x  -----</span>
        for (PairInt p : pattern.zeroes) {
<span class="fc" id="L437">            p.setX(-1 * p.getX());</span>
        }
<span class="fc" id="L439">        for (PairInt p : pattern.ones) {</span>
            p.setX(-1 * p.getX());
        }
<span class="fc bfc" id="L442" title="All 2 branches covered.">    }</span>

<span class="fc" id="L444">    private Routes checkForAdjacentEndpoints(Set&lt;PairInt&gt; points,</span>
        LinkedList&lt;Segment&gt; section) {
<span class="fc" id="L446"></span>
        // the list of segments was built from a closed curve

<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        Routes routes = null;</span>
        
<span class="fc" id="L451">        for (int i = 0; i &lt; 2; ++i) {</span>
        
            Segment firstOrLastSegment = (i == 0) ? section.getFirst() :
                section.getLast();            
<span class="fc bfc" id="L455" title="All 2 branches covered."></span>
<span class="fc" id="L456">            if (firstOrLastSegment instanceof VertSegment) {</span>

                boolean useVertical = true;
<span class="fc bfc" id="L459" title="All 4 branches covered."></span>
                routes = findEndPointsVertHorizPatterns(points, routes, firstOrLastSegment,
<span class="fc" id="L461">                    useVertical);</span>

<span class="fc bfc" id="L463" title="All 2 branches covered.">            } else if (firstOrLastSegment instanceof HorizSegment) {</span>

<span class="fc" id="L465">                boolean useVertical = false;</span>

                routes = findEndPointsVertHorizPatterns(points, routes, firstOrLastSegment,
<span class="fc" id="L468">                    useVertical);</span>

<span class="fc" id="L470">            } else if (firstOrLastSegment instanceof DiagSegment) {</span>

                routes = findEndPointsDiagPatterns(points, routes,
<span class="pc bpc" id="L473" title="6 of 10 branches missed.">                    (DiagSegment)firstOrLastSegment);</span>
            }

<span class="nc" id="L476">            if (routes == null) {</span>
                return routes;
            }

            if ((i == 0) &amp;&amp; section.size() &gt; 1) {
<span class="fc" id="L481"></span>
                int added = 0;

                for (int ii = 1; ii &lt; section.size(); ++ii) {

                    Segment segment = section.get(ii);
<span class="fc" id="L487"></span>
<span class="fc" id="L488">                    // add node to routes</span>
                    int didAdd = addSegmentToRoutes(routes, segment);
<span class="fc bfc" id="L490" title="All 2 branches covered."></span>
                    added = added | didAdd;
<span class="pc bpc" id="L492" title="1 of 7 branches missed.">                }</span>

<span class="fc" id="L494">                if (!((added == 1) &amp;&amp; (routes.ep0 == null || routes.ep0End == null ||</span>
<span class="fc" id="L495">                    routes.ep1 == null || routes.ep1End == null))) {</span>

<span class="fc" id="L497">                    break;</span>
<span class="fc" id="L498">                }</span>
            }
<span class="fc" id="L500">        }</span>
<span class="fc" id="L501"></span>
        return routes;
<span class="fc" id="L503">    }</span>
<span class="fc" id="L504"></span>
    private Routes findEndPointsVertHorizPatterns(Set&lt;PairInt&gt; points,
<span class="fc" id="L506">        Routes routes, Segment segment, boolean useVert) {</span>
<span class="fc" id="L507"></span>
        int x0 = segment.p0.getX();
<span class="fc" id="L509">        int y0 = segment.p0.getY();</span>
<span class="fc" id="L510"></span>
        for (int i = 0; i &lt; 6; ++i) {
<span class="nc" id="L512">            Pattern pattern;</span>
            switch(i) {
<span class="fc bfc" id="L514" title="All 2 branches covered.">                case 0:</span>
<span class="fc" id="L515">                    pattern = getEndPointsVertPattern1S();</span>
                    break;
<span class="fc" id="L517">                case 1:</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">                    pattern = getEndPointsVertPattern1Opp();</span>
<span class="fc" id="L519">                    break;</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">                case 2:</span>
<span class="fc" id="L521">                    pattern = getEndPointsVertPattern2S();</span>
<span class="fc" id="L522">                    break;</span>
                case 3:
<span class="fc" id="L524">                    pattern = getEndPointsVertPattern2Opp();</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                    break;</span>
<span class="fc" id="L526">                case 4:</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                    pattern = getEndPointsVertPattern3S();</span>
<span class="fc" id="L528">                    break;</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                case 5:</span>
<span class="nc" id="L530">                    pattern = getEndPointsVertPattern3Opp();</span>
                    break;
<span class="fc bfc" id="L532" title="All 2 branches covered.">                default:</span>
<span class="fc" id="L533">                    return null;</span>
<span class="fc" id="L534">            }</span>
            if (!useVert) {
<span class="fc" id="L536">                rotatePattern(pattern, -0.5*Math.PI);</span>
<span class="fc" id="L537">            }</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">            boolean found = true;</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">            for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L540">                PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
                if (points.contains(p2)) {
<span class="fc bfc" id="L542" title="All 2 branches covered.">                    found = false;</span>
<span class="fc" id="L543">                    break;</span>
                }
<span class="fc bfc" id="L545" title="All 2 branches covered.">            }</span>
<span class="fc" id="L546">            if (found) {</span>
                Set&lt;PairInt&gt; endPoints = new HashSet&lt;PairInt&gt;();
<span class="fc" id="L548">                for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L549">                    PairInt p2 = new PairInt(x0 + p.getX(), y0 + p.getY());</span>
                    if (segment.contains(p2)) {
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                        continue;</span>
<span class="nc" id="L552">                    }</span>
                    if (!points.contains(p2)) {
                        found = false;
<span class="fc" id="L555">                        break;</span>
                    }
                    endPoints.add(p2);
                }
<span class="fc" id="L559">                if (found) {</span>
                    if (routes == null) {
                        routes = createRoute(segment, x0, y0);
                    }
                    if ((i &amp; 1) == 0) {
                        int added = addEndpointsForHorizVertPatternForward(
                            x0, y0, pattern, routes, endPoints, useVert);
                        if (added == 0) {
                            routes = null;
                        }
                    } else {
                        int added = addEndpointsForHorizVertPatternOppos(x0, y0,
                            pattern, routes, endPoints, useVert);
                        if (added == 0) {
                            routes = null;
<span class="fc" id="L574">                        }</span>
<span class="fc" id="L575">                    }</span>
<span class="fc" id="L576">                    break;</span>
                }
            }
<span class="fc" id="L579">        }</span>
<span class="fc" id="L580">        return routes;</span>
<span class="fc" id="L581">    }</span>
<span class="fc" id="L582"></span>
<span class="fc" id="L583">    private Pattern getEndPointsVertPattern1S() {</span>
<span class="fc" id="L584">        /* the pattern returned is relative to</span>
<span class="fc" id="L585">        position '0', just like the other patterns.</span>

<span class="fc" id="L587">        searching for .'s and #'s</span>
<span class="fc" id="L588">                        -2</span>
<span class="fc" id="L589">           -  2  1  -   -1</span>
<span class="fc" id="L590">           -  3  0  -    0</span>
              #  -  #    1
                 -       2
          -2 -1  0  1
        */
        Pattern pattern = new Pattern();
        pattern.ones = new HashSet&lt;PairInt&gt;();
        pattern.zeroes = new HashSet&lt;PairInt&gt;();

        // '#' end points
        PairInt t1 = new PairInt(-1, 1);
        pattern.ones.add(t1);
        PairInt t0 = new PairInt(1, 1);
        pattern.ones.add(t0);
        pattern.ep0 = t0;
        pattern.ones.add(t1);
        pattern.ep1 = t1;
<span class="fc" id="L607"></span>
<span class="fc" id="L608">        pattern.zeroes.add(new PairInt(-2, -1)); pattern.zeroes.add(new PairInt(-2, 0));</span>
<span class="fc" id="L609">        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 1));</span>
        pattern.zeroes.add(new PairInt(1, 0)); pattern.zeroes.add(new PairInt(1, -1));
<span class="fc" id="L611">        return pattern;</span>
<span class="fc" id="L612">    }</span>
<span class="fc" id="L613"></span>
<span class="fc" id="L614">    private Pattern getEndPointsVertPattern1Opp() {</span>
<span class="fc" id="L615">        /* the pattern returned is relative to</span>
<span class="fc" id="L616">        position '0', just like the other patterns.</span>

<span class="fc" id="L618">             R1    R0</span>
<span class="fc" id="L619">             /|\    |</span>
<span class="fc" id="L620">              |    \|/</span>
<span class="fc" id="L621">                 -      -3</span>
              #  -  #   -2
           -  2  1  -   -1
              3  0       0

          -2 -1  0  1
        */
        Pattern pattern = new Pattern();
        pattern.ones = new HashSet&lt;PairInt&gt;();
        pattern.zeroes = new HashSet&lt;PairInt&gt;();

        PairInt t1 = new PairInt(-1, -2);
        pattern.ones.add(t1);
        pattern.ep1 = t1;
        PairInt t0 = new PairInt(1, -2);
        pattern.ones.add(t0);
<span class="fc" id="L637">        pattern.ep0 = t0;</span>
<span class="fc" id="L638"></span>
<span class="fc" id="L639">        pattern.zeroes.add(new PairInt(-2, -1));</span>
        pattern.zeroes.add(new PairInt(0, -2)); pattern.zeroes.add(new PairInt(0, -3));
        pattern.zeroes.add(new PairInt(1, -1));
<span class="fc" id="L642">        return pattern;</span>
<span class="fc" id="L643">    }</span>
<span class="fc" id="L644"></span>
<span class="fc" id="L645">    private Pattern getEndPointsVertPattern2S() {</span>
<span class="fc" id="L646"></span>
<span class="fc" id="L647">        /* the pattern returned is relative to</span>
        position '0', just like the other patterns.
<span class="fc" id="L649"></span>
<span class="fc" id="L650">        searching for .'s and #'s</span>
<span class="fc" id="L651">                        -2</span>
<span class="fc" id="L652">              2  1      -1</span>
           -  3  0  -    0
<span class="fc" id="L654">           #  -  -  #    1</span>
              -  -       2
          -2 -1  0  1
        */
        Pattern pattern = new Pattern();
        pattern.ones = new HashSet&lt;PairInt&gt;();
        pattern.zeroes = new HashSet&lt;PairInt&gt;();

        // '#' end points
        PairInt t1 = new PairInt(-2, 1);
        pattern.ones.add(t1);
        PairInt t0 = new PairInt(1, 1);
        pattern.ones.add(t0);
        pattern.ep1 = t1;
        pattern.ep0 = t0;

        pattern.zeroes.add(new PairInt(-2, 0));
        pattern.zeroes.add(new PairInt(-1, 2)); pattern.zeroes.add(new PairInt(-1, 1));
        pattern.zeroes.add(new PairInt(0, 2)); pattern.zeroes.add(new PairInt(0, 1));
<span class="fc" id="L673">        pattern.zeroes.add(new PairInt(1, 0));</span>
<span class="fc" id="L674">        </span>
<span class="fc" id="L675">        return pattern;</span>
    }

<span class="fc" id="L678">    private Pattern getEndPointsVertPattern2Opp() {</span>
<span class="fc" id="L679"></span>
<span class="fc" id="L680">        /* the pattern returned is relative to</span>
<span class="fc" id="L681">        position '0', just like the other patterns.</span>
<span class="fc" id="L682"></span>
<span class="fc" id="L683">          R1       R0</span>
          /|\       |
<span class="fc" id="L685">           |       \|/</span>
<span class="fc" id="L686">              -  -      -3</span>
<span class="fc" id="L687">           #  -  -  #   -2</span>
<span class="fc" id="L688">           -  2  1  -   -1</span>
<span class="fc" id="L689">              3  0       0</span>

          -2 -1  0  1
        */

        Pattern pattern = new Pattern();
        pattern.ones = new HashSet&lt;PairInt&gt;();
        pattern.zeroes = new HashSet&lt;PairInt&gt;();

        // '#' end points
        PairInt t1 = new PairInt(-2, -2);
        PairInt t0 = new PairInt(1, -2);
        pattern.ones.add(t1);
        pattern.ones.add(t0);
        pattern.ep0 = t0;
        pattern.ep1 = t1;
<span class="fc" id="L705"></span>
<span class="fc" id="L706">        pattern.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L707">        pattern.zeroes.add(new PairInt(-1, -2)); pattern.zeroes.add(new PairInt(-1, -3));</span>
        pattern.zeroes.add(new PairInt(0, -2)); pattern.zeroes.add(new PairInt(0, -3));
<span class="fc" id="L709">        pattern.zeroes.add(new PairInt(1, -1));</span>
<span class="fc" id="L710">        return pattern;</span>
<span class="fc" id="L711">    }</span>
    
    private Pattern getEndPointsVertPattern3S() {
<span class="fc" id="L714"></span>
<span class="fc" id="L715">        /* the pattern returned is relative to</span>
<span class="fc" id="L716">        position '0', just like the other patterns.</span>
<span class="fc" id="L717"></span>
<span class="fc" id="L718">        searching for .'s and #'s</span>
<span class="fc" id="L719">                        -2</span>
           -  2  1  -   -1
<span class="fc" id="L721">           -  3  0  -    0</span>
           #  -  #       1
              -          2
          -2 -1  0  1
        */
        Pattern pattern = new Pattern();
        pattern.ones = new HashSet&lt;PairInt&gt;();
        pattern.zeroes = new HashSet&lt;PairInt&gt;();

        pattern.zeroes.add(new PairInt(-2, -1)); pattern.zeroes.add(new PairInt(-2, 0));
        pattern.zeroes.add(new PairInt(-1, 2)); pattern.zeroes.add(new PairInt(-1, 1));
        pattern.zeroes.add(new PairInt(1, 0)); pattern.zeroes.add(new PairInt(1, -1));

        // '#' end points
        PairInt t1 = new PairInt(-2, 1);
        pattern.ones.add(t1);
        PairInt t0 = new PairInt(0, 1);
        pattern.ones.add(t0);
<span class="fc" id="L739">        pattern.ep1 = t1;</span>
<span class="fc" id="L740">        pattern.ep0 = t0;</span>
<span class="fc" id="L741"></span>
        return pattern;
    }
<span class="fc" id="L744"></span>
<span class="fc" id="L745">    private Pattern getEndPointsVertPattern3Opp() {</span>
<span class="fc" id="L746"></span>
<span class="fc" id="L747">        /* the pattern returned is relative to</span>
<span class="fc" id="L748">        position '0', just like the other patterns.</span>
<span class="fc" id="L749">          R1    R0</span>
          /|\    |
<span class="fc" id="L751">           |    \|/</span>
<span class="fc" id="L752">              -         -3</span>
<span class="fc" id="L753">           #  -  #      -2</span>
           -  2  1  -   -1
<span class="fc" id="L755">              3  0       0</span>

          -2 -1  0  1
        */

        Pattern pattern = new Pattern();
<span class="fc" id="L761">        pattern.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L762">        pattern.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L764" title="All 2 branches covered.">        // '#' end points</span>
        PairInt t1 = new PairInt(-2, -2);
<span class="fc" id="L766">        PairInt t0 = new PairInt(0, -2);</span>
        pattern.ones.add(t1);
<span class="fc bfc" id="L768" title="All 2 branches covered.">        pattern.ones.add(t0);</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">        pattern.ep0 = t0;</span>
<span class="fc" id="L770">        pattern.ep1 = t1;</span>

<span class="fc" id="L772">        pattern.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L773">        pattern.zeroes.add(new PairInt(-1, -2)); pattern.zeroes.add(new PairInt(-1, -3));</span>
<span class="fc" id="L774">        pattern.zeroes.add(new PairInt(1, -1));</span>
<span class="fc" id="L775"></span>
<span class="fc" id="L776">        return pattern;</span>
<span class="fc" id="L777">    }</span>
<span class="fc" id="L778"></span>
<span class="fc" id="L779">    private Routes findEndPointsDiagPatterns(Set&lt;PairInt&gt; points,</span>
        Routes routes, DiagSegment segment) {

<span class="fc" id="L782">        int x0 = segment.p0.getX();</span>
        int y0 = segment.p0.getY();
<span class="fc bfc" id="L784" title="All 2 branches covered.">        </span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">        if (segment instanceof ULDiagSegment) {</span>
<span class="fc" id="L786">            // returns top endpoint of '2', then '1'</span>
            PairInt[] endPoints = findULDiagTopEndpoints(points,
<span class="fc" id="L788">                (ULDiagSegment)segment);</span>
<span class="fc" id="L789">            if (endPoints != null) {</span>
<span class="fc" id="L790">                if (routes == null) {</span>
<span class="fc" id="L791">                    routes = createRoute(segment, x0, y0);</span>
<span class="fc" id="L792">                }</span>
<span class="fc" id="L793">                routes.route1.add(endPoints[0]);</span>
<span class="fc" id="L794">                routes.ep1End = endPoints[0];</span>
<span class="fc" id="L795">                routes.ep0 = endPoints[1];</span>
                LinkedHashSet&lt;PairInt&gt; tmp0 = new LinkedHashSet&lt;PairInt&gt;();
<span class="fc" id="L797">                tmp0.add(endPoints[1]);</span>
                tmp0.addAll(routes.route0);
                routes.route0 = tmp0;
                return routes;
            }
            // returns bottom endpoint of '3', then '0'
<span class="fc" id="L803">            endPoints = findULDiagBottomEndpoints(points,</span>
                (ULDiagSegment)segment);
<span class="fc bfc" id="L805" title="All 2 branches covered.">            if (endPoints != null) {</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">                if (routes == null) {</span>
<span class="fc" id="L807">                    routes = createRoute(segment, x0, y0);</span>
                }
<span class="fc" id="L809">                routes.route0.add(endPoints[1]);</span>
<span class="fc" id="L810">                routes.ep0End = endPoints[1];</span>
<span class="fc" id="L811">                routes.ep1 = endPoints[0];</span>
<span class="fc" id="L812">                LinkedHashSet&lt;PairInt&gt; tmp1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L813">                tmp1.add(endPoints[0]);</span>
<span class="fc" id="L814">                tmp1.addAll(routes.route1);</span>
<span class="fc" id="L815">                routes.route1 = tmp1;</span>
<span class="fc" id="L816">                return routes;</span>
            }
            return routes;
        }
<span class="fc" id="L820">        </span>
        // else is instance of UUDiagSegment
<span class="fc bfc" id="L822" title="All 2 branches covered.">    </span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">        // returns top endpoint of '2', then '1'</span>
<span class="fc" id="L824">        PairInt[] endPoints = findUUDiagTopEndpoints(points, </span>
            (UUDiagSegment)segment);
<span class="fc" id="L826">        if (endPoints != null) {</span>
<span class="fc" id="L827">            if (routes == null) {</span>
<span class="fc" id="L828">                routes = createRoute(segment, x0, y0);</span>
<span class="fc" id="L829">            }</span>
<span class="fc" id="L830">            routes.route1.add(endPoints[0]);</span>
<span class="fc" id="L831">            routes.ep1End = endPoints[0];</span>
<span class="fc" id="L832">            routes.ep0 = endPoints[1];</span>
<span class="fc" id="L833">            LinkedHashSet&lt;PairInt&gt; tmp0 = new LinkedHashSet&lt;PairInt&gt;();</span>
            tmp0.add(endPoints[1]);
            tmp0.addAll(routes.route0);
<span class="fc" id="L836">            routes.route0 = tmp0;</span>
            return routes;
        }
        
        // returns bottom endpoint of '3', then '0'
        endPoints = findUUDiagBottomEndpoints(points,
            (UUDiagSegment)segment);
        if (endPoints != null) {
            if (routes == null) {
                routes = createRoute(segment, x0, y0);
<span class="fc" id="L846">            }</span>
            routes.route0.add(endPoints[1]);
<span class="fc" id="L848">            routes.ep0End = endPoints[1];</span>
            routes.ep1 = endPoints[0];
<span class="fc" id="L850">            LinkedHashSet&lt;PairInt&gt; tmp1 = new LinkedHashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L851">            tmp1.add(endPoints[0]);</span>
<span class="fc" id="L852">            tmp1.addAll(routes.route1);</span>
<span class="fc" id="L853">            routes.route1 = tmp1;</span>
<span class="fc" id="L854">            return routes;</span>
<span class="fc" id="L855">        }</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        </span>
<span class="fc" id="L857">        return routes;</span>
<span class="fc bfc" id="L858" title="All 4 branches covered.">    }</span>

<span class="fc" id="L860">    private Set&lt;PairInt&gt; checkForZigZagEndPoints(Set&lt;PairInt&gt; points,</span>
<span class="fc" id="L861">        Segment segment) {</span>

<span class="fc" id="L863">        /*Each of the 4 needs at least one neighbor that is not one of the 4</span>
<span class="fc" id="L864">        points in the zig zap and all of their neighbors cannot be adjacent</span>
        to any of the other neighbors.*/
<span class="fc" id="L866"></span>
<span class="fc" id="L867">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L869">        Set&lt;Integer&gt; indexesWithMoreThanOneNeighbor = new HashSet&lt;Integer&gt;();</span>

        List&lt;Set&lt;PairInt&gt;&gt; listOfNeighbors = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();
<span class="fc" id="L872">        Set&lt;PairInt&gt; segmentPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L873">        segmentPoints.add(segment.p0);</span>
<span class="fc" id="L874">        segmentPoints.add(segment.p1);</span>
<span class="fc bfc" id="L875" title="All 4 branches covered.">        segmentPoints.add(segment.p2);</span>
<span class="fc" id="L876">        segmentPoints.add(segment.p3);</span>
        for (int i = 0; i &lt; 4; ++i) {
<span class="fc bfc" id="L878" title="All 2 branches covered.">            PairInt p = null;</span>
<span class="fc" id="L879">            switch(i) {</span>
<span class="fc" id="L880">                case 0:</span>
                    p = segment.p0;
<span class="fc" id="L882">                    break;</span>
                case 1:
                    p = segment.p1;
                    break;
                case 2:
                    p = segment.p2;
<span class="fc bfc" id="L888" title="All 2 branches covered.">                    break;</span>
<span class="fc" id="L889">                default:</span>
<span class="fc" id="L890">                    p = segment.p3;</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">                    break;</span>
<span class="fc" id="L892">            }</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(p.getX(),</span>
<span class="fc" id="L894">                p.getY(), points);</span>
            neighbors.removeAll(segmentPoints);
<span class="fc" id="L896">            if (!((neighbors.size() == 1) || (neighbors.size() == 2))) {</span>
<span class="fc" id="L897">                return null;</span>
            }
<span class="fc" id="L899">            if (neighbors.size() &gt; 1) {</span>
                indexesWithMoreThanOneNeighbor.add(
                    Integer.valueOf(listOfNeighbors.size()));
            }
            listOfNeighbors.add(neighbors);
<span class="fc bfc" id="L904" title="All 2 branches covered.">        }</span>
<span class="fc" id="L905"></span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">        /* for this kind of junction, some points share a neighbor.</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">        need to reduce the neighbor lists to unique members</span>
<span class="fc" id="L908">        */</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        for (Integer index : indexesWithMoreThanOneNeighbor) {</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">            int idx = index.intValue();</span>
<span class="fc" id="L911">            Set&lt;PairInt&gt; neighborSet = listOfNeighbors.get(idx);</span>
            for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {
<span class="fc" id="L913">                Integer index2 = Integer.valueOf(i);</span>
                if (indexesWithMoreThanOneNeighbor.contains(index2)) {
<span class="fc" id="L915">                    continue;</span>
                }
                PairInt p2 = listOfNeighbors.get(index2.intValue()).iterator().next();
                neighborSet.remove(p2);
            }
        }

        // assert that each in list has no members adjacent to any other members
        // TODO: could use a data structure that uses spatial indexing to make
        // this faster, but there are not very many points per 4 sets to compare...
<span class="fc" id="L925">        for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">            Set&lt;PairInt&gt; setI = listOfNeighbors.get(i);</span>
<span class="fc" id="L927">            for (PairInt pI : setI) {</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">                for (int j = (i + 1); j &lt; listOfNeighbors.size(); ++j) {</span>
<span class="fc" id="L929">                    Set&lt;PairInt&gt; setJ = listOfNeighbors.get(j);</span>
<span class="fc bfc" id="L930" title="All 4 branches covered.">                    for (PairInt pJ : setJ) {</span>
                        if (areAdjacent(pI, pJ)) {
<span class="fc" id="L932">                            return null;</span>
<span class="fc" id="L933">                        }</span>
                    }
<span class="fc" id="L935">                }</span>
<span class="fc" id="L936">            }</span>
        }
<span class="fc" id="L938">     </span>
<span class="fc" id="L939">        // if arrive here, all neighbor sets have at least one point and none</span>
        // are adjacent to points in a different set.
<span class="fc" id="L941">        </span>
        // if there are more than one per set, we only want to keep the
        // closest to make a clear route with.
<span class="fc" id="L944">        // TODO: revisit this decision w/ further testing</span>
<span class="fc" id="L945">        </span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L947">        for (int i = 0; i &lt; listOfNeighbors.size(); ++i) {</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">            Set&lt;PairInt&gt; set = listOfNeighbors.get(i);</span>
<span class="fc" id="L949">            if (set.size() &gt; 0) {</span>
<span class="fc" id="L950">                PairInt p = null;</span>
                switch(i) {
<span class="fc" id="L952">                    case 0:</span>
<span class="fc" id="L953">                        p = segment.p0;</span>
<span class="fc" id="L954">                        break;</span>
                    case 1:
<span class="fc" id="L956">                        p = segment.p1;</span>
                        break;
<span class="fc" id="L958">                    case 2:</span>
                        p = segment.p2;
                        break;
                    default:
<span class="fc" id="L962">                        p = segment.p3;</span>
<span class="fc" id="L963">                        break;</span>
<span class="fc bfc" id="L964" title="All 4 branches covered.">                }</span>
<span class="fc" id="L965">                int minDistSq = Integer.MAX_VALUE;</span>
                PairInt minDistP = null;
<span class="fc" id="L967">                for (PairInt p2 : set) {</span>
                    int distSq = distSq(p, p2);
                    if (distSq &lt; minDistSq) {
                        minDistSq = distSq;
                        minDistP = p2;
<span class="fc" id="L972">                    }</span>
<span class="fc" id="L973">                }</span>
                set.clear();
<span class="fc bfc" id="L975" title="All 2 branches covered.">                set.add(minDistP);</span>
<span class="fc" id="L976">            }</span>
<span class="fc" id="L977">            output.addAll(set);</span>
<span class="fc" id="L978">        }</span>
<span class="fc" id="L979">        return output;</span>
<span class="fc" id="L980">    }</span>
<span class="fc" id="L981"></span>
<span class="fc" id="L982">    private boolean areAdjacent(PairInt p0, PairInt p1) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">        int diffX = Math.abs(p0.getX() - p1.getX());</span>
<span class="fc" id="L984">        int diffY = Math.abs(p0.getY() - p1.getY());</span>
<span class="fc" id="L985">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L986">            return true;</span>
<span class="fc" id="L987">        }</span>
<span class="fc" id="L988">        return false;</span>
<span class="fc" id="L989">    }</span>
<span class="fc" id="L990"></span>
<span class="fc" id="L991">    protected void rotatePattern(Pattern pattern, double theta) {</span>

        double sine = Math.sin(theta);
        double cosine = Math.cos(theta);

        for (PairInt p : pattern.zeroes) {
            int x = p.getX();
            int y = p.getY();
            int xt = (int)Math.round(((x*cosine) + (y*sine)));
            int yt = (int)Math.round(((-x*sine) + (y*cosine)));
            p.setX(xt);
            p.setY(yt);
        }
        for (PairInt p : pattern.ones) {
            int x = p.getX();
            int y = p.getY();
            int xt = (int)Math.round(((x*cosine) + (y*sine)));
            int yt = (int)Math.round(((-x*sine) + (y*cosine)));
            p.setX(xt);
            p.setY(yt);
        }
    }

    private Routes createRoute(Segment segment, int x0, int y0) {

        /*
            VertSegment
             R1  R0
             /|\ |
              |  |
              | \|/
              .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
              .  .       1
          -2 -1  0  1

<span class="fc bfc" id="L1028" title="All 2 branches covered.">               HorizPattern</span>
<span class="fc" id="L1029">                    -  -  -   -2</span>
<span class="pc bpc" id="L1030" title="3 of 4 branches missed.">            R1--&gt;   .  3  2   -1  --&gt;R1 ends</span>
<span class="pc bpc" id="L1031" title="3 of 4 branches missed.">                    .  0  1    0</span>
<span class="pc bpc" id="L1032" title="3 of 4 branches missed.">            R0&lt;--   -  -  -    1  &lt;--R0 starts</span>
<span class="fc" id="L1033">                   -1  0  1</span>
<span class="fc" id="L1034">        </span>
<span class="fc" id="L1035">                 UUDiagSegment                ULDiagSegment</span>
<span class="fc" id="L1036">                    -  -      -2                    2      -2</span>
              -  2  1  -  -   -1                 3  1      -1
<span class="fc" id="L1038">              -  -  3  0  -    0                 0          0</span>
                 -  -          1                            1
<span class="fc bfc" id="L1040" title="All 2 branches covered.">             -3 -2 -1  0  1                 -1   0  1  2</span>
<span class="fc" id="L1041"></span>
<span class="pc bpc" id="L1042" title="3 of 4 branches missed.">               E0 is '1', and route0         E0 is '1', and route0</span>
<span class="pc bpc" id="L1043" title="3 of 4 branches missed.">                  continues with             continues with</span>
<span class="pc bpc" id="L1044" title="3 of 4 branches missed.">                  point '0'                  point '0'</span>
<span class="fc" id="L1045">               E1 is '3', and route1         E1 is '3', and route1</span>
<span class="fc" id="L1046">                  continues with '2'            continues with '2'</span>
<span class="fc" id="L1047">        */</span>
<span class="fc" id="L1048"></span>
        if (segment instanceof VertSegment) {
<span class="fc" id="L1050">            Routes routes = new Routes();</span>
            assert(segment.p1.equals(new PairInt(x0, y0 - 1)));
<span class="pc bpc" id="L1052" title="1 of 4 branches missed.">            assert(segment.p2.equals(new PairInt(x0 - 1, y0 - 1)));</span>
<span class="fc" id="L1053">            assert(segment.p3.equals(new PairInt(x0 - 1, y0)));</span>
<span class="fc" id="L1054">            routes.route0.add(segment.p1);</span>
<span class="fc" id="L1055">            routes.route0.add(segment.p0);</span>
<span class="fc" id="L1056">            routes.route1.add(segment.p3);</span>
<span class="fc" id="L1057">            routes.route1.add(segment.p2);</span>
<span class="fc" id="L1058">            </span>
            return routes;
<span class="nc" id="L1060">            </span>
<span class="nc" id="L1061">        } else if (segment instanceof HorizSegment) {</span>
            Routes routes = new Routes();
            assert(segment.p1.equals(new PairInt(x0 + 1, y0)));
            assert(segment.p2.equals(new PairInt(x0 + 1, y0 - 1)));
            assert(segment.p3.equals(new PairInt(x0, y0 - 1)));
            routes.route0.add(segment.p1);
            routes.route0.add(segment.p0);
            routes.route1.add(segment.p3);
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">            routes.route1.add(segment.p2);</span>
<span class="nc" id="L1070">            </span>
            return routes;
<span class="pc bpc" id="L1072" title="1 of 4 branches missed."></span>
<span class="fc" id="L1073">        } else if ((segment instanceof UUDiagSegment) || (segment instanceof ULDiagSegment)) {</span>
            Routes routes = new Routes();
            routes.route0.add(segment.p1);
            routes.route0.add(segment.p0);
            routes.route1.add(segment.p3);
            routes.route1.add(segment.p2);
            return routes;
        } else {
            throw new IllegalStateException(&quot;error in algorithm: &quot; +
                &quot; segment not handled:&quot; + segment.getClass().getSimpleName());
        }
    }

    private int addEndpointsForHorizVertPatternForward(final int x0,
        final int y0, Pattern pattern, final Routes routes,
        Set&lt;PairInt&gt; endPoints, boolean useVert) {

        if (endPoints.size() &lt; 2) {
            throw new IllegalStateException(&quot;error in algorithm&quot;);
        }
        if ((routes.ep0End != null) || (routes.ep1 != null)) {
            return 0;
        }
        //assert(routes.ep0End == null);
        //assert(routes.ep1 == null);

        /*
           endPointsVertPattern1, for example
<span class="pc bpc" id="L1101" title="3 of 4 branches missed.">                 R0</span>
<span class="fc" id="L1102">                 \/</span>
<span class="fc" id="L1103">                        -2</span>
<span class="pc bpc" id="L1104" title="2 of 4 branches missed.">           -  2  1  -   -1</span>
<span class="nc" id="L1105">           -  3  0  -    0</span>
           -  .  .  -    1
<span class="pc bpc" id="L1107" title="3 of 4 branches missed.">              #  -  #    2</span>
<span class="pc bpc" id="L1108" title="3 of 4 branches missed.">                 -       3</span>
             /\
<span class="fc" id="L1110">             R1</span>
<span class="fc" id="L1111">          -2 -1  0  1</span>
        
<span class="fc" id="L1113">            endPointsHorizPattern1</span>
<span class="fc" id="L1114">                  -  -  -   -2</span>
<span class="fc" id="L1115">        R1--&gt; #   .  3  2   -1  --&gt;R1 ends</span>
<span class="fc" id="L1116">          -   -   .  0  1    0</span>
<span class="fc" id="L1117">        R0&lt;-- #   -  -  -    1  &lt;--R0 starts</span>
                             2
<span class="fc" id="L1119">                             3</span>
         -3  -2  -1  0  1
        */
        assert(pattern.ep0 != null);
        PairInt tE1 = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());
        PairInt tE0 = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">        if (!endPoints.contains(tE1) || !endPoints.contains(tE0)) {</span>
<span class="nc" id="L1126">            throw new IllegalStateException(&quot;error in algorithm&quot;);</span>
        }
<span class="pc bpc" id="L1128" title="2 of 4 branches missed.">        assert(!routes.route0.contains(tE0));</span>
<span class="nc" id="L1129">        assert(!routes.route1.contains(tE1));</span>

        routes.route0.add(tE0);
        routes.ep0End = tE0;

        LinkedHashSet&lt;PairInt&gt; tmp1 = new LinkedHashSet&lt;PairInt&gt;();
        tmp1.add(tE1);
        tmp1.addAll(routes.route1);
        routes.route1 = tmp1;
        routes.ep1 = tE1;
        
        return 1;
    }

    private int addEndpointsForHorizVertPatternOppos(int x0, int y0,
        Pattern pattern, Routes routes, Set&lt;PairInt&gt; endPoints, boolean useVert) {

        if (endPoints.size() &lt; 2) {
            throw new IllegalStateException(&quot;error in algorithm&quot;);
        }
        if ((routes.ep0 != null) || (routes.ep1End != null)) {
            return 0;
        }
        //assert(routes.ep0 == null);
<span class="fc" id="L1153">        //assert(routes.ep1End == null);</span>
<span class="fc" id="L1154"></span>
<span class="pc bpc" id="L1155" title="2 of 4 branches missed.">        /*</span>
<span class="nc" id="L1156">         VertSegment</span>
             R1  R0
<span class="pc bpc" id="L1158" title="3 of 4 branches missed.">             /|\ |</span>
<span class="pc bpc" id="L1159" title="3 of 4 branches missed.">              |  |</span>
              | \|/
<span class="fc" id="L1161">              .  .      -2</span>
<span class="fc" id="L1162">           -  2  1  -   -1</span>
           -  3  0  -    0
<span class="fc" id="L1164">              .  .       1</span>
<span class="fc" id="L1165">          -2 -1  0  1</span>
<span class="fc" id="L1166"></span>
<span class="fc" id="L1167">               HorizPattern</span>
<span class="fc" id="L1168">                    -  -  -   -2</span>
            R1--&gt;   .  3  2   -1  --&gt;R1 ends
<span class="fc" id="L1170">                    .  0  1    0</span>
            R0&lt;--   -  -  -    1  &lt;--R0 starts
                   -1  0  1
        */
        PairInt tE1 = new PairInt(x0 + pattern.ep1.getX(), y0 + pattern.ep1.getY());
<span class="pc bpc" id="L1175" title="3 of 4 branches missed.">        PairInt tE0 = new PairInt(x0 + pattern.ep0.getX(), y0 + pattern.ep0.getY());</span>
<span class="pc bpc" id="L1176" title="3 of 4 branches missed.">        if (!endPoints.contains(tE1) || !endPoints.contains(tE0)) {</span>
            throw new IllegalStateException(&quot;error in algorithm&quot;);
        }
        assert(!routes.route0.contains(tE0));
        assert(!routes.route1.contains(tE1));

        routes.route1.add(tE1);
        routes.ep1End = tE1;
        
        LinkedHashSet&lt;PairInt&gt; tmp0 = new LinkedHashSet&lt;PairInt&gt;();
        tmp0.add(tE0);
        tmp0.addAll(routes.route0);
        routes.route0 = tmp0;
        routes.ep0 = tE0;
        
        return 1;
    }

    private int addSegmentToRoutes(Routes routes, Segment segment) {

        assert(!routes.route0.isEmpty());
        assert(!routes.route1.isEmpty());
        
        /*   Vertical pattern
              R1 R0
             /|\ |
              |  |
              | \|/
              .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
                         1  
          -2 -1  0  1    
        
                HorizPattern 
                    -  -  -   -2
            R1--&gt;   .  3  2   -1  --&gt;R1 ends
                    .  0  1    0
<span class="pc bpc" id="L1214" title="1 of 4 branches missed.">            R0&lt;--   -  -  -    1  &lt;--R0 starts</span>
<span class="nc bnc" id="L1215" title="All 4 branches missed.">                   -1  0  1</span>
<span class="nc" id="L1216">        </span>
                 UL Diag
                          2         -2    1 to 0 is ---&gt; R0
                       3  1         -1    3 to 2 is ---&gt; R1
<span class="fc" id="L1220">                       0             0</span>
                                     1
<span class="fc" id="L1222">             -3 -2 -1  0  1  2  3</span>
<span class="fc" id="L1223">        </span>
<span class="fc" id="L1224">        </span>
<span class="fc" id="L1225">                UU Diag</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                -         -2</span>
<span class="fc" id="L1227">             2  1  -  -   -1    1 to 0 is ---&gt; R0</span>
<span class="fc" id="L1228">             -  3  0  -    0</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">             -  -          1    3 to 2 is ---&gt; R1</span>
<span class="fc" id="L1230">        </span>
<span class="fc" id="L1231">         -3 -2 -1  0  1</span>
        */ 
<span class="fc" id="L1233">        </span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">        // if segment is already in routes, return</span>
<span class="fc" id="L1235">        if (routes.route0.contains(segment.p0) &amp;&amp; routes.route0.contains(segment.p1)</span>
<span class="fc" id="L1236">            &amp;&amp; routes.route1.contains(segment.p2) &amp;&amp; routes.route1.contains(segment.p3)) {</span>
            return 0;
        }
      
<span class="fc bfc" id="L1240" title="All 4 branches covered.">        // -------- add to routes1 -------------------------</span>
<span class="pc bpc" id="L1241" title="3 of 4 branches missed.">        PairInt[] r1FirstLastNodes = getFirstAndLast(routes.route1.iterator());</span>
<span class="pc bpc" id="L1242" title="3 of 4 branches missed."></span>
<span class="pc bpc" id="L1243" title="1 of 4 branches missed.">        double p3MinDistSq = Double.MAX_VALUE;</span>
<span class="pc bpc" id="L1244" title="3 of 4 branches missed.">        int p3MinIdx = -1;</span>
<span class="pc bpc" id="L1245" title="3 of 4 branches missed.">        double p2MinDistSq = Double.MAX_VALUE;</span>
        int p2MinIdx = -1;
        for (int i = 0; i &lt; r1FirstLastNodes.length; ++i) {
<span class="pc bpc" id="L1248" title="3 of 4 branches missed.">            PairInt r1 = r1FirstLastNodes[i];</span>
<span class="pc bpc" id="L1249" title="3 of 4 branches missed.">            int distSq = distSq(segment.p3, r1);</span>
            if (distSq &lt; p3MinDistSq) {
                p3MinDistSq = distSq;
                p3MinIdx = i;
            }
            distSq = distSq(segment.p2, r1);
            if (distSq &lt; p2MinDistSq) {
                p2MinDistSq = distSq;
                p2MinIdx = i;
            }
        }
        
        if (segment instanceof HorizSegment || (segment instanceof ULDiagSegment)) {
            assert(segment.p3.getX() &lt; segment.p2.getX());
            assert(segment.p0.getX() &lt; segment.p1.getX());
        } else if (segment instanceof VertSegment || (segment instanceof UUDiagSegment)) {
            assert(segment.p3.getY() &gt; segment.p2.getY());
            assert(segment.p0.getY() &gt; segment.p1.getY());
        }
        
        assert(p2MinDistSq &lt;= 4);
        assert(p3MinDistSq &lt;= 4);
        
        /*   Vertical pattern
              R1 R0
             /|\ |
              |  |
              | \|/
              .  .      -2
           -  2  1  -   -1
           -  3  0  -    0
                         1  
          -2 -1  0  1    
        
                HorizPattern 
                    -  -  -   -2
<span class="pc bpc" id="L1285" title="1 of 4 branches missed.">            R1--&gt;   .  3  2   -1  --&gt;R1 ends</span>
                    .  0  1    0
            R0&lt;--   -  -  -    1  &lt;--R0 starts
<span class="fc" id="L1288">                   -1  0  1</span>
<span class="fc" id="L1289">        </span>
<span class="pc bpc" id="L1290" title="1 of 2 branches missed.">                    UL Diag</span>
                          2         -2    1 to 0 is ---&gt; R0
<span class="nc" id="L1292">                       3  1         -1    3 to 2 is ---&gt; R1</span>
<span class="nc" id="L1293">                       0             0</span>
                                     1
<span class="fc" id="L1295">             -3 -2 -1  0  1  2  3</span>
<span class="fc" id="L1296">        </span>
<span class="fc" id="L1297">              UU Diag</span>
<span class="pc bpc" id="L1298" title="2 of 4 branches missed.">                -         -2</span>
             2  1  -  -   -1    1 to 0 is ---&gt; R0
             -  3  0  -    0
<span class="fc" id="L1301">             -  -          1    3 to 2 is ---&gt; R1</span>
<span class="fc" id="L1302">        </span>
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">         -3 -2 -1  0  1</span>
<span class="nc" id="L1304">        */   </span>
<span class="nc" id="L1305">        </span>
        if ((p2MinDistSq &gt; p3MinDistSq) &amp;&amp; (p3MinIdx == 1)) {
<span class="fc" id="L1307">            // append to end of route1             R1:[start  stop]  p3  p2 </span>
<span class="fc" id="L1308">            //and insert at beginning of route0    R0:[stop  start]  p0  p1 </span>
<span class="fc" id="L1309">            LinkedHashSet&lt;PairInt&gt; tmp0 = new LinkedHashSet&lt;PairInt&gt;();</span>
            tmp0.add(segment.p1);
            if (p3MinDistSq &gt; 0) {
<span class="fc" id="L1312">                // append p2</span>
                routes.route1.add(segment.p3);
                tmp0.add(segment.p0);
            }
<span class="fc" id="L1316">            routes.route1.add(segment.p2);</span>
<span class="fc" id="L1317">            tmp0.addAll(routes.route0);</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">            routes.route0 = tmp0;</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        } else if ((p2MinDistSq &lt; p3MinDistSq) &amp;&amp; (p2MinIdx == 0)) {            </span>
<span class="fc" id="L1320">            // insert at beginning of route1    p3  p2  R1:[start  stop]</span>
            // append to end of route0          p0  p1  R0:[stop  start]
<span class="fc" id="L1322">            LinkedHashSet&lt;PairInt&gt; tmp1 = new LinkedHashSet&lt;PairInt&gt;();</span>
            tmp1.add(segment.p3);
            if (p2MinDistSq &gt; 0) {
<span class="fc" id="L1325">                tmp1.add(segment.p2);</span>
                routes.route0.add(segment.p1);
            }
            routes.route0.add(segment.p0);
            tmp1.addAll(routes.route1);
<span class="pc bpc" id="L1330" title="1 of 4 branches missed.">            routes.route1 = tmp1;            </span>
        }
<span class="nc" id="L1332">        </span>
        return 1;
    }

<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">    protected PairInt[] getFirstAndLast(Iterator&lt;PairInt&gt; iter) {</span>
<span class="nc" id="L1337">        PairInt firstNode = null;</span>
        PairInt lastNode = null;
        while (iter.hasNext()) {
<span class="fc" id="L1340">            if (firstNode == null) {</span>
                firstNode = iter.next();
<span class="fc bfc" id="L1342" title="All 2 branches covered.">            } else {</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">                lastNode = iter.next();</span>
            }
        }
        return new PairInt[]{firstNode, lastNode};
    }

    private ZigZagSegmentRoutes parseZigZag(Segment segment, Set&lt;PairInt&gt; endPoints) {

        if (!(segment instanceof ZigZagSegment) &amp;&amp;
            !(segment instanceof ZigZagSegment2)) {
            throw new IllegalArgumentException(
            &quot;segment type must be ZigZagSegment or ZigZagSegment2&quot;);
        }

        if (endPoints.size() != 4) {
<span class="fc" id="L1358">            throw new IllegalStateException(&quot;endPoints must be size 4&quot;);</span>
        }
<span class="fc" id="L1360"></span>
<span class="fc" id="L1361">        ZigZagSegmentRoutes routes = null;</span>
<span class="fc" id="L1362"></span>
<span class="fc" id="L1363">        if (segment instanceof ZigZagSegment) {</span>
<span class="fc" id="L1364">            if (segment.p2.getX() &lt; segment.p1.getX()) {</span>
<span class="fc" id="L1365"></span>
                /*
<span class="fc" id="L1367">                       E0</span>
<span class="fc" id="L1368">                           2  -            -2</span>
<span class="fc" id="L1369">                           -  1 .  E0end   -1</span>
<span class="fc" id="L1370">                  E1end  . 0  -             0</span>
<span class="fc" id="L1371">                           -  3             1</span>
<span class="fc" id="L1372">                                 E1</span>
                 -3 -2 -1  0  1
                */

                // '1' and '2' on one route and '0' and '3' on another.
                // add the endpoints before and after

                routes = new ZigZagSegmentRoutes();

                routes.ep1 = findClosestTo(segment.p3, endPoints);
                routes.route1.add(routes.ep1);
                routes.route1.add(segment.p3);
                routes.route1.add(segment.p0);
                routes.ep1End = findClosestTo(segment.p0, endPoints);
                routes.route1.add(routes.ep1End);
<span class="fc" id="L1387"></span>
                routes.ep0 = findClosestTo(segment.p2, endPoints);
<span class="fc" id="L1389">                routes.route0.add(routes.ep0);</span>
<span class="fc" id="L1390">                routes.route0.add(segment.p2);</span>
<span class="fc" id="L1391">                routes.route0.add(segment.p1);</span>
<span class="fc" id="L1392">                routes.ep0End = findClosestTo(segment.p1, endPoints);</span>
<span class="fc" id="L1393">                routes.route0.add(routes.ep0End);</span>
<span class="fc" id="L1394"></span>
            } else {
<span class="fc" id="L1396"></span>
<span class="fc" id="L1397">                /*            E0end</span>
<span class="fc" id="L1398">                        -  2          -2</span>
<span class="fc" id="L1399">                 E0   . 1  -          -1</span>
<span class="fc" id="L1400">                        -  0 . E1      0</span>
<span class="fc" id="L1401">                        3  -           1</span>
                  E1end
                 -3 -2 -1  0  1
                */
<span class="fc bfc" id="L1405" title="All 2 branches covered.">                // '1' and '2' on one route and '0' and '3' on another.</span>
                // add the endpoints before and after

                routes = new ZigZagSegmentRoutes();

                routes.ep0 = findClosestTo(segment.p1, endPoints);
                routes.route0.add(routes.ep0);
                routes.route0.add(segment.p1);
                routes.route0.add(segment.p2);
                routes.ep0End = findClosestTo(segment.p2, endPoints);
                routes.route0.add(routes.ep0End);

<span class="fc" id="L1417">                routes.ep1 = findClosestTo(segment.p0, endPoints);</span>
                routes.route1.add(routes.ep1);
<span class="fc" id="L1419">                routes.route1.add(segment.p0);</span>
<span class="fc" id="L1420">                routes.route1.add(segment.p3);</span>
<span class="fc" id="L1421">                routes.ep1End = findClosestTo(segment.p3, endPoints);</span>
<span class="fc" id="L1422">                routes.route1.add(routes.ep1End);</span>
<span class="fc" id="L1423"></span>
<span class="fc" id="L1424">            }</span>
        } else {
<span class="fc" id="L1426">            if (segment.p0.getY() &lt; segment.p1.getY()) {</span>
<span class="fc" id="L1427"></span>
<span class="fc" id="L1428">                /*      E1end     E0</span>
<span class="fc" id="L1429">                           .            -1</span>
<span class="fc" id="L1430">                        -  0  -  3       0</span>
<span class="fc" id="L1431">                        1  -  2  -       1</span>
                     E1       .  E0end   2
                 -3 -2 -1  0  1  2  3
                */
                // '1' and '0' on one route and '2' and '3' on another.
                // add the endpoints before and after

                routes = new ZigZagSegmentRoutes();

                routes.ep0 = findClosestTo(segment.p3, endPoints);
                routes.route0.add(routes.ep0);
                routes.route0.add(segment.p3);
                routes.route0.add(segment.p2);
                routes.ep0End = findClosestTo(segment.p2, endPoints);
                routes.route0.add(routes.ep0End);

<span class="fc" id="L1447">                routes.ep1 = findClosestTo(segment.p1, endPoints);</span>
                routes.route1.add(routes.ep1);
<span class="fc" id="L1449">                routes.route1.add(segment.p1);</span>
<span class="fc" id="L1450">                routes.route1.add(segment.p0);</span>
<span class="fc" id="L1451">                routes.ep1End = findClosestTo(segment.p0, endPoints);</span>
<span class="fc" id="L1452">                routes.route1.add(routes.ep1End);</span>
<span class="fc" id="L1453"></span>
<span class="fc" id="L1454">            } else {</span>

<span class="fc" id="L1456">                /*</span>
<span class="fc" id="L1457">                    E1end    E0</span>
<span class="fc" id="L1458">                              .         -2</span>
<span class="fc" id="L1459">                        1  -  2  -      -1</span>
<span class="fc" id="L1460">                        -  0  -  3       0</span>
<span class="fc" id="L1461">                        E1 .    E0end    1</span>
                                         2
                 -3 -2 -1  0  1  2  3
                */
<span class="fc" id="L1465">                // '1' and '0' on one route and '2' and '3' on another.</span>
                // add the endpoints before and after

                routes = new ZigZagSegmentRoutes();

<span class="pc bpc" id="L1470" title="1 of 4 branches missed.">                routes.ep0 = findClosestTo(segment.p2, endPoints);</span>
                routes.route0.add(routes.ep0);
<span class="nc" id="L1472">                routes.route0.add(segment.p2);</span>
                routes.route0.add(segment.p3);
                routes.ep0End = findClosestTo(segment.p3, endPoints);
                routes.route0.add(routes.ep0End);
<span class="pc bpc" id="L1476" title="1 of 2 branches missed."></span>
<span class="nc" id="L1477">                routes.ep1 = findClosestTo(segment.p0, endPoints);</span>
                routes.route1.add(routes.ep1);
                routes.route1.add(segment.p0);
<span class="fc" id="L1480">                routes.route1.add(segment.p1);</span>
                routes.ep1End = findClosestTo(segment.p1, endPoints);
<span class="fc" id="L1482">                routes.route1.add(routes.ep1End);</span>
            }
        }

        return routes;
    }

    private ZigZagSegmentRoutes parseDiagZigZag(Segment segment, Set&lt;PairInt&gt; endPoints) {

        if (!(segment instanceof DiagZigZagSegment) &amp;&amp;
            !(segment instanceof DiagZigZagSegment2)) {
            throw new IllegalArgumentException(
            &quot;segment type must be DiagZigZagSegment or DiagZigZagSegment2&quot;);
        }

<span class="fc" id="L1497">        if (endPoints.size() != 4) {</span>
            throw new IllegalStateException(&quot;endPoints must be size 4&quot;);
<span class="fc" id="L1499">        }</span>
<span class="fc" id="L1500"></span>
<span class="fc" id="L1501">        Set&lt;PairInt&gt; cpEndPoints = new HashSet&lt;PairInt&gt;(endPoints);</span>
<span class="fc" id="L1502"></span>
<span class="fc" id="L1503">        ZigZagSegmentRoutes routes = null;</span>
<span class="fc" id="L1504"></span>
<span class="fc" id="L1505">        /*  first pattern is shown.  The others are consistent w/ different</span>
        locations.
<span class="fc" id="L1507">                      E0           -2</span>
<span class="fc" id="L1508">              E1end 3  1  -        -1</span>
<span class="fc" id="L1509">                    -  0  2  E0end  0</span>
<span class="fc" id="L1510">                      E1  -         1</span>
<span class="fc" id="L1511"></span>
<span class="fc" id="L1512">             -3 -2 -1  0  1</span>
<span class="fc" id="L1513">        */</span>

<span class="fc" id="L1515">        // '1' and '2' on one route and '0' and '3' on another.</span>
        // add the endpoints before and after

        routes = new ZigZagSegmentRoutes();

<span class="fc" id="L1520">        routes.ep1 = findClosestTo(segment.p0, cpEndPoints);</span>
<span class="fc" id="L1521">        routes.route1.add(routes.ep1);</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">        routes.route1.add(segment.p0);</span>
<span class="fc" id="L1523">        routes.route1.add(segment.p3);</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">        cpEndPoints.remove(routes.ep1);</span>
<span class="fc" id="L1525">        routes.ep1End = findClosestTo(segment.p3, cpEndPoints);</span>
<span class="fc" id="L1526">        routes.route1.add(routes.ep1End);</span>

<span class="fc" id="L1528">        routes.ep0 = findClosestTo(segment.p1, cpEndPoints);</span>
        routes.route0.add(routes.ep0);
<span class="fc" id="L1530">        routes.route0.add(segment.p1);</span>
        routes.route0.add(segment.p2);
        cpEndPoints.remove(routes.ep0);
        routes.ep0End = findClosestTo(segment.p2, cpEndPoints);
        routes.route0.add(routes.ep0End);
<span class="pc bpc" id="L1535" title="1 of 2 branches missed."></span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        return routes;</span>
<span class="fc" id="L1537">    }</span>

<span class="fc bfc" id="L1539" title="All 2 branches covered.">    private PairInt findClosestTo(PairInt p0, Set&lt;PairInt&gt; points) {</span>
<span class="fc" id="L1540"></span>
<span class="fc" id="L1541">        PairInt pt = null;</span>
        int minDistSq = Integer.MAX_VALUE;
        for (PairInt p : points) {
            int distSq = distSq(p, p0);
<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">            if (distSq &lt; minDistSq) {</span>
<span class="fc bfc" id="L1546" title="All 2 branches covered.">                minDistSq = distSq;</span>
<span class="fc" id="L1547">                pt = p;</span>
            }
<span class="fc bfc" id="L1549" title="All 2 branches covered.">        }</span>
<span class="fc" id="L1550"></span>
<span class="fc" id="L1551">        return pt;</span>
    }

<span class="fc" id="L1554">    private void setNullEndpoints(Routes routes) {</span>

        if (!routes.getRoute0().isEmpty()) {
            if (routes.getEP0() == null) {
<span class="fc bfc" id="L1558" title="All 2 branches covered.">                routes.ep0 = routes.getRoute0().iterator().next();</span>
<span class="fc" id="L1559">            }</span>
<span class="fc" id="L1560">            if (routes.getEP0End() == null) {</span>
<span class="fc" id="L1561">                PairInt[] a = getFirstAndLast(routes.getRoute0().iterator());</span>
                routes.ep0End = a[1];
            }
        }
<span class="fc" id="L1565"></span>
        if (!routes.getRoute1().isEmpty()) {
<span class="fc" id="L1567">            if (routes.getEP1() == null) {</span>
                routes.ep1 = routes.getRoute1().iterator().next();
            }
            if (routes.getEP1End() == null) {
                PairInt[] a = getFirstAndLast(routes.getRoute1().iterator());
                routes.ep1End = a[1];
            }
        }
    }

    private void setNullEndpoints(List&lt;Routes&gt; routesList) {
<span class="fc bfc" id="L1578" title="All 2 branches covered."></span>
<span class="fc" id="L1579">        for (Routes routes : routesList) {</span>
<span class="fc" id="L1580">            setNullEndpoints(routes);</span>
<span class="fc" id="L1581">        }</span>
<span class="fc" id="L1582">    }</span>
<span class="fc" id="L1583"></span>
    private Segment checkDiagZigZagSegmentPattern(int x, int y, Set&lt;PairInt&gt; points) {
<span class="fc" id="L1585"></span>
        Pattern pattern = getDiagZigZagSegmentPattern();

<span class="fc" id="L1588">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>

<span class="fc" id="L1590">        /*</span>
        3, 0 are one route and 2, 1 are the other
                -            -2
                3  1  -      -1
                -  0  2       0
                      -       1

         -3 -2 -1  0  1
        */
        if (matchesPattern) {
            DiagZigZagSegment segment = new DiagZigZagSegment();
<span class="fc bfc" id="L1601" title="All 2 branches covered.">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1602">            segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc" id="L1603">            segment.p2 = new PairInt(x + 1, y);</span>
<span class="fc" id="L1604">            segment.p3 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L1605"></span>
<span class="fc" id="L1606">            return segment;</span>
        }
<span class="fc" id="L1608"></span>
        swapXDirection(pattern);

<span class="fc" id="L1611">        matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
        3, 0 are one route and 2, 1 are the other
                      -      -2
<span class="fc" id="L1616">                -  1  3      -1</span>
                2  0  -       0
<span class="fc" id="L1618">                -             1</span>

         -3 -2 -1  0  1
        */
        if (matchesPattern) {
            DiagZigZagSegment segment = new DiagZigZagSegment();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x, y - 1);
            segment.p2 = new PairInt(x - 1, y);
            segment.p3 = new PairInt(x + 1, y - 1);

<span class="fc bfc" id="L1629" title="All 2 branches covered.">            return segment;</span>
<span class="fc" id="L1630">        }</span>
<span class="fc" id="L1631"></span>
<span class="fc" id="L1632">        return null;</span>
<span class="fc" id="L1633">    }</span>
<span class="fc" id="L1634"></span>
    private Segment checkDiagZigZag2SegmentPattern(int x, int y, Set&lt;PairInt&gt; points) {
<span class="fc" id="L1636"></span>
        Pattern pattern = getDiagZigZag2SegmentPattern();

<span class="fc" id="L1639">        boolean matchesPattern = matchesPattern(x, y, points, pattern);</span>

<span class="fc" id="L1641">        /*</span>
        3, 0 are one route and 2, 1 are the other
                             -2
                   -  3  -   -1
                   0  1       0
                -  2  -       1

         -3 -2 -1  0  1  2
        */
        if (matchesPattern) {
            DiagZigZagSegment2 segment = new DiagZigZagSegment2();
<span class="fc bfc" id="L1652" title="All 2 branches covered.">            segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L1653">            segment.p1 = new PairInt(x + 1, y);</span>
<span class="fc" id="L1654">            segment.p2 = new PairInt(x, y + 1);</span>
<span class="fc" id="L1655">            segment.p3 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L1656"></span>
<span class="fc" id="L1657">            return segment;</span>
        }
<span class="fc" id="L1659"></span>
        swapYDirection(pattern);

<span class="fc" id="L1662">        matchesPattern = matchesPattern(x, y, points, pattern);</span>

        /*
        3, 0 are one route and 2, 1 are the other
                             -2
<span class="fc bfc" id="L1667" title="All 2 branches covered.">                -  2  -      -1</span>
<span class="fc" id="L1668">                   0  1       0</span>
                   -  3  -    1

<span class="fc" id="L1671">         -3 -2 -1  0  1  2</span>
        */
<span class="fc" id="L1673">        if (matchesPattern) {</span>
            DiagZigZagSegment2 segment = new DiagZigZagSegment2();
<span class="fc" id="L1675">            segment.p0 = new PairInt(x, y);</span>
            segment.p1 = new PairInt(x + 1, y);
<span class="fc" id="L1677">            segment.p2 = new PairInt(x, y - 1);</span>
            segment.p3 = new PairInt(x + 1, y + 1);

<span class="fc" id="L1680">            return segment;</span>
        }

        return null;
<span class="fc bfc" id="L1684" title="All 2 branches covered.">    }</span>
<span class="fc" id="L1685"></span>
    private void mergeIfAdjacent(List&lt;LinkedList&lt;Segment&gt;&gt; sections) {
        
        if (sections.size() &lt; 2) {
<span class="fc" id="L1689">            return;</span>
        }
        
        mergeIfAdjacent(sections, UUDiagSegment.class);
        
        mergeIfAdjacent(sections, ULDiagSegment.class);
        
        mergeIfAdjacent(sections, VertSegment.class);
         
        mergeHorizontalIfAdjacent(sections);       
        
        //TODO: add logic for diagonal in between horizonal or vertical merges
    }
    
<span class="fc" id="L1703">    private void mergeHorizontalIfAdjacent(List&lt;LinkedList&lt;Segment&gt;&gt; sections) {</span>
        
<span class="fc" id="L1705">        if (sections.size() &lt; 2) {</span>
            return;
<span class="fc" id="L1707">        }</span>
<span class="fc bfc" id="L1708" title="All 4 branches covered.">        </span>
<span class="fc" id="L1709">        // sorts by each list's first item's p0.x</span>
<span class="pc bpc" id="L1710" title="3 of 4 branches missed.">        Collections.sort(sections, new HorizSegmentListComparator());</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">        </span>
<span class="fc" id="L1712">        /*</span>
        using algorithm similar to leftedge.  
<span class="fc" id="L1714">                   O(N*lg(N)) + O(N) where N is sections.size()</span>
<span class="fc" id="L1715">        </span>
        sort by p0.x, then append, but only if adjacent and a horizontal segment
<span class="fc bfc" id="L1717" title="All 2 branches covered.">        </span>
<span class="fc" id="L1718">        horizontal s0      [][][]</span>
                   s1    []
                   s2              []
<span class="fc bfc" id="L1721" title="All 2 branches covered.">                   s3            []</span>
        */
<span class="fc" id="L1723">        </span>
<span class="pc bpc" id="L1724" title="3 of 4 branches missed.">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1725" title="All 2 branches covered.">        </span>
        int start = 0;
<span class="fc" id="L1727">        </span>
        LinkedList&lt;Segment&gt; currentSegments = null;
        while ((currentSegments == null) &amp;&amp; (start &lt; sections.size())) {
<span class="fc" id="L1730">            LinkedList&lt;Segment&gt; list = sections.get(start);</span>
<span class="fc" id="L1731">            assert(!list.isEmpty());</span>
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">            if (list.get(0) instanceof HorizSegment) {</span>
                currentSegments = list;
<span class="fc" id="L1734">            }</span>
<span class="fc" id="L1735">            start++;</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        }</span>
        
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        if (currentSegments == null) {</span>
<span class="pc bpc" id="L1739" title="3 of 4 branches missed.">            return;</span>
        }
<span class="fc" id="L1741">        </span>
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">        for (int i = start; i &lt; sections.size(); ++i) {</span>
<span class="nc" id="L1743">            </span>
            LinkedList&lt;Segment&gt; segments = sections.get(i);
            assert(!segments.isEmpty());
<span class="fc" id="L1746">            if (!(segments.get(0) instanceof HorizSegment)) {</span>
<span class="pc bpc" id="L1747" title="1 of 2 branches missed.">                // only merging the horizontal segments with this method</span>
<span class="nc" id="L1748">                continue;</span>
            }
            
            boolean csOrderedAscendingX = 
                (currentSegments.get(currentSegments.size() - 1).p0.getX() &gt;
                currentSegments.get(0).p0.getX());

            boolean sOrderedAscendingX = 
                (segments.get(segments.size() - 1).p0.getX() &gt;
<span class="fc" id="L1757">                segments.get(0).p0.getX());</span>
<span class="fc" id="L1758">            </span>
            if (sOrderedAscendingX &amp;&amp; 
<span class="fc" id="L1760">                ((currentSegments.size() == 1) || csOrderedAscendingX)) {</span>
<span class="fc" id="L1761">                </span>
                Segment currentLastSegment = currentSegments.get(currentSegments.size() - 1);
<span class="pc bpc" id="L1763" title="5 of 8 branches missed.">                if (!(currentLastSegment instanceof HorizSegment)) {</span>
                    continue;
<span class="fc" id="L1765">                }</span>
<span class="fc" id="L1766">                </span>
<span class="fc" id="L1767">                Segment firstSegment = segments.get(0);</span>
                if (!(firstSegment instanceof HorizSegment)) {
                    continue;
                }
                
                /*
                      c[0]    c[1]   c[2]      s[0]
                      3  2    3  2   3  2      3  2
<span class="nc" id="L1775">                      0  1    0  1   0  1      0  1</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">                */</span>
<span class="nc" id="L1777">                </span>
                int clP2X = currentLastSegment.p2.getX();
                int clP1X = currentLastSegment.p1.getX();
<span class="nc" id="L1780"></span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">                int fP3X = firstSegment.p3.getX();</span>
<span class="nc" id="L1782">                int fP0X = firstSegment.p0.getX();</span>
            
<span class="nc" id="L1784">                if ((((clP2X + 1) == fP3X) &amp;&amp; ((clP1X + 1) == fP0X)) ||</span>
<span class="nc" id="L1785">                    ((clP2X == fP3X) &amp;&amp; (clP1X == fP0X)) ) {</span>
                    currentSegments.addAll(segments);
<span class="nc" id="L1787">                    remove.add(Integer.valueOf(i));</span>
<span class="nc" id="L1788">                    continue;</span>
                }
<span class="nc bnc" id="L1790" title="All 8 branches missed.">                </span>
                /*
<span class="nc" id="L1792">                 s[n-1]     c[0]    c[1]   c[2] </span>
<span class="nc" id="L1793">                  3  2      3  2    3  2   3  2 </span>
<span class="nc" id="L1794">                  0  1      0  1    0  1   0  1   </span>
<span class="nc" id="L1795">                */</span>
<span class="nc" id="L1796">                Segment currentFirstSegment = currentSegments.get(0);</span>
<span class="nc" id="L1797">                if (!(currentFirstSegment instanceof HorizSegment)) {</span>
                    continue;
                }
<span class="pc bpc" id="L1800" title="1 of 2 branches missed.">                </span>
<span class="pc bpc" id="L1801" title="1 of 4 branches missed.">                Segment lastSegment = segments.get(segments.size() - 1);</span>
                if (!(lastSegment instanceof HorizSegment)) {
                    continue;
                }
                int clP3X = currentFirstSegment.p3.getX();
                int clP0X = currentFirstSegment.p0.getX();

<span class="fc" id="L1808">                int sP2X = lastSegment.p2.getX();</span>
<span class="pc bpc" id="L1809" title="1 of 2 branches missed.">                int sP1X = lastSegment.p1.getX();</span>
<span class="nc" id="L1810">                </span>
                if ((((sP2X + 1) == clP3X) &amp;&amp; ((sP1X + 1) == clP0X)) 
                    || ((sP2X == clP3X) &amp;&amp; (sP1X == clP0X))) {
<span class="fc" id="L1813">                    LinkedList&lt;Segment&gt; tmp = new LinkedList&lt;Segment&gt;();</span>
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">                    tmp.addAll(segments);</span>
<span class="nc" id="L1815">                    tmp.addAll(currentSegments);</span>
                    remove.add(Integer.valueOf(i));
                    currentSegments.clear();
<span class="fc" id="L1818">                    currentSegments.addAll(tmp);</span>
<span class="fc" id="L1819">                }</span>
                
<span class="fc" id="L1821">            } else if (!sOrderedAscendingX &amp;&amp; </span>
<span class="fc" id="L1822">                ((currentSegments.size() == 1) || !csOrderedAscendingX)) {</span>
                
<span class="pc bpc" id="L1824" title="4 of 8 branches missed.">                /*</span>
                     c[1]    c[0]    s[n-1]
<span class="fc" id="L1826">                     3  2    3  2     3  2</span>
<span class="fc" id="L1827">                     0  1    0  1     0  1</span>
<span class="fc" id="L1828">                */</span>
<span class="fc" id="L1829">                Segment currentFirstSegment = currentSegments.get(0);</span>
<span class="fc" id="L1830">                if (!(currentFirstSegment instanceof HorizSegment)) {</span>
<span class="fc" id="L1831">                    continue;</span>
                }
            
                Segment lastSegment = segments.get(segments.size() - 1);
                if (!(lastSegment instanceof HorizSegment)) {
                    continue;
                }
                
<span class="fc" id="L1839">                int cP2X = currentFirstSegment.p2.getX();</span>
<span class="pc bpc" id="L1840" title="1 of 2 branches missed.">                int cP1X = currentFirstSegment.p1.getX();</span>
<span class="nc" id="L1841"></span>
                int sP3X = lastSegment.p3.getX();
                int sP0X = lastSegment.p0.getX();
<span class="fc" id="L1844">                </span>
<span class="pc bpc" id="L1845" title="1 of 2 branches missed.">                if ((((sP3X + 1) == cP2X) &amp;&amp; ((sP0X + 1) == cP1X)) </span>
<span class="nc" id="L1846">                    || ((sP3X == cP2X) &amp;&amp; (sP0X == cP1X))) {</span>
                    LinkedList&lt;Segment&gt; tmp = new LinkedList&lt;Segment&gt;();
                    tmp.addAll(segments);
<span class="fc" id="L1849">                    tmp.addAll(currentSegments);</span>
<span class="fc" id="L1850">                    remove.add(Integer.valueOf(i));</span>
                    currentSegments.clear();
<span class="fc" id="L1852">                    currentSegments.addAll(tmp);</span>
<span class="fc" id="L1853">                }</span>
                
<span class="pc bpc" id="L1855" title="6 of 8 branches missed.">                /*</span>
                 s[0]        c[1]    c[0]  
<span class="nc" id="L1857">                 3  2        3  2    3  2   </span>
<span class="nc" id="L1858">                 0  1        0  1    0  1   </span>
                */
                Segment currentLastSegment = currentSegments.get(currentSegments.size() - 1);
                if (!(currentLastSegment instanceof HorizSegment)) {
                    continue;
                }
            
                Segment firstSegment = segments.get(0);
                if (!(firstSegment instanceof HorizSegment)) {
                    continue;
                }
                
<span class="fc bfc" id="L1870" title="All 2 branches covered.">                int cP3X = currentLastSegment.p3.getX();</span>
<span class="fc" id="L1871">                int cP0X = currentLastSegment.p0.getX();</span>

<span class="fc" id="L1873">                int sP2X = firstSegment.p2.getX();</span>
                int sP1X = firstSegment.p1.getX();
                
                if ((((sP2X + 1) == cP3X) &amp;&amp; ((sP1X + 1) == cP0X)) ||
                    ((sP2X == cP3X) &amp;&amp; (sP1X == cP0X)) ) {
                    currentSegments.addAll(segments);
                    remove.add(Integer.valueOf(i));
                }
                
<span class="pc bpc" id="L1882" title="1 of 2 branches missed.">            } else {</span>
<span class="nc" id="L1883">                //TODO: handle merging when segments were assembled with different</span>
                // directions.  preferably, do this at top of method.
                // the caveat is that a linked list may be composed of items
                // which are composed of any combination of horizontal,
                // vertical, and diagonal already ordered by curve point order.
            }
<span class="fc" id="L1889">        }</span>
        
        for (int i = (remove.size() - 1); i &gt; -1; --i) {
            sections.remove(remove.get(i).intValue());
        }
    }
    
    /**
     * @param sections
<span class="fc" id="L1898">     * @param cls should only extend DiagSegment or VertSegment</span>
     */
<span class="fc" id="L1900">     private void mergeIfAdjacent(List&lt;LinkedList&lt;Segment&gt;&gt; sections,</span>
        final Class&lt;? extends Segment&gt; cls) {
<span class="fc" id="L1902">        </span>
<span class="fc bfc" id="L1903" title="All 4 branches covered.">        if (sections.size() &lt; 2) {</span>
<span class="fc" id="L1904">            return;</span>
<span class="pc bpc" id="L1905" title="3 of 4 branches missed.">        }</span>
<span class="fc bfc" id="L1906" title="All 2 branches covered.">               </span>
<span class="fc" id="L1907">        //NOTE:  this one is the same as mergeVertIfAdjacent except for type check</span>
        
<span class="fc" id="L1909">        // sorts by each list's first item's p0.y, descending</span>
<span class="fc" id="L1910">        Collections.sort(sections, new VertSegmentListComparator());</span>
        
<span class="fc bfc" id="L1912" title="All 2 branches covered.">        /*</span>
<span class="fc" id="L1913">        using algorithm similar to leftedge.  </span>
                   O(N*lg(N)) + O(N) where N is sections.size()
        
<span class="fc bfc" id="L1916" title="All 2 branches covered.">        sort by p0.y, then append, but only if adjacent and a UUDiagSegment</span>
        */
<span class="fc" id="L1918">        </span>
<span class="pc bpc" id="L1919" title="3 of 4 branches missed.">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1920" title="All 2 branches covered.">        </span>
<span class="fc" id="L1921">        int start = 0;</span>
        
        LinkedList&lt;Segment&gt; currentSegments = null;
<span class="fc" id="L1924">        while ((currentSegments == null) &amp;&amp; (start &lt; sections.size())) {</span>
<span class="fc" id="L1925">            LinkedList&lt;Segment&gt; list = sections.get(start);</span>
<span class="pc bpc" id="L1926" title="1 of 2 branches missed.">            assert(!list.isEmpty());</span>
            if (list.get(0).getClass().isAssignableFrom(cls)) {
<span class="fc" id="L1928">                currentSegments = list;</span>
<span class="fc" id="L1929">            }</span>
<span class="pc bpc" id="L1930" title="1 of 2 branches missed.">            start++;</span>
        }
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">        </span>
<span class="nc bnc" id="L1933" title="All 4 branches missed.">        if (currentSegments == null) {</span>
            return;
        }
<span class="nc" id="L1936">        </span>
        for (int i = start; i &lt; sections.size(); ++i) {
<span class="nc bnc" id="L1938" title="All 2 branches missed.">            </span>
<span class="nc" id="L1939">            LinkedList&lt;Segment&gt; segments = sections.get(i);</span>
            assert(!segments.isEmpty());
            if (!(segments.get(0).getClass().isAssignableFrom(cls))) {
                continue;
            }
            
            boolean csOrderedDescendingY = 
                (currentSegments.get(currentSegments.size() - 1).p0.getY() &lt;
                currentSegments.get(0).p0.getY());

            boolean sOrderedDescendingY = 
                (segments.get(segments.size() - 1).p0.getY() &lt;
<span class="nc" id="L1951">                segments.get(0).p0.getY());</span>
<span class="nc" id="L1952">            </span>
            if (sOrderedDescendingY &amp;&amp; 
<span class="nc" id="L1954">                ((currentSegments.size() == 1) || csOrderedDescendingY)) {</span>
<span class="nc" id="L1955">                </span>
                // last segment of current
<span class="nc bnc" id="L1957" title="All 8 branches missed.">                Segment currentLastSegment = currentSegments.get(currentSegments.size() - 1);</span>
                
<span class="nc" id="L1959">                if (!(currentLastSegment.getClass().isAssignableFrom(cls))) {</span>
<span class="nc" id="L1960">                    continue;</span>
<span class="nc" id="L1961">                }</span>
            
                /*   
                                               2 1
                                       -3        3 0 s[0]
                      2 1              -2
                        3 0 c[1]       -1
                          2 1           0
                            3 0 c[0]
                */
                
                int clP1Y = currentLastSegment.p1.getY();
<span class="nc" id="L1973">                int clP2Y = currentLastSegment.p2.getY();</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">                </span>
<span class="nc" id="L1975">                int fP0Y = segments.get(0).p0.getY();</span>
                int fP3Y = segments.get(0).p3.getY();
             
<span class="nc" id="L1978">                if ((((clP1Y - 1) == fP0Y) &amp;&amp; ((clP2Y - 1) == fP3Y))</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">                    || ((clP1Y == fP0Y) &amp;&amp; (clP2Y == fP3Y))) {</span>
<span class="nc" id="L1980">                    currentSegments.addAll(segments);</span>
                    remove.add(Integer.valueOf(i));
                    continue;
<span class="nc" id="L1983">                }</span>
<span class="nc" id="L1984">                </span>
                /*   
<span class="nc" id="L1986">                                        -3 </span>
<span class="nc" id="L1987">                    2 1                 -2</span>
                      3 0 c[1]          -1
<span class="nc bnc" id="L1989" title="All 8 branches missed.">                        2 1              0</span>
                          3 0 c[0]
                                   2 1
<span class="nc" id="L1992">                                   3 0  s[n-1]</span>
<span class="nc" id="L1993">                */</span>
<span class="nc" id="L1994">                Segment currentFirstSegment = currentSegments.get(0);</span>
<span class="nc" id="L1995">                if (!(currentFirstSegment.getClass().isAssignableFrom(cls))) {</span>
<span class="nc" id="L1996">                    continue;</span>
<span class="nc" id="L1997">                }</span>
            
                Segment lastSegment = segments.get(segments.size() - 1);
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">                if (!(lastSegment.getClass().isAssignableFrom(cls))) {</span>
<span class="pc bpc" id="L2001" title="1 of 4 branches missed.">                    continue;</span>
                }
                
                int cP0Y = currentFirstSegment.p0.getY();
                int cP3Y = currentFirstSegment.p3.getY();

                int sP1Y = lastSegment.p1.getY();
                int sP2Y = lastSegment.p2.getY();
                
<span class="fc" id="L2010">                if ((((sP2Y - 1) == cP3Y) &amp;&amp; ((sP1Y - 1) == cP0Y)) </span>
<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">                    || ((sP2Y == cP3Y) &amp;&amp; (sP1Y == cP0Y))</span>
<span class="nc" id="L2012">                    ) {</span>
                    LinkedList&lt;Segment&gt; tmp = new LinkedList&lt;Segment&gt;();
                    tmp.addAll(segments);
<span class="fc" id="L2015">                    tmp.addAll(currentSegments);</span>
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">                    remove.add(Integer.valueOf(i));</span>
<span class="nc" id="L2017">                    currentSegments.clear();</span>
                    currentSegments.addAll(tmp);
                }
<span class="fc" id="L2020">                </span>
<span class="fc" id="L2021">            } else if (!sOrderedDescendingY &amp;&amp; </span>
                ((currentSegments.size() == 1) || !csOrderedDescendingY)) {
<span class="fc" id="L2023">                /*   </span>
<span class="fc" id="L2024">                                     2 1</span>
                                 -3    3 0 s[n-1]
<span class="pc bpc" id="L2026" title="4 of 8 branches missed.">                    2 1          -2</span>
                      3 0 c[0]   -1
<span class="fc" id="L2028">                        2 1       0</span>
<span class="fc" id="L2029">                          3 0 c[1]</span>
<span class="fc" id="L2030">                */</span>
<span class="fc" id="L2031">                Segment currentFirstSegment = currentSegments.get(0);</span>
<span class="fc" id="L2032">                if (!(currentFirstSegment.getClass().isAssignableFrom(cls))) {</span>
<span class="fc" id="L2033">                    continue;</span>
<span class="fc" id="L2034">                }</span>
            
                Segment lastSegment = segments.get(segments.size() - 1);
                if (!(lastSegment.getClass().isAssignableFrom(cls))) {
                    continue;
                }
                
                int cP2Y = currentFirstSegment.p2.getY();
                int cP1Y = currentFirstSegment.p1.getY();

                int sP3Y = lastSegment.p3.getY();
                int sP0Y = lastSegment.p0.getY();
                
                if ((((cP2Y - 1) == sP3Y) &amp;&amp; ((cP1Y - 1) == sP0Y))
<span class="fc" id="L2048">                    || ((cP2Y == sP3Y) &amp;&amp; (cP1Y == sP0Y))){</span>
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">                    LinkedList&lt;Segment&gt; tmp = new LinkedList&lt;Segment&gt;();</span>
<span class="nc" id="L2050">                    tmp.addAll(segments);</span>
                    tmp.addAll(currentSegments);
                    remove.add(Integer.valueOf(i));
<span class="fc" id="L2053">                    currentSegments.clear();</span>
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">                    currentSegments.addAll(tmp);</span>
<span class="nc" id="L2055">                    continue;</span>
                }
                
<span class="fc" id="L2058">                /*   </span>
<span class="fc" id="L2059">                                    -3 </span>
                    2 1             -2
<span class="fc" id="L2061">                      3 0 c[0]      -1</span>
<span class="fc" id="L2062">                        2 1          0</span>
                          3 0 c[1]
<span class="pc bpc" id="L2064" title="6 of 8 branches missed.">                                   2 1</span>
                                   3 0  s[0]
<span class="nc" id="L2066">                */</span>
<span class="nc" id="L2067">                </span>
                // last segment of current
                Segment currentLastSegment = currentSegments.get(currentSegments.size() - 1);
                if (!(currentLastSegment.getClass().isAssignableFrom(cls))) {
                    continue;
                }
                
                Segment firstSegment = segments.get(0);
                if (!(firstSegment.getClass().isAssignableFrom(cls))) {
                    continue;
                }
                
<span class="fc bfc" id="L2079" title="All 2 branches covered.">                int clP3Y = currentLastSegment.p3.getY();</span>
<span class="fc" id="L2080">                int clP0Y = currentLastSegment.p0.getY();</span>

<span class="fc" id="L2082">                int sP2Y = firstSegment.p2.getY();</span>
                int sP1Y = firstSegment.p1.getY();
                
                if ((((sP2Y - 1) == clP3Y) &amp;&amp; ((sP1Y - 1) == clP0Y))
                    || ((sP2Y == clP3Y) &amp;&amp; (sP1Y == clP0Y))) {
                    currentSegments.addAll(segments);
                    remove.add(Integer.valueOf(i));
                }
                
            } else {
                //TODO: handle merging when segments were assembled with different
                // directions.  preferably, do this at top of method.
                // the caveat is that a linked list may be composed of items
                // which are composed of any combination of horizontal,
                // vertical, and diagonal already ordered by curve point order.
            }
        }
        
<span class="fc" id="L2100">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L2101">            sections.remove(remove.get(i).intValue());</span>
<span class="fc" id="L2102">        }</span>
<span class="fc" id="L2103">    }</span>
<span class="fc" id="L2104"></span>
<span class="fc" id="L2105">    private PairInt[] findULDiagTopEndpoints(Set&lt;PairInt&gt; points, </span>
<span class="fc" id="L2106">        ULDiagSegment segment) {</span>
<span class="fc" id="L2107">        </span>
        // returns top endpoint of '2', then '1'
        /*
         1 to 0 is ---&gt; R0
         3 to 2 is ---&gt; R1
<span class="fc" id="L2112">        </span>
<span class="fc bfc" id="L2113" title="All 2 branches covered.">             UL Diag pattern, top endpoints:</span>
<span class="fc bfc" id="L2114" title="All 2 branches covered.">                   a  b  c      -3</span>
<span class="fc" id="L2115">                      2  d      -2</span>
                   3  1  e      -1
                   0     f       0
<span class="fc bfc" id="L2118" title="All 2 branches covered.">                                 1</span>
<span class="fc" id="L2119">            -2 -1  0  1  2</span>
        */
        PairInt a = new PairInt(segment.p0.getX(),     segment.p0.getY() - 3);
<span class="fc" id="L2122">        PairInt b = new PairInt(segment.p0.getX() + 1, segment.p0.getY() - 3);</span>
<span class="fc bfc" id="L2123" title="All 2 branches covered.">        PairInt c = new PairInt(segment.p0.getX() + 2, segment.p0.getY() - 3);</span>
<span class="fc bfc" id="L2124" title="All 2 branches covered.">        PairInt d = new PairInt(segment.p0.getX() + 2, segment.p0.getY() - 2);</span>
<span class="fc" id="L2125">        PairInt e = new PairInt(segment.p0.getX() + 2, segment.p0.getY() - 1);</span>
        PairInt f = new PairInt(segment.p0.getX() + 2, segment.p0.getY());
        PairInt[] t2 = new PairInt[]{a, b, c, d};
<span class="pc bpc" id="L2128" title="1 of 2 branches missed.">        PairInt[] t1 = new PairInt[]{d, e, f};</span>
<span class="nc" id="L2129">        /*</span>
        find unique pair from set2={a,b,c,d} and set1={d,e,f}
        where the pair are not adjacent horizontally or vertically
        */
        Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t2) {
            if (points.contains(p)) {
                set2.add(p);
            }
        }
        if (set2.isEmpty()) {
            return null;
        }
        
        Set&lt;PairInt&gt; set1 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t1) {
            if (points.contains(p)) {
                set1.add(p);
<span class="fc" id="L2147">            }</span>
<span class="fc" id="L2148">        }</span>
<span class="fc" id="L2149">        if (set1.isEmpty()) {</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">            return null;</span>
<span class="fc bfc" id="L2151" title="All 2 branches covered.">        }</span>
<span class="fc bfc" id="L2152" title="All 2 branches covered.">        </span>
<span class="fc" id="L2153">        /*</span>
         1 to 0 is ---&gt; R0
<span class="fc" id="L2155">         3 to 2 is ---&gt; R1</span>
<span class="fc" id="L2156">        </span>
<span class="pc bpc" id="L2157" title="3 of 8 branches missed.">             UL Diag pattern, top endpoints:</span>
<span class="nc" id="L2158">                   a  b  c      -3</span>
                      2  d      -2
<span class="fc" id="L2160">                   3  1  e      -1</span>
<span class="pc bpc" id="L2161" title="1 of 2 branches missed.">                   0     f       0</span>
<span class="fc" id="L2162">                                 1</span>
<span class="fc" id="L2163">            -2 -1  0  1  2</span>
<span class="fc" id="L2164">        </span>
        find unique pair from set2={a,b,c,d} and set1={d,e,f}
<span class="fc" id="L2166">        where the pair are not adjacent horizontally or vertically</span>
<span class="fc" id="L2167">        */</span>
<span class="pc bpc" id="L2168" title="1 of 4 branches missed.">        PairInt s2 = null;</span>
<span class="fc" id="L2169">        PairInt s1 = null;</span>
        int minDistSq = Integer.MAX_VALUE;
<span class="fc" id="L2171">        for (PairInt p2 : set2) {</span>
            for (PairInt p1 : set1) {
                if (p2.equals(p1)) {
                    continue;
                }
                int diffX = Math.abs(p2.getX() - p1.getX());
                int diffY = Math.abs(p2.getY() - p1.getY());
                if ((diffX == 0 &amp;&amp; diffY == 1) || (diffX == 1 &amp;&amp; diffY == 0)) {
                    continue;
                }
                int distSq = (diffX * diffX) + (diffY* diffY);
                if (distSq &lt; minDistSq) {
                    minDistSq = distSq;
                    s2 = p2;
                    s1 = p1;
                }
            }
        }
        if (s2 != null &amp;&amp; s1 != null) {
            return new PairInt[]{s2, s1};
<span class="fc" id="L2191">        }</span>
<span class="fc" id="L2192">        return null;</span>
<span class="fc" id="L2193">    }</span>
<span class="fc" id="L2194"></span>
<span class="fc" id="L2195">    private PairInt[] findULDiagBottomEndpoints(Set&lt;PairInt&gt; points, </span>
<span class="fc" id="L2196">        ULDiagSegment segment) {</span>
<span class="fc" id="L2197">        </span>
<span class="fc" id="L2198">        // returns bottom endpoint of '3', then '0'</span>
        /*
         1 to 0 is ---&gt; R0
         3 to 2 is ---&gt; R1
        
<span class="fc" id="L2203">              UL Diag pattern, bottom endpoints:</span>
<span class="fc bfc" id="L2204" title="All 2 branches covered.">                                -3</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                a     2         -2</span>
<span class="fc" id="L2206">                b  3  1         -1</span>
                c  0             0
                d  e  f          1
<span class="fc bfc" id="L2209" title="All 2 branches covered.">        </span>
<span class="fc" id="L2210">            -2 -1  0  1  2</span>
        */
        PairInt a = new PairInt(segment.p0.getX() - 1, segment.p0.getY() - 2);
<span class="fc" id="L2213">        PairInt b = new PairInt(segment.p0.getX() - 1, segment.p0.getY() - 1);</span>
<span class="fc bfc" id="L2214" title="All 2 branches covered.">        PairInt c = new PairInt(segment.p0.getX() - 1, segment.p0.getY());</span>
<span class="fc bfc" id="L2215" title="All 2 branches covered.">        PairInt d = new PairInt(segment.p0.getX() - 1, segment.p0.getY() + 1);</span>
<span class="fc" id="L2216">        PairInt e = new PairInt(segment.p0.getX(),     segment.p0.getY() + 1);</span>
        PairInt f = new PairInt(segment.p0.getX() + 1, segment.p0.getY() + 1);
        PairInt[] t3 = new PairInt[]{a, b, c};
<span class="pc bpc" id="L2219" title="1 of 2 branches missed.">        PairInt[] t0 = new PairInt[]{c, d, e, f};</span>
<span class="nc" id="L2220">        /*</span>
        find unique pair from set3={a,b,c} and set0={c,d,e,f}
        where the pair are not adjacent horizontally or vertically
        */
        Set&lt;PairInt&gt; set3 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t3) {
            if (points.contains(p)) {
                set3.add(p);
            }
        }
        if (set3.isEmpty()) {
            return null;
        }
        
        Set&lt;PairInt&gt; set0 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t0) {
            if (points.contains(p)) {
                set0.add(p);
<span class="fc" id="L2238">            }</span>
<span class="fc" id="L2239">        }</span>
<span class="fc" id="L2240">        if (set0.isEmpty()) {</span>
<span class="fc bfc" id="L2241" title="All 2 branches covered.">            return null;</span>
<span class="fc bfc" id="L2242" title="All 2 branches covered.">        }</span>
<span class="fc bfc" id="L2243" title="All 2 branches covered.">        </span>
<span class="fc" id="L2244">        /*</span>
         1 to 0 is ---&gt; R0
<span class="fc" id="L2246">         3 to 2 is ---&gt; R1</span>
<span class="fc" id="L2247">        UL Diag pattern, bottom endpoints:</span>
<span class="pc bpc" id="L2248" title="6 of 8 branches missed.">                                -3</span>
<span class="nc" id="L2249">                a     2         -2</span>
                b  3  1         -1
<span class="fc" id="L2251">                c  0             0</span>
<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">                d  e  f          1</span>
<span class="fc" id="L2253">        </span>
<span class="fc" id="L2254">            -2 -1  0  1  2</span>
<span class="fc" id="L2255">        </span>
        find unique pair from set3={a,b,c} and set0={c,d,e,f}
<span class="fc" id="L2257">        where the pair are not adjacent horizontally or vertically</span>
<span class="fc" id="L2258">        */</span>
<span class="pc bpc" id="L2259" title="2 of 4 branches missed.">        PairInt s3 = null;</span>
<span class="fc" id="L2260">        PairInt s0 = null;</span>
        int minDistSq = Integer.MAX_VALUE;
<span class="nc" id="L2262">        for (PairInt p3 : set3) {</span>
            for (PairInt p0 : set0) {
                if (p3.equals(p0)) {
                    continue;
                }
                int diffX = Math.abs(p3.getX() - p0.getX());
                int diffY = Math.abs(p3.getY() - p0.getY());
                if ((diffX == 0 &amp;&amp; diffY == 1) || (diffX == 1 &amp;&amp; diffY == 0)) {
                    continue;
                }
                int distSq = (diffX * diffX) + (diffY* diffY);
                if (distSq &lt; minDistSq) {
                    minDistSq = distSq;
                    s3 = p3;
                    s0 = p0;
                }
            }
        }
        if (s3 != null &amp;&amp; s0 != null) {
            return new PairInt[]{s3, s0};
<span class="fc" id="L2282">        }</span>
<span class="fc" id="L2283">        return null;</span>
<span class="fc" id="L2284">    }</span>
<span class="fc" id="L2285"></span>
<span class="fc" id="L2286">    private PairInt[] findUUDiagTopEndpoints(Set&lt;PairInt&gt; points, </span>
<span class="fc" id="L2287">        UUDiagSegment segment) {</span>
<span class="fc" id="L2288">        </span>
<span class="fc" id="L2289">        // returns top endpoint of '2', then '1'</span>
        
        /*
        1 to 0 is ---&gt; R0
        3 to 2 is ---&gt; R1
<span class="fc" id="L2294">        </span>
<span class="fc bfc" id="L2295" title="All 2 branches covered.">                   UU Diag, top endpoints</span>
<span class="fc bfc" id="L2296" title="All 2 branches covered.">              c  d  e  f          -2</span>
<span class="fc" id="L2297">              b  2  1  -  -       -1    </span>
              a  -  3  0  -        0
                 -  -              1    
<span class="fc bfc" id="L2300" title="All 2 branches covered."></span>
<span class="fc" id="L2301">             -3 -2 -1  0  1</span>
        */
        PairInt a = new PairInt(segment.p0.getX() - 3, segment.p0.getY());
<span class="fc" id="L2304">        PairInt b = new PairInt(segment.p0.getX() - 3, segment.p0.getY() - 1);</span>
<span class="fc bfc" id="L2305" title="All 2 branches covered.">        PairInt c = new PairInt(segment.p0.getX() - 3, segment.p0.getY() - 2);</span>
<span class="fc bfc" id="L2306" title="All 2 branches covered.">        PairInt d = new PairInt(segment.p0.getX() - 2, segment.p0.getY() - 2);</span>
<span class="fc" id="L2307">        PairInt e = new PairInt(segment.p0.getX() - 1, segment.p0.getY() - 2);</span>
        PairInt f = new PairInt(segment.p0.getX(),     segment.p0.getY() - 2);
        PairInt[] t2 = new PairInt[]{a, b, c, d};
<span class="fc bfc" id="L2310" title="All 2 branches covered.">        PairInt[] t1 = new PairInt[]{d, e, f};</span>
<span class="fc" id="L2311">        /*</span>
        find unique pair from set2={a,b,c,d} and set1={d,e,f}
        where the pair are not adjacent horizontally or vertically
        */
        Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t2) {
            if (points.contains(p)) {
                set2.add(p);
            }
        }
        if (set2.isEmpty()) {
            return null;
        }
        
        Set&lt;PairInt&gt; set1 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t1) {
            if (points.contains(p)) {
                set1.add(p);
<span class="fc" id="L2329">            }</span>
<span class="fc" id="L2330">        }</span>
<span class="fc" id="L2331">        if (set1.isEmpty()) {</span>
<span class="fc bfc" id="L2332" title="All 2 branches covered.">            return null;</span>
<span class="fc bfc" id="L2333" title="All 2 branches covered.">        }</span>
<span class="fc bfc" id="L2334" title="All 2 branches covered.">        </span>
<span class="fc" id="L2335">        /*</span>
         1 to 0 is ---&gt; R0
<span class="fc" id="L2337">         3 to 2 is ---&gt; R1</span>
<span class="fc" id="L2338">        </span>
<span class="pc bpc" id="L2339" title="3 of 8 branches missed.">              UU Diag, top endpoints</span>
<span class="fc" id="L2340">              c  d  e  f</span>
              b  2  1  -  -       -1    
<span class="fc" id="L2342">              a  -  3  0  -        0</span>
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">                 -  -              1    </span>
<span class="fc" id="L2344"></span>
<span class="fc" id="L2345">             -3 -2 -1  0  1</span>
<span class="fc" id="L2346">        </span>
        find unique pair from set2={a,b,c, d} and set1={d,e,f}
<span class="fc" id="L2348">        where the pair are not adjacent horizontally or vertically</span>
<span class="fc" id="L2349">        */</span>
<span class="pc bpc" id="L2350" title="1 of 4 branches missed.">        PairInt s2 = null;</span>
<span class="fc" id="L2351">        PairInt s1 = null;</span>
        int minDistSq = Integer.MAX_VALUE;
<span class="fc" id="L2353">        for (PairInt p2 : set2) {</span>
            for (PairInt p1 : set1) {
                if (p2.equals(p1)) {
                    continue;
                }
                int diffX = Math.abs(p2.getX() - p1.getX());
                int diffY = Math.abs(p2.getY() - p1.getY());
                if ((diffX == 0 &amp;&amp; diffY == 1) || (diffX == 1 &amp;&amp; diffY == 0)) {
                    continue;
                }
                int distSq = (diffX * diffX) + (diffY* diffY);
                if (distSq &lt; minDistSq) {
                    minDistSq = distSq;
                    s2 = p2;
                    s1 = p1;
                }
            }
        }
<span class="fc" id="L2371">        if (s2 != null &amp;&amp; s1 != null) {</span>
<span class="fc" id="L2372">            return new PairInt[]{s2, s1};</span>
<span class="fc" id="L2373">        }</span>
<span class="fc" id="L2374">        return null;   </span>
<span class="fc" id="L2375">    }</span>
<span class="fc" id="L2376"></span>
<span class="fc" id="L2377">    private PairInt[] findUUDiagBottomEndpoints(Set&lt;PairInt&gt; points, </span>
<span class="fc" id="L2378">        UUDiagSegment segment) {</span>
        
        // returns bottom endpoint of '3', then '0'
        /*
        1 to 0 is ---&gt; R0
<span class="fc" id="L2383">        3 to 2 is ---&gt; R1</span>
<span class="fc bfc" id="L2384" title="All 2 branches covered.">        </span>
<span class="fc bfc" id="L2385" title="All 2 branches covered.">             UU Diag, bottom endpoints</span>
<span class="fc" id="L2386">                 2  1  -  f       -1    </span>
                 -  3  0  e        0
                 a  b  c  d        1    
<span class="fc bfc" id="L2389" title="All 2 branches covered."></span>
<span class="fc" id="L2390">             -3 -2 -1  0  1</span>
        */
        PairInt a = new PairInt(segment.p0.getX() - 2, segment.p0.getY() + 1);
<span class="fc" id="L2393">        PairInt b = new PairInt(segment.p0.getX() - 1, segment.p0.getY() + 1);</span>
<span class="fc bfc" id="L2394" title="All 2 branches covered.">        PairInt c = new PairInt(segment.p0.getX(),     segment.p0.getY() + 1);</span>
<span class="fc bfc" id="L2395" title="All 2 branches covered.">        PairInt d = new PairInt(segment.p0.getX() + 1, segment.p0.getY() + 1);</span>
<span class="fc" id="L2396">        PairInt e = new PairInt(segment.p0.getX() + 1, segment.p0.getY());</span>
        PairInt f = new PairInt(segment.p0.getX() + 1, segment.p0.getY() - 1);
        PairInt[] t3 = new PairInt[]{a, b, c};
<span class="pc bpc" id="L2399" title="1 of 2 branches missed.">        PairInt[] t0 = new PairInt[]{c, d, e, f};</span>
<span class="nc" id="L2400">        /*</span>
        find unique pair from set3={a,b,c} and set0={c,d,e,f}
        where the pair are not adjacent horizontally or vertically
        */
        Set&lt;PairInt&gt; set3 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t3) {
            if (points.contains(p)) {
                set3.add(p);
            }
        }
        if (set3.isEmpty()) {
            return null;
        }
        
        Set&lt;PairInt&gt; set0 = new HashSet&lt;PairInt&gt;();
        for (PairInt p : t0) {
            if (points.contains(p)) {
<span class="fc" id="L2417">                set0.add(p);</span>
<span class="fc" id="L2418">            }</span>
<span class="fc" id="L2419">        }</span>
<span class="fc bfc" id="L2420" title="All 2 branches covered.">        if (set0.isEmpty()) {</span>
<span class="fc bfc" id="L2421" title="All 2 branches covered.">            return null;</span>
<span class="fc bfc" id="L2422" title="All 2 branches covered.">        }</span>
<span class="fc" id="L2423">        </span>
        /*
<span class="fc" id="L2425">         1 to 0 is ---&gt; R0</span>
<span class="fc" id="L2426">         3 to 2 is ---&gt; R1</span>
<span class="pc bpc" id="L2427" title="4 of 8 branches missed.">        </span>
<span class="nc" id="L2428">            UU Diag, bottom endpoints</span>
                 2  1  -  f       -1    
<span class="fc" id="L2430">                 -  3  0  e        0</span>
<span class="pc bpc" id="L2431" title="1 of 2 branches missed.">                 a  b  c  d        1    </span>
<span class="fc" id="L2432"></span>
<span class="fc" id="L2433">             -3 -2 -1  0  1</span>
<span class="fc" id="L2434">        </span>
        find unique pair from set3={a,b,c} and set0={c,d,e,f}
<span class="fc" id="L2436">        where the pair are not adjacent horizontally or vertically</span>
<span class="fc" id="L2437">        */</span>
<span class="pc bpc" id="L2438" title="2 of 4 branches missed.">        PairInt s3 = null;</span>
<span class="fc" id="L2439">        PairInt s0 = null;</span>
        int minDistSq = Integer.MAX_VALUE;
<span class="nc" id="L2441">        for (PairInt p3 : set3) {</span>
            for (PairInt p0 : set0) {
                if (p3.equals(p0)) {
                    continue;
                }
                int diffX = Math.abs(p3.getX() - p0.getX());
                int diffY = Math.abs(p3.getY() - p0.getY());
                if ((diffX == 0 &amp;&amp; diffY == 1) || (diffX == 1 &amp;&amp; diffY == 0)) {
                    continue;
                }
                int distSq = (diffX * diffX) + (diffY* diffY);
<span class="pc bpc" id="L2452" title="2 of 4 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L2453">                    minDistSq = distSq;</span>
                    s3 = p3;
<span class="pc bpc" id="L2455" title="1 of 4 branches missed.">                    s0 = p0;</span>
<span class="fc" id="L2456">                }</span>
            }
<span class="pc bpc" id="L2458" title="2 of 4 branches missed.">        }</span>
<span class="nc" id="L2459">        if (s3 != null &amp;&amp; s0 != null) {</span>
            return new PairInt[]{s3, s0};
<span class="pc bpc" id="L2461" title="2 of 4 branches missed.">        }</span>
<span class="nc" id="L2462">        return null;</span>
    }

<span class="fc" id="L2465">    /**</span>
     * check for x or y coordinates being 0. note that it does not include
     * a check for maximum column or row.
     * @param segment
     * @return 
     */
    private boolean isOnImageBoundaries(Segment segment) {
        
        if (segment.p0.getX() == 0 || segment.p0.getY() == 0) {
            return true;
        }
        if (segment.p1.getX() == 0 || segment.p1.getY() == 0) {
            return true;
        }
        if (segment.p2.getX() == 0 || segment.p2.getY() == 0) {
            return true;
        }
        if (segment.p3.getX() == 0 || segment.p3.getY() == 0) {
            return true;
        }
        
        return false;
    }

    private Segment[] checkWideDiagSegments(int x, int y, Set&lt;PairInt&gt; points) {

        Segment[] segments = checkUUWideDiagSegments(x, y, points);

        if (segments != null) {
            return segments;
        }

        segments = checkULWideDiagSegments(x, y, points);

        return segments;
    }
    
    private Segment[] checkUUWideDiagSegments(int x, int y, Set&lt;PairInt&gt; points) {
                
        /*
                 UUWideDiagSegment
              .   .            -3
              - # - # -        -2
                - 2 - 1 -      -1        1 to 0 is ---&gt; R0
                  - 3 - 0 -     0        3 to 2 is ---&gt; R1
                      .   .     1
                 -3-2-1 0 1 2
        */
        Set&lt;PairInt&gt; zeroes = new HashSet&lt;PairInt&gt;();
        zeroes.add(new PairInt(x + 1, y));
        zeroes.add(new PairInt(x - 1, y));
        zeroes.add(new PairInt(x - 3, y));
        zeroes.add(new PairInt(x,     y - 1));
        zeroes.add(new PairInt(x - 2, y - 1));
        zeroes.add(new PairInt(x - 4, y - 1));
        zeroes.add(new PairInt(x - 1, y - 2));
        zeroes.add(new PairInt(x - 3, y - 2));
        zeroes.add(new PairInt(x - 5, y - 2));
        for (PairInt p : zeroes) {
            if (points.contains(p)) {
                return null;
            }
        }
        
        PairInt p1 = new PairInt(x - 1, y - 1);
        PairInt p2 = new PairInt(x - 3, y - 1);
        PairInt p3 = new PairInt(x - 2, y);
        PairInt p11 = new PairInt(x - 2, y - 2);
        PairInt p22 = new PairInt(x - 4, y - 2);
        
        if (!points.contains(p1)) {
            return null;
        }
        if (!points.contains(p2)) {
            return null;
        }
        if (!points.contains(p3)) {
            return null;
        }
        if (!points.contains(p11)) {
            return null;
        }
        if (!points.contains(p22)) {
            return null;
        }
<span class="fc" id="L2550">        </span>
<span class="fc" id="L2551">        /*</span>
<span class="fc" id="L2552">                 UUWideDiagSegment</span>
              .   .            -3
<span class="fc" id="L2554">              - # - # -        -2</span>
<span class="fc" id="L2555">                - 2 - 1 -      -1        1 to 0 is ---&gt; R0</span>
                  - 3 - 0 -     0        3 to 2 is ---&gt; R1
<span class="fc" id="L2557">                      .   .     1</span>
<span class="fc" id="L2558">                 -3-2-1 0 1 2</span>
        */
<span class="fc" id="L2560">        Segment s0 = new Segment();</span>
        s0.p0 = new PairInt(x, y);
        s0.p1 = p1;
        s0.p2 = p2;
        s0.p3 = p3;
        
        Segment s1 = new Segment();
        s1.p0 = p1.copy();
        s1.p3 = p2.copy();
        s1.p1 = p11;
        s1.p2 = p22;
<span class="fc" id="L2571">        </span>
<span class="fc" id="L2572">        return new Segment[]{s0, s1};</span>
<span class="fc" id="L2573">    }</span>
    
<span class="fc" id="L2575">    private Segment[] checkULWideDiagSegments(int x, int y, Set&lt;PairInt&gt; points) {</span>
<span class="fc" id="L2576">             </span>
<span class="fc" id="L2577">        /*</span>
<span class="fc" id="L2578">                  ULWideDiagSegment</span>
                            - .  -5
<span class="fc" id="L2580">                          - #    -4</span>
<span class="fc" id="L2581">                        - 2 - .  -3</span>
                        3 - #    -2
<span class="fc" id="L2583">                      . - 1 -    -1        1 to 0 is ---&gt; R0</span>
                        0 -       0        3 to 2 is ---&gt; R1
                      . -         1
                 -3-2-1 0 1 2 3
        */
        Set&lt;PairInt&gt; zeroes = new HashSet&lt;PairInt&gt;();
        zeroes.add(new PairInt(x, y + 1));
        zeroes.add(new PairInt(x, y - 1));
        zeroes.add(new PairInt(x, y - 3));
        zeroes.add(new PairInt(x + 1, y));
        zeroes.add(new PairInt(x + 1, y - 2));
        zeroes.add(new PairInt(x + 1, y - 4));
        zeroes.add(new PairInt(x + 2, y - 1));
        zeroes.add(new PairInt(x + 2, y - 3));
        zeroes.add(new PairInt(x + 2, y - 5));
        for (PairInt p : zeroes) {
            if (points.contains(p)) {
<span class="fc" id="L2600">                return null;</span>
<span class="fc" id="L2601">            }</span>
<span class="fc" id="L2602">        }</span>
        
<span class="fc" id="L2604">        PairInt p1 = new PairInt(x + 1, y - 1);</span>
<span class="fc" id="L2605">        PairInt p2 = new PairInt(x + 1, y - 3);</span>
        PairInt p3 = new PairInt(x, y - 2);
<span class="fc" id="L2607">        PairInt p11 = new PairInt(x + 2, y - 2);</span>
<span class="fc" id="L2608">        PairInt p22 = new PairInt(x + 2, y - 4);</span>
        
<span class="fc" id="L2610">        if (!points.contains(p1)) {</span>
            return null;
        }
        if (!points.contains(p2)) {
            return null;
        }
        if (!points.contains(p3)) {
            return null;
        }
        if (!points.contains(p11)) {
            return null;
        }
        if (!points.contains(p22)) {
            return null;
        }
        
<span class="fc" id="L2626">        /*</span>
<span class="fc" id="L2627">                   ULWideDiagSegment</span>
<span class="fc" id="L2628">                              .  -5</span>
                            #    -4
<span class="fc" id="L2630">                          2   .  -3</span>
<span class="fc" id="L2631">                        3   #    -2</span>
<span class="fc" id="L2632">                      .   1      -1        1 to 0 is ---&gt; R0</span>
<span class="fc" id="L2633">                        0         0        3 to 2 is ---&gt; R1</span>
                      .           1
<span class="fc" id="L2635">                 -3-2-1 0 1 2 3</span>
<span class="fc" id="L2636">        */</span>
<span class="fc" id="L2637">        Segment s0 = new Segment();</span>
<span class="fc" id="L2638">        s0.p0 = new PairInt(x, y);</span>
        s0.p1 = p1;
<span class="fc" id="L2640">        s0.p2 = p2;</span>
        s0.p3 = p3;
        
        Segment s1 = new Segment();
        s1.p0 = p1.copy();
        s1.p3 = p2.copy();
        s1.p1 = p11;
        s1.p2 = p22;
        
        return new Segment[]{s0, s1};
    }
    
    /*
    may change these classes to have ordered points or to specify the
    indexes of points that are the connections, that is the '.'s in sketches
    below.
    */
    public static class Segment {
<span class="fc" id="L2658">        // the 4 points matching the segment as 0, 1, 2, 3 in the subclasses</span>
<span class="fc" id="L2659">        PairInt p0;</span>
<span class="fc" id="L2660">        PairInt p1;</span>
        PairInt p2;
<span class="fc" id="L2662">        PairInt p3;</span>
<span class="fc" id="L2663">        boolean contains(PairInt p) {</span>
            if (p0.equals(p)) {
<span class="fc" id="L2665">                return true;</span>
<span class="fc" id="L2666">            } else if (p1.equals(p)) {</span>
<span class="fc" id="L2667">                return true;</span>
            } else if (p2.equals(p)) {
<span class="fc" id="L2669">                return true;</span>
            } else if (p3.equals(p)) {
                return true;
            }
            return false;
        }
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;p0=&quot;).append(p0.toString())
                .append(&quot; p1=&quot;).append(p1.toString())
                .append(&quot; p2=&quot;).append(p2.toString())
                .append(&quot; p3=&quot;).append(p3.toString());
            return sb.toString();
        }
        public void filterOutContaining(Set&lt;PairInt&gt; points) {
            points.remove(p0);
            points.remove(p1);
<span class="fc" id="L2687">            points.remove(p2);</span>
<span class="fc" id="L2688">            points.remove(p3);</span>
<span class="fc" id="L2689">        }</span>
    }
<span class="fc" id="L2691"></span>
<span class="fc" id="L2692">    public static class VertSegment extends Segment {</span>
<span class="fc" id="L2693">    }</span>
<span class="fc" id="L2694">    public static class HorizSegment extends Segment {</span>
    }
<span class="fc" id="L2696">    public static class DiagSegment extends Segment {</span>
<span class="fc" id="L2697">    }</span>
    public static class UUDiagSegment extends DiagSegment {
<span class="fc" id="L2699">    }</span>
    public static class ULDiagSegment extends DiagSegment {
    }
    public static class ZigZagSegment extends Segment {
    }
    public static class ZigZagSegment2 extends Segment {
<span class="fc bfc" id="L2705" title="All 2 branches covered.">    }</span>
<span class="fc" id="L2706">    public static class DiagZigZagSegment extends Segment {</span>
    }
    public static class DiagZigZagSegment2 extends Segment {
    }
    public static class WideDiagSegment extends Segment {
    }

    public static class Pattern {
        Set&lt;PairInt&gt; ones;
        Set&lt;PairInt&gt; zeroes;
        /*
        an endpoint in route0.  can be null
        */
        PairInt ep0 = null;
        /*
        an endpoint in route1.  can be null
        */
        PairInt ep1 = null;
    }

    protected Pattern getVertSegmentPattern() {

        /*    .  .      -2
<span class="fc" id="L2729">           -  2  1  -   -1</span>
           -  3  0  -    0
<span class="fc bfc" id="L2731" title="All 2 branches covered.">              .  .       1</span>
<span class="fc" id="L2732">          -2 -1  0  1</span>
        */
        Pattern pr = new Pattern();
<span class="fc" id="L2735">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
        pr.zeroes = new HashSet&lt;PairInt&gt;();
<span class="fc bfc" id="L2737" title="All 2 branches covered."></span>
<span class="fc bfc" id="L2738" title="All 2 branches covered.">        pr.zeroes.add(new PairInt(-2, 0)); pr.zeroes.add(new PairInt(-2, -1));</span>
<span class="fc" id="L2739">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -1));</span>
<span class="fc" id="L2740"></span>
<span class="fc" id="L2741">        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L2742">        pr.ones.add(new PairInt(0, -1));</span>
<span class="fc" id="L2743"></span>
<span class="fc" id="L2744">        return pr;</span>
    }
<span class="fc" id="L2746"></span>
<span class="fc" id="L2747">    protected Pattern getUUDiagSegmentPattern() {</span>
<span class="fc" id="L2748"></span>
<span class="fc" id="L2749">        /*      -         -2</span>
<span class="fc" id="L2750">             2  1  -      -1    1 to 0 is ---&gt; R0</span>
<span class="fc" id="L2751">             -  3  0  -    0</span>
             -  -          1    3 to 2 is ---&gt; R1
         -3 -2 -1  0  1
        */
<span class="fc" id="L2755">        Pattern pr = new Pattern();</span>
        pr.ones = new HashSet&lt;PairInt&gt;();
        pr.zeroes = new HashSet&lt;PairInt&gt;();

        pr.zeroes.add(new PairInt(-2, 1)); pr.zeroes.add(new PairInt(-2, 0));
        pr.zeroes.add(new PairInt(-1, 1)); pr.zeroes.add(new PairInt(-1, -2));
        pr.zeroes.add(new PairInt(0, -1)); 
        pr.zeroes.add(new PairInt(1, 0));

        pr.ones.add(new PairInt(-2, -1));
        pr.ones.add(new PairInt(-1, 0)); pr.ones.add(new PairInt(-1, -1));
<span class="fc" id="L2766"></span>
        return pr;
<span class="fc" id="L2768">    }</span>

    protected Pattern getZigZagSegmentPattern() {

        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
<span class="fc bfc" id="L2776" title="All 2 branches covered.">                   -  3       1</span>
<span class="fc" id="L2777"></span>
<span class="fc" id="L2778">         -3 -2 -1  0  1</span>
<span class="fc" id="L2779"></span>
<span class="fc" id="L2780">        Each of the 4 needs at least one neighbor that is not one of the 4</span>
<span class="fc" id="L2781">        points in the zig zap and all of their neighbors cannot be adjacent</span>
        to any of the other neighbors.
<span class="fc" id="L2783">        */</span>
        Pattern pr = new Pattern();
        pr.ones = new HashSet&lt;PairInt&gt;();
<span class="fc" id="L2786">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2788">        pr.zeroes.add(new PairInt(0, 1)); pr.zeroes.add(new PairInt(0, -1));</span>
        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -2));

        pr.ones.add(new PairInt(0, -2));
        pr.ones.add(new PairInt(1, 1)); pr.ones.add(new PairInt(1, -1));

        return pr;
    }

<span class="fc bfc" id="L2797" title="All 2 branches covered.">    protected Pattern getZigZag2SegmentPattern() {</span>
<span class="fc" id="L2798"></span>
<span class="fc" id="L2799">        /*</span>
<span class="fc" id="L2800">                   .            -1</span>
<span class="fc" id="L2801">                -  0  -  3       0</span>
<span class="fc" id="L2802">                1  -  2  -       1</span>
                      .          2
<span class="fc" id="L2804">         -3 -2 -1  0  1  2  3</span>

        Each of the 4 needs at least one neighbor that is not one of the 4
<span class="fc" id="L2807">        points in the zig zap and all of their neighbors cannot be adjacent</span>
        to any of the other neighbors.
        */
        Pattern pr = new Pattern();
        pr.ones = new HashSet&lt;PairInt&gt;();
        pr.zeroes = new HashSet&lt;PairInt&gt;();
<span class="fc" id="L2813"></span>
        pr.zeroes.add(new PairInt(-1, 0));
<span class="fc" id="L2815">        pr.zeroes.add(new PairInt(0, 1));</span>
        pr.zeroes.add(new PairInt(1, 0));
        pr.zeroes.add(new PairInt(2, 1));

        pr.ones.add(new PairInt(-1, 1));
        pr.ones.add(new PairInt(0, 0)); pr.ones.add(new PairInt(0, -1));
        pr.ones.add(new PairInt(1, 1)); pr.ones.add(new PairInt(1, 2));
        pr.ones.add(new PairInt(2, 0));

        return pr;
<span class="fc bfc" id="L2825" title="All 2 branches covered.">    }</span>
<span class="fc" id="L2826"></span>
<span class="fc" id="L2827">    protected Pattern getDiagZigZagSegmentPattern() {</span>
<span class="fc" id="L2828"></span>
<span class="fc" id="L2829">        /*</span>
<span class="fc" id="L2830">        3, 0 are one route and 2, 1 are the other</span>
                -            -2
<span class="fc" id="L2832">                3  1  -      -1</span>
                -  0  2       0
                      -       1
<span class="fc" id="L2835"></span>
         -3 -2 -1  0  1
<span class="fc" id="L2837"></span>
        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
        Pattern pr = new Pattern();
        pr.ones = new HashSet&lt;PairInt&gt;();
        pr.zeroes = new HashSet&lt;PairInt&gt;();

        pr.zeroes.add(new PairInt(-1, 0)); pr.zeroes.add(new PairInt(-1, -2));
<span class="fc bfc" id="L2847" title="All 2 branches covered.">        pr.zeroes.add(new PairInt(1, 1)); pr.zeroes.add(new PairInt(1, -1));</span>
<span class="fc" id="L2848"></span>
<span class="fc" id="L2849">        pr.ones.add(new PairInt(-1, -1));</span>
<span class="fc" id="L2850">        pr.ones.add(new PairInt(0, -1));</span>
<span class="fc" id="L2851">        pr.ones.add(new PairInt(1, 0));</span>
<span class="fc" id="L2852"></span>
        return pr;
<span class="fc" id="L2854">    }</span>

    protected Pattern getDiagZigZag2SegmentPattern() {
<span class="fc" id="L2857"></span>
        /*
        3, 0 are one route and 2, 1 are the other
                             -2
                   -  3  -   -1
                   0  1       0
<span class="fc" id="L2863">                -  2  -       1</span>

<span class="fc" id="L2865">         -3 -2 -1  0  1  2</span>

        Each of the 4 needs at least one neighbor that is not one of the 4
        points in the zig zap and all of their neighbors cannot be adjacent
        to any of the other neighbors.
        */
        Pattern pr = new Pattern();
        pr.ones = new HashSet&lt;PairInt&gt;();
        pr.zeroes = new HashSet&lt;PairInt&gt;();
<span class="fc bfc" id="L2874" title="All 2 branches covered."></span>
<span class="fc" id="L2875">        pr.zeroes.add(new PairInt(-1, 1));</span>
<span class="fc" id="L2876">        pr.zeroes.add(new PairInt(0, -1));</span>
<span class="fc" id="L2877">        pr.zeroes.add(new PairInt(1, 1));</span>
<span class="fc" id="L2878">        pr.zeroes.add(new PairInt(2, -1));</span>
<span class="fc" id="L2879"></span>
        pr.ones.add(new PairInt(0, 1));
<span class="fc" id="L2881">        pr.ones.add(new PairInt(1, 0));  pr.ones.add(new PairInt(1, -1));</span>

        return pr;
<span class="fc" id="L2884">    }</span>

<span class="fc" id="L2886">    private Segment checkVertHorizSegmentPattern(int x, int y,</span>
        Set&lt;PairInt&gt; neighbors, boolean useVertical) {

        if (neighbors.size() &lt; 4) {
            return null;
        }
            
        /*
            VertSegment    
<span class="fc bfc" id="L2895" title="All 2 branches covered.">             R1  R0</span>
<span class="fc" id="L2896">             /|\ |</span>
<span class="fc" id="L2897">              |  |</span>
<span class="fc" id="L2898">              | \|/</span>
<span class="fc" id="L2899">              .  .      -2</span>
<span class="fc" id="L2900">           -  2  1  -   -1  </span>
           -  3  0  -    0  
<span class="fc" id="L2902">              .  .       1 </span>
          -2 -1  0  1     

<span class="fc" id="L2905">               HorizPattern </span>
                    -  -  -   -2
            R1--&gt;   .  3  2   -1  --&gt;R1 ends
                    .  0  1    0
<span class="fc" id="L2909">            R0&lt;--   -  -  -    1  &lt;--R0 starts</span>
<span class="fc" id="L2910">                   -1  0  1   </span>
<span class="fc" id="L2911">        */</span>
<span class="fc" id="L2912"></span>
        Pattern pattern = getVertSegmentPattern();

        if (!useVertical) {
            rotatePattern(pattern, -0.5*Math.PI);
        }
<span class="fc bfc" id="L2918" title="All 2 branches covered."></span>
<span class="fc" id="L2919">        boolean matchesPattern = matchesPattern(x, y, neighbors, pattern);</span>
<span class="fc bfc" id="L2920" title="All 2 branches covered."></span>
<span class="fc" id="L2921">        if (matchesPattern) {</span>
            if (useVertical) {
<span class="fc" id="L2923">                VertSegment segment = new VertSegment();</span>
<span class="fc bfc" id="L2924" title="All 2 branches covered.">                segment.p0 = new PairInt(x, y);</span>
<span class="fc" id="L2925">                segment.p1 = new PairInt(x, y - 1);</span>
<span class="fc bfc" id="L2926" title="All 2 branches covered.">                segment.p2 = new PairInt(x - 1, y - 1);</span>
<span class="fc" id="L2927">                segment.p3 = new PairInt(x - 1, y);</span>
                return segment;
<span class="fc" id="L2929">            } else {</span>
                HorizSegment segment = new HorizSegment();
<span class="fc" id="L2931">                segment.p0 = new PairInt(x, y);</span>
                segment.p1 = new PairInt(x + 1, y);
                segment.p2 = new PairInt(x + 1, y - 1);
                segment.p3 = new PairInt(x, y - 1);
                return segment;
            }
<span class="fc bfc" id="L2937" title="All 2 branches covered.">        }</span>
<span class="fc" id="L2938"></span>
<span class="fc bfc" id="L2939" title="All 2 branches covered.">        return null;</span>
<span class="fc" id="L2940">    }</span>

<span class="fc" id="L2942">    private Segment checkDiagSegmentPattern(int x, int y, Set&lt;PairInt&gt; points,</span>
<span class="fc bfc" id="L2943" title="All 2 branches covered.">        Set&lt;PairInt&gt; neighbors) {</span>
<span class="fc" id="L2944"></span>
<span class="fc bfc" id="L2945" title="All 4 branches covered.">        //TODO: when write the section for diagonal large pattern, it has 3 neighbors</span>
<span class="fc" id="L2946">        /*if (neighbors.size() != 3) {</span>
            return null;
<span class="fc" id="L2948">        }*/</span>
        
<span class="fc" id="L2950">        Pattern pattern = getUUDiagSegmentPattern();</span>

        boolean matchesPattern = matchesPattern(x, y, points, neighbors, pattern);

        /*      -         -2
             2  1  -      -1    1 to 0 is ---&gt; R0
             -  3  0  -    0
             -  -          1    3 to 2 is ---&gt; R1
         -3 -2 -1  0  1
        */
        if (matchesPattern) {
            UUDiagSegment segment = new UUDiagSegment();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x - 1, y - 1);
            segment.p2 = new PairInt(x - 2, y - 1);
            segment.p3 = new PairInt(x - 1, y);

            return segment;
        }

        rotatePattern(pattern, -0.5*Math.PI);

        matchesPattern = matchesPattern(x, y, points, neighbors, pattern);

        /*
                      2         -2    1 to 0 is ---&gt; R0
                   3  1         -1    3 to 2 is ---&gt; R1
                   0             0
                                 1
         -3 -2 -1  0  1  2  3
        */
        if (matchesPattern) {
            ULDiagSegment segment = new ULDiagSegment();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x + 1, y - 1);
            segment.p2 = new PairInt(x + 1, y - 2);
            segment.p3 = new PairInt(x, y - 1);

            return segment;
        }

        return null;
    }

    private ZigZagSegment checkZigZagSegmentPattern(int x, int y,
        Set&lt;PairInt&gt; points) {

        Pattern pattern = getZigZagSegmentPattern();

        boolean matchesPattern = matchesPattern(x, y, points, pattern);

        /*
                   2  -      -2
                   -  1      -1
                   0  -       0
                   -  3       1

         -3 -2 -1  0  1
        */
        if (matchesPattern) {
            ZigZagSegment segment = new ZigZagSegment();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x + 1, y - 1);
            segment.p2 = new PairInt(x, y - 2);
            segment.p3 = new PairInt(x + 1, y + 1);

            return segment;
        }

        swapXDirection(pattern);

        matchesPattern = matchesPattern(x, y, points, pattern);

        /*
                -  2      -2
                1  -      -1
                -  0       0
                3  -       1

         -3 -2 -1  0  1
        */
        if (matchesPattern) {
            ZigZagSegment segment = new ZigZagSegment();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x - 1, y - 1);
            segment.p2 = new PairInt(x, y - 2);
            segment.p3 = new PairInt(x - 1, y + 1);

            return segment;
        }

        return null;
    }

    private ZigZagSegment2 checkZigZag2SegmentPattern(int x, int y,
<span class="fc" id="L3045">        Set&lt;PairInt&gt; points) {</span>

        Pattern pattern = getZigZag2SegmentPattern();

        boolean matchesPattern = matchesPattern(x, y, points, pattern);

        /*
                   .            -1
                -  0  -  3       0
                1  -  2  -       1
                      .          2
         -3 -2 -1  0  1  2  3
        */
        if (matchesPattern) {
            ZigZagSegment2 segment = new ZigZagSegment2();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x - 1, y + 1);
            segment.p2 = new PairInt(x + 1, y + 1);
            segment.p3 = new PairInt(x + 2, y);

            return segment;
        }

        swapYDirection(pattern);

        matchesPattern = matchesPattern(x, y, points, pattern);

        /*            .         -2
                1  -  2  -      -1
                -  0  -  3       0
                   .             1
                                 2
         -3 -2 -1  0  1  2  3
        */
        if (matchesPattern) {
            ZigZagSegment2 segment = new ZigZagSegment2();
            segment.p0 = new PairInt(x, y);
            segment.p1 = new PairInt(x - 1, y - 1);
            segment.p2 = new PairInt(x + 1, y - 1);
            segment.p3 = new PairInt(x + 2, y);

            return segment;
        }

        return null;
    }
    
    protected int distSq(PairInt p0, PairInt p1) {
        int diffX = p0.getX() - p1.getX();
        int diffY = p0.getY() - p1.getY();
        int distSq = (diffX * diffX) + (diffY * diffY);
        return distSq;
    }

    private boolean matchesPattern(final int x, final int y, Set&lt;PairInt&gt; neighbors,
        Pattern pattern) {

        for (PairInt p : pattern.zeroes) {
            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());
            if (neighbors.contains(p2)) {
                return false;
            }
        }
        for (PairInt p : pattern.ones) {
            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());
            if (!neighbors.contains(p2)) {
                return false;
            }
        }
        
        return true;
    }

    private boolean matchesPattern(final int x, final int y, Set&lt;PairInt&gt; points,
        Set&lt;PairInt&gt; neighbors, Pattern pattern) {

        for (PairInt p : pattern.zeroes) {
            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());
            if (neighbors.contains(p2)) {
                return false;
            }
        }
        for (PairInt p : pattern.ones) {
            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());
            if (!neighbors.contains(p2) &amp;&amp; !points.contains(p2)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * route0 and route1 are the two routes in opposite directions for a section
     * in a closed curve with a junction. route0 and route1 do not cross and are
     * exist to help populate the curve so that the points are traversed in
     * opposite directions.
     */
    public static class Routes {
        PairInt ep0 = null;
        PairInt ep1 = null;
        PairInt ep0End = null;
        PairInt ep1End = null;
        //route0, route1 need to be searchable but ordered.
        LinkedHashSet&lt;PairInt&gt; route0 = new LinkedHashSet&lt;PairInt&gt;();
        LinkedHashSet&lt;PairInt&gt; route1 = new LinkedHashSet&lt;PairInt&gt;();
        public LinkedHashSet&lt;PairInt&gt; getRoute0() {
            return route0;
        }
        public LinkedHashSet&lt;PairInt&gt; getRoute1() {
            return route1;
        }
        public PairInt getEP0() {
            return ep0;
        }
        public PairInt getEP0End() {
            return ep0End;
        }
        public PairInt getEP1() {
            return ep1;
        }
        public PairInt getEP1End() {
            return ep1End;
        }
        public void applyOffsets(final int xOffset, final int yOffset) {
            if (ep0 != null) {
                ep0 = new PairInt(ep0.getX() + xOffset, ep0.getY() + yOffset);
            }
            if (ep0End != null) {
                ep0End = new PairInt(ep0End.getX() + xOffset, ep0End.getY() + yOffset);
            }
            if (ep1 != null) {
                ep1 = new PairInt(ep1.getX() + xOffset, ep1.getY() + yOffset);
            }
            if (ep1End != null) {
                ep1End = new PairInt(ep1End.getX() + xOffset, ep1End.getY() + yOffset);
            }

            LinkedHashSet&lt;PairInt&gt; tmp = new LinkedHashSet&lt;PairInt&gt;();
            Iterator&lt;PairInt&gt; iter = this.route0.iterator();
            while (iter.hasNext()) {
                PairInt p = iter.next();
                tmp.add(new PairInt(p.getX() + xOffset, p.getY() + yOffset));
            }
            route0 = tmp;

            tmp = new LinkedHashSet&lt;PairInt&gt;();
            iter = this.route1.iterator();
            while (iter.hasNext()) {
                PairInt p = iter.next();
                tmp.add(new PairInt(p.getX() + xOffset, p.getY() + yOffset));
            }
            route1 = tmp;
        }
    }
    public static class VertSegmentRoutes extends Routes {
    }
    public static class HorizSegmentRoutes extends Routes {
    }
    public static class UUDiagSegmentRoutes extends Routes {
    }
    public static class ZigZagSegmentRoutes extends Routes {
    }

    private static class HorizSegmentListComparator implements Comparator&lt;LinkedList&lt;Segment&gt;&gt; {

        public HorizSegmentListComparator() {
        }

        @Override
        public int compare(LinkedList&lt;Segment&gt; o1, LinkedList&lt;Segment&gt; o2) {
            
            if (o1.isEmpty() &amp;&amp; o2.isEmpty()) {
                return 0;
            } else if (o1.isEmpty() &amp;&amp; !o2.isEmpty()) {
                return 1;
            } else if (!o1.isEmpty() &amp;&amp; o2.isEmpty()) {
                return -1;
            }
            
            return Integer.compare(o1.get(0).p0.getX(), o2.get(0).p0.getX());
        }
    }

    private static class VertSegmentListComparator implements Comparator&lt;LinkedList&lt;Segment&gt;&gt; {

        public VertSegmentListComparator() {
        }

        @Override
        public int compare(LinkedList&lt;Segment&gt; o1, LinkedList&lt;Segment&gt; o2) {
            
            if (o1.isEmpty() &amp;&amp; o2.isEmpty()) {
                return 0;
            } else if (o1.isEmpty() &amp;&amp; !o2.isEmpty()) {
                return 1;
            } else if (!o1.isEmpty() &amp;&amp; o2.isEmpty()) {
                return -1;
            }
            
            return Integer.compare(o2.get(0).p0.getY(), o1.get(0).p0.getY());
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
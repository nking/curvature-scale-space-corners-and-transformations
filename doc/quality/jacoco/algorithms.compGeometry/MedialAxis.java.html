<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MedialAxis.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">MedialAxis.java</span></div><h1>MedialAxis.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.compGeometry.voronoi.VoronoiFortunesSweep;
import algorithms.compGeometry.voronoi.VoronoiFortunesSweep.GraphEdge;
import algorithms.compGeometry.voronoi.VoronoiFortunesSweep.Site;
import algorithms.imageProcessing.BresenhamsLine;
import algorithms.imageProcessing.ImageProcessor;
import algorithms.imageProcessing.PostLineThinnerCorrections;
import algorithms.imageProcessing.SpurRemover;
import algorithms.imageProcessing.ZhangSuenLineThinner;
import algorithms.misc.MiscMath;
import algorithms.mst.PrimsMST;
import algorithms.search.NearestNeighbor2D;
import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PolygonAndPointPlotter;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.TObjectIntMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TObjectIntHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
   A class to create a 2D medial axis given shape points
   and the boundary.
       from https://en.wikipedia.org/wiki/Medial_axis
       &quot;the medial axis of a subset S which is bounded 
        by planar curve C is the locus of the centers 
        of circles that are tangent to curve C in two 
        or more points.&quot;

   The class uses a Voronoi diagram, removes the 
   boundary connecting edges, and then tries to
   remove points that are not medial axis points
   that are artifacts of small bumps in the
   shape boundary.

   The class is a work in progress, so there may still
   be non-medial axis points that have not been removed
   yet.

 * @author nichole
 */
public class MedialAxis {
    
<span class="nc" id="L62">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    private final Set&lt;PairInt&gt; points;
<span class="nc" id="L65">    private Set&lt;PairInt&gt; boundary = null;</span>
    
    /**
     * if a line thinner was applied, the points
     * removed from the boundary are kept here.
     * they are needed when excluding &quot;exterior&quot;
     * points from the medial axis edges.
     */
<span class="nc" id="L73">    private final Set&lt;PairInt&gt; removedPoints = </span>
        new HashSet&lt;PairInt&gt;();
    
    //xMin, xMax, yMin, yMax
    private final int[] minMaxXY;
    
<span class="nc" id="L79">    private List&lt;GraphEdge&gt; edges = null;</span>
    
<span class="nc" id="L81">    private Set&lt;PairInt&gt; edgePoints = null;</span>
    
<span class="nc" id="L83">    private boolean applyLT = false;</span>
    
    /**
     * constructor containing all points in the area
     * and the bounding points.
     * 
     * @param shapePoints
     * @param boundaryPoints 
     */
    public MedialAxis(final Set&lt;PairInt&gt; shapePoints,
<span class="nc" id="L93">        final Set&lt;PairInt&gt; boundaryPoints) {</span>

<span class="nc" id="L95">        this.points = new HashSet&lt;PairInt&gt;(shapePoints);</span>
        
<span class="nc" id="L97">        this.boundary = new HashSet&lt;PairInt&gt;(boundaryPoints);</span>
            
<span class="nc" id="L99">        points.removeAll(boundary);</span>
        
<span class="nc" id="L101">        minMaxXY = MiscMath.findMinMaxXY(boundary);         </span>
<span class="nc" id="L102">    }</span>
    
    public void setToApplyLineThinner() {
<span class="nc" id="L105">        applyLT = true;</span>
<span class="nc" id="L106">    }</span>
    
    /**
     * find the medial axis, but with the warning that 
     * it may contain extra spikes out to false medial
     * axis points that are artifacts of bumps in the
     * boundary of the shape.
     * The artifacts are not harmful for the main reason
     * the class was built, so this faster method is
     * offered as an option.
     * The runtime complexity is purely that of Voronoi
     * Fortune Sweep, O(N * log_2(N)) where N is the
     * number of boundary points.
     * 
     */
    public void fastFindMedialAxis() {
    
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (edges != null) {</span>
<span class="nc" id="L124">            throw new IllegalStateException(</span>
                &quot;find... has already been inboked&quot;);
        }
        
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (applyLT) {</span>
<span class="nc" id="L129">            applyLineThinner();</span>
        }
        
<span class="nc" id="L132">        edges = findVoronoiInteriorEdges();</span>
        
        //plotVoronoi();        
<span class="nc" id="L135">    }</span>
    
    public void findMedialAxis() {
        
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (edges != null) {</span>
<span class="nc" id="L140">            throw new IllegalStateException(</span>
                &quot;find... has already been inboked&quot;);
        }
        
<span class="nc" id="L144">        applyLineThinner();</span>
        
<span class="nc" id="L146">        edges = findVoronoiInteriorEdges2();</span>
                
        //plotVoronoi();

<span class="nc" id="L150">    }</span>
    
    private List&lt;GraphEdge&gt; findVoronoiInteriorEdges() {
        
<span class="nc" id="L154">        float xmin = minMaxXY[0];</span>
<span class="nc" id="L155">        float xmax = minMaxXY[1];</span>
<span class="nc" id="L156">        float ymin = minMaxXY[2];</span>
<span class="nc" id="L157">        float ymax = minMaxXY[3];</span>
        
<span class="nc" id="L159">        int n = boundary.size();</span>
<span class="nc" id="L160">        float[] x = new float[n];</span>
<span class="nc" id="L161">        float[] y = new float[n];</span>
        
<span class="nc" id="L163">        int count = 0;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        for (PairInt p : boundary) {</span>
<span class="nc" id="L165">            float xp = p.getX();</span>
<span class="nc" id="L166">            float yp = p.getY();</span>
<span class="nc" id="L167">            x[count] = xp;</span>
<span class="nc" id="L168">            y[count] = yp;</span>
<span class="nc" id="L169">            count++;</span>
<span class="nc" id="L170">        }</span>
                
<span class="nc" id="L172">        int minDist = 0;</span>
<span class="nc" id="L173">        int offset = 2;</span>
        
<span class="nc" id="L175">        VoronoiFortunesSweep voronoi = new VoronoiFortunesSweep();</span>
        
<span class="nc" id="L177">        voronoi.generateVoronoi(x, y, </span>
            xmin - offset, xmax + offset, 
            ymin - offset, ymax + offset, 
            minDist);
        
        //voronoi.plot(1234);
                
<span class="nc" id="L184">        LinkedList&lt;GraphEdge&gt; edges = voronoi.getAllEdges();</span>
        
<span class="nc" id="L186">        List&lt;GraphEdge&gt; output = new ArrayList&lt;GraphEdge&gt;();</span>
       
<span class="nc" id="L188">        count = 0;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        for (GraphEdge edge : edges) {</span>
<span class="nc" id="L190">            int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L191">            int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L192">            int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L193">            int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L195">            PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L196">            PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (p1.equals(p2)) {</span>
<span class="nc" id="L198">                continue;</span>
            }
        
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (removedPoints.contains(p1) ||</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                removedPoints.contains(p2) ||</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                boundary.contains(p1) ||</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                boundary.contains(p2)) {</span>
<span class="nc" id="L205">                continue;</span>
            }
            
<span class="nc bnc" id="L208" title="All 4 branches missed.">            if (points.contains(p1) &amp;&amp; points.contains(p2)) {</span>
<span class="nc" id="L209">                output.add(edge);</span>
            }
<span class="nc" id="L211">        }</span>
        
<span class="nc bnc" id="L213" title="All 4 branches missed.">        if (output.isEmpty() &amp;&amp; boundary.size() &gt; 3 &amp;&amp;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            boundary.size() &lt; 12) {</span>
            
            // small space, and the thinning stage before
            // using this class may have removed interior
            // points so the points.contains(p) fails.
            // this does the more expensive point in polygon
            // test too.
            // TODO: find a fast correction for the line thinning
            // subsequent removal of points from shape points.
            
<span class="nc" id="L224">            x = Arrays.copyOf(x, x.length + 1);</span>
<span class="nc" id="L225">            y = Arrays.copyOf(y, y.length + 1);</span>
<span class="nc" id="L226">            x[x.length - 1] = x[0];</span>
<span class="nc" id="L227">            y[y.length - 1] = y[0];</span>
            
<span class="nc" id="L229">            PointInPolygon pip = new PointInPolygon();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            for (GraphEdge edge : edges) {</span>
<span class="nc" id="L231">                int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L232">                int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L233">                int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L234">                int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L236">                PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L237">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (p1.equals(p2)) {</span>
<span class="nc" id="L239">                    continue;</span>
                }
                
                // if p1 is in points or is interior to boundary
                // and same for p2, can keep it
<span class="nc bnc" id="L244" title="All 2 branches missed.">                if ((points.contains(p1) ||</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    pip.isInSimpleCurve(x1, y1, x, y, x.length)) &amp;&amp; </span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                    (points.contains(p2) ||</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                    pip.isInSimpleCurve(x2, y2, x, y, x.length))) {</span>
                    
<span class="nc" id="L249">                    output.add(edge);</span>
                }
<span class="nc" id="L251">            }</span>
        }
        
<span class="nc" id="L254">        return output;</span>
    }
    
    private List&lt;GraphEdge&gt; findVoronoiInteriorEdges2() {
               
        //TODO: improve this:
<span class="nc" id="L260">        Set&lt;PairInt&gt; c = findBoundaryProblems();</span>
        
<span class="nc" id="L262">        NearestNeighbor2D nn = new NearestNeighbor2D(</span>
            c, minMaxXY[1], minMaxXY[3]);
        
<span class="nc" id="L265">        float xmin = minMaxXY[0];</span>
<span class="nc" id="L266">        float xmax = minMaxXY[1];</span>
<span class="nc" id="L267">        float ymin = minMaxXY[2];</span>
<span class="nc" id="L268">        float ymax = minMaxXY[3];</span>
        
<span class="nc" id="L270">        int n = boundary.size();</span>
<span class="nc" id="L271">        float[] x = new float[n];</span>
<span class="nc" id="L272">        float[] y = new float[n];</span>
        
<span class="nc" id="L274">        int count = 0;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        for (PairInt p : boundary) {</span>
<span class="nc" id="L276">            float xp = p.getX();</span>
<span class="nc" id="L277">            float yp = p.getY();</span>
<span class="nc" id="L278">            x[count] = xp;</span>
<span class="nc" id="L279">            y[count] = yp;</span>
<span class="nc" id="L280">            count++;</span>
<span class="nc" id="L281">        }</span>
                
<span class="nc" id="L283">        int minDist = 0;</span>
        
<span class="nc" id="L285">        VoronoiFortunesSweep voronoi = </span>
            new VoronoiFortunesSweep();
        
<span class="nc" id="L288">        voronoi.generateVoronoi(x, y, </span>
            xmin - 1, xmax + 1, ymin - 1, ymax + 1, 
            minDist);
        
<span class="nc" id="L292">        LinkedList&lt;GraphEdge&gt; edges = voronoi.getAllEdges();</span>
        
<span class="nc" id="L294">        List&lt;GraphEdge&gt; output = new ArrayList&lt;GraphEdge&gt;();</span>
       
<span class="nc" id="L296">        Site[] sites = voronoi.getSites();</span>
        
        /*
        need to store edge points and make an adjacency
        map for them.
        while storing the edge points, need to find the
        edge points which are very near the set rm.
        
        then will make an mst for the adjacency map.
        
        then will remove the rm points and the branch
        they are on up until they reach a parent with
        another child.
        */
        
        TIntObjectMap&lt;TIntIntMap&gt;
<span class="nc" id="L312">            adjCostMap = new TIntObjectHashMap&lt;TIntIntMap&gt;();</span>
       
        /*
        edge: v1, v2
           each vertex in edge gets a vertex index
              that may already exist
        each edge is stored in map w/ key=pairint(v1,v2)
           where v1&lt;v2.
        
        rm are the verex indexes to remove
        */
<span class="nc" id="L323">        TIntSet rm = new TIntHashSet();</span>
<span class="nc" id="L324">        TObjectIntMap&lt;PairInt&gt; vertexIndexes </span>
            = new TObjectIntHashMap&lt;PairInt&gt;();
<span class="nc" id="L326">        Map&lt;PairInt, GraphEdge&gt; vertexEdgeMap = </span>
            new HashMap&lt;PairInt, GraphEdge&gt;();
        
<span class="nc" id="L329">        count = 0;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (GraphEdge edge : edges) {</span>
<span class="nc" id="L331">            int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L332">            int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L333">            int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L334">            int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L336">            PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L337">            PairInt p2 = new PairInt(x2, y2);</span>
           
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (p1.equals(p2)) {</span>
<span class="nc" id="L340">                continue;</span>
            }
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (removedPoints.contains(p1) ||</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                removedPoints.contains(p1) ||</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                boundary.contains(p1) ||</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                boundary.contains(p2)) {</span>
<span class="nc" id="L346">                continue;</span>
            }
            
<span class="nc bnc" id="L349" title="All 4 branches missed.">            if (points.contains(p1) &amp;&amp; points.contains(p2)) {</span>

                int idx1;
<span class="nc bnc" id="L352" title="All 2 branches missed.">                if (vertexIndexes.containsKey(p1)) {</span>
<span class="nc" id="L353">                    idx1 = vertexIndexes.get(p1);</span>
                } else {
<span class="nc" id="L355">                    idx1 = vertexIndexes.size();</span>
<span class="nc" id="L356">                    vertexIndexes.put(p1, idx1);</span>
                }
                        
<span class="nc" id="L359">                Set&lt;PairInt&gt; nearest1 = </span>
<span class="nc" id="L360">                    nn.findClosest(x1, y1, 3);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                if (!nearest1.isEmpty()) {</span>
<span class="nc" id="L362">                    rm.add(idx1);</span>
                    //System.out.println(&quot;rm: &quot; + p1);
                }
                
                int idx2;
<span class="nc bnc" id="L367" title="All 2 branches missed.">                if (vertexIndexes.containsKey(p2)) {</span>
<span class="nc" id="L368">                    idx2 = vertexIndexes.get(p2);</span>
                } else {
<span class="nc" id="L370">                    idx2 = vertexIndexes.size();</span>
<span class="nc" id="L371">                    vertexIndexes.put(p2, idx2);</span>
                }
<span class="nc" id="L373">                Set&lt;PairInt&gt; nearest2 = </span>
<span class="nc" id="L374">                    nn.findClosest(x2, y2, 3);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                if (!nearest2.isEmpty()) {</span>
<span class="nc" id="L376">                    rm.add(idx2);</span>
                    //System.out.println(&quot;rm: &quot; + p2);
                }
                
                PairInt eKey;
<span class="nc bnc" id="L381" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L382">                    eKey = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L384">                    eKey = new PairInt(idx2, idx1);</span>
                }
                
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (vertexEdgeMap.containsKey(eKey)) {</span>
<span class="nc" id="L388">                    continue;</span>
                }
<span class="nc" id="L390">                vertexEdgeMap.put(eKey, edge);</span>
                
<span class="nc" id="L392">                TIntIntMap map = adjCostMap.get(idx1);</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                if (map == null) {</span>
<span class="nc" id="L394">                    map = new TIntIntHashMap();</span>
<span class="nc" id="L395">                    adjCostMap.put(idx1, map);</span>
                }
<span class="nc" id="L397">                map.put(idx2, 1);</span>
                
<span class="nc" id="L399">                map = adjCostMap.get(idx2);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                if (map == null) {</span>
<span class="nc" id="L401">                    map = new TIntIntHashMap();</span>
<span class="nc" id="L402">                    adjCostMap.put(idx2, map);</span>
                }
<span class="nc" id="L404">                map.put(idx1, 1);</span>
            }
<span class="nc" id="L406">        }</span>
        
       // System.out.println(&quot;nVertexes=&quot; + vertexIndexes.size());
       // System.out.println(&quot;nEdges=&quot; + vertexEdgeMap.size());
        
<span class="nc" id="L411">        PrimsMST mst = new PrimsMST();</span>
<span class="nc" id="L412">        mst.calculateMinimumSpanningTree(vertexIndexes.size(), </span>
            adjCostMap);
        
<span class="nc" id="L415">        int[] prev = mst.getPrecessorArray();</span>
<span class="nc" id="L416">        TIntObjectMap&lt;TIntList&gt; revPrevMap =</span>
<span class="nc" id="L417">            mst.createReverseMap();</span>
                
<span class="nc" id="L419">        TIntSet rm2 = new TIntHashSet();</span>
        
<span class="nc" id="L421">        Set&lt;GraphEdge&gt; rmEdges = new HashSet&lt;GraphEdge&gt;();</span>
<span class="nc" id="L422">        TIntIterator iter = rm.iterator();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
            
<span class="nc" id="L425">            int idx = iter.next();</span>
                                    
            // keep walking up tree until a parent has children.n&gt;2
            while (true) {
                
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (rm2.contains(idx)) {</span>
<span class="nc" id="L431">                    break;</span>
                }
                
<span class="nc" id="L434">                int prevIdx = prev[idx];</span>
                
                PairInt rmKey;
<span class="nc bnc" id="L437" title="All 2 branches missed.">                if (idx &lt; prevIdx) {</span>
<span class="nc" id="L438">                    rmKey = new PairInt(idx, prevIdx);</span>
                } else {
<span class="nc" id="L440">                    rmKey = new PairInt(prevIdx, idx);</span>
                }

<span class="nc" id="L443">                rmEdges.add(vertexEdgeMap.get(rmKey));</span>
                
<span class="nc" id="L445">                TIntList pC = revPrevMap.get(prevIdx);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (pC == null) {</span>
<span class="nc" id="L447">                    break;</span>
                }
                //boolean removed = pC.remove(idx);
                //rm2.add(idx);
                //assert(removed);
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (pC.size() &gt; 1) {</span>
<span class="nc" id="L453">                    break;</span>
                }
<span class="nc" id="L455">                idx = prevIdx;</span>
<span class="nc" id="L456">            }</span>
<span class="nc" id="L457">        }</span>
        
        //System.out.println(&quot;nEdges to remove=&quot; + rmEdges.size());
        
<span class="nc" id="L461">        Iterator&lt;Entry&lt;PairInt, GraphEdge&gt;&gt; iter2 = </span>
<span class="nc" id="L462">            vertexEdgeMap.entrySet().iterator();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        while (iter2.hasNext()) {</span>
<span class="nc" id="L464">            Entry&lt;PairInt, GraphEdge&gt; entry = iter2.next();</span>
<span class="nc" id="L465">            GraphEdge edge = entry.getValue();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (!rmEdges.contains(edge)) {</span>
<span class="nc" id="L467">                output.add(edge);</span>
            }
<span class="nc" id="L469">        }</span>
        
<span class="nc" id="L471">        System.out.println(&quot;nEdges=&quot; + output.size());</span>
        
<span class="nc" id="L473">        return output;</span>
    }
    
    private void plotVoronoi() {
        
<span class="nc" id="L478">        float xmin = minMaxXY[0];</span>
<span class="nc" id="L479">        float xmax = minMaxXY[1];</span>
<span class="nc" id="L480">        float ymin = minMaxXY[2];</span>
<span class="nc" id="L481">        float ymax = minMaxXY[3];</span>
        
<span class="nc" id="L483">        int n = boundary.size();</span>
<span class="nc" id="L484">        float[] x = new float[n];</span>
<span class="nc" id="L485">        float[] y = new float[n];</span>
        
<span class="nc" id="L487">        int count = 0;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        for (PairInt p : boundary) {</span>
<span class="nc" id="L489">            float xp = p.getX();</span>
<span class="nc" id="L490">            float yp = p.getY();</span>
<span class="nc" id="L491">            x[count] = xp;</span>
<span class="nc" id="L492">            y[count] = yp;</span>
<span class="nc" id="L493">            count++;</span>
<span class="nc" id="L494">        }</span>
               
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (edges == null) {</span>
<span class="nc" id="L497">            fastFindMedialAxis();</span>
        }
                
        try {
<span class="nc" id="L501">        PolygonAndPointPlotter plotter = </span>
            new PolygonAndPointPlotter(xmin - 1, xmax + 1, 
                ymin - 1, ymax + 1);
        
<span class="nc" id="L505">        float[] xPolygon = null;</span>
<span class="nc" id="L506">        float[] yPolygon = null;</span>
                
<span class="nc" id="L508">        n = edges.size();</span>
<span class="nc" id="L509">        xPolygon = new float[2*n];</span>
<span class="nc" id="L510">        yPolygon = new float[2*n];</span>
<span class="nc" id="L511">        count = 0;</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">        for (GraphEdge edge : edges) {</span>
<span class="nc" id="L513">            float x1 = edge.x1;</span>
<span class="nc" id="L514">            float y1 = edge.y1;</span>
<span class="nc" id="L515">            float x2 = edge.x2;</span>
<span class="nc" id="L516">            float y2 = edge.y2;</span>
            
<span class="nc" id="L518">            xPolygon[count] = x1;</span>
<span class="nc" id="L519">            yPolygon[count] = y1;</span>
<span class="nc" id="L520">            xPolygon[count + 1] = x2;</span>
<span class="nc" id="L521">            yPolygon[count + 1] = y2;</span>
<span class="nc" id="L522">            count += 2;</span>
<span class="nc" id="L523">        }</span>
<span class="nc" id="L524">        plotter.addPlotWithLines(x, y, xPolygon, yPolygon, </span>
            &quot;edges&quot;);
        
<span class="nc" id="L527">        count = 0;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        for (GraphEdge edge : edges) {</span>
<span class="nc" id="L529">            int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L530">            int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L531">            int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L532">            int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L534">            PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L535">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L537" title="All 4 branches missed.">            if (points.contains(p1) &amp;&amp; points.contains(p2)) {</span>
<span class="nc" id="L538">                xPolygon[count] = x1;</span>
<span class="nc" id="L539">                yPolygon[count] = y1;</span>
<span class="nc" id="L540">                xPolygon[count + 1] = x2;</span>
<span class="nc" id="L541">                yPolygon[count + 1] = y2;</span>
<span class="nc" id="L542">                count += 2;</span>
            }
<span class="nc" id="L544">        }</span>
<span class="nc" id="L545">        xPolygon = Arrays.copyOf(xPolygon, count);</span>
<span class="nc" id="L546">        yPolygon = Arrays.copyOf(yPolygon, count);</span>
        
<span class="nc" id="L548">        plotter.addPlotWithLines(x, y, xPolygon, yPolygon, </span>
            &quot;edited for medial axes&quot;);
        
        //-----
<span class="nc" id="L552">        Set&lt;PairInt&gt; pts = getMedialAxisPoints();</span>
<span class="nc" id="L553">        n = pts.size();</span>
<span class="nc" id="L554">        x = new float[n];</span>
<span class="nc" id="L555">        y = new float[n];</span>
<span class="nc" id="L556">        count = 0;</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        for (PairInt p : pts) {</span>
<span class="nc" id="L558">            float xp = p.getX();</span>
<span class="nc" id="L559">            float yp = p.getY();</span>
<span class="nc" id="L560">            x[count] = xp;</span>
<span class="nc" id="L561">            y[count] = yp;</span>
<span class="nc" id="L562">            count++;</span>
<span class="nc" id="L563">        }</span>
<span class="nc" id="L564">        plotter.addPlotWithLines(x, y, xPolygon, yPolygon, </span>
            &quot;med axis pts&quot;);
        
<span class="nc" id="L567">        String filePath = plotter.writeFile(1000);</span>
<span class="nc" id="L568">        System.out.println(&quot;wrote file=&quot; + filePath);</span>
<span class="nc" id="L569">        } catch (Throwable t) {</span>
            
<span class="nc" id="L571">        }</span>
<span class="nc" id="L572">    }</span>

    /**
     * return the results as the graph edges.
     * The output is copied so modifications
     * won't affect the instance variables.
     * @return 
     */
    protected List&lt;GraphEdge&gt; getMedAxisAsEdges() {
<span class="nc" id="L581">        return new ArrayList&lt;GraphEdge&gt;(edges);</span>
    }
    
    /**
     * return the results as undirected point sets.
     * Note that the method runtime complexity is
     * O(N_edges) because it creates points between
     * the edge endpoints.
     * @return 
     */
    public Set&lt;PairInt&gt; getMedialAxisPoints() {
        
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (edgePoints != null) {</span>
<span class="nc" id="L594">            return edgePoints;</span>
        }
       
<span class="nc" id="L597">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L599" title="All 2 branches missed.">        for (GraphEdge edge : edges) {</span>
        
<span class="nc" id="L601">            int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L602">            int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L603">            int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L604">            int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L606">            BresenhamsLine.createLinePoints(x1, y1, x2, y2,</span>
                output);
<span class="nc" id="L608">        }</span>
        
<span class="nc" id="L610">        this.edgePoints = output;</span>
        
<span class="nc" id="L612">        return output;</span>
    }
    
    private Set&lt;PairInt&gt; findBoundaryProblems() {
                
<span class="nc" id="L617">        PostLineThinnerCorrections pltc = new </span>
            PostLineThinnerCorrections();
        
<span class="nc" id="L620">        return pltc.findBoundaryPattern(boundary, minMaxXY[1], minMaxXY[3]);</span>
        
    }

    private void applyLineThinner() {
        
<span class="nc" id="L626">        Set&lt;PairInt&gt; b = new HashSet&lt;PairInt&gt;(boundary);</span>
        
<span class="nc" id="L628">        ImageProcessor imp = new ImageProcessor();</span>
<span class="nc" id="L629">        imp.applyThinning(b, minMaxXY[1] + 1, </span>
            minMaxXY[3] + 1);
        
        //SpurRemover spurRm = new SpurRemover();
        //spurRm.remove(b, minMaxXY[1] + 3, 
        //    minMaxXY[3] + 3);
        
        /*
        ZhangSuenLineThinner lt = new ZhangSuenLineThinner();
        lt.applyLineThinner(b, 
            minMaxXY[0] - 1, minMaxXY[1] + 1, 
            minMaxXY[2] - 1, minMaxXY[3] + 1);
        */
            
        // store the removed points
<span class="nc" id="L644">        removedPoints.addAll(boundary);</span>
<span class="nc" id="L645">        removedPoints.removeAll(b);</span>
        
<span class="nc" id="L647">        System.out.println(&quot;line thinning removed &quot; +</span>
<span class="nc" id="L648">            removedPoints.size() + &quot; from the boundary&quot;);</span>
        
<span class="nc" id="L650">        boundary = b;</span>
<span class="nc" id="L651">    }</span>

    public Set&lt;PairInt&gt; getBoundary() {
<span class="nc" id="L654">        return boundary;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
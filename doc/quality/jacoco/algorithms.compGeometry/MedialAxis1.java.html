<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MedialAxis1.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">MedialAxis1.java</span></div><h1>MedialAxis1.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.compGeometry.voronoi.VoronoiFortunesSweep;
import algorithms.compGeometry.voronoi.VoronoiFortunesSweep.GraphEdge;
import algorithms.imageProcessing.Heap;
import algorithms.imageProcessing.HeapNode;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import algorithms.search.NearestNeighbor2D;
import algorithms.util.PairInt;
import algorithms.util.PolygonAndPointPlotter;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntDoubleMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntDoubleHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;

/**
  NOTE: the MedialAxis should be preferred to this one.
 This needs improvements.
 * 
   A class to create a 2D medial axis given shape points
   and the boundary.
       from https://en.wikipedia.org/wiki/Medial_axis
       &quot;the medial axis of a subset S which is bounded 
        by planar curve C is the locus of the centers 
        of circles that are tangent to curve C in two 
        or more points.&quot;

   This class is an implementation of 
   &quot;Efficient and Robust Computation of an Approximated Medial Axis&quot;
   by Yang, Brock, and Moll
   
 * which requires
 * &quot;Efficient Computation of A Simplified Medial Axis&quot;
 * by Foskey, Lin, and Manocha
 * and 
 * &quot;A Framework for Using the Workspace Medial Axis in 
 * PRM Planners&quot;
 * by Holleman and Kavraki
 * 
 * 
 
 * @author nichole
 */
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">public class MedialAxis1 {</span>
    
    //TODO: change to use methods in ImageProcessorTest.testCreateZeroCrossingsCurvature
    
<span class="pc" id="L60">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    private final Set&lt;PairInt&gt; points;
    private final Set&lt;PairInt&gt; boundary;
    private final NearestNeighbor2D np;
    
    /** as circles within points are searched, they are placed
    in processed
    */
    private final Set&lt;PairInt&gt; processed;
    
    private final List&lt;MedialAxisPoint&gt; medAxisList;
    
    //xMin, xMax, yMin, yMax
    private final int[] minMaxXY;
    
    /**
     * separation angle used for sampling points in
     * a circle around a point.
     */
    private final double sepAng;// = Math.PI/3;
    private final int nSampl;//  2*pi/sepAng
    
    
    //private static final double sepAng = Math.PI/6;
    //private final int nSampl = 12;//  2*pi/sepAng
    
    //private static final double sepAng = Math.PI/9;
    //private final int nSampl = 18;//  2*pi/sepAng
    
    //private static final double sepAng = Math.PI/18;
    //private final int nSampl = 36;//  2*pi/sepAng
    
    // 10 degrees threshold for separation angle criterion
    // ~ 0.1745
    //private final double threshold = Math.PI/18;
    
<span class="pc" id="L97">    private double twoPI = Math.PI;</span>
    private final double sinePiDivN;
    
    private final int nInterior;
    
    /*
    TODO:
       algorithm needs corrections for the resolution of
       integer numbers for unfound medial axis points 
       that are sometimes at a distance from the nearest
       boundary points that is off by 1 pixel from the
       distance to another nearest boundary point.
       - need to create a new method in k nearest or in
         nearest neighbors to handle returning not only the
         nearest single distance, but any that are 1 pixel 
         (sqrt(2), that is) from it.
       some of the logic to keep a single pixel wide
       medial axis will need to be edited and added to also.
    */
    
    /**
     * NOTE: use MedialAxis instead.  This class
     * needs improvements.
     * constructor containing all points in the area
     * and the bounding points.
     * (NOTE: in future may make a version that doesn't
     * need all interior points and uses an adaptive
     * sampling, but use case for now fits these arguments
     * better.).
     * 
     * @param shapePoints
     * @param boundaryPoints 
     */
    public MedialAxis1(final Set&lt;PairInt&gt; shapePoints,
<span class="fc" id="L131">        final Set&lt;PairInt&gt; boundaryPoints) {</span>

<span class="fc" id="L133">        this.nSampl = 6;</span>
        
<span class="fc" id="L135">        this.sepAng = Math.PI/(nSampl/2);    </span>
    
<span class="fc" id="L137">        this.sinePiDivN = Math.sin(Math.PI/nSampl);</span>
        
<span class="fc" id="L139">        this.points = new HashSet&lt;PairInt&gt;(shapePoints);</span>
        
<span class="fc" id="L141">        this.boundary = new HashSet&lt;PairInt&gt;(boundaryPoints);</span>
    
<span class="fc" id="L143">        points.removeAll(boundary);</span>
        
<span class="fc" id="L145">        minMaxXY = MiscMath.findMinMaxXY(boundary);</span>
 
<span class="fc" id="L147">        nInterior = points.size();</span>
        
<span class="fc" id="L149">        this.np = new NearestNeighbor2D(boundary, </span>
            minMaxXY[1], minMaxXY[3]);
        
<span class="fc" id="L152">        processed = new HashSet&lt;PairInt&gt;(points.size());</span>
        
<span class="fc" id="L154">        medAxisList = new ArrayList&lt;MedialAxisPoint&gt;();</span>
<span class="fc" id="L155">    }</span>
    
    /**
     * NOTE: use MedialAxis instead.  This class needs
     * improvements.
     * @param shapePoints
     * @param boundaryPoints
     * @param nPSrchCircle number of points to use 
     * on a search circle.  by default, this is 6
     * and that is the minimum allowed also.
     */
    public MedialAxis1(final Set&lt;PairInt&gt; shapePoints,
        final Set&lt;PairInt&gt; boundaryPoints, 
<span class="nc" id="L168">        int nPSrchCircle) {</span>
        
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (nPSrchCircle &lt; 6) {</span>
<span class="nc" id="L171">            throw new IllegalArgumentException(</span>
                &quot;nPSrchCircle must be 6 or larger&quot;);
        }
        
<span class="nc" id="L175">        this.nSampl = nPSrchCircle;</span>
        
<span class="nc" id="L177">        this.sepAng = Math.PI/(nSampl/2);</span>

<span class="nc" id="L179">        this.sinePiDivN = Math.sin(Math.PI/nSampl);</span>
        
<span class="nc" id="L181">        this.points = new HashSet&lt;PairInt&gt;(shapePoints);</span>
        
<span class="nc" id="L183">        this.boundary = new HashSet&lt;PairInt&gt;(boundaryPoints);</span>
    
<span class="nc" id="L185">        points.removeAll(boundary);</span>
        
<span class="nc" id="L187">        minMaxXY = MiscMath.findMinMaxXY(boundary);</span>
 
<span class="nc" id="L189">        nInterior = points.size();</span>
        
<span class="nc" id="L191">        this.np = new NearestNeighbor2D(boundary, </span>
            minMaxXY[1], minMaxXY[3]);
        
<span class="nc" id="L194">        processed = new HashSet&lt;PairInt&gt;(points.size());</span>
        
<span class="nc" id="L196">        medAxisList = new ArrayList&lt;MedialAxisPoint&gt;();</span>
<span class="nc" id="L197">    }</span>
    
    protected Set&lt;PairInt&gt; getNearestBoundaryPoints(PairInt p) {
<span class="nc" id="L200">        return np.findClosest(p.getX(), p.getY());</span>
    }
    
    protected double getSepAng() {
<span class="fc" id="L204">        return sepAng;</span>
    }
    protected int getNSampl() {
<span class="nc" id="L207">        return nSampl;</span>
    }

    /**
     * add mp to the heap, calculating a node key for it
     * that results in ordering by decreasing radius.
     * @param heap
     * @param mp 
     */    
    protected void addToHeap(Heap heap, MedialAxisPoint mp) {
        // constructing key out of the inverse of the distance
        // from medial axis point to it's nearest boundary point,
        // where max is max of maxx and maxy.
        // key is a long so will use a factor equal to max
        
<span class="fc" id="L222">        long max = Math.max(minMaxXY[1], minMaxXY[3]);</span>
        
<span class="fc" id="L224">        double r = mp.getBoundaryPoints()[0].getDistance();</span>
                
<span class="fc" id="L226">        double invR = 1./r;</span>
        
<span class="fc" id="L228">        long key = (long)Math.ceil(max * invR);</span>
        
<span class="fc" id="L230">        HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L231">        node.setData(mp);</span>
        
<span class="fc" id="L233">        heap.insert(node);</span>
<span class="fc" id="L234">    }</span>
    
    protected boolean assertPointTotals() {
<span class="nc" id="L237">        int nP1 = points.size();</span>
<span class="nc" id="L238">        int nP2 = processed.size();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if ((nP1 + nP2) == nInterior) {</span>
<span class="nc" id="L240">            return true;</span>
        }
<span class="nc" id="L242">        return false;</span>
    }
    
    protected boolean assertUniqueMedialAxesPoints() {
<span class="nc" id="L246">        Set&lt;PairInt&gt; mAPs = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        for (MedialAxis1.MedialAxisPoint mp : medAxisList) {</span>
<span class="nc" id="L248">            PairInt pp = mp.getCenter();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (mAPs.contains(pp)) {</span>
<span class="nc" id="L250">                return false;</span>
            }
<span class="nc" id="L252">            mAPs.add(pp);</span>
<span class="nc" id="L253">        }</span>
<span class="nc" id="L254">        return true;</span>
    }
    
    /**
     * find medial axis.  The results can be retrieved
     * with getMedialAxisPoints().
     * NOTE: the method is not yet fully tested so
     * resolution arguments are not yet available for use.
     */
    public void findMedialAxis() {
              
<span class="fc" id="L265">        medAxisList.clear();</span>
        
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (points.size() &lt; boundary.size()) {</span>
            // special handling for narrow search space
<span class="fc" id="L269">            searchEachPoint();</span>
<span class="fc" id="L270">            return;</span>
        }
        
        // max heap ordered by largest radius
<span class="fc" id="L274">        Heap q = new Heap();</span>
        
<span class="fc" id="L276">        Set&lt;PairInt&gt; addedM = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L277">        Set&lt;PairInt&gt; removed = null;</span>
        
        // also adds point(s) to the heap
<span class="fc" id="L280">        MedialAxisResults results = </span>
<span class="fc" id="L281">            findAndProcessFirstPoint(q, addedM);</span>
        
<span class="fc" id="L283">        int[] xSurf = new int[nSampl];</span>
<span class="fc" id="L284">        int[] ySurf = new int[nSampl];</span>
       
<span class="fc" id="L286">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L288">        int nIter = 0;</span>
        
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">        while (!q.isEmpty() &amp;&amp; (processed.size() &lt; nInterior)) {</span>

<span class="fc" id="L292">            nIter++;</span>
            
<span class="fc" id="L294">            HeapNode node = q.extractMin();</span>
            
<span class="fc" id="L296">            MedialAxisPoint mp = (MedialAxisPoint) node.getData();</span>
            
            /*
            for each medial axis point, search for other
            medial axis points within a radius defined as
            the distance to the nearest boundary point
            from mp.  the radius is used to sample the 
            circumference of a sphere at that distance.
            */
            
<span class="fc" id="L306">            PairInt p = mp.getCenter();</span>
            
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (visited.contains(p)) {</span>
<span class="nc" id="L309">                continue;</span>
            }
<span class="fc" id="L311">            visited.add(p);</span>
  
            // for each p, sample points at a radius r
            // and search for medial axis points around
            // those.  (note that searching p directly for
            // medial axis points is a less detailed complete
            // result than creating p2's and searching those.)
            
<span class="fc" id="L319">            double r = mp.getBoundaryPoints()[0].getDistance();</span>
<span class="pc bpc" id="L320" title="3 of 4 branches missed.">            assert(r != Double.MIN_VALUE);</span>
<span class="fc" id="L321">            int nSPoints = populateSurfacePoints(p, r,</span>
                xSurf, ySurf);
                        
<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (nSPoints == 0) {</span>
<span class="fc" id="L325">                removed = subtractFromPoints(p, r - 1);</span>
<span class="fc" id="L326">                processed.addAll(removed);</span>
<span class="pc bpc" id="L327" title="3 of 4 branches missed.">                assert(assertPointTotals());</span>

<span class="pc bpc" id="L329" title="1 of 4 branches missed.">                if (q.isEmpty() &amp;&amp; (points.size() &gt; 0)) {</span>
                    // choose another point from points and continue
                    // also adds point(s) to the heap
<span class="fc" id="L332">                    results = findAndProcessARemainingPoint(q, addedM);</span>
                }

<span class="pc bpc" id="L335" title="3 of 4 branches missed.">                assert(assertUniqueMedialAxesPoints());</span>
                
                continue;
            }
            
<span class="fc" id="L340">            log.info(&quot;nIter=&quot; + nIter + &quot; q.size=&quot; </span>
<span class="fc" id="L341">                + q.getNumberOfNodes() + </span>
<span class="fc" id="L342">                &quot; s.size=&quot; + processed.size()</span>
                + &quot; nInterior=&quot; + nInterior);

<span class="fc bfc" id="L345" title="All 2 branches covered.">            for (int i = 0; i &lt; nSPoints; ++i) {</span>
                
<span class="fc" id="L347">                PairInt p2 = new PairInt(xSurf[i], ySurf[i]);</span>
                
<span class="fc bfc" id="L349" title="All 2 branches covered.">                if (visited.contains(p2)) {</span>
<span class="fc" id="L350">                    continue;</span>
                }
                
<span class="fc" id="L353">                results = findMedialAxesNearPoint(p2, addedM);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (results == null) {</span>
<span class="fc" id="L355">                    PairInt bPoint = np.findClosest(p2.getX(), p2.getY())</span>
<span class="fc" id="L356">                        .iterator().next();</span>
<span class="fc" id="L357">                    double d = distance(bPoint.getX(), bPoint.getY(), p);</span>
<span class="fc" id="L358">                    processed.addAll(subtractFromPoints(p2, d - 1));                    </span>
<span class="pc bpc" id="L359" title="3 of 4 branches missed.">                    assert(assertPointTotals());</span>
                    
                    continue;
                }
                
<span class="pc bpc" id="L364" title="3 of 4 branches missed.">                assert(assertUniqueMedialAxesPoints());</span>
                
                // add to data structures, as above
<span class="fc bfc" id="L367" title="All 2 branches covered.">                for (MedialAxisPoint mp2 : results.medialAxes) {</span>
<span class="fc" id="L368">                    PairInt pp = mp2.getCenter();</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                    if (addedM.contains(pp)) {</span>
<span class="fc" id="L370">                        continue;</span>
                    }
<span class="fc" id="L372">                    addToHeap(q, mp2);</span>
<span class="fc" id="L373">                }</span>
                
<span class="fc" id="L375">                searchCenterPoint(results, addedM);</span>
        
<span class="fc bfc" id="L377" title="All 2 branches covered.">                for (MedialAxisPoint m : results.medialAxes) {</span>
<span class="fc" id="L378">                    PairInt pp = m.getCenter();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                    if (addedM.contains(pp)) {</span>
<span class="fc" id="L380">                        continue;</span>
                    }
<span class="fc" id="L382">                    addedM.add(pp);</span>
<span class="fc" id="L383">                    medAxisList.add(m);</span>
<span class="fc" id="L384">                }</span>
                         
<span class="fc" id="L386">                processed.addAll(subtractFromPoints(results.center,</span>
                    results.centerSrchR - 1));
                
<span class="pc bpc" id="L389" title="3 of 4 branches missed.">                assert(assertPointTotals());</span>
<span class="pc bpc" id="L390" title="3 of 4 branches missed.">                assert(assertUniqueMedialAxesPoints());</span>
            }
             
<span class="pc bpc" id="L393" title="3 of 4 branches missed.">            assert(assertUniqueMedialAxesPoints());</span>
        
<span class="fc" id="L395">            log.info(&quot;q.n=&quot; + q.getNumberOfNodes() +</span>
<span class="fc" id="L396">                &quot; points.size=&quot; + points.size());</span>
            
<span class="pc bpc" id="L398" title="1 of 4 branches missed.">            if (q.isEmpty() &amp;&amp; (points.size() &gt; 0)) {</span>
                // choose another point from points and continue
                // also adds point(s) to the heap
<span class="fc" id="L401">                results = findAndProcessARemainingPoint(q, addedM);</span>
            
<span class="pc bpc" id="L403" title="3 of 4 branches missed.">                assert(assertUniqueMedialAxesPoints());</span>
            }
<span class="fc" id="L405">        }</span>
        
<span class="fc" id="L407">        log.info(&quot;med axis nIter=&quot; + nIter);</span>
        
<span class="pc bpc" id="L409" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());</span>

<span class="fc" id="L411">        addedM = null;</span>
        
        // iterate over medial axis points to refine centers.
        // dither should be defined by the tolerance tol
<span class="fc" id="L415">        Set&lt;PairInt&gt; srch = refineCentersOfMedAxisList();</span>
        
<span class="pc bpc" id="L417" title="3 of 4 branches missed.">        assert(assertPointTotals());</span>
<span class="pc bpc" id="L418" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());</span>

        // ----- code to fill in gaps using a DFS search --- 
<span class="fc" id="L421">        fillInGaps(srch);</span>
        
<span class="pc bpc" id="L423" title="3 of 4 branches missed.">        assert(assertPointTotals());</span>
<span class="pc bpc" id="L424" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());</span>
     
<span class="fc" id="L426">   }</span>

    protected List&lt;MedialAxisPoint&gt; getMedAxisList() {
<span class="fc" id="L429">        return medAxisList;</span>
    }
    
    /**
     * get the calculated medial axis point as a set of
     * unordered points.
     * @return 
     */
    public Set&lt;PairInt&gt; getMedialAxisPoints() {
<span class="fc" id="L438">        Set&lt;PairInt&gt; mAPs = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        for (MedialAxis1.MedialAxisPoint mp : medAxisList) {</span>
<span class="fc" id="L440">            mAPs.add(mp.getCenter());</span>
<span class="fc" id="L441">        }</span>
<span class="fc" id="L442">        return mAPs;</span>
    }

    /**
     * find an initial point to begin the search.
     * The point has a circle of radius = distance
     * to nearest boundary point.  That circle
     * intersects with at least one medial axis 
     * point.
     * @return 
     */
    private MedialAxisResults findInitialPoint(Set&lt;PairInt&gt; addedM) {
    
<span class="fc" id="L455">        PairInt p = points.iterator().next();</span>
        
<span class="fc" id="L457">        return findMedialAxesNearPoint(p, addedM);</span>
    }
    
    /**
     * Find a point which has a circle of radius = distance
     * to nearest boundary point, and that circle
     * intersects with at least one medial axis 
     * point. Note that if the original point does not
     * have medial axis point in the points sampled at
     * that radius, a search pattern is used to change
     * the point center until a point meeting the goals
     * is found or until all search variants have failed.
     * Failure can occur when the instance set &quot;processed&quot;
     * contains most of the points and the instance set
     * &quot;points&quot; is nearly empty.
     * 
     * @return 
     */
    protected MedialAxisResults findMedialAxesNearPoint(PairInt p,
        Set&lt;PairInt&gt; addedM) {
    
<span class="fc" id="L478">        log.info(&quot;++srch for medial axis near p=&quot; + p);</span>
        
<span class="fc" id="L480">        List&lt;MedialAxisPoint&gt; medialAxes </span>
            = new ArrayList&lt;MedialAxisPoint&gt;();
        
<span class="fc" id="L483">        PairInt[] closestB = findNearestBoundsAsArray(</span>
<span class="fc" id="L484">            p.getX(), p.getY());</span>
        
<span class="pc bpc" id="L486" title="3 of 4 branches missed.">        assert(closestB.length &gt; 0);</span>
        
<span class="fc" id="L488">        int status = 0;</span>
        
        // find a p that results in valid medial axis points,
        // and update the closestB for it
        
<span class="fc" id="L493">        status = intersectsMedialAxis(closestB, p, medialAxes);</span>

<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (status == -3) {</span>

<span class="nc" id="L497">            throw new IllegalStateException(&quot;Error in algorithm:&quot;</span>
                + &quot; could not find a nearest boundary for &quot; +
<span class="nc" id="L499">                p.toString());</span>

<span class="fc bfc" id="L501" title="All 2 branches covered.">        } else if (status == -2) {</span>

            //status==-2: no medial axis angle larger than threshold was found

<span class="fc" id="L505">            PairInt origP = p.copy();</span>
           
            /*
            NOTES from paper:
            may need to revisit this while testing:
            If the new medial axis segment is significantly
            different from normal to the previous,
            then start 2 searches, 1 perpendicular to the previous
            medial axis center and 1 perp to the current medial
            axis.  the points should be away from the
            smallest angle between the old and new segments.            
            */
            
<span class="fc" id="L518">            log.info(&quot;++STATUS=-2 for p=&quot; + p);</span>
           
<span class="fc" id="L520">            int cIdx = 0;</span>
            
            // in case the algorithm fails and has a dx=0 or dy=0
            // this allows a retry and override of the zero variable
<span class="fc" id="L524">            boolean overrideDXY = false;</span>
            
<span class="pc bpc" id="L526" title="1 of 4 branches missed.">            while (status != 1 &amp;&amp; (cIdx &lt; closestB.length)) {</span>
                
<span class="fc" id="L528">                medialAxes.clear();</span>
 
<span class="fc" id="L530">                PairInt bPoint = closestB[cIdx];</span>

<span class="fc" id="L532">                double r = distance(bPoint.getX(), bPoint.getY(), p);</span>

                /*from bPoint to p, scale offsets by new r:
                 diffX = (p.x - b.x)/r
                 diffY = (p.y - b.y)/r
                 p2.x = p.x + (diffX * r2)
                 p2.y = p.y + (diffY * r2)
                */
<span class="fc" id="L540">                double diffX = (p.getX() - bPoint.getX())/r;</span>
<span class="fc" id="L541">                double diffY = (p.getY() - bPoint.getY())/r;</span>
                
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">                if (cIdx == 0) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if (overrideDXY) {</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                        if (diffX == 0) {</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                            diffX = (p.getX() - bPoint.getX()) &lt; 0 ?</span>
                                1 : -1;
                        } else {
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                            diffY = (p.getY() - bPoint.getY()) &lt; 0 ?</span>
                                1 : -1;
                        }
                    }
                }
                
<span class="fc" id="L555">                cIdx++;</span>

<span class="fc" id="L557">                log.info(&quot;++origP=&quot; + origP + &quot; nbp[i]=&quot; + bPoint + &quot; r=&quot; + r</span>
                    + &quot; dx=&quot; + diffX + &quot; dy=&quot; + diffY);

                int low, high;
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (status == -2) {</span>
<span class="fc" id="L562">                    low = (int)Math.round(r);</span>
                    // guestimate w/ half of xMax or yMax
<span class="fc" id="L564">                    high = (int)Math.round(0.5 * </span>
<span class="fc" id="L565">                        Math.max(minMaxXY[1], minMaxXY[3]));</span>
                } else {
<span class="fc" id="L567">                    low = 1;</span>
<span class="fc" id="L568">                    high = (int)Math.round(r);</span>
                }
<span class="fc" id="L570">                int mid = (int)Math.round(0.5 * (high + low));</span>

<span class="fc" id="L572">                log.info(&quot;++init:  mid=&quot; + mid + &quot; low=&quot; + low + &quot; high=&quot; + high);</span>

                // choose another circle center by choosing the point
                // on the circle around p which is opposite the nearest
                // boundary point.

<span class="fc bfc" id="L578" title="All 2 branches covered.">                while (low &lt; high) {</span>
<span class="fc" id="L579">                    mid = (int)Math.round(0.5 * (high + low));</span>
                    // create new p from mid distance from b along path to p
<span class="fc" id="L581">                    int x2 = p.getX() + (int)Math.round(diffX * mid);</span>
<span class="fc" id="L582">                    int y2 = p.getY() + (int)Math.round(diffY * mid);</span>
<span class="fc" id="L583">                    PairInt p2 = new PairInt(x2, y2);</span>
                    
<span class="fc" id="L585">                    log.info(&quot;++   p2=&quot; + p2 + &quot; mid=&quot; + mid + &quot; low=&quot; + low + &quot; high=&quot; + high);</span>
             
<span class="fc bfc" id="L587" title="All 2 branches covered.">                    if (addedM.contains(p2)) {</span>
<span class="fc" id="L588">                        status = -10;</span>
<span class="fc" id="L589">                        break;</span>
                    }
                    
                    //TODO: consider removing if processed here
<span class="fc bfc" id="L593" title="All 4 branches covered.">                    if ((points.contains(p2) || processed.contains(p2))) {</span>
                        
                        // check if point intersects medial axis
                        // and if so, exit loop
<span class="fc" id="L597">                        PairInt[] closestB2 = findNearestBoundsAsArray(p2.getX(), p2.getY());</span>
<span class="fc" id="L598">                        status = intersectsMedialAxis(closestB2, p2, medialAxes);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                        if (status == 1) {</span>
<span class="fc" id="L600">                            p = p2;</span>
<span class="fc" id="L601">                            closestB = closestB2;</span>
<span class="fc" id="L602">                            break;</span>
                        }
                    }
<span class="fc bfc" id="L605" title="All 2 branches covered.">                    if (high == mid) {</span>
<span class="fc" id="L606">                        high -= 1;</span>
                    } else {
<span class="fc" id="L608">                        high = mid;</span>
                    }
<span class="fc" id="L610">                } // end loop low&lt;high</span>
            
                // if srch unsuccessful, throw error or retry
<span class="fc bfc" id="L613" title="All 2 branches covered.">                if (status != 1) {</span>
<span class="fc bfc" id="L614" title="All 6 branches covered.">                    if (!overrideDXY &amp;&amp; (diffX == 0 || diffY == 0)) {</span>
<span class="fc" id="L615">                        cIdx = 0;</span>
<span class="fc" id="L616">                        overrideDXY = true;</span>
                    } else {
<span class="fc" id="L618">                        log.info(&quot;++Possible Error in algorithm:&quot;</span>
                        + &quot; could not find a valid medial axis&quot;
                        + &quot; point from the random first point.&quot;);
                        //NOTE: in one case, p2 was a valid med axis
                        // pt but was already processed.
<span class="fc" id="L623">                        return null;</span>
                    }
                }
                // end of binary search to change circle center
<span class="fc" id="L627">            }</span>
        }

<span class="fc" id="L630">        MedialAxisResults results = new MedialAxisResults();</span>
<span class="fc" id="L631">        results.medialAxes = medialAxes;</span>
<span class="fc" id="L632">        results.center = p;</span>
<span class="fc" id="L633">        results.centerSrchR = </span>
<span class="fc" id="L634">            distance(p.getX(), p.getY(), closestB[0]);</span>
        
<span class="fc" id="L636">        return results;</span>
        
        /*
        From &quot;Efficient Computation of A Simplified Medial Axis&quot;
        by Foskey, Lin, and Manocha.
        
        separation angle is the maximum angle formed 
        by the vectors connecting the medial axis 
        point x to its closest points on the boundary,
        and portions of the medial axis with a larger 
        separation angle tend to be more stable. 
        
        If there is more than two nearest points,
        then the maximum of the separation angles is used
        
        N_x is neighbor direction field.
        N_x = the direction of vector difference
            as (boundaryP - medialP vectors)/|(boundaryP - medialP)|

        two points medialP1 and medialP2 are on opposite
        sides of a medial axis sheet if N_x(medialP1) and
        N_x(medialP2) diverge.
        
        for a pair of points, calc angle between direction
        vectors N_x.
        if angle is &lt; threshold, reject the pair.
        else
            check for false positives
                for example:
             reflex vertex for the nearest neighbor boundary point.
                both direction vectors converge towards vertex.
                if points are close to the vertex,
                the angle between them, is large even
                though the 2 points are not on oppos sides
                of a medial axis.  Tp avoid this error,
                check that the distance between the heads of
                the vectors is at least as large as the tails
                of the vectors.

                medialP1         medialP2
                   * tail of vectors  *

                           * head of vectors for false medial axis points due to reflex.
                           /\
               ___________/  \__________
        
 ===&gt; this check for reflex points looks like it has to be
      done after several or all medial axis points have
      been found, not just as two are added.
        
        two different spatial subdivision schemes can be used:
         -- uniform grid
            simplest and is fast using distance fields.
            3D is handled as a slice for each z, and each 2D is handled:
            the area is divided in axis aligned grid.
            the distance field is scalar function: D_X of real numbers.
            it's determined by lower envelope (or minima) of all D_X_i.
         -- adaptive grid
            - an octree, for example.
         -- I'll use my static nearest neighbors
         whichever scheme is used, once a pair is found
         that satisfies the separation criteria,
         add it to the medial axis
         (need to design the medial axis and nodes.
         a node needs its coordinates, vectors from boundary
            and possibly the parent node which is the node
            adjacent to it that this one is derived from)
        
         More on the separation angle criteria:
            the distance from the candidate medial
            axis point to the nearest boundary point 
            should be much larger than the separation 
            of the adjacent boundary points...       

        -----------
        
    identifying medial axis points:
        U = uniformly distributed sample points on surface of sphere
        
        separation angle criteria:
            For a point on the sphere, the angle is defined
            as the angle between the nearest point on the 
            boundary and the nearest point on the other boundary.
            -- the authors here use 2 points on the sphere
               instead and the third point is the closest 
               point for them on the boundary
               (which should be the same point for them).
               the angle subtended by the third point
               is maximum for the point on the medial axis.
               if that angle is larger than a threshold
               theta t, the midpoint between them becomes
               the aMA point.
    
    note:
       for uniformly sampled points,
       the angle delta theta between 2 neighboring
       points (e.g. q1p1, q1p2) is 2*pi/N.
       and the distance between them is 2 * r * sin(pi/N).
       
       The absolute error is then eps_a = r * sin(pi/N).
    
       reversing that, one gets the number of points on
       a sphere: N = pi/(arcsin(eps_a/r))
    
       The relative error needs to locate the closest
       point on the sphere to the medial axis, 
       which can name q1 and m, respectively.
          eps_r = delta(q1) * sin(pi/N)
    
       with triangle inequality, have 
       eps_a/(delta(q1)+eps_a) &lt; eps_a/delta(m) &lt;= eps_a/delta(q1)
    
       if r &lt;= delta(q1), can select N with:
          N = pi/arcsin(eps_r)
       else if r &gt;= delta(q1), can select N with:
          N = pi/arcsin(eps_r * r /delta(q1))
    
       Given N, origin of sphere, and r, can calculate
         p_i x: origin_x + r * cos(2*pi*i/N)
             y: origin_y + r * sin(2*pi*i/N)
    
    
       Given an absolute error eps_a, 
       the algorithm will stop if the maximum delta(p) 
       of all sample points p is smaller than eps_a. 
       For a relative error eps_r, the algorithm will 
       terminate if the radius of all spheres is 
       smaller than the threshold Ke. 
       For this case using relative error, 
       the size of the largest &quot;missed area&quot; gate which 
       depends on the amount of local free space.
      */
   
    }
    
    /**
     * subtract the points in set &quot;points&quot; found within
     * a radius of center from set.
     * @param center
     * @param radius
     * @return 
     */
    protected Set&lt;PairInt&gt; subtractFromPoints(PairInt center,
        double radius) {
        
<span class="fc" id="L781">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L783">        extractFromPoints(center, radius, output);</span>
        
<span class="fc" id="L785">        points.removeAll(output);</span>
        
<span class="fc" id="L787">        return output;</span>
    }
    
    /**
     * extract points from instance set &quot;points&quot; that are
     * within radius of center.
     * NOTE: that this class is still being tested.
     * For very complex shapes, this might be removing
     * points that need to searched that were not sampled
     * in the uniform sampling model (might need to use
     * the adaptive sampling).
     * 
     * @param center
     * @param radius
     * @param output 
     */
    protected void extractFromPoints(PairInt center,
        double radius, Set&lt;PairInt&gt; output) {
         
<span class="fc" id="L806">        Stack&lt;PairInt&gt; stack = new Stack&lt;PairInt&gt;();</span>
<span class="fc" id="L807">        stack.add(center);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (points.contains(center)) {</span>
<span class="fc" id="L809">            output.add(center);</span>
        }
        
<span class="fc" id="L812">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L813">        int[] dys = Misc.dy8;</span>
        
<span class="fc" id="L815">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L817" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
<span class="fc" id="L818">            PairInt p = stack.pop();</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">            if (visited.contains(p)) {</span>
<span class="fc" id="L820">                continue;</span>
            }
<span class="fc" id="L822">            visited.add(p);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L824">                int x2 = p.getX() + dxs[k];</span>
<span class="fc" id="L825">                int y2 = p.getY() + dys[k];</span>
<span class="pc bpc" id="L826" title="4 of 8 branches missed.">                if (x2 &lt; minMaxXY[0] || y2 &lt; minMaxXY[2] || (x2 &gt; minMaxXY[1])</span>
                    || (y2 &gt; minMaxXY[3])) {
<span class="nc" id="L828">                    continue;</span>
                }
<span class="fc" id="L830">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">                if (!points.contains(p2)) {</span>
<span class="fc" id="L832">                    continue;</span>
                }
<span class="fc" id="L834">                double dist = distance(x2, y2, center);</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">                if (dist &lt;= radius) {</span>
<span class="fc" id="L836">                    output.add(p2);</span>
<span class="fc" id="L837">                    stack.add(p2);</span>
                }
            }
<span class="fc" id="L840">        }        </span>
<span class="fc" id="L841">    }</span>
    
    /*
    for uniformly sampled points,
       the angle delta theta between 2 neighboring
       points (e.g. q1p1, q1p2) is 2*pi/N.
       and the distance between them is 2 * r * sin(pi/N).
       
       The absolute error is then eps_a = r * sin(pi/N).
    
       reversing that, one gets the number of points on
       a sphere: N = pi/(arcsin(eps_a/r))
    */
    
    /*
    input:  
       perimeter points
       interior points
    
    -- first primitive operation:
        identifies an initial point m and associated 
        distance delta(m), such that the resulting 
        sphere of radius delta(m) around m intersects 
        the medial axis. 
    
    -- second primitive operation: 
        given a solid D, a set of points P in the 
        interior of D and their direction vectors, 
        for each point p ∈ P, this method identifies 
        that point on the medial axis of D which 
        is closest to p.
    
    These primitives will be described after we 
    have detailed the algorithm of computing the aMA.
Assume point m lies on the medial axis and is 
    distance δ(m) away from the closest obstacle. 
    This point is determined using aforementioned 
    primitive. A priority queue Q is initialized
    to contain the sphere de- scribed by point m 
    and radius δ(m). The set S of spheres describing 
    the free space inside the solid D is initialized 
    to be the empty set.
    
    
    */
    
    /**
     * populate surfaceX and surfaceY with nSampl number of
     * points that are a distance r from center p.
     * Note that redundant points are removed and any points
     * that are in the instance set &quot;processed&quot;.
     * The number of usable items in surfaceX and surfaceY
     * are the return argument.
     * @param p
     * @param r
     * @param surfaceX an empty array of size nSampl
     * @param surfaceY an empty array of size nSampl
     * @return 
     */
    protected int populateSurfacePoints(PairInt p, double r,
        int[] surfaceX, int[] surfaceY) {
        
<span class="fc" id="L903">        int ns = 0;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">        for (int i = 0; i &lt; surfaceX.length; ++i) {</span>
<span class="fc" id="L905">            double t = 2. * twoPI * (double)i/(double)nSampl;</span>
<span class="fc" id="L906">            int x1 = p.getX() + (int)Math.round(r * Math.cos(t));</span>
<span class="fc" id="L907">            int y1 = p.getY() + (int)Math.round(r * Math.sin(t));</span>
<span class="fc bfc" id="L908" title="All 8 branches covered.">            if (x1 &lt; minMaxXY[0] || (x1 &gt; minMaxXY[1]) ||</span>
                y1 &lt; minMaxXY[2] || (y1 &gt; minMaxXY[3])) {
<span class="fc" id="L910">                continue;</span>
            }
<span class="pc bpc" id="L912" title="1 of 6 branches missed.">            if ((ns &gt; 0) &amp;&amp; (x1 == surfaceX[ns - 1]) &amp;&amp; (y1 ==</span>
                surfaceY[ns - 1])) {
<span class="nc" id="L914">                continue;</span>
<span class="pc bpc" id="L915" title="1 of 8 branches missed.">            } else if ((i == (nSampl - 1)) &amp;&amp; (ns &gt; 0) &amp;&amp; </span>
                (x1 == surfaceX[0]) &amp;&amp; (y1 == surfaceY[0])) {
<span class="nc" id="L917">                continue;</span>
            }
            // also, do not include space already searched in &quot;processed&quot;
<span class="fc" id="L920">            PairInt sp = new PairInt(x1, y1);</span>
<span class="fc bfc" id="L921" title="All 4 branches covered.">            if (processed.contains(sp) || boundary.contains(sp)) {</span>
<span class="fc" id="L922">                continue;</span>
            }
            
<span class="fc" id="L925">            surfaceX[ns] = x1;</span>
<span class="fc" id="L926">            surfaceY[ns] = y1;</span>
            
<span class="fc" id="L928">            ns++;</span>
        }
        
<span class="fc" id="L931">        return ns;</span>
    }
    
    /**
     * finds the medial axis points if p intersects medial axis.
     * @param nearestBounds
     * @param p
     * @param output 
     * @return code for result: 
     * -3 means there are no nearest boundary points;
     * -2 means no medial axis angle larger than threshold was found;
     * 1 means successfully found the medial axis points
     * and placed them in output.
     */
    protected int intersectsMedialAxis(PairInt[] nearestBounds, 
        PairInt p, List&lt;MedialAxisPoint&gt; output) {
        
<span class="pc bpc" id="L948" title="2 of 4 branches missed.">        if (nearestBounds == null || nearestBounds.length == 0) {</span>
<span class="nc" id="L949">            return -3;</span>
        }
        
<span class="fc" id="L952">        output.clear();</span>
        
<span class="fc" id="L954">        PairInt bPoint = nearestBounds[0];</span>
        
<span class="fc" id="L956">        double r = distance(bPoint.getX(), bPoint.getY(), p);</span>
        
        // might need to increase this to 2*
<span class="fc" id="L959">        int tol = (int)Math.ceil(r * sinePiDivN);</span>
<span class="fc" id="L960">        double threshold = 0.5 * sinePiDivN;</span>
     
<span class="fc" id="L962">        log.info(&quot;p=&quot; + p.toString() + &quot; a nearest boundary=&quot;</span>
<span class="fc" id="L963">            + bPoint.toString() + &quot; r=&quot; + r </span>
<span class="fc" id="L964">            + String.format(&quot; tol=%d pix  sinePiDivN=%.4f&quot;, </span>
<span class="fc" id="L965">                tol, sinePiDivN));       </span>
        
        // create uniformly sampled circles
        // and check that all points are within bounds
        
<span class="fc" id="L970">        int[] surfaceX = new int[nSampl];</span>
<span class="fc" id="L971">        int[] surfaceY = new int[nSampl];</span>
<span class="fc" id="L972">        int ns = populateSurfacePoints(p, r, surfaceX, surfaceY);</span>
        
        /*
        since nearestBounds are all equidistant, can
        choose one of them as the corner of a triangle.
        
        for each pair of circle surface points, measuring
        the angle subtended by them and the boundary point
        to find the maximum angle above threshold.
        */
        
        // there may be more than one medial axis point,
        // for example, the circle enscribed in an open
        // triangle has one near the vertex side of circle
        // and on opposite side
<span class="fc" id="L987">        TIntList surfIdxes1 = new TIntArrayList();</span>
<span class="fc" id="L988">        TIntList surfIdxes2 = new TIntArrayList();</span>
        // tracking PairInt[] combinedNBP w/ key = index to surfIdxes1
<span class="fc" id="L990">        TIntObjectMap&lt;PairInt[]&gt; surfNBMap = new TIntObjectHashMap&lt;PairInt[]&gt;();</span>
        
        // keeping a map of indexes and angles
        // in case adjacent pair passed filters.  keep latgest angle
<span class="fc" id="L994">        TIntDoubleMap indexAngleMap = new TIntDoubleHashMap();</span>
        
<span class="fc bfc" id="L996" title="All 2 branches covered.">        for (int i = 0; i &lt; ns; ++i) {</span>
<span class="fc" id="L997">            int x1 = surfaceX[i];</span>
<span class="fc" id="L998">            int y1 = surfaceY[i];</span>
            int idx2;
<span class="fc bfc" id="L1000" title="All 2 branches covered.">            if (i &lt; (ns - 1)) {</span>
<span class="fc" id="L1001">                idx2 = i + 1;</span>
            } else {
<span class="fc" id="L1003">                idx2 = 0;</span>
            }
<span class="fc" id="L1005">            int x2 = surfaceX[idx2];</span>
<span class="fc" id="L1006">            int y2 = surfaceY[idx2];</span>
            
            /* law of cosines:  cosine A = (b^2 + c^2 - a^2)/2bc
              B   a   C
                c   b
                  A
            
            where B and C and the circle surface points
            and A is the boundary point.
            
            a, b, and c are the lengths of the segments
            between the surrounding points (B,C), (C,A),
            and (A,B) respectively.
            
            Note that c and b must be much larger than a.
            */
            
<span class="fc" id="L1023">            double cSq = distanceSq(x1, y1, nearestBounds[0].getX(),</span>
<span class="fc" id="L1024">                nearestBounds[0].getY());</span>
            
<span class="fc" id="L1026">            double bSq = distanceSq(x2, y2, nearestBounds[0].getX(),</span>
<span class="fc" id="L1027">                nearestBounds[0].getY());</span>
            
<span class="fc" id="L1029">            double aSq = distanceSq(x1, y1, x2, y2);</span>
            
<span class="fc bfc" id="L1031" title="All 4 branches covered.">            if (cSq &lt; aSq || bSq &lt; aSq) {</span>
<span class="fc" id="L1032">                log.info(String.format(&quot;REMOVED1 (%d,%d) (%d,%d)&quot;, </span>
<span class="fc" id="L1033">                    x1, y1, x2, y2));</span>
<span class="fc" id="L1034">                continue;</span>
            }
            
            //cosine A = (b^2 + c^2 - a^2)/2bc
<span class="fc" id="L1038">            double cosA = (bSq + cSq - aSq)/(2 * Math.sqrt(bSq * cSq));</span>
            
<span class="fc" id="L1040">            final double angleA = Math.acos(cosA);</span>
    
<span class="fc bfc" id="L1042" title="All 2 branches covered.">            if (angleA &lt; threshold) {</span>
<span class="fc" id="L1043">                log.info(String.format(&quot;REMOVED2 angleA=%.4f (%d,%d) (%d,%d)&quot;, </span>
<span class="fc" id="L1044">                    (float)angleA, x1, y1, x2, y2));</span>
<span class="fc" id="L1045">                continue;</span>
            }
            
<span class="fc" id="L1048">            log.info(String.format(&quot;angle=%.4f (%d,%d) (%d,%d) i=[%d,%d]&quot;, </span>
<span class="fc" id="L1049">                (float)angleA, x1, y1, x2, y2, i, idx2));</span>
            
            /*
            figure 2 of the paper suggests that with a fast nearest 
            neighbors for the boundary points,
            find the nearest for 
            (x1, y1) and (x2, u2) and if they are 
            roughly equivalent (no tolerance is mentioned or shown),
            then one would take the average of the
            2 points as a medial axis point unless they 
            both point to a reflex point.
            */
   
<span class="fc" id="L1062">            List&lt;PairInt&gt; combinedNBP = </span>
<span class="fc" id="L1063">                haveEquidistantNearestPoints(x1, y1, x2, y2, tol);</span>
        
<span class="fc bfc" id="L1065" title="All 2 branches covered.">            if (combinedNBP != null) {</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">                if (indexAngleMap.containsKey(i)) {</span>
<span class="fc" id="L1067">                    double prevAngle = indexAngleMap.get(i);</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                    if (prevAngle &gt; angleA) {</span>
<span class="fc" id="L1069">                        continue;</span>
                    }
                }
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                if (indexAngleMap.containsKey(idx2)) {</span>
<span class="fc" id="L1073">                    double prevAngle = indexAngleMap.get(idx2);</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">                    if (prevAngle &gt; angleA) {</span>
<span class="nc" id="L1075">                        continue;</span>
                    }
                }
                
                // TODO: consider using a small tolerance for same
                //   angle decision here:
<span class="fc bfc" id="L1081" title="All 2 branches covered.">                if ((indexAngleMap.containsKey(i) &amp;&amp; </span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">                    (indexAngleMap.get(i) == angleA)) ||</span>
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">                    (indexAngleMap.containsKey(idx2) &amp;&amp; </span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                    (indexAngleMap.get(idx2) == angleA))    </span>
                    ) {
                    // should choose the outer numbers of both
<span class="fc" id="L1087">                    int nPrev = surfIdxes1.size() - 1;</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">                    if (surfIdxes2.get(nPrev) == i) {</span>
                        // replace 2nd number w/ current idx2
<span class="fc" id="L1090">                        int prevIdx2 = surfIdxes2.get(nPrev);</span>
<span class="fc" id="L1091">                        indexAngleMap.remove(prevIdx2);</span>
<span class="fc" id="L1092">                        indexAngleMap.put(idx2, angleA);</span>
<span class="fc" id="L1093">                        surfIdxes2.set(nPrev, idx2);</span>
<span class="fc" id="L1094">                        surfNBMap.put(nPrev, combinedNBP.toArray(</span>
<span class="fc" id="L1095">                            new PairInt[combinedNBP.size()]));</span>
<span class="fc" id="L1096">                        continue;</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                    } else if (surfIdxes2.get(0) == i) {</span>
<span class="nc" id="L1098">                        int prevIdx2 = surfIdxes2.get(0);</span>
<span class="nc" id="L1099">                        indexAngleMap.remove(prevIdx2);</span>
<span class="nc" id="L1100">                        indexAngleMap.put(idx2, angleA);</span>
<span class="nc" id="L1101">                        surfIdxes2.set(0, idx2);</span>
<span class="nc" id="L1102">                        surfNBMap.put(0, combinedNBP.toArray(</span>
<span class="nc" id="L1103">                            new PairInt[combinedNBP.size()]));</span>
<span class="nc" id="L1104">                        continue;</span>
                    }
                }
<span class="fc" id="L1107">                surfNBMap.put(surfIdxes1.size(), combinedNBP.toArray(</span>
<span class="fc" id="L1108">                    new PairInt[combinedNBP.size()]));</span>
<span class="fc" id="L1109">                surfIdxes1.add(i);</span>
<span class="fc" id="L1110">                surfIdxes2.add(idx2);</span>
<span class="fc" id="L1111">                indexAngleMap.put(i, angleA);</span>
<span class="fc" id="L1112">                indexAngleMap.put(idx2, angleA);</span>
            
<span class="fc" id="L1114">                log.info(&quot;  &lt;-- prev is a med axis pt&quot;);</span>
            }
        }       
        
<span class="fc bfc" id="L1118" title="All 2 branches covered.">        if (surfIdxes1.isEmpty()) {</span>
<span class="fc" id="L1119">            return -2;</span>
        }
        
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        for (int i = 0; i &lt; surfIdxes1.size(); ++i) {</span>
<span class="fc" id="L1123">            int idx1 = surfIdxes1.get(i);</span>
<span class="fc" id="L1124">            int idx2 = surfIdxes2.get(i);</span>
            
<span class="fc" id="L1126">            int avgX = Math.round(0.5f*(surfaceX[idx1] + surfaceX[idx2]));</span>
<span class="fc" id="L1127">            int avgY = Math.round(0.5f*(surfaceY[idx1] + surfaceY[idx2]));</span>
<span class="fc" id="L1128">            PairInt medialP = new PairInt(avgX, avgY);</span>

<span class="fc bfc" id="L1130" title="All 4 branches covered.">            if (!(points.contains(medialP) || processed.contains(medialP))) {</span>
<span class="fc" id="L1131">                continue;</span>
            }
            
<span class="fc" id="L1134">            PairInt[] nearB = surfNBMap.get(i);</span>
            
<span class="fc" id="L1136">            MedialAxisPoint mp = createMedialAxisPoint(medialP,</span>
                nearB, r);
            
<span class="fc" id="L1139">            output.add(mp);</span>
        }
        
        /*
        More on the separation angle criteria:
            the distance from the candidate medial
            axis point to the nearest boundary point 
            should be much larger than the separation 
            of the adjacent boundary points...
        
        separation angle criteria:
            For a point on the sphere, the angle is defined
            as the angle between the nearest point on the 
            boundary and the nearest point on the other boundary.
            -- the authors Yang, Brock, and Moll  
               use 2 points on the sphere instead and the third 
               point is the closest point for them on the boundary
               (which should be the same point for them).
               the angle subtended by the third point
               is maximum for the point on the medial axis.
               if that angle is larger than a threshold
               theta t, the midpoint between them becomes
               the aMA point.
        */

<span class="fc" id="L1164">        return 1;</span>
    }
     
    /**
     * calculate euclidean distance between (x,y) and point p.
     * @param x
     * @param y
     * @param p
     * @return 
     */
    protected double distance(int x, int y, PairInt p) {
<span class="fc" id="L1175">        int diffX = x - p.getX();</span>
<span class="fc" id="L1176">        int diffY = y - p.getY();</span>
<span class="fc" id="L1177">        double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>
<span class="fc" id="L1178">        return dist;</span>
    }
    
    /**
     * calculate the square of the euclidean distance
     * between (x1,y1) and (x2, y2)
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @return 
     */
    protected double distanceSq(int x1, int y1, int x2, int y2) {
<span class="fc" id="L1191">        int diffX = x1 - x2;</span>
<span class="fc" id="L1192">        int diffY = y1 - y2;</span>
<span class="fc" id="L1193">        return (diffX * diffX + diffY * diffY);</span>
    }

    /**
     * compare the nearest boundary points of (x1, y1)
     * and (x2, y2) and return those that were the
     * same distance from the respective points and
     * not the same direction vectors.
     * 
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param tol
     * @return 
     */
    private List&lt;PairInt&gt; haveEquidistantNearestPoints(
        int x1, int y1, int x2, int y2, int tol) {
        
<span class="fc" id="L1212">        PairInt[] np1 = findNearestBoundsAsArray(x1, y1);</span>
<span class="fc" id="L1213">        PairInt[] np2 = findNearestBoundsAsArray(x2, y2);</span>
       
<span class="fc" id="L1215">        List&lt;PairInt&gt; output = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        for (int i = 0; i &lt; np1.length; ++i) {</span>
<span class="fc" id="L1218">            PairInt p1 = np1[i];</span>
<span class="fc" id="L1219">            double dist1 = distance(x1, y1, p1);</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">            for (int j = 0; j &lt; np2.length; ++j) {</span>
<span class="fc" id="L1221">                PairInt p2 = np2[j];</span>
                
                //TODO: check this exclusion:
<span class="fc bfc" id="L1224" title="All 2 branches covered.">                if (p1.equals(p2)) {</span>
<span class="fc" id="L1225">                    continue;</span>
                }
<span class="fc" id="L1227">                double dist2 = distance(x2, y2, p2);</span>
<span class="fc" id="L1228">                log.info(&quot;   dist diff=&quot; + </span>
<span class="fc" id="L1229">                    Math.abs(dist1 - dist2) + &quot; dist1=&quot; + dist1 </span>
                    + &quot; dist2=&quot; + dist2);
<span class="fc bfc" id="L1231" title="All 6 branches covered.">                if ((dist1 == dist2) || ((dist1 &gt; tol &amp;&amp; dist2 &gt; tol) &amp;&amp;</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                    (Math.abs(dist1 - dist2) &lt;= tol))) {</span>
<span class="fc" id="L1233">                    int[] dir1 = calculateNeighborDirection(x1, y1, p1);</span>
<span class="fc" id="L1234">                    int[] dir2 = calculateNeighborDirection(x2, y2, p2);</span>
<span class="fc" id="L1235">                    log.info(&quot;   tolsq=&quot; + tol</span>
<span class="fc" id="L1236">                        + &quot; np1=&quot; + p1.toString()</span>
<span class="fc" id="L1237">                        + &quot; np2=&quot; + p2.toString()</span>
<span class="fc" id="L1238">                        + &quot;\n         dir1=&quot; + Arrays.toString(dir1)</span>
<span class="fc" id="L1239">                        + &quot; dir2=&quot; + Arrays.toString(dir2)</span>
                    );
<span class="fc bfc" id="L1241" title="All 2 branches covered.">                    if (!Arrays.equals(dir1, dir2)) {</span>
<span class="fc" id="L1242">                        output.add(np1[i]);</span>
<span class="fc" id="L1243">                        output.add(np2[j]);</span>
                    }
                }
            }
        }
        
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        if (output.isEmpty()) {</span>
<span class="fc" id="L1250">            return null;</span>
        }
        
<span class="fc" id="L1253">        return output;</span>
    }
    
    /**
     * examine the given nearestBounds to find the points
     * that are equidistant within tolerance from (x, y),
     * and have different direction vectors and return
     * that subset of points.
     * 
     * @param x
     * @param y
     * @param tol
     * @param nearestBounds
     * @return 
     */
    private PairInt[] findEquidistantNearestPoints(
        int x, int y, double tol, PairInt[] nearestBounds) {
                
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        if (nearestBounds.length &lt; 2) {</span>
<span class="fc" id="L1272">            return null;</span>
        }

<span class="fc" id="L1275">        TIntList maxSameIdxs = null;</span>
<span class="fc" id="L1276">        double dist = Double.MAX_VALUE;</span>
        
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        for (int i = 0; i &lt; nearestBounds.length; ++i) {</span>
            
            // looking for 2 or more points w/ same
            //   distances and different directions
            
<span class="fc" id="L1283">            PairInt p1 = nearestBounds[i];</span>
<span class="fc" id="L1284">            double dist1 = distance(x, y, p1);</span>
<span class="fc" id="L1285">            int[] dir1 = calculateNeighborDirection(x, y, p1);</span>
            
<span class="fc" id="L1287">            TIntList sameIdxs = new TIntArrayList();</span>
<span class="fc" id="L1288">            sameIdxs.add(i);</span>
            
<span class="fc bfc" id="L1290" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; nearestBounds.length; ++j) {</span>
<span class="fc" id="L1291">                PairInt p2 = nearestBounds[j];</span>
<span class="fc" id="L1292">                double dist2 = distance(x, y, p2);</span>
<span class="fc" id="L1293">                int[] dir2 = calculateNeighborDirection(x, y, p2);</span>
                
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">                boolean t1 = Math.abs(dist1 - dist2) &lt;= tol;</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">                boolean t2 = !Arrays.equals(dir1, dir2);</span>
<span class="pc bpc" id="L1297" title="1 of 4 branches missed.">                if (t1 &amp;&amp; t2) {</span>
<span class="fc" id="L1298">                    sameIdxs.add(j);</span>
                }
            }
            
<span class="fc bfc" id="L1302" title="All 4 branches covered.">            if ((sameIdxs.size() &gt; 1) &amp;&amp;</span>
                ((maxSameIdxs == null) || 
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">                (sameIdxs.size() &gt; maxSameIdxs.size()))) {</span>
<span class="fc" id="L1305">                maxSameIdxs = sameIdxs;</span>
<span class="fc" id="L1306">                dist = dist1;</span>
            }
        }
        
<span class="fc bfc" id="L1310" title="All 2 branches covered.">        if (maxSameIdxs != null) {</span>
<span class="pc bpc" id="L1311" title="3 of 4 branches missed.">            assert(maxSameIdxs.size() &gt; 1);</span>
<span class="fc" id="L1312">            PairInt[] output = new PairInt[maxSameIdxs.size()];</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">            for (int i = 0; i &lt; maxSameIdxs.size(); ++i) {</span>
<span class="fc" id="L1314">                int idx = maxSameIdxs.get(i);</span>
<span class="fc" id="L1315">                output[i] = nearestBounds[idx];</span>
            }
<span class="fc" id="L1317">            return output;</span>
        }
        
<span class="fc" id="L1320">        return null;</span>
    }

    /**
     * calculate whether the point that was the center
     * of the circle surface search is a medial axis
     * point and return it if so, else return null.
     * This method is used when a search returns 
     * 2 medial axis points.
     * @param p
     * @param medAxis1
     * @param medAxis2
     * @param tol
     * @return a populated instance of MedialAxisPoint
     * is returned if p is a medial axis point, else
     * null is returned.
     */
    private MedialAxisPoint centerIsAlsoMedialAxisPoint(
        PairInt p, MedialAxisPoint medAxis1, 
        MedialAxisPoint medAxis2, double tol) {
        
<span class="pc bpc" id="L1341" title="1 of 4 branches missed.">        if (!(points.contains(p) || processed.contains(p))) {</span>
<span class="nc" id="L1342">            return null;</span>
        }
                
        // test if p is on line between medAxis1 and medAxis2
<span class="fc" id="L1346">        PairInt mp1 = medAxis1.getCenter();</span>
<span class="fc" id="L1347">        PairInt mp2 = medAxis2.getCenter();</span>
        
<span class="fc bfc" id="L1349" title="All 2 branches covered.">        if (LinesAndAngles.onSegment(mp1.getX(), mp1.getY(),</span>
<span class="fc" id="L1350">            mp2.getX(), mp2.getY(), p.getX(), p.getY())) {</span>
            
            // create structure for medial axis point
                        
<span class="fc" id="L1354">            PairInt[] nearestBounds = findNearestBoundsAsArray(</span>
<span class="fc" id="L1355">                p.getX(), p.getY());</span>
            
<span class="fc" id="L1357">            nearestBounds = findEquidistantNearestPoints(</span>
<span class="fc" id="L1358">                p.getX(), p.getY(), tol, nearestBounds);</span>
            
<span class="pc bpc" id="L1360" title="3 of 4 branches missed.">            if (nearestBounds == null || (nearestBounds.length &lt; 2)) {</span>
<span class="fc" id="L1361">                return null;</span>
            }
            
            // use the average of search radii to approximate the
            // search radius used.
<span class="nc" id="L1366">            double avgSrchR = 0.5 * (medAxis1.getSearchRadiusUsed() +</span>
<span class="nc" id="L1367">                medAxis2.getSearchRadiusUsed());</span>
        
<span class="nc" id="L1369">            MedialAxisPoint mp0 = createMedialAxisPoint(p, nearestBounds,</span>
                avgSrchR);
            
<span class="nc" id="L1372">            return mp0;</span>
        }
        
<span class="fc" id="L1375">        return null;</span>
    }

    /**
     * given nearestBounds which are equidistant from
     * medialP, construct a MedialAxisPoint.
     * This method assumes that nearestBounds have all
     * been checked for different directions.
     * @param medialP
     * @param nearestBounds
     * @return 
     */
    private MedialAxisPoint createMedialAxisPoint(
        PairInt medialP, PairInt[] nearestBounds,
        double srchRadiusUsed) {
        
<span class="fc" id="L1391">        MedialAxisPoint mp = new MedialAxisPoint(medialP,</span>
            nearestBounds.length, srchRadiusUsed);
        
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        for (int j = 0; j &lt; nearestBounds.length; ++j) {</span>

<span class="fc" id="L1396">            PairInt boundaryP = nearestBounds[j];</span>
            
<span class="fc" id="L1398">            double dist = distance(medialP.getX(), </span>
<span class="fc" id="L1399">                medialP.getY(), boundaryP);</span>

            // vector from medial axis point to boundary point
<span class="fc" id="L1402">            MVector pv = new MVector(boundaryP, dist);</span>

            //boundary point and medial axis
<span class="fc" id="L1405">            mp.add(pv, j);</span>
        }
            
<span class="fc" id="L1408">        return mp;</span>
    }

    /**
     * examine each medial axis point and if the nearest
     * neighbors aren't exactly the same difference and
     * with different direction vectors, then use a 
     * small dither around the point to find the real
     * medial axis point.
     * The edited and added medial axis points are added to the
     * instance variable medAxisList.
     * The points that did not need changes, and new
     * points added are returned in a set for later
     * use (points searched around with the dither
     * pattern are excluded to avoid re-searching them).
     * @return 
     */
    private Set&lt;PairInt&gt; refineCentersOfMedAxisList() {

        // store the points that were already true medial
        // axis points and store the points that were
        // added as refinements
        // to possibly use later for seeds to a DFS search for
        // unfound, connected points.
<span class="fc" id="L1432">        Set&lt;PairInt&gt; store = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L1434">        Set&lt;PairInt&gt; present = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        for (int i = 0; i &lt; medAxisList.size(); ++i) {</span>
<span class="fc" id="L1436">            MedialAxisPoint mp = medAxisList.get(i);</span>
<span class="fc" id="L1437">            present.add(mp.getCenter());</span>
        }        
        
<span class="fc" id="L1440">        List&lt;MedialAxisPoint&gt; addTo = new ArrayList&lt;MedialAxisPoint&gt;();</span>
<span class="fc" id="L1441">        TIntList rm = new TIntArrayList();</span>
<span class="fc" id="L1442">        int[] offsets = null;</span>
<span class="fc" id="L1443">        int prevTol = Integer.MIN_VALUE;</span>
        
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        for (int i = 0; i &lt; medAxisList.size(); ++i) {</span>
<span class="fc" id="L1446">            MedialAxisPoint medAxisPt = medAxisList.get(i);</span>
<span class="fc" id="L1447">            PairInt medAxisCenter = medAxisPt.getCenter();</span>
        
<span class="fc" id="L1449">            double origSrchR = medAxisPt.getSearchRadiusUsed();</span>
            
<span class="fc" id="L1451">            int tol = (int) Math.ceil(origSrchR * sinePiDivN);</span>
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">            if (tol &lt; 1) {</span>
<span class="nc" id="L1453">                tol = 1;</span>
            }
<span class="fc" id="L1455">            log.info(&quot;medAxisPt.center=&quot; + medAxisCenter);</span>
            
<span class="fc" id="L1457">            int tol2 = 1;//0;</span>
            
            // if medAxisPt nearest bounds are already equal and diff dir,
            // skip refinement.
            // because some of the medAxisPts were built on averaged
            //   bunds of adjacent pts on spehere, the nearest bounds
            //   and directions should be re-checked here.
                        
<span class="fc" id="L1465">            PairInt[] nearB = findNearestBoundsAsArray(</span>
<span class="fc" id="L1466">                medAxisCenter.getX(), medAxisCenter.getY());</span>
<span class="fc" id="L1467">            nearB = findEquidistantNearestPoints(</span>
<span class="fc" id="L1468">                medAxisCenter.getX(), medAxisCenter.getY(), tol2, nearB);</span>
<span class="pc bpc" id="L1469" title="1 of 4 branches missed.">            if (nearB != null &amp;&amp; (nearB.length &gt; 1)) {</span>
                //update the point
<span class="fc" id="L1471">                MedialAxisPoint mp2 = createMedialAxisPoint(</span>
                    medAxisCenter, nearB, origSrchR);
<span class="fc" id="L1473">                medAxisList.set(i, mp2);</span>
<span class="fc" id="L1474">                store.add(medAxisCenter);</span>
<span class="fc" id="L1475">                continue;</span>
            }
                    
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">            if (tol &gt; 3) {</span>
<span class="nc" id="L1479">                String msg = &quot;Algorithm needs logic for &quot;</span>
                    + &quot;dither with large radius=&quot; + tol;
                // temporarily capturing case as an exception.
                // need to consider fast options for large srch radius here.
                //throw new IllegalStateException(msg);
<span class="nc" id="L1484">                log.warning(msg);</span>
<span class="nc" id="L1485">                continue;</span>
            }
            
<span class="fc bfc" id="L1488" title="All 2 branches covered.">            if (tol != prevTol) {</span>
<span class="fc" id="L1489">                offsets = Misc.createOrderedNeighborOffsets(tol);</span>
<span class="fc" id="L1490">                prevTol = tol;</span>
            }
            
<span class="fc" id="L1493">            log.info(&quot;  dither to improve &quot; + medAxisCenter + &quot;&quot;</span>
                + &quot; dither=&quot; + tol);
                        
<span class="fc" id="L1496">            List&lt;PairInt&gt; better = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L1497">            TIntObjectMap&lt;PairInt[]&gt; betterNBs = new TIntObjectHashMap&lt;PairInt[]&gt;();</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">            for (int k = 0; k &lt; offsets.length; k += 2) {</span>
<span class="fc" id="L1499">                int x2 = medAxisCenter.getX() + offsets[k];</span>
<span class="pc bpc" id="L1500" title="1 of 4 branches missed.">                if (x2 &lt; minMaxXY[0] || (x2 &gt; minMaxXY[1])) {</span>
<span class="nc" id="L1501">                    continue;</span>
                }
<span class="fc" id="L1503">                int y2 = medAxisCenter.getY() + offsets[k + 1];</span>
<span class="pc bpc" id="L1504" title="1 of 4 branches missed.">                if (y2 &lt; minMaxXY[2] || (y2 &gt; minMaxXY[3])) {</span>
<span class="fc" id="L1505">                    continue;</span>
                }
<span class="fc" id="L1507">                PairInt p2 = new PairInt(x2, y2);</span>
                
<span class="fc bfc" id="L1509" title="All 2 branches covered.">                if (present.contains(p2)) {</span>
<span class="fc" id="L1510">                    continue;</span>
                }
<span class="fc bfc" id="L1512" title="All 4 branches covered.">                if (!(points.contains(p2) || processed.contains(p2))) {</span>
<span class="fc" id="L1513">                    continue;</span>
                }
 
<span class="fc" id="L1516">                nearB = findNearestBoundsAsArray(x2, y2);</span>
<span class="fc" id="L1517">                nearB = findEquidistantNearestPoints(</span>
                    x2, y2, tol2, nearB);
                
<span class="pc bpc" id="L1520" title="1 of 4 branches missed.">                if (nearB != null &amp;&amp; (nearB.length &gt; 1)) {</span>
<span class="fc" id="L1521">                    betterNBs.put(better.size(), nearB);</span>
<span class="fc" id="L1522">                    better.add(p2);</span>
<span class="fc" id="L1523">                    store.add(p2);</span>
                }
            }
<span class="fc bfc" id="L1526" title="All 2 branches covered.">            if (better.isEmpty()) {</span>
<span class="fc" id="L1527">                log.info(&quot;  WARNING: did not find better for &quot; + medAxisCenter);</span>
<span class="fc" id="L1528">                rm.add(i);</span>
            } else{
                // replace mp w/ first and add remaining
<span class="fc" id="L1531">                MedialAxisPoint mp2 = createMedialAxisPoint(</span>
<span class="fc" id="L1532">                    better.get(0), betterNBs.get(0), origSrchR);</span>
<span class="fc" id="L1533">                medAxisList.set(i, mp2);</span>
<span class="fc" id="L1534">                present.remove(medAxisCenter);</span>
<span class="fc" id="L1535">                present.add(better.get(0));</span>
<span class="fc" id="L1536">                store.add(better.get(0));</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">                for (int jj = 1; jj &lt; better.size(); ++jj) {</span>
<span class="fc" id="L1538">                    MedialAxisPoint mp3 = createMedialAxisPoint(</span>
<span class="fc" id="L1539">                        better.get(jj), betterNBs.get(jj), origSrchR);</span>
<span class="fc" id="L1540">                    addTo.add(mp3);</span>
<span class="fc" id="L1541">                    present.add(better.get(jj));</span>
<span class="fc" id="L1542">                    store.add(better.get(jj));</span>
                }
            }
        }
<span class="fc" id="L1546">        rm.sort();</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">        for (int i = (rm.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1548">            int idx = rm.get(i);</span>
<span class="fc" id="L1549">            medAxisList.remove(idx);</span>
        }
<span class="fc" id="L1551">        medAxisList.addAll(addTo);</span>

<span class="fc" id="L1553">        return store;</span>
    }

    /**
     * search around the points in srch using a dither
     * of 1 to find new medial axis points.
     * The found medial axis points are added to the
     * instance variable medAxisList.
     * @param srch 
     */
    private void fillInGaps(Set&lt;PairInt&gt; srch) {
        
<span class="fc" id="L1565">        Stack&lt;PairInt&gt; stack = new Stack&lt;PairInt&gt;();</span>
<span class="fc" id="L1566">        stack.addAll(srch);</span>

        // search for nearest neighbors within dist tol
        /*
        NOTE: 
           alternative dither values could be:
           (1) derive from search radius of each medial axis point.
               (would need to change argument to pass those in instead)
           (2) derive from general characteristics of data max:
               int dither = Math.min(minMaxXY[1], minMaxXY[3]);
               dither = (int)Math.ceil(2 * tol * sinePiDivN); 
        
        int[] offsets = Misc.createOrderedNeighborOffsets(tol);
        */
        
<span class="fc" id="L1581">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1582">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1584">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1586">        Set&lt;PairInt&gt; srched = new HashSet&lt;PairInt&gt;(srch);</span>

<span class="fc" id="L1588">        int tol2 = 1;//0;</span>
        
<span class="fc bfc" id="L1590" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
<span class="fc" id="L1591">            PairInt p = stack.pop();</span>
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">            if (visited.contains(p)) {</span>
<span class="nc" id="L1593">                continue;</span>
            }
<span class="fc" id="L1595">            visited.add(p);</span>
<span class="fc" id="L1596">            int x = p.getX();</span>
<span class="fc" id="L1597">            int y = p.getY();</span>

<span class="fc bfc" id="L1599" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1600">                int x2 = x + dxs[k];</span>
<span class="fc" id="L1601">                int y2 = y + dys[k];</span>
<span class="pc bpc" id="L1602" title="3 of 8 branches missed.">                if (x2 &lt; minMaxXY[0] || y2 &lt; minMaxXY[2] || (x2 &gt; minMaxXY[1])</span>
                    || (y2 &gt; minMaxXY[3])) {
<span class="nc" id="L1604">                    continue;</span>
                }
<span class="fc" id="L1606">                PairInt p2 = new PairInt(x2, y2);</span>
                
<span class="fc bfc" id="L1608" title="All 4 branches covered.">                if (!(points.contains(p2) || processed.contains(p2))</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                    || srched.contains(p2)) {</span>
<span class="fc" id="L1610">                    continue;</span>
                }
<span class="fc" id="L1612">                srched.add(p2);</span>

<span class="fc" id="L1614">                PairInt[] nearestBounds = findNearestBoundsAsArray(</span>
                    x2, y2);
<span class="fc" id="L1616">                nearestBounds = findEquidistantNearestPoints(</span>
                    x2, y2, tol2, nearestBounds);
<span class="pc bpc" id="L1618" title="1 of 4 branches missed.">                if (nearestBounds == null || (nearestBounds.length &lt; 2)) {</span>
<span class="nc" id="L1619">                    continue;</span>
                }
<span class="fc" id="L1621">                double d = distance(x2, y2, nearestBounds[0]);</span>
<span class="fc" id="L1622">                MedialAxisPoint mp2 = createMedialAxisPoint(p2,</span>
                    nearestBounds, d);
<span class="fc" id="L1624">                medAxisList.add(mp2);</span>
<span class="fc" id="L1625">                stack.add(p2);</span>
            }
<span class="fc" id="L1627">        }</span>
<span class="fc" id="L1628">    }</span>

    private void searchCenterPoint(MedialAxisResults results, 
        Set&lt;PairInt&gt; addedM) {
        
<span class="fc bfc" id="L1633" title="All 2 branches covered.">        if (results.medialAxes.size() == 2) {</span>
            // if there are 2 medial axes points and if center is not inline
            // with the 2 med axis points, this is a &quot;critical point&quot; region too
<span class="fc bfc" id="L1636" title="All 2 branches covered.">            if (points.contains(results.center) || </span>
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">                processed.contains(results.center)) {</span>
<span class="fc" id="L1638">                int tol2 = (int)Math.ceil(results.medialAxes.get(0).getSearchRadiusUsed()</span>
                        * sinePiDivN);
<span class="pc bpc" id="L1640" title="1 of 2 branches missed.">                if (tol2 &lt; 1) {</span>
<span class="nc" id="L1641">                    tol2 = 1;</span>
                }
<span class="fc" id="L1643">                MedialAxisPoint mp0 = centerIsAlsoMedialAxisPoint(results.center,</span>
<span class="fc" id="L1644">                    results.medialAxes.get(0),</span>
<span class="fc" id="L1645">                    results.medialAxes.get(1),</span>
                    tol2);
<span class="pc bpc" id="L1647" title="3 of 4 branches missed.">                if (mp0 != null &amp;&amp; !addedM.contains(mp0.getCenter())) {</span>
<span class="nc" id="L1648">                    medAxisList.add(mp0);</span>
<span class="nc" id="L1649">                    addedM.add(mp0.getCenter());</span>
                }
            }
        }        
<span class="fc" id="L1653">    }</span>

    private MedialAxisResults findAndProcessFirstPoint(
        Heap q, Set&lt;PairInt&gt; addedM) {
        
<span class="fc" id="L1658">        MedialAxisResults results = findInitialPoint(addedM);</span>
        
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">        if (results == null) {</span>
            //TODO: refactor so that can remove the searched
            // points even when null is returned.
<span class="nc" id="L1663">            return null;</span>
        }
        
        // remove the searched circle from this.points.
        // and add the extracted to &quot;processed&quot;.
        // NOTE: have used search radius - 1 to not remove
        // any found medial axis points.
<span class="fc" id="L1670">        Set&lt;PairInt&gt; removed = subtractFromPoints(results.center, </span>
            results.centerSrchR - 1);
         
<span class="fc" id="L1673">        processed.addAll(removed);</span>
        
<span class="fc" id="L1675">        searchCenterPoint(results, addedM);</span>
        
<span class="pc bpc" id="L1677" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());</span>
        
<span class="fc bfc" id="L1679" title="All 2 branches covered.">        for (MedialAxisPoint m : results.medialAxes) {</span>
<span class="fc" id="L1680">            PairInt pp = m.getCenter();</span>
<span class="pc bpc" id="L1681" title="1 of 2 branches missed.">            if (!addedM.contains(pp)) {</span>
<span class="fc" id="L1682">                addedM.add(pp);</span>
<span class="fc" id="L1683">                medAxisList.add(m);</span>
<span class="fc" id="L1684">                addToHeap(q, m);</span>
            }
<span class="fc" id="L1686">        }</span>

<span class="pc bpc" id="L1688" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());  </span>

<span class="fc" id="L1690">        return results;</span>
    }
    
    private MedialAxisResults findAndProcessARemainingPoint(
        Heap q, Set&lt;PairInt&gt; addedM) {
        
<span class="fc" id="L1696">        Iterator&lt;PairInt&gt; iter = points.iterator();</span>
<span class="fc" id="L1697">        PairInt p = iter.next();</span>
        
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        while (addedM.contains(p)) {</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">           if (!iter.hasNext()) {</span>
<span class="nc" id="L1701">               return null;</span>
           }
<span class="nc" id="L1703">           p = iter.next();</span>
        }
    
<span class="fc" id="L1706">        int tol = 1;//0;</span>
        
        // first check the point p itself
<span class="fc" id="L1709">        PairInt[] nearB = findNearestBoundsAsArray(</span>
<span class="fc" id="L1710">            p.getX(), p.getY());</span>
<span class="fc" id="L1711">        nearB = findEquidistantNearestPoints(</span>
<span class="fc" id="L1712">            p.getX(), p.getY(), tol, nearB);</span>
<span class="pc bpc" id="L1713" title="1 of 4 branches missed.">        if (nearB != null &amp;&amp; (nearB.length &gt; 1)) {</span>
<span class="fc" id="L1714">            double d = distance(p.getX(), p.getY(), nearB[0]);</span>
<span class="fc" id="L1715">            MedialAxisPoint mp2 = createMedialAxisPoint(</span>
                p, nearB, d);
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">            if (!addedM.contains(mp2.getCenter())) {</span>
<span class="fc" id="L1718">                medAxisList.add(mp2);</span>
<span class="fc" id="L1719">                addToHeap(q, mp2);</span>
<span class="fc" id="L1720">                addedM.add(p);</span>
            }
<span class="fc" id="L1722">            processed.addAll(subtractFromPoints(p, d - 1));         </span>
        }
        
        // search within a sampled radius for medial axis points
<span class="fc" id="L1726">        MedialAxisResults results = findMedialAxesNearPoint(p, addedM);</span>
                
<span class="fc bfc" id="L1728" title="All 2 branches covered.">        if (results == null) {</span>
            //TODO: refactor so that can remove the searched
            // points even when null is returned.
<span class="fc" id="L1731">            return null;</span>
        }
        
        // remove the searched circle from this.points.
        // and add the extracted to &quot;processed&quot;.
        // NOTE: have used search radius - 1 to not remove
        // any found medial axis points.
<span class="fc" id="L1738">        Set&lt;PairInt&gt; removed = subtractFromPoints(results.center, </span>
            results.centerSrchR - 1);
         
<span class="fc" id="L1741">        processed.addAll(removed);</span>
        
<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">        if (!results.center.equals(p)) {</span>
<span class="nc" id="L1744">            searchCenterPoint(results, addedM);</span>
        }
<span class="pc bpc" id="L1746" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());</span>
        
<span class="fc bfc" id="L1748" title="All 2 branches covered.">        for (MedialAxisPoint m : results.medialAxes) {</span>
<span class="fc" id="L1749">            PairInt pp = m.getCenter();</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">            if (!addedM.contains(pp)) {</span>
<span class="fc" id="L1751">                addedM.add(pp);</span>
<span class="fc" id="L1752">                medAxisList.add(m);</span>
<span class="fc" id="L1753">                addToHeap(q, m);</span>
            }
<span class="fc" id="L1755">        }</span>

<span class="pc bpc" id="L1757" title="3 of 4 branches missed.">        assert(assertUniqueMedialAxesPoints());  </span>

<span class="fc" id="L1759">        return results;</span>
    }

    private void searchEachPoint() {
        
<span class="fc" id="L1764">        int tol = 1;//0;</span>
        
<span class="fc bfc" id="L1766" title="All 2 branches covered.">        for (PairInt p : points) {</span>
            
<span class="fc" id="L1768">            PairInt[] nearestBounds = findNearestBoundsAsArray(</span>
<span class="fc" id="L1769">                p.getX(), p.getY());</span>
<span class="fc" id="L1770">            nearestBounds = findEquidistantNearestPoints(</span>
<span class="fc" id="L1771">                p.getX(), p.getY(), tol, nearestBounds);        </span>
<span class="pc bpc" id="L1772" title="1 of 4 branches missed.">            if (nearestBounds == null || (nearestBounds.length &lt; 2)) {</span>
<span class="nc" id="L1773">                continue;</span>
            }
<span class="fc" id="L1775">            double avgSrchR = 1;</span>

<span class="fc" id="L1777">            MedialAxisPoint mp0 = createMedialAxisPoint(p, nearestBounds,</span>
                avgSrchR);
            
<span class="fc" id="L1780">            medAxisList.add(mp0);</span>
<span class="fc" id="L1781">        }</span>
<span class="fc" id="L1782">        processed.addAll(points);</span>
<span class="fc" id="L1783">        points.clear();;</span>
<span class="fc" id="L1784">    }</span>

    protected static class MedialAxisPoint {
        private final MVector[] boundaryPoints;
        private final PairInt p;
        private MedialAxisPoint parent = null;
        private final double originalSearchRadius;
        public MedialAxisPoint(PairInt center, int nVectors,
            double srchRadiusUsed) {
            boundaryPoints = new MVector[nVectors];
            p = center;
            originalSearchRadius = srchRadiusUsed;
        }
        
        /**
         * add the boundary point and medial axis internal
         * array at index index.
         * @param mv
         * @param index 
         */
        public void add(MVector mv, int index) {
            boundaryPoints[index] = mv;
        }
        
        /**
         * get vectors of boundaryPoint and point which
         * is medial axis.  Note that pv.delta should
         * be the distance from medialAxisPoint to its 
         * nearest boundary point and it may be null
         * so that it can be lazily populated to avoid
         * the log_2(N) NN if not needed.
         * @return 
         */
        public MVector[] getBoundaryPoints() {
            return boundaryPoints;
        }
        public MedialAxisPoint getParent() {
            return parent;
        }
        public void setParent(MedialAxisPoint medAxisP) {
            parent = medAxisP;
        }
        public PairInt getCenter() {
            return p;
        }
        public double getSearchRadiusUsed() {
            return originalSearchRadius;
        }
    }
    
    /**
     * class to hold one of the nearest boundary
     * points to a medial axis point and the
     * distance between them.
     */
    protected static class MVector {
        private final PairInt boundaryP;
        private final double dist;
        // direction is from medAxisP to boundaryP
        private int[] dir = null;
        
        public MVector(PairInt b, double d) {
            this.boundaryP = b;
            this.dist = d;
        }
        public PairInt getBoundaryPoint() {
            return boundaryP;
        }
        public double getDistance() {
            return dist;
        }
        public void setDirection(int[] direction) {
            dir = direction;
        }
        public int[] getDirection() {
            return dir;
        }
    }
  
    private int[] calculateNeighborDirection(int x1, int y1, PairInt p2) {
        /*
            N_x = (boundaryP - medialP vectors)
                  /|(boundaryP - medialP)|
         */
<span class="fc" id="L1868">        int diffX = p2.getX() - x1;</span>
<span class="fc" id="L1869">        int diffY = p2.getY() - y1;</span>
<span class="fc" id="L1870">        int[] result = new int[2];</span>
<span class="fc bfc" id="L1871" title="All 4 branches covered.">        result[0] = (diffX &lt; 0) ? -1 : (diffX &gt; 0) ? 1 : 0;</span>
<span class="fc bfc" id="L1872" title="All 4 branches covered.">        result[1] = (diffY &lt; 0) ? -1 : (diffY &gt; 0) ? 1 : 0;</span>
<span class="fc" id="L1873">        return result;</span>
    }
    
    protected static class MedialAxisResults {
        List&lt;MedialAxisPoint&gt; medialAxes;
        PairInt center;
        double centerSrchR;
    }
    
    /**
     * use the instance variable nb to find nearest neighbor(s)
     * of (x, y) and return them as an array.
     * The returned points have the same distance from (x. y).
     * @param x
     * @param y
     * @return 
     */
    protected PairInt[] findNearestBoundsAsArray(int x, int y) {
    
<span class="fc" id="L1892">        Set&lt;PairInt&gt; nearestB = np.findClosest(x, y);</span>
<span class="fc" id="L1893">        int count = 0;</span>
<span class="fc" id="L1894">        PairInt[] nearestBounds = new PairInt[nearestB.size()];</span>
<span class="fc bfc" id="L1895" title="All 2 branches covered.">        for (PairInt p : nearestB) {</span>
<span class="fc" id="L1896">            nearestBounds[count] = p;</span>
<span class="fc" id="L1897">            count++;</span>
<span class="fc" id="L1898">        }</span>
<span class="fc" id="L1899">        return nearestBounds;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
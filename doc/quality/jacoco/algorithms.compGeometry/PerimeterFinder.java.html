<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PerimeterFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">PerimeterFinder.java</span></div><h1>PerimeterFinder.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

import algorithms.imageProcessing.DFSConnectedGroupsFinder;
import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.util.PathStep;
import algorithms.misc.MiscMath;
import algorithms.util.BitVectorRepresentation;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;

/**
 * class to create a map of rows with start and stop column bounds (inclusive)
 * for each row to bound the area occupied by given points while including also
 * groups of points that are completely embedded in the point set though not
 * part of the point set.  Those embedded points are retrievable separately.
 * The data structure is somewhat like a concave hull.  It's used to help
 * quickly scan a region and not include the tops of mountains that the sky
 * concave hull is bent around, for example.
 *
 * @author nichole
 */
<span class="fc" id="L33">public class PerimeterFinder {</span>

<span class="fc" id="L35">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L37">    private boolean debug = true;</span>

    /**
     * For the given points, find the ranges of columns that bound the points
     * that are contiguous and the points that are completely
     * enclosed within points but not part of the set.
     * This returns an outline of the points attempting to correct for
     * concave portions of the hull, that is, it is roughly a concave hull
     * that includes embedded PairInts that are not in the set points.
     *
     * @param points
     * @param outputRowMinMax output populated as the min and max of rows are
     * determined.
     * @param imageMaxColumn maximum column index of image (used to understand
     * when a pixel is in the last column)
     * @param outputEmbeddedGapPoints a return variable holding the found
     * embedded points that are not in the &quot;points&quot; set, but are enclosed by it.
     * @return map w/ key being row number, value being a list of column ranges
     * that inclusively bound the points in that row.
     */
    public Map&lt;Integer, List&lt;PairInt&gt;&gt; find(Set&lt;PairInt&gt; points,
        int[] outputRowMinMax, int imageMaxColumn,
        Set&lt;PairInt&gt; outputEmbeddedGapPoints) {

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (points == null) {</span>
<span class="nc" id="L62">	    	throw new IllegalArgumentException(&quot;points cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (outputRowMinMax == null) {</span>
<span class="nc" id="L65">	    	throw new IllegalArgumentException(&quot;outputRowMinMax cannot be null&quot;);</span>
        }

        //== O(N):
<span class="fc" id="L69">        int[] minMaxXY = MiscMath.findMinMaxXY(points);</span>
<span class="fc" id="L70">        int minX = minMaxXY[0];</span>
<span class="fc" id="L71">        int maxX = minMaxXY[1];</span>
<span class="fc" id="L72">        int minY = minMaxXY[2];</span>
<span class="fc" id="L73">        int maxY = minMaxXY[3];</span>

<span class="fc" id="L75">        outputRowMinMax[0] = minY;</span>
<span class="fc" id="L76">        outputRowMinMax[1] = maxY;</span>

        /*
        TODO: consider where can make changes to iterate over data by
        point in &quot;points&quot; instead of minX, maxX, minY, maxY to reduce the
        runtime and keep it easier to make polynomial estimate.
        */

        //== O((maxX-minX+1)*(maxY-minY+1)):
        // key holds row number
        // value holds (first column number, last column number) for points in the row
<span class="fc" id="L87">        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges = findRowColRanges(points,</span>
            minX, maxX, minY, maxY);

        // runtime complexity is &gt; O(m) where m is the number of contig gap ranges by row
<span class="fc" id="L91">        List&lt;List&lt;Gap&gt;&gt; contiguousGaps = findContiguousGaps(rowColRanges,</span>
            minX, maxX, minY, maxY);

        //runtime complexity is &gt; O(m) where m is the number of contig gap ranges by row
<span class="fc" id="L95">        List&lt;List&lt;Gap&gt;&gt; embeddedGapGroups = findBoundedGaps(contiguousGaps,</span>
            minY, maxY, imageMaxColumn, rowColRanges);

        // update the rowColRanges to encapsulate the truly embedded points too
<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (List&lt;Gap&gt; embeddedGroup : embeddedGapGroups) {</span>

<span class="fc" id="L101">            updateRowColRangesForVerifiedEmbedded(rowColRanges,</span>
                embeddedGroup, outputEmbeddedGapPoints);

<span class="fc" id="L104">        }</span>

<span class="fc" id="L106">        return rowColRanges;</span>
    }

    /**
     * For the given points, find the ranges of columns that bound the points
     * that are contiguous and the points that are completely
     * enclosed within points but not part of the set.
     * This returns an outline of the points attempting to correct for
     * concave portions of the hull, that is, it is roughly a concave hull
     * that includes embedded PairInts that are not in the set points.
     * @param rowMinMax
     * @param imageMaxColumn
     * @param rowColRanges
     * @return 
     */
    public Set&lt;PairInt&gt; findEmbeddedGivenRowData(
        int[] rowMinMax, int imageMaxColumn,
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges) {

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (rowColRanges == null) {</span>
<span class="nc" id="L126">	    	throw new IllegalArgumentException(&quot;rowColRanges cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (rowMinMax == null) {</span>
<span class="nc" id="L129">	    	throw new IllegalArgumentException(&quot;outputRowMinMax cannot be null&quot;);</span>
        }

<span class="fc" id="L132">        int minX = Integer.MAX_VALUE;</span>
<span class="fc" id="L133">        int maxX = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; row++) {</span>
<span class="fc" id="L135">            List&lt;PairInt&gt; rcr = rowColRanges.get(Integer.valueOf(row));</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (rcr.isEmpty()) {</span>
<span class="nc" id="L137">                continue;</span>
            }
<span class="fc" id="L139">            int x0 = rcr.get(0).getX();</span>
<span class="fc" id="L140">            int xf = rcr.get(rcr.size() - 1).getY();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (x0 &lt; minX) {</span>
<span class="fc" id="L142">                minX = x0;</span>
            }
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (xf &gt; maxX) {</span>
<span class="fc" id="L145">                maxX = xf;</span>
            }
        }

        // runtime complexity is &gt; O(m) where m is the number of contig gap ranges by row
<span class="fc" id="L150">        List&lt;List&lt;Gap&gt;&gt; contiguousGaps = findContiguousGaps(rowColRanges,</span>
            minX, maxX, rowMinMax[0], rowMinMax[1]);

        //runtime complexity is &gt; O(m) where m is the number of contig gap ranges by row
<span class="fc" id="L154">        List&lt;List&lt;Gap&gt;&gt; embeddedGapGroups = findBoundedGaps(contiguousGaps,</span>
            rowMinMax[0], rowMinMax[1], imageMaxColumn, rowColRanges);

<span class="fc" id="L157">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>

        // update the rowColRanges to encapsulate the truly embedded points too
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (List&lt;Gap&gt; embeddedGroup : embeddedGapGroups) {</span>

<span class="fc" id="L162">            updateRowColRangesForVerifiedEmbedded(rowColRanges,</span>
                embeddedGroup, outputEmbeddedGapPoints);
<span class="fc" id="L164">        }</span>

<span class="fc" id="L166">        return outputEmbeddedGapPoints;</span>
    }

    boolean boundedByPointsInHigherRows(int row, int gapStart, int gapStop,
        int maxRow, int imageMaxColumn, Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRange) {

<span class="fc" id="L172">        LinkedHashSet&lt;Integer&gt; gapRange = createRange(gapStart, gapStop);</span>

<span class="fc" id="L174">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (int r = (row + 1); r &lt;= maxRow; r++) {</span>

<span class="fc" id="L178">            List&lt;PairInt&gt; colRanges = rowColRange.get(Integer.valueOf(r));</span>

<span class="fc" id="L180">            boolean bounded = boundedByPoints(colRanges, imageMaxColumn,</span>
                gapRange, remove);

<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (bounded) {</span>
<span class="fc" id="L184">                return true;</span>
            }
        }

<span class="fc" id="L188">        return gapRange.isEmpty();</span>
    }

    boolean boundedByPointsInLowerRows(int row, int gapStart, int gapStop,
        int minRow, int imageMaxColumn,
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges) {

<span class="fc" id="L195">        LinkedHashSet&lt;Integer&gt; gapRange = createRange(gapStart, gapStop);</span>
<span class="fc" id="L196">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (int r = (row - 1); r &gt;= minRow; r--) {</span>

<span class="fc" id="L200">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(r));</span>

<span class="fc" id="L202">            boolean bounded = boundedByPoints(colRanges, imageMaxColumn,</span>
                gapRange, remove);

<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (bounded) {</span>
<span class="fc" id="L206">                return true;</span>
            }
        }

<span class="fc" id="L210">        return gapRange.isEmpty();</span>
    }

    private boolean boundedByPoints(List&lt;PairInt&gt; colRanges, int imageMaxColumn,
        LinkedHashSet&lt;Integer&gt; gapRange, List&lt;Integer&gt; remove) {

<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (PairInt colRange : colRanges) {</span>

<span class="fc" id="L218">            int col0 = colRange.getX();</span>
<span class="fc" id="L219">            int col1 = colRange.getY();</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">            for (Integer gapColumn : gapRange) {</span>

<span class="fc" id="L223">                int col = gapColumn.intValue();</span>

<span class="fc bfc" id="L225" title="All 4 branches covered.">                if ((col &gt;= col0) &amp;&amp; (col &lt;= col1)) {</span>

<span class="fc" id="L227">                    remove.add(gapColumn);</span>
                }
<span class="fc" id="L229">            }</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            for (Integer rm : remove) {</span>
<span class="fc" id="L231">                gapRange.remove(rm);</span>
<span class="fc" id="L232">            }</span>
<span class="fc" id="L233">            remove.clear();</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (gapRange.isEmpty()) {</span>
<span class="fc" id="L236">                return true;</span>
            }
<span class="fc" id="L238">        }</span>

<span class="fc" id="L240">        return gapRange.isEmpty();</span>
    }

    LinkedHashSet&lt;Integer&gt; createRange(int start, int stopInclusive) {

<span class="fc" id="L245">        int n = stopInclusive - start + 1;</span>

<span class="fc" id="L247">        LinkedHashSet&lt;Integer&gt; range = new LinkedHashSet&lt;Integer&gt;(n);</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

<span class="fc" id="L251">            Integer value = Integer.valueOf(start + i);</span>

<span class="fc" id="L253">            range.add(value);</span>
        }

<span class="fc" id="L256">        return range;</span>
    }

    /**
     * for the given points, find the ranges of contiguous columns and return
     * that by row.
     * runtime complexity is O((maxX-minX+1)*(maxY-minY+1)), so this is
     * larger than O(N) for points datasets that are less dense than the min
     * max range.
     *
     * @return a map with key = row, value = list of contiguous points in the
     * row.
     */
    Map&lt;Integer, List&lt;PairInt&gt;&gt; findRowColRanges(Set&lt;PairInt&gt; points,
        int minX, int maxX, int minY, int maxY) {

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (points == null) {</span>
<span class="nc" id="L273">	    	throw new IllegalArgumentException(&quot;points cannot be null&quot;);</span>
        }

        /*
        TODO: consider where can make changes to iterate over data by
        point in &quot;points&quot; instead of minX, maxX, minY, maxY to reduce the
        runtime and keep it easier to make polynomial estimate.
        */

        // key holds row number
        // value holds (first column number, last column number) for points in the row
<span class="fc" id="L284">        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRange = new HashMap&lt;Integer, List&lt;PairInt&gt;&gt;();</span>

        //O(N):
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (int row = minY; row &lt;= maxY; row++) {</span>

<span class="fc" id="L289">            List&lt;PairInt&gt; colRanges = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L290">            Integer key = Integer.valueOf(row);</span>
<span class="fc" id="L291">            rowColRange.put(key, colRanges);</span>

<span class="fc" id="L293">            PairInt currentColRange = null;</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">            for (int col = minX; col &lt;= maxX; col++) {</span>

<span class="fc" id="L297">                boolean contains = points.contains(new PairInt(col, row));</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">                if (currentColRange == null) {</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                    if (contains) {</span>
<span class="fc" id="L301">                        currentColRange = new PairInt(col, col);</span>
                    }
                } else {
<span class="fc bfc" id="L304" title="All 2 branches covered.">                    if (contains) {</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                        if (col == (currentColRange.getY() + 1)) {</span>
<span class="fc" id="L306">                            currentColRange.setY(col);</span>
                        } else {
<span class="nc" id="L308">                            colRanges.add(currentColRange);</span>
<span class="nc" id="L309">                            currentColRange = null;</span>
                        }
                    } else {
<span class="fc" id="L312">                        colRanges.add(currentColRange);</span>
<span class="fc" id="L313">                        currentColRange = null;</span>
                    }
                }
            }

            //store last currentColRange
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (currentColRange != null) {</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">                if (colRanges.isEmpty()) {</span>

<span class="fc" id="L323">                    colRanges.add(currentColRange);</span>

<span class="fc" id="L325">                } else if (</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                    !colRanges.get(colRanges.size() - 1).equals(currentColRange)) {</span>

<span class="fc" id="L328">                    colRanges.add(currentColRange);</span>
                }
            }
        }

<span class="fc" id="L333">        return rowColRange;</span>
    }

    /**
     * Find the gaps in rowColRanges and put them in same group if they are
     * connected.  Note that diagonal pixels are not considered connected
     * (though this may change if test cases show they should be).
     *
     * @param rowColRanges
     * @param minX
     * @param maxX
     * @param minY
     * @param maxY
     * @return
     */
    protected List&lt;List&lt;Gap&gt;&gt; findContiguousGaps(Map&lt;Integer, List&lt;PairInt&gt;&gt;
        rowColRanges, int minX, int maxX, int minY, int maxY) {

        // ---------------- store the gaps in a stack ---------------------
        // runtime complexity is
        // O((maxY-minY+1)*k) where k is the number of contig ranges per row
<span class="fc" id="L354">        Stack&lt;Gap&gt; stack = findGaps(rowColRanges, minX, maxX, minY, maxY);</span>

        // ----------------- find contiguous gaps ------------------------
<span class="fc" id="L357">        List&lt;List&lt;Gap&gt;&gt; gapGroups = new ArrayList&lt;List&lt;Gap&gt;&gt;();</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (stack.isEmpty()) {</span>
<span class="fc" id="L360">            return gapGroups;</span>
        }

<span class="fc" id="L363">        Map&lt;Gap, Integer&gt; gapToIndexMap = new HashMap&lt;Gap, Integer&gt;();</span>

<span class="fc" id="L365">        Map&lt;Gap, Boolean&gt; visited = new HashMap&lt;Gap, Boolean&gt;();</span>

        //TODO: add minimum and maximum runtime estimates here.

<span class="fc bfc" id="L369" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>

<span class="fc" id="L371">            Gap uNode = stack.pop();</span>

<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (visited.containsKey(uNode)) {</span>
<span class="fc" id="L374">                continue;</span>
            }

<span class="fc" id="L377">            visited.put(uNode, Boolean.TRUE);</span>

<span class="fc" id="L379">            int row = uNode.getRow();</span>
<span class="fc" id="L380">            int uStart = uNode.getStart();</span>
<span class="fc" id="L381">            int uStopIncl = uNode.getStopInclusive();</span>

            // search in row above for a neighbor.
            // to save space, just looking in rowColRanges

<span class="fc" id="L386">            int vRow = row + 1;</span>

<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (vRow &gt; maxY) {</span>
<span class="fc" id="L389">                continue;</span>
            }

            // ------ find the connected neighbors of u, below u ---------

<span class="fc" id="L394">            List&lt;Gap&gt; vNodes = new ArrayList&lt;Gap&gt;();</span>

            // these are ordered by increasing range:
<span class="fc" id="L397">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(vRow));</span>

            /*
                  |----|    |----|
                @@@@@@@@@            case 0
               @@@@@                 case 1
                      @@@@@          case 2
                    @@               case 3
            */
<span class="fc bfc" id="L406" title="All 2 branches covered.">            for (int i = 1; i &lt; colRanges.size(); i++) {</span>
<span class="fc" id="L407">                int gapStart = colRanges.get(i - 1).getY() + 1;</span>
<span class="fc" id="L408">                int gapStop = colRanges.get(i).getX() - 1;</span>

<span class="fc" id="L410">                Gap vNode = null;</span>

                // is any portion of uStart is within col0:col2
<span class="fc bfc" id="L413" title="All 4 branches covered.">                if ((uStart &lt;= gapStart) &amp;&amp; (uStopIncl &gt;= gapStop)) {</span>
<span class="fc" id="L414">                    vNode = new Gap(vRow, gapStart, gapStop);</span>
<span class="fc bfc" id="L415" title="All 4 branches covered.">                } else if ((uStopIncl &gt;= gapStart) &amp;&amp; (uStopIncl &lt;= gapStop)) {</span>
<span class="fc" id="L416">                    vNode = new Gap(vRow, gapStart, gapStop);</span>
<span class="fc bfc" id="L417" title="All 4 branches covered.">                } else if ((uStart &gt;= gapStart) &amp;&amp; (uStart &lt;= gapStop)) {</span>
<span class="fc" id="L418">                    vNode = new Gap(vRow, gapStart, gapStop);</span>
                }

<span class="fc bfc" id="L421" title="All 2 branches covered.">                if (vNode != null) {</span>

<span class="fc" id="L423">                    vNodes.add(vNode);</span>
                }
            }

            // ---------------- process the neighbors -----------------

<span class="fc bfc" id="L429" title="All 2 branches covered.">            for (Gap vNode : vNodes) {</span>
                // process each node.  add to existing group or start a new one
<span class="fc" id="L431">                Integer uIdx = gapToIndexMap.get(uNode);</span>
<span class="fc" id="L432">                Integer vIdx = gapToIndexMap.get(vNode);</span>
<span class="fc" id="L433">                Integer groupIdx = null;</span>
<span class="fc bfc" id="L434" title="All 4 branches covered.">                if ((uIdx != null) &amp;&amp; (vIdx != null)) {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">                    if (uIdx.intValue() == vIdx.intValue()) {</span>
                        // these are already in the same group... should not be visited again though
<span class="nc" id="L437">                        groupIdx = uIdx;</span>
                    } else {
                        Integer moveTo;
                        Integer moveFrom;
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                        if (uIdx.intValue() &lt; vIdx.intValue()) {</span>
<span class="nc" id="L442">                            moveTo = uIdx;</span>
<span class="nc" id="L443">                            moveFrom = vIdx;</span>
                        } else {
<span class="fc" id="L445">                            moveTo = vIdx;</span>
<span class="fc" id="L446">                            moveFrom = uIdx;</span>
                        }
<span class="fc" id="L448">                        List&lt;Gap&gt; moveFromG = gapGroups.get(moveFrom);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">                        for (Gap g : moveFromG) {</span>
<span class="fc" id="L450">                            gapToIndexMap.put(g, moveTo);</span>
<span class="fc" id="L451">                        }</span>
<span class="fc" id="L452">                        gapGroups.get(moveTo).addAll(moveFromG);</span>
<span class="fc" id="L453">                        gapGroups.get(moveFrom).clear();</span>
<span class="fc" id="L454">                    }</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                } else if (uIdx != null) {</span>
<span class="fc" id="L456">                    groupIdx = uIdx;</span>
<span class="fc" id="L457">                    List&lt;Gap&gt; group = gapGroups.get(groupIdx);</span>
<span class="fc" id="L458">                    group.add(vNode);</span>
<span class="fc" id="L459">                    gapToIndexMap.put(vNode, groupIdx);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">                } else if (vIdx != null) {</span>
<span class="fc" id="L461">                    groupIdx = vIdx;</span>
<span class="fc" id="L462">                    List&lt;Gap&gt; group = gapGroups.get(groupIdx);</span>
<span class="fc" id="L463">                    group.add(uNode);</span>
<span class="fc" id="L464">                    gapToIndexMap.put(uNode, groupIdx);</span>
<span class="fc" id="L465">                } else {</span>
                    // both are null
<span class="fc" id="L467">                    List&lt;Gap&gt; group = new ArrayList&lt;Gap&gt;();</span>
<span class="fc" id="L468">                    group.add(uNode);</span>
<span class="fc" id="L469">                    group.add(vNode);</span>
<span class="fc" id="L470">                    groupIdx = Integer.valueOf(gapGroups.size());</span>
<span class="fc" id="L471">                    gapGroups.add(group);</span>
<span class="fc" id="L472">                    gapToIndexMap.put(uNode, groupIdx);</span>
<span class="fc" id="L473">                    gapToIndexMap.put(vNode, groupIdx);</span>
                }

                //System.out.println(groupIdx + &quot; ==&gt; u &quot; + uNode.toString()
                //    + &quot; v &quot; + vNode.toString());

<span class="fc" id="L479">                stack.push(vNode);</span>
<span class="fc" id="L480">            }</span>

<span class="fc bfc" id="L482" title="All 2 branches covered.">            if (vNodes.isEmpty()) {</span>
                // store u alone
<span class="fc" id="L484">                Integer groupIdx = gapToIndexMap.get(uNode);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">                if (groupIdx == null) {</span>
<span class="fc" id="L486">                    groupIdx = Integer.valueOf(gapGroups.size());</span>
<span class="fc" id="L487">                    List&lt;Gap&gt; group = new ArrayList&lt;Gap&gt;();</span>
<span class="fc" id="L488">                    group.add(uNode);</span>
<span class="fc" id="L489">                    gapGroups.add(group);</span>
<span class="fc" id="L490">                    gapToIndexMap.put(uNode, groupIdx);</span>
                }
            }
<span class="fc" id="L493">        }</span>

        // condense:
<span class="fc" id="L496">        boolean hasAnEmpty = false;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        for (List&lt;Gap&gt; group : gapGroups) {</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            if (group.isEmpty()) {</span>
<span class="fc" id="L499">                hasAnEmpty = true;</span>
<span class="fc" id="L500">                break;</span>
            }
<span class="fc" id="L502">        }</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (hasAnEmpty) {</span>
<span class="fc" id="L504">            List&lt;List&lt;Gap&gt;&gt; tmp = new ArrayList&lt;List&lt;Gap&gt;&gt;(gapGroups.size() - 1);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            for (List&lt;Gap&gt; group : gapGroups) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                if (!group.isEmpty()) {</span>
<span class="fc" id="L507">                    tmp.add(group);</span>
                }
<span class="fc" id="L509">            }</span>
<span class="fc" id="L510">            gapGroups = tmp;</span>
        }

<span class="fc" id="L513">        return gapGroups;</span>
    }

    Stack&lt;Gap&gt; findGaps(Map&lt;Integer, List&lt;PairInt&gt;&gt;
        rowColRanges, int minX, int maxX, int minY, int maxY) {

        // ------- store the gaps in a stack --------
        // runtime complexity is
        // O((maxY-minY+1)*k) where k is the number of contig ranges per row

        // stack is lifo, so push in reverse order of desired use
<span class="fc" id="L524">        Stack&lt;Gap&gt; stack = new java.util.Stack&lt;Gap&gt;();</span>

<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (int row = maxY; row &gt;= minY; row--) {</span>

<span class="fc" id="L528">            Integer key = Integer.valueOf(row);</span>

<span class="fc" id="L530">            List&lt;PairInt&gt; colRanges = rowColRanges.get(key);</span>

<span class="fc bfc" id="L532" title="All 2 branches covered.">            for (int i = (colRanges.size() - 1); i &gt; 0; i--) {</span>

<span class="fc" id="L534">                int gapStart = colRanges.get(i - 1).getY() + 1;</span>
<span class="fc" id="L535">                int gapStop = colRanges.get(i).getX() - 1;</span>

<span class="fc" id="L537">                Gap gap = new Gap(row, gapStart, gapStop);</span>

<span class="fc" id="L539">                stack.push(gap);</span>
            }
        }

<span class="fc" id="L543">        return stack;</span>
    }

    /**
     * given contiguousGapGroups, return the subset that are completely bounded
     * by points (note that the bounds are given by rowColRanges).
     * @param contiguousGapGroups
     * @param minY the minimum row of the points set used to construct rowColRanges
     * @param maxY the maximum row of the points set used to construct rowColRanges
     * @param imageMaxColumn the maximum column index of the image
     * @param rowColRanges map with key = row number and value = list of column
     * ranges for the presence of points.
     * @return subset of contiguousGapGroups that are completely bounded by
     * rowColRanges
     */
    protected List&lt;List&lt;Gap&gt;&gt; findBoundedGaps(List&lt;List&lt;Gap&gt;&gt; contiguousGapGroups,
        int minY, int maxY, int imageMaxColumn,
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges) {

<span class="fc" id="L562">        List&lt;List&lt;Gap&gt;&gt; contiguousBoundedGapGroups = new ArrayList&lt;List&lt;Gap&gt;&gt;();</span>

        /* need a data structure to access all Gaps by row by number.
        Will use a Map with key=integer and value = set of Gaps.
        Since there are not usually very many Gaps per row, will not use
        a sorted list of Gaps as the value, but that might be something to
        consider in the future with stats of the total number of gaps in
        contiguousBoundedGapGroups compared to the number of pixels in sky.
        */
<span class="fc" id="L571">        Map&lt;Integer, Set&lt;Gap&gt;&gt; rowGapsMap = createRowMap(contiguousGapGroups);</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">        for (List&lt;Gap&gt; contiguousGap : contiguousGapGroups) {</span>

<span class="fc" id="L575">            boolean notBounded = false;</span>

<span class="fc bfc" id="L577" title="All 2 branches covered.">            for (Gap gap : contiguousGap) {</span>

<span class="fc" id="L579">                int row = gap.getRow();</span>

                /*
                 check that the gap above it if any is not in a gap that
                 continues to the image boundary
                */
<span class="fc" id="L585">                boolean adjRowGapIsUnbounded =</span>
<span class="fc" id="L586">                    adjacentGapIsConnectedToImageBoundary(gap.getStart(),</span>
<span class="fc" id="L587">                        gap.getStopInclusive(),</span>
<span class="fc" id="L588">                        rowGapsMap.get(Integer.valueOf(row + 1)),</span>
<span class="fc" id="L589">                        rowColRanges.get(Integer.valueOf(row + 1)),</span>
                        imageMaxColumn);

<span class="fc bfc" id="L592" title="All 2 branches covered.">                if (adjRowGapIsUnbounded) {</span>
<span class="fc" id="L593">                    notBounded = true;</span>
<span class="fc" id="L594">                    break;</span>
                }

                /*
                 same check for row below
                */
<span class="fc" id="L600">                adjRowGapIsUnbounded = adjacentGapIsConnectedToImageBoundary(</span>
<span class="fc" id="L601">                    gap.getStart(), gap.getStopInclusive(),</span>
<span class="fc" id="L602">                    rowGapsMap.get(Integer.valueOf(row - 1)),</span>
<span class="fc" id="L603">                    rowColRanges.get(Integer.valueOf(row - 1)),</span>
                    imageMaxColumn);

<span class="fc bfc" id="L606" title="All 2 branches covered.">                if (adjRowGapIsUnbounded) {</span>
<span class="fc" id="L607">                    notBounded = true;</span>
<span class="fc" id="L608">                    break;</span>
                }

<span class="fc" id="L611">                boolean bounded = boundedByPointsInHigherRows(row,</span>
<span class="fc" id="L612">                    gap.getStart(), gap.getStopInclusive(), maxY,</span>
                    imageMaxColumn, rowColRanges);

<span class="fc bfc" id="L615" title="All 2 branches covered.">                if (!bounded) {</span>
<span class="fc" id="L616">                    notBounded = true;</span>
<span class="fc" id="L617">                    break;</span>
                }

<span class="fc" id="L620">                bounded = boundedByPointsInLowerRows(row, gap.getStart(),</span>
<span class="fc" id="L621">                    gap.getStopInclusive(), minY, imageMaxColumn, rowColRanges);</span>

<span class="fc bfc" id="L623" title="All 2 branches covered.">                if (!bounded) {</span>
<span class="fc" id="L624">                    notBounded = true;</span>
<span class="fc" id="L625">                    break;</span>
                }
<span class="fc" id="L627">            }</span>

<span class="fc bfc" id="L629" title="All 2 branches covered.">            if (!notBounded) {</span>
<span class="fc" id="L630">                contiguousBoundedGapGroups.add(contiguousGap);</span>
            }
<span class="fc" id="L632">        }</span>

<span class="fc" id="L634">        return contiguousBoundedGapGroups;</span>
    }

    protected boolean updateForAddedPoints(
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges, int[] rowMinMax,
        Collection&lt;PairInt&gt; addedPoints) {

<span class="fc" id="L641">        boolean allAreWithinExistingRange = true;</span>

        // ------------------- update rowColRanges --------------------------
<span class="fc bfc" id="L644" title="All 2 branches covered.">        for (PairInt p : addedPoints) {</span>

<span class="fc" id="L646">            int row = p.getY();</span>
<span class="fc" id="L647">            Integer rowKey = Integer.valueOf(row);</span>

<span class="fc" id="L649">            int col = p.getX();</span>

<span class="fc" id="L651">            List&lt;PairInt&gt; colRanges = rowColRanges.get(rowKey);</span>

            /*
             cases:
                no row or empty list for row in rowColRanges

                point is before first range in colRanges
                   adjacent to it or not

                point is after last range in colRanges
                   adjacent to it or not

                point is between ranges in colRanges
                   adjacent to a range or not

                point is within range in colRanges

            Note that when the insert is adjacent to a range, have to consider
            whether it is adjacent on both sides, in which case it is a merge.
            */

<span class="fc bfc" id="L672" title="All 4 branches covered.">            if ((colRanges == null) || colRanges.isEmpty()) {</span>

                // case: no row or empty list for row in rowColRanges

<span class="fc" id="L676">                allAreWithinExistingRange = false;</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">                if (colRanges == null) {</span>
<span class="fc" id="L679">                    colRanges = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L680">                    rowColRanges.put(rowKey, colRanges);</span>
                }
<span class="fc" id="L682">                colRanges.add(new PairInt(col, col));</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (row &lt; rowMinMax[0]) {</span>
<span class="fc" id="L684">                    rowMinMax[0] = row;</span>
                }
<span class="fc bfc" id="L686" title="All 2 branches covered.">                if (row &gt; rowMinMax[1]) {</span>
<span class="fc" id="L687">                    rowMinMax[1] = row;</span>
                }
                continue;
            }

<span class="fc" id="L692">            int n = colRanges.size();</span>

<span class="fc bfc" id="L694" title="All 2 branches covered.">            if (col &lt; colRanges.get(0).getX()) {</span>

                //case: point is before first range

<span class="fc" id="L698">                allAreWithinExistingRange = false;</span>

<span class="fc" id="L700">                PairInt first = colRanges.get(0);</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">                if (col == (first.getX() - 1)) {</span>
<span class="fc" id="L702">                    first.setX(col);</span>
                } else {
<span class="nc" id="L704">                    PairInt add = new PairInt(col, col);</span>
<span class="nc" id="L705">                    colRanges.add(0, add);</span>
                }
<span class="fc bfc" id="L707" title="All 2 branches covered.">            } else if (col &gt; colRanges.get(n - 1).getY()) {</span>

                //case: point is after last range

<span class="fc" id="L711">                allAreWithinExistingRange = false;</span>

<span class="fc" id="L713">                PairInt last = colRanges.get(n - 1);</span>

<span class="fc bfc" id="L715" title="All 2 branches covered.">                if (col == (last.getY() + 1)) {</span>
<span class="fc" id="L716">                    last.setY(col);</span>
                } else {
<span class="fc" id="L718">                    PairInt add = new PairInt(col, col);</span>
<span class="fc" id="L719">                    colRanges.add(add);</span>
                }
<span class="fc bfc" id="L721" title="All 2 branches covered.">            } else if (n == 1) {</span>
                // was not before or after the only range, so check within
<span class="fc" id="L723">                PairInt current = colRanges.get(0);</span>
<span class="pc bpc" id="L724" title="2 of 4 branches missed.">                if (!((col &gt;= current.getX()) &amp;&amp; (col &lt;= current.getY()))) {</span>
                    // not in range.  this should not happen
<span class="nc" id="L726">                    throw new IllegalStateException(&quot;error in algorithm: point &quot;</span>
                        + col + &quot;, &quot; + row + &quot; was not added to rowColRanges&quot;);
                }
<span class="fc" id="L729">            } else {</span>

                //case: point is between ranges in colRanges
                // or
                //case: point is within range in colRanges

<span class="fc" id="L735">                boolean added = false;</span>

<span class="pc bpc" id="L737" title="1 of 2 branches missed.">                for (int i = (colRanges.size() - 1); i &gt; 0; i--) {</span>

<span class="fc" id="L739">                    PairInt current = colRanges.get(i);</span>

<span class="fc" id="L741">                    PairInt prev = colRanges.get(i - 1);</span>

                    //case: point is within range in colRanges
<span class="pc bpc" id="L744" title="1 of 4 branches missed.">                    if ((col &gt;= current.getX()) &amp;&amp; (col &lt;= current.getY())) {</span>
                        // no need to change range
<span class="fc" id="L746">                        added = true;</span>
<span class="fc" id="L747">                        break;</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">                    } else if ((i == 1) &amp;&amp;</span>
<span class="pc bpc" id="L749" title="1 of 4 branches missed.">                        (col &gt;= prev.getX()) &amp;&amp; (col &lt;= prev.getY())) {</span>
<span class="fc" id="L750">                        added = true;</span>
<span class="fc" id="L751">                        break;</span>
                    }

                    //case: point is between ranges in colRanges

<span class="fc" id="L756">                    allAreWithinExistingRange = false;</span>

<span class="pc bpc" id="L758" title="1 of 4 branches missed.">                    if ((col &gt;= prev.getY()) &amp;&amp; (col &lt;= current.getX())) {</span>

<span class="pc bpc" id="L760" title="1 of 2 branches missed.">                        if (col == (prev.getY() + 1)) {</span>

                            //if adjacent to current range too, merge them
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                            if (col == (current.getX() - 1)) {</span>
                                // extend prev to current end and remove current
<span class="fc" id="L765">                                prev.setY(current.getY());</span>
<span class="fc" id="L766">                                colRanges.remove(current);</span>
                            } else {
<span class="nc" id="L768">                                prev.setY(col);</span>
                            }
<span class="fc" id="L770">                            added = true;</span>
<span class="fc" id="L771">                            break;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                        } else if (col == (current.getX() - 1)) {</span>
<span class="nc" id="L773">                            current.setX(col);</span>
<span class="nc" id="L774">                            added = true;</span>
<span class="nc" id="L775">                            break;</span>
                        } else {
<span class="nc" id="L777">                            PairInt add = new PairInt(col, col);</span>
<span class="nc" id="L778">                            colRanges.add(i, add);</span>
<span class="nc" id="L779">                            added = true;</span>
<span class="nc" id="L780">                            break;</span>
                        }
                    }
                }
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">                if (!added) {</span>

                    // find min and max of ranges:
<span class="nc" id="L787">                    int[] minMaxCols = findMinMaxColumns(rowColRanges,</span>
                        rowMinMax);

<span class="nc" id="L790">                     List&lt;PairInt&gt; colRanges0 = rowColRanges.get(</span>
<span class="nc" id="L791">                         Integer.valueOf(p.getY()));</span>
<span class="nc" id="L792">                     StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">                     for (PairInt cr : colRanges0) {</span>
<span class="nc" id="L794">                         sb.append(&quot;colRange=&quot; + cr.getX() + &quot;:&quot; + cr.getY());</span>
<span class="nc" id="L795">                         sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L796">                     }</span>

<span class="nc" id="L798">                    throw new IllegalStateException(&quot;point &quot; + p.toString() +</span>
                        &quot; was not added to a colRange. &quot; +
                        &quot; colRanges minX=&quot; + minMaxCols[0] +
                        &quot; maxX=&quot; + minMaxCols[1] + &quot; minRow=&quot; + rowMinMax[0] +
<span class="nc" id="L802">                        &quot; maxRow=&quot; + rowMinMax[1] + &quot; &quot; + sb.toString());</span>
                }
            }
<span class="fc" id="L805">        }</span>

<span class="fc" id="L807">        return allAreWithinExistingRange;</span>
    }

    public void updateRowColRangesForAddedPoints(
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges, int[] rowMinMax,
        int imageMaxColumn, Collection&lt;PairInt&gt; addedPoints) {

        /*
        - update rowColRanges and rowMinMax for individual pixels.
          This is faster to update rowColRanges rather than create it anew
          from all points (not given in arguments).
          * runtime: O(N_addedPoints)
        - findContiguousGaps
          * runtime: &gt; O(m) where m is the number of contig gap ranges by row
        - findBoundedGaps
          * runtime: &gt; O(m) where m is the number of contig gap ranges by row
        - update rowColRanges to include the truly embedded gaps just verified
          * runtime:

        Note that can avoid the last 3 steps if the addedPoints all exist within
        existing ranges in rowColRanges.
        */

<span class="fc" id="L830">        boolean allAreWithinExistingRange = updateForAddedPoints(</span>
            rowColRanges, rowMinMax, addedPoints);

<span class="fc bfc" id="L833" title="All 2 branches covered.">        if (allAreWithinExistingRange) {</span>
<span class="fc" id="L834">            return;</span>
        }

        // ------- find minX and maxX -------
        // runtime is O(rowColRanges.size)
<span class="fc" id="L839">        int minY = rowMinMax[0];</span>
<span class="fc" id="L840">        int maxY = rowMinMax[1];</span>
<span class="fc" id="L841">        int minX = Integer.MAX_VALUE;</span>
<span class="fc" id="L842">        int maxX = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">        for (int row = minY; row &lt;= maxY; row++) {</span>
<span class="fc" id="L844">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>
<span class="pc bpc" id="L845" title="2 of 4 branches missed.">            if ((colRanges == null) || colRanges.isEmpty()) {</span>
<span class="nc" id="L846">                continue;</span>
            }
<span class="fc" id="L848">            int n = colRanges.size();</span>
<span class="fc" id="L849">            PairInt cr = colRanges.get(0);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">            if (cr.getX() &lt; minX) {</span>
<span class="fc" id="L851">                minX = cr.getX();</span>
            }
<span class="fc bfc" id="L853" title="All 2 branches covered.">            if (n &gt; 1) {</span>
<span class="fc" id="L854">                cr = colRanges.get(n - 1);</span>
            }
<span class="fc bfc" id="L856" title="All 2 branches covered.">            if (cr.getY() &gt; maxX) {</span>
<span class="fc" id="L857">                maxX = cr.getY();</span>
            }
        }

        // runtime complexity is &gt; O(m) where m is the number of contig gap ranges by row
<span class="fc" id="L862">        List&lt;List&lt;Gap&gt;&gt; contiguousGaps = findContiguousGaps(rowColRanges,</span>
            minX, maxX, minY, maxY);

        //runtime complexity is &gt; O(m) where m is the number of contig gap ranges by row
<span class="fc" id="L866">        List&lt;List&lt;Gap&gt;&gt; embeddedGapGroups = findBoundedGaps(contiguousGaps, minY,</span>
            maxY, imageMaxColumn, rowColRanges);

        // update the rowColRanges to encapsulate the truly embedded points too
<span class="fc" id="L870">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L872" title="All 2 branches covered.">        for (List&lt;Gap&gt; embeddedGroup : embeddedGapGroups) {</span>

<span class="fc" id="L874">            updateRowColRangesForVerifiedEmbedded(rowColRanges,</span>
                embeddedGroup, outputEmbeddedGapPoints);
<span class="fc" id="L876">        }</span>
<span class="fc" id="L877">    }</span>

    private void updateRowColRangesForVerifiedEmbedded(
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges,
        Collection&lt;Gap&gt; embeddedGaps, Set&lt;PairInt&gt; outputEmbeddedGapPoints) {

<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (Gap gap : embeddedGaps) {</span>

<span class="fc" id="L885">            int row = gap.getRow();</span>

<span class="fc" id="L887">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="fc bfc" id="L889" title="All 2 branches covered.">            for (int i = (colRanges.size() - 1); i &gt; 0; i--) {</span>

<span class="fc" id="L891">                int gapStart = colRanges.get(i - 1).getY() + 1;</span>
<span class="fc" id="L892">                int gapStop = colRanges.get(i).getX() - 1;</span>

<span class="pc bpc" id="L894" title="1 of 4 branches missed.">                if ((gap.getStart() == gapStart) &amp;&amp; (gap.getStopInclusive() == gapStop)) {</span>

<span class="fc" id="L896">                    PairInt edit = colRanges.get(i - 1);</span>

<span class="fc" id="L898">                    PairInt current = colRanges.get(i);</span>

<span class="fc" id="L900">                    edit.setY(current.getY());</span>

<span class="fc" id="L902">                    colRanges.remove(i);</span>

<span class="fc bfc" id="L904" title="All 2 branches covered.">                    for (int cIdx = gapStart; cIdx &lt;= gapStop; cIdx++) {</span>
<span class="fc" id="L905">                        outputEmbeddedGapPoints.add(new PairInt(cIdx, row));</span>
                    }
                }
            }
<span class="fc" id="L909">        }</span>
<span class="fc" id="L910">    }</span>

    /**
     * find the pixels which are the borders of rowColRanges including concave
     * pixels, but excluding any pixels that are the image border pixels.
     * Note that rowColRanges has to represent a contiguous point set.
     *
     * @param rowColRanges the column bounds for each row of a contiguous
     * point set.
     * @param rowMinMax the minimum and maximum rows present in the contiguous
     * point set.
     * @param imageMaxColumn the maximum column in the image from which the
     * point set was derived.
     * @param imageMaxRow the maximum row in the image from which the point
     * set was derived.
     * @return
     */
    public Set&lt;PairInt&gt; getBorderPixels(Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges,
        int[] rowMinMax, int imageMaxColumn, int imageMaxRow) {

<span class="fc" id="L930">        Set&lt;PairInt&gt; borderPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (rowColRanges.isEmpty()) {</span>
<span class="nc" id="L933">            return borderPixels;</span>
        }

<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="fc" id="L937">            algorithms.misc.MiscDebug.assertAllRowsPopulated(rowColRanges,</span>
                rowMinMax, imageMaxColumn, imageMaxRow);
        }

        /*
        Need to handle concave bounds:
           [][][][][][][][]
           [][]    [][]  [][]
              [][][][][][]
             []     []
              [][]
           [][]  [][]  [][] &lt;--- the 2nd to last point should be found as border too
              [][]  [][][]  &lt;--- same for 3rd to last here and 2nd in row

          ___________________
          |[][][][][][][][]  |  Find the min and max column bounds for the
          |[][]    [][]  [][]|  region.  make a point set of all points that
          |   [][][][][][]   |  are not in a colRange.
          |  []     []       |  Find the contiguous groups among those points.
          |   [][]           |  Then iterate over the boundaries of the region
          |[][]  [][]  [][]  |  to test whether a point is found n a group,
          |   [][]  [][][]   |  and when it is, put it in a set called
          --------------------  connectedToBounds.
                                        Then iterate over each point in colRanges
        ----------------------------    and for each test if it is adjacent to
        |     ___________________       a point in connectedToBounds.
        |     |[][][][][][][][]  |      If the point is connected, put it in the
        |     |[][]    [][]  [][]|  border points set.
        |     |   [][][][][][]   |
        |     |  []     [][][]   |  Then, if the top row is &gt; 0, add the top
        |     |   [][]           |  row colRange pixels to border points set.
        |     |[][]  []  [][][]  |
        |     |   [][]  [][][]   |  Then, if the bottow row is &lt; max of image rows,
        |     --------------------  add the bottom row colRange pixels to
        |                           border points.
        ----------------------------
                                    Then if any colRanges are equal to the leftmost
                                    region bounds and that is &gt; 0,
                                    those points should be added to border pixels set.

        Then if any colRanges are equal to the rightmost region bounds and that
        is &lt; imageMaxColumn, those points should be added to border pixels set.

        */

<span class="fc" id="L982">        int[] colMinMax = getMinMaxColumnsInRanges(rowColRanges, rowMinMax);</span>

        // ---- find nonMembers that are connected to the bounds of the -----
        // ---- region bounded by rowMinMax and colMinMax               -----

<span class="fc" id="L987">        Set&lt;PairInt&gt; nonMembersConnectedToBounds =</span>
<span class="fc" id="L988">            findNonMembersConnectedToBounds(rowColRanges, rowMinMax, colMinMax,</span>
                imageMaxColumn, imageMaxRow);

        //int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
        //int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};
<span class="fc" id="L993">        int[] dxs = new int[]{-1, 0,  1, 0};</span>
<span class="fc" id="L994">        int[] dys = new int[]{ 0, -1, 0, 1};</span>

        // --- for each member in colRanges, if it's adjacent to a point
        // --- in nonMembersConnectedToBounds it's a border point
<span class="fc bfc" id="L998" title="All 2 branches covered.">        for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; ++row) {</span>

<span class="fc" id="L1000">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="pc bpc" id="L1002" title="2 of 4 branches missed.">            if (colRanges == null || colRanges.isEmpty()) {</span>
<span class="nc" id="L1003">                throw new IllegalStateException(</span>
                &quot;each row should have a point in it, else not contiguous&quot;);
            }

<span class="fc bfc" id="L1007" title="All 2 branches covered.">            for (PairInt colRange : colRanges) {</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">                for (int col = colRange.getX(); col &lt;= colRange.getY(); ++col) {</span>

                    // test if adjacent to a point in nonMembersConnectedToBounds
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                    for (int idx = 0; idx &lt; dxs.length; ++idx) {</span>

<span class="fc" id="L1013">                        int x = col + dxs[idx];</span>
<span class="fc" id="L1014">                        int y = row + dys[idx];</span>

<span class="fc" id="L1016">                        PairInt t = new PairInt(x, y);</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">                        if (nonMembersConnectedToBounds.contains(t)) {</span>
<span class="fc" id="L1018">                            borderPixels.add(new PairInt(col, row));</span>
<span class="fc" id="L1019">                            break;</span>
                        }
                    }
                }
<span class="fc" id="L1023">            }</span>
        }

        // --- then add any pixels on the bounds if the bounds is not the
        //     same as the image bounds

        int[] rows;
<span class="fc bfc" id="L1030" title="All 2 branches covered.">        if (rowMinMax[0] &gt; 0) {</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">            if (rowMinMax[1] &lt; imageMaxRow) {</span>
<span class="fc" id="L1032">                rows = new int[]{rowMinMax[0], rowMinMax[1]};</span>
            } else {
<span class="fc" id="L1034">                rows = new int[]{rowMinMax[0]};</span>
            }
<span class="fc bfc" id="L1036" title="All 2 branches covered.">        } else if (rowMinMax[1] &lt; imageMaxRow) {</span>
<span class="fc" id="L1037">            rows = new int[]{rowMinMax[1]};</span>
        } else {
<span class="fc" id="L1039">            rows = new int[]{};</span>
        }

<span class="fc bfc" id="L1042" title="All 2 branches covered.">        for (int row : rows) {</span>

<span class="fc" id="L1044">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="pc bpc" id="L1046" title="2 of 4 branches missed.">            if (colRanges == null || colRanges.isEmpty()) {</span>
<span class="nc" id="L1047">                throw new IllegalStateException(</span>
                &quot;each row should have a point in it, else not contiguous&quot;);
            }

<span class="fc bfc" id="L1051" title="All 2 branches covered.">            for (PairInt colRange : colRanges) {</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">                for (int col = colRange.getX(); col &lt;= colRange.getY(); ++col) {</span>
<span class="fc" id="L1053">                    borderPixels.add(new PairInt(col, row));</span>
                }
<span class="fc" id="L1055">            }</span>
        }

<span class="fc bfc" id="L1058" title="All 2 branches covered.">        for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; ++row) {</span>

<span class="fc" id="L1060">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="pc bpc" id="L1062" title="2 of 4 branches missed.">            if (colRanges == null || colRanges.isEmpty()) {</span>
<span class="nc" id="L1063">                throw new IllegalStateException(</span>
                &quot;each row should have a point in it, else not contiguous&quot;);
            }

<span class="fc" id="L1067">            int firstX = colRanges.get(0).getX();</span>

<span class="pc bpc" id="L1069" title="1 of 4 branches missed.">            if ((colMinMax[0] &gt; 0) &amp;&amp; (firstX &gt;= colMinMax[0])) {</span>
<span class="fc" id="L1070">                borderPixels.add(new PairInt(firstX, row));</span>
<span class="pc bpc" id="L1071" title="1 of 4 branches missed.">            } else if ((colMinMax[0] == 0) &amp;&amp; (firstX &gt; colMinMax[0])) {</span>
<span class="fc" id="L1072">                borderPixels.add(new PairInt(firstX, row));</span>
            }

<span class="fc" id="L1075">            int n = colRanges.size();</span>

<span class="fc" id="L1077">            int lastX = colRanges.get(n - 1).getY();</span>

<span class="pc bpc" id="L1079" title="1 of 4 branches missed.">            if ((colMinMax[1] &lt; imageMaxColumn) &amp;&amp; (lastX &lt;= colMinMax[1])) {</span>
<span class="fc" id="L1080">                borderPixels.add(new PairInt(lastX, row));</span>
<span class="pc bpc" id="L1081" title="1 of 4 branches missed.">            } else if ((colMinMax[1] == imageMaxColumn) &amp;&amp; (lastX &lt; colMinMax[1])) {</span>
<span class="fc" id="L1082">                borderPixels.add(new PairInt(lastX, row));</span>
            }
        }

<span class="fc" id="L1086">        return borderPixels;</span>
    }

    /**
     * get a point set of the points not in column ranges for the region bounded
     * by min row, max row, and the minimum of columns and the maximum of columns.
     * @param rowColRanges
     * @param rowMinMax
     * @param colMinMax
     * @param imageMaxColumn
     * @param imageMaxRow
     * @return
     */
    public Set&lt;PairInt&gt; getVoidsInRectangularRegion(Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges,
        int[] rowMinMax, int[] colMinMax, int imageMaxColumn, int imageMaxRow) {

<span class="fc" id="L1102">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L1104" title="All 2 branches covered.">        for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; row++) {</span>

<span class="fc" id="L1106">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="pc bpc" id="L1108" title="2 of 4 branches missed.">            if ((colRanges == null) || colRanges.isEmpty()) {</span>
<span class="nc" id="L1109">                continue;</span>
            }

<span class="fc" id="L1112">            int n = colRanges.size();</span>

<span class="fc" id="L1114">            PairInt colRange = colRanges.get(0);</span>

<span class="fc bfc" id="L1116" title="All 2 branches covered.">            for (int x = colMinMax[0]; x &lt; colRange.getX(); ++x) {</span>
<span class="fc" id="L1117">                set.add(new PairInt(x, row));</span>
            }

<span class="fc bfc" id="L1120" title="All 2 branches covered.">            for (int i = 1; i &lt; n; ++i) {</span>
<span class="fc" id="L1121">                int lx = colRange.getY();</span>
<span class="fc" id="L1122">                colRange = colRanges.get(i);</span>
<span class="fc" id="L1123">                int rx = colRange.getX();</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">                for (int x = (lx + 1); x &lt; rx; ++x) {</span>
<span class="fc" id="L1125">                    set.add(new PairInt(x, row));</span>
                }
            }

<span class="fc bfc" id="L1129" title="All 2 branches covered.">            for (int x = (colRange.getY() + 1); x &lt;= colMinMax[1]; ++x) {</span>
<span class="fc" id="L1130">                set.add(new PairInt(x, row));</span>
            }
        }

<span class="fc" id="L1134">        return set;</span>
    }

    public int[] getMinMaxColumnsInRanges(Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges,
        int[] rowMinMax) {

<span class="fc" id="L1140">        int minX = Integer.MAX_VALUE;</span>
<span class="fc" id="L1141">        int maxX = Integer.MIN_VALUE;</span>

<span class="fc bfc" id="L1143" title="All 2 branches covered.">        for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; row++) {</span>

<span class="fc" id="L1145">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="pc bpc" id="L1147" title="2 of 4 branches missed.">            if ((colRanges == null) || colRanges.isEmpty()) {</span>
<span class="nc" id="L1148">                continue;</span>
            }

<span class="fc" id="L1151">            int n = colRanges.size();</span>

<span class="fc" id="L1153">            int tc = colRanges.get(0).getX();</span>

<span class="fc bfc" id="L1155" title="All 2 branches covered.">            if (tc &lt; minX) {</span>
<span class="fc" id="L1156">                minX = tc;</span>
            }
<span class="fc" id="L1158">            tc = colRanges.get(n - 1).getY();</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">            if (tc &gt; maxX) {</span>
<span class="fc" id="L1160">                maxX = tc;</span>
            }
        }

<span class="fc" id="L1164">        return new int[]{minX, maxX};</span>
    }

    protected Gap findLastGap(Set&lt;Gap&gt; gaps) {
<span class="fc" id="L1168">        Gap lastGap = null;</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        for (Gap gap : gaps) {</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">            if (lastGap == null) {</span>
<span class="fc" id="L1171">                lastGap = gap;</span>
            } else {
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                if (gap.getStopInclusive() &gt; lastGap.getStopInclusive()) {</span>
<span class="fc" id="L1174">                    lastGap = gap;</span>
                }
            }
<span class="fc" id="L1177">        }</span>
<span class="fc" id="L1178">        return lastGap;</span>
    }

    protected Gap findFirstGap(Set&lt;Gap&gt; gaps) {
<span class="fc" id="L1182">        Gap firstGap = null;</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        for (Gap gap : gaps) {</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">            if (firstGap == null) {</span>
<span class="fc" id="L1185">                firstGap = gap;</span>
            } else {
<span class="fc bfc" id="L1187" title="All 2 branches covered.">                if (gap.getStart() &lt; firstGap.getStart()) {</span>
<span class="fc" id="L1188">                    firstGap = gap;</span>
                }
            }
<span class="fc" id="L1191">        }</span>
<span class="fc" id="L1192">        return firstGap;</span>
    }

    protected boolean adjacentGapIsConnectedToImageBoundary(
        int startGap, int stopGapInclusive, Set&lt;Gap&gt; adjacentGaps,
        List&lt;PairInt&gt; adjacentColRanges, int imageMaxColumn) {

<span class="fc bfc" id="L1199" title="All 4 branches covered.">        if ((adjacentColRanges == null) || adjacentColRanges.isEmpty()) {</span>
<span class="fc" id="L1200">            return true;</span>
        }

        /*
        check to see if the startGap:stopGapInclusive is adjacent to a
        row which has a leading or trailing gap which is connected to the image
        boundaries.
        */
<span class="fc" id="L1208">        PairInt lastColRange = adjacentColRanges.get(adjacentColRanges.size() - 1);</span>
<span class="pc bpc" id="L1209" title="1 of 4 branches missed.">        if ((adjacentGaps == null) || adjacentGaps.isEmpty()) {</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">            if (lastColRange.getY() &lt; imageMaxColumn) {</span>
<span class="fc bfc" id="L1211" title="All 2 branches covered.">                if (stopGapInclusive &gt;= (lastColRange.getY() + 1)) {</span>
<span class="fc" id="L1212">                    return true;</span>
                }
            }
        } else {
<span class="fc" id="L1216">            Gap lastGap = findLastGap(adjacentGaps);</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">            if (lastColRange.getX() &gt; lastGap.getStopInclusive()) {</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">                if (lastColRange.getY() &lt; imageMaxColumn) {</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">                    if (stopGapInclusive &gt;= (lastColRange.getY() + 1)) {</span>
<span class="fc" id="L1220">                        return true;</span>
                    }
                }
            }
        }
<span class="fc" id="L1225">        PairInt firstColRange = adjacentColRanges.get(0);</span>
<span class="pc bpc" id="L1226" title="1 of 4 branches missed.">        if ((adjacentGaps == null) || adjacentGaps.isEmpty()) {</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">            if (firstColRange.getX() &gt; 0) {</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">                if (startGap &lt;= (firstColRange.getX() - 1)) {</span>
<span class="fc" id="L1229">                    return true;</span>
                }
            }
        } else {
<span class="fc" id="L1233">            Gap firstGap = findFirstGap(adjacentGaps);</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">            if (firstColRange.getY() &lt; firstGap.getStart()) {</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">                if (firstColRange.getX() &gt; 0) {</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">                    if (startGap &lt;= (firstColRange.getX() - 1)) {</span>
<span class="fc" id="L1237">                        return true;</span>
                    }
                }
            }
        }

<span class="pc bpc" id="L1243" title="1 of 4 branches missed.">        if ((adjacentGaps == null) || adjacentGaps.isEmpty()) {</span>
<span class="fc" id="L1244">            return false;</span>
        }

<span class="fc bfc" id="L1247" title="All 2 branches covered.">        for (int col = startGap; col &lt;= stopGapInclusive; col++) {</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">            for (Gap gap : adjacentGaps) {</span>
<span class="fc bfc" id="L1249" title="All 4 branches covered.">                if ((col &gt;= gap.getStart()) &amp;&amp; (col &lt;= gap.getStopInclusive())) {</span>
<span class="fc bfc" id="L1250" title="All 4 branches covered.">                    if ((gap.getStart() == 0) || (gap.getStopInclusive() == imageMaxColumn)) {</span>
<span class="fc" id="L1251">                        return true;</span>
                    }
                }
<span class="fc" id="L1254">            }</span>
        }

<span class="fc" id="L1257">        return false;</span>
    }

    protected Map&lt;Integer, Set&lt;Gap&gt;&gt; createRowMap(List&lt;List&lt;Gap&gt;&gt; gapLists) {

<span class="fc" id="L1262">        Map&lt;Integer, Set&lt;Gap&gt;&gt; rowSetsMap = new HashMap&lt;Integer, Set&lt;Gap&gt;&gt;();</span>

<span class="fc bfc" id="L1264" title="All 2 branches covered.">        for (List&lt;Gap&gt; gaps : gapLists) {</span>

<span class="fc bfc" id="L1266" title="All 2 branches covered.">            for (Gap gap : gaps) {</span>

<span class="fc" id="L1268">                Integer row = Integer.valueOf(gap.getRow());</span>

<span class="fc" id="L1270">                Set&lt;Gap&gt; set = rowSetsMap.get(row);</span>

<span class="fc bfc" id="L1272" title="All 2 branches covered.">                if (set == null) {</span>
<span class="fc" id="L1273">                    set = new HashSet&lt;Gap&gt;();</span>
<span class="fc" id="L1274">                    rowSetsMap.put(row, set);</span>
                }

<span class="fc" id="L1277">                set.add(gap);</span>
<span class="fc" id="L1278">            }</span>
<span class="fc" id="L1279">        }</span>

<span class="fc" id="L1281">        return rowSetsMap;</span>
    }

    protected int findIndexOfOverlappingRange(List&lt;PairInt&gt; colRanges,
        PairInt findColRange) {

<span class="pc bpc" id="L1287" title="1 of 4 branches missed.">        if ((colRanges == null) || colRanges.isEmpty()) {</span>
<span class="fc" id="L1288">            return -1;</span>
        }
<span class="fc" id="L1290">        int fc0 = findColRange.getX();</span>
<span class="fc" id="L1291">        int fc1 = findColRange.getY();</span>

<span class="fc bfc" id="L1293" title="All 2 branches covered.">        for (int i = 0; i &lt; colRanges.size(); i++) {</span>
<span class="fc" id="L1294">            PairInt colRange = colRanges.get(i);</span>
<span class="fc" id="L1295">            int c0 = colRange.getX();</span>
<span class="fc" id="L1296">            int c1 = colRange.getY();</span>

<span class="fc bfc" id="L1298" title="All 4 branches covered.">            if ((fc0 &lt;= c0) &amp;&amp; (fc1 &gt;= c0)) {</span>
<span class="fc" id="L1299">                return i;</span>
<span class="fc bfc" id="L1300" title="All 4 branches covered.">            } else if ((fc0 &gt;= c0) &amp;&amp; (fc0 &lt;= c1)) {</span>
<span class="fc" id="L1301">                return i;</span>
            }
        }
<span class="fc" id="L1304">        return -1;</span>
    }

    private int[] findMinMaxColumns(Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges,
        int[] rowMinMax) {

        // runtime is O(rowColRanges.size)
<span class="nc" id="L1311">        int minY = rowMinMax[0];</span>
<span class="nc" id="L1312">        int maxY = rowMinMax[1];</span>
<span class="nc" id="L1313">        int minX = Integer.MAX_VALUE;</span>
<span class="nc" id="L1314">        int maxX = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        for (int row = minY; row &lt;= maxY; row++) {</span>
<span class="nc" id="L1316">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>
<span class="nc bnc" id="L1317" title="All 4 branches missed.">            if ((colRanges == null) || colRanges.isEmpty()) {</span>
<span class="nc" id="L1318">                continue;</span>
            }
<span class="nc" id="L1320">            int n = colRanges.size();</span>
<span class="nc" id="L1321">            PairInt cr = colRanges.get(0);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if (cr.getX() &lt; minX) {</span>
<span class="nc" id="L1323">                minX = cr.getX();</span>
            }
<span class="nc bnc" id="L1325" title="All 2 branches missed.">            if (n &gt; 1) {</span>
<span class="nc" id="L1326">                cr = colRanges.get(n - 1);</span>
            }
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            if (cr.getY() &gt; maxX) {</span>
<span class="nc" id="L1329">                maxX = cr.getY();</span>
            }
        }

<span class="nc" id="L1333">        return new int[]{minX, maxX};</span>
    }

    private Map&lt;Integer, List&lt;PairInt&gt;&gt; copy(
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges, int[] rowMinMax) {

<span class="nc" id="L1339">         Map&lt;Integer, List&lt;PairInt&gt;&gt; output = new HashMap&lt;Integer, List&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">         for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; ++row) {</span>

<span class="nc" id="L1342">             Integer key = Integer.valueOf(row);</span>

<span class="nc" id="L1344">             List&lt;PairInt&gt; colRanges = rowColRanges.get(key);</span>

<span class="nc" id="L1346">             List&lt;PairInt&gt; outputColRanges = new ArrayList&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1348" title="All 2 branches missed.">             for (PairInt p : colRanges) {</span>
<span class="nc" id="L1349">                 outputColRanges.add(new PairInt(p.getX(), p.getY()));</span>
<span class="nc" id="L1350">             }</span>

<span class="nc" id="L1352">             output.put(key, outputColRanges);</span>
         }

<span class="nc" id="L1355">         return output;</span>
    }

    public Set&lt;PairInt&gt; findNonMembersConnectedToBounds(
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges, int[] rowMinMax,
        int[] colMinMax, int imageMaxColumn, int imageMaxRow) {

<span class="fc" id="L1362">        Set&lt;PairInt&gt; nonMembers = getVoidsInRectangularRegion(rowColRanges,</span>
            rowMinMax, colMinMax, imageMaxColumn, imageMaxRow);

        //Find the contiguous groups among nonMembers.
<span class="fc" id="L1366">        DFSConnectedGroupsFinder contigFinder = new DFSConnectedGroupsFinder();</span>
<span class="fc" id="L1367">        contigFinder.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L1368">        contigFinder.findConnectedPointGroups(nonMembers, imageMaxColumn,</span>
            imageMaxRow);

<span class="fc" id="L1371">        Set&lt;Set&lt;PairInt&gt;&gt; contigNonMembers = new HashSet&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">        for (int i = 0; i &lt; contigFinder.getNumberOfGroups(); ++i) {</span>
<span class="fc" id="L1373">            Set&lt;PairInt&gt; group = contigFinder.getXY(i);</span>
<span class="fc" id="L1374">            contigNonMembers.add(group);</span>
        }

<span class="fc" id="L1377">        Set&lt;PairInt&gt; contigNonMembersConnectedToBounds = new HashSet&lt;PairInt&gt;();</span>

        // --- find the top and bottom row pixels not in colRanges and test memberships ---
<span class="fc" id="L1380">        int[] rows = new int[]{rowMinMax[0], rowMinMax[1]};</span>

<span class="fc bfc" id="L1382" title="All 2 branches covered.">        for (int row : rows) {</span>

<span class="fc" id="L1384">            List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(row));</span>

<span class="pc bpc" id="L1386" title="2 of 4 branches missed.">            if ((colRanges == null) || colRanges.isEmpty()) {</span>
<span class="nc" id="L1387">                continue;</span>
            }

<span class="fc" id="L1390">            int n = colRanges.size();</span>

<span class="fc" id="L1392">            PairInt colRange = colRanges.get(0);</span>

<span class="fc bfc" id="L1394" title="All 2 branches covered.">            for (int x = colMinMax[0]; x &lt; colRange.getX(); ++x) {</span>
<span class="fc" id="L1395">                PairInt t = new PairInt(x, row);</span>
<span class="fc" id="L1396">                Set&lt;PairInt&gt; keep = null;</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">                for (Set&lt;PairInt&gt; set : contigNonMembers) {</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">                    if (set.contains(t)) {</span>
<span class="fc" id="L1399">                        keep = set;</span>
<span class="fc" id="L1400">                        break;</span>
                    }
<span class="fc" id="L1402">                }</span>
<span class="fc bfc" id="L1403" title="All 2 branches covered.">                if (keep != null) {</span>
<span class="fc" id="L1404">                    contigNonMembersConnectedToBounds.addAll(keep);</span>
<span class="fc" id="L1405">                    contigNonMembers.remove(keep);</span>
                }
            }

<span class="fc bfc" id="L1409" title="All 2 branches covered.">            for (int i = 1; i &lt; n; ++i) {</span>
<span class="fc" id="L1410">                int lx = colRange.getY();</span>
<span class="fc" id="L1411">                colRange = colRanges.get(i);</span>
<span class="fc" id="L1412">                int rx = colRange.getX();</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">                for (int x = (lx + 1); x &lt; rx; ++x) {</span>
<span class="fc" id="L1414">                    PairInt t = new PairInt(x, row);</span>
<span class="fc" id="L1415">                    Set&lt;PairInt&gt; keep = null;</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">                    for (Set&lt;PairInt&gt; set : contigNonMembers) {</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">                        if (set.contains(t)) {</span>
<span class="fc" id="L1418">                            keep = set;</span>
<span class="fc" id="L1419">                            break;</span>
                        }
<span class="fc" id="L1421">                    }</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">                    if (keep != null) {</span>
<span class="fc" id="L1423">                        contigNonMembersConnectedToBounds.addAll(keep);</span>
<span class="fc" id="L1424">                        contigNonMembers.remove(keep);</span>
                    }
                }
            }

<span class="fc bfc" id="L1429" title="All 2 branches covered.">            for (int x = (colRange.getY() + 1); x &lt;= colMinMax[1]; ++x) {</span>
<span class="fc" id="L1430">                PairInt t = new PairInt(x, row);</span>
<span class="fc" id="L1431">                Set&lt;PairInt&gt; keep = null;</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">                for (Set&lt;PairInt&gt; set : contigNonMembers) {</span>
<span class="fc bfc" id="L1433" title="All 2 branches covered.">                    if (set.contains(t)) {</span>
<span class="fc" id="L1434">                        keep = set;</span>
<span class="fc" id="L1435">                        break;</span>
                    }
<span class="fc" id="L1437">                }</span>
<span class="fc bfc" id="L1438" title="All 2 branches covered.">                if (keep != null) {</span>
<span class="fc" id="L1439">                    contigNonMembersConnectedToBounds.addAll(keep);</span>
<span class="fc" id="L1440">                    contigNonMembers.remove(keep);</span>
                }
            }
        }

        // --- scan the pixels in first and last columns and test membership ---
        // --- in contigNonMembers
<span class="fc" id="L1447">        int[] cols = new int[]{colMinMax[0], colMinMax[1]};</span>

<span class="fc bfc" id="L1449" title="All 2 branches covered.">        for (int col : cols) {</span>

<span class="fc bfc" id="L1451" title="All 2 branches covered.">            for (int row = rowMinMax[0]; row &lt;= rowMinMax[1]; ++row) {</span>

<span class="fc" id="L1453">                PairInt t = new PairInt(col, row);</span>
<span class="fc" id="L1454">                Set&lt;PairInt&gt; keep = null;</span>
<span class="fc bfc" id="L1455" title="All 2 branches covered.">                for (Set&lt;PairInt&gt; set : contigNonMembers) {</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">                    if (set.contains(t)) {</span>
<span class="fc" id="L1457">                        keep = set;</span>
<span class="fc" id="L1458">                        break;</span>
                    }
<span class="fc" id="L1460">                }</span>

<span class="fc bfc" id="L1462" title="All 2 branches covered.">                if (keep != null) {</span>
<span class="fc" id="L1463">                    contigNonMembersConnectedToBounds.addAll(keep);</span>
<span class="fc" id="L1464">                    contigNonMembers.remove(keep);</span>
                }
            }
        }

<span class="fc" id="L1469">        return contigNonMembersConnectedToBounds;</span>
    }

    /* NOT READY FOR USE
     * Walk the border to find the perimeter border pixels.
     * Note that rowColRanges has to represent the contiguous point set called points.
     * Note also that this method removes spurs (single pixel width paths
     * without a turn around).
     * If wanted to keep the spurs and still have a connected sequential curve,
     * could copy this method and instead of back-tracking, add the previous
     * point in the linked list at the dead end and continue (for the spurs,
     * there will be the same points leading out and back composing the spur
     * in the final curve - special care is needed for starter points which
     * are spurs and storing &quot;visited&quot; for that altered algorithm).
     *
     * @param rowColRanges the column bounds for each row of a contiguous
     * point set.
     * @param rowMinMax the minimum and maximum rows present in the contiguous
     * point set.
     * @param imageMaxColumn the maximum column in the image from which the
     * point set was derived.
     * @param imageMaxRow the maximum row in the image from which the point
     * set was derived.
     * @return
    public PairIntArray getOrderedBorderPixels(Set&lt;PairInt&gt; points,
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges,
        int[] rowMinMax, int imageMaxColumn, int imageMaxRow) {

        PerimeterFinderMemo memo = new PerimeterFinderMemo();

        BitVectorRepresentation bitVectorHelper = new BitVectorRepresentation(points);

        //the algorithm uses rowColRanges to make a starting point and add it
        //to the path of steps.
        //
        //for each currentStep, the state at the time of instantiation is stored
        //in it's node.  the state is it's pixel location, a summary of all visited
        //nodes at that moment, and the available moves for the pixel location.
        //
        //it's available moves are adjacent points that have at least one non-point
        //neighbor (the goal is to find border points, so has to be on perimeter
        //of points) and have not been visited yet.
        //
        //at each iteration, the currentStep is first checked against memo's list
        //of known &quot;non-solution states&quot;.  if that exists, it backtracks (without
        //storing backtrack state again).
        //If the currentStep was not found by memo, its nextSteps are examined to
        //choose the next step if any is possible, else backtrack if none are
        //possible. (Note that backtracking stores the entire path in memo to
        //capture the state of nodes that led to &quot;no solution&quot; and then removes
        //currentStep from previous step's nextSteps, removes currentStep from visited
        //and border,
        //then removes currentStep from path and sets currentStep to last node in path).
        //(Note, that the responsibility of updating a step's nextNodes to remove
        //a point should only occur at backtrack stage after memoization in order
        //to allow correct recognition of state later to avoid &quot;non-solution&quot; states).
        // 
        //If a next step is possible (did not backtrack), a PathStep is created
        //for the nextStep and it is added to the path, border, and visited.
        //
        //then iteration continues until an end state is reached.
        //end state is currentStep is adjacent to starter point after have left
        //the start region, or all points have been visited or all paths tried &lt;--- review this

        //example for memoization and backtracking.
        //
        //In this example, can see that when the path reaches node 20, needs to
        //backtrack to node 1 and choose 1-&gt;4 instead of 1-&gt;2-&gt;3-&gt;4.
        //
        //Can see that nodes 5 to 18 are outside of an interaction distance with
        //path nodes 1 through 4, so then, the paths from 5 to 18
        //can be saved and restored if needed later instead of re-computing them 
        //when '4' is next selected as the next node in a path.  the &quot;next move&quot; 
        //after '4' would skip forward to '18' in a choice of one of the saved 
        //paths from 5 to 18.
        //
        //have not implemented that below, but have implemented memoization
        //for states that lead to no-solution, and avoidance of continuing on
        //those paths in the future.
        //
        //see PerimeterFinderMemo.java, in progress...
        //
        //Reuse of successful paths is needed for this algorithm if the point sets
        //are larger than a couple dozen points, UNLESS the method is given 
        //points that are already an edge thinned to single pixel widths at all
        //locations, including the diagonals.
        //
        //55
        //54                     11   12
        //53            9   10   14   13
        //52            8   15
        //51            7   16
        //50            6   17
        //49            5   20   18
        //48            4   19
        //47       1    2    3
        //46       0
        //   125  126  127  128  129  130

        PairIntArray border = new PairIntArray();

        if (rowColRanges.isEmpty()) {
            return border;
        }

        if (points.size() &lt; 5) {
            throw new IllegalArgumentException(
            &quot;points.size() needs to be a least 5 points&quot;);
        }

        if (debug) {
            algorithms.misc.MiscDebug.assertAllRowsPopulated(rowColRanges,
                rowMinMax, imageMaxColumn, imageMaxRow);
        }

        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();

        //xc,yc
        double[] xyCentroid = curveHelper.calculateXYCentroids(points);

        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();
        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();

        // ------- initialize with step 0 ------
        //step 0 should be the smallest row and col,
        //but because it may be a single pixel width spur (which will not end in
        //a closed curve), have to make sure that the added point has at least
        //2 neighbors, else discard it and continue forward until have found a
        //starter point with 2 neighbors.

        int y0 = rowMinMax[0];
        List&lt;PairInt&gt; colRanges = rowColRanges.get(Integer.valueOf(y0));
        PairInt colRange = colRanges.get(0);
        int x0 = colRange.getX();

        //storing the state of choices in a linked list.
        //   each choice holds the col,row of that pixel and the neighbor points
        //      for paths not chosen.
        //backtracking removes last node and chooses from next to last node
        
        LinkedList&lt;PathStep&gt; path = new LinkedList&lt;PathStep&gt;();
        PathStep currentStep = null;

        curveHelper.findNeighborsWithAtLeastOneNonPoint(x0, y0, neighbors,
            points, visited, imageMaxColumn + 1, imageMaxRow + 1);

        if (neighbors.size() &lt; 2) {

            while (neighbors.size() &lt; 2) {
                PairInt p = neighbors.iterator().next();
                x0 = p.getX();
                y0 = p.getY();
                curveHelper.findNeighborsWithAtLeastOneNonPoint(x0, y0,
                    neighbors, points, visited,
                    imageMaxColumn + 1, imageMaxRow + 1);
            }
            border.add(x0, y0);
            visited.add(new PairInt(x0, y0));

            currentStep = new PathStep(new PairInt(x0, y0), neighbors,
                bitVectorHelper.createBitstring(visited));

            path.add(currentStep);

            log.fine(&quot;start point=(&quot; + x0 + &quot;,&quot; + y0 + &quot;)&quot;);

        } else {

            border.add(x0, y0);
            visited.add(new PairInt(x0, y0));

            currentStep = new PathStep(new PairInt(x0, y0), neighbors,
                bitVectorHelper.createBitstring(visited));

            path.add(currentStep);

            log.fine(&quot;start point=(&quot; + x0 + &quot;,&quot; + y0 + &quot;)&quot;);

            // --- take the 2nd step if colRange.getY() is &gt; col, to make start
            //     direction clockwise ---

            if (colRange.getY() &gt; colRange.getX()) {

                PairInt p = new PairInt(x0 + 1, y0);
                border.add(x0 + 1, y0);
                visited.add(p);
                log.fine(&quot;adding (&quot; + (x0 + 1) + &quot;,&quot; + y0 + &quot;)&quot;);

                curveHelper.findNeighborsWithAtLeastOneNonPoint(x0 + 1, y0, 
                    neighbors, points, visited,
                    imageMaxColumn + 1, imageMaxRow + 1);

                currentStep = new PathStep(p, neighbors,
                    bitVectorHelper.createBitstring(visited));

                path.add(currentStep);
            }
        }

        // consider each move in all 8 directions in which move point is
        //   !visited.constains(point) &amp;&amp; points.contains(point)
        //
        //if more than one choice, prefer choice with fewer neighbors.
        //
        //if there are zero choices, remove the latest point from border and try again.
        //
        //repeat while col,row is not adjacent to x0,y0 and visited.size &lt; points.size. &lt;=== reviewing this when testing

        boolean search = true;

        int earliestBacktrack = Integer.MAX_VALUE;

        while (search) {

            boolean currentIsNoSolution = memo.isANoSolutionState(currentStep);
            
            if (currentStep.getNextSteps().isEmpty() || currentIsNoSolution) {

                while (currentStep.getNextSteps().isEmpty() || currentIsNoSolution) {

                    log.fine(&quot;   removing (&quot; + currentStep.getCoords().getX() + &quot;,&quot;
                        + currentStep.getCoords().getY() + &quot;)&quot;
                        + &quot; border.n=&quot; + border.getN() + &quot; path.size=&quot; + path.size()
                    );

                    if (border.getN() == 0) {
                        return null;
                    }

                    // no solution for this path, so store state and backtrack

                    if (!currentIsNoSolution) {
                        // if currentIsNoSolution, state has already been stored
                        memo.storeNoSolutionState(path);
                    }

                    path.removeLast();
                    
                    PathStep nextStep = path.peekLast();

                    if (nextStep != null) {
                        nextStep.getNextSteps().remove(currentStep.getCoords());
                    }

                    border.removeRange(border.getN() - 1, border.getN() - 1);

                    visited.remove(currentStep.getCoords());

                    if (path.size() &lt; earliestBacktrack) {
                        earliestBacktrack = path.size();
                        log.info(&quot;earliestBacktrack=&quot; + earliestBacktrack);
                    }

                    currentStep = nextStep;

                    if (currentStep == null) {
                        return border;
                    }

                    currentIsNoSolution = memo.isANoSolutionState(currentStep);
                }

            } else if (currentStep.getNextSteps().size() == 1) {

                PairInt p = currentStep.getNextSteps().iterator().next();
                border.add(p.getX(), p.getY());
                visited.add(p);
                log.fine(&quot;adding (&quot; + p.getX() + &quot;,&quot; + p.getY() + &quot;)&quot;
                    + &quot; border.n=&quot; + border.getN() + &quot; path.size=&quot; + path.size()
                );

                curveHelper.findNeighborsWithAtLeastOneNonPoint(p.getX(), 
                    p.getY(), neighbors, points,
                    visited, imageMaxColumn + 1, imageMaxRow + 1);

                currentStep = new PathStep(p, neighbors,
                    bitVectorHelper.createBitstring(visited));

                path.add(currentStep);

            } else {

                // choose the neighbor with the fewest neighbors and when there
                // are ties, choose the one furthest from the centroid

                PairInt p = null;
                int minNNeigbors = Integer.MAX_VALUE;

                for (PairInt pn : currentStep.getNextSteps()) {

                    int x2 = pn.getX();
                    int y2 = pn.getY();

                    log.fine(&quot;   compare &quot; + &quot; (&quot; + x2 + &quot;,&quot; + y2 + &quot;)  to&quot;
                        + &quot; (&quot; + currentStep.getCoords().getX() + &quot;,&quot;
                        + currentStep.getCoords().getY() + &quot;)&quot;);

                    int nNeighbors = curveHelper.countNeighbors(x2, y2, points,
                        imageMaxColumn + 1, imageMaxRow + 1);

                    if (p == null) {

                        minNNeigbors = nNeighbors;
                        p = pn;

                    } else if (nNeighbors &lt; minNNeigbors) {

                        minNNeigbors = nNeighbors;
                        p = pn;

                    } else if (nNeighbors == minNNeigbors) {

                        double distC = Math.sqrt(
                            (p.getX() - xyCentroid[0])*(p.getX() - xyCentroid[0])
                            +
                            (p.getY() - xyCentroid[1])*(p.getY() - xyCentroid[1]));

                        double dist2 = Math.sqrt(
                            (x2 - xyCentroid[0])*(x2 - xyCentroid[0])
                            +
                            (y2 - xyCentroid[1])*(y2 - xyCentroid[1]));

                        if (dist2 &gt; distC) {
                            p = pn;
                        }
                    }
                }

                border.add(p.getX(), p.getY());
                visited.add(p);
                log.fine(&quot;adding (&quot; + p.getX() + &quot;,&quot; + p.getY() + &quot;)&quot;
                    + &quot; border.n=&quot; + border.getN() + &quot; path.size=&quot; + path.size()
                );

                curveHelper.findNeighborsWithAtLeastOneNonPoint(p.getX(), 
                    p.getY(), neighbors, points,
                    visited, imageMaxColumn + 1, imageMaxRow + 1);

                currentStep = new PathStep(p, neighbors,
                    bitVectorHelper.createBitstring(visited));

                path.add(currentStep);

            }

            // only eval if have left the region of start point.
            //TODO: refine this limit for very small point sets (e.g. 9).
            //TODO: need a check on the innermost block that the points are
            //      bounded, excepting spurs which should be stored. do not want
            //      a path which turns around early, missing most of the points.
            //      can use point in polygon test...or an area test or centroid test...
            if (border.getN() &gt; 8) {
                if ((Math.abs(currentStep.getCoords().getX() - x0) &lt; 2)
                    &amp;&amp; (Math.abs(currentStep.getCoords().getY() - y0) &lt; 2)) {
                    search = false;
                }
            }
        }

        return border;
    }
    */

<span class="fc" id="L1832">    static class Gap {</span>

        private final int row;

        private final int start;

        private final int stopInclusive;

        public Gap(int rowNumber, int startColumn, int stopColumnInclusive) {
            row = rowNumber;
            start = startColumn;
            stopInclusive = stopColumnInclusive;
        }

        /**
         * @return the row
         */
        public int getRow() {
            return row;
        }

        /**
         * @return the start
         */
        public int getStart() {
            return start;
        }

        /**
         * @return the stopInclusive
         */
        public int getStopInclusive() {
            return stopInclusive;
        }

        @Override
        public boolean equals(Object obj) {

            if (!(obj instanceof Gap)) {
                return false;
            }

            Gap other = (Gap)obj;

            if ((other.getRow() == row) &amp;&amp; (other.getStart() == start) &amp;&amp;
                (other.getStopInclusive() == stopInclusive)) {
                return true;
            }

            return false;
        }

        @Override
        public int hashCode() {

            int hash = fnvHashCode(this.row, this.start, this.stopInclusive);

            return hash;
        }

        int fnv321aInit = 0x811c9dc5;
        int fnv32Prime = 0x01000193;

        protected int fnvHashCode(int i0, int i1, int i2) {

            /*
             * hash = offset_basis
             * for each octet_of_data to be hashed
             *     hash = hash xor octet_of_data
             *     hash = hash * FNV_prime
             * return hash
             *
             * Public domain:  http://www.isthe.com/chongo/src/fnv/hash_32a.c
             */
            int hash = 0;

            int sum = fnv321aInit;

            // xor the bottom with the current octet.
            sum ^= i0;

            // multiply by the 32 bit FNV magic prime mod 2^32
            sum *= fnv32Prime;

            sum ^= i1;

            sum *= fnv32Prime;

            sum ^= i2;

            sum *= fnv32Prime;

            hash = sum;

            return hash;
        }

        @Override
        public String toString() {

            StringBuilder sb = new StringBuilder();
            sb.append(&quot;row=&quot;).append(Integer.toString(row))
                .append(&quot; cols=&quot;).append(Integer.toString(start))
                .append(&quot;:&quot;).append(Integer.toString(stopInclusive));

            return sb.toString();
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
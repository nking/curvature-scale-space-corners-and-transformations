<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RotatedOffsets.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry</a> &gt; <span class="el_source">RotatedOffsets.java</span></div><h1>RotatedOffsets.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry;

/**
 * a class to dynamically populate upon need and cache offset arrays for rotated
 * offsets used in the FeatureMatcher. Note that the methods are not thread safe
 * - they reuse an internal array to avoid constructing a new one for each fetch
 * for a rotation. The user should not allow more than one thread to use the
 * getXOffsets and getYOffsets simultaneously and no more than one of each
 * simultaneously. If multiple use is needed, the class can
 * be altered to be thread safe, but incur the cost of an array construction for
 * each get and a block to check existence of internal data.
 *
 * @author nichole
 */
public class RotatedOffsets {

<span class="fc" id="L17">    private static RotatedOffsets instance = null;</span>

    private static int[][] offsets360X;
    private static int[][] offsets360Y;

    private static long[][] offsets360XL;
    private static long[][] offsets360YL;

    private static final int cellDimension = 2;
    private static final int range0 = 6;

    private final boolean is64Bit;
    
    // field useful to assert re-using a live singleton
<span class="fc" id="L31">    private boolean containsData = false;</span>

    /**
     * &lt;pre&gt;
     * defaults in IntensityFeatures: 
     * cellDim=2
     * nCellsAcross=6 
     * range0 = 2 * (nCellsAcross/2) = 6
     * length of array = (2*nCellsAcross) * (2*nCellsAcross) = 144
     * &lt;/pre&gt;
     * xOffsets and yOffsets are arrays to be reused for return values and this
     * is the design that must be changed if the usage ever changes to multiple
     * access (that is, more than one return retained and used at the same time).
     */
<span class="fc" id="L45">    private final int[] xOffsets = new int[4 * range0 * range0];</span>
<span class="fc" id="L46">    private final int[] yOffsets = new int[xOffsets.length];</span>

    /**
     * max value is (2*range0) 12 and that be stored in 4 bits, and the negative 
     * portion requires one more bit, so 5 bits total to store an offset.
     */
<span class="fc" id="L52">    private static int itemBits = 5;</span>

<span class="fc" id="L54">    private RotatedOffsets() {</span>

<span class="fc" id="L56">        String arch = System.getProperty(&quot;sun.arch.data.model&quot;);</span>

<span class="pc bpc" id="L58" title="2 of 4 branches missed.">        is64Bit = ((arch != null) &amp;&amp; arch.equals(&quot;64&quot;)) ? true : false;</span>

        // use platform word size for most efficient storage:
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (is64Bit) {</span>
<span class="fc" id="L62">            offsets360XL = new long[360][];</span>
<span class="fc" id="L63">            offsets360YL = new long[360][];</span>
<span class="fc" id="L64">            offsets360X = null;</span>
<span class="fc" id="L65">            offsets360Y = null;</span>
        } else {
<span class="nc" id="L67">            offsets360X = new int[360][];</span>
<span class="nc" id="L68">            offsets360Y = new int[360][];</span>
<span class="nc" id="L69">            offsets360XL = null;</span>
<span class="nc" id="L70">            offsets360YL = null;</span>
        }
<span class="fc" id="L72">    }</span>

    public static synchronized RotatedOffsets getInstance() {
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (instance == null) {</span>
<span class="fc" id="L76">            instance = new RotatedOffsets();</span>
        }
<span class="fc" id="L78">        return instance;</span>
    }

    /**
     * get the offset array for rotation by rotationInDegrees. &lt;em&gt;Note that this
     * method is not thread safe - it reuses an internal array to avoid
     * constructing a new one for each invocation. The user should not allow
     * more than one thread to use getXOffsets simultaneously or more than one
     * return from the method to be retained simultaneously because both returns
     * will be the same instance.&lt;/em&gt;
     *
     * @param rotationInDegrees
     * @return
     */
    public int[] getXOffsets(int rotationInDegrees) {

<span class="fc" id="L94">        checkBounds(rotationInDegrees);</span>

<span class="fc" id="L96">        populateIfMissingX(rotationInDegrees);</span>

<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (is64Bit) {</span>

<span class="fc" id="L100">            long[] compresedOffsets = offsets360XL[rotationInDegrees];</span>

<span class="fc" id="L102">            populateOffsets(compresedOffsets, xOffsets);</span>

<span class="fc" id="L104">        } else {</span>

<span class="nc" id="L106">            int[] compresedOffsets = offsets360X[rotationInDegrees];</span>

<span class="nc" id="L108">            populateOffsets(compresedOffsets, xOffsets);</span>
        }

<span class="fc" id="L111">        containsData = true;</span>
        
<span class="fc" id="L113">        return xOffsets;</span>
    }

    private void populateIfMissingX(int rotationInDegrees) {

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (is64Bit) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (offsets360XL[rotationInDegrees] == null) {</span>
<span class="fc" id="L120">                populateXOffsetsLong(rotationInDegrees);</span>
            }
        } else {
<span class="nc bnc" id="L123" title="All 2 branches missed.">            if (offsets360X[rotationInDegrees] == null) {</span>
<span class="nc" id="L124">                populateXOffsetsInt(rotationInDegrees);</span>
            }
        }

<span class="fc" id="L128">    }</span>

    private void populateIfMissingY(int rotationInDegrees) {

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (is64Bit) {</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (offsets360YL[rotationInDegrees] == null) {</span>
<span class="fc" id="L134">                populateYOffsetsLong(rotationInDegrees);</span>
            }
        } else {
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (offsets360Y[rotationInDegrees] == null) {</span>
<span class="nc" id="L138">                populateYOffsetsInt(rotationInDegrees);</span>
            }
        }

<span class="fc" id="L142">    }</span>

    protected void populateXOffsetsLong(int rotationInDegrees) {

<span class="fc" id="L146">        double rotationInRadians = rotationInDegrees * Math.PI / 180.;</span>
<span class="fc" id="L147">        double mc = Math.cos(rotationInRadians);</span>
<span class="fc" id="L148">        double ms = Math.sin(rotationInRadians);</span>

        //64 bits / itemBits = 12 values per item
        
<span class="fc" id="L152">        long minAllowed = Long.MIN_VALUE;</span>
        
<span class="fc" id="L154">        long mask = (1L &lt;&lt; itemBits) - 1L;</span>

        // 144 / 12 = 12
<span class="fc" id="L157">        long[] compresedOffsets = new long[12];</span>

<span class="fc" id="L159">        int count = 0;        </span>
<span class="fc" id="L160">        int count12 = 0;</span>
        
        // move all numbers down to fill the signed portion of a long
<span class="fc" id="L163">        long datum12 = minAllowed;</span>
        
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (int dx = -range0; dx &lt; range0; dx += cellDimension) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            for (int dy = -range0; dy &lt; range0; dy += cellDimension) {</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">                for (int dxc = 0; dxc &lt; cellDimension; ++dxc) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                    for (int dyc = 0; dyc &lt; cellDimension; ++dyc) {</span>

<span class="fc" id="L171">                        double xt = (((dx + dxc) * mc) + ((dy + dyc) * ms));</span>

<span class="fc" id="L173">                        int v = (int) Math.round(xt);</span>

                        // if it's a negative number, make the number a positive 
                        // and times two then make the last bit to 1 to make it odd
<span class="fc bfc" id="L177" title="All 2 branches covered.">                        long t = (v &lt; 0) ? ((-1 * v &lt;&lt; 1) | 1) : (v &lt;&lt; 1);</span>
                        
<span class="fc" id="L179">                        long shift = (long) (itemBits * count12);</span>
                        
<span class="fc" id="L181">                        long shifted = (t &amp; mask) &lt;&lt; shift;</span>

<span class="fc" id="L183">                        datum12 += shifted;</span>

<span class="fc" id="L185">                        count12++;</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">                        if (count12 == 12) {</span>
<span class="fc" id="L188">                            compresedOffsets[count] = datum12;</span>
<span class="fc" id="L189">                            count++;</span>
<span class="fc" id="L190">                            count12 = 0;</span>
<span class="fc" id="L191">                            datum12 = minAllowed;</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L198">        offsets360XL[rotationInDegrees] = compresedOffsets;</span>
<span class="fc" id="L199">    }</span>

    protected void populateXOffsetsInt(int rotationInDegrees) {

<span class="nc" id="L203">        double rotationInRadians = rotationInDegrees * Math.PI / 180.;</span>
<span class="nc" id="L204">        double mc = Math.cos(rotationInRadians);</span>
<span class="nc" id="L205">        double ms = Math.sin(rotationInRadians);</span>
        
<span class="nc" id="L207">        int minAllowed = Integer.MIN_VALUE;</span>

        //32 bits / itemBits = 6 values per item
<span class="nc" id="L210">        int mask = (1 &lt;&lt; itemBits) - 1;</span>

        // 144 / 6 = 24
<span class="nc" id="L213">        int[] compresedOffsets = new int[24];</span>

<span class="nc" id="L215">        int count = 0;</span>
<span class="nc" id="L216">        int count6 = 0;</span>
        
        // move all numbers down to fill the signed portion of a long
<span class="nc" id="L219">        int datum6 = minAllowed;</span>
        
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for (int dx = -range0; dx &lt; range0; dx += cellDimension) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            for (int dy = -range0; dy &lt; range0; dy += cellDimension) {</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">                for (int dxc = 0; dxc &lt; cellDimension; ++dxc) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                    for (int dyc = 0; dyc &lt; cellDimension; ++dyc) {</span>

<span class="nc" id="L227">                        double xt = (((dx + dxc) * mc) + ((dy + dyc) * ms));</span>

<span class="nc" id="L229">                        int v = (int) Math.round(xt);</span>

                        // if it's a negative number, make the number a positive 
                        // and times two then make the last bit to 1 to make it odd
<span class="nc bnc" id="L233" title="All 2 branches missed.">                        int t = (v &lt; 0) ? ((-1 * v &lt;&lt; 1) | 1) : (v &lt;&lt; 1);</span>
                        
<span class="nc" id="L235">                        int shift = (itemBits * count6);</span>

<span class="nc" id="L237">                        int shifted = (t &amp; mask) &lt;&lt; shift;</span>

<span class="nc" id="L239">                        datum6 += shifted;</span>

<span class="nc" id="L241">                        count6++;</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">                        if (count6 == 6) {</span>
<span class="nc" id="L244">                            compresedOffsets[count] = datum6;</span>
<span class="nc" id="L245">                            count++;</span>
<span class="nc" id="L246">                            count6 = 0;</span>
<span class="nc" id="L247">                            datum6 = minAllowed;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L254">        offsets360X[rotationInDegrees] = compresedOffsets;</span>
<span class="nc" id="L255">    }</span>

    protected void populateYOffsetsLong(int rotationInDegrees) {
        
<span class="fc" id="L259">        double rotationInRadians = rotationInDegrees * Math.PI / 180.;</span>
<span class="fc" id="L260">        double mc = Math.cos(rotationInRadians);</span>
<span class="fc" id="L261">        double ms = Math.sin(rotationInRadians);</span>

        //64 bits / itemBits = 12 values per item
        
<span class="fc" id="L265">        long minAllowed = Long.MIN_VALUE;</span>
        
<span class="fc" id="L267">        long mask = (1L &lt;&lt; itemBits) - 1L;</span>

        // 144 / 12 = 12
<span class="fc" id="L270">        long[] compresedOffsets = new long[12];</span>
        
<span class="fc" id="L272">        int count = 0;</span>
<span class="fc" id="L273">        int count12 = 0;</span>
        
        // move all numbers down to fill the signed portion of a long
<span class="fc" id="L276">        long datum12 = minAllowed;</span>
        
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (int dx = -range0; dx &lt; range0; dx += cellDimension) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">            for (int dy = -range0; dy &lt; range0; dy += cellDimension) {</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">                for (int dxc = 0; dxc &lt; cellDimension; ++dxc) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">                    for (int dyc = 0; dyc &lt; cellDimension; ++dyc) {</span>

<span class="fc" id="L284">                        double yt = (-((dx + dxc) * ms)) + ((dy + dyc) * mc);</span>

<span class="fc" id="L286">                        int v = (int) Math.round(yt);</span>

                        // if it's a negative number, make the number a positive 
                        // and times two then make the last bit to 1 to make it odd
<span class="fc bfc" id="L290" title="All 2 branches covered.">                        int t = (v &lt; 0) ? ((-1 * v &lt;&lt; 1) | 1) : (v &lt;&lt; 1);</span>

<span class="fc" id="L292">                        long shift = (long) (itemBits * count12);</span>

<span class="fc" id="L294">                        long shifted = (t &amp; mask) &lt;&lt; shift;</span>

<span class="fc" id="L296">                        datum12 += shifted;</span>

<span class="fc" id="L298">                        count12++;</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">                        if (count12 == 12) {</span>
<span class="fc" id="L301">                            compresedOffsets[count] = datum12;</span>
<span class="fc" id="L302">                            count++;</span>
<span class="fc" id="L303">                            count12 = 0;</span>
<span class="fc" id="L304">                            datum12 = minAllowed;</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L311">        offsets360YL[rotationInDegrees] = compresedOffsets;</span>
<span class="fc" id="L312">    }</span>

    protected void populateYOffsetsInt(int rotationInDegrees) {

<span class="nc" id="L316">        double rotationInRadians = rotationInDegrees * Math.PI / 180.;</span>
<span class="nc" id="L317">        double mc = Math.cos(rotationInRadians);</span>
<span class="nc" id="L318">        double ms = Math.sin(rotationInRadians);</span>
        
<span class="nc" id="L320">        int minAllowed = Integer.MIN_VALUE;</span>

        //32 bits / itemBits = 6 values per item
<span class="nc" id="L323">        int mask = (1 &lt;&lt; itemBits) - 1;</span>

        // 144 / 6 = 24
<span class="nc" id="L326">        int[] compresedOffsets = new int[24];</span>

<span class="nc" id="L328">        int count = 0;</span>
<span class="nc" id="L329">        int count6 = 0;</span>
        
        // move all numbers down to fill the signed portion of a long
<span class="nc" id="L332">        int datum6 = minAllowed;</span>
        
<span class="nc bnc" id="L334" title="All 2 branches missed.">        for (int dx = -range0; dx &lt; range0; dx += cellDimension) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            for (int dy = -range0; dy &lt; range0; dy += cellDimension) {</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">                for (int dxc = 0; dxc &lt; cellDimension; ++dxc) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    for (int dyc = 0; dyc &lt; cellDimension; ++dyc) {</span>

<span class="nc" id="L340">                        double yt = (-((dx + dxc) * ms)) + ((dy + dyc) * mc);</span>

<span class="nc" id="L342">                        int v = (int) Math.round(yt);</span>
                        
                        // if it's a negative number, make the number a positive 
                        // and times two then make the last bit to 1 to make it odd
<span class="nc bnc" id="L346" title="All 2 branches missed.">                        int t = (v &lt; 0) ? ((-1 * v &lt;&lt; 1) | 1) : (v &lt;&lt; 1);</span>
                        
<span class="nc" id="L348">                        int shift = (itemBits * count6);</span>

<span class="nc" id="L350">                        int shifted = (t &amp; mask) &lt;&lt; shift;</span>

<span class="nc" id="L352">                        datum6 += shifted;</span>

<span class="nc" id="L354">                        count6++;</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">                        if (count6 == 6) {</span>
<span class="nc" id="L357">                            compresedOffsets[count] = datum6;</span>
<span class="nc" id="L358">                            count++;</span>
<span class="nc" id="L359">                            count6 = 0;</span>
<span class="nc" id="L360">                            datum6 = minAllowed;</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L367">        offsets360Y[rotationInDegrees] = compresedOffsets;</span>
<span class="nc" id="L368">    }</span>
    
    private void populateOffsets(long[] compresedOffsets, int[] outputOffsets) {

<span class="fc" id="L372">        long minAllowed = Long.MIN_VALUE;</span>
        
        //64 bits / itemBits = 12 values per item
<span class="fc" id="L375">        long mask = (1L &lt;&lt; itemBits) - 1L;</span>

<span class="fc" id="L377">        int count = 0;</span>

<span class="fc bfc" id="L379" title="All 2 branches covered.">        for (int i = 0; i &lt; compresedOffsets.length; ++i) {</span>

<span class="fc" id="L381">            long item = compresedOffsets[i];</span>

            // read each of the 12 datum in the item
<span class="fc bfc" id="L384" title="All 2 branches covered.">            for (int j = 0; j &lt; 12; ++j) {</span>

<span class="fc" id="L386">                long v = ((item - minAllowed) &gt;&gt; (long) (j * itemBits)) &amp; mask;</span>
                
                // decode to negative
<span class="fc bfc" id="L389" title="All 2 branches covered.">                long t = ((v &amp; 1) == 1) ? -1 * (v &gt;&gt; 1) : v &gt;&gt; 1;</span>

<span class="fc" id="L391">                outputOffsets[count] = (int) t;</span>

<span class="fc" id="L393">                count++;</span>
            }
        }
<span class="fc" id="L396">    }</span>

    private void populateOffsets(int[] compresedOffsets, int[] outputOffsets) {

        //32 bits / itemBits = 6 values per item
<span class="nc" id="L401">        int mask = (1 &lt;&lt; itemBits) - 1;</span>
        
<span class="nc" id="L403">        int minAllowed = Integer.MIN_VALUE;</span>

<span class="nc" id="L405">        int count = 0;</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">        for (int i = 0; i &lt; compresedOffsets.length; ++i) {</span>

<span class="nc" id="L409">            int item = compresedOffsets[i];</span>

            // read each of the 6 datum in the item
<span class="nc bnc" id="L412" title="All 2 branches missed.">            for (int j = 0; j &lt; 6; ++j) {</span>

<span class="nc" id="L414">                int v = ((item - minAllowed) &gt;&gt; (j * itemBits)) &amp; mask;</span>
                
                // decode to negative
<span class="nc bnc" id="L417" title="All 2 branches missed.">                int t = ((v &amp; 1) == 1) ? -1 * (v &gt;&gt; 1) : v &gt;&gt; 1;</span>

<span class="nc" id="L419">                outputOffsets[count] = t;</span>

<span class="nc" id="L421">                count++;</span>
            }
        }
<span class="nc" id="L424">    }</span>

    /**
     * get the offset array for rotation by rotationInDegrees. &lt;em&gt;Note that this
     * method is not thread safe - it reuses an internal array to avoid
     * constructing a new one for each invocation. The user should not allow
     * more than one thread to use getYOffsets simultaneously or more than one
     * return from the method to be retained simultaneously because both returns
     * will be the same instance.&lt;/em&gt;
     *
     * @param rotationInDegrees
     * @return
     */
    public int[] getYOffsets(int rotationInDegrees) {

<span class="fc" id="L439">        checkBounds(rotationInDegrees);</span>

<span class="fc" id="L441">        populateIfMissingY(rotationInDegrees);</span>

<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (is64Bit) {</span>

<span class="fc" id="L445">            long[] compresedOffsets = offsets360YL[rotationInDegrees];</span>

<span class="fc" id="L447">            populateOffsets(compresedOffsets, yOffsets);</span>

<span class="fc" id="L449">        } else {</span>

<span class="nc" id="L451">            int[] compresedOffsets = offsets360Y[rotationInDegrees];</span>

<span class="nc" id="L453">            populateOffsets(compresedOffsets, yOffsets);</span>
        }

<span class="fc" id="L456">        containsData = true;</span>
        
<span class="fc" id="L458">        return yOffsets;</span>
    }

    private void checkBounds(int rotationInDegrees) {

<span class="pc bpc" id="L463" title="2 of 4 branches missed.">        if (rotationInDegrees &lt; 0 || rotationInDegrees &gt; 359) {</span>
<span class="nc" id="L464">            throw new IllegalArgumentException(</span>
                &quot;rotationInDegrees must be &gt;=0 and &lt; 360&quot;);
        }
<span class="fc" id="L467">    }</span>

    public boolean containsData() {
<span class="nc" id="L470">        return containsData;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ORB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features.orb</a> &gt; <span class="el_source">ORB.java</span></div><h1>ORB.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features.orb;

import algorithms.QuickSort;
import algorithms.imageProcessing.*;
import algorithms.matrix.MatrixUtil;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.TwoDFloatArray;
import algorithms.VeryLongBitString;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TDoubleArrayList;
import gnu.trove.list.array.TFloatArrayList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 * An implementation of &quot;ORB: an efficient alternative to SIFT or SURF&quot;
 * (paper reference is Rublee, Rabaud, Konolige, and Bradski, 2011).
 * http://www.vision.cs.chubu.ac.jp/CV-R/pdf/Rublee_iccv2011.pdf
 *
 * excerpts from the paper:
 * ORB is a very fast binary descriptor based on BRIEF, 
 * which is rotation invariant and resistant to noise.
 * It builds on the well-known FAST keypoint detector and the recently-developed 
 * BRIEF descriptor [6]; for this reason we call it 
 * ORB (Oriented FAST and Rotated BRIEF).
 * 
 * FAST and its variants are the method of choice for finding keypoints in 
 * real-time systems that match visual features, for example, Parallel Tracking 
 * and Mapping. It is efficient and finds reasonable corner keypoints, although 
 * it must be augmented with pyramid schemes for scale, and in our case, 
 * a Harris corner filter [11] to reject edges and provide a reasonable score.
 * 
 * ORB orientation operator is built using the centroid technique of Rosin.
 * 
   Descriptor BRIEF:
   *   is a recent feature descriptor (a bit string description of an image 
   *   patch) that uses simple binary 
   *   tests between pixels in a smoothed image patch. Its performance is similar
   *   to SIFT in many respects, including robustness to lighting, blur, and 
   *   perspective distortion. However, it is very sensitive to in-plane 
   *   rotation.
 
 *     BRIEF grew out of research that uses binary tests to train a set of 
 *     classification trees [4]. Once trained on a set of 500 or so typical 
 *     keypoints, the trees can be used to return a signature for any arbitrary 
 *     keypoint [5]. In a similar manner, we look for the tests least sensitive 
 *     to orientation...NOTE that PCA and SIFT are computationally intensive.
 * 
 *     Visual vocabulary methods [21, 27] use offline clustering to find exemplars 
 *     that are uncorrelated and can be used in matching. These techniques might 
 *     also be useful in finding uncorrelated binary tests.
 * 
 * FAST detector: 
 *    the intensity threshold between the center pixel and those in a circular 
 *    ring about the center (e.g. a circular radius of 9).
 *    FAST does not produce a measure of cornerness, and it has large responses 
 *    along edges. We employ a Harris corner measure [11] to order the FAST 
 *    keypoints. For a target number N of keypoints, we first set the threshold 
 *    low enough to get more than N keypoints, then order them according to the 
 *    Harris measure, and pick the top N points.
 *    FAST is used on each image in a scaled image pyramid.
 * 
 * Orientation:
 *     corner orientation, the intensity centroid [22]. The intensity centroid 
 *     assumes that a cornerâ€™s intensity is offset from its center, and this vector 
 *     may be used to impute an orientation. Rosin defines the moments of a patch as:
 * 
 *    m_p_q = moments = summation_over_x_and_y( (x^p) * (y^q) * I(x,y) )
 *       where I(x,y) is the pixel intensity.
 * 
 *    C = the centroid = ( m_1_0/m_0_0, m_0_1/m_0_0)
 *    
 *    orientation = theta = atan2( m_0_1, m_1_0)
 * 
 *     
 * ---------
 * The implementation below is adapted from the scipy implementation which has
 * the following copyright:* 
* 
 https://github.com/scikit-image/scikit-image/blob/master/LICENSE.txt

-- begin scipy, skimage copyright ---
Unless otherwise specified by LICENSE.txt files in individual
directories, all code is

Copyright (C) 2011, the scikit-image team
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.
 3. Neither the name of skimage nor the names of its contributors may be
    used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-- end scipy, skimage copyright ---

Note, in some places, scipy functions have been
replaced with existing functions in this project in this implementation below.

 Oriented FAST and rotated BRIEF feature detector and binary descriptor
    extractor.

Have also edited alot of the ordering of logic, but the core content is still adapted
from the scipy code.
 
Note: to include color information, consider combining the results of
a greyscale ORB with the results of a &quot;C&quot; from LCH colorspace and/or another
* color transformation that uses a chromaticity transformation 
* to distinguish colors.  
* For the latter, would need to make a separate ORB because the
* differences in the &quot;H&quot;, that is polar theta, would need
* to use a threshold of 20 degrees or so and a result of binary
* difference, and would need a correction for wrap around the
* circular coordinate space, so the keypoint extraction would
* need to be adjusted for that.  The main reason for such 
* consideration is to be able to distinguish between colors whose
* combinations are the same in greyscale color.

NOTE, have chosen to keep the results (which are available publicly via getters)
in Lists in which each list index is a scale in the pyramidal decimation
to allow the user to recover scale information if wanted.
To use the way that scipy does, all results as single lists of variables
are available via getAll*getters.

Still testing the class, there may be bugs present.
 &lt;pre&gt;
 Example Use:
    int nKeyPoints = 200;
    ORB orb = new ORB(nKeyPoints);
    orb.overrideToAlsoCreate1stDerivKeypoints();
    orb.detectAndExtract(image);

    // to get the list of keypoint coordinates in row-major, but separated:
    List TIntList keypoints0 = orb.getAllKeyPoints0(); // rows being first dimension
    List TIntList keypoints1 = orb.getAllKeyPoints1(); // cols being second dimension

    // to get the descriptors:
    List Descriptors descList = orb.getDescriptors();
       or
    Descriptors desc = orb.getAllDescriptors();
    
 * &lt;/pre&gt;
 */
<span class="fc" id="L173">public class ORB {</span>
   
<span class="fc" id="L175">    protected boolean useSingleScale = false;</span>

    // these could be made static across all instances, but needs guards for synchronous initialization
<span class="fc" id="L178">    protected int[][] OFAST_MASK = null;</span>
<span class="fc" id="L179">    protected int[] OFAST_UMAX = null;</span>
<span class="fc" id="L180">    protected int[][] POS0 = null;</span>
<span class="fc" id="L181">    protected int[][] POS1 = null;</span>

<span class="fc" id="L183">    protected int fastN = 9;</span>
    // fastThreshold should probably be &lt;= 0.01 for low res images
<span class="fc" id="L185">    protected float fastThreshold = 0.08f;</span>
<span class="fc" id="L186">    protected final float harrisK = 0.04f;</span>
    protected final int nKeypoints;

    /**
    the first dimension of the pyramids is scale
    and the value is the image as a 2 dimensional row major format float array.
    */
<span class="fc" id="L193">    protected TwoDFloatArray[] pyramidImages = null;</span>
<span class="fc" id="L194">    protected float[] scales = null;</span>
<span class="fc" id="L195">    protected StructureTensor[] tensorComponents = null;</span>
<span class="fc" id="L196">    protected TwoDFloatArray[] harrisResponseImages = null;</span>

    /**
     * although there may be multiple color images in the pyramid, there is
     * only one set of coordinates derived for each scale.
     */
<span class="fc" id="L202">    protected List&lt;TIntList&gt; keypoints0List = null;</span>
<span class="fc" id="L203">    protected List&lt;TIntList&gt; keypoints1List = null;</span>
    
<span class="fc" id="L205">    protected List&lt;TDoubleList&gt; orientationsList = null;</span>
<span class="fc" id="L206">    protected List&lt;TFloatList&gt; harrisResponses = null;</span>
    
    //`True`` or ``False`` representing
    //the outcome of the intensity comparison for i-th keypoint on j-th
    //decision pixel-pair. It is ``Q == np.sum(mask)``.
<span class="fc" id="L211">    private List&lt;Descriptors&gt; descriptorsList = null;</span>
    
<span class="fc" id="L213">    private List&lt;PairInt&gt; combinedKeypointList = null;</span>
<span class="fc" id="L214">    private TDoubleList combinedOrientationList = null;</span>
<span class="fc" id="L215">    private TFloatList combinedHarrisResponseList = null;</span>
<span class="fc" id="L216">    private Descriptors combinedDescriptors = null;</span>

<span class="fc" id="L218">    protected float curvatureThresh = 0.05f;</span>

<span class="fc" id="L220">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>

    // pyramid images will be no smaller than this
    private final static int defaultDecimationLimit = 32;
<span class="fc" id="L224">    protected final int decimationLimit = defaultDecimationLimit;</span>

    public enum DescriptorChoice {
        NONE, GREYSCALE
    }
<span class="fc" id="L229">    private DescriptorChoice descrChoice = DescriptorChoice.GREYSCALE;</span>

<span class="fc" id="L231">    protected boolean doCreate1stDerivKeypoints = false;</span>

<span class="fc" id="L233">    protected boolean doCreateCurvatureKeyPoints = false;</span>

<span class="fc" id="L235">    protected int nPyramidB = 3;</span>

<span class="fc" id="L237">    protected boolean doCreate1stATrousKeypoints = true;</span>

    protected final GreyscaleImage img;

    /**
     * Still testing the class, there may be bugs present.
     * @param image image to calculate keypoints and descriptors for.
     * @param nKeypoints the limit to the number of keypoints per
     *                   pyramidal octave scale, and the limit to the
     *                   total combined keypoint list of all octave scales.
     *
     */
<span class="fc" id="L249">    public ORB(GreyscaleImage image, int nKeypoints) {</span>

<span class="fc" id="L251">        initMasks();</span>

<span class="fc" id="L253">        this.img = image;</span>
                
<span class="fc" id="L255">        this.nKeypoints = nKeypoints;</span>
<span class="fc" id="L256">    }</span>
   
    /**
     * @param descrChoice the descrChoice to set
     */
    public void setDescrChoice(DescriptorChoice descrChoice) {
<span class="nc" id="L262">        this.descrChoice = descrChoice;</span>
<span class="nc" id="L263">    }</span>
    
    public void overrideToUseSingleScale() {
<span class="nc" id="L266">        useSingleScale = true;</span>
<span class="nc" id="L267">    }</span>

    protected void overrideFastN(int nFast) {
<span class="nc" id="L270">        this.fastN = nFast;</span>
<span class="nc" id="L271">    }</span>
    /**
     * default is 0.08f.
     * For a low resolution image, may want to use 0.01f.
     * @param threshold
     */
    public void overrideFastThreshold(float threshold) {
<span class="nc" id="L278">        this.fastThreshold = threshold;</span>
<span class="nc" id="L279">    }</span>

    /**
     * override the number of divisions of scale to add in
     * between the powers of 2 scalings.  The default number
     * is 3.
     * @param n
     */
    public void overridePyamidalExtraN(int n) {
        
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (useSingleScale) {</span>
<span class="nc" id="L290">            throw new IllegalArgumentException(&quot;useSingleScale=true so cannot &quot;</span>
                + &quot; set this parameter&quot;);
        }
        
<span class="nc" id="L294">        this.nPyramidB = n;</span>
<span class="nc" id="L295">    }</span>

    /**
     * set option to not create descriptors.
     */
    public void overrideToNotCreateDescriptors() {
<span class="fc" id="L301">        descrChoice = DescriptorChoice.NONE;</span>
<span class="fc" id="L302">    }</span>
    
    public void overrideToAlsoCreate1stDerivKeypoints() {
<span class="fc" id="L305">        doCreate1stDerivKeypoints = true;</span>
<span class="fc" id="L306">    }</span>
    
    public void overrideToNotCreateATrousKeypoints() {
<span class="fc" id="L309">        doCreate1stATrousKeypoints = false;</span>
<span class="fc" id="L310">    }</span>

    public void overrideToCreateCurvaturePoints() {
<span class="nc" id="L313">        doCreateCurvatureKeyPoints = true;</span>
<span class="nc" id="L314">    }</span>

    private void initMasks() {

<span class="fc" id="L318">        OFAST_MASK = new int[31][31];</span>
        int i;
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for (i = 0; i &lt; 31; ++i) {</span>
<span class="fc" id="L321">            OFAST_MASK[i] = new int[31];</span>
        }

<span class="fc" id="L324">        OFAST_UMAX = new int[]{15, 15, 15, 15, 14, 14, 14, 13, 13, 12, 11, 10,</span>
            9, 8, 6, 3};

<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (i = -15; i &lt; 16; ++i) {</span>
<span class="fc" id="L328">            int absI = Math.abs(i);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            for (int j = -OFAST_UMAX[absI]; j &lt; (OFAST_UMAX[absI] + 1); ++j) {</span>
<span class="fc" id="L330">                OFAST_MASK[15 + j][15 + i] = 1;</span>
            }
        }
<span class="fc" id="L333">    }</span>

    /**
      NOTE: still testing, there may be bugs.

      Detect oriented FAST keypoints and extract rBRIEF descriptors.
      Note that this is faster than first calling `detect` and then
      `extract`.

      code is adapted from
      https://github.com/scikit-image/scikit-image/blob/401c1fd9c7db4b50ae9c4e0a9f4fd7ef1262ea3c/skimage/feature/orb.py
      with some functions replaced by code in this project.

     */
    public void detectAndExtract() {

<span class="fc" id="L349">        buildPyramid();</span>
        
<span class="fc" id="L351">        buildTensors();</span>
        
<span class="fc" id="L353">        buildHarrisImages();</span>
        
        // NOTE that the keypoints are all in the coord frame of the largest image
        // which is scales[0], that is, octave = 0.
<span class="fc" id="L357">        extractKeypoints();</span>

<span class="fc" id="L359">        extractDescriptors();</span>

<span class="fc" id="L361">        combineAndFilterTotal();</span>

        //int nKeyPointsTotal = countKeypoints();

        //log.info(&quot;nKeypointsTotal=&quot; + nKeyPointsTotal +
        //    &quot; number of allowed Keypoints=&quot; + this.nKeypoints);                
<span class="fc" id="L367">    }</span>
  
    private void buildPyramid() {
       
<span class="fc" id="L371">        List&lt;TwoDFloatArray&gt; pyr = buildPyramid(img);</span>

<span class="fc" id="L373">        int nScales = pyr.size();</span>

<span class="fc" id="L375">        pyramidImages = new TwoDFloatArray[nScales];</span>
<span class="fc" id="L376">        scales = new float[nScales];</span>
        
<span class="fc" id="L378">        scales[0] = 1.f;</span>
<span class="fc" id="L379">        pyramidImages[0] = pyr.get(0);</span>

        float x0, y0;
<span class="fc bfc" id="L382" title="All 2 branches covered.">        for (int i = 1; i &lt; nScales; ++i) {</span>
<span class="fc" id="L383">            pyramidImages[i] = pyr.get(i);</span>
<span class="fc" id="L384">            x0 = (float)pyramidImages[i - 1].a.length/</span>
                (float)pyramidImages[i].a.length;
<span class="fc" id="L386">            y0 = (float)pyramidImages[i - 1].a[0].length/</span>
                (float)pyramidImages[i].a[0].length;
<span class="fc" id="L388">            scales[i] = scales[i-1] * (x0 + y0)/2.f;</span>
        }
<span class="fc" id="L390">    }</span>
  
    /**
     * @param img in col major format
     * @return float array of pyramid images in row major format
     */
    private List&lt;TwoDFloatArray&gt; buildPyramid(GreyscaleImage img) {

        //TODO: need a finer grained decimation as an option
        //   can build one with gaussian and down-sampling
        // of use the ATrous b3 method and down-sampling
        //   see the upsampling code in image processing to reverse...

<span class="fc" id="L403">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        int dl = useSingleScale ?</span>
<span class="nc" id="L406">            Math.min(img.getWidth(), img.getHeight()) - 1 :</span>
<span class="fc" id="L407">            decimationLimit;</span>
        
<span class="fc" id="L409">        List&lt;GreyscaleImage&gt; output = imageProcessor.buildPyramid2(img, dl);</span>

<span class="fc" id="L411">        List&lt;TwoDFloatArray&gt; output2 = new ArrayList&lt;TwoDFloatArray&gt;();</span>
        float[][] rowMajorImg;
        TwoDFloatArray f;
        
<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (GreyscaleImage im : output) {</span>
<span class="fc" id="L416">            rowMajorImg = imageProcessor.copyToRowMajor(im);</span>
<span class="fc" id="L417">            MatrixUtil.multiply(rowMajorImg, 1.f/255.f);</span>
<span class="fc" id="L418">            f = new TwoDFloatArray(rowMajorImg);</span>
<span class="fc" id="L419">            output2.add(f);</span>
<span class="fc" id="L420">        }</span>

<span class="fc" id="L422">        return output2;</span>
    }
    
    protected void buildTensors() {
    
        // Standard deviation used for the Gaussian kernel, which is used as
        // weighting function for the auto-correlation matrix.
<span class="fc" id="L429">        float sigma = SIGMA.getValue(SIGMA.ZEROPOINTFIVE);</span>
        
<span class="fc" id="L431">        tensorComponents = new StructureTensor[scales.length];</span>

        TwoDFloatArray octaveImage;

<span class="fc bfc" id="L435" title="All 2 branches covered.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
            
<span class="fc" id="L437">            octaveImage = pyramidImages[i];</span>

            // octaveImage.a is in row-major format
<span class="fc" id="L440">            tensorComponents[i] = new StructureTensor(octaveImage.a,</span>
                sigma, doCreateCurvatureKeyPoints);
        }
        
<span class="fc" id="L444">    }</span>

    private void buildHarrisImages() {
        
<span class="fc" id="L448">        harrisResponseImages = new TwoDFloatArray[scales.length];</span>

        TwoDFloatArray octaveImage;
        StructureTensor tensors;
        float[][] detA;
        float[][] traceA;
        float[][] harrisResponse;

<span class="fc bfc" id="L456" title="All 2 branches covered.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
            
<span class="fc" id="L458">            octaveImage = pyramidImages[i];</span>
            
<span class="fc" id="L460">            tensors = tensorComponents[i];</span>
            
<span class="fc" id="L462">            detA = tensors.getDeterminant();</span>

<span class="fc" id="L464">            traceA = tensors.getTrace();</span>

            // size is same a octaveImage
<span class="fc" id="L467">            harrisResponse = cornerHarris(octaveImage.a, detA, traceA);</span>

<span class="fc" id="L469">            harrisResponseImages[i] = new TwoDFloatArray(harrisResponse);</span>
        }
<span class="fc" id="L471">    }</span>
    
    protected void debugPrint(String label, float[][] a) {

<span class="nc" id="L475">        String str = MiscDebug.getPrintRowMajor(a, label);</span>
        
<span class="nc" id="L477">        log.info(str);</span>
<span class="nc" id="L478">    }</span>

    private void debugPrint(String label, int[][] a) {

<span class="nc" id="L482">        StringBuilder sb = new StringBuilder(label);</span>
<span class="nc" id="L483">        sb.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L485">            sb.append(Arrays.toString(a[i])).append(&quot;\n&quot;);</span>
        }

<span class="nc" id="L488">        log.info(sb.toString());</span>
<span class="nc" id="L489">    }</span>

    protected float[][] multiply(float[][] a, float[][] b) {

<span class="nc" id="L493">        float[][] c = copy(a);</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="nc" id="L497">                c[i][j] *= b[i][j];</span>
            }
        }

<span class="nc" id="L501">        return c;</span>
    }

    protected float[][] add(float[][] a, float[][] b) {

<span class="nc" id="L506">        float[][] c = copy(a);</span>

<span class="nc bnc" id="L508" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="nc" id="L510">                c[i][j] += b[i][j];</span>
            }
        }

<span class="nc" id="L514">        return c;</span>
    }

    protected float[][] subtract(float[][] a, float[][] b) {

<span class="nc" id="L519">        float[][] c = copy(a);</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="nc" id="L523">                c[i][j] -= b[i][j];</span>
            }
        }

<span class="nc" id="L527">        return c;</span>
    }

    /**
     extracts keypoints, orientations, and harris response images
     and stores results in the class level variables.
     NOTE: the octaves are also stored at class level in this method too
     once any keypoints are detected.
     returned is the list of octaves which were used.
    */
    private void extractKeypoints() {

<span class="fc" id="L539">        keypoints0List = new ArrayList&lt;TIntList&gt;();</span>
<span class="fc" id="L540">        keypoints1List = new ArrayList&lt;TIntList&gt;();</span>
<span class="fc" id="L541">        orientationsList = new ArrayList&lt;TDoubleList&gt;();</span>
<span class="fc" id="L542">        harrisResponses = new ArrayList&lt;TFloatList&gt;();</span>
     
        // atrous keypoints if any
<span class="fc" id="L545">        TIntList atk0 = new TIntArrayList();</span>
<span class="fc" id="L546">        TIntList atk1 = new TIntArrayList();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (doCreate1stATrousKeypoints) {</span>
<span class="fc" id="L548">            extractATrousKeypoints(atk0, atk1);</span>
        }
                
        Resp r;
        TIntList mask;
        float[][] harrisResponse;
        int n, count, i, x, y, c0, c1;
        float[] scores;
        PairInt[] points;
        TIntList kpc0s;
        TIntList kpc1s;
        float scale;
        
        // largest pyramid harris response image and tensor image size
<span class="fc" id="L562">        int rH = harrisResponseImages[0].a.length;</span>
<span class="fc" id="L563">        int cH = harrisResponseImages[0].a[0].length;</span>
        
        Set&lt;PairInt&gt; set;
        TIntList kp0s;
        TIntList kp1s;
        float[][] octaveImage;
        TDoubleList orientations;
        TFloatList responses;
        int len;
            
<span class="fc bfc" id="L573" title="All 2 branches covered.">        for (int octave = 0; octave &lt; scales.length; ++octave) {</span>
            // order by response and filter
            
<span class="fc" id="L576">            scale = scales[octave];</span>
            
<span class="fc" id="L578">            r = extractKeypoints(octave);</span>

<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (!atk0.isEmpty()) {</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">                for (i = 0; i &lt; atk0.size(); ++i) {</span>
                    // shrink the atrous keypoints for this octave scale
<span class="fc" id="L583">                    c0 = Math.round((float)atk0.get(i)/scale);</span>
<span class="fc" id="L584">                    c1 = Math.round((float)atk1.get(i)/scale);</span>
<span class="fc" id="L585">                    r.keypoints0.add(c0);</span>
<span class="fc" id="L586">                    r.keypoints1.add(c1);</span>
                }
            }

            //mask of length orientations.size() containing a 1 or 0
            // indicating if pixels are within the image (``True``) or in the
            // border region of the image (``False``).
<span class="fc" id="L593">            mask = filterNearBorder(pyramidImages[octave].a, r.keypoints0, r.keypoints1);</span>
        
<span class="fc" id="L595">            harrisResponse = harrisResponseImages[octave].a;</span>

<span class="fc" id="L597">            n = r.keypoints0.size();</span>
                        
<span class="pc bnc" id="L599" title="All 2 branches missed.">            assert(harrisResponse.length == pyramidImages[octave].a.length);</span>
<span class="pc bnc" id="L600" title="All 2 branches missed.">            assert(harrisResponse.length == tensorComponents[octave].getDXSquared().length);</span>
<span class="pc bnc" id="L601" title="All 2 branches missed.">            assert(harrisResponse[0].length == pyramidImages[octave].a[0].length);</span>
<span class="pc bnc" id="L602" title="All 2 branches missed.">            assert(harrisResponse[0].length == tensorComponents[octave].getDXSquared()[0].length);</span>
            
<span class="fc" id="L604">            scores = new float[n];</span>
<span class="fc" id="L605">            points = new PairInt[n];</span>
<span class="fc" id="L606">            count = 0;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
                // these are in octave reference frame
<span class="fc" id="L609">                x = r.keypoints1.get(i);</span>
<span class="fc" id="L610">                y = r.keypoints0.get(i);</span>
<span class="fc" id="L611">                points[count] = new PairInt(x, y);</span>
<span class="fc" id="L612">                scores[count] = harrisResponse[y][x];</span>
<span class="fc" id="L613">                count++;</span>
            }
     
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">            if (n &gt; 0) {</span>
                // the harris points are negative values.
                //    strongest response is the smallest value (i.e. -2 is stronger than 0)
<span class="fc" id="L619">                QuickSort.sortBy1stArg(scores, points);</span>
            }
        
<span class="fc" id="L622">            kpc0s = new TIntArrayList(this.nKeypoints);</span>
<span class="fc" id="L623">            kpc1s = new TIntArrayList(this.nKeypoints);</span>

<span class="fc bfc" id="L625" title="All 2 branches covered.">            for (i = 0; i &lt; points.length; i++) {</span>
<span class="fc" id="L626">                PairInt p = points[i];</span>
<span class="fc" id="L627">                x = p.getX();</span>
<span class="fc" id="L628">                y = p.getY();</span>
<span class="fc" id="L629">                kpc1s.add(x);</span>
<span class="fc" id="L630">                kpc0s.add(y);</span>
            }

            // then filter
<span class="fc" id="L634">            maskCoordinates(kpc0s, kpc1s, harrisResponse.length,</span>
                harrisResponse[0].length, 4);//8);
        
            // filter to remove redundant points when rescaled
<span class="fc" id="L638">            set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L639">            kp0s = new TIntArrayList(kpc0s.size());</span>
<span class="fc" id="L640">            kp1s = new TIntArrayList(kpc0s.size());</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">            for (i = 0; i &lt; kpc0s.size(); ++i) {</span>
                // coords are in octave reference frame so expand to largest pyramid frame
                //    for redundancy and boundary check
<span class="fc" id="L644">                y = kpc0s.get(i);</span>
<span class="fc" id="L645">                x = kpc1s.get(i);</span>
<span class="fc" id="L646">                c0 = Math.round((float)y*scale);</span>
<span class="fc" id="L647">                c1 = Math.round((float)x*scale);</span>
                // if larger than largest pyramid image height
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                if (c0 &gt;= rH) {</span>
<span class="nc" id="L650">                    c0 = rH - 1;</span>
                }
                // if larger than largest pyramid image width
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">                if (c1 &gt;= cH) {</span>
<span class="nc" id="L654">                    c1 = cH - 1;</span>
                }
<span class="fc" id="L656">                PairInt p = new PairInt(c0, c1); // y, x</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (set.contains(p)) {</span>
<span class="fc" id="L658">                    continue;</span>
                }
<span class="fc" id="L660">                set.add(p);</span>
<span class="fc" id="L661">                kp0s.add(y);</span>
<span class="fc" id="L662">                kp1s.add(x);</span>
            }
            // let the VM reclaim the memory if it chooses:
<span class="fc" id="L665">            set = null;</span>
<span class="fc" id="L666">            kpc0s = null;</span>
<span class="fc" id="L667">            kpc1s = null;</span>
            
            // filter for number of points if requested
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (kp0s.size() &gt; this.nKeypoints) {</span>
<span class="fc" id="L671">                len = kp0s.size() - this.nKeypoints;</span>
                // TIntList.remove(int offset, int length)
                //          Removes length values from the list, starting at offset
<span class="fc" id="L674">                kp0s.remove(this.nKeypoints, len);</span>
<span class="fc" id="L675">                kp1s.remove(this.nKeypoints, len);</span>
            }
            // coords are in octave reference frame so expand to largest pyramid frame
<span class="fc" id="L678">            octaveImage = pyramidImages[octave].a;</span>
<span class="fc" id="L679">            orientations = calculateOrientations(octaveImage, kp0s, kp1s);</span>
            
<span class="fc" id="L681">            responses = new TFloatArrayList(kp0s.size());</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">            for (i = 0; i &lt; kp0s.size(); ++i) {</span>
<span class="fc" id="L683">                c0 = kp0s.get(i);</span>
<span class="fc" id="L684">                c1 = kp1s.get(i);</span>
<span class="fc" id="L685">                responses.add(harrisResponse[c0][c1]);</span>
            }
            
            // transform keypoints to full size coordinate reference frame.
<span class="fc bfc" id="L689" title="All 2 branches covered.">            for (i = 0; i &lt; kp0s.size(); ++i) {</span>
<span class="fc" id="L690">                c0 = Math.round(scale * kp0s.get(i));</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">                if (c0 &gt;= rH) {</span>
<span class="nc" id="L692">                    c0 = rH - 1;</span>
                }
<span class="fc" id="L694">                kp0s.set(i, c0);</span>

<span class="fc" id="L696">                c1 = Math.round(scale * kp1s.get(i));</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                if (c1 &gt;= cH) {</span>
<span class="nc" id="L698">                    c1 = cH - 1;</span>
                }
<span class="fc" id="L700">                kp1s.set(i, c1);</span>
            }

            // kp0s and kp1s are in coord frame of largest image

<span class="fc" id="L705">            keypoints0List.add(kp0s);</span>
<span class="fc" id="L706">            keypoints1List.add(kp1s);</span>
<span class="fc" id="L707">            orientationsList.add(orientations);</span>
<span class="fc" id="L708">            harrisResponses.add(responses);</span>
            
<span class="pc bnc" id="L710" title="All 2 branches missed.">            assert(orientations.size() == kp0s.size());</span>
<span class="pc bnc" id="L711" title="All 2 branches missed.">            assert(responses.size() == kp0s.size());</span>
<span class="pc bnc" id="L712" title="All 2 branches missed.">            assert(kp1s.size() == kp0s.size());</span>

        } // end loop over octave

        // note, at this point, each octave has the limit of this.nKeypoints,
        //    but the total may be as large as scales.length*this.nKeypoints
        
<span class="pc bnc" id="L719" title="All 2 branches missed.">        assert(pyramidImages.length == keypoints0List.size());</span>
<span class="pc bnc" id="L720" title="All 2 branches missed.">        assert(pyramidImages.length == keypoints1List.size());</span>
<span class="pc bnc" id="L721" title="All 2 branches missed.">        assert(pyramidImages.length == orientationsList.size());</span>
<span class="pc bnc" id="L722" title="All 2 branches missed.">        assert(pyramidImages.length == this.harrisResponses.size());</span>
<span class="pc bnc" id="L723" title="All 2 branches missed.">        assert(pyramidImages.length == scales.length);        </span>
<span class="fc" id="L724">    }</span>

    private void combineAndFilterTotal() {
        //combined into one list and sort by harris response then take first nKeypoints
                
<span class="fc" id="L729">        combinedKeypointList = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L730">        combinedOrientationList = new TDoubleArrayList();</span>
<span class="fc" id="L731">        combinedHarrisResponseList = new TFloatArrayList();</span>
        
<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (descrChoice.ordinal() != DescriptorChoice.NONE.ordinal()) {</span>
<span class="fc" id="L734">            combinedDescriptors = new Descriptors();</span>
        }
        
<span class="fc" id="L737">        final int nTotal = countKeypoints();</span>
        
        int octave, i;
<span class="fc" id="L740">        int count = 0;</span>
        TFloatList h;
        
<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (nTotal &lt; this.nKeypoints) {</span>
            //fill the arrays and return
            
<span class="fc" id="L746">            VeryLongBitString[] combinedD = new VeryLongBitString[nTotal];</span>
            TDoubleList orList;
            TIntList kp0List, kp1List;
            Descriptors d;
            
<span class="fc bfc" id="L751" title="All 2 branches covered.">            for (octave = 0; octave &lt; scales.length; ++octave) {</span>
<span class="fc" id="L752">                kp0List = keypoints0List.get(octave);</span>
<span class="fc" id="L753">                kp1List = keypoints1List.get(octave);</span>
<span class="fc" id="L754">                orList = orientationsList.get(octave);</span>
<span class="fc" id="L755">                h = harrisResponses.get(octave);</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">                for (i = 0; i &lt; kp0List.size(); ++i) {</span>
<span class="fc" id="L757">                    combinedKeypointList.add(new PairInt(kp1List.get(i), kp0List.get(i)));</span>
<span class="fc" id="L758">                    combinedHarrisResponseList.add(h.get(i));</span>
<span class="fc" id="L759">                    combinedOrientationList.add(orList.get(i));</span>
                }
            }
<span class="fc" id="L762">            count = 0;</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">            if (descrChoice.ordinal() != DescriptorChoice.NONE.ordinal()) {</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                for (octave = 0; octave &lt; scales.length; ++octave) {</span>
<span class="fc" id="L765">                    d = descriptorsList.get(octave);</span>
<span class="fc" id="L766">                    System.arraycopy(d.descriptors, 0, combinedD, count, d.descriptors.length);</span>
<span class="fc" id="L767">                    count += d.descriptors.length;</span>
                }
<span class="fc" id="L769">                combinedDescriptors.descriptors = combinedD;</span>
<span class="pc bnc" id="L770" title="All 2 branches missed.">                assert (combinedDescriptors.descriptors.length == nTotal);</span>
            }
<span class="pc bnc" id="L772" title="All 2 branches missed.">            assert(combinedKeypointList.size() == nTotal);</span>
<span class="pc bnc" id="L773" title="All 2 branches missed.">            assert (combinedOrientationList.size() == nTotal);</span>
<span class="pc bnc" id="L774" title="All 2 branches missed.">            assert (combinedHarrisResponseList.size() == nTotal);</span>

<span class="fc" id="L776">            return;</span>
        }

        // else sort and keep the top nKeypoints

        //TODO: consider the filtering that went into each octave and apply similar
        // here over the combined keypoint list as there are repeated keypoints and
        // some keypoints which are very near several other.
    
<span class="fc" id="L785">        PairInt[] idxs00 = new PairInt[nTotal];</span>
<span class="fc" id="L786">        int[] idxs0 = new int[nTotal];</span>
        
<span class="fc" id="L788">        count = 0;</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        for (octave = 0; octave &lt; scales.length; ++octave) {</span>
<span class="fc" id="L790">            h = harrisResponses.get(octave);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">            for (i = 0; i &lt; h.size(); ++i) {</span>
<span class="fc" id="L792">                idxs00[count] = new PairInt(octave, i);</span>
<span class="fc" id="L793">                idxs0[count] = count;</span>
<span class="fc" id="L794">                count++;</span>
<span class="fc" id="L795">                combinedHarrisResponseList.add(h.get(i));</span>
            }
        }
        
<span class="fc" id="L799">        QuickSort.sortBy1stArg(combinedHarrisResponseList, idxs0);</span>
        
<span class="fc" id="L801">        VeryLongBitString[] combinedD = new VeryLongBitString[this.nKeypoints];</span>
        int idxOctave, idxList, idx0;
        PairInt p;
        
<span class="fc bfc" id="L805" title="All 2 branches covered.">        for (i = 0; i &lt; this.nKeypoints; ++i) {</span>
<span class="fc" id="L806">            idx0 = idxs0[i];</span>
<span class="fc" id="L807">            idxOctave = idxs00[idx0].getX();</span>
<span class="fc" id="L808">            idxList = idxs00[idx0].getY();</span>
            
<span class="fc" id="L810">            p = new PairInt(keypoints1List.get(idxOctave).get(idxList),</span>
<span class="fc" id="L811">                keypoints0List.get(idxOctave).get(idxList));</span>
<span class="fc" id="L812">            combinedKeypointList.add(p);</span>
            
<span class="fc" id="L814">            combinedOrientationList.add(this.orientationsList.get(idxOctave).get(idxList));            </span>
        }
<span class="fc bfc" id="L816" title="All 2 branches covered.">        if (descrChoice.ordinal() != DescriptorChoice.NONE.ordinal()) {</span>
<span class="fc" id="L817">            count = 0;</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">            for (i = 0; i &lt; this.nKeypoints; ++i) {</span>
<span class="fc" id="L819">                idx0 = idxs0[i];</span>
<span class="fc" id="L820">                idxOctave = idxs00[idx0].getX();</span>
<span class="fc" id="L821">                idxList = idxs00[idx0].getY();</span>
                // this is the descriptor for one keypoint
<span class="fc" id="L823">                combinedD[count] = descriptorsList.get(idxOctave).descriptors[idxList];</span>
<span class="fc" id="L824">                count++;</span>
            }
<span class="fc" id="L826">            combinedDescriptors.descriptors = combinedD;</span>
<span class="pc bnc" id="L827" title="All 2 branches missed.">            assert(combinedDescriptors.descriptors.length == this.nKeypoints);</span>
        }
        
<span class="fc" id="L830">        combinedHarrisResponseList.remove(this.nKeypoints, nTotal - this.nKeypoints);</span>
        
<span class="pc bnc" id="L832" title="All 2 branches missed.">        assert(combinedKeypointList.size() == this.nKeypoints);</span>
<span class="pc bnc" id="L833" title="All 2 branches missed.">        assert(combinedOrientationList.size() == this.nKeypoints);</span>
<span class="pc bnc" id="L834" title="All 2 branches missed.">        assert(combinedHarrisResponseList.size() == this.nKeypoints);</span>
<span class="fc" id="L835">    }</span>

    private void extractDescriptors() {

<span class="fc bfc" id="L839" title="All 2 branches covered.">        if (descrChoice.equals(DescriptorChoice.NONE)) {</span>
<span class="fc" id="L840">            return;</span>
        }
        
<span class="fc" id="L843">        int nScales = scales.length;</span>
        
<span class="fc" id="L845">        descriptorsList = new ArrayList&lt;Descriptors&gt;(nScales);</span>
    
        TIntList kp0;
        TIntList kp1;
        TDoubleList or;
<span class="fc bfc" id="L850" title="All 2 branches covered.">        for (int i = 0; i &lt; nScales; ++i) {</span>

<span class="fc" id="L852">            float[][] octaveImage = pyramidImages[i].a;</span>

<span class="fc" id="L854">            kp0 = this.keypoints0List.get(i);</span>
<span class="fc" id="L855">            kp1 = this.keypoints1List.get(i);</span>
<span class="fc" id="L856">            or = this.orientationsList.get(i);</span>

            // result contains descriptors and mask.
            // also, modified by mask are the keypoints and orientations
<span class="fc" id="L860">            Descriptors desc = extractOctaveDescriptor(octaveImage, kp0, kp1, or,</span>
                scales[i]);

<span class="fc" id="L863">            descriptorsList.add(desc);</span>
        }
<span class="fc" id="L865">    }</span>

    private int countKeypoints() {
<span class="fc" id="L868">        int n = 0;</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">        for (TIntList kp0 : keypoints0List) {</span>
<span class="fc" id="L870">            n += kp0.size();</span>
<span class="fc" id="L871">        }</span>
<span class="fc" id="L872">        return n;</span>
    }

    private float[][] copy(float[][] a) {

<span class="nc" id="L877">        int n1 = a.length;</span>
<span class="nc" id="L878">        int n2 = a[0].length;</span>

<span class="nc" id="L880">        float[][] out = new float[n1][n2];</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc" id="L882">            out[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="nc" id="L885">        return out;</span>
    }

    protected class Resp {
        TIntList keypoints0;
        TIntList keypoints1;
    }

    public static class Descriptors {
        //NOTE: consider packing 4 descriptors into one or
        // doing as Image.java does with sensing 64 bit and 32 bit to make
        // long or int bit vectors
        public VeryLongBitString[] descriptors;
    }

    /**
     * adapted from
     * https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/orb.py
     *
     * @param octave scale
     * @return
     */
    private Resp extractKeypoints(int octave) {

<span class="fc" id="L909">        float[][] octaveImage = pyramidImages[octave].a;</span>
        
<span class="fc" id="L911">        float scale = scales[octave];</span>
        
<span class="fc" id="L913">        StructureTensor tensors = tensorComponents[octave];</span>
        
<span class="fc" id="L915">        float[][] fastResponse = cornerFast(octaveImage, fastN, fastThreshold);</span>

<span class="fc" id="L917">        int nRows = fastResponse.length;</span>
<span class="fc" id="L918">        int nCols = fastResponse[0].length;</span>

<span class="fc" id="L920">        TIntList keypoints0 = new TIntArrayList();</span>
<span class="fc" id="L921">        TIntList keypoints1 = new TIntArrayList();</span>
 
        // list of format [row, col, ...] of filtered maxima ordered by intensity
<span class="fc" id="L924">        cornerPeaks(fastResponse, 1, keypoints0, keypoints1);</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">        if (keypoints0.isEmpty()) {</span>
<span class="nc" id="L926">            Resp r2 = new Resp();</span>
<span class="nc" id="L927">            r2.keypoints0 = keypoints0;</span>
<span class="nc" id="L928">            r2.keypoints1 = keypoints1;</span>
<span class="nc" id="L929">            return r2;</span>
        }
        
<span class="fc" id="L932">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="fc bfc" id="L934" title="All 2 branches covered.">        if (doCreate1stDerivKeypoints) {</span>

<span class="fc" id="L936">            float hLimit = 0.01f;//0.09f;</span>

<span class="fc" id="L938">            imageProcessor.createFirstDerivKeyPoints(</span>
                tensors, keypoints0, keypoints1, hLimit);
            
            /*try {
                float factor = 255.f;
                Image img2 = new Image(nCols, nRows);
                for (int i = 0; i &lt; nRows; ++i) {
                    for (int j = 0; j &lt; nCols; ++j) {
                        int v = Math.round(factor * octaveImage[i][j]);
                        if (v &gt; 255) {
                            v = 255;
                        } else if (v &lt; 0) {
                            v = 0;
                        }
                        img2.setRGB(j, i, v, v, v);
                    }
                }
                for (int i = 0; i &lt; keypoints0.size(); ++i) {
                    int x = keypoints1.get(i);
                    int y = keypoints0.get(i);
                    img2.setRGB(x, y, 255, 0, 0);
                }
                System.out.println(&quot;nRows=&quot; + nRows + &quot; nCols=&quot; + nCols);
                //algorithms.imageProcessing.ImageDisplayer.displayImage(&quot;first deriv&quot;, img2);
                MiscDebug.writeImage(img2, &quot;_fr_&quot; 
                    + MiscDebug.getCurrentTimeFormatted());
                int z = 1;
            } catch(Exception e) {
                System.out.println(e.getMessage());
            }*/
        }

<span class="pc bpc" id="L970" title="1 of 2 branches missed.">        if (doCreateCurvatureKeyPoints) {</span>

            // usually, only create these points for points on an edge.
            // wanting the min and max of curvature,
            // and then those maxima that are 2 or 3 times stronger than
            // one of the adjacent minima.
            // with a single edge, the peak curvature should be larger than
            // 2 times that of the preceding or proceeding minima.

            //default thresh is 0.01f
<span class="nc" id="L980">            imageProcessor.createCurvatureKeyPoints(tensors, </span>
                keypoints0, keypoints1, curvatureThresh);

            /*try {
                float factor = 255.f;
                Image img2 = new Image(nCols, nRows);
                for (int i = 0; i &lt; nRows; ++i) {
                    for (int j = 0; j &lt; nCols; ++j) {
                        int v = Math.round(factor * octaveImage[i][j]);
                        if (v &gt; 255) {
                            v = 255;
                        } else if (v &lt; 0) {
                            v = 0;
                        }
                        img2.setRGB(j, i, v, v, v);
                    }
                }
                for (int i = 0; i &lt; keypoints0.size(); ++i) {
                    int x = keypoints1.get(i);
                    int y = keypoints0.get(i);
                    img2.setRGB(x, y, 255, 0, 0);
                }
                System.out.println(&quot;nRows=&quot; + nRows + &quot; nCols=&quot; + nCols);
                //algorithms.imageProcessing.ImageDisplayer.displayImage(&quot;curvature&quot;, img2);
                MiscDebug.writeImage(img2, &quot;_curve_&quot; 
                    + MiscDebug.getCurrentTimeFormatted());
                int z = 1;
            } catch(Exception e) {
                System.out.println(e.getMessage());
            }*/
        }
           
        // remove redundant keypoints
<span class="fc" id="L1013">        Set&lt;PairInt&gt; exists = new HashSet&lt;PairInt&gt;();</span>
        PairInt p;
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        for (int i = (keypoints0.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1016">            p = new PairInt(keypoints0.get(i), keypoints1.get(i));</span>
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">            if (exists.contains(p)) {</span>
<span class="nc" id="L1018">                keypoints0.removeAt(i);</span>
<span class="nc" id="L1019">                keypoints1.removeAt(i);</span>
            } else {
<span class="fc" id="L1021">                exists.add(p);</span>
            }
        }
               
        // size is same a octaveImage
<span class="fc" id="L1026">        float[][] harrisResponse = harrisResponseImages[octave].a;</span>

        // --- harris corners from response image ----
        
<span class="fc" id="L1030">        imageProcessor.peakLocalMax(harrisResponse, </span>
            1, 0.1f,
            true, keypoints0, keypoints1);

<span class="fc" id="L1034">        Resp r2 = new Resp();</span>
<span class="fc" id="L1035">        r2.keypoints0 = keypoints0;</span>
<span class="fc" id="L1036">        r2.keypoints1 = keypoints1;</span>
        
        /*{//DEBUG
            Image dbg = new Image(harrisResponse[0].length,
                harrisResponse.length);
            float[] tmp = new float[dbg.getNPixels()];
            tmp = new float[dbg.getNPixels()];
            for (int i = 0; i &lt; dbg.getNPixels(); ++i) {
                int x = dbg.getCol(i);
                int y = dbg.getRow(i);
                tmp[i] = harrisResponse[y][x];
            }
            MiscMath.rescale(tmp, 0, 255);
            for (int i = 0; i &lt; dbg.getNPixels(); ++i) {
                if (tmp[i] &gt; 0) {
                    dbg.setRGB(i, 255, 255, 255);
                }
            }
            PairIntArray tmp2 = new PairIntArray(keypoints0.size());
            for (int i = 0; i &lt; keypoints0.size(); ++i) {
                int x = keypoints1.get(i);
                int y = keypoints0.get(i);
                tmp2.add(x, y);
            }
            ImageIOHelper.addCurveToImage(tmp2, dbg, 2, 255, 0, 0);
            MiscDebug.writeImage(dbg, &quot;_hr_&quot; + 
                MiscDebug.getCurrentTimeFormatted());
            System.out.println(&quot;nKP=&quot; + keypoints0.size() + &quot; for octave=&quot; + 
                octave);
        }*/
        
<span class="fc" id="L1067">        return r2;</span>
    }

    /**
     Extract FAST corners for a given image.

     code is adapted from :
     https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/corner.py

     which has the copyright above in the class level documentation.

    &lt;pre&gt;
     References
    ----------
    .. [1] Edward Rosten and Tom Drummond
           &quot;Machine Learning for high-speed corner detection&quot;,
           http://www.edwardrosten.com/work/rosten_2006_machine.pdf
    .. [2] Wikipedia, &quot;Features from accelerated segment test&quot;,
           https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test
     &lt;/pre&gt;

     @param img
          Input image as 2D array in row-major, C-style ordered array
     @param n
          Minimum number of consecutive pixels out of 16 pixels on the circle
          that should all be either brighter or darker w.r.t testpixel.
          A point c on the circle is darker w.r.t test pixel p if
          `Ic lessThan Ip - threshold` and brighter if `Ic greaterThan Ip + threshold`.
          Also stands for the n in `FAST-n` corner detector.
          (the scipy default is n=12).
     @param threshold
          Threshold used in deciding whether the pixels on the circle are
          brighter, darker or similar w.r.t. the test pixel. Decrease the
          threshold when more corners are desired and vice-versa.
          (the scipy default is threshold=0.15)
     @return
        FAST corner response image.
     */
    protected float[][] cornerFast(final float[][] img, final int n, final float threshold) {

<span class="pc bnc" id="L1107" title="All 2 branches missed.">        assert(n == fastN);</span>

<span class="fc" id="L1109">        int nRows = img.length;</span>
<span class="fc" id="L1110">        int nCols = img[0].length;</span>

        int i, j, k;

        int speed_sum_b, speed_sum_d;
        float curr_pixel;
        float lower_threshold, upper_threshold;

<span class="fc" id="L1118">        float[][] cornerResponse = new float[nRows][nCols];</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        for (i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L1120">            cornerResponse[i] = new float[nCols];</span>
        }

<span class="fc" id="L1123">        int[] rp = new int[]{0, 1, 2, 3, 3, 3, 2, 1, 0, -1, -2, -3, -3, -3, -2, -1};</span>
<span class="fc" id="L1124">        int[] cp = new int[]{3, 3, 2, 1, 0, -1, -2, -3, -3, -3, -2, -1, 0, 1, 2, 3};</span>
<span class="fc" id="L1125">        char[] bins = new char[16];</span>
<span class="fc" id="L1126">        float[] circleIntensities = new float[16];</span>
        float currResponse;

<span class="fc bfc" id="L1129" title="All 2 branches covered.">        for (i = 3; i &lt; (nRows - 3); ++i) {</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">            for (j = 3; j &lt; (nCols - 3); ++j) {</span>
<span class="fc" id="L1131">                curr_pixel = img[i][j];</span>
<span class="fc" id="L1132">                lower_threshold = curr_pixel - threshold;</span>
<span class="fc" id="L1133">                upper_threshold = curr_pixel + threshold;</span>

<span class="fc bfc" id="L1135" title="All 2 branches covered.">                for (k = 0; k &lt; 16; ++k) {</span>
<span class="fc" id="L1136">                    circleIntensities[k] = img[i + rp[k]][j + cp[k]];</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">                    if (circleIntensities[k] &gt; upper_threshold) {</span>
                        //# Brighter pixel
<span class="fc" id="L1139">                        bins[k] = 'b';</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">                    } else if (circleIntensities[k] &lt; lower_threshold) {</span>
                        //# Darker pixel
<span class="fc" id="L1142">                        bins[k] = 'd';</span>
                    } else {
                        //# Similar pixel
<span class="fc" id="L1145">                        bins[k] = 's';</span>
                    }
                }
                //# High speed test for n &gt;= 12
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">                if (n &gt;= 12) {</span>
<span class="nc" id="L1150">                    speed_sum_b = 0;</span>
<span class="nc" id="L1151">                    speed_sum_d = 0;</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">                    for (k = 0; k &lt; 16; k += 4) {</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                        if (bins[k] == 'b') {</span>
<span class="nc" id="L1154">                            speed_sum_b += 1;</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                        } else if (bins[k] == 'd') {</span>
<span class="nc" id="L1156">                            speed_sum_d += 1;</span>
                        }
                    }
<span class="nc bnc" id="L1159" title="All 4 branches missed.">                    if ((speed_sum_d &lt; 3) &amp;&amp; (speed_sum_b &lt; 3)) {</span>
<span class="nc" id="L1160">                        continue;</span>
                    }
                }

                //# Test for bright pixels
<span class="fc" id="L1165">                currResponse = _corner_fast_response(curr_pixel,</span>
                    circleIntensities, bins, 'b', n);

                //# Test for dark pixels
<span class="fc bfc" id="L1169" title="All 2 branches covered.">                if (currResponse == 0) {</span>
<span class="fc" id="L1170">                    currResponse = _corner_fast_response(curr_pixel,</span>
                        circleIntensities, bins, 'd', n);
                }

<span class="fc bfc" id="L1174" title="All 2 branches covered.">                if (currResponse &gt; 0) {</span>
<span class="fc" id="L1175">                    cornerResponse[i][j] = currResponse;</span>
                }
            }
        }

<span class="fc" id="L1180">        return cornerResponse;</span>
    }

    /**
     * https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/corner_cy.pyx

     * @param curr_pixel
     * @param circleIntensities
     * @param bins
     * @param state
     * @param n
     * @return
     */
    private float _corner_fast_response(final float curr_pixel,
        float[] circleIntensities, char[] bins, final char state, final int n) {

<span class="fc" id="L1196">        int consecutiveCount = 0;</span>
        float currResponse;
        int l, m;
<span class="fc bfc" id="L1199" title="All 2 branches covered.">        for (l = 0; l &lt; (15 + n); ++l) {</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">            if (bins[l % 16] == state) {</span>
<span class="fc" id="L1201">                consecutiveCount += 1;</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">                if (consecutiveCount == n) {</span>
<span class="fc" id="L1203">                    currResponse = 0;</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">                    for (m = 0; m &lt; 16; ++m) {</span>
<span class="fc" id="L1205">                        currResponse += Math.abs(circleIntensities[m] - curr_pixel);</span>
                    }
<span class="fc" id="L1207">                    return currResponse;</span>
                }
            } else {
<span class="fc" id="L1210">                consecutiveCount = 0;</span>
            }
        }

<span class="fc" id="L1214">        return 0;</span>
    }

    private void maskCoordinates(TIntList keypoints0, TIntList keypoints1,
        int nRows, int nCols, int maskRadius) {

<span class="pc bnc" id="L1220" title="All 2 branches missed.">        assert(keypoints0.size() == keypoints1.size());</span>

<span class="fc" id="L1222">        TIntSet peaks = new TIntHashSet();</span>

        /* making single pixel index out of coordinates:
        (row * width) + col
        pixIdxs[count] = (j * nRows) + i;  this is consistent with Image.java for plotting 
        */
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        for (int i = 0; i &lt; keypoints0.size(); ++i) {</span>
<span class="fc" id="L1229">            int ii = keypoints0.get(i);//row</span>
<span class="fc" id="L1230">            int jj = keypoints1.get(i);//col</span>
<span class="fc" id="L1231">            int pixIdx = (ii * nRows) + jj;</span>
<span class="fc" id="L1232">            peaks.add(pixIdx);</span>
        }

<span class="fc bfc" id="L1235" title="All 2 branches covered.">        for (int i = 0; i &lt; keypoints0.size(); ++i) {</span>
<span class="fc" id="L1236">            int ii = keypoints0.get(i); //row</span>
<span class="fc" id="L1237">            int jj = keypoints1.get(i); //col</span>
<span class="fc" id="L1238">            int pixIdx = (ii * nRows) + jj;</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">            if (!peaks.contains(pixIdx)) {</span>
<span class="fc" id="L1240">                continue;</span>
            }
<span class="fc bfc" id="L1242" title="All 2 branches covered.">            for (int k0 = ii - maskRadius; k0 &lt;= (ii + maskRadius); ++k0) {</span>
<span class="fc bfc" id="L1243" title="All 4 branches covered.">                if ((k0 &lt; 0) || (k0 &gt; (nRows - 1))) {</span>
<span class="fc" id="L1244">                    continue;</span>
                }
<span class="fc bfc" id="L1246" title="All 2 branches covered.">                for (int k1 = jj - maskRadius; k1 &lt;= (jj + maskRadius); ++k1) {</span>
<span class="fc bfc" id="L1247" title="All 8 branches covered.">                    if ((k1 &lt; 0) || (k1 &gt; (nCols - 1)) || (k0 == ii &amp;&amp; k1 == jj)) {</span>
<span class="fc" id="L1248">                        continue;</span>
                    }
                    //TODO: check this.  looks like error in pixIdx2
<span class="fc" id="L1251">                    int pixIdx2 = (k0 * nRows) + k1;</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">                    if (peaks.contains(pixIdx2)) {</span>
<span class="fc" id="L1253">                        peaks.remove(pixIdx2);</span>
                    }
                }
            }
        }

<span class="fc" id="L1259">        TIntList keypoints0_2 = new TIntArrayList(peaks.size());</span>
<span class="fc" id="L1260">        TIntList keypoints1_2 = new TIntArrayList(peaks.size());</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">        for (int i = 0; i &lt; keypoints0.size(); ++i) {</span>
<span class="fc" id="L1262">            int ii = keypoints0.get(i);//row</span>
<span class="fc" id="L1263">            int jj = keypoints1.get(i);//col</span>
<span class="fc" id="L1264">            int pixIdx = (ii * nRows) + jj;</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">            if (peaks.contains(pixIdx)) {</span>
<span class="fc" id="L1266">                keypoints0_2.add(ii);</span>
<span class="fc" id="L1267">                keypoints1_2.add(jj);</span>
            }
        }

<span class="fc" id="L1271">        keypoints0.clear();</span>
<span class="fc" id="L1272">        keypoints0.addAll(keypoints0_2);</span>

<span class="fc" id="L1274">        keypoints1.clear();</span>
<span class="fc" id="L1275">        keypoints1.addAll(keypoints1_2);</span>
<span class="fc" id="L1276">    }</span>

    /**
     *
     * @param nRows
     * @param nCols
     * @param border
     * @return mask of length input.size/2 containing a 1 or 0
     *     indicating if pixels are within the image (``True``) or in the
           border region of the image (``False``).
     */
    private TIntList maskCoordinatesIfBorder(TIntList coords0, TIntList coords1,
        int nRows, int nCols, int border) {

<span class="fc" id="L1290">        TIntSet set = new TIntHashSet();</span>

        /* making single pixel index out of coordinates:
        (row * width) + col
        pixIdxs[count] = (j * nRows) + i;
        */
<span class="fc bfc" id="L1296" title="All 2 branches covered.">        for (int i = 0; i &lt; coords0.size(); ++i) {</span>
<span class="fc" id="L1297">            int ii = coords0.get(i);</span>
<span class="fc" id="L1298">            int jj = coords1.get(i);</span>
<span class="fc" id="L1299">            int pixIdx = (jj * nRows) + ii;</span>
<span class="fc" id="L1300">            set.add(pixIdx);</span>
        }

<span class="fc" id="L1303">        int nBefore = set.size();</span>

<span class="fc bfc" id="L1305" title="All 2 branches covered.">        for (int i = 0; i &lt; coords0.size(); ++i) {</span>
<span class="fc" id="L1306">            int ii = coords0.get(i);</span>
<span class="fc" id="L1307">            int jj = coords1.get(i);</span>
<span class="fc" id="L1308">            int pixIdx = (jj * nRows) + ii;</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">            if (!set.contains(pixIdx)) {</span>
<span class="fc" id="L1310">                continue;</span>
            }
<span class="fc bfc" id="L1312" title="All 8 branches covered.">            if ((ii &lt; border) || (jj &lt; border) || (ii &gt; (nRows - border - 1)) ||</span>
                (jj &gt; (nCols - border - 1))) {
<span class="fc" id="L1314">                set.remove(pixIdx);</span>
            }
        }

        //System.out.println(&quot;nBefore border rm=&quot; + nBefore +
        //    &quot; nAfter=&quot; + set.size());

        /*
        Mask indicating if pixels are within the image (``True``) or in the
            border region of the image (``False``).
        */

<span class="fc" id="L1326">        TIntList mask = new TIntArrayList(coords0.size());</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">        for (int i = 0; i &lt; coords0.size(); ++i) {</span>
<span class="fc" id="L1328">            int ii = coords0.get(i);</span>
<span class="fc" id="L1329">            int jj = coords1.get(i);</span>
<span class="fc" id="L1330">            int pixIdx = (jj * nRows) + ii;</span>
<span class="fc bfc" id="L1331" title="All 2 branches covered.">            if (set.contains(pixIdx)) {</span>
<span class="fc" id="L1332">                mask.add(1);</span>
            } else {
<span class="fc" id="L1334">                mask.add(0);</span>
            }
        }
<span class="pc bnc" id="L1337" title="All 2 branches missed.">        assert(coords0.size() == mask.size());</span>
<span class="pc bnc" id="L1338" title="All 2 branches missed.">        assert(coords0.size() == coords1.size());</span>

<span class="fc" id="L1340">        return mask;</span>
    }

    /**
     * https://github.com/scikit-image/scikit-image/blob/d19b60add22b818298c7aefa65fharris0e7c1467ef4d/skimage/feature/corner.py
     *
      Find corners in corner measure response image.
      This differs from `skimage.feature.peak_local_max` in that it suppresses
      multiple connected peaks with the same accumulator value.
     *
     * @param img
     * @param minDistance
     * @param outputKeypoints0 the output row coordinates of keypoints
     * @param outputKeypoints1 the output col coordinates of keypoints
     */
    protected void cornerPeaks(float[][] img, int minDistance,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

<span class="fc" id="L1358">        float thresholdRel = 0.1f;</span>

<span class="fc" id="L1360">        int nRows = img.length;</span>
<span class="fc" id="L1361">        int nCols = img[0].length;</span>
        
<span class="fc" id="L1363">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
        // these results have been sorted by decreasing intensity
<span class="fc" id="L1366">        imageProcessor.peakLocalMax(img, minDistance, thresholdRel,</span>
            true, outputKeypoints0, outputKeypoints1);

        //System.out.println(&quot;keypoints in cornerPeaks=&quot;
        //    + &quot;rows=&quot; + outputKeypoints0.toString()
        //    + &quot;cols=&quot; + outputKeypoints1.toString()
        //    + &quot;\nsize=&quot; + outputKeypoints0.size());

<span class="fc" id="L1374">        maskCoordinates(outputKeypoints0, outputKeypoints1, nRows, nCols,</span>
            minDistance);
<span class="fc" id="L1376">    }</span>

    public static class Pix implements Comparable&lt;Pix&gt; {

        public final int i;
        public final int j;
        public final Float value;
        public Pix(int i, int j, Float v) {
            this.i = i;
            this.j = j;
            this.value = v;
        }
        @Override
        public int compareTo(Pix other) {
            // changed for a descending sort
            return other.value.compareTo(this.value);
        }

    }

    /**
        Compute the orientation of corners.
        The orientation of corners is computed using the first order central moment
        i.e. the center of mass approach. The corner orientation is the angle of
        the vector from the corner coordinate to the intensity centroid in the
        local neighborhood around the corner calculated using first order central
        moment.
        adapted from
        from https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/corner_cy.pyx

        &lt;pre&gt;
            +90
        135  |  +45
             |
       180-------- 0
             |
       -135  |   -45
            -90
        &lt;/pre&gt;


        References
        ----------
        .. [1] Ethan Rublee, Vincent Rabaud, Kurt Konolige and Gary Bradski
              &quot;ORB : An efficient alternative to SIFT and SURF&quot;
              http://www.vision.cs.chubu.ac.jp/CV-R/pdf/Rublee_iccv2011.pdf
        .. [2] Paul L. Rosin, &quot;Measuring Corner Properties&quot;
              http://users.cs.cf.ac.uk/Paul.Rosin/corner2.pdf
     * @param octaveImage
           Input grayscale image.
     * @param keypoints0 keypoint y coords in reference frame of this octave image
     * @param keypoints1 keypoint x coords in reference frame of this octave iamge
     * @localParam OFAST_MASK
     *     Mask defining the local neighborhood of the corner used for the
           calculation of the central moment.
     * @return
     *    orientations : (N, 1) array
               Orientations of corners in the range [-pi, pi].
     */
    public TDoubleList calculateOrientations(float[][] octaveImage,
        TIntList keypoints0, TIntList keypoints1) {

        //same as mask, same 0's and 1's:
        //cdef unsigned char[:, ::1] cmask = np.ascontiguousarray(mask != 0, dtype=np.uint8)

        int i, r, c, r0, c0;
<span class="fc" id="L1442">        int nMaskRows = OFAST_MASK.length;</span>
<span class="fc" id="L1443">        int nMaskCols = OFAST_MASK[0].length;</span>
<span class="fc" id="L1444">        int nMaskRows2 = (nMaskRows - 1) / 2;</span>
<span class="fc" id="L1445">        int nMaskCols2 = (nMaskCols - 1) / 2;</span>

        //cdef double[:, :] cimage = np.pad(image, (mrows2, mcols2), mode='constant',
        //    constant_values=0)
<span class="fc" id="L1449">        int nRows2 = octaveImage.length + (2 * nMaskRows2);</span>
<span class="fc" id="L1450">        int nCols2 = octaveImage[0].length + (2 * nMaskCols2);</span>
<span class="fc" id="L1451">        double[][] cImage = new double[nRows2][nCols2];</span>
<span class="fc bfc" id="L1452" title="All 2 branches covered.">        for (i = 0; i &lt; nRows2; ++i) {</span>
<span class="fc" id="L1453">            cImage[i] = new double[nCols2];</span>
<span class="fc bfc" id="L1454" title="All 4 branches covered.">            if ((i &gt;= nMaskRows2) &amp;&amp; (i &lt; (nRows2 - nMaskRows2 - 1))) {</span>
<span class="fc" id="L1455">                float[] src = octaveImage[i - nMaskRows2];</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">                for (int ii = 0; ii &lt; src.length; ++ii) {</span>
<span class="fc" id="L1457">                    cImage[i][ii + nMaskCols2] = src[ii];</span>
                }
            }
        }

        // number of corner coord pairs
<span class="fc" id="L1463">        int nCorners = keypoints0.size();</span>

<span class="fc" id="L1465">        TDoubleList orientations = new TDoubleArrayList(nCorners);</span>

        // eqns (1), (2), (3) of Rublee et al.
        double curr_pixel;
        double m01, m10, m01_tmp;

<span class="fc bfc" id="L1471" title="All 2 branches covered.">        for (i = 0; i &lt; nCorners; ++i) {</span>
<span class="fc" id="L1472">            r0 = keypoints0.get(i);</span>
<span class="fc" id="L1473">            c0 = keypoints1.get(i);</span>

<span class="fc" id="L1475">            m01 = 0;</span>
<span class="fc" id="L1476">            m10 = 0;</span>

<span class="fc bfc" id="L1478" title="All 2 branches covered.">            for (r = 0; r &lt; nMaskRows; ++r) {</span>
<span class="fc" id="L1479">                m01_tmp = 0;</span>
<span class="fc bfc" id="L1480" title="All 2 branches covered.">                for (c = 0; c &lt; nMaskCols; ++c) {</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">                    if (OFAST_MASK[r][c] &gt; 0) {</span>
<span class="fc" id="L1482">                        curr_pixel = cImage[r0 + r][c0 + c];</span>
<span class="fc" id="L1483">                        m10 += curr_pixel * (c - nMaskCols2);</span>
<span class="fc" id="L1484">                        m01_tmp += curr_pixel;</span>
                    }
                }
<span class="fc" id="L1487">                m01 += m01_tmp * (r - nMaskRows2);</span>
            }

            //arc tangent of y/x, in the interval [-pi,+pi] radians
<span class="fc" id="L1491">            orientations.add(Math.atan2(m01, m10));</span>

        }

<span class="fc" id="L1495">        return orientations;</span>
    }

    /**
      Compute Harris corner measure response image.
        This corner detector uses information from the auto-correlation matrix A
        (a.k.a. he structure tensor):
            A = [(imx**2)   (imx*imy)] = [Axx Axy]
                [(imx*imy)   (imy**2)]   [Axy Ayy]
        Where imx and imy are first derivatives, averaged with a gaussian filter.
        The corner measure is then defined as::
            det(A) - k * trace(A)**2

      adapted from
      from https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/corner.py

     NOTE: made the change for case where entire detA is 0 to use +k*Trace^2;

    @param image
     * @param detA
     * @param traceA
    @return the harris corner response image of same size as image,
    *   and composed of
    *   response = detA - k * traceA ** 2 built from the 2nd derivatives of
    *   image intensity.
    */
    protected float[][] cornerHarris(float[][] image, float[][] detA,
        float[][] traceA) {

        // method = 'k'.  k is Sensitivity factor to separate corners from edges,
        // Small values of k result in detection of sharp corners.
<span class="fc" id="L1526">        float k = this.harrisK;</span>

        //response = detA - k * traceA ** 2
        // unless detA is all 0's, then will use only +k * traceA**2
<span class="fc" id="L1530">        float[][] response = new float[detA.length][];</span>
<span class="fc" id="L1531">        boolean detAAll0s = true;</span>
<span class="fc bfc" id="L1532" title="All 2 branches covered.">        for (int i = 0; i &lt; detA.length; ++i) {</span>
<span class="fc" id="L1533">            response[i] = new float[detA[0].length];</span>
<span class="fc bfc" id="L1534" title="All 2 branches covered.">            for (int j = 0; j &lt; detA[i].length; ++j) {</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered.">                if (detA[i][j] != 0.f) {</span>
<span class="fc" id="L1536">                    detAAll0s = false;</span>
<span class="fc" id="L1537">                    break;</span>
                }
            }
        }
        
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        for (int i = 0; i &lt; detA.length; ++i) {</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">            for (int j = 0; j &lt; detA[i].length; ++j) {</span>
<span class="fc" id="L1544">                float v = k * (traceA[i][j] * traceA[i][j]);</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">                if (detAAll0s) {</span>
<span class="fc" id="L1546">                    response[i][j] = v;</span>
                } else {
<span class="fc" id="L1548">                    response[i][j] = detA[i][j] - v;</span>
                }
            }
        }

<span class="fc" id="L1553">        return response;</span>
    }

    /**
     Compute Harris corner measure response image
     ([Harris and Stephens, 1988).
     This corner detector uses information from the auto-correlation matrix A
     (a.k.a. the structure tensor):
     &lt;pre&gt;
     A = [(imx**2)   (imx*imy)] = [Axx Axy]
        [(imx*imy)   (imy**2)]   [Axy Ayy]
     &lt;/pre&gt;
     Where imx and imy are first derivatives, averaged with a gaussian filter.
     The corner measure is then defined as::
     MASKS eqn (11.1)
         det(A) + k * trace(A)**2

     originally adapted
     from https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/corner.py

     @param image
     @return the harris corner response image of same size as image,
      *   and composed of
      *   response = detA + k * traceA ** 2 built from the 2nd derivatives of
      *   image intensity.
     */
    public static double[][] cornerHarris(double[][] image) {

<span class="fc" id="L1581">        float sigma = 1.f;</span>

<span class="fc" id="L1583">        StructureTensorD tensor = new StructureTensorD(image, sigma, false);</span>

        // method = 'k'.  k is Sensitivity factor to separate corners from edges,
        // Small values of k result in detection of sharp corners.
<span class="fc" id="L1587">        double k = 0.04;</span>

<span class="fc" id="L1589">        double[][] detA = tensor.getDeterminant();</span>
<span class="fc" id="L1590">        double[][] traceA = tensor.getTrace();</span>
        int i;
        int j;
<span class="fc" id="L1593">        boolean detAAll0s = true;</span>
        //response = detA - k * traceA ** 2
<span class="fc" id="L1595">        double[][] response = new double[detA.length][];</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">        for (i = 0; i &lt; detA.length; ++i) {</span>
<span class="fc" id="L1597">            response[i] = new double[detA[0].length];</span>
<span class="pc bpc" id="L1598" title="1 of 2 branches missed.">            for (j = 0; j &lt; detA[i].length; ++j) {</span>
<span class="pc bpc" id="L1599" title="1 of 2 branches missed.">                if (detA[i][j] != 0.f) {</span>
<span class="fc" id="L1600">                    detAAll0s = false;</span>
<span class="fc" id="L1601">                    break;</span>
                }
            }
        }
        double v;
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        for (i = 0; i &lt; detA.length; ++i) {</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">            for (j = 0; j &lt; detA[i].length; ++j) {</span>
<span class="fc" id="L1608">                v = k * (traceA[i][j] * traceA[i][j]);</span>
<span class="pc bpc" id="L1609" title="1 of 2 branches missed.">                if (detAAll0s) {</span>
<span class="nc" id="L1610">                    response[i][j] = v;</span>
                } else {
<span class="fc" id="L1612">                    response[i][j] = detA[i][j] - v;</span>
                }
            }
        }

<span class="fc" id="L1617">        return response;</span>
    }

    /**
     * filter the keypoints, orientations, and responses to remove those close
     * to the border and then create descriptors for the remaining.
     *
     * @param octaveImage
     * @param keypoints0
     * @param keypoints1
     * @return the encapsulated descriptors and mask
     */
    protected TIntList filterNearBorder(float[][] octaveImage,
        TIntList keypoints0, TIntList keypoints1) {

<span class="fc" id="L1632">        int nRows = octaveImage.length;</span>
<span class="fc" id="L1633">        int nCols = octaveImage[0].length;</span>

<span class="fc" id="L1635">        int border = 5;</span>
<span class="fc bfc" id="L1636" title="All 2 branches covered.">        if (Math.min(nRows, nCols)/20. &lt; border) {</span>
<span class="fc" id="L1637">            border = (int)(Math.min(nRows, nCols)/20.);</span>
        }

<span class="fc" id="L1640">        TIntList mask = maskCoordinatesIfBorder(keypoints0, keypoints1,</span>
            nRows, nCols, border);//16);

<span class="fc bfc" id="L1643" title="All 2 branches covered.">        for (int i = (mask.size() - 1); i &gt; -1; --i) {</span>
<span class="fc bfc" id="L1644" title="All 2 branches covered.">            if (mask.get(i) == 0) {</span>
<span class="fc" id="L1645">                keypoints0.removeAt(i);</span>
<span class="fc" id="L1646">                keypoints1.removeAt(i);</span>
            }
        }

<span class="fc" id="L1650">        return mask;</span>
    }

    /**
     * filter the keypoints, orientations, and responses to remove those close
     * to the border and then create descriptors for the remaining.
     *
     * @param octaveImage
     * @param keypoints0 keypoint y coordinates in the 
     * reference frame of the largest pyramid image
     * @param keypoints1 keypoint x coordinates in the 
     * reference frame of the largest pyramid image
     * @param orientations
     * @param scale
     * @return the encapsulated descriptors and mask
     */
    protected Descriptors extractOctaveDescriptor(float[][] octaveImage,
        TIntList keypoints0, TIntList keypoints1,
        TDoubleList orientations, float scale) {

<span class="pc bnc" id="L1670" title="All 2 branches missed.">        assert(orientations.size() == keypoints0.size());</span>
<span class="pc bnc" id="L1671" title="All 2 branches missed.">        assert(orientations.size() == keypoints1.size());</span>

<span class="fc" id="L1673">        Descriptors desc = new Descriptors();</span>

<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">        if (descrChoice.equals(DescriptorChoice.NONE)) {</span>
<span class="nc" id="L1676">            desc.descriptors = new VeryLongBitString[0];</span>
        } else {
<span class="fc" id="L1678">            desc.descriptors = orbLoop(octaveImage, keypoints0, keypoints1,</span>
                orientations, scale);
        }

<span class="fc" id="L1682">        return desc;</span>
    }

    /**
     * create descriptors for the given keypoints.
     *
     * adapted from
     * https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/orb_cy.pyx
     *
     * @param octaveImage
     * @param keypoints0 keypoint y coords in reference frame of the largest
     * pyramid image
     * @param keypoints1 keypoint x coords in reference frame of the largest
     * pyramid image
     * @param orientations
     * @param scale the scale for this octave image.
     * @return
     * array of bit vectors of which only 256 bits are used
     * length is [orientations.size]
     */
    private VeryLongBitString[] orbLoop(float[][] octaveImage, TIntList keypoints0,
        TIntList keypoints1, TDoubleList orientations, float scale) {
      
<span class="pc bnc" id="L1705" title="All 2 branches missed.">        assert(orientations.size() == keypoints0.size());</span>

<span class="fc bfc" id="L1707" title="All 2 branches covered.">        if (POS0 == null) {</span>
<span class="fc" id="L1708">            POS0 = ORBDescriptorPositions.POS0;</span>
        }
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        if (POS1 == null) {</span>
<span class="fc" id="L1711">            POS1 = ORBDescriptorPositions.POS1;</span>
        }
        
<span class="fc" id="L1714">        int nKP = keypoints0.size();</span>

<span class="fc" id="L1716">        log.fine(&quot;nKP=&quot; + nKP);</span>

        // each item is a 256 length bit string
<span class="fc" id="L1719">        VeryLongBitString[] descriptors = new VeryLongBitString[nKP];</span>
        
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">        if (nKP == 0) {</span>
<span class="nc" id="L1722">            return descriptors;</span>
        }
        
        //System.out.printf(&quot;scale=%.2f, nKP=%d\n&quot;, scale, nKP);

        double pr0, pc0, pr1, pc1, angle, sinA, cosA;
        int spr0, spc0, spr1, spc1, kr, kc, i, j, x0, y0, x1, y1;
      
<span class="fc bfc" id="L1730" title="All 2 branches covered.">        for (i = 0; i &lt; nKP; ++i) {</span>

<span class="fc" id="L1732">            descriptors[i] = new VeryLongBitString(POS1.length);</span>

<span class="fc" id="L1734">            angle = orientations.get(i);</span>
<span class="fc" id="L1735">            sinA = Math.sin(angle);</span>
<span class="fc" id="L1736">            cosA = Math.cos(angle);</span>

<span class="fc" id="L1738">            kr = keypoints0.get(i);</span>
<span class="fc" id="L1739">            kc = keypoints1.get(i);</span>

            // put kr and kc into this octave's pyramid image reference frame.
<span class="fc" id="L1742">            kr = (int)(kr/scale);</span>
<span class="fc" id="L1743">            kc = (int)(kc/scale);</span>

<span class="fc bfc" id="L1745" title="All 2 branches covered.">            for (j = 0; j &lt; POS0.length; ++j) {</span>
<span class="fc" id="L1746">                pr0 = POS0[j][0];</span>
<span class="fc" id="L1747">                pc0 = POS0[j][1];</span>
<span class="fc" id="L1748">                pr1 = POS1[j][0];</span>
<span class="fc" id="L1749">                pc1 = POS1[j][1];</span>

<span class="fc" id="L1751">                spr0 = (int)Math.round(sinA * pr0 + cosA * pc0);</span>
<span class="fc" id="L1752">                spc0 = (int)Math.round(cosA * pr0 - sinA * pc0);</span>
<span class="fc" id="L1753">                spr1 = (int)Math.round(sinA * pr1 + cosA * pc1);</span>
<span class="fc" id="L1754">                spc1 = (int)Math.round(cosA * pr1 - sinA * pc1);</span>

<span class="fc" id="L1756">                x0 = kr + spr0;</span>
<span class="fc" id="L1757">                y0 = kc + spc0;</span>
<span class="fc" id="L1758">                x1 = kr + spr1;</span>
<span class="fc" id="L1759">                y1 = kc + spc1;</span>

<span class="fc bfc" id="L1761" title="All 16 branches covered.">                if (x0 &lt; 0 || y0 &lt; 0 || x1 &lt; 0 || y1 &lt; 0 ||</span>
                    (x0 &gt; (octaveImage.length - 1)) ||
                    (x1 &gt; (octaveImage.length - 1)) ||
                    (y0 &gt; (octaveImage[0].length - 1)) ||
                    (y1 &gt; (octaveImage[0].length - 1))
                    ) {
<span class="fc" id="L1767">                    continue;</span>
                }
                // eqn (4) of Rublee et al.
<span class="fc bfc" id="L1770" title="All 2 branches covered.">                if (octaveImage[x0][y0] &lt; octaveImage[x1][y1]) {</span>
<span class="fc" id="L1771">                    descriptors[i].setBit(j);</span>
                }
            }
        }

<span class="fc" id="L1776">        return descriptors;</span>
    }

    /**
     * get a list of each octave's descriptors.  NOTE that the list
     * is not copied so do not modify.
     * The coordinates of the descriptors can be found in keyPointsList, but
     * with twice the spacing because that stores row and col in same list.
     * @return
     */
    public List&lt;Descriptors&gt; getDescriptorsList() {
<span class="fc" id="L1787">        return descriptorsList;</span>
    }

    /**
     * get a list of each octave's descriptors as a combined descriptor.
     * The coordinates of the descriptors can be found in getAllKeypoints, but
     * with twice the spacing because that stores row and col in same list.
     * @return
     */
    public Descriptors getAllDescriptors() {
<span class="fc" id="L1797">        return combinedDescriptors;</span>
    }

    /**
     * get a list of each octave's descriptors as a combined descriptor.
     * The coordinates of the descriptors can be found in getAllKeypoints, but
     * with twice the spacing because that stores row and col in same list.
     * @return
     */
    public static Descriptors combineDescriptors(List&lt;Descriptors&gt; list) {

<span class="nc" id="L1808">        int n = 0;</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">        for (Descriptors dl : list) {</span>
<span class="nc" id="L1810">            n += dl.descriptors.length;</span>
<span class="nc" id="L1811">        }</span>

<span class="nc" id="L1813">        int nPos0 = ORBDescriptorPositions.POS0.length;</span>

<span class="nc" id="L1815">        VeryLongBitString[] combinedD = new VeryLongBitString[n];</span>

<span class="nc" id="L1817">        int count = 0;</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); ++i) {</span>

<span class="nc" id="L1820">            VeryLongBitString[] d = list.get(i).descriptors;</span>

            //TODO: may want to revisit this and use the instance copy methods individually
<span class="nc" id="L1823">            System.arraycopy(d, 0, combinedD, count, d.length);</span>
<span class="nc" id="L1824">            count += d.length;</span>
        }

<span class="nc" id="L1827">        Descriptors combined = new Descriptors();</span>
<span class="nc" id="L1828">        combined.descriptors = combinedD;</span>

<span class="nc" id="L1830">        return combined;</span>
    }
    
    /**
     * combine key-point lists k1 and k2, removing redundancies, then
     * create a combined Descriptors for the combined key-point's descriptors,
     * and a combined orientations list for the same combined key-points.
     * @param d1 descriptors from dataset 1
     * @param k1 key-points from dataset 1
     * @param o1 orientations from dataset 1
     * @param d2 descriptors from dataset 2
     * @param k2 key-points from dataset 2
     * @param o2 orientations from dataset 2
     * 
     * @return a 3-dimensional array holding the combined Descriptors in the
     * first element, the combined key-points in the second element, and the
     * combined orientations in the third element.
     * i.e. new Object[]{combinedDescriptors, combinedKeyPoints} with
     */
    public static Object[] combine(Descriptors d1, List&lt;PairInt&gt; k1, TDoubleList o1,
        Descriptors d2, List&lt;PairInt&gt; k2, TDoubleList o2) {
        
<span class="nc bnc" id="L1852" title="All 2 branches missed.">        if (d1.descriptors.length != k1.size()) {</span>
<span class="nc" id="L1853">            throw new IllegalArgumentException(&quot;d1.descriptors.length and k1.size must be the same&quot;);</span>
        }
<span class="nc bnc" id="L1855" title="All 2 branches missed.">        if (d2.descriptors.length != k2.size()) {</span>
<span class="nc" id="L1856">            throw new IllegalArgumentException(&quot;d2.descriptors.length and k2.size must be the same&quot;);</span>
        }
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if (k1.size() != o1.size()) {</span>
<span class="nc" id="L1859">            throw new IllegalArgumentException(&quot;k1.size and o1.size must be the same&quot;);</span>
        }
<span class="nc bnc" id="L1861" title="All 2 branches missed.">        if (k2.size() != o2.size()) {</span>
<span class="nc" id="L1862">            throw new IllegalArgumentException(&quot;k2.size and o2.size must be the same&quot;);</span>
        }
        
<span class="nc" id="L1865">        int n = k1.size() + k2.size();</span>

<span class="nc" id="L1867">        Set&lt;PairInt&gt; k12 = new HashSet&lt;PairInt&gt;();</span>
                
<span class="nc" id="L1869">        List&lt;PairInt&gt; kCombined = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L1870">        Descriptors dCombined = new Descriptors();</span>
<span class="nc" id="L1871">        dCombined.descriptors = new VeryLongBitString[n];</span>
<span class="nc" id="L1872">        TDoubleList oCombined = new TDoubleArrayList();</span>
        
        PairInt p;
        int idx, j;
<span class="nc bnc" id="L1876" title="All 2 branches missed.">        for (idx = 0; idx &lt; k1.size(); ++idx) {</span>
<span class="nc" id="L1877">            p = k1.get(idx);</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">            if (!k12.contains(p)) {</span>
<span class="nc" id="L1879">                kCombined.add(k1.get(idx));</span>
<span class="nc" id="L1880">                oCombined.add(o1.get(idx));</span>
<span class="nc" id="L1881">                j = k12.size();</span>
<span class="nc" id="L1882">                dCombined.descriptors[j] = d1.descriptors[idx].copy();</span>
<span class="nc" id="L1883">                k12.add(k1.get(idx));</span>
            }
        }    
<span class="nc bnc" id="L1886" title="All 2 branches missed.">        for (idx = 0; idx &lt; k2.size(); ++idx) {</span>
<span class="nc" id="L1887">            p = k2.get(idx);</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">            if (!k12.contains(p)) {</span>
<span class="nc" id="L1889">                kCombined.add(p);</span>
<span class="nc" id="L1890">                oCombined.add(o2.get(idx));</span>
<span class="nc" id="L1891">                j = k12.size();</span>
<span class="nc" id="L1892">                dCombined.descriptors[j] = d2.descriptors[idx].copy();</span>
<span class="nc" id="L1893">                k12.add(p);</span>
            }
        }
        
<span class="nc bnc" id="L1897" title="All 2 branches missed.">        if (k12.size() &lt; n) {</span>
<span class="nc" id="L1898">            dCombined.descriptors = Arrays.copyOf(dCombined.descriptors, k12.size());</span>
        }
        
<span class="nc bnc" id="L1901" title="All 2 branches missed.">        assert(dCombined.descriptors.length == kCombined.size());</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">        assert(kCombined.size() == oCombined.size());</span>
<span class="nc bnc" id="L1903" title="All 2 branches missed.">        assert(kCombined.size() == k12.size());</span>
        
<span class="nc" id="L1905">        return new Object[]{dCombined, kCombined, oCombined};</span>
    }

    /**
     * get a list of each octave's keypoint rows as a combined list.
     * The list contains coordinates which have already been scaled to the
     * full image reference frame.
     * These are the row coordinates of key-points.  (The column coordinates are in keypoints1).
     * @return
     */
    public TIntList getAllKeyPoints0() {

<span class="fc" id="L1917">        TIntList combined = new TIntArrayList(combinedKeypointList.size());</span>
        PairInt p;
<span class="fc bfc" id="L1919" title="All 2 branches covered.">        for (int i = 0; i &lt; combinedKeypointList.size(); ++i) {</span>
<span class="fc" id="L1920">            p = combinedKeypointList.get(i);</span>
<span class="fc" id="L1921">            combined.add(p.getY());</span>
        }

<span class="fc" id="L1924">        return combined;</span>
    }

    /**
     * get a list of the octave's keypoints in format [3 X nKeypoints] where
     * row 0 are the column (== x-axis) indexes, row 1 are the row (== y-axis)
     * indexes, and row 2 are all 1's for the homogeneous coordinate z-axis.
     * All coordinates are with respect to the largest image frame, scales[0],
     * which is also called the first octave.
     * @return keypoints in format [3 X nKeypoints] where
     * row 0 are the column (== x-axis) indexes, row 1 are the row (== y-axis)
     * indexes, and row 2 are all 1's for the homogeneous coordinate z-axis.
     * Note that homogeneous coordinates append a &quot;1&quot; to (x,y,z) coordinates,
     * resulting in a 4-dimensional vactor (x,y,z,1).
     */
    public double[][] getKeyPointsHomogenous(int octave) {
<span class="pc bpc" id="L1940" title="2 of 4 branches missed.">        if (octave &lt; 0 || octave &gt;= scales.length) {</span>
<span class="nc" id="L1941">            throw new IllegalArgumentException(&quot;octave can be 0 to &quot; + (scales.length - 1) + &quot;, inclusive&quot;);</span>
        }
<span class="fc" id="L1943">        TIntList rows = this.keypoints0List.get(octave);</span>
<span class="fc" id="L1944">        TIntList cols = this.keypoints1List.get(octave);</span>
<span class="fc" id="L1945">        int n = rows.size();</span>
<span class="fc" id="L1946">        double[][] x = MatrixUtil.zeros(3, n);</span>
<span class="fc bfc" id="L1947" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1948">            x[0][i] = cols.get(i);</span>
<span class="fc" id="L1949">            x[1][i] = rows.get(i);</span>
        }
<span class="fc" id="L1951">        Arrays.fill(x[2], 1);</span>
<span class="fc" id="L1952">        return x;</span>
    }

    /**
     * get a list of all octave's keypoints in format [3 X nKeypoints] where
     * row 0 are the column (== x-axis) indexes, row 1 are the row (== y-axis)
     * indexes, and row 2 are all 1's for the homogeneous coordinate z-axis.
     * All coordinates are with respect to the largest image frame, scales[0],
     * which is also called the first octave.
     * @return keypoints in format [3 X nKeypoints] where
     * row 0 are the column (== x-axis) indexes, row 1 are the row (== y-axis)
     * indexes, and row 2 are all 1's for the homogeneous coordinate z-axis.
     */
    public double[][] getAllKeyPointsHomogenous() {
        // combined are x,y
<span class="fc" id="L1967">        int n = combinedKeypointList.size();</span>
<span class="fc" id="L1968">        double[][] x = MatrixUtil.zeros(3, n);</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1970">            x[0][i] = combinedKeypointList.get(i).getX();</span>
<span class="fc" id="L1971">            x[1][i] = combinedKeypointList.get(i).getY();</span>
        }
<span class="fc" id="L1973">        Arrays.fill(x[2], 1);</span>
<span class="fc" id="L1974">        return x;</span>
    }
    
    /**
     * get a list of each octave's keypoint cols as a combined list.
     * The list contains coordinates which have already been scaled to the
     * full image reference frame.
     * These are the column coordinates of
     * key-points.  (The row coordinates are in keypoints0).
     * @return
     */
    public TIntList getAllKeyPoints1() {

<span class="fc" id="L1987">        TIntList combined = new TIntArrayList(combinedKeypointList.size());</span>
        PairInt p;
<span class="fc bfc" id="L1989" title="All 2 branches covered.">        for (int i = 0; i &lt; combinedKeypointList.size(); ++i) {</span>
<span class="fc" id="L1990">            p = combinedKeypointList.get(i);</span>
<span class="fc" id="L1991">            combined.add(p.getX());</span>
        }

<span class="fc" id="L1994">        return combined;</span>
    }


    /**
     * get a list of each octave's keypoint rows as a combined list.
     * The list contains coordinates which have already been scaled to the
     * full image reference frame and are in column major format.
     * @return
     */
    public List&lt;PairInt&gt; getAllKeyPoints() {
<span class="fc" id="L2005">        return combinedKeypointList;</span>
    }


    /**
     * get a list of each octave's orientations as a combined list.
     * The corresponding coordinates can be obtained with getAllKeyPoints();
     * @return
     */
    public TDoubleList getAllOrientations() {
<span class="fc" id="L2015">        return combinedOrientationList;</span>
    }

    /**
     * get a list of each octave's harris response strengths as a combined list.
     * The corresponding coordinates can be obtained with getAllKeyPoints();
     * @return
     */
    public TFloatList getAllHarrisResponses() {
<span class="fc" id="L2024">        return combinedHarrisResponseList;</span>
    }

    /**
     * get a list of an octave's keypoints in column major format,
     * that is pairint(x=column, y=row).
     * @return
     */
    public List&lt;PairInt&gt; getKeyPointListColMaj(int octave) {
<span class="nc" id="L2033">        List&lt;PairInt&gt; out = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">        for (int i = 0; i &lt; keypoints0List.get(octave).size(); ++i) {</span>
<span class="nc" id="L2035">            int x = keypoints1List.get(octave).get(i);</span>
<span class="nc" id="L2036">            int y = keypoints0List.get(octave).get(i);</span>
<span class="nc" id="L2037">            out.add(new PairInt(x, y));</span>
        }
<span class="nc" id="L2039">        return out;</span>
    }
    
    /**
     * get a list of an octave's keypoints in pixel indexes,
     * that is pixIdx = (y * imageWidth) + x.
     * @return
     */
    public TIntList getKeyPointListPix(int octave) {
<span class="nc" id="L2048">        int w = this.pyramidImages[octave].a[0].length;</span>
        //(row * width) + col
<span class="nc" id="L2050">        TIntList out = new TIntArrayList();</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        for (int i = 0; i &lt; keypoints0List.get(octave).size(); ++i) {</span>
<span class="nc" id="L2052">            int x = keypoints1List.get(octave).get(i);</span>
<span class="nc" id="L2053">            int y = keypoints0List.get(octave).get(i);</span>
<span class="nc" id="L2054">            int pixIdx = (y * w) + x;</span>
<span class="nc" id="L2055">            out.add(pixIdx);</span>
        }
<span class="nc" id="L2057">        return out;</span>
    }
    
    /**
     * get a list of each octave's keypoint rows in the reference frame
     * of the original full image size.  NOTE that the list
     * is not copied so do not modify.
     * @return
     */
    public List&lt;TIntList&gt; getKeyPoint0List() {
<span class="pc bpc" id="L2067" title="1 of 2 branches missed.">        if (keypoints0List == null) {</span>
            //TODO: consider whether this should be an IllegalStateException
<span class="nc" id="L2069">            System.err.println(&quot;keypoint0List is null.  detectAndExtract() must be run first&quot;);</span>
        }
<span class="fc" id="L2071">        return keypoints0List;</span>
    }

    /**
     * get a list of each octave's keypoint cols in the reference frame
     * of the original full image size.  NOTE that the list
     * is not copied so do not modify.
     * @return
     */
    public List&lt;TIntList&gt; getKeyPoint1List() {
<span class="pc bpc" id="L2081" title="1 of 2 branches missed.">        if (keypoints1List == null) {</span>
            //TODO: consider whether this should be an IllegalStateException
<span class="nc" id="L2083">            System.err.println(&quot;keypoints1List is null.  detectAndExtract() must be run first&quot;);</span>
        }
<span class="fc" id="L2085">        return keypoints1List;</span>
    }

    /**
     * get a list of each octave's orientations.  NOTE that the list
     * is not copied so do not modify.
     * The coordinates of the descriptors can be found in keyPointsList, but
     * with twice the spacing because that stores row and col in same list.
     * @return
     */
    public List&lt;TDoubleList&gt; getOrientationsList() {
<span class="nc" id="L2096">        return orientationsList;</span>
    }

    /**
     * get a list of each octave's scales.  NOTE that the list
     * is not copied so do not modify.
     * @return
     */
    public float[] getScales() {
<span class="fc" id="L2105">        return scales;</span>
    }

    /**
     * get a list of each octave's harris responses.  NOTE that the list
     * is not copied so do not modify.
     * The coordinates of the descriptors can be found in keyPointsList, but
     * with twice the spacing because that stores row and col in same list.
     * @return
     */
    public List&lt;TFloatList&gt; getHarrisResponseList() {
<span class="nc" id="L2116">        return harrisResponses;</span>
    }

    /**
     * calculate a cost matrix composed of the sum of XOR of each descriptor in d1 to d2.
     *
     * @param d1 array of bit vectors wherein 256 bits of the integer are used
     * @param d2 array of bit vectors wherein 256 bits of the integer are used
     * @return matches two dimensional int array of indexes in d1 and
     * d2 which are matched.
     */
    public static int[][] calcDescriptorCostMatrix(
        VeryLongBitString[] d1, VeryLongBitString[] d2) {

<span class="fc" id="L2130">        int n1 = d1.length;</span>
<span class="fc" id="L2131">        int n2 = d2.length;</span>

<span class="fc" id="L2133">        int[][] cost = new int[n1][n2];</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L2135">            cost[i] = new int[n2];</span>
<span class="fc bfc" id="L2136" title="All 2 branches covered.">            for (int j = 0; j &lt; n2; ++j) {</span>
<span class="fc" id="L2137">                cost[i][j] = (int)d1[i].nBitsDifferent(d2[j]);</span>
            }
        }

<span class="fc" id="L2141">        return cost;</span>
    }

    /**
     * calculate a cost matrix composed of the sum of XOR of each descriptor in d1 to d2.
     *
     * @param desc1 two dimensional array with first being keypoint indexes and
     * second dimension being descriptor.
     * @param desc2  two dimensional array with first being keypoint indexes and
     * second dimension being descriptor.
     * @return matches two dimensional int array of indexes in d1 and
     * d2 which are matched.
     */
    public static int[][] calcDescriptorCostMatrix(
        Descriptors[] desc1, Descriptors[] desc2) {

<span class="nc bnc" id="L2157" title="All 2 branches missed.">        assert(desc1.length == desc2.length);</span>

<span class="nc" id="L2159">        int nd = desc1.length;</span>

<span class="nc" id="L2161">        int n1 = desc1[0].descriptors.length;</span>
<span class="nc" id="L2162">        int n2 = desc2[0].descriptors.length;</span>

        // d1 contains multiple descriptors for same points, such as
        // descriptors for H, S, and V

<span class="nc" id="L2167">        int[][] cost = new int[n1][n2];</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc" id="L2169">            cost[i] = new int[n2];</span>
        }

<span class="nc bnc" id="L2172" title="All 2 branches missed.">        for (int k = 0; k &lt; nd; ++k) {</span>
<span class="nc" id="L2173">            VeryLongBitString[] d1 = desc1[k].descriptors;</span>
<span class="nc" id="L2174">            VeryLongBitString[] d2 = desc2[k].descriptors;</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">            assert(d1.length == n1);</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            assert(d2.length == n2);</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">            for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc bnc" id="L2178" title="All 2 branches missed.">                for (int j = 0; j &lt; n2; ++j) {</span>
                    //cost[i][j] += (nbits * nbits); could use sq diff...
<span class="nc" id="L2180">                    cost[i][j] += (int)d1[i].nBitsDifferent(d2[j]);</span>
                }
            }
        }

<span class="nc" id="L2185">        return cost;</span>
    }

    /**
     * create col major image from row major input
     * @param a
     * @return
     */
    public static Image convertToImage(TwoDFloatArray a) {
<span class="nc" id="L2194">        int n1 = a.a.length;</span>
<span class="nc" id="L2195">        int n2 = a.a[0].length;</span>
<span class="nc" id="L2196">        Image img = new Image(n2, n1);</span>
<span class="nc bnc" id="L2197" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">            for (int j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L2199">                float v = 255.f * a.a[i][j];</span>
<span class="nc" id="L2200">                int vInt = Math.round(v);</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">                if (vInt &gt; 255) {</span>
<span class="nc" id="L2202">                    vInt = 255;</span>
                }
<span class="nc" id="L2204">                img.setRGB(j, i, vInt, vInt, vInt);</span>
            }
        }
<span class="nc" id="L2207">        return img;</span>
    }
    
    private void extractATrousKeypoints(TIntList outputKP0, TIntList outputKP1) {
        
<span class="fc" id="L2212">        List&lt;GreyscaleImage&gt; transformed = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="fc" id="L2213">        List&lt;GreyscaleImage&gt; coeffs = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="fc" id="L2215">        ATrousWaveletTransform at = new ATrousWaveletTransform();</span>
<span class="fc" id="L2216">        at.calculateWithB3SplineScalingFunction(img, transformed, coeffs, 2);</span>

<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">        if (coeffs.size() &gt;= 2) {</span>

<span class="fc" id="L2220">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L2221">            float[][] rowMajorImg = imageProcessor.copyToRowMajor(</span>
<span class="fc" id="L2222">                coeffs.get(1));</span>
<span class="fc" id="L2223">            MatrixUtil.multiply(rowMajorImg, 1.f / 255.f);</span>

            // lowering this results in more keypoints
<span class="fc" id="L2226">            float ff = 0.08f;</span>

<span class="fc" id="L2228">            float[][] fastResponse = cornerFast(rowMajorImg, fastN, ff);</span>

<span class="fc" id="L2230">            float f = 0.1f;</span>
<span class="fc" id="L2231">            imageProcessor.peakLocalMax(fastResponse, 1, f, </span>
                true, outputKP0, outputKP1);
            /*
            float factor = 255.f;
            Image img2 = img.createWithDimensions().copyToColorGreyscale();
            for (int i = 0; i &lt; outputKP0.size(); ++i) {
                int x = outputKP1.get(i);
                int y = outputKP0.get(i);
                img2.setRGB(x, y, 255, 0, 0);
            }
            algorithms.misc.MiscDebug.writeImage(img2, &quot;_atrous_&quot; 
                + algorithms.misc.MiscDebug.getCurrentTimeFormatted());
            */
<span class="fc" id="L2244">            log.fine(&quot;  atrous nKeypoints= &quot; + outputKP0.size());</span>
        }
<span class="fc" id="L2246">    }</span>
    
    /**
     * create col major image from row major input
     * @param a
     * @return
     */
    public static GreyscaleImage convertToImageGS(TwoDFloatArray a) {
<span class="nc" id="L2254">        int n1 = a.a.length;</span>
<span class="nc" id="L2255">        int n2 = a.a[0].length;</span>
<span class="nc" id="L2256">        GreyscaleImage img = new GreyscaleImage(n2, n1);</span>
<span class="nc bnc" id="L2257" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">            for (int j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L2259">                float v = 255.f * a.a[i][j];</span>
<span class="nc" id="L2260">                int vInt = Math.round(v);</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">                if (vInt &gt; 255) {</span>
<span class="nc" id="L2262">                    vInt = 255;</span>
                }
<span class="nc" id="L2264">                img.setValue(j, i, vInt);</span>
            }
        }
<span class="nc" id="L2267">        return img;</span>
    }

     /**
     * @return the pyramidImages
     */
    public TwoDFloatArray[] getPyramidImages() {
<span class="nc" id="L2274">        return pyramidImages;</span>
    }

    /**
     * @return the descrChoice
     */
    public DescriptorChoice getDescrChoice() {
<span class="nc" id="L2281">        return descrChoice;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TourHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.mst</a> &gt; <span class="el_source">TourHandler.java</span></div><h1>TourHandler.java</h1><pre class="source lang-java linenums">package algorithms.mst;

import algorithms.MultiArrayMergeSort;
import algorithms.QuickSort;
import algorithms.SubsetChooser;
import algorithms.compGeometry.LinesAndAngles;
import algorithms.search.KNearestNeighbors;
import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.TObjectIntMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TObjectIntHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.Arrays;
import java.util.List;
import thirdparty.edu.princeton.cs.algs4.Interval;
import thirdparty.edu.princeton.cs.algs4.Interval2D;
import thirdparty.edu.princeton.cs.algs4.QuadTreeInterval2D;

/**
 class to handle path sum and edits of
 a tour, used by TSPPrimsMST.
  
 NOTE, the method and class
 are meant for single threaded use only due to
 time and memory saving internal variable use.
 
 @author nichole
 */
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">public class TourHandler {</span>
   
    /**
     * array w/ indexes being the tour order and
     * values being the original graph
     * vertexes.
     * NOTE: not editing last vertex because it
     * it a repeat of the first, unless the
     * first vertex is changed.
    */
    private final int[] tour;
    
    /**
     adjCostMap key = vertex index1, 
     value = map with key = index2 and value = 
     cost for edge index1 to index2. 
    */
    private final TIntObjectMap&lt;TIntIntMap&gt; 
        adjCostMap;
    
    /**
    map with key = vertex indexes, that is the
    values of tour[i] values which are also the indexes
    of the vertexes given as a graph to the TSP class.
    map value = index of tour array.
    */
    private final TIntIntMap tourValueToIndexMap; 
 
    private final PairInt[] coordinates;
    
    private final QuadTreeInterval2D&lt;Integer, PairInt&gt; qt;
        
    // bounding boxes of tour[i] to tour[i+1]
    // stored by keys that are the first value,
    // tour[i] which is the vertex index
    private final TIntObjectMap&lt;Interval2D&lt;Integer&gt;&gt; indexEdgeBounds;
        
    private final TObjectIntMap&lt;Interval2D&lt;Integer&gt;&gt; edgeIndexBounds;
        
<span class="fc" id="L76">    private int pathSum = 0;</span>

    /**
     * reserved as a cache for use in
     * method findNonIntersectingBestSwap
    */
<span class="fc" id="L82">    private final int[] cache0 = new int[3];</span>
<span class="fc" id="L83">    private final int[][] cache1 = new int[6][3];</span>
<span class="fc" id="L84">    private final int[] cache2 = new int[2];</span>
    
<span class="fc" id="L86">    private KNearestNeighbors kNN = null;</span>
    
    /**
     * constructor for tour handler.  Note that theTour
     * is not copied, and is modified by changePaths(). 
     * @param theTour
     * @param theAdjacencyCostMap 
     */
    public TourHandler(int[] theTour, 
        TIntObjectMap&lt;TIntIntMap&gt; theAdjacencyCostMap,
<span class="fc" id="L96">        PairInt[] theCoordinates) {</span>
        
<span class="fc" id="L98">        tour = theTour;</span>
        
<span class="fc" id="L100">        adjCostMap = theAdjacencyCostMap;</span>
        
<span class="fc" id="L102">        tourValueToIndexMap = new TIntIntHashMap();</span>
    
<span class="fc" id="L104">        pathSum = 0;</span>
        
<span class="fc" id="L106">        coordinates = theCoordinates;</span>
        
<span class="fc" id="L108">        qt = new QuadTreeInterval2D&lt;Integer, PairInt&gt;();</span>

<span class="fc" id="L110">        indexEdgeBounds</span>
            = new TIntObjectHashMap&lt;Interval2D&lt;Integer&gt;&gt;();

<span class="fc" id="L113">        edgeIndexBounds</span>
            = new TObjectIntHashMap&lt;Interval2D&lt;Integer&gt;&gt;();

<span class="fc" id="L116">        init();</span>
<span class="fc" id="L117">    }</span>
    
    private void initKNNIfNeeded() {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (kNN != null) {</span>
<span class="nc" id="L121">            return;</span>
        }
        
<span class="nc" id="L124">        int[] xp = new int[coordinates.length];</span>
<span class="nc" id="L125">        int[] yp = new int[coordinates.length];</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        for (int i = 0; i &lt; coordinates.length; ++i) {</span>
<span class="nc" id="L127">            PairInt p = this.coordinates[i];</span>
<span class="nc" id="L128">            xp[i] = p.getX();</span>
<span class="nc" id="L129">            yp[i] = p.getY();</span>
        }
        
<span class="nc" id="L132">        kNN = new KNearestNeighbors(xp, yp);</span>
<span class="nc" id="L133">    }</span>
    
    private void init() {
        
<span class="fc bfc" id="L137" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; ++i) {</span>
<span class="fc" id="L138">            cache1[i] = new int[3];</span>
        }
        
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (int i = 0; i &lt; (tour.length - 1); ++i) {</span>
<span class="fc" id="L142">            int cIdx = tour[i];</span>
<span class="fc" id="L143">            tourValueToIndexMap.put(cIdx, i);</span>
        }
<span class="pc bpc" id="L145" title="3 of 4 branches missed.">        assert(tourValueToIndexMap.size() == tour.length - 1);</span>
        
<span class="fc" id="L147">        pathSum = 0;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        for (int i = 0; i &lt; (tour.length - 1); ++i) {</span>
<span class="fc" id="L149">            int cIdx1 = tour[i];</span>
<span class="fc" id="L150">            int cIdx2 = tour[i + 1];</span>
<span class="fc" id="L151">            int cost = adjCostMap.get(cIdx1).get(cIdx2);</span>
<span class="fc" id="L152">            pathSum += cost;</span>
            
<span class="fc" id="L154">            insertEdgeBox(cIdx1, cIdx2);</span>
        }   
<span class="fc" id="L156">    }</span>
    
    /**
     * given first index n the reference frame of 
     * vertex indexes,
     * find the edges in the tour that it intersects
     * with and return the list of indexes in format
     * edge A vertex 1 index, edge A vertex 2 index,
     * edge B vertex 1 index, edge B vertex 2 index,
     * edge C vertex 1 index, edge C vertex 2 index,
     * etc
     * where edge A is idxEdgeAVertex1 and the 
     * item that follows it in the tour.
     * 
     * @param idxEdgeAVertex1 edge A vertex 1 index,
     * the second edge index is implicitly the one
     * that follows this in the tour array.
     
     * @return the list of indexes in format
     * edge A vertex 1 index, edge A vertex 2 index,
     * edge B vertex 1 index, edge B vertex 2 index,
     * edge C vertex 1 index, edge C vertex 2 index,
     * etc
     * where edge A is idxEdgeAVertex1 and the 
     * item that follows it in the tour.
     */
    public TIntList findIntersectingEdges(
        final int idxEdgeAVertex1) {
        
<span class="fc" id="L185">        int tIdxA1 = getTourIndex(idxEdgeAVertex1);</span>
<span class="fc" id="L186">        int tIdxA2 = getNextTourIndex(tIdxA1);</span>
 
<span class="fc" id="L188">        final int idxEdgeAVertex2 = getVertexIndex(tIdxA2);</span>

<span class="fc" id="L190">        Interval2D&lt;Integer&gt; box12 = </span>
<span class="fc" id="L191">            indexEdgeBounds.get(idxEdgeAVertex1);</span>
<span class="pc bpc" id="L192" title="3 of 4 branches missed.">        assert(box12 != null);</span>
        
        // find intersection boxes and look for 
        // edges that intersect with these
        
<span class="fc" id="L197">        List&lt;Interval2D&lt;Integer&gt;&gt; list = qt.query2D(box12);</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (list.size() &lt; 2) {</span>
<span class="fc" id="L200">            return null;</span>
        }

<span class="fc" id="L203">        int x1 = coordinates[idxEdgeAVertex1].getX();</span>
<span class="fc" id="L204">        int y1 = coordinates[idxEdgeAVertex1].getY();</span>

<span class="fc" id="L206">        int x2 = coordinates[idxEdgeAVertex2].getX();</span>
<span class="fc" id="L207">        int y2 = coordinates[idxEdgeAVertex2].getY();</span>

<span class="fc" id="L209">        TIntList output = new TIntArrayList();</span>
        
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (int listIdx = 0; listIdx &lt; list.size();</span>
<span class="fc" id="L212">            ++listIdx) {</span>

<span class="fc" id="L214">            Interval2D&lt;Integer&gt; box34 = list.get(listIdx);</span>
<span class="pc bpc" id="L215" title="3 of 4 branches missed.">            assert(box34 != null);</span>
            
<span class="fc bfc" id="L217" title="All 2 branches covered.">            if (box34.equals(box12)) {</span>
<span class="fc" id="L218">                continue;</span>
            }

<span class="fc" id="L221">            final int idxEdgeBVertex1 = edgeIndexBounds.get(box34);</span>
<span class="fc" id="L222">            int tIdxB1 = getTourIndex(idxEdgeBVertex1);</span>
<span class="fc" id="L223">            int tIdxB2 = getNextTourIndex(tIdxB1);</span>
<span class="fc" id="L224">            final int idxEdgeBVertex2 = getVertexIndex(tIdxB2);</span>
<span class="pc bpc" id="L225" title="3 of 4 branches missed.">            assert(tour[tIdxB1] == idxEdgeBVertex1);</span>
<span class="pc bpc" id="L226" title="3 of 4 branches missed.">            assert(tour[tIdxB2] == getNextVertexIndex(idxEdgeBVertex1));            </span>
<span class="pc bpc" id="L227" title="3 of 4 branches missed.">            assert(tour[tIdxB2] == idxEdgeBVertex2);</span>
<span class="pc bpc" id="L228" title="3 of 4 branches missed.">            assert(tIdxB1 == getTourIndex(idxEdgeBVertex1));</span>
       
            // vertex disjoint
<span class="pc bpc" id="L231" title="1 of 8 branches missed.">            if ((tIdxA1 == tIdxB1) || (tIdxA1 == tIdxB2) ||</span>
                (tIdxA2 == tIdxB1) || (tIdxA2 == tIdxB2)) {
<span class="nc" id="L233">                continue;</span>
            } 
            
<span class="fc" id="L236">            int x3 = coordinates[idxEdgeBVertex1].getX();</span>
<span class="fc" id="L237">            int y3 = coordinates[idxEdgeBVertex1].getY();</span>

<span class="fc" id="L239">            int x4 = coordinates[idxEdgeBVertex2].getX();</span>
<span class="fc" id="L240">            int y4 = coordinates[idxEdgeBVertex2].getY();</span>

            // determine if p12 p34 intersect
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (!LinesAndAngles.linesIntersect(</span>
                x1, y1, x2, y2, x3, y3, x4, y4)) {
<span class="fc" id="L245">                continue;</span>
            }
            
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (output.size() == 0) {</span>
<span class="fc" id="L249">                output.add(idxEdgeAVertex1);</span>
<span class="fc" id="L250">                output.add(idxEdgeAVertex2);</span>
            }
<span class="fc" id="L252">            output.add(idxEdgeBVertex1);</span>
<span class="fc" id="L253">            output.add(idxEdgeBVertex2);</span>

        }
        
<span class="fc" id="L257">        return output;</span>
    }
    
    //TODO: revisit this algorithm using the edge flipping pattern from one method of
    // building Delaunay triangles... any 4 points under consideration for flipping should
    // be convex and in counter clockwise order.
    // also, can use a fast inCircle method:
    //  when det is positive d is within circumcircle abc.  when det==0, all are cocircular
    //                     det = | a_x   a_y  a_x^2 + a_y^2   1
    //                           | b_x   b_y  b_x^2 + b_y^2   1
    //                           | c_x   c_y  c_x^2 + c_y^2   1
    //                           | d_x   d_y  d_x^2 + d_y^2   1
    //
    public void modifyTourIntersectingEdges() {
 
        //TODO: revise nMaxIter
<span class="fc" id="L273">        int nIter = 0;</span>
<span class="fc" id="L274">        int nMaxIter = Math.round(0.8f * coordinates.length);</span>
<span class="fc" id="L275">        int nChanged = 0;</span>
         
        do {
            
<span class="fc" id="L279">            nChanged = 0;</span>
         
            /*
            storing best params for two different types of changes:
            - swapping 2 edges between 4 vertexes
            - reversing a single edge
            
            Only if no best among swapping 2 edges is found is
            the reversal of the single edge applied.
            (NOTE: may change that when testing begins to apply
            the best of either.)
            */
            // 2 edge swap:
<span class="fc" id="L292">            int bestVertexIdxA_1 = -1;</span>
<span class="fc" id="L293">            int bestVertexIdxB_1 = -1;</span>
<span class="fc" id="L294">            int[] bestVertexIdxs1_1 = new int[4];</span>
<span class="fc" id="L295">            int minPathSum_1 = pathSum;</span>

            // single edge reversal:
<span class="fc" id="L298">            int bestVertexIdxA1_2 = -1;</span>
<span class="fc" id="L299">            int minPathSum_2 = pathSum;</span>
            
            //vertex indexes returned for min path sum
<span class="fc" id="L302">            int[] tmp = new int[4]; </span>
<span class="fc" id="L303">            int[] tmpMin2 = new int[4];</span>
            
<span class="fc bfc" id="L305" title="All 2 branches covered.">            for (int cIdx1 = 0; cIdx1 &lt; coordinates.length;</span>
<span class="fc" id="L306">                ++cIdx1) {</span>
                 
<span class="fc" id="L308">                TIntList interIndexes</span>
<span class="fc" id="L309">                    = findIntersectingEdges(cIdx1);</span>
                
<span class="fc bfc" id="L311" title="All 4 branches covered.">                if (interIndexes == null || interIndexes.isEmpty()) {</span>
<span class="fc" id="L312">                    continue;</span>
                }
                        
<span class="fc" id="L315">                final int idxEdgeAVertex1 = interIndexes.get(0);</span>
<span class="fc" id="L316">                final int idxEdgeAVertex2 = interIndexes.get(1);</span>
                
<span class="fc" id="L318">                final int tIdxA1 = getTourIndex(idxEdgeAVertex1);</span>
<span class="fc" id="L319">                final int tIdxA2 = getTourIndex(idxEdgeAVertex2);</span>
 
                //vertex indexes returned for min path sum
<span class="fc" id="L322">                int minSum = minPathSum_1;</span>
<span class="fc" id="L323">                int minSumEdgeBVertex1 = -1;</span>
          
                
<span class="fc bfc" id="L326" title="All 2 branches covered.">                for (int listIdx = 2; listIdx &lt; interIndexes.size();</span>
<span class="fc" id="L327">                    listIdx+=2) {</span>

<span class="fc" id="L329">                    final int idxEdgeBVertex1 = interIndexes.get(listIdx);</span>
<span class="fc" id="L330">                    final int idxEdgeBVertex2 = interIndexes.get(listIdx + 1);</span>
<span class="fc" id="L331">                    int tIdxB1 = getTourIndex(idxEdgeBVertex1);</span>
<span class="fc" id="L332">                    int tIdxB2 = getTourIndex(idxEdgeBVertex2);</span>

<span class="pc bpc" id="L334" title="3 of 4 branches missed.">                    assert (tour[tIdxB1] == idxEdgeBVertex1);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                    assert (tour[tIdxB2] </span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                        == getNextVertexIndex(idxEdgeBVertex1));</span>
<span class="pc bpc" id="L337" title="3 of 4 branches missed.">                    assert (tour[tIdxB2] == idxEdgeBVertex2);</span>
<span class="pc bpc" id="L338" title="3 of 4 branches missed.">                    assert (tIdxB1 == getTourIndex(idxEdgeBVertex1));</span>
                    
<span class="fc" id="L340">                    int sum = findMinValidBestSwap(</span>
                        idxEdgeAVertex1, idxEdgeAVertex2,
                        idxEdgeBVertex1, idxEdgeBVertex2, tmp);

<span class="fc bfc" id="L344" title="All 2 branches covered.">                    if (sum &lt; minSum) {</span>
<span class="fc" id="L345">                        minSum = sum;</span>
                        // tmp are graph vertex indexes
<span class="fc" id="L347">                        System.arraycopy(tmp, 0, tmpMin2, </span>
                            0, tmp.length);
<span class="fc" id="L349">                        minSumEdgeBVertex1 = idxEdgeBVertex1;</span>
                    }
                }
<span class="fc bfc" id="L352" title="All 2 branches covered.">                if (minSum &lt; minPathSum_1) {</span>
                    // update best params for 2 edge swap
                    
<span class="fc" id="L355">                    minPathSum_1 = minSum;</span>
<span class="fc" id="L356">                    bestVertexIdxA_1 = cIdx1;</span>
<span class="fc" id="L357">                    bestVertexIdxB_1 = minSumEdgeBVertex1;</span>
<span class="fc" id="L358">                    System.arraycopy(tmpMin2, </span>
                        0, bestVertexIdxs1_1, 0, tmpMin2.length);
                
<span class="fc" id="L361">                    continue;</span>
                }
                
                // else, there were intersecting edges, but no 
                // combination of uncrossing for this edge 
                // improved the path,
                // so test whether reversing the edge does
                
<span class="fc" id="L369">                int tIdxPrevA1 = getPrevTourIndex(tIdxA1);</span>
<span class="fc" id="L370">                int tIdxNextA2 = getNextTourIndex(tIdxA2);</span>

<span class="fc" id="L372">                int sum = peekSumPathChangesReverseEdge(tIdxPrevA1,</span>
                    tIdxA1, tIdxA2, tIdxNextA2);
<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (sum &lt; minPathSum_2) {</span>
<span class="fc" id="L375">                    minPathSum_2 = sum;</span>
<span class="fc" id="L376">                    bestVertexIdxA1_2 = idxEdgeAVertex1;</span>
                }
            }// end cIdx1 loop which is over graph vertex indexes
            
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (minPathSum_1 &lt; pathSum) {</span>
                // apply the 2 edge swap
<span class="fc" id="L382">                int sum = changePaths(</span>
                    bestVertexIdxA_1, bestVertexIdxB_1, 
                    bestVertexIdxs1_1);
<span class="fc" id="L385">                System.out.println(&quot;nIter=&quot; + nIter </span>
                    + &quot; sum=&quot; + sum + &quot; min=&quot; + minPathSum_1);
<span class="pc bpc" id="L387" title="3 of 4 branches missed.">                assert(sum == minPathSum_1);</span>
<span class="fc" id="L388">                nChanged++;</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            } else if (minPathSum_2 &lt; pathSum) {</span>
                // apply reversal of edge 1
<span class="nc" id="L391">                int sum = changePathsToReverseEdge(</span>
<span class="nc" id="L392">                    getVertexIndex(bestVertexIdxA1_2));</span>
<span class="nc" id="L393">                System.out.println(&quot;nIter=&quot; + nIter </span>
                    + &quot; sum=&quot; + sum + &quot; min=&quot; + minPathSum_2);
<span class="nc bnc" id="L395" title="All 4 branches missed.">                assert(sum == minPathSum_1);</span>
<span class="nc" id="L396">                nChanged++;</span>
            }
            
<span class="fc" id="L399">            nIter++;</span>
            
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">        } while ((nChanged != 0) &amp;&amp; (nIter &lt; nMaxIter));</span>
        
<span class="fc" id="L403">    }</span>
    
    /**
     * given first indexes of edge1 and edge2 in tour but
     * in the reference frame of vertex indexes, 
     * find which swap among the 2 pairs
     * produces the shortest path and return the pathSum
     * and populate outputIndexes with the suggested 
     * swap indexes.  NOTE, the method and class
     * are meant for single threaded use only - there
     * are reserved cache variables used without 
     * synchronization or mutexes.
     * @param idxEdgeAVertex1 edge A vertex 1 index,
     * the second edge index is implicitly the one
     * that follows this in the tour array.
     * @param idxEdgeAVertex2 edge A vertex 3 index,
     * the second edge index that follows 
     * idxEdgeAVertex1 in the tour array.
     * @param idxEdgeBVertex1 edge B vertex 1 index,
     * the second edge index is implicitly the one
     * that follows this in the tour array.
     * @param idxEdgeBVertex2 edge B vertex 3 index,
     * the second edge index that follows 
     * idxEdgeBVertex1 in the tour array.
     * @param outputVertexIdxs array of size 4
     * holding the combination of vertexes that result
     * in best path sum.
     * @return best path sum for a combination of swapping
     * edge vertexes between the 2 edges given else -1
     * if a better combination than current was not found.
     */
    protected int findMinValidBestSwap(
        int idxEdgeAVertex1, int idxEdgeAVertex2,
        final int idxEdgeBVertex1, final int idxEdgeBVertex2,
        int[] outputVertexIdxs) {

<span class="pc bpc" id="L439" title="3 of 4 branches missed.">        assert(outputVertexIdxs.length == 4);</span>
        
<span class="fc" id="L441">        int tIdxA1 = getTourIndex(idxEdgeAVertex1);</span>
<span class="fc" id="L442">        int tIdxA2 = getTourIndex(idxEdgeAVertex2);</span>
<span class="pc bpc" id="L443" title="3 of 4 branches missed.">        assert(tIdxA2 == getNextTourIndex(tIdxA1));</span>
<span class="fc" id="L444">        int tIdxPrevA1 = getPrevTourIndex(tIdxA1);</span>
<span class="fc" id="L445">        int tIdxNextA2 = getNextTourIndex(tIdxA2);</span>

<span class="fc" id="L447">        int tIdxB1 = getTourIndex(idxEdgeBVertex1);</span>
<span class="fc" id="L448">        int tIdxB2 = getTourIndex(idxEdgeBVertex2);</span>

<span class="pc bpc" id="L450" title="3 of 4 branches missed.">        assert(tIdxB2 == getNextTourIndex(tIdxB1));</span>
<span class="fc" id="L451">        int tIdxPrevB1 = getPrevTourIndex(tIdxB1);</span>
<span class="fc" id="L452">        int tIdxNextB2 = getNextTourIndex(tIdxB2);</span>

<span class="fc" id="L454">        int minSum = pathSum;</span>

        // fixing first integer and permuting the other 3
<span class="fc" id="L457">        cache0[0] = tIdxA2;</span>
<span class="fc" id="L458">        cache0[1] = tIdxB1;</span>
<span class="fc" id="L459">        cache0[2] = tIdxB2;</span>
        
<span class="fc" id="L461">        cache2[0] = 0;</span>
<span class="fc" id="L462">        permutation(cache0, cache1, 3, cache2);</span>
        
<span class="fc bfc" id="L464" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; ++i) {</span>

<span class="pc bpc" id="L466" title="1 of 6 branches missed.">            if ((tIdxA2 == cache1[i][0]) &amp;&amp;</span>
            (tIdxB1 == cache1[i][1]) &amp;&amp;
            (tIdxB2 == cache1[i][2])) {
<span class="fc" id="L469">                continue;</span>
            }
            
<span class="fc" id="L472">            boolean isValid = validateEdges(tIdxPrevA1,</span>
                tIdxNextA2, tIdxPrevB1, tIdxNextB2,
                tIdxA1, cache1[i][0], cache1[i][1], cache1[i][2]);

<span class="fc bfc" id="L476" title="All 2 branches covered.">            if (!isValid) {</span>
<span class="fc" id="L477">                continue;</span>
            }
            
<span class="fc" id="L480">            int sum = peekSumPathChanges(tIdxPrevA1,</span>
                tIdxA1, tIdxA2, tIdxNextA2,
                tIdxPrevB1, tIdxB1, tIdxB2, tIdxNextB2,
                tIdxA1, cache1[i][0], cache1[i][1], cache1[i][2]);          
            
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (sum &lt; minSum) {</span>
                
<span class="fc" id="L487">                minSum = sum;</span>
                
                // outputVertexIdxs is graph vertex indexes
                // instead of tour indexes.
                // cache1[i] are tour indexes.
                
<span class="fc" id="L493">                outputVertexIdxs[0] = getVertexIndex(tIdxA1);</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                for (int j = 0; j &lt; cache1[i].length; ++j) {</span>
<span class="fc" id="L495">                    outputVertexIdxs[j + 1] = </span>
<span class="fc" id="L496">                        getVertexIndex(cache1[i][j]);</span>
                }

<span class="pc bpc" id="L499" title="3 of 4 branches missed.">assert(assertSameSets(</span>
<span class="nc" id="L500"> getVertexIndex(tIdxA1), </span>
<span class="nc" id="L501"> getVertexIndex(tIdxA2), </span>
<span class="nc" id="L502"> getVertexIndex(tIdxB1), </span>
<span class="nc" id="L503"> getVertexIndex(tIdxB2),</span>
 outputVertexIdxs[0], 
 outputVertexIdxs[1], 
 outputVertexIdxs[2],
 outputVertexIdxs[3]));
<span class="pc bpc" id="L508" title="3 of 4 branches missed."> assert(assertSameSets(</span>
 tIdxA1, tIdxA2, tIdxB1, tIdxB2,
<span class="nc" id="L510"> getTourIndex(outputVertexIdxs[0]), </span>
<span class="nc" id="L511"> getTourIndex(outputVertexIdxs[1]), </span>
<span class="nc" id="L512"> getTourIndex(outputVertexIdxs[2]),</span>
<span class="nc" id="L513"> getTourIndex(outputVertexIdxs[3])));</span>
 
            }
        }
        
<span class="fc bfc" id="L518" title="All 2 branches covered.">        return (minSum == pathSum) ? Integer.MAX_VALUE : minSum;</span>
    }

    void permutation(int a[], int[][] out, int size, int[] count) {
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (size == 1) {</span>
<span class="fc" id="L523">            System.arraycopy(a, 0, out[count[0]], 0, a.length);</span>
<span class="fc" id="L524">            count[0]++;</span>
<span class="fc" id="L525">            return;</span>
        }
<span class="fc bfc" id="L527" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L528">            permutation(a, out, size - 1, count);</span>
<span class="fc" id="L529">            int swap = a[size - 1];</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if ((size &amp; 1) == 1) {</span>
<span class="fc" id="L531">                a[size - 1] = a[0];</span>
<span class="fc" id="L532">                a[0] = swap;</span>
            } else {
<span class="fc" id="L534">                a[size - 1] = a[i];</span>
<span class="fc" id="L535">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L538">    }</span>
    
    /**
     * given the vertex index from the original graph,
     * return the vertex index the follows it in the
     * tour.
     * @param vertexIdx
     * @return 
     */
    public int getNextVertexIndex(int vertexIdx) {
<span class="fc" id="L548">        int tIdx = getTourIndex(vertexIdx);</span>
<span class="fc" id="L549">        return tour[getNextTourIndex(tIdx)];</span>
    }
    
    /**
     * given the vertex index from the original graph,
     * return the vertex index the precedes it in the
     * tour.
     * @param vertexIdx
     * @return 
     */
    public int getPrevVertexIndex(int vertexIdx) {
<span class="fc" id="L560">        int tIdx = getTourIndex(vertexIdx);</span>
<span class="fc" id="L561">        return tour[getPrevTourIndex(tIdx)];</span>
    }
    
    private int getNextTourIndex(int tIdx) {
        // last index is same as first.  always
        // return first index.
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (tIdx == (tour.length - 2)) {</span>
<span class="fc" id="L568">            return 0;</span>
        }
<span class="fc" id="L570">        return tIdx + 1;</span>
    }
    
    private int getPrevTourIndex(int tIdx) {
        // last index is same as first.  always
        // return first index.
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (tIdx == 0) {</span>
<span class="fc" id="L577">            return tour.length - 2;</span>
        }
<span class="fc" id="L579">        return tIdx - 1;</span>
    }
    
    /**
     * given tour indexes A1, A2, B1, B2 and the
     * vertexes to change those to, calculate what
     * the path sum would be with those changes,
     * but do not apply the changes.
     * The tour indexes before and after edgeA and 
     * edgeB are passed in to avoid recalculating.
     * The invoking method has the responsibility of 
     * passing valid arguments to this method.
     @param tIdxPrevA1 is the tour index before that
     * containing vertexIdxs0[0].
     @param tIdxA1 tour index for first point of edgeA
     @param tIdxA2 tour index for last point of edgeA
     @param tIdxNextA2 is the tour index after that
       containing vertexIdxs0[1]
     @param tIdxPrevB1 is the tour index before that
     * containing vertexIdxs0[2]
     @param tIdxB1 tour index for first point of edgeB
     @param tIdxB2 tour index for last point of edgeB
     @param tIdxNextB2 is the tour index after that
       containing vertexIdxs0[3]
     @param tIdx1 candidate change edge A vertex1 tour index
     @param tIdx2 candidate change edge A vertex2 tour index
     @param tIdx3 candidate change edge B vertex1 tour index
     @param tIdx4 candidate change edge B vertex2 tour index
     * @return the calculated path sum for the path
     * changed from vertexes vertexIdxs0 to vertexIdxs1.
     */
    protected int peekSumPathChanges(int tIdxPrevA1,
        int tIdxA1, int tIdxA2, int tIdxNextA2, 
        int tIdxPrevB1, int tIdxB1, int tIdxB2, int tIdxNextB2,
        int tIdx1, int tIdx2, int tIdx3, int tIdx4) {
        
<span class="fc" id="L615">        int sum = pathSum;</span>
        
<span class="fc" id="L617">        int a1 = adjCostMap.get(getVertexIndex(tIdxPrevA1))</span>
<span class="fc" id="L618">            .get(getVertexIndex(tIdxA1));</span>
<span class="fc" id="L619">        int a2 = adjCostMap.get(getVertexIndex(tIdxA1))</span>
<span class="fc" id="L620">            .get(getVertexIndex(tIdxA2));</span>
<span class="fc" id="L621">        int a3 = adjCostMap.get(getVertexIndex(tIdxA2))</span>
<span class="fc" id="L622">            .get(getVertexIndex(tIdxNextA2));</span>
        
<span class="fc" id="L624">        int minusA = a1 + a2 + a3;</span>
         
<span class="fc" id="L626">        int b1 = adjCostMap.get(getVertexIndex(tIdxPrevB1))</span>
<span class="fc" id="L627">            .get(getVertexIndex(tIdxB1));</span>
<span class="fc" id="L628">        int b2 = adjCostMap.get(getVertexIndex(tIdxB1))</span>
<span class="fc" id="L629">            .get(getVertexIndex(tIdxB2));</span>
<span class="fc" id="L630">        int b3 = adjCostMap.get(getVertexIndex(tIdxB2))</span>
<span class="fc" id="L631">            .get(getVertexIndex(tIdxNextB2));</span>
        
<span class="fc" id="L633">        int minusB = b1 + b2 + b3;</span>
        
<span class="fc" id="L635">        int plusA1 = adjCostMap.get(getVertexIndex(tIdxPrevA1))</span>
<span class="fc" id="L636">            .get(getVertexIndex(tIdx1));</span>
<span class="fc" id="L637">        int plusA2 = adjCostMap.get(getVertexIndex(tIdx1))</span>
<span class="fc" id="L638">            .get(getVertexIndex(tIdx2));</span>
<span class="fc" id="L639">        int plusA3 = adjCostMap.get(getVertexIndex(tIdx2))</span>
<span class="fc" id="L640">            .get(getVertexIndex(tIdxNextA2));</span>
        
<span class="fc" id="L642">        int plusA = plusA1 + plusA2 + plusA3;</span>
        
<span class="fc" id="L644">        int plusB1 = adjCostMap.get(getVertexIndex(tIdxPrevB1))</span>
<span class="fc" id="L645">            .get(getVertexIndex(tIdx3));</span>
<span class="fc" id="L646">        int plusB2 = adjCostMap.get(getVertexIndex(tIdx3))</span>
<span class="fc" id="L647">            .get(getVertexIndex(tIdx4));</span>
<span class="fc" id="L648">        int plusB3 = adjCostMap.get(getVertexIndex(tIdx4))</span>
<span class="fc" id="L649">            .get(getVertexIndex(tIdxNextB2));</span>
        
<span class="fc" id="L651">        int plusB = plusB1 + plusB2 + plusB3;</span>
        
<span class="fc" id="L653">        sum -= minusA;</span>
<span class="fc" id="L654">        sum -= minusB;</span>
<span class="fc" id="L655">        sum += plusA;</span>
<span class="fc" id="L656">        sum += plusB;</span>
        
<span class="fc" id="L658">        return sum;</span>
    }
    
    /**
     * given tour indexes A1, A2, B1, B2 and the
     * vertexes to change those to, calculate what
     * the path sum would be with those changes,
     * but do not apply the changes.
     * The tour indexes before and after edgeA and 
     * edgeB are passed in to avoid recalculating.
     * The invoking method has the responsibility of 
     * passing valid arguments to this method.
     @param tIdxPrevA1 is the tour index before that
     * containing vertexIdxs0[0].
     @param tIdxA1 tour index for first point of edgeA
     @param tIdxA2 tour index for last point of edgeA
     @param tIdxNextA2 is the tour index after that
       containing vertexIdxs0[1]
     
     * @return the calculated path sum for the path
     * changed from vertexes vertexIdxs0 to vertexIdxs1.
     */
    protected int peekSumPathChangesReverseEdge(int tIdxPrevA1,
        int tIdxA1, int tIdxA2, int tIdxNextA2) {
        
<span class="fc" id="L683">        int sum = pathSum;</span>
        
<span class="fc" id="L685">        int a1 = adjCostMap.get(getVertexIndex(tIdxPrevA1))</span>
<span class="fc" id="L686">            .get(getVertexIndex(tIdxA1));</span>
<span class="fc" id="L687">        int a2 = adjCostMap.get(getVertexIndex(tIdxA1))</span>
<span class="fc" id="L688">            .get(getVertexIndex(tIdxA2));</span>
<span class="fc" id="L689">        int a3 = adjCostMap.get(getVertexIndex(tIdxA2))</span>
<span class="fc" id="L690">            .get(getVertexIndex(tIdxNextA2));</span>
        
<span class="fc" id="L692">        int minusA = a1 + a2 + a3;</span>
                
<span class="fc" id="L694">        int plusA1 = adjCostMap.get(getVertexIndex(tIdxPrevA1))</span>
<span class="fc" id="L695">            .get(getVertexIndex(tIdxA2));</span>
<span class="fc" id="L696">        int plusA2 = adjCostMap.get(getVertexIndex(tIdxA2))</span>
<span class="fc" id="L697">            .get(getVertexIndex(tIdxA1));</span>
<span class="fc" id="L698">        int plusA3 = adjCostMap.get(getVertexIndex(tIdxA1))</span>
<span class="fc" id="L699">            .get(getVertexIndex(tIdxNextA2));</span>
        
<span class="fc" id="L701">        int plusA = plusA1 + plusA2 + plusA3;</span>
                
<span class="fc" id="L703">        sum -= minusA;</span>
<span class="fc" id="L704">        sum += plusA;</span>
        
<span class="fc" id="L706">        return sum;</span>
    }
    
    private void removeEdgeBoxes(int tIdxPrev1, int tIdx1, 
        int tIdx2, int tIdxNext2) {

<span class="fc" id="L712">        int cIdxPrev1 = getVertexIndex(tIdxPrev1);</span>
<span class="fc" id="L713">        int cIdx1 = getVertexIndex(tIdx1);</span>
<span class="fc" id="L714">        int cIdx2 = getVertexIndex(tIdx2);</span>
             
        Interval2D&lt;Integer&gt; box;
        
<span class="fc" id="L718">        box = indexEdgeBounds.remove(cIdxPrev1);</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (box != null) {</span>
<span class="fc" id="L720">            edgeIndexBounds.remove(box);</span>
<span class="fc" id="L721">            qt.remove(box);</span>
        }

<span class="fc" id="L724">        box = indexEdgeBounds.remove(cIdx1);</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (box != null) {</span>
<span class="fc" id="L726">            edgeIndexBounds.remove(box);</span>
<span class="fc" id="L727">            qt.remove(box);</span>
        }
        
<span class="fc" id="L730">        box = indexEdgeBounds.remove(cIdx2);</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (box != null) {</span>
<span class="fc" id="L732">            edgeIndexBounds.remove(box);</span>
<span class="fc" id="L733">            qt.remove(box);</span>
        }
<span class="fc" id="L735">    }</span>
    
    private void removeEdgeBox(int idxVertex) {
    
        Interval2D&lt;Integer&gt; box;
        
<span class="nc" id="L741">        box = indexEdgeBounds.remove(idxVertex);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (box != null) {</span>
<span class="nc" id="L743">            edgeIndexBounds.remove(box);</span>
<span class="nc" id="L744">            qt.remove(box);</span>
        }
<span class="nc" id="L746">    }</span>
    
    private void insertEdgeBox(int idxEdgeVertex1,
        int idxEdgeVertex2) {

        Interval2D&lt;Integer&gt; box;
        int x1, y1, x2, y2;
        Interval&lt;Integer&gt; xi1, yi1;
        PairInt desc;
        
<span class="fc" id="L756">        x1 = coordinates[idxEdgeVertex1].getX();</span>
<span class="fc" id="L757">        y1 = coordinates[idxEdgeVertex1].getY();</span>
<span class="fc" id="L758">        x2 = coordinates[idxEdgeVertex2].getX();</span>
<span class="fc" id="L759">        y2 = coordinates[idxEdgeVertex2].getY();</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (x1 &lt;= x2) {</span>
<span class="fc" id="L761">            xi1 = new Interval&lt;Integer&gt;(x1, x2);</span>
        } else  {
<span class="fc" id="L763">            xi1 = new Interval&lt;Integer&gt;(x2, x1);</span>
        }
<span class="fc bfc" id="L765" title="All 2 branches covered.">        if (y1 &lt;= y2) {</span>
<span class="fc" id="L766">            yi1 = new Interval&lt;Integer&gt;(y1, y2);</span>
        } else {
<span class="fc" id="L768">            yi1 = new Interval&lt;Integer&gt;(y2, y1);</span>
        }
<span class="fc" id="L770">        box = new Interval2D&lt;Integer&gt;(xi1, yi1);</span>
<span class="fc" id="L771">        desc = new PairInt(idxEdgeVertex1, idxEdgeVertex2);</span>
<span class="fc" id="L772">        qt.insert(box, desc);</span>
<span class="fc" id="L773">        edgeIndexBounds.put(box, idxEdgeVertex1);</span>
<span class="fc" id="L774">        indexEdgeBounds.put(idxEdgeVertex1, box);</span>
        
<span class="fc" id="L776">    }</span>
    
    private void insertEdgeBoxes(int idxEdgeVertex1,
        int idxEdgeVertex2,
        int idxEdgePrevVertex1, int idxEdgeNextVertex2) {

<span class="fc" id="L782">        int cIdx1 = idxEdgeVertex1;</span>
<span class="fc" id="L783">        int cIdx2 = idxEdgeVertex2;</span>
<span class="fc" id="L784">        int cIdxPrev1 = idxEdgePrevVertex1;</span>
<span class="fc" id="L785">        int cIdxNext2 = idxEdgeNextVertex2;</span>

<span class="fc" id="L787">        insertEdgeBox(cIdxPrev1, cIdx1);</span>
<span class="fc" id="L788">        insertEdgeBox(cIdx1, cIdx2);</span>
<span class="fc" id="L789">        insertEdgeBox(cIdx2, cIdxNext2);</span>
<span class="fc" id="L790">    }</span>
    
    /**
     * given tour values (which are the original graph
     * vertexes), change to vertexIdxs1 and return the
     * updated pathSum.
     @param idxEdgeAVertex1 edge A vertex 1 index,
     * the second edge index is implicitly the one
     * that follows this in the tour array.
     @param idxEdgeBVertex1 edge B vertex 1 index,
     * the second edge index is implicitly the one
     * that follows this in the tour array.
     @param vertexIdxs the vertexes to change edge A
     * and edge B to in thr tour
     @return the updated path sum after the changes
     * are applied.
    */
    public int changePaths(int idxEdgeAVertex1, 
        int idxEdgeBVertex1, int[] vertexIdxs) {
    
<span class="fc" id="L810">        int tIdxA1 = getTourIndex(idxEdgeAVertex1);</span>
<span class="fc" id="L811">        int tIdxA2 = getNextTourIndex(tIdxA1);</span>
<span class="fc" id="L812">        int tIdxPrevA1 = getPrevTourIndex(tIdxA1);</span>
<span class="fc" id="L813">        int tIdxNextA2 = getNextTourIndex(tIdxA2);</span>
            
<span class="fc" id="L815">        int tIdxB1 = getTourIndex(idxEdgeBVertex1);</span>
<span class="fc" id="L816">        int tIdxB2 = getNextTourIndex(tIdxB1);</span>
<span class="fc" id="L817">        int tIdxPrevB1 = getPrevTourIndex(tIdxB1);</span>
<span class="fc" id="L818">        int tIdxNextB2 = getNextTourIndex(tIdxB2);</span>
        
        // ---- update the edge bounding boxes -----
<span class="fc" id="L821">        removeEdgeBoxes(tIdxPrevA1, tIdxA1, tIdxA2, </span>
            tIdxNextA2);
<span class="fc" id="L823">        removeEdgeBoxes(tIdxPrevB1, tIdxB1, tIdxB2, </span>
            tIdxNextB2);
        
<span class="fc" id="L826">        insertEdgeBoxes(vertexIdxs[0], vertexIdxs[1],</span>
<span class="fc" id="L827">            getVertexIndex(tIdxPrevA1), </span>
<span class="fc" id="L828">            getVertexIndex(tIdxNextA2));</span>
<span class="fc" id="L829">        insertEdgeBoxes(vertexIdxs[2], vertexIdxs[3],</span>
<span class="fc" id="L830">            getVertexIndex(tIdxPrevB1), </span>
<span class="fc" id="L831">            getVertexIndex(tIdxNextB2));</span>
        
        // ---- update the tour -----
    
<span class="fc" id="L835">        pathSum = peekSumPathChanges(tIdxPrevA1,</span>
            tIdxA1, tIdxA2, tIdxNextA2, 
            tIdxPrevB1, tIdxB1, tIdxB2, tIdxNextB2, 
<span class="fc" id="L838">            getTourIndex(vertexIdxs[0]), </span>
<span class="fc" id="L839">            getTourIndex(vertexIdxs[1]), </span>
<span class="fc" id="L840">            getTourIndex(vertexIdxs[2]),</span>
<span class="fc" id="L841">            getTourIndex(vertexIdxs[3]));</span>
 
<span class="pc bpc" id="L843" title="3 of 4 branches missed.">assert(assertSameSets(</span>
<span class="nc" id="L844"> getVertexIndex(tIdxA1), </span>
<span class="nc" id="L845"> getVertexIndex(tIdxA2), </span>
<span class="nc" id="L846"> getVertexIndex(tIdxB1),</span>
<span class="nc" id="L847"> getVertexIndex(tIdxB2),</span>
 vertexIdxs[0], 
 vertexIdxs[1], 
 vertexIdxs[2],
 vertexIdxs[3]));
<span class="pc bpc" id="L852" title="3 of 4 branches missed."> assert(assertSameSets(</span>
 tIdxA1, tIdxA2, tIdxB1, tIdxB2,
<span class="nc" id="L854"> getTourIndex(vertexIdxs[0]), </span>
<span class="nc" id="L855"> getTourIndex(vertexIdxs[1]), </span>
<span class="nc" id="L856"> getTourIndex(vertexIdxs[2]),</span>
<span class="nc" id="L857"> getTourIndex(vertexIdxs[3])));</span>
 
<span class="pc bpc" id="L859" title="3 of 4 branches missed."> assert(assertTourData());</span>
<span class="fc" id="L860"> System.out.println(String.format(&quot;change tour[%d] = %d to %d&quot;, </span>
<span class="fc" id="L861"> tIdxA1, tour[tIdxA1], vertexIdxs[0]));</span>
<span class="fc" id="L862"> System.out.println(String.format(&quot;change tour[%d] = %d to %d&quot;, </span>
<span class="fc" id="L863"> tIdxA2, tour[tIdxA2], vertexIdxs[1]));</span>
<span class="fc" id="L864"> System.out.println(String.format(&quot;change tour[%d] = %d to %d&quot;, </span>
<span class="fc" id="L865"> tIdxB1, tour[tIdxB1], vertexIdxs[2]));</span>
<span class="fc" id="L866"> System.out.println(String.format(&quot;change tour[%d] = %d to %d&quot;, </span>
<span class="fc" id="L867"> tIdxB2, tour[tIdxB2], vertexIdxs[3]));</span>
 
<span class="fc" id="L869">        tour[tIdxA1] = vertexIdxs[0];</span>
<span class="fc" id="L870">        tour[tIdxA2] = vertexIdxs[1];</span>
<span class="fc" id="L871">        tour[tIdxB1] = vertexIdxs[2];</span>
<span class="fc" id="L872">        tour[tIdxB2] = vertexIdxs[3];</span>
 
<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (tIdxA2 == 0) {</span>
<span class="fc" id="L875">            tour[tour.length - 1] = vertexIdxs[1];</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        } else if (tIdxB1 == 0) {</span>
<span class="nc" id="L877">            tour[tour.length - 1] = vertexIdxs[2];</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        } else if (tIdxB2 == 0) {</span>
<span class="fc" id="L879">            tour[tour.length - 1] = vertexIdxs[3];</span>
        }
        
        // ---- update the values of tour map
        // since the changes are swaps, all changed items
        // are present here in the updates
<span class="fc" id="L885">        tourValueToIndexMap.put(vertexIdxs[0], tIdxA1);</span>
<span class="fc" id="L886">        tourValueToIndexMap.put(vertexIdxs[1], tIdxA2);</span>
<span class="fc" id="L887">        tourValueToIndexMap.put(vertexIdxs[2], tIdxB1);</span>
<span class="fc" id="L888">        tourValueToIndexMap.put(vertexIdxs[3], tIdxB2);</span>

<span class="pc bpc" id="L890" title="3 of 4 branches missed.">        assert(assertTourData());</span>

<span class="fc" id="L892">System.out.println(&quot;new pathSum =&quot; + pathSum + </span>
<span class="fc" id="L893">&quot; tour=&quot; + Arrays.toString(tour));</span>

<span class="fc" id="L895">        return pathSum;</span>
    }
  
    /**
     * given tour values (which are the original graph
     * vertexes), change to vertexIdxs1 and return the
     * updated pathSum.
     @param tIdxA1 edge A vertex 1 tour index,
     * the second edge index is implicitly the one
     * that follows this in the tour array.
     @return the updated path sum after the changes
     * are applied.
    */
    public int changePathsToReverseEdge(int tIdxA1) {
    
<span class="nc" id="L910">        int tIdxA2 = getNextTourIndex(tIdxA1);</span>
<span class="nc" id="L911">        int tIdxPrevA1 = getPrevTourIndex(tIdxA1);</span>
<span class="nc" id="L912">        int tIdxNextA2 = getNextTourIndex(tIdxA2);</span>
        
        // ---- update the edge bounding boxes -----
<span class="nc" id="L915">        removeEdgeBoxes(tIdxPrevA1, tIdxA1, tIdxA2, </span>
            tIdxNextA2);
        
<span class="nc" id="L918">        insertEdgeBoxes(</span>
<span class="nc" id="L919">            getVertexIndex(tIdxA1),</span>
<span class="nc" id="L920">            getVertexIndex(tIdxA2),</span>
<span class="nc" id="L921">            getVertexIndex(tIdxPrevA1), </span>
<span class="nc" id="L922">            getVertexIndex(tIdxNextA2));</span>
        
        // ---- update the tour -----
    
<span class="nc" id="L926">        pathSum = peekSumPathChangesReverseEdge(</span>
            tIdxPrevA1, tIdxA1, tIdxA2, tIdxNextA2);
 
<span class="nc" id="L929">        tour[tIdxA1] = getVertexIndex(tIdxA2);</span>
<span class="nc" id="L930">        tour[tIdxA2] = getVertexIndex(tIdxA1);</span>
 
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (tIdxA2 == 0) {</span>
<span class="nc" id="L933">            tour[tour.length - 1] = tour[tIdxA2];</span>
        }
        
        // ---- update the values of tour map
        // since the changes are swaps, all changed items
        // are present here in the updates
<span class="nc" id="L939">        tourValueToIndexMap.put(tour[tIdxA1], tIdxA1);</span>
<span class="nc" id="L940">        tourValueToIndexMap.put(tour[tIdxA2], tIdxA2);</span>
         
<span class="nc bnc" id="L942" title="All 4 branches missed.">        assert(assertTourData());</span>
       
<span class="nc" id="L944">System.out.println(&quot;new pathSum==&quot; + pathSum + </span>
<span class="nc" id="L945">&quot; tour=&quot; + Arrays.toString(tour)</span>
<span class="nc" id="L946">+ printTourCoords());</span>

<span class="nc" id="L948">        return pathSum;</span>
    }
  
    public int getPathSum() {
<span class="fc" id="L952">        return pathSum;</span>
    }
    
    public int[] getTour() {
<span class="nc" id="L956">        return tour;</span>
    }
    
    /**
     * given the original graph vertex index,
     * return the index of that point in the 
     * tour.  Note that if the result is 0,
     * the vertex is also present as the last
     * item of the tour, but that index is not returned.
     * @param vertexIdx
     * @return 
     */
    public int getTourIndex(int vertexIdx) {
<span class="pc bpc" id="L969" title="2 of 4 branches missed.">        if (vertexIdx &lt; 0 || (vertexIdx &gt; (tour.length - 2))) {</span>
<span class="nc" id="L970">            throw new IllegalArgumentException(</span>
            &quot;vertexIdx is out of bounds&quot;);
        }
<span class="fc" id="L973">        int tIdx = tourValueToIndexMap.get(vertexIdx);</span>
<span class="fc" id="L974">        return tIdx;</span>
    }
    
    public int getVertexIndex(int tourIdx) {
<span class="pc bpc" id="L978" title="2 of 4 branches missed.">        if (tourIdx &lt; 0 || (tourIdx &gt; (tour.length - 1))) {</span>
<span class="nc" id="L979">            throw new IllegalArgumentException(</span>
            &quot;tourIdx is out of bounds&quot;);
        }
<span class="fc" id="L982">        return tour[tourIdx];</span>
    }

    /**
     * 
     * @param tIdxPrevA1
     * @param tIdxNextA2
     * @param tIdxPrevB1
     * @param tIdxNextB2
     @param tIdx1 candidate change edge A 1 tour vertex
     @param tIdx2 candidate change edge A 2 tour vertex
     @param tIdx3 candidate change edge B 1 tour vertex
     @param tIdx4 candidate change edge B 2 tour vertex
     * @return 
     */
    private boolean validateEdges(int tIdxPrevA1, 
        int tIdxNextA2, int tIdxPrevB1, int tIdxNextB2,
        int tIdx1, int tIdx2, int tIdx3, int tIdx4) {
        
        // validate that edge exists
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        for (int j = 0; j &lt; 4; ++j) {</span>
            int edge1, edge2;
<span class="fc bfc" id="L1004" title="All 2 branches covered.">            if (j == 0) {</span>
<span class="fc" id="L1005">                edge1 = getVertexIndex(tIdxPrevA1);</span>
<span class="fc" id="L1006">                edge2 = getVertexIndex(tIdx1);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            } else if (j == 1) {</span>
<span class="fc" id="L1008">                edge1 = getVertexIndex(tIdx2);</span>
<span class="fc" id="L1009">                edge2 = getVertexIndex(tIdxNextA2);</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            } else if (j == 2) {</span>
<span class="fc" id="L1011">                edge1 = getVertexIndex(tIdxPrevB1);</span>
<span class="fc" id="L1012">                edge2 = getVertexIndex(tIdx3);</span>
            } else {
<span class="fc" id="L1014">                edge1 = getVertexIndex(tIdx4);</span>
<span class="fc" id="L1015">                edge2 = getVertexIndex(tIdxNextB2);</span>
            }
           
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">            if (!(adjCostMap.containsKey(edge1)</span>
<span class="fc" id="L1019">                &amp;&amp; adjCostMap.get(edge1)</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                .containsKey(edge2))) {</span>
<span class="fc" id="L1021">                return false;</span>
            }
<span class="fc bfc" id="L1023" title="All 2 branches covered.">            if (j == 3) {</span>
                // try the combination if passed other checks
<span class="fc" id="L1025">                edge1 = getVertexIndex(tIdx1);</span>
<span class="fc" id="L1026">                edge2 = getVertexIndex(tIdx2);</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">                if (!(adjCostMap.containsKey(edge1)</span>
<span class="fc" id="L1028">                    &amp;&amp; adjCostMap.get(edge1)</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">                    .containsKey(edge2))) {</span>
<span class="nc" id="L1030">                    return false;</span>
                }
<span class="fc" id="L1032">                edge1 = getVertexIndex(tIdx3);</span>
<span class="fc" id="L1033">                edge2 = getVertexIndex(tIdx4);</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">                if (!(adjCostMap.containsKey(edge1)</span>
<span class="fc" id="L1035">                    &amp;&amp; adjCostMap.get(edge1)</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">                    .containsKey(edge2))) {</span>
<span class="nc" id="L1037">                    return false;</span>
                }
            }
        }
<span class="fc" id="L1041">        return true;</span>
    }
    
    private boolean assertTourData() {
        
<span class="nc bnc" id="L1046" title="All 4 branches missed.">        assert(tourValueToIndexMap.size() == tour.length - 1);</span>
        
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        for (int i = 0; i &lt; (tour.length - 1); ++i) {</span>
<span class="nc" id="L1049">            int cIdx = tour[i];</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if (!tourValueToIndexMap.containsKey(cIdx)) {</span>
<span class="nc" id="L1051">                return false;</span>
            }
<span class="nc" id="L1053">            int tIdx = tourValueToIndexMap.get(cIdx);</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            if (tIdx != i) {</span>
<span class="nc" id="L1055">                return false;</span>
            }
        }
        
<span class="nc" id="L1059">        return true;</span>
    }
    
    private boolean assertSameSets(int t1, int t2, int t3, int t4,
        int s1, int s2, int s3, int s4) {
<span class="nc" id="L1064">        TIntSet set1 = new TIntHashSet();</span>
<span class="nc" id="L1065">        TIntSet set2 = new TIntHashSet();</span>
        
<span class="nc" id="L1067">        set1.add(t1);</span>
<span class="nc" id="L1068">        set1.add(t2);</span>
<span class="nc" id="L1069">        set1.add(t3);</span>
<span class="nc" id="L1070">        set1.add(t4);</span>
        
<span class="nc" id="L1072">        set2.add(s1);</span>
<span class="nc" id="L1073">        set2.add(s2);</span>
<span class="nc" id="L1074">        set2.add(s3);</span>
<span class="nc" id="L1075">        set2.add(s4);</span>
        
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if (set1.size() != set2.size()) {</span>
<span class="nc" id="L1078">            return false;</span>
        }
<span class="nc" id="L1080">        TIntIterator iter = set1.iterator();</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1082">            int t = iter.next();</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (!set2.contains(t)) {</span>
<span class="nc" id="L1084">                return false;</span>
            }
<span class="nc" id="L1086">        }</span>
<span class="nc" id="L1087">        return true;</span>
    }

    private String printTourCoords() {

<span class="nc" id="L1092">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</span>
        
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        for (int i = 0; i &lt; tour.length; ++i) {            </span>
<span class="nc" id="L1095">            int idx = tour[i];</span>
<span class="nc" id="L1096">            sb.append(String.format(</span>
<span class="nc" id="L1097">            &quot;[%d %d] &quot;, i, idx));</span>
<span class="nc" id="L1098">            sb.append(coordinates[idx].toString()).append(&quot;\n&quot;);</span>
        }
        
<span class="nc" id="L1101">        sb.append(&quot;]&quot;);</span>
        
<span class="nc" id="L1103">        return sb.toString();</span>
    }

    private void sortByEdgeLength(TIntList edgeAList) {

<span class="nc" id="L1108">        int[] len = new int[edgeAList.size()];</span>
<span class="nc" id="L1109">        int[] vtxs = new int[len.length];</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        for (int i = 0; i &lt; edgeAList.size(); ++i) {</span>
<span class="nc" id="L1111">            int idx1 = edgeAList.get(i);</span>
<span class="nc" id="L1112">            int idx2 = getNextVertexIndex(idx1);</span>
<span class="nc" id="L1113">            int cost = adjCostMap.get(idx1).get(idx2);</span>
<span class="nc" id="L1114">            len[i] = cost;</span>
<span class="nc" id="L1115">            vtxs[i] = idx1;</span>
        }
        
<span class="nc" id="L1118">        QuickSort.sortBy1stArg(len, vtxs);</span>
        
<span class="nc bnc" id="L1120" title="All 2 branches missed.">        for (int i = 0; i &lt; vtxs.length; ++i) {</span>
<span class="nc" id="L1121">            edgeAList.set(i, vtxs[i]);</span>
        }
<span class="nc" id="L1123">    }</span>

    private TObjectIntMap&lt;PairInt&gt; createPointVertexMap() {

<span class="nc" id="L1127">        TObjectIntMap&lt;PairInt&gt; map = new TObjectIntHashMap&lt;PairInt&gt;();</span>
    
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        for (int i = 0; i &lt; coordinates.length; ++i) {</span>
<span class="nc" id="L1130">            map.put(coordinates[i], i);</span>
        }
        
<span class="nc" id="L1133">        return map;</span>
    }

    private int getCost(int idxV1, int idxV2) {

<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (adjCostMap.containsKey(idxV1) </span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">           &amp;&amp; adjCostMap.get(idxV1).containsKey(idxV2)) {</span>
<span class="nc" id="L1140">           return adjCostMap.get(idxV1).get(idxV2);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        } else if (adjCostMap.containsKey(idxV1) </span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">           &amp;&amp; adjCostMap.get(idxV1).containsKey(idxV2)) {</span>
<span class="nc" id="L1143">           return adjCostMap.get(idxV1).get(idxV2);</span>
        }
        
<span class="nc" id="L1146">        return 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
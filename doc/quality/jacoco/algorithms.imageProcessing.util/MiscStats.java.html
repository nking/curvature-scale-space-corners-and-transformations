<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscStats.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.util</a> &gt; <span class="el_source">MiscStats.java</span></div><h1>MiscStats.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.util;

import algorithms.compGeometry.PointInPolygon;
import algorithms.imageProcessing.features.FeatureComparisonStat;
import algorithms.imageProcessing.transform.MatchedPointsTransformationCalculator;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import com.climbwithyourfeet.clustering.DTClusterFinder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="nc bnc" id="L30" title="All 2 branches missed.">public class MiscStats {</span>
    
    public static double[] calculateMeanStDevAndMode(List&lt;Double&gt; a, double binSize) {
        
<span class="nc" id="L34">        double n = (double)a.size();</span>
<span class="nc" id="L35">        double minValue = Double.MAX_VALUE;</span>
<span class="nc" id="L36">        double maxValue = Double.MIN_VALUE;</span>
<span class="nc" id="L37">        double mean = 0;</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">        for (Double d : a) {</span>
<span class="nc" id="L39">            double dp = d.doubleValue();</span>
<span class="nc" id="L40">            mean += dp;</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">            if (dp &lt; minValue) {</span>
<span class="nc" id="L42">                minValue = dp;</span>
            }
<span class="nc bnc" id="L44" title="All 2 branches missed.">            if (dp &gt; maxValue) {</span>
<span class="nc" id="L45">                maxValue = dp;</span>
            }
<span class="nc" id="L47">        }</span>
<span class="nc" id="L48">        mean /= n;</span>

<span class="nc" id="L50">        double stDev = 0;</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">        for (Double d : a) {</span>
<span class="nc" id="L52">            double diff = d.doubleValue() - mean;</span>
<span class="nc" id="L53">            stDev += (diff * diff);</span>
<span class="nc" id="L54">        }</span>
<span class="nc" id="L55">        stDev = Math.sqrt(stDev/(n - 1.));</span>

        // --- histogram for finding mode, given binSize ----
<span class="nc" id="L58">        int nBins = (int)Math.ceil((maxValue - minValue)/binSize);</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (nBins == 0) {</span>
<span class="nc" id="L60">            nBins = 1;</span>
        }
<span class="nc" id="L62">        double[] xHist = new double[nBins];</span>
<span class="nc" id="L63">        int[] yHist = new int[nBins];</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        for (int i = 0; i &lt; nBins; i++) {</span>
<span class="nc" id="L65">            xHist[i] = minValue + ((double)i)*binSize + (binSize/2.);</span>
        }
<span class="nc bnc" id="L67" title="All 2 branches missed.">        for (int i = 0; i &lt; a.size(); i++) {</span>
<span class="nc" id="L68">            int bin = (int)((a.get(i).doubleValue() - minValue)/binSize);</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">            if ((bin &gt; -1) &amp;&amp; (bin &lt; nBins)) {</span>
<span class="nc" id="L70">                yHist[bin]++;</span>
            }
        }
<span class="nc" id="L73">        double maxYHist = Double.MIN_VALUE;</span>
<span class="nc" id="L74">        int maxYIdx = -1;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        for (int i = 0; i &lt; yHist.length; ++i) {</span>
<span class="nc" id="L76">            int y = yHist[i];</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">            if (y &gt; maxYHist) {</span>
<span class="nc" id="L78">                maxYHist = y;</span>
<span class="nc" id="L79">                maxYIdx = i;</span>
            }
        }
<span class="nc" id="L82">        double mode = xHist[maxYIdx];</span>
        
<span class="nc" id="L84">        return new double[]{mean, stDev, mode};</span>
    }
    
    public static int[] filterForScaleAndRotation(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L91">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L93">                indexes[i] = i;</span>
            }
<span class="nc" id="L95">            return indexes;</span>
        }
        
<span class="nc" id="L98">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L99">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L100">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L102">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L104">                r = 360 - r;</span>
            }
<span class="nc" id="L106">            rotations[i] = r;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L108">                minRD = r;</span>
            }
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L111">                maxRD = r;</span>
            }
        }

<span class="nc" id="L115">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L116">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L117">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L119">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L121">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L123" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L124">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L127">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L129">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L132">        float factor = (int)(maxRD - minRD)/diffS;</span>
<span class="nc" id="L133">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L134">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L136">            float s = scales[i];</span>
<span class="nc" id="L137">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L139">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L143">        Set&lt;PairIntWithIndex&gt; points = new HashSet&lt;PairIntWithIndex&gt;();</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L146">            float x = rotations[i];</span>
<span class="nc" id="L147">            float y = scales[i];</span>
<span class="nc" id="L148">            PairIntWithIndex p = new PairIntWithIndex(Math.round(x),</span>
<span class="nc" id="L149">                Math.round(y), i);</span>
<span class="nc" id="L150">            points.add(p);</span>
        }

<span class="nc" id="L153">        int dimen1 = (int)(Math.ceil(maxRD) + 1);</span>
<span class="nc" id="L154">        int dimen2 = (int)(Math.ceil(maxS) + 1);</span>

<span class="nc" id="L156">        DTClusterFinder&lt;PairIntWithIndex&gt; cFinder </span>
            = new DTClusterFinder&lt;PairIntWithIndex&gt;(points, dimen1, dimen2);
        //cFinder.setToDebug();
<span class="nc" id="L159">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L161">        cFinder.findClusters();</span>

<span class="nc" id="L163">        int n = cFinder.getNumberOfClusters();</span>
        
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L166">            return new int[0];</span>
        }
        
<span class="nc" id="L169">        int maxN = Integer.MIN_VALUE;</span>
<span class="nc" id="L170">        int maxNIdx = -1;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L172">            int ns = cFinder.getCluster(i).size();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (ns &gt; maxN) {</span>
<span class="nc" id="L174">                maxN = ns;</span>
<span class="nc" id="L175">                maxNIdx = i;</span>
            }
        }
<span class="nc" id="L178">        int[] indexes = new int[maxN];</span>
<span class="nc" id="L179">        int count = 0;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (PairIntWithIndex p : cFinder.getCluster(maxNIdx)) {</span>
<span class="nc" id="L181">            indexes[count] = p.getPixIndex();</span>
<span class="nc" id="L182">            count++;</span>
<span class="nc" id="L183">        }</span>
        
<span class="nc" id="L185">        return indexes;</span>
    }

    public static int[] filterForScaleAndRotationUsingHist(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L192">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L194">                indexes[i] = i;</span>
            }
<span class="nc" id="L196">            return indexes;</span>
        }
        
<span class="nc" id="L199">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L200">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L201">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L203">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L205">                r = 360 - r;</span>
            }
<span class="nc" id="L207">            rotations[i] = r;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L209">                minRD = r;</span>
            }
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L212">                maxRD = r;</span>
            }
        }

<span class="nc" id="L216">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L217">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L218">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L220">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L222">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L225">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L228">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L230">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L233">        float factor = (int)(maxRD - minRD)/diffS;</span>
<span class="nc" id="L234">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L235">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L237">            float s = scales[i];</span>
<span class="nc" id="L238">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L240">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L244">        HistogramHolder rHist = Histogram.createSimpleHistogram(25.f, rotations, </span>
<span class="nc" id="L245">            Errors.populateYErrorsBySqrt(rotations));</span>
        
<span class="nc" id="L247">        HistogramHolder sHist = Histogram.createSimpleHistogram(25.f, scales, </span>
<span class="nc" id="L248">            Errors.populateYErrorsBySqrt(scales));</span>
        
<span class="nc" id="L250">        int[] rYMaxIdx = MiscMath.findYMaxIndexes(rHist.getYHist());</span>
        
<span class="nc" id="L252">        int[] sYMaxIdx = MiscMath.findYMaxIndexes(sHist.getYHist());</span>
        
<span class="nc" id="L254">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (rYMaxIdx != null) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            for (int vIdx : rYMaxIdx) {</span>
<span class="nc" id="L258">                float v = rHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                for (int i = 0; i &lt; rotations.length; ++i) {</span>
<span class="nc" id="L260">                    float diff = Math.abs(rotations[i] - v);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L262">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (sYMaxIdx != null) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            for (int vIdx : sYMaxIdx) {</span>
<span class="nc" id="L270">                float v = sHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L272">                    float diff = Math.abs(scales[i] - v);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L274">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L280">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L281">        int count = 0;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L283">            indexes[count] = index.intValue();</span>
<span class="nc" id="L284">            count++;</span>
<span class="nc" id="L285">        }</span>
        
<span class="nc" id="L287">        return indexes;</span>
    }
    
    public static int[] filterForRotationUsingHist(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L294">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L296">                indexes[i] = i;</span>
            }
<span class="nc" id="L298">            return indexes;</span>
        }
        
<span class="nc" id="L301">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L302">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L303">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L305">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L307">                r = 360 - r;</span>
            }
<span class="nc" id="L309">            rotations[i] = r;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L311">                minRD = r;</span>
            }
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L314">                maxRD = r;</span>
            }
        }

<span class="nc" id="L318">        HistogramHolder rHist = Histogram.createSimpleHistogram(25.f, rotations, </span>
<span class="nc" id="L319">            Errors.populateYErrorsBySqrt(rotations));</span>
        
<span class="nc" id="L321">        int[] rYMaxIdx = MiscMath.findYMaxIndexes(rHist.getYHist());</span>
        
<span class="nc" id="L323">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (rYMaxIdx != null) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            for (int vIdx : rYMaxIdx) {</span>
<span class="nc" id="L327">                float v = rHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                for (int i = 0; i &lt; rotations.length; ++i) {</span>
<span class="nc" id="L329">                    float diff = Math.abs(rotations[i] - v);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L331">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L337">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L338">        int count = 0;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L340">            indexes[count] = index.intValue();</span>
<span class="nc" id="L341">            count++;</span>
<span class="nc" id="L342">        }</span>
        
<span class="nc" id="L344">        return indexes;</span>
    }

    public static int[] filterForScaleUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (paramsList.size() &lt; 3) {</span>
<span class="nc" id="L351">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L353">                indexes[i] = i;</span>
            }
<span class="nc" id="L355">            return indexes;</span>
        }
        
<span class="nc" id="L358">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L359">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L360">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L362">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L364">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L367">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L370">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L372">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L375">        float factor = 360/diffS;</span>
<span class="nc" id="L376">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L377">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L379">            float s = scales[i];</span>
<span class="nc" id="L380">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L382">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L386">        HistogramHolder sHist = Histogram.createSimpleHistogram(25.f, scales, </span>
<span class="nc" id="L387">            Errors.populateYErrorsBySqrt(scales));</span>
                
<span class="nc" id="L389">        int[] sYMaxIdx = MiscMath.findYMaxIndexes(sHist.getYHist());</span>
        
<span class="nc" id="L391">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (sYMaxIdx != null) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            for (int vIdx : sYMaxIdx) {</span>
<span class="nc" id="L395">                float v = sHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L397">                    float diff = Math.abs(scales[i] - v);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L399">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L405">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L406">        int count = 0;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L408">            indexes[count] = index.intValue();</span>
<span class="nc" id="L409">            count++;</span>
<span class="nc" id="L410">        }</span>
        
<span class="nc" id="L412">        return indexes;</span>
    }
    
    public static int[] filterForTranslationXUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {        
        
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (paramsList.size() &lt; 3) {</span>
<span class="nc" id="L419">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L421">                indexes[i] = i;</span>
            }
<span class="nc" id="L423">            return indexes;</span>
        }
        
<span class="nc" id="L426">        float minX = Float.MAX_VALUE;</span>
<span class="nc" id="L427">        float maxX = Float.MIN_VALUE;</span>
<span class="nc" id="L428">        float[] translationXs = new float[paramsList.size()];</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L430">            translationXs[i] = paramsList.get(i).getTranslationX();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (translationXs[i] &lt; minX) {</span>
<span class="nc" id="L432">                minX = translationXs[i];</span>
            }
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (translationXs[i] &gt; maxX) {</span>
<span class="nc" id="L435">                maxX = translationXs[i];</span>
            }
        }
        
<span class="nc" id="L439">        HistogramHolder tXHist = Histogram.createSimpleHistogram(translationXs, </span>
<span class="nc" id="L440">            Errors.populateYErrorsBySqrt(translationXs));</span>
                
<span class="nc" id="L442">        int[] txMaxIdx = MiscMath.findYMaxIndexes(tXHist.getYHist());</span>
        
<span class="nc" id="L444">        float binSize = tXHist.getXHist()[1] - tXHist.getXHist()[0];</span>
        
<span class="nc" id="L446">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (txMaxIdx != null) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">            for (int vIdx : txMaxIdx) {</span>
<span class="nc" id="L450">                float v = tXHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                for (int i = 0; i &lt; translationXs.length; ++i) {</span>
<span class="nc" id="L452">                    float diff = Math.abs(translationXs[i] - v);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                    if (diff &lt;= 1.1*binSize) {</span>
<span class="nc" id="L454">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L460">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L461">        int count = 0;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L463">            indexes[count] = index.intValue();</span>
<span class="nc" id="L464">            count++;</span>
<span class="nc" id="L465">        }</span>
        
<span class="nc" id="L467">        return indexes;</span>
    }
    
    public static int[] filterForTranslationYUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (paramsList.size() &lt; 3) {</span>
<span class="nc" id="L474">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L476">                indexes[i] = i;</span>
            }
<span class="nc" id="L478">            return indexes;</span>
        }
        
<span class="nc" id="L481">        float minY = Float.MAX_VALUE;</span>
<span class="nc" id="L482">        float maxY = Float.MIN_VALUE;</span>
<span class="nc" id="L483">        float[] translationYs = new float[paramsList.size()];</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L485">            translationYs[i] = paramsList.get(i).getTranslationY();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (translationYs[i] &lt; minY) {</span>
<span class="nc" id="L487">                minY = translationYs[i];</span>
            }
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (translationYs[i] &gt; maxY) {</span>
<span class="nc" id="L490">                maxY = translationYs[i];</span>
            }
        }
        
<span class="nc" id="L494">        HistogramHolder tYHist = Histogram.createSimpleHistogram(translationYs, </span>
<span class="nc" id="L495">            Errors.populateYErrorsBySqrt(translationYs));</span>
                
<span class="nc" id="L497">        int[] tyMaxIdx = MiscMath.findYMaxIndexes(tYHist.getYHist());</span>
        
<span class="nc" id="L499">        float binSize = tYHist.getXHist()[1] - tYHist.getXHist()[0];</span>
        
<span class="nc" id="L501">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (tyMaxIdx != null) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            for (int vIdx : tyMaxIdx) {</span>
<span class="nc" id="L505">                float v = tYHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                for (int i = 0; i &lt; translationYs.length; ++i) {</span>
<span class="nc" id="L507">                    float diff = Math.abs(translationYs[i] - v);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    if (diff &lt;= 1.1*binSize) {</span>
<span class="nc" id="L509">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L515">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L516">        int count = 0;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L518">            indexes[count] = index.intValue();</span>
<span class="nc" id="L519">            count++;</span>
<span class="nc" id="L520">        }</span>
        
<span class="nc" id="L522">        return indexes;</span>
    }
    
    public static int[] filterForTranslation(List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L528">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L530">                indexes[i] = i;</span>
            }
<span class="nc" id="L532">            return indexes;</span>
        }
        
<span class="nc" id="L535">        float minTX = Float.MAX_VALUE;</span>
<span class="nc" id="L536">        float maxTX = Float.MIN_VALUE;</span>
<span class="nc" id="L537">        float[] transX = new float[paramsList.size()];</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L539">            float v = paramsList.get(i).getTranslationX();</span>
<span class="nc" id="L540">            transX[i] = v;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (v &lt; minTX) {</span>
<span class="nc" id="L542">                minTX = v;</span>
            }
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (v &gt; maxTX) {</span>
<span class="nc" id="L545">                maxTX = v;</span>
            }
        }
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (minTX != 0) {</span>
            // shift the values so that '1' is the lowest value... 
            // dt in clustering runtime is O(dimension * lg_2(dimension))
<span class="nc" id="L551">            float offset = -1*minTX;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            for (int i = 0; i &lt; transX.length; ++i) {</span>
<span class="nc" id="L553">                transX[i] += (offset + 1);</span>
            }
<span class="nc" id="L555">            minTX += (offset + 1);</span>
<span class="nc" id="L556">            maxTX += (offset + 1);</span>
        }
        
<span class="nc" id="L559">        float minTY = Float.MAX_VALUE;</span>
<span class="nc" id="L560">        float maxTY = Float.MIN_VALUE;</span>
<span class="nc" id="L561">        float[] transY = new float[paramsList.size()];</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L563">            float v = paramsList.get(i).getTranslationY();</span>
<span class="nc" id="L564">            transY[i] = v;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (v &lt; minTY) {</span>
<span class="nc" id="L566">                minTY = v;</span>
            }
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (v &gt; maxTY) {</span>
<span class="nc" id="L569">                maxTY = v;</span>
            }
        }
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (minTY != 0) {</span>
            // shift the values so that '1' is the lowest value... 
            // dt in clustering runtime is O(dimension * lg_2(dimension))
<span class="nc" id="L575">            float offset = -1*minTY;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            for (int i = 0; i &lt; transY.length; ++i) {</span>
<span class="nc" id="L577">                transY[i] += (offset + 1);</span>
            }
<span class="nc" id="L579">            minTY += (offset + 1);</span>
<span class="nc" id="L580">            maxTY += (offset + 1);</span>
        }
        
<span class="nc bnc" id="L583" title="All 4 branches missed.">        if ((maxTX &gt; 1000) || (maxTY &gt; 1000)) {</span>
            //TODO: implement a histogram version
        }
        
<span class="nc" id="L587">        Set&lt;PairIntWithIndex&gt; points = new HashSet&lt;PairIntWithIndex&gt;();</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">        for (int i = 0; i &lt; transX.length; ++i) {</span>
<span class="nc" id="L590">            float x = transX[i];</span>
<span class="nc" id="L591">            float y = transY[i];</span>
<span class="nc" id="L592">            PairIntWithIndex p = new PairIntWithIndex(Math.round(x),</span>
<span class="nc" id="L593">                Math.round(y), i);</span>
<span class="nc" id="L594">            points.add(p);</span>
        }

<span class="nc" id="L597">        int dimen1 = (int)(Math.ceil(maxTX) + 1);</span>
<span class="nc" id="L598">        int dimen2 = (int)(Math.ceil(maxTY) + 1);</span>

<span class="nc" id="L600">        DTClusterFinder&lt;PairIntWithIndex&gt; cFinder </span>
            = new DTClusterFinder&lt;PairIntWithIndex&gt;(points, dimen1, dimen2);
        //cFinder.setToDebug();
<span class="nc" id="L603">        cFinder.setThreshholdFactor(0.75f);</span>
<span class="nc" id="L604">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L606">        cFinder.findClusters();</span>

<span class="nc" id="L608">        int n = cFinder.getNumberOfClusters();</span>
        
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L611">            return new int[0];</span>
        }
        
<span class="nc" id="L614">        int maxN = Integer.MIN_VALUE;</span>
<span class="nc" id="L615">        int maxNIdx = -1;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L617">            int ns = cFinder.getCluster(i).size();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (ns &gt; maxN) {</span>
<span class="nc" id="L619">                maxN = ns;</span>
<span class="nc" id="L620">                maxNIdx = i;</span>
            }
        }
<span class="nc" id="L623">        int[] indexes = new int[maxN];</span>
<span class="nc" id="L624">        int count = 0;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        for (PairIntWithIndex p : cFinder.getCluster(maxNIdx)) {</span>
<span class="nc" id="L626">            indexes[count] = p.getPixIndex();</span>
<span class="nc" id="L627">            count++;</span>
<span class="nc" id="L628">        }</span>
        
<span class="nc" id="L630">        return indexes;</span>
    }

    public static boolean standardDeviationsAreSmall(TransformationParameters params) {

<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (params.getStandardDeviations() == null) {</span>
<span class="nc" id="L636">            return false;</span>
        }
        
        // calculation
<span class="nc" id="L640">        float tS = (params.getStandardDeviations()[0] / params.getScale());</span>
<span class="nc" id="L641">        float tR = (float) (2. * Math.PI / params.getStandardDeviations()[1]);</span>

        // consider comparing stdev in translations to a fraction of the image
<span class="nc" id="L644">        int tTx = Math.round(params.getStandardDeviations()[2]);</span>
<span class="nc" id="L645">        int tTy = Math.round(params.getStandardDeviations()[3]);</span>

<span class="nc" id="L647">        float tXConstraint = 20;</span>
<span class="nc" id="L648">        float tYConstraint = 20;</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if (params.getNumberOfPointsUsed() &lt; 3) {</span>
<span class="nc" id="L650">            tXConstraint = 10;</span>
<span class="nc" id="L651">            tYConstraint = 10;</span>
        }

        //TODO: review these limits
<span class="nc bnc" id="L655" title="All 8 branches missed.">        if ((tS &lt; 0.2) &amp;&amp; (tR &gt;= 18.) &amp;&amp; (tTx &lt; tXConstraint)</span>
            &amp;&amp; (tTy &lt; tYConstraint)) {

<span class="nc" id="L658">            return true;</span>
        }

<span class="nc" id="L661">        return false;</span>
    }

    /**
     * comparing each parameter to others and keeping only if there are other
     * similar params and among the similar, only returning average of similar.
     * 
     * @param paramsMap
     * @return 
     */
    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets(
        Map&lt;PairInt, TransformationParameters&gt; paramsMap, int binFactor1,
        int binFactor2) {
        
<span class="nc" id="L675">        int transTol = 30;</span>
<span class="nc bnc" id="L676" title="All 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="nc" id="L677">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="nc" id="L680">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="nc" id="L683">        Set&lt;PairInt&gt; alreadyCombined = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L685" title="All 2 branches missed.">        for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry : paramsMap.entrySet()) {</span>
            
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if (alreadyCombined.contains(entry.getKey())) {</span>
<span class="nc" id="L688">                continue;</span>
            }
                        
<span class="nc" id="L691">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
            
<span class="nc" id="L693">            TransformationParameters params0 = entry.getValue();</span>
            
<span class="nc bnc" id="L695" title="All 2 branches missed.">            for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry2 : paramsMap.entrySet()) {</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                if (entry2.getKey().equals(entry.getKey()) || </span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                    alreadyCombined.contains(entry2.getKey())) {</span>
<span class="nc" id="L698">                    continue;</span>
                }
<span class="nc" id="L700">                TransformationParameters compare = entry2.getValue();</span>
<span class="nc" id="L701">                float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L702">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="nc" id="L704">                    continue;</span>
                }
<span class="nc" id="L706">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="nc" id="L708">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="nc" id="L712">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="nc" id="L713">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="nc" id="L715">                    continue;</span>
                }
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if (!alreadyCombined.contains(entry.getKey())) {</span>
<span class="nc" id="L718">                    alreadyCombined.add(entry.getKey());</span>
                }
<span class="nc" id="L720">                alreadyCombined.add(entry2.getKey());</span>
                
<span class="nc" id="L722">                set.add(params0);</span>
<span class="nc" id="L723">                set.add(compare);</span>
<span class="nc" id="L724">            }</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (!set.isEmpty()) {</span>
<span class="nc" id="L726">                similarSets.add(set);</span>
            }
<span class="nc" id="L728">        }</span>
                  
        // use histograms to remove translation outliers in similar sets
        
<span class="nc" id="L732">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();

<span class="nc bnc" id="L735" title="All 2 branches missed.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="nc" id="L737">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="nc" id="L739">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="nc" id="L740">            filter(similar, keep);</span>
<span class="nc" id="L741">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="nc" id="L742">            filter(similar, keep);</span>
            
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L745">                continue;</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            } else if (similar.size() == 1) {</span>
<span class="nc" id="L747">                combinedParams.add(similar.get(0));</span>
<span class="nc" id="L748">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="nc" id="L753">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="nc" id="L754">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="nc" id="L755">            combinedParams.add(params);</span>
<span class="nc" id="L756">        }</span>
        
        // sometimes, the averaged params in similarSets are similar to one
        // another too, so one more round of checking for similarity
<span class="nc" id="L760">        List&lt;TransformationParameters&gt; combinedParams2 = new ArrayList&lt;TransformationParameters&gt;();</span>
        
<span class="nc" id="L762">        Set&lt;TransformationParameters&gt; alreadyCombined2 = new HashSet&lt;TransformationParameters&gt;();</span>
        
<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (TransformationParameters params0 : combinedParams) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            if (alreadyCombined2.contains(params0)) {</span>
<span class="nc" id="L766">                continue;</span>
            }
<span class="nc" id="L768">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
<span class="nc" id="L769">            set.add(params0);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            for (TransformationParameters compare : combinedParams) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                if (compare.equals(params0)) {</span>
<span class="nc" id="L772">                    continue;</span>
                }
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (alreadyCombined2.contains(compare)) {</span>
<span class="nc" id="L775">                    continue;</span>
                }
<span class="nc" id="L777">                float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L778">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="nc" id="L780">                    continue;</span>
                }
<span class="nc" id="L782">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="nc" id="L784">                    continue;</span>
                }
                //TODO: may need to revise translation tolerance...
<span class="nc" id="L787">                double diffX = Math.abs(params0.getTranslationX() - compare.getTranslationX());</span>
<span class="nc" id="L788">                double diffY = Math.abs(params0.getTranslationY() - compare.getTranslationY());</span>
<span class="nc bnc" id="L789" title="All 4 branches missed.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)) {</span>
<span class="nc" id="L790">                    continue;</span>
                }
<span class="nc" id="L792">                set.add(compare);</span>
<span class="nc" id="L793">            }</span>
<span class="nc" id="L794">            alreadyCombined2.addAll(set);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (set.size() &gt; 1) {</span>
<span class="nc" id="L796">                MatchedPointsTransformationCalculator tc = new MatchedPointsTransformationCalculator();</span>
<span class="nc" id="L797">                TransformationParameters params =  tc.averageWithoutRemoval(</span>
                    new ArrayList&lt;TransformationParameters&gt;(set));
<span class="nc" id="L799">                combinedParams2.add(params);</span>
<span class="nc" id="L800">            } else {</span>
<span class="nc" id="L801">                combinedParams2.addAll(set);</span>
            }
<span class="nc" id="L803">        }</span>
        
<span class="nc" id="L805">        return combinedParams2;</span>
    }
    
    /**
     * comparing each parameter to others and if there are other
     * similar params, averaging those.
     * 
     * @param paramsMap
     * @param binFactor1
     * @param binFactor2
     * @return 
     */
    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets2(
        Map&lt;PairInt, TransformationParameters&gt; paramsMap, int binFactor1,
        int binFactor2) {
        
<span class="nc" id="L821">        int transTol = 30;</span>
<span class="nc bnc" id="L822" title="All 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="nc" id="L823">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="nc" id="L826">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="nc" id="L829">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="nc" id="L832">        Set&lt;PairInt&gt; alreadyCombined = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L834" title="All 2 branches missed.">        for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry : paramsMap.entrySet()) {</span>
            
<span class="nc bnc" id="L836" title="All 2 branches missed.">            if (alreadyCombined.contains(entry.getKey())) {</span>
<span class="nc" id="L837">                continue;</span>
            }
                      
<span class="nc" id="L840">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
            
<span class="nc" id="L842">            TransformationParameters params0 = entry.getValue();</span>
            
<span class="nc bnc" id="L844" title="All 2 branches missed.">            for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry2 : paramsMap.entrySet()) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">                if (entry2.getKey().equals(entry.getKey()) || </span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">                    alreadyCombined.contains(entry2.getKey())) {</span>
<span class="nc" id="L847">                    continue;</span>
                }
<span class="nc" id="L849">                TransformationParameters compare = entry2.getValue();</span>
<span class="nc" id="L850">                float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L851">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="nc" id="L853">                    continue;</span>
                }
<span class="nc" id="L855">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="nc" id="L857">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="nc" id="L861">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="nc" id="L862">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="nc bnc" id="L863" title="All 4 branches missed.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="nc" id="L864">                    continue;</span>
                }
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (!alreadyCombined.contains(entry.getKey())) {</span>
<span class="nc" id="L867">                    alreadyCombined.add(entry.getKey());</span>
                }
<span class="nc" id="L869">                alreadyCombined.add(entry2.getKey());</span>
                
<span class="nc" id="L871">                set.add(params0);</span>
<span class="nc" id="L872">                set.add(compare);</span>
<span class="nc" id="L873">            }</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if (set.isEmpty()) {</span>
<span class="nc" id="L875">                combinedParams.add(params0);</span>
            } else {
<span class="nc" id="L877">                similarSets.add(set);</span>
            }
<span class="nc" id="L879">        }</span>
        
        // use histograms to remove translation outliers in similar sets

<span class="nc bnc" id="L883" title="All 2 branches missed.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="nc" id="L885">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="nc" id="L887">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="nc" id="L888">            Set&lt;Integer&gt; unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            for (Integer ind : unique) {</span>
<span class="nc" id="L890">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="nc" id="L891">            }</span>
            
<span class="nc" id="L893">            filter(similar, keep);</span>
<span class="nc" id="L894">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="nc" id="L895">            unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">            for (Integer ind : unique) {</span>
<span class="nc" id="L897">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="nc" id="L898">            }</span>
<span class="nc" id="L899">            filter(similar, keep);</span>
            
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L902">                continue;</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">            } else if (similar.size() == 1) {</span>
<span class="nc" id="L904">                combinedParams.add(similar.get(0));</span>
<span class="nc" id="L905">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="nc" id="L910">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="nc" id="L911">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="nc" id="L912">            combinedParams.add(params);</span>
<span class="nc" id="L913">        }</span>
        
<span class="nc" id="L915">        return combinedParams;</span>
    }
    
    public static Set&lt;Integer&gt; indexesNotPresent(int[] indexes, int totalNumber) {
<span class="nc" id="L919">        int n = totalNumber = indexes.length;</span>
<span class="nc" id="L920">        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        for (int index : indexes) {</span>
<span class="nc" id="L922">            set.add(Integer.valueOf(index));</span>
        }
<span class="nc" id="L924">        Set&lt;Integer&gt; diff = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">        for (int i = 0; i &lt; totalNumber; ++i) {</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">            if (!set.contains(Integer.valueOf(i))) {</span>
<span class="nc" id="L927">                diff.add(Integer.valueOf(i));</span>
            }
        }
<span class="nc" id="L930">        return diff;</span>
    }

    private static void filter(List&lt;TransformationParameters&gt; params, 
        int[] indexesToKeep) {
                
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (indexesToKeep.length &lt; 2) {</span>
<span class="nc" id="L937">            return;</span>
        }
        
<span class="nc" id="L940">        List&lt;TransformationParameters&gt; paramsList2 = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="nc bnc" id="L943" title="All 2 branches missed.">        for (int i = 0; i &lt; indexesToKeep.length;++i) {</span>
<span class="nc" id="L944">            int idx = indexesToKeep[i];</span>
<span class="nc" id="L945">            paramsList2.add(params.get(idx));</span>
        }
                
<span class="nc" id="L948">        params.clear();</span>
<span class="nc" id="L949">        params.addAll(paramsList2);</span>
<span class="nc" id="L950">    }</span>

    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param pointValueMap
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndValues(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L966">        int minTheta = Integer.MAX_VALUE;</span>
<span class="nc" id="L967">        int maxTheta = Integer.MIN_VALUE;</span>
                
<span class="nc bnc" id="L969" title="All 2 branches missed.">        for (Map.Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L970">            int v = Math.round(entry.getValue().floatValue());</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (v &lt; minTheta) {</span>
<span class="nc" id="L972">                minTheta = v;</span>
            }
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (v &gt; maxTheta) {</span>
<span class="nc" id="L975">                maxTheta = v;</span>
            }
<span class="nc" id="L977">        }</span>
                
<span class="nc bnc" id="L979" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // sort values and find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L984">            int[] values = new int[pointValueMap.size()];</span>
<span class="nc" id="L985">            int count = 0;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">            for (Map.Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L987">                values[count] = Math.round(entry.getValue().floatValue());</span>
<span class="nc" id="L988">                count++;</span>
<span class="nc" id="L989">            }</span>
<span class="nc" id="L990">            Arrays.sort(values);</span>
            
<span class="nc" id="L992">            return determineStartEndValues(values, maxValueForWrapAround, </span>
                toleranceInValue);
        }
        
<span class="nc" id="L996">        return new int[]{minTheta, maxTheta};</span>
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndValues(int[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1013">        int[] startEndIndexes = determineStartEndIndexes(sortedValues, </span>
            maxValueForWrapAround, toleranceInValue);
        
<span class="nc" id="L1016">        return new int[]{sortedValues[startEndIndexes[0]], </span>
            sortedValues[startEndIndexes[1]]};
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndIndexes(int[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1034">        int minTheta = sortedValues[0];</span>
<span class="nc" id="L1035">        int maxTheta = sortedValues[sortedValues.length - 1];</span>
         
<span class="nc bnc" id="L1037" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1042">            int endIdx = -1;</span>
<span class="nc" id="L1043">            int startIdx = -1;</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            for (int i = 0; i &lt; (sortedValues.length - 1); ++i) {</span>
<span class="nc" id="L1045">                int diff = sortedValues[i + 1] - sortedValues[i];</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                if (diff &gt; (toleranceInValue + 1)) {</span>
<span class="nc" id="L1047">                    endIdx = i;</span>
<span class="nc" id="L1048">                    startIdx = i;</span>
<span class="nc" id="L1049">                    break;</span>
                }
            }
<span class="nc bnc" id="L1052" title="All 4 branches missed.">            if (startIdx &gt; -1 &amp;&amp; endIdx &gt; -1) {</span>
<span class="nc" id="L1053">                return new int[]{startIdx, endIdx};</span>
            }
        }
        
<span class="nc" id="L1057">        return new int[]{0, sortedValues.length - 1};</span>
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndIndexes(float[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1074">        float minTheta = sortedValues[0];</span>
<span class="nc" id="L1075">        float maxTheta = sortedValues[sortedValues.length - 1];</span>
         
<span class="nc bnc" id="L1077" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1082">            int endIdx = -1;</span>
<span class="nc" id="L1083">            int startIdx = -1;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            for (int i = 0; i &lt; (sortedValues.length - 1); ++i) {</span>
<span class="nc" id="L1085">                float diff = sortedValues[i + 1] - sortedValues[i];</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                if (diff &gt; (toleranceInValue + 1)) {</span>
<span class="nc" id="L1087">                    endIdx = i;</span>
<span class="nc" id="L1088">                    startIdx = i;</span>
<span class="nc" id="L1089">                    break;</span>
                }
            }
<span class="nc bnc" id="L1092" title="All 4 branches missed.">            if (startIdx &gt; -1 &amp;&amp; endIdx &gt; -1) {</span>
<span class="nc" id="L1093">                return new int[]{startIdx, endIdx};</span>
            }
        }
        
<span class="nc" id="L1097">        return new int[]{0, sortedValues.length - 1};</span>
    }
    
    public static double[] filterStatsForTranslation(
        TransformationParameters params, List&lt;FeatureComparisonStat&gt; compStats, 
        float sigmaFactor) {
        
<span class="nc bnc" id="L1104" title="All 4 branches missed.">        assert(!compStats.isEmpty());</span>
                
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (compStats.size() &lt; 2) {</span>
<span class="nc" id="L1107">            return null;</span>
        }
        
<span class="nc" id="L1110">        Transformer transformer = new Transformer();</span>
        
<span class="nc" id="L1112">        double sumTx = 0;</span>
<span class="nc" id="L1113">        double sumTy = 0;</span>
<span class="nc" id="L1114">        double[] diffX = new double[compStats.size()];</span>
<span class="nc" id="L1115">        double[] diffY = new double[compStats.size()];</span>
        
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="nc" id="L1119">            FeatureComparisonStat compStat = compStats.get(i);</span>
            
<span class="nc" id="L1121">            int x1 = compStat.getImg1Point().getX();</span>
<span class="nc" id="L1122">            int y1 = compStat.getImg1Point().getY();</span>
                        
<span class="nc" id="L1124">            int x2 = compStat.getImg2Point().getX();</span>
<span class="nc" id="L1125">            int y2 = compStat.getImg2Point().getY();</span>
            
<span class="nc" id="L1127">            double[] xy1Tr = transformer.applyTransformation(params, x1, y1);</span>
            
<span class="nc" id="L1129">            diffX[i] = xy1Tr[0] - x1;</span>
<span class="nc" id="L1130">            diffY[i] = xy1Tr[1] - y1;</span>
            
<span class="nc" id="L1132">            sumTx += diffX[i];</span>
<span class="nc" id="L1133">            sumTy += diffY[i];</span>
        }
        
<span class="nc" id="L1136">        double length = (double)compStats.size();</span>
        
<span class="nc" id="L1138">        double avgTx = sumTx/length;</span>
<span class="nc" id="L1139">        double avgTy = sumTy/length;</span>
        
<span class="nc" id="L1141">        double stDevX = 0;</span>
<span class="nc" id="L1142">        double stDevY = 0;</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        for (int i = 0; i &lt; diffX.length; ++i) {</span>
<span class="nc" id="L1144">            double d = diffX[i] - avgTx;</span>
<span class="nc" id="L1145">            stDevX += (d*d);</span>
<span class="nc" id="L1146">            d = diffY[i] - avgTy;</span>
<span class="nc" id="L1147">            stDevY += (d*d);</span>
        }
<span class="nc" id="L1149">        stDevX = (Math.sqrt(stDevX/(length - 1.0f)));</span>
<span class="nc" id="L1150">        stDevY = (Math.sqrt(stDevY/(length - 1.0f)));</span>

<span class="nc" id="L1152">        double sumDist = 0;</span>
<span class="nc" id="L1153">        double sumSSD = 0;</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        for (int i = (compStats.size() - 1); i &gt; -1; --i) {</span>
                        
<span class="nc" id="L1156">            double dx = Math.abs(diffX[i] - avgTx);</span>
<span class="nc" id="L1157">            double dy = Math.abs(diffY[i] - avgTy);</span>
            
<span class="nc bnc" id="L1159" title="All 4 branches missed.">            if ((dx &gt; (sigmaFactor * stDevX)) || (dy &gt; (sigmaFactor * stDevY))) {</span>
<span class="nc" id="L1160">                sumDist += Math.sqrt(diffX[i]*diffX[i] + diffY[i]*diffY[i]); </span>
<span class="nc" id="L1161">                sumSSD += compStats.get(i).getSumIntensitySqDiff();</span>
<span class="nc" id="L1162">                compStats.remove(i);</span>
            }
        }
<span class="nc" id="L1165">        length = compStats.size();</span>
        
<span class="nc" id="L1167">        double[] sumDistSSD = new double[2];</span>
<span class="nc" id="L1168">        sumDistSSD[0] = (sumDist/params.getScale())/length;</span>
<span class="nc" id="L1169">        sumDistSSD[1] = sumSSD/length;</span>
        
<span class="nc" id="L1171">        return sumDistSSD;</span>
    }

    public static List&lt;Integer&gt; filterForDegeneracy(List&lt;FeatureComparisonStat&gt; 
        stats) {
           
<span class="nc" id="L1177">        Map&lt;PairInt, List&lt;Integer&gt;&gt; pointIndexes = new HashMap&lt;PairInt, List&lt;Integer&gt;&gt;();</span>
        
        // filter for same pt1 first
<span class="nc" id="L1180">        FeatureComparisonStat[] statsCp = new FeatureComparisonStat[stats.size()];</span>
        
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
<span class="nc" id="L1183">            FeatureComparisonStat stat = stats.get(i);</span>
<span class="nc" id="L1184">            statsCp[i] = stat;</span>
<span class="nc" id="L1185">            List&lt;Integer&gt; indexes = pointIndexes.get(stat.getImg1Point());</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (indexes == null) {</span>
<span class="nc" id="L1187">                indexes = new ArrayList&lt;Integer&gt;();</span>
            }
<span class="nc" id="L1189">            indexes.add(Integer.valueOf(i));</span>
<span class="nc" id="L1190">            pointIndexes.put(stat.getImg1Point(), indexes);</span>
        }
        
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        for (Entry&lt;PairInt, List&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="nc" id="L1194">            List&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">            if (indexes.size() &lt; 2) {</span>
<span class="nc" id="L1196">                continue;</span>
            }
<span class="nc" id="L1198">            float minCost = Float.MAX_VALUE;</span>
<span class="nc" id="L1199">            Integer minCostIndex = null;</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">            for (Integer index : indexes) {</span>
<span class="nc" id="L1201">                FeatureComparisonStat stat = statsCp[index.intValue()];</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                if (stat == null) {</span>
<span class="nc" id="L1203">                    continue;</span>
                }
<span class="nc" id="L1205">                float cost = stat.getSumIntensitySqDiff();</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">                if (cost &lt; minCost) {</span>
<span class="nc" id="L1207">                    minCost = cost;</span>
<span class="nc" id="L1208">                    minCostIndex = index;</span>
                }
<span class="nc" id="L1210">            }</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">            if (minCostIndex != null) {</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                for (Integer index : indexes) {</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                    if (index.equals(minCostIndex)) {</span>
<span class="nc" id="L1214">                        continue;</span>
                    }
<span class="nc" id="L1216">                    statsCp[index.intValue()] = null;</span>
<span class="nc" id="L1217">                } </span>
            }
<span class="nc" id="L1219">        }</span>
        
<span class="nc" id="L1221">        pointIndexes.clear();</span>
        
        // filter for same point2
        
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        for (int i = 0; i &lt; statsCp.length; ++i) {</span>
<span class="nc" id="L1226">            FeatureComparisonStat stat = statsCp[i];</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">            if (stat == null) {</span>
<span class="nc" id="L1228">                continue;</span>
            }
<span class="nc" id="L1230">            List&lt;Integer&gt; indexes = pointIndexes.get(stat.getImg2Point());</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (indexes == null) {</span>
<span class="nc" id="L1232">                indexes = new ArrayList&lt;Integer&gt;();</span>
            }
<span class="nc" id="L1234">            indexes.add(Integer.valueOf(i));</span>
<span class="nc" id="L1235">            pointIndexes.put(stat.getImg2Point(), indexes);</span>
        }
        
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        for (Entry&lt;PairInt, List&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="nc" id="L1239">            List&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            if (indexes.size() &lt; 2) {</span>
<span class="nc" id="L1241">                continue;</span>
            }
<span class="nc" id="L1243">            float minCost = Float.MAX_VALUE;</span>
<span class="nc" id="L1244">            Integer minCostIndex = null;</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            for (Integer index : indexes) {</span>
<span class="nc" id="L1246">                FeatureComparisonStat stat = statsCp[index.intValue()];</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">                if (stat == null) {</span>
<span class="nc" id="L1248">                    continue;</span>
                }
<span class="nc" id="L1250">                float cost = stat.getSumIntensitySqDiff();</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">                if (cost &lt; minCost) {</span>
<span class="nc" id="L1252">                    minCost = cost;</span>
<span class="nc" id="L1253">                    minCostIndex = index;</span>
                }
<span class="nc" id="L1255">            }</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            if (minCostIndex != null) {</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                for (Integer index : indexes) {</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">                    if (index.equals(minCostIndex)) {</span>
<span class="nc" id="L1259">                        continue;</span>
                    }
<span class="nc" id="L1261">                    statsCp[index.intValue()] = null;</span>
<span class="nc" id="L1262">                } </span>
            }
<span class="nc" id="L1264">        }</span>
        
<span class="nc" id="L1266">        stats.clear();</span>
        // store removed indexes
<span class="nc" id="L1268">        List&lt;Integer&gt; removed = new ArrayList&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        for (int i = 0; i &lt; statsCp.length; ++i) {</span>
<span class="nc" id="L1271">            FeatureComparisonStat stat = statsCp[i];</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">            if (stat == null) {</span>
<span class="nc" id="L1273">                removed.add(Integer.valueOf(i));</span>
<span class="nc" id="L1274">                continue;</span>
            }
<span class="nc" id="L1276">            stats.add(stat);</span>
        }
        
<span class="nc" id="L1279">        Collections.sort(removed);</span>
        
<span class="nc" id="L1281">        return removed;</span>
    }
    
    public static double calculateCombinedIntensityStat(List&lt;FeatureComparisonStat&gt; 
        compStats) {
        
<span class="nc bnc" id="L1287" title="All 2 branches missed.">        if (compStats.isEmpty()) {</span>
<span class="nc" id="L1288">            return Double.POSITIVE_INFINITY;</span>
        }
        
<span class="nc" id="L1291">        double sum = 0;</span>
        
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        for (FeatureComparisonStat compStat : compStats) {</span>
<span class="nc" id="L1294">            sum += compStat.getSumIntensitySqDiff();</span>
<span class="nc" id="L1295">        }</span>
        
<span class="nc" id="L1297">        sum /= (double) compStats.size();</span>
        
<span class="nc" id="L1299">        return sum;</span>
    }
    
    public static double[][] getBoundsOfIntersectionInFrame2(TransformationParameters 
        parameters, int img1Width, int img1Height, int img2Width, int img2Height) {
        
        //calculate the intersection of the 2 images
        
<span class="nc" id="L1307">        MatchedPointsTransformationCalculator tc = </span>
            new MatchedPointsTransformationCalculator();
        
<span class="nc" id="L1310">        Transformer transformer = new Transformer();</span>
        
<span class="nc" id="L1312">        TransformationParameters revParams = tc.swapReferenceFrames(parameters);</span>
        
        /*
        
       / \   ( tr )    ( tr )            (x2q3, y2q3)      (x2q4, y2q4)
        |
        |
        0    ( tr )    ( tr )            (x2q2, y2q2)      (x2q1, y2q1)
          0 --&gt;
        
        */
        
        // determine intersection of img2 with img1 in img1 reference frame
<span class="nc" id="L1325">        double[] q1Tr = transformer.applyTransformation(revParams, </span>
            img2Width - 1, 0);
        
<span class="nc" id="L1328">        double[] q2Tr = transformer.applyTransformation(revParams, </span>
            0, 0);
        
<span class="nc" id="L1331">        double[] q3Tr = transformer.applyTransformation(revParams, </span>
            0, img2Height - 1);
        
<span class="nc" id="L1334">        double[] q4Tr = transformer.applyTransformation(revParams, </span>
            img2Width - 1, img2Height - 1);
        
        // if the transformed bounds are off image, reset the bounds to img1 bounds
<span class="nc" id="L1338">        double[][] img1Intersection = new double[4][2];</span>
<span class="nc" id="L1339">        img1Intersection[0] = q1Tr;</span>
<span class="nc" id="L1340">        img1Intersection[1] = q2Tr;</span>
<span class="nc" id="L1341">        img1Intersection[2] = q3Tr;</span>
<span class="nc" id="L1342">        img1Intersection[3] = q4Tr;</span>
        
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        for (double[] xyTr : img1Intersection) {</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            if (xyTr[0] &lt; 0) {</span>
<span class="nc" id="L1346">                xyTr[0] = 0;</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            } else if (xyTr[0] &gt; (img1Width - 1)) {</span>
<span class="nc" id="L1348">                xyTr[0] = (img1Width - 1);</span>
            }
<span class="nc bnc" id="L1350" title="All 2 branches missed.">            if (xyTr[1] &lt; 0) {</span>
<span class="nc" id="L1351">                xyTr[1] = 0;</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            } else if (xyTr[1] &gt; (img1Height - 1)) {</span>
<span class="nc" id="L1353">                xyTr[1] = (img1Height - 1);</span>
            }
        }
        
        // transform the img1 intersection into reference frame of img2
<span class="nc" id="L1358">        double[] q1TrTr = transformer.applyTransformation(parameters, q1Tr[0], q1Tr[1]);</span>
        
<span class="nc" id="L1360">        double[] q2TrTr = transformer.applyTransformation(parameters, q2Tr[0], q2Tr[1]);</span>
        
<span class="nc" id="L1362">        double[] q3TrTr = transformer.applyTransformation(parameters, q3Tr[0], q3Tr[1]);</span>
        
<span class="nc" id="L1364">        double[] q4TrTr = transformer.applyTransformation(parameters, q4Tr[0], q4Tr[1]);</span>
        
<span class="nc" id="L1366">        double[][] img2Intersection = new double[4][2];</span>
<span class="nc" id="L1367">        img2Intersection[0] = q1TrTr;</span>
<span class="nc" id="L1368">        img2Intersection[1] = q2TrTr;</span>
<span class="nc" id="L1369">        img2Intersection[2] = q3TrTr;</span>
<span class="nc" id="L1370">        img2Intersection[3] = q4TrTr;</span>
        
<span class="nc bnc" id="L1372" title="All 2 branches missed.">        for (double[] xyTr : img2Intersection) {</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">            if (xyTr[0] &lt; 0) {</span>
<span class="nc" id="L1374">                xyTr[0] = 0;</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">            } else if (xyTr[0] &gt; (img2Width - 1)) {</span>
<span class="nc" id="L1376">                xyTr[0] = (img2Width - 1);</span>
            }
<span class="nc bnc" id="L1378" title="All 2 branches missed.">            if (xyTr[1] &lt; 0) {</span>
<span class="nc" id="L1379">                xyTr[1] = 0;</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">            } else if (xyTr[1] &gt; (img2Height - 1)) {</span>
<span class="nc" id="L1381">                xyTr[1] = (img2Height - 1);</span>
            }
        }
        
<span class="nc" id="L1385">        return img2Intersection;</span>
    }

    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets2(
        List&lt;TransformationParameters&gt; paramsList, int binFactor1, int binFactor2) {
        
<span class="nc" id="L1391">        int transTol = 30;</span>
<span class="nc bnc" id="L1392" title="All 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="nc" id="L1393">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="nc" id="L1396">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="nc" id="L1399">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="nc" id="L1402">        Set&lt;Integer&gt; alreadyCombined = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
            
<span class="nc" id="L1406">            Integer key = Integer.valueOf(i);</span>
                        
<span class="nc bnc" id="L1408" title="All 2 branches missed.">            if (alreadyCombined.contains(key)) {</span>
<span class="nc" id="L1409">                continue;</span>
            }
            
<span class="nc" id="L1412">            TransformationParameters params0 = paramsList.get(i);</span>
            
<span class="nc" id="L1414">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
                        
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            for (int j = (i + 1); j &lt; paramsList.size(); ++j) {</span>
                
<span class="nc" id="L1418">                Integer key2 = Integer.valueOf(j);</span>
                
<span class="nc bnc" id="L1420" title="All 2 branches missed.">                if (alreadyCombined.contains(key2)) {</span>
<span class="nc" id="L1421">                    continue;</span>
                }
                
<span class="nc" id="L1424">                TransformationParameters compare = paramsList.get(j);</span>
                
<span class="nc" id="L1426">                float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L1427">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="nc" id="L1429">                    continue;</span>
                }
<span class="nc" id="L1431">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="nc" id="L1433">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="nc" id="L1437">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="nc" id="L1438">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="nc bnc" id="L1439" title="All 4 branches missed.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="nc" id="L1440">                    continue;</span>
                }
<span class="nc bnc" id="L1442" title="All 2 branches missed.">                if (!alreadyCombined.contains(key)) {</span>
<span class="nc" id="L1443">                    alreadyCombined.add(key);</span>
                }
<span class="nc" id="L1445">                alreadyCombined.add(key2);</span>
                
<span class="nc" id="L1447">                set.add(params0);</span>
<span class="nc" id="L1448">                set.add(compare);</span>
            }
<span class="nc bnc" id="L1450" title="All 2 branches missed.">            if (set.isEmpty()) {</span>
<span class="nc" id="L1451">                combinedParams.add(params0);</span>
            } else {
<span class="nc" id="L1453">                similarSets.add(set);</span>
            }
        }
        
        // use histograms to remove translation outliers in similar sets

<span class="nc bnc" id="L1459" title="All 2 branches missed.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="nc" id="L1461">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="nc" id="L1463">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="nc" id="L1464">            Set&lt;Integer&gt; unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">            for (Integer ind : unique) {</span>
<span class="nc" id="L1466">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="nc" id="L1467">            }</span>
            
<span class="nc" id="L1469">            filter(similar, keep);</span>
<span class="nc" id="L1470">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="nc" id="L1471">            unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            for (Integer ind : unique) {</span>
<span class="nc" id="L1473">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="nc" id="L1474">            }</span>
<span class="nc" id="L1475">            filter(similar, keep);</span>
            
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L1478">                continue;</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            } else if (similar.size() == 1) {</span>
<span class="nc" id="L1480">                combinedParams.add(similar.get(0));</span>
<span class="nc" id="L1481">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="nc" id="L1486">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="nc" id="L1487">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="nc" id="L1488">            combinedParams.add(params);</span>
<span class="nc" id="L1489">        }</span>
        
<span class="nc" id="L1491">        return combinedParams;</span>
    }
    
    /**
     * a method to determine the intersection of transformed image 1 with
     * image 2 and then examine the distribution of stats's points in 
     * 4 quadrants of the intersection to return whether stats are present in
     * all quadrants.  A caveat of the method is that not all of the 
     * intersection necessarily has image details which could be matched, for 
     * example, clear sky does not have corners using the methods here.
     * @param stats
     * @param params
     * @param image1Width
     * @param image1Height
     * @param image2Width
     * @param image2Height
     * @return 
     */
    public static boolean statsCoverIntersection(List&lt;FeatureComparisonStat&gt; stats,
        TransformationParameters params, int image1Width, int image1Height,
        int image2Width, int image2Height) {
        
        /*
        calculate the intersection of the 2 images.
        divide the region into 4 parts (2 vertical and 2 horizontal) by noting
        the 4 boundary points for each and making a polygon for each.
        
        then use point in polygon tests to count the number of stats.point2's
        in each of the 4 regions.        
        */
        
        /*
       / \   ( tr )    ( tr )            (x2q2, y2q2)  d5   (x2q3, y2q3)
        |
        |                                 d2           d3             d4
        |
        0    ( tr )    ( tr )            (x2q1, y2q1)  d1   (x2q0, y2q0)
          0 --&gt;
        */
        
<span class="nc" id="L1531">        double[][] img2Intersection = MiscStats.getBoundsOfIntersectionInFrame2(</span>
            params, image1Width, image1Height, image2Width, image2Height);
        
<span class="nc" id="L1534">        float[] d1 = new float[]{</span>
            (float)((img2Intersection[0][0] + img2Intersection[1][0])/2.f),
            (float)((img2Intersection[0][1] + img2Intersection[1][1])/2.f)};     
<span class="nc" id="L1537">        float[] d2 = new float[]{</span>
            (float)((img2Intersection[1][0] + img2Intersection[2][0])/2.f),
            (float)((img2Intersection[1][1] + img2Intersection[2][1])/2.f)};
<span class="nc" id="L1540">        float[] d4 = new float[]{</span>
            (float)((img2Intersection[0][0] + img2Intersection[3][0])/2.f),
            (float)((img2Intersection[0][1] + img2Intersection[3][1])/2.f)};
<span class="nc" id="L1543">        float[] d5 = new float[]{</span>
            (float)((img2Intersection[2][0] + img2Intersection[3][0])/2.f),
            (float)((img2Intersection[2][1] + img2Intersection[3][1])/2.f)};
<span class="nc" id="L1546">        float[] d3 = new float[]{(d2[0] + d4[0])/2.f, (d1[1] + d5[1])/2.f};</span>
        
<span class="nc" id="L1548">        float[] xPoly0 = new float[5];</span>
<span class="nc" id="L1549">        float[] yPoly0 = new float[5];</span>
<span class="nc" id="L1550">        xPoly0[0] = (float)img2Intersection[0][0];</span>
<span class="nc" id="L1551">        yPoly0[0] = (float)img2Intersection[0][1];</span>
<span class="nc" id="L1552">        xPoly0[1] = d1[0];</span>
<span class="nc" id="L1553">        yPoly0[1] = d1[1];</span>
<span class="nc" id="L1554">        xPoly0[2] = d3[0];</span>
<span class="nc" id="L1555">        yPoly0[2] = d3[1];</span>
<span class="nc" id="L1556">        xPoly0[3] = d4[0];</span>
<span class="nc" id="L1557">        yPoly0[3] = d4[1];</span>
<span class="nc" id="L1558">        xPoly0[4] = xPoly0[0];</span>
<span class="nc" id="L1559">        yPoly0[4] = yPoly0[0];</span>

        /*
       / \   ( tr )    ( tr )            (x2q2, y2q2)  d5   (x2q3, y2q3)
        |
        |                                 d2           d3             d4
        |
        0    ( tr )    ( tr )            (x2q1, y2q1)  d1   (x2q0, y2q0)
          0 --&gt;
        */
        
<span class="nc" id="L1570">        float[] xPoly1 = new float[5];</span>
<span class="nc" id="L1571">        float[] yPoly1 = new float[5];</span>
<span class="nc" id="L1572">        xPoly1[0] = d1[0];</span>
<span class="nc" id="L1573">        yPoly1[0] = d1[1];</span>
<span class="nc" id="L1574">        xPoly1[1] = (float)img2Intersection[1][0];</span>
<span class="nc" id="L1575">        yPoly1[1] = (float)img2Intersection[1][1];</span>
<span class="nc" id="L1576">        xPoly1[2] = d2[0];</span>
<span class="nc" id="L1577">        yPoly1[2] = d2[1];</span>
<span class="nc" id="L1578">        xPoly1[3] = d3[0];</span>
<span class="nc" id="L1579">        yPoly1[3] = d3[1];</span>
<span class="nc" id="L1580">        xPoly1[4] = xPoly1[0];</span>
<span class="nc" id="L1581">        yPoly1[4] = yPoly1[0];</span>
        
<span class="nc" id="L1583">        float[] xPoly2 = new float[5];</span>
<span class="nc" id="L1584">        float[] yPoly2 = new float[5];</span>
<span class="nc" id="L1585">        xPoly2[0] = d3[0];</span>
<span class="nc" id="L1586">        yPoly2[0] = d3[1];</span>
<span class="nc" id="L1587">        xPoly2[1] = d2[0];</span>
<span class="nc" id="L1588">        yPoly2[1] = d2[1];</span>
<span class="nc" id="L1589">        xPoly2[2] = (float)img2Intersection[2][0];</span>
<span class="nc" id="L1590">        yPoly2[2] = (float)img2Intersection[2][1];</span>
<span class="nc" id="L1591">        xPoly2[3] = d5[0];</span>
<span class="nc" id="L1592">        yPoly2[3] = d5[1];</span>
<span class="nc" id="L1593">        xPoly2[4] = xPoly2[0];</span>
<span class="nc" id="L1594">        yPoly2[4] = yPoly2[0];</span>
        
        /*
       / \   ( tr )    ( tr )            (x2q2, y2q2)  d5   (x2q3, y2q3)
        |
        |                                 d2           d3             d4
        |
        0    ( tr )    ( tr )            (x2q1, y2q1)  d1   (x2q0, y2q0)
          0 --&gt;
        */
        
<span class="nc" id="L1605">        float[] xPoly3 = new float[5];</span>
<span class="nc" id="L1606">        float[] yPoly3 = new float[5];</span>
<span class="nc" id="L1607">        xPoly3[0] = d4[0];</span>
<span class="nc" id="L1608">        yPoly3[0] = d4[1];</span>
<span class="nc" id="L1609">        xPoly3[1] = d3[0];</span>
<span class="nc" id="L1610">        yPoly3[1] = d3[1];</span>
<span class="nc" id="L1611">        xPoly3[2] = d5[0];</span>
<span class="nc" id="L1612">        yPoly3[2] = d5[1];</span>
<span class="nc" id="L1613">        xPoly3[3] = (float)img2Intersection[3][0];</span>
<span class="nc" id="L1614">        yPoly3[3] = (float)img2Intersection[3][1];</span>
<span class="nc" id="L1615">        xPoly3[4] = xPoly3[0];</span>
<span class="nc" id="L1616">        yPoly3[4] = yPoly3[0];</span>
        
<span class="nc" id="L1618">        PointInPolygon poly = new PointInPolygon();</span>
        
<span class="nc" id="L1620">        int[] count = new int[4];</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="nc" id="L1622">            int x = stat.getImg2Point().getX() * stat.getBinFactor2();</span>
<span class="nc" id="L1623">            int y = stat.getImg2Point().getY() * stat.getBinFactor2();</span>
<span class="nc" id="L1624">            boolean isIn = poly.isInSimpleCurve(x, y, xPoly0, yPoly0, 5);</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            if (isIn) {</span>
<span class="nc" id="L1626">                count[0]++;</span>
            } else {
<span class="nc" id="L1628">                isIn = poly.isInSimpleCurve(x, y, xPoly1, yPoly1, 5);</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                if (isIn) {</span>
<span class="nc" id="L1630">                    count[1]++;</span>
                } else {
<span class="nc" id="L1632">                    isIn = poly.isInSimpleCurve(x, y, xPoly2, yPoly2, 5);</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">                    if (isIn) {</span>
<span class="nc" id="L1634">                        count[2]++;</span>
                    } else {
<span class="nc" id="L1636">                        isIn = poly.isInSimpleCurve(x, y, xPoly3, yPoly3, 5);</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">                        if (isIn) {</span>
<span class="nc" id="L1638">                            count[3]++;</span>
                        }
                    }
                }
            }
<span class="nc" id="L1643">        }</span>
        
<span class="nc" id="L1645">        int nq = 0;</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        for (int c : count) {</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L1648">                nq++;</span>
            }
        }
        
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        return (nq == 4);</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
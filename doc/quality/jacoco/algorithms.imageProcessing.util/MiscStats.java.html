<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscStats.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.util</a> &gt; <span class="el_source">MiscStats.java</span></div><h1>MiscStats.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.util;

import algorithms.imageProcessing.FeatureComparisonStat;
import algorithms.imageProcessing.FeatureMatcher;
import algorithms.imageProcessing.MatchedPointsTransformationCalculator;
import algorithms.imageProcessing.TransformationParameters;
import algorithms.imageProcessing.Transformer;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import com.climbwithyourfeet.clustering.DTClusterFinder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">public class MiscStats {</span>
    
    public static int[] filterForScaleAndRotation(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L35" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L36">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L38">                indexes[i] = i;</span>
            }
<span class="nc" id="L40">            return indexes;</span>
        }
        
<span class="nc" id="L43">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L44">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L45">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L47">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L49">                r = 360 - r;</span>
            }
<span class="nc" id="L51">            rotations[i] = r;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L53">                minRD = r;</span>
            }
<span class="nc bnc" id="L55" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L56">                maxRD = r;</span>
            }
        }

<span class="nc" id="L60">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L61">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L62">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L64">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L66">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L68" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L69">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L72">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L74">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L77">        float factor = (int)(maxRD - minRD)/diffS;</span>
<span class="nc" id="L78">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L79">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L81">            float s = scales[i];</span>
<span class="nc" id="L82">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L84">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L88">        Set&lt;PairIntWithIndex&gt; points = new HashSet&lt;PairIntWithIndex&gt;();</span>

<span class="nc bnc" id="L90" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L91">            float x = rotations[i];</span>
<span class="nc" id="L92">            float y = scales[i];</span>
<span class="nc" id="L93">            PairIntWithIndex p = new PairIntWithIndex(Math.round(x),</span>
<span class="nc" id="L94">                Math.round(y), i);</span>
<span class="nc" id="L95">            points.add(p);</span>
        }

<span class="nc" id="L98">        int dimen1 = (int)(Math.ceil(maxRD) + 1);</span>
<span class="nc" id="L99">        int dimen2 = (int)(Math.ceil(maxS) + 1);</span>

<span class="nc" id="L101">        DTClusterFinder&lt;PairIntWithIndex&gt; cFinder </span>
            = new DTClusterFinder&lt;PairIntWithIndex&gt;(points, dimen1, dimen2);
        //cFinder.setToDebug();
<span class="nc" id="L104">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L106">        cFinder.findClusters();</span>

<span class="nc" id="L108">        int n = cFinder.getNumberOfClusters();</span>
        
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L111">            return new int[0];</span>
        }
        
<span class="nc" id="L114">        int maxN = Integer.MIN_VALUE;</span>
<span class="nc" id="L115">        int maxNIdx = -1;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L117">            int ns = cFinder.getCluster(i).size();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (ns &gt; maxN) {</span>
<span class="nc" id="L119">                maxN = ns;</span>
<span class="nc" id="L120">                maxNIdx = i;</span>
            }
        }
<span class="nc" id="L123">        int[] indexes = new int[maxN];</span>
<span class="nc" id="L124">        int count = 0;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        for (PairIntWithIndex p : cFinder.getCluster(maxNIdx)) {</span>
<span class="nc" id="L126">            indexes[count] = p.getPixIndex();</span>
<span class="nc" id="L127">            count++;</span>
<span class="nc" id="L128">        }</span>
        
<span class="nc" id="L130">        return indexes;</span>
    }

    public static int[] filterForScaleAndRotationUsingHist(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L137">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L139">                indexes[i] = i;</span>
            }
<span class="nc" id="L141">            return indexes;</span>
        }
        
<span class="nc" id="L144">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L145">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L146">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L148">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L150">                r = 360 - r;</span>
            }
<span class="nc" id="L152">            rotations[i] = r;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L154">                minRD = r;</span>
            }
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L157">                maxRD = r;</span>
            }
        }

<span class="nc" id="L161">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L162">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L163">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L165">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L167">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L170">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L173">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L175">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L178">        float factor = (int)(maxRD - minRD)/diffS;</span>
<span class="nc" id="L179">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L180">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L182">            float s = scales[i];</span>
<span class="nc" id="L183">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L185">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L189">        HistogramHolder rHist = Histogram.createSimpleHistogram(25.f, rotations, </span>
<span class="nc" id="L190">            Errors.populateYErrorsBySqrt(rotations));</span>
        
<span class="nc" id="L192">        HistogramHolder sHist = Histogram.createSimpleHistogram(25.f, scales, </span>
<span class="nc" id="L193">            Errors.populateYErrorsBySqrt(scales));</span>
        
<span class="nc" id="L195">        int[] rYMaxIdx = MiscMath.findYMaxIndexes(rHist.getYHist());</span>
        
<span class="nc" id="L197">        int[] sYMaxIdx = MiscMath.findYMaxIndexes(sHist.getYHist());</span>
        
<span class="nc" id="L199">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (rYMaxIdx != null) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            for (int vIdx : rYMaxIdx) {</span>
<span class="nc" id="L203">                float v = rHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                for (int i = 0; i &lt; rotations.length; ++i) {</span>
<span class="nc" id="L205">                    float diff = Math.abs(rotations[i] - v);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L207">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (sYMaxIdx != null) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            for (int vIdx : sYMaxIdx) {</span>
<span class="nc" id="L215">                float v = sHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L217">                    float diff = Math.abs(scales[i] - v);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L219">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L225">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L226">        int count = 0;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L228">            indexes[count] = index.intValue();</span>
<span class="nc" id="L229">            count++;</span>
<span class="nc" id="L230">        }</span>
        
<span class="nc" id="L232">        return indexes;</span>
    }
    
    public static int[] filterForRotationUsingHist(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L239">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L241">                indexes[i] = i;</span>
            }
<span class="nc" id="L243">            return indexes;</span>
        }
        
<span class="nc" id="L246">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L247">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L248">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L250">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L252">                r = 360 - r;</span>
            }
<span class="nc" id="L254">            rotations[i] = r;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L256">                minRD = r;</span>
            }
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L259">                maxRD = r;</span>
            }
        }

<span class="nc" id="L263">        HistogramHolder rHist = Histogram.createSimpleHistogram(25.f, rotations, </span>
<span class="nc" id="L264">            Errors.populateYErrorsBySqrt(rotations));</span>
        
<span class="nc" id="L266">        int[] rYMaxIdx = MiscMath.findYMaxIndexes(rHist.getYHist());</span>
        
<span class="nc" id="L268">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (rYMaxIdx != null) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            for (int vIdx : rYMaxIdx) {</span>
<span class="nc" id="L272">                float v = rHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                for (int i = 0; i &lt; rotations.length; ++i) {</span>
<span class="nc" id="L274">                    float diff = Math.abs(rotations[i] - v);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L276">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L282">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L283">        int count = 0;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L285">            indexes[count] = index.intValue();</span>
<span class="nc" id="L286">            count++;</span>
<span class="nc" id="L287">        }</span>
        
<span class="nc" id="L289">        return indexes;</span>
    }

    public static int[] filterForScaleUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (paramsList.size() &lt; 3) {</span>
<span class="nc" id="L296">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L298">                indexes[i] = i;</span>
            }
<span class="nc" id="L300">            return indexes;</span>
        }
        
<span class="nc" id="L303">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L304">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L305">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L307">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L309">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L312">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L315">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L317">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L320">        float factor = 360/diffS;</span>
<span class="nc" id="L321">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L322">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L324">            float s = scales[i];</span>
<span class="nc" id="L325">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L327">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L331">        HistogramHolder sHist = Histogram.createSimpleHistogram(25.f, scales, </span>
<span class="nc" id="L332">            Errors.populateYErrorsBySqrt(scales));</span>
                
<span class="nc" id="L334">        int[] sYMaxIdx = MiscMath.findYMaxIndexes(sHist.getYHist());</span>
        
<span class="nc" id="L336">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (sYMaxIdx != null) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            for (int vIdx : sYMaxIdx) {</span>
<span class="nc" id="L340">                float v = sHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L342">                    float diff = Math.abs(scales[i] - v);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L344">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L350">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L351">        int count = 0;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L353">            indexes[count] = index.intValue();</span>
<span class="nc" id="L354">            count++;</span>
<span class="nc" id="L355">        }</span>
        
<span class="nc" id="L357">        return indexes;</span>
    }
    
    public static int[] filterForTranslationXUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {        
        
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (paramsList.size() &lt; 3) {</span>
<span class="fc" id="L364">            int[] indexes = new int[paramsList.size()];</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L366">                indexes[i] = i;</span>
            }
<span class="fc" id="L368">            return indexes;</span>
        }
        
<span class="fc" id="L371">        float minX = Float.MAX_VALUE;</span>
<span class="fc" id="L372">        float maxX = Float.MIN_VALUE;</span>
<span class="fc" id="L373">        float[] translationXs = new float[paramsList.size()];</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L375">            translationXs[i] = paramsList.get(i).getTranslationX();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            if (translationXs[i] &lt; minX) {</span>
<span class="fc" id="L377">                minX = translationXs[i];</span>
            }
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (translationXs[i] &gt; maxX) {</span>
<span class="fc" id="L380">                maxX = translationXs[i];</span>
            }
        }
        
<span class="fc" id="L384">        HistogramHolder tXHist = Histogram.createSimpleHistogram(translationXs, </span>
<span class="fc" id="L385">            Errors.populateYErrorsBySqrt(translationXs));</span>
                
<span class="fc" id="L387">        int[] txMaxIdx = MiscMath.findYMaxIndexes(tXHist.getYHist());</span>
        
<span class="fc" id="L389">        float binSize = tXHist.getXHist()[1] - tXHist.getXHist()[0];</span>
        
<span class="fc" id="L391">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (txMaxIdx != null) {</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            for (int vIdx : txMaxIdx) {</span>
<span class="fc" id="L395">                float v = tXHist.getXHist()[vIdx];</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">                for (int i = 0; i &lt; translationXs.length; ++i) {</span>
<span class="fc" id="L397">                    float diff = Math.abs(translationXs[i] - v);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                    if (diff &lt;= 1.1*binSize) {</span>
<span class="fc" id="L399">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="fc" id="L405">        int[] indexes = new int[keep.size()];</span>
<span class="fc" id="L406">        int count = 0;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        for (Integer index : keep) {</span>
<span class="fc" id="L408">            indexes[count] = index.intValue();</span>
<span class="fc" id="L409">            count++;</span>
<span class="fc" id="L410">        }</span>
        
<span class="fc" id="L412">        return indexes;</span>
    }
    
    public static int[] filterForTranslationYUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {
        
<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (paramsList.size() &lt; 3) {</span>
<span class="fc" id="L419">            int[] indexes = new int[paramsList.size()];</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L421">                indexes[i] = i;</span>
            }
<span class="fc" id="L423">            return indexes;</span>
        }
        
<span class="fc" id="L426">        float minY = Float.MAX_VALUE;</span>
<span class="fc" id="L427">        float maxY = Float.MIN_VALUE;</span>
<span class="fc" id="L428">        float[] translationYs = new float[paramsList.size()];</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L430">            translationYs[i] = paramsList.get(i).getTranslationY();</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (translationYs[i] &lt; minY) {</span>
<span class="fc" id="L432">                minY = translationYs[i];</span>
            }
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (translationYs[i] &gt; maxY) {</span>
<span class="fc" id="L435">                maxY = translationYs[i];</span>
            }
        }
        
<span class="fc" id="L439">        HistogramHolder tYHist = Histogram.createSimpleHistogram(translationYs, </span>
<span class="fc" id="L440">            Errors.populateYErrorsBySqrt(translationYs));</span>
                
<span class="fc" id="L442">        int[] tyMaxIdx = MiscMath.findYMaxIndexes(tYHist.getYHist());</span>
        
<span class="fc" id="L444">        float binSize = tYHist.getXHist()[1] - tYHist.getXHist()[0];</span>
        
<span class="fc" id="L446">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (tyMaxIdx != null) {</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            for (int vIdx : tyMaxIdx) {</span>
<span class="fc" id="L450">                float v = tYHist.getXHist()[vIdx];</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                for (int i = 0; i &lt; translationYs.length; ++i) {</span>
<span class="fc" id="L452">                    float diff = Math.abs(translationYs[i] - v);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                    if (diff &lt;= 1.1*binSize) {</span>
<span class="fc" id="L454">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="fc" id="L460">        int[] indexes = new int[keep.size()];</span>
<span class="fc" id="L461">        int count = 0;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (Integer index : keep) {</span>
<span class="fc" id="L463">            indexes[count] = index.intValue();</span>
<span class="fc" id="L464">            count++;</span>
<span class="fc" id="L465">        }</span>
        
<span class="fc" id="L467">        return indexes;</span>
    }
    
    public static int[] filterForTranslation(List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L473">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L475">                indexes[i] = i;</span>
            }
<span class="nc" id="L477">            return indexes;</span>
        }
        
<span class="nc" id="L480">        float minTX = Float.MAX_VALUE;</span>
<span class="nc" id="L481">        float maxTX = Float.MIN_VALUE;</span>
<span class="nc" id="L482">        float[] transX = new float[paramsList.size()];</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L484">            float v = paramsList.get(i).getTranslationX();</span>
<span class="nc" id="L485">            transX[i] = v;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (v &lt; minTX) {</span>
<span class="nc" id="L487">                minTX = v;</span>
            }
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (v &gt; maxTX) {</span>
<span class="nc" id="L490">                maxTX = v;</span>
            }
        }
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (minTX != 0) {</span>
            // shift the values so that '1' is the lowest value... 
            // dt in clustering runtime is O(dimension * lg_2(dimension))
<span class="nc" id="L496">            float offset = -1*minTX;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            for (int i = 0; i &lt; transX.length; ++i) {</span>
<span class="nc" id="L498">                transX[i] += (offset + 1);</span>
            }
<span class="nc" id="L500">            minTX += (offset + 1);</span>
<span class="nc" id="L501">            maxTX += (offset + 1);</span>
        }
        
<span class="nc" id="L504">        float minTY = Float.MAX_VALUE;</span>
<span class="nc" id="L505">        float maxTY = Float.MIN_VALUE;</span>
<span class="nc" id="L506">        float[] transY = new float[paramsList.size()];</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L508">            float v = paramsList.get(i).getTranslationY();</span>
<span class="nc" id="L509">            transY[i] = v;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (v &lt; minTY) {</span>
<span class="nc" id="L511">                minTY = v;</span>
            }
<span class="nc bnc" id="L513" title="All 2 branches missed.">            if (v &gt; maxTY) {</span>
<span class="nc" id="L514">                maxTY = v;</span>
            }
        }
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (minTY != 0) {</span>
            // shift the values so that '1' is the lowest value... 
            // dt in clustering runtime is O(dimension * lg_2(dimension))
<span class="nc" id="L520">            float offset = -1*minTY;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">            for (int i = 0; i &lt; transY.length; ++i) {</span>
<span class="nc" id="L522">                transY[i] += (offset + 1);</span>
            }
<span class="nc" id="L524">            minTY += (offset + 1);</span>
<span class="nc" id="L525">            maxTY += (offset + 1);</span>
        }
        
<span class="nc bnc" id="L528" title="All 4 branches missed.">        if ((maxTX &gt; 1000) || (maxTY &gt; 1000)) {</span>
            //TODO: implement a histogram version
        }
        
<span class="nc" id="L532">        Set&lt;PairIntWithIndex&gt; points = new HashSet&lt;PairIntWithIndex&gt;();</span>

<span class="nc bnc" id="L534" title="All 2 branches missed.">        for (int i = 0; i &lt; transX.length; ++i) {</span>
<span class="nc" id="L535">            float x = transX[i];</span>
<span class="nc" id="L536">            float y = transY[i];</span>
<span class="nc" id="L537">            PairIntWithIndex p = new PairIntWithIndex(Math.round(x),</span>
<span class="nc" id="L538">                Math.round(y), i);</span>
<span class="nc" id="L539">            points.add(p);</span>
        }

<span class="nc" id="L542">        int dimen1 = (int)(Math.ceil(maxTX) + 1);</span>
<span class="nc" id="L543">        int dimen2 = (int)(Math.ceil(maxTY) + 1);</span>

<span class="nc" id="L545">        DTClusterFinder&lt;PairIntWithIndex&gt; cFinder </span>
            = new DTClusterFinder&lt;PairIntWithIndex&gt;(points, dimen1, dimen2);
        //cFinder.setToDebug();
<span class="nc" id="L548">        cFinder.setThreshholdFactor(0.75f);</span>
<span class="nc" id="L549">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L551">        cFinder.findClusters();</span>

<span class="nc" id="L553">        int n = cFinder.getNumberOfClusters();</span>
        
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L556">            return new int[0];</span>
        }
        
<span class="nc" id="L559">        int maxN = Integer.MIN_VALUE;</span>
<span class="nc" id="L560">        int maxNIdx = -1;</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L562">            int ns = cFinder.getCluster(i).size();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (ns &gt; maxN) {</span>
<span class="nc" id="L564">                maxN = ns;</span>
<span class="nc" id="L565">                maxNIdx = i;</span>
            }
        }
<span class="nc" id="L568">        int[] indexes = new int[maxN];</span>
<span class="nc" id="L569">        int count = 0;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (PairIntWithIndex p : cFinder.getCluster(maxNIdx)) {</span>
<span class="nc" id="L571">            indexes[count] = p.getPixIndex();</span>
<span class="nc" id="L572">            count++;</span>
<span class="nc" id="L573">        }</span>
        
<span class="nc" id="L575">        return indexes;</span>
    }

    public static boolean standardDeviationsAreSmall(TransformationParameters params) {

<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (params.getStandardDeviations() == null) {</span>
<span class="nc" id="L581">            return false;</span>
        }
        
        // calculation
<span class="nc" id="L585">        float tS = (params.getStandardDeviations()[0] / params.getScale());</span>
<span class="nc" id="L586">        float tR = (float) (2. * Math.PI / params.getStandardDeviations()[1]);</span>

        // consider comparing stdev in translations to a fraction of the image
<span class="nc" id="L589">        int tTx = Math.round(params.getStandardDeviations()[2]);</span>
<span class="nc" id="L590">        int tTy = Math.round(params.getStandardDeviations()[3]);</span>

<span class="nc" id="L592">        float tXConstraint = 20;</span>
<span class="nc" id="L593">        float tYConstraint = 20;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (params.getNumberOfPointsUsed() &lt; 3) {</span>
<span class="nc" id="L595">            tXConstraint = 10;</span>
<span class="nc" id="L596">            tYConstraint = 10;</span>
        }

        //TODO: review these limits
<span class="nc bnc" id="L600" title="All 8 branches missed.">        if ((tS &lt; 0.2) &amp;&amp; (tR &gt;= 18.) &amp;&amp; (tTx &lt; tXConstraint)</span>
            &amp;&amp; (tTy &lt; tYConstraint)) {

<span class="nc" id="L603">            return true;</span>
        }

<span class="nc" id="L606">        return false;</span>
    }

    /**
     * comparing each parameter to others and keeping only if there are other
     * similar params and among the similar, only returning average of similar.
     * 
     * @param paramsMap
     * @return 
     */
    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets(
        Map&lt;PairInt, TransformationParameters&gt; paramsMap, int binFactor1,
        int binFactor2) {
        
<span class="nc" id="L620">        int transTol = 30;</span>
<span class="nc bnc" id="L621" title="All 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="nc" id="L622">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="nc" id="L625">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="nc" id="L628">        Set&lt;PairInt&gt; alreadyCombined = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L630" title="All 2 branches missed.">        for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry : paramsMap.entrySet()) {</span>
            
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (alreadyCombined.contains(entry.getKey())) {</span>
<span class="nc" id="L633">                continue;</span>
            }
                        
<span class="nc" id="L636">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
            
<span class="nc" id="L638">            TransformationParameters params0 = entry.getValue();</span>
            
<span class="nc bnc" id="L640" title="All 2 branches missed.">            for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry2 : paramsMap.entrySet()) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                if (entry2.getKey().equals(entry.getKey()) || </span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                    alreadyCombined.contains(entry2.getKey())) {</span>
<span class="nc" id="L643">                    continue;</span>
                }
<span class="nc" id="L645">                TransformationParameters compare = entry2.getValue();</span>
<span class="nc" id="L646">                float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L647">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="nc" id="L649">                    continue;</span>
                }
<span class="nc" id="L651">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="nc" id="L653">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="nc" id="L657">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="nc" id="L658">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="nc" id="L660">                    continue;</span>
                }
<span class="nc bnc" id="L662" title="All 2 branches missed.">                if (!alreadyCombined.contains(entry.getKey())) {</span>
<span class="nc" id="L663">                    alreadyCombined.add(entry.getKey());</span>
                }
<span class="nc" id="L665">                alreadyCombined.add(entry2.getKey());</span>
                
<span class="nc" id="L667">                set.add(params0);</span>
<span class="nc" id="L668">                set.add(compare);</span>
<span class="nc" id="L669">            }</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (!set.isEmpty()) {</span>
<span class="nc" id="L671">                similarSets.add(set);</span>
            }
<span class="nc" id="L673">        }</span>
                  
        // use histograms to remove translation outliers in similar sets
        
<span class="nc" id="L677">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();

<span class="nc bnc" id="L680" title="All 2 branches missed.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="nc" id="L682">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="nc" id="L684">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="nc" id="L685">            filter(similar, keep);</span>
<span class="nc" id="L686">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="nc" id="L687">            filter(similar, keep);</span>
            
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L690">                continue;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            } else if (similar.size() == 1) {</span>
<span class="nc" id="L692">                combinedParams.add(similar.get(0));</span>
<span class="nc" id="L693">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="nc" id="L698">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="nc" id="L699">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="nc" id="L700">            combinedParams.add(params);</span>
<span class="nc" id="L701">        }</span>
        
        // sometimes, the averaged params in similarSets are similar to one
        // another too, so one more round of checking for similarity
<span class="nc" id="L705">        List&lt;TransformationParameters&gt; combinedParams2 = new ArrayList&lt;TransformationParameters&gt;();</span>
        
<span class="nc" id="L707">        Set&lt;TransformationParameters&gt; alreadyCombined2 = new HashSet&lt;TransformationParameters&gt;();</span>
        
<span class="nc bnc" id="L709" title="All 2 branches missed.">        for (TransformationParameters params0 : combinedParams) {</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (alreadyCombined2.contains(params0)) {</span>
<span class="nc" id="L711">                continue;</span>
            }
<span class="nc" id="L713">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
<span class="nc" id="L714">            set.add(params0);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            for (TransformationParameters compare : combinedParams) {</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                if (compare.equals(params0)) {</span>
<span class="nc" id="L717">                    continue;</span>
                }
<span class="nc bnc" id="L719" title="All 2 branches missed.">                if (alreadyCombined2.contains(compare)) {</span>
<span class="nc" id="L720">                    continue;</span>
                }
<span class="nc" id="L722">                float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L723">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="nc" id="L725">                    continue;</span>
                }
<span class="nc" id="L727">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="nc" id="L729">                    continue;</span>
                }
                //TODO: may need to revise translation tolerance...
<span class="nc" id="L732">                double diffX = Math.abs(params0.getTranslationX() - compare.getTranslationX());</span>
<span class="nc" id="L733">                double diffY = Math.abs(params0.getTranslationY() - compare.getTranslationY());</span>
<span class="nc bnc" id="L734" title="All 4 branches missed.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)) {</span>
<span class="nc" id="L735">                    continue;</span>
                }
<span class="nc" id="L737">                set.add(compare);</span>
<span class="nc" id="L738">            }</span>
<span class="nc" id="L739">            alreadyCombined2.addAll(set);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            if (set.size() &gt; 1) {</span>
<span class="nc" id="L741">                MatchedPointsTransformationCalculator tc = new MatchedPointsTransformationCalculator();</span>
<span class="nc" id="L742">                TransformationParameters params =  tc.averageWithoutRemoval(</span>
                    new ArrayList&lt;TransformationParameters&gt;(set));
<span class="nc" id="L744">                combinedParams2.add(params);</span>
<span class="nc" id="L745">            } else {</span>
<span class="nc" id="L746">                combinedParams2.addAll(set);</span>
            }
<span class="nc" id="L748">        }</span>
        
<span class="nc" id="L750">        return combinedParams2;</span>
    }
    
    /**
     * comparing each parameter to others and if there are other
     * similar params, averaging those.
     * 
     * @param paramsMap
     * @param binFactor1
     * @param binFactor2
     * @return 
     */
    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets2(
        Map&lt;PairInt, TransformationParameters&gt; paramsMap, int binFactor1,
        int binFactor2) {
        
<span class="fc" id="L766">        int transTol = 30;</span>
<span class="pc bpc" id="L767" title="3 of 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc" id="L768">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="fc" id="L771">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="fc" id="L774">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="fc" id="L777">        Set&lt;PairInt&gt; alreadyCombined = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry : paramsMap.entrySet()) {</span>
            
<span class="fc bfc" id="L781" title="All 2 branches covered.">            if (alreadyCombined.contains(entry.getKey())) {</span>
<span class="fc" id="L782">                continue;</span>
            }
                      
<span class="fc" id="L785">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
            
<span class="fc" id="L787">            TransformationParameters params0 = entry.getValue();</span>
            
<span class="fc bfc" id="L789" title="All 2 branches covered.">            for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry2 : paramsMap.entrySet()) {</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                if (entry2.getKey().equals(entry.getKey()) || </span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                    alreadyCombined.contains(entry2.getKey())) {</span>
<span class="fc" id="L792">                    continue;</span>
                }
<span class="fc" id="L794">                TransformationParameters compare = entry2.getValue();</span>
<span class="fc" id="L795">                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L796">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="fc" id="L798">                    continue;</span>
                }
<span class="fc" id="L800">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="fc" id="L802">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="fc" id="L806">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="fc" id="L807">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="fc bfc" id="L808" title="All 4 branches covered.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="fc" id="L809">                    continue;</span>
                }
<span class="fc bfc" id="L811" title="All 2 branches covered.">                if (!alreadyCombined.contains(entry.getKey())) {</span>
<span class="fc" id="L812">                    alreadyCombined.add(entry.getKey());</span>
                }
<span class="fc" id="L814">                alreadyCombined.add(entry2.getKey());</span>
                
<span class="fc" id="L816">                set.add(params0);</span>
<span class="fc" id="L817">                set.add(compare);</span>
<span class="fc" id="L818">            }</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">            if (set.isEmpty()) {</span>
<span class="fc" id="L820">                combinedParams.add(params0);</span>
            } else {
<span class="fc" id="L822">                similarSets.add(set);</span>
            }
<span class="fc" id="L824">        }</span>
        
        // use histograms to remove translation outliers in similar sets

<span class="fc bfc" id="L828" title="All 2 branches covered.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="fc" id="L830">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="fc" id="L832">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="fc" id="L833">            Set&lt;Integer&gt; unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">            for (Integer ind : unique) {</span>
<span class="fc" id="L835">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="fc" id="L836">            }</span>
            
<span class="fc" id="L838">            filter(similar, keep);</span>
<span class="fc" id="L839">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="fc" id="L840">            unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">            for (Integer ind : unique) {</span>
<span class="fc" id="L842">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="fc" id="L843">            }</span>
<span class="fc" id="L844">            filter(similar, keep);</span>
            
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L847">                continue;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">            } else if (similar.size() == 1) {</span>
<span class="fc" id="L849">                combinedParams.add(similar.get(0));</span>
<span class="fc" id="L850">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="fc" id="L855">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="fc" id="L856">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="fc" id="L857">            combinedParams.add(params);</span>
<span class="fc" id="L858">        }</span>
        
<span class="fc" id="L860">        return combinedParams;</span>
    }
    
    public static Set&lt;Integer&gt; indexesNotPresent(int[] indexes, int totalNumber) {
<span class="fc" id="L864">        int n = totalNumber = indexes.length;</span>
<span class="fc" id="L865">        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">        for (int index : indexes) {</span>
<span class="fc" id="L867">            set.add(Integer.valueOf(index));</span>
        }
<span class="fc" id="L869">        Set&lt;Integer&gt; diff = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">        for (int i = 0; i &lt; totalNumber; ++i) {</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">            if (!set.contains(Integer.valueOf(i))) {</span>
<span class="fc" id="L872">                diff.add(Integer.valueOf(i));</span>
            }
        }
<span class="fc" id="L875">        return diff;</span>
    }

    private static void filter(List&lt;TransformationParameters&gt; params, 
        int[] indexesToKeep) {
                
<span class="fc bfc" id="L881" title="All 2 branches covered.">        if (indexesToKeep.length &lt; 2) {</span>
<span class="fc" id="L882">            return;</span>
        }
        
<span class="fc" id="L885">        List&lt;TransformationParameters&gt; paramsList2 = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="fc bfc" id="L888" title="All 2 branches covered.">        for (int i = 0; i &lt; indexesToKeep.length;++i) {</span>
<span class="fc" id="L889">            int idx = indexesToKeep[i];</span>
<span class="fc" id="L890">            paramsList2.add(params.get(idx));</span>
        }
                
<span class="fc" id="L893">        params.clear();</span>
<span class="fc" id="L894">        params.addAll(paramsList2);</span>
<span class="fc" id="L895">    }</span>
    
    public static TransformationParameters calculateTransformation(int binFactor1, 
        int binFactor2, List&lt;FeatureComparisonStat&gt; compStats, 
        float[] outputScaleRotTransXYStDev, boolean removeIntensityOutliers) {
        
<span class="pc bpc" id="L901" title="3 of 4 branches missed.">        assert (compStats.isEmpty() == false);</span>
        
<span class="fc" id="L903">        Logger log = Logger.getLogger(MiscStats.class.getName());</span>
                
<span class="fc bfc" id="L905" title="All 2 branches covered.">        if (removeIntensityOutliers) {</span>
<span class="fc" id="L906">            log.info(&quot;filter for intensity outliers&quot;);</span>
<span class="fc" id="L907">            FeatureMatcher.removeIntensityOutliers(compStats);</span>
        }
        
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        if (compStats.size() &lt; 2) {</span>
<span class="nc" id="L911">            return null;</span>
        }
        
<span class="fc" id="L914">        MatchedPointsTransformationCalculator tc = </span>
            new MatchedPointsTransformationCalculator();
        
<span class="fc" id="L917">        int centroidX1 = 0;</span>
<span class="fc" id="L918">        int centroidY1 = 0;</span>
        
<span class="fc" id="L920">        PairIntArray matchedXY1 = new PairIntArray();</span>
<span class="fc" id="L921">        PairIntArray matchedXY2 = new PairIntArray();</span>
        
<span class="fc" id="L923">        float[] weights = new float[compStats.size()];</span>
        
<span class="fc" id="L925">        double sum = 0;</span>
        
<span class="fc bfc" id="L927" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="fc" id="L929">            FeatureComparisonStat compStat = compStats.get(i);</span>
            
<span class="fc" id="L931">            int x1 = compStat.getImg1Point().getX() * binFactor1;</span>
<span class="fc" id="L932">            int y1 = compStat.getImg1Point().getY() * binFactor1;</span>
            
<span class="fc" id="L934">            matchedXY1.add(x1, y1);</span>
            
<span class="fc" id="L936">            int x2 = compStat.getImg2Point().getX() * binFactor2;</span>
<span class="fc" id="L937">            int y2 = compStat.getImg2Point().getY() * binFactor2;</span>
            
<span class="fc" id="L939">            matchedXY2.add(x2, y2);</span>
            
<span class="fc" id="L941">            weights[i] = compStat.getSumIntensitySqDiff();</span>
            
<span class="fc" id="L943">            sum += weights[i];</span>
        }

<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        if (sum &gt; 0) {</span>
            
<span class="fc" id="L948">            double tot = 0;</span>

<span class="fc bfc" id="L950" title="All 2 branches covered.">            for (int i = 0; i &lt; compStats.size(); ++i) {</span>

<span class="fc" id="L952">                double div = (sum - weights[i]) / ((compStats.size() - 1) * sum);</span>

<span class="fc" id="L954">                weights[i] = (float) div;</span>

<span class="fc" id="L956">                tot += div;</span>
            }
 
<span class="pc bpc" id="L959" title="3 of 4 branches missed.">            assert(Math.abs(tot - 1.) &lt; 0.03);</span>
            
<span class="fc" id="L961">        } else {</span>
<span class="nc" id="L962">            float a = 1.f/weights.length;</span>
<span class="nc" id="L963">            Arrays.fill(weights, a);</span>
        }
                
<span class="fc" id="L966">        TransformationParameters params = tc.calulateEuclidean(matchedXY1, </span>
            matchedXY2, weights, centroidX1, centroidY1, 
            outputScaleRotTransXYStDev);
        
<span class="fc" id="L970">        return params;</span>
    }

    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param pointValueMap
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndValues(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L987">        int minTheta = Integer.MAX_VALUE;</span>
<span class="nc" id="L988">        int maxTheta = Integer.MIN_VALUE;</span>
                
<span class="nc bnc" id="L990" title="All 2 branches missed.">        for (Map.Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L991">            int v = Math.round(entry.getValue().floatValue());</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (v &lt; minTheta) {</span>
<span class="nc" id="L993">                minTheta = v;</span>
            }
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (v &gt; maxTheta) {</span>
<span class="nc" id="L996">                maxTheta = v;</span>
            }
<span class="nc" id="L998">        }</span>
                
<span class="nc bnc" id="L1000" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // sort values and find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1005">            int[] values = new int[pointValueMap.size()];</span>
<span class="nc" id="L1006">            int count = 0;</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            for (Map.Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L1008">                values[count] = Math.round(entry.getValue().floatValue());</span>
<span class="nc" id="L1009">                count++;</span>
<span class="nc" id="L1010">            }</span>
<span class="nc" id="L1011">            Arrays.sort(values);</span>
            
<span class="nc" id="L1013">            return determineStartEndValues(values, maxValueForWrapAround, </span>
                toleranceInValue);
        }
        
<span class="nc" id="L1017">        return new int[]{minTheta, maxTheta};</span>
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndValues(int[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1034">        int[] startEndIndexes = determineStartEndIndexes(sortedValues, </span>
            maxValueForWrapAround, toleranceInValue);
        
<span class="nc" id="L1037">        return new int[]{sortedValues[startEndIndexes[0]], </span>
            sortedValues[startEndIndexes[1]]};
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndIndexes(int[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1055">        int minTheta = sortedValues[0];</span>
<span class="nc" id="L1056">        int maxTheta = sortedValues[sortedValues.length - 1];</span>
         
<span class="nc bnc" id="L1058" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1063">            int endIdx = -1;</span>
<span class="nc" id="L1064">            int startIdx = -1;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            for (int i = 0; i &lt; (sortedValues.length - 1); ++i) {</span>
<span class="nc" id="L1066">                int diff = sortedValues[i + 1] - sortedValues[i];</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                if (diff &gt; (toleranceInValue + 1)) {</span>
<span class="nc" id="L1068">                    endIdx = i;</span>
<span class="nc" id="L1069">                    startIdx = i;</span>
<span class="nc" id="L1070">                    break;</span>
                }
            }
<span class="nc bnc" id="L1073" title="All 4 branches missed.">            if (startIdx &gt; -1 &amp;&amp; endIdx &gt; -1) {</span>
<span class="nc" id="L1074">                return new int[]{startIdx, endIdx};</span>
            }
        }
        
<span class="nc" id="L1078">        return new int[]{0, sortedValues.length - 1};</span>
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndIndexes(float[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1095">        float minTheta = sortedValues[0];</span>
<span class="nc" id="L1096">        float maxTheta = sortedValues[sortedValues.length - 1];</span>
         
<span class="nc bnc" id="L1098" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1103">            int endIdx = -1;</span>
<span class="nc" id="L1104">            int startIdx = -1;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            for (int i = 0; i &lt; (sortedValues.length - 1); ++i) {</span>
<span class="nc" id="L1106">                float diff = sortedValues[i + 1] - sortedValues[i];</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                if (diff &gt; (toleranceInValue + 1)) {</span>
<span class="nc" id="L1108">                    endIdx = i;</span>
<span class="nc" id="L1109">                    startIdx = i;</span>
<span class="nc" id="L1110">                    break;</span>
                }
            }
<span class="nc bnc" id="L1113" title="All 4 branches missed.">            if (startIdx &gt; -1 &amp;&amp; endIdx &gt; -1) {</span>
<span class="nc" id="L1114">                return new int[]{startIdx, endIdx};</span>
            }
        }
        
<span class="nc" id="L1118">        return new int[]{0, sortedValues.length - 1};</span>
    }
    
    public static double[] filterStatsForTranslation(
        TransformationParameters params, List&lt;FeatureComparisonStat&gt; compStats, 
        float sigmaFactor) {
        
<span class="pc bpc" id="L1125" title="3 of 4 branches missed.">        assert(!compStats.isEmpty());</span>
                
<span class="pc bpc" id="L1127" title="1 of 2 branches missed.">        if (compStats.size() &lt; 2) {</span>
<span class="nc" id="L1128">            return null;</span>
        }
        
<span class="fc" id="L1131">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L1133">        double sumTx = 0;</span>
<span class="fc" id="L1134">        double sumTy = 0;</span>
<span class="fc" id="L1135">        double[] diffX = new double[compStats.size()];</span>
<span class="fc" id="L1136">        double[] diffY = new double[compStats.size()];</span>
        
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="fc" id="L1140">            FeatureComparisonStat compStat = compStats.get(i);</span>
            
<span class="fc" id="L1142">            int x1 = compStat.getImg1Point().getX();</span>
<span class="fc" id="L1143">            int y1 = compStat.getImg1Point().getY();</span>
                        
<span class="fc" id="L1145">            int x2 = compStat.getImg2Point().getX();</span>
<span class="fc" id="L1146">            int y2 = compStat.getImg2Point().getY();</span>
            
<span class="fc" id="L1148">            double[] xy1Tr = transformer.applyTransformation(params, x1, y1);</span>
            
<span class="fc" id="L1150">            diffX[i] = xy1Tr[0] - x1;</span>
<span class="fc" id="L1151">            diffY[i] = xy1Tr[1] - y1;</span>
            
<span class="fc" id="L1153">            sumTx += diffX[i];</span>
<span class="fc" id="L1154">            sumTy += diffY[i];</span>
        }
        
<span class="fc" id="L1157">        double length = (double)compStats.size();</span>
        
<span class="fc" id="L1159">        double avgTx = sumTx/length;</span>
<span class="fc" id="L1160">        double avgTy = sumTy/length;</span>
        
<span class="fc" id="L1162">        double stDevX = 0;</span>
<span class="fc" id="L1163">        double stDevY = 0;</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">        for (int i = 0; i &lt; diffX.length; ++i) {</span>
<span class="fc" id="L1165">            double d = diffX[i] - avgTx;</span>
<span class="fc" id="L1166">            stDevX += (d*d);</span>
<span class="fc" id="L1167">            d = diffY[i] - avgTy;</span>
<span class="fc" id="L1168">            stDevY += (d*d);</span>
        }
<span class="fc" id="L1170">        stDevX = (Math.sqrt(stDevX/(length - 1.0f)));</span>
<span class="fc" id="L1171">        stDevY = (Math.sqrt(stDevY/(length - 1.0f)));</span>

<span class="fc" id="L1173">        double sumDist = 0;</span>
<span class="fc" id="L1174">        double sumSSD = 0;</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">        for (int i = (compStats.size() - 1); i &gt; -1; --i) {</span>
                        
<span class="fc" id="L1177">            double dx = Math.abs(diffX[i] - avgTx);</span>
<span class="fc" id="L1178">            double dy = Math.abs(diffY[i] - avgTy);</span>
            
<span class="fc bfc" id="L1180" title="All 4 branches covered.">            if ((dx &gt; (sigmaFactor * stDevX)) || (dy &gt; (sigmaFactor * stDevY))) {</span>
<span class="fc" id="L1181">                sumDist += Math.sqrt(diffX[i]*diffX[i] + diffY[i]*diffY[i]); </span>
<span class="fc" id="L1182">                sumSSD += compStats.get(i).getSumIntensitySqDiff();</span>
<span class="fc" id="L1183">                compStats.remove(i);</span>
            }
        }
<span class="fc" id="L1186">        length = compStats.size();</span>
        
<span class="fc" id="L1188">        double[] sumDistSSD = new double[2];</span>
<span class="fc" id="L1189">        sumDistSSD[0] = (sumDist/params.getScale())/length;</span>
<span class="fc" id="L1190">        sumDistSSD[1] = sumSSD/length;</span>
        
<span class="fc" id="L1192">        return sumDistSSD;</span>
    }

    public static List&lt;Integer&gt; filterForDegeneracy(List&lt;FeatureComparisonStat&gt; 
        stats) {
           
<span class="fc" id="L1198">        Map&lt;PairInt, List&lt;Integer&gt;&gt; pointIndexes = new HashMap&lt;PairInt, List&lt;Integer&gt;&gt;();</span>
        
        // filter for same pt1 first
<span class="fc" id="L1201">        FeatureComparisonStat[] statsCp = new FeatureComparisonStat[stats.size()];</span>
        
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
<span class="fc" id="L1204">            FeatureComparisonStat stat = stats.get(i);</span>
<span class="fc" id="L1205">            statsCp[i] = stat;</span>
<span class="fc" id="L1206">            List&lt;Integer&gt; indexes = pointIndexes.get(stat.getImg1Point());</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L1208">                indexes = new ArrayList&lt;Integer&gt;();</span>
            }
<span class="fc" id="L1210">            indexes.add(Integer.valueOf(i));</span>
<span class="fc" id="L1211">            pointIndexes.put(stat.getImg1Point(), indexes);</span>
        }
        
<span class="fc bfc" id="L1214" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="fc" id="L1215">            List&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">            if (indexes.size() &lt; 2) {</span>
<span class="fc" id="L1217">                continue;</span>
            }
<span class="fc" id="L1219">            float minCost = Float.MAX_VALUE;</span>
<span class="fc" id="L1220">            Integer minCostIndex = null;</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
<span class="fc" id="L1222">                FeatureComparisonStat stat = statsCp[index.intValue()];</span>
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">                if (stat == null) {</span>
<span class="nc" id="L1224">                    continue;</span>
                }
<span class="fc" id="L1226">                float cost = stat.getSumIntensitySqDiff();</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">                if (cost &lt; minCost) {</span>
<span class="fc" id="L1228">                    minCost = cost;</span>
<span class="fc" id="L1229">                    minCostIndex = index;</span>
                }
<span class="fc" id="L1231">            }</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">            if (minCostIndex != null) {</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">                for (Integer index : indexes) {</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">                    if (index.equals(minCostIndex)) {</span>
<span class="fc" id="L1235">                        continue;</span>
                    }
<span class="fc" id="L1237">                    statsCp[index.intValue()] = null;</span>
<span class="fc" id="L1238">                } </span>
            }
<span class="fc" id="L1240">        }</span>
        
<span class="fc" id="L1242">        pointIndexes.clear();</span>
        
        // filter for same point2
        
<span class="fc bfc" id="L1246" title="All 2 branches covered.">        for (int i = 0; i &lt; statsCp.length; ++i) {</span>
<span class="fc" id="L1247">            FeatureComparisonStat stat = statsCp[i];</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">            if (stat == null) {</span>
<span class="fc" id="L1249">                continue;</span>
            }
<span class="fc" id="L1251">            List&lt;Integer&gt; indexes = pointIndexes.get(stat.getImg2Point());</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L1253">                indexes = new ArrayList&lt;Integer&gt;();</span>
            }
<span class="fc" id="L1255">            indexes.add(Integer.valueOf(i));</span>
<span class="fc" id="L1256">            pointIndexes.put(stat.getImg2Point(), indexes);</span>
        }
        
<span class="fc bfc" id="L1259" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="fc" id="L1260">            List&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">            if (indexes.size() &lt; 2) {</span>
<span class="fc" id="L1262">                continue;</span>
            }
<span class="fc" id="L1264">            float minCost = Float.MAX_VALUE;</span>
<span class="fc" id="L1265">            Integer minCostIndex = null;</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
<span class="fc" id="L1267">                FeatureComparisonStat stat = statsCp[index.intValue()];</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">                if (stat == null) {</span>
<span class="nc" id="L1269">                    continue;</span>
                }
<span class="fc" id="L1271">                float cost = stat.getSumIntensitySqDiff();</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">                if (cost &lt; minCost) {</span>
<span class="fc" id="L1273">                    minCost = cost;</span>
<span class="fc" id="L1274">                    minCostIndex = index;</span>
                }
<span class="fc" id="L1276">            }</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">            if (minCostIndex != null) {</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">                for (Integer index : indexes) {</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">                    if (index.equals(minCostIndex)) {</span>
<span class="fc" id="L1280">                        continue;</span>
                    }
<span class="fc" id="L1282">                    statsCp[index.intValue()] = null;</span>
<span class="fc" id="L1283">                } </span>
            }
<span class="fc" id="L1285">        }</span>
        
<span class="fc" id="L1287">        stats.clear();</span>
        // store removed indexes
<span class="fc" id="L1289">        List&lt;Integer&gt; removed = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        for (int i = 0; i &lt; statsCp.length; ++i) {</span>
<span class="fc" id="L1292">            FeatureComparisonStat stat = statsCp[i];</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">            if (stat == null) {</span>
<span class="fc" id="L1294">                removed.add(Integer.valueOf(i));</span>
<span class="fc" id="L1295">                continue;</span>
            }
<span class="fc" id="L1297">            stats.add(stat);</span>
        }
        
<span class="fc" id="L1300">        Collections.sort(removed);</span>
        
<span class="fc" id="L1302">        return removed;</span>
    }
    
    public static double calculateCombinedIntensityStat(List&lt;FeatureComparisonStat&gt; 
        compStats) {
        
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">        if (compStats.isEmpty()) {</span>
<span class="nc" id="L1309">            return Double.POSITIVE_INFINITY;</span>
        }
        
<span class="fc" id="L1312">        double sum = 0;</span>
        
<span class="fc bfc" id="L1314" title="All 2 branches covered.">        for (FeatureComparisonStat compStat : compStats) {</span>
<span class="fc" id="L1315">            sum += compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L1316">        }</span>
        
<span class="fc" id="L1318">        sum /= (double) compStats.size();</span>
        
<span class="fc" id="L1320">        return sum;</span>
    }
    
    public static double[][] getBoundsOfIntersectionInFrame2(TransformationParameters 
        parameters, int img1Width, int img1Height, int img2Width, int img2Height) {
        
        //calculate the intersection of the 2 images
        
<span class="fc" id="L1328">        MatchedPointsTransformationCalculator tc = </span>
            new MatchedPointsTransformationCalculator();
        
<span class="fc" id="L1331">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L1333">        TransformationParameters revParams = tc.swapReferenceFrames(parameters);</span>
        
        /*
        
       / \   ( tr )    ( tr )            (x2q3, y2q3)      (x2q4, y2q4)
        |
        |
        0    ( tr )    ( tr )            (x2q2, y2q2)      (x2q1, y2q1)
          0 --&gt;
        
        */
        
        // determine intersection of img2 with img1 in img1 reference frame
<span class="fc" id="L1346">        double[] q1Tr = transformer.applyTransformation(revParams, </span>
            img2Width - 1, 0);
        
<span class="fc" id="L1349">        double[] q2Tr = transformer.applyTransformation(revParams, </span>
            0, 0);
        
<span class="fc" id="L1352">        double[] q3Tr = transformer.applyTransformation(revParams, </span>
            0, img2Height - 1);
        
<span class="fc" id="L1355">        double[] q4Tr = transformer.applyTransformation(revParams, </span>
            img2Width - 1, img2Height - 1);
        
        // if the transformed bounds are off image, reset the bounds to img1 bounds
<span class="fc" id="L1359">        double[][] img1Intersection = new double[4][2];</span>
<span class="fc" id="L1360">        img1Intersection[0] = q1Tr;</span>
<span class="fc" id="L1361">        img1Intersection[1] = q2Tr;</span>
<span class="fc" id="L1362">        img1Intersection[2] = q3Tr;</span>
<span class="fc" id="L1363">        img1Intersection[3] = q4Tr;</span>
        
<span class="fc bfc" id="L1365" title="All 2 branches covered.">        for (double[] xyTr : img1Intersection) {</span>
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">            if (xyTr[0] &lt; 0) {</span>
<span class="nc" id="L1367">                xyTr[0] = 0;</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">            } else if (xyTr[0] &gt; (img1Width - 1)) {</span>
<span class="fc" id="L1369">                xyTr[0] = (img1Width - 1);</span>
            }
<span class="fc bfc" id="L1371" title="All 2 branches covered.">            if (xyTr[1] &lt; 0) {</span>
<span class="fc" id="L1372">                xyTr[1] = 0;</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">            } else if (xyTr[1] &gt; (img1Height - 1)) {</span>
<span class="nc" id="L1374">                xyTr[1] = (img1Height - 1);</span>
            }
        }
        
        // transform the img1 intersection into reference frame of img2
<span class="fc" id="L1379">        double[] q1TrTr = transformer.applyTransformation(parameters, q1Tr[0], q1Tr[1]);</span>
        
<span class="fc" id="L1381">        double[] q2TrTr = transformer.applyTransformation(parameters, q2Tr[0], q2Tr[1]);</span>
        
<span class="fc" id="L1383">        double[] q3TrTr = transformer.applyTransformation(parameters, q3Tr[0], q3Tr[1]);</span>
        
<span class="fc" id="L1385">        double[] q4TrTr = transformer.applyTransformation(parameters, q4Tr[0], q4Tr[1]);</span>
        
<span class="fc" id="L1387">        double[][] img2Intersection = new double[4][2];</span>
<span class="fc" id="L1388">        img2Intersection[0] = q1TrTr;</span>
<span class="fc" id="L1389">        img2Intersection[1] = q2TrTr;</span>
<span class="fc" id="L1390">        img2Intersection[2] = q3TrTr;</span>
<span class="fc" id="L1391">        img2Intersection[3] = q4TrTr;</span>
        
<span class="fc bfc" id="L1393" title="All 2 branches covered.">        for (double[] xyTr : img2Intersection) {</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">            if (xyTr[0] &lt; 0) {</span>
<span class="fc" id="L1395">                xyTr[0] = 0;</span>
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">            } else if (xyTr[0] &gt; (img2Width - 1)) {</span>
<span class="nc" id="L1397">                xyTr[0] = (img2Width - 1);</span>
            }
<span class="fc bfc" id="L1399" title="All 2 branches covered.">            if (xyTr[1] &lt; 0) {</span>
<span class="fc" id="L1400">                xyTr[1] = 0;</span>
<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">            } else if (xyTr[1] &gt; (img2Height - 1)) {</span>
<span class="nc" id="L1402">                xyTr[1] = (img2Height - 1);</span>
            }
        }
        
<span class="fc" id="L1406">        return img2Intersection;</span>
    }

    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets2(
        List&lt;TransformationParameters&gt; paramsList, int binFactor1, int binFactor2) {
        
<span class="fc" id="L1412">        int transTol = 30;</span>
<span class="pc bpc" id="L1413" title="3 of 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc" id="L1414">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="fc" id="L1417">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="fc" id="L1420">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="fc" id="L1423">        Set&lt;Integer&gt; alreadyCombined = new HashSet&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
            
<span class="fc" id="L1427">            Integer key = Integer.valueOf(i);</span>
                        
<span class="fc bfc" id="L1429" title="All 2 branches covered.">            if (alreadyCombined.contains(key)) {</span>
<span class="fc" id="L1430">                continue;</span>
            }
            
<span class="fc" id="L1433">            TransformationParameters params0 = paramsList.get(i);</span>
            
<span class="fc" id="L1435">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
                        
<span class="fc bfc" id="L1437" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; paramsList.size(); ++j) {</span>
                
<span class="fc" id="L1439">                Integer key2 = Integer.valueOf(j);</span>
                
<span class="fc bfc" id="L1441" title="All 2 branches covered.">                if (alreadyCombined.contains(key2)) {</span>
<span class="fc" id="L1442">                    continue;</span>
                }
                
<span class="fc" id="L1445">                TransformationParameters compare = paramsList.get(j);</span>
                
<span class="fc" id="L1447">                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L1448">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="fc" id="L1450">                    continue;</span>
                }
<span class="fc" id="L1452">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="fc bfc" id="L1453" title="All 2 branches covered.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="fc" id="L1454">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="fc" id="L1458">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="fc" id="L1459">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="fc bfc" id="L1460" title="All 4 branches covered.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="fc" id="L1461">                    continue;</span>
                }
<span class="fc bfc" id="L1463" title="All 2 branches covered.">                if (!alreadyCombined.contains(key)) {</span>
<span class="fc" id="L1464">                    alreadyCombined.add(key);</span>
                }
<span class="fc" id="L1466">                alreadyCombined.add(key2);</span>
                
<span class="fc" id="L1468">                set.add(params0);</span>
<span class="fc" id="L1469">                set.add(compare);</span>
            }
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            if (set.isEmpty()) {</span>
<span class="fc" id="L1472">                combinedParams.add(params0);</span>
            } else {
<span class="fc" id="L1474">                similarSets.add(set);</span>
            }
        }
        
        // use histograms to remove translation outliers in similar sets

<span class="fc bfc" id="L1480" title="All 2 branches covered.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="fc" id="L1482">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="fc" id="L1484">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="fc" id="L1485">            Set&lt;Integer&gt; unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">            for (Integer ind : unique) {</span>
<span class="fc" id="L1487">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="fc" id="L1488">            }</span>
            
<span class="fc" id="L1490">            filter(similar, keep);</span>
<span class="fc" id="L1491">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="fc" id="L1492">            unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="fc bfc" id="L1493" title="All 2 branches covered.">            for (Integer ind : unique) {</span>
<span class="fc" id="L1494">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="fc" id="L1495">            }</span>
<span class="fc" id="L1496">            filter(similar, keep);</span>
            
<span class="pc bpc" id="L1498" title="1 of 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L1499">                continue;</span>
<span class="fc bfc" id="L1500" title="All 2 branches covered.">            } else if (similar.size() == 1) {</span>
<span class="fc" id="L1501">                combinedParams.add(similar.get(0));</span>
<span class="fc" id="L1502">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="fc" id="L1507">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="fc" id="L1508">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="fc" id="L1509">            combinedParams.add(params);</span>
<span class="fc" id="L1510">        }</span>
        
<span class="fc" id="L1512">        return combinedParams;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscStats.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.util</a> &gt; <span class="el_source">MiscStats.java</span></div><h1>MiscStats.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.util;

import algorithms.imageProcessing.FeatureComparisonStat;
import algorithms.imageProcessing.FeatureMatcher;
import algorithms.imageProcessing.MatchedPointsTransformationCalculator;
import algorithms.imageProcessing.TransformationParameters;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import com.climbwithyourfeet.clustering.DTClusterFinder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class MiscStats {</span>
    
    public static int[] filterForScaleAndRotation(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L30" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L31">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L32" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L33">                indexes[i] = i;</span>
            }
<span class="nc" id="L35">            return indexes;</span>
        }
        
<span class="nc" id="L38">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L39">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L40">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L42">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L44">                r = 360 - r;</span>
            }
<span class="nc" id="L46">            rotations[i] = r;</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L48">                minRD = r;</span>
            }
<span class="nc bnc" id="L50" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L51">                maxRD = r;</span>
            }
        }

<span class="nc" id="L55">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L56">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L57">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L59">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L61">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L63" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L64">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L67">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L69">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L72">        float factor = (int)(maxRD - minRD)/diffS;</span>
<span class="nc" id="L73">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L74">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L76">            float s = scales[i];</span>
<span class="nc" id="L77">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L79">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L83">        Set&lt;PairIntWithIndex&gt; points = new HashSet&lt;PairIntWithIndex&gt;();</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L86">            float x = rotations[i];</span>
<span class="nc" id="L87">            float y = scales[i];</span>
<span class="nc" id="L88">            PairIntWithIndex p = new PairIntWithIndex(Math.round(x),</span>
<span class="nc" id="L89">                Math.round(y), i);</span>
<span class="nc" id="L90">            points.add(p);</span>
        }

<span class="nc" id="L93">        int dimen1 = (int)(Math.ceil(maxRD) + 1);</span>
<span class="nc" id="L94">        int dimen2 = (int)(Math.ceil(maxS) + 1);</span>

<span class="nc" id="L96">        DTClusterFinder&lt;PairIntWithIndex&gt; cFinder </span>
            = new DTClusterFinder&lt;PairIntWithIndex&gt;(points, dimen1, dimen2);
        //cFinder.setToDebug();
<span class="nc" id="L99">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L101">        cFinder.findClusters();</span>

<span class="nc" id="L103">        int n = cFinder.getNumberOfClusters();</span>
        
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L106">            return new int[0];</span>
        }
        
<span class="nc" id="L109">        int maxN = Integer.MIN_VALUE;</span>
<span class="nc" id="L110">        int maxNIdx = -1;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L112">            int ns = cFinder.getCluster(i).size();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (ns &gt; maxN) {</span>
<span class="nc" id="L114">                maxN = ns;</span>
<span class="nc" id="L115">                maxNIdx = i;</span>
            }
        }
<span class="nc" id="L118">        int[] indexes = new int[maxN];</span>
<span class="nc" id="L119">        int count = 0;</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        for (PairIntWithIndex p : cFinder.getCluster(maxNIdx)) {</span>
<span class="nc" id="L121">            indexes[count] = p.getPixIndex();</span>
<span class="nc" id="L122">            count++;</span>
<span class="nc" id="L123">        }</span>
        
<span class="nc" id="L125">        return indexes;</span>
    }

    public static int[] filterForScaleAndRotationUsingHist(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L132">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L134">                indexes[i] = i;</span>
            }
<span class="nc" id="L136">            return indexes;</span>
        }
        
<span class="nc" id="L139">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L140">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L141">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L143">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L145">                r = 360 - r;</span>
            }
<span class="nc" id="L147">            rotations[i] = r;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L149">                minRD = r;</span>
            }
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L152">                maxRD = r;</span>
            }
        }

<span class="nc" id="L156">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L157">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L158">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L160">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L162">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L164" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L165">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L168">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L170">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L173">        float factor = (int)(maxRD - minRD)/diffS;</span>
<span class="nc" id="L174">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L175">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L177">            float s = scales[i];</span>
<span class="nc" id="L178">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L180">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L184">        HistogramHolder rHist = Histogram.createSimpleHistogram(25.f, rotations, </span>
<span class="nc" id="L185">            Errors.populateYErrorsBySqrt(rotations));</span>
        
<span class="nc" id="L187">        HistogramHolder sHist = Histogram.createSimpleHistogram(25.f, scales, </span>
<span class="nc" id="L188">            Errors.populateYErrorsBySqrt(scales));</span>
        
<span class="nc" id="L190">        int[] rYMaxIdx = MiscMath.findYMaxIndexes(rHist.getYHist());</span>
        
<span class="nc" id="L192">        int[] sYMaxIdx = MiscMath.findYMaxIndexes(sHist.getYHist());</span>
        
<span class="nc" id="L194">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (rYMaxIdx != null) {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            for (int vIdx : rYMaxIdx) {</span>
<span class="nc" id="L198">                float v = rHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                for (int i = 0; i &lt; rotations.length; ++i) {</span>
<span class="nc" id="L200">                    float diff = Math.abs(rotations[i] - v);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L202">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (sYMaxIdx != null) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            for (int vIdx : sYMaxIdx) {</span>
<span class="nc" id="L210">                float v = sHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L212">                    float diff = Math.abs(scales[i] - v);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L214">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L220">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L221">        int count = 0;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L223">            indexes[count] = index.intValue();</span>
<span class="nc" id="L224">            count++;</span>
<span class="nc" id="L225">        }</span>
        
<span class="nc" id="L227">        return indexes;</span>
    }
    
    public static int[] filterForRotationUsingHist(
        List&lt;TransformationParameters&gt; paramsList, int shiftRotation) {
        
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L234">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L236">                indexes[i] = i;</span>
            }
<span class="nc" id="L238">            return indexes;</span>
        }
        
<span class="nc" id="L241">        float minRD = Float.MAX_VALUE;</span>
<span class="nc" id="L242">        float maxRD = Float.MIN_VALUE;</span>
<span class="nc" id="L243">        float[] rotations = new float[paramsList.size()];</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L245">            float r = shiftRotation + paramsList.get(i).getRotationInDegrees();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (r &gt;= 360) {</span>
<span class="nc" id="L247">                r = 360 - r;</span>
            }
<span class="nc" id="L249">            rotations[i] = r;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (r &lt; minRD) {</span>
<span class="nc" id="L251">                minRD = r;</span>
            }
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (r &gt; maxRD) {</span>
<span class="nc" id="L254">                maxRD = r;</span>
            }
        }

<span class="nc" id="L258">        HistogramHolder rHist = Histogram.createSimpleHistogram(25.f, rotations, </span>
<span class="nc" id="L259">            Errors.populateYErrorsBySqrt(rotations));</span>
        
<span class="nc" id="L261">        int[] rYMaxIdx = MiscMath.findYMaxIndexes(rHist.getYHist());</span>
        
<span class="nc" id="L263">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (rYMaxIdx != null) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            for (int vIdx : rYMaxIdx) {</span>
<span class="nc" id="L267">                float v = rHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                for (int i = 0; i &lt; rotations.length; ++i) {</span>
<span class="nc" id="L269">                    float diff = Math.abs(rotations[i] - v);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L271">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L277">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L278">        int count = 0;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L280">            indexes[count] = index.intValue();</span>
<span class="nc" id="L281">            count++;</span>
<span class="nc" id="L282">        }</span>
        
<span class="nc" id="L284">        return indexes;</span>
    }

    public static int[] filterForScaleUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (paramsList.size() &lt; 3) {</span>
<span class="nc" id="L291">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L293">                indexes[i] = i;</span>
            }
<span class="nc" id="L295">            return indexes;</span>
        }
        
<span class="nc" id="L298">        float minS = Float.MAX_VALUE;</span>
<span class="nc" id="L299">        float maxS = Float.MIN_VALUE;</span>
<span class="nc" id="L300">        float[] scales = new float[paramsList.size()];</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L302">            scales[i] = paramsList.get(i).getScale();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (scales[i] &lt; minS) {</span>
<span class="nc" id="L304">                minS = scales[i];</span>
            }
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L307">                maxS = scales[i];</span>
            }
        }
<span class="nc" id="L310">        int diffS = (int)(maxS - minS);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (diffS == 0) {</span>
<span class="nc" id="L312">            diffS = 1;</span>
        }
        // cluster finder scales by O(dimension * lg2(dimension)), so start at 0
<span class="nc" id="L315">        float factor = 360/diffS;</span>
<span class="nc" id="L316">        float offset = -1 * (minS * factor);</span>
<span class="nc" id="L317">        maxS = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L319">            float s = scales[i];</span>
<span class="nc" id="L320">            scales[i] = (s * factor) + offset;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (scales[i] &gt; maxS) {</span>
<span class="nc" id="L322">                maxS = scales[i];</span>
            }
        }

<span class="nc" id="L326">        HistogramHolder sHist = Histogram.createSimpleHistogram(25.f, scales, </span>
<span class="nc" id="L327">            Errors.populateYErrorsBySqrt(scales));</span>
                
<span class="nc" id="L329">        int[] sYMaxIdx = MiscMath.findYMaxIndexes(sHist.getYHist());</span>
        
<span class="nc" id="L331">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (sYMaxIdx != null) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            for (int vIdx : sYMaxIdx) {</span>
<span class="nc" id="L335">                float v = sHist.getXHist()[vIdx];</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                for (int i = 0; i &lt; scales.length; ++i) {</span>
<span class="nc" id="L337">                    float diff = Math.abs(scales[i] - v);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    if (diff &lt;= 20) {</span>
<span class="nc" id="L339">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="nc" id="L345">        int[] indexes = new int[keep.size()];</span>
<span class="nc" id="L346">        int count = 0;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        for (Integer index : keep) {</span>
<span class="nc" id="L348">            indexes[count] = index.intValue();</span>
<span class="nc" id="L349">            count++;</span>
<span class="nc" id="L350">        }</span>
        
<span class="nc" id="L352">        return indexes;</span>
    }
    
    public static int[] filterForTranslationXUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {        
        
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (paramsList.size() &lt; 3) {</span>
<span class="fc" id="L359">            int[] indexes = new int[paramsList.size()];</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L361">                indexes[i] = i;</span>
            }
<span class="fc" id="L363">            return indexes;</span>
        }
        
<span class="fc" id="L366">        float minX = Float.MAX_VALUE;</span>
<span class="fc" id="L367">        float maxX = Float.MIN_VALUE;</span>
<span class="fc" id="L368">        float[] translationXs = new float[paramsList.size()];</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L370">            translationXs[i] = paramsList.get(i).getTranslationX();</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (translationXs[i] &lt; minX) {</span>
<span class="fc" id="L372">                minX = translationXs[i];</span>
            }
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (translationXs[i] &gt; maxX) {</span>
<span class="fc" id="L375">                maxX = translationXs[i];</span>
            }
        }
        
<span class="fc" id="L379">        HistogramHolder tXHist = Histogram.createSimpleHistogram(translationXs, </span>
<span class="fc" id="L380">            Errors.populateYErrorsBySqrt(translationXs));</span>
                
<span class="fc" id="L382">        int[] txMaxIdx = MiscMath.findYMaxIndexes(tXHist.getYHist());</span>
        
<span class="fc" id="L384">        float binSize = tXHist.getXHist()[1] - tXHist.getXHist()[0];</span>
        
<span class="fc" id="L386">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (txMaxIdx != null) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            for (int vIdx : txMaxIdx) {</span>
<span class="fc" id="L390">                float v = tXHist.getXHist()[vIdx];</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                for (int i = 0; i &lt; translationXs.length; ++i) {</span>
<span class="fc" id="L392">                    float diff = Math.abs(translationXs[i] - v);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                    if (diff &lt;= 1.1*binSize) {</span>
<span class="fc" id="L394">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="fc" id="L400">        int[] indexes = new int[keep.size()];</span>
<span class="fc" id="L401">        int count = 0;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (Integer index : keep) {</span>
<span class="fc" id="L403">            indexes[count] = index.intValue();</span>
<span class="fc" id="L404">            count++;</span>
<span class="fc" id="L405">        }</span>
        
<span class="fc" id="L407">        return indexes;</span>
    }
    
    public static int[] filterForTranslationYUsingHist(
        List&lt;TransformationParameters&gt; paramsList) {
        
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (paramsList.size() &lt; 3) {</span>
<span class="fc" id="L414">            int[] indexes = new int[paramsList.size()];</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L416">                indexes[i] = i;</span>
            }
<span class="fc" id="L418">            return indexes;</span>
        }
        
<span class="fc" id="L421">        float minY = Float.MAX_VALUE;</span>
<span class="fc" id="L422">        float maxY = Float.MIN_VALUE;</span>
<span class="fc" id="L423">        float[] translationYs = new float[paramsList.size()];</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="fc" id="L425">            translationYs[i] = paramsList.get(i).getTranslationY();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (translationYs[i] &lt; minY) {</span>
<span class="fc" id="L427">                minY = translationYs[i];</span>
            }
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (translationYs[i] &gt; maxY) {</span>
<span class="fc" id="L430">                maxY = translationYs[i];</span>
            }
        }
        
<span class="fc" id="L434">        HistogramHolder tYHist = Histogram.createSimpleHistogram(translationYs, </span>
<span class="fc" id="L435">            Errors.populateYErrorsBySqrt(translationYs));</span>
                
<span class="fc" id="L437">        int[] tyMaxIdx = MiscMath.findYMaxIndexes(tYHist.getYHist());</span>
        
<span class="fc" id="L439">        float binSize = tYHist.getXHist()[1] - tYHist.getXHist()[0];</span>
        
<span class="fc" id="L441">        Set&lt;Integer&gt; keep = new HashSet&lt;Integer&gt;();</span>
        
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (tyMaxIdx != null) {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">            for (int vIdx : tyMaxIdx) {</span>
<span class="fc" id="L445">                float v = tYHist.getXHist()[vIdx];</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">                for (int i = 0; i &lt; translationYs.length; ++i) {</span>
<span class="fc" id="L447">                    float diff = Math.abs(translationYs[i] - v);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                    if (diff &lt;= 1.1*binSize) {</span>
<span class="fc" id="L449">                        keep.add(Integer.valueOf(i));</span>
                    }
                }
            }
        }
        
<span class="fc" id="L455">        int[] indexes = new int[keep.size()];</span>
<span class="fc" id="L456">        int count = 0;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (Integer index : keep) {</span>
<span class="fc" id="L458">            indexes[count] = index.intValue();</span>
<span class="fc" id="L459">            count++;</span>
<span class="fc" id="L460">        }</span>
        
<span class="fc" id="L462">        return indexes;</span>
    }
    
    public static int[] filterForTranslation(List&lt;TransformationParameters&gt; paramsList) {
        
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (paramsList.size() &lt; 4) {</span>
<span class="nc" id="L468">            int[] indexes = new int[paramsList.size()];</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L470">                indexes[i] = i;</span>
            }
<span class="nc" id="L472">            return indexes;</span>
        }
        
<span class="nc" id="L475">        float minTX = Float.MAX_VALUE;</span>
<span class="nc" id="L476">        float maxTX = Float.MIN_VALUE;</span>
<span class="nc" id="L477">        float[] transX = new float[paramsList.size()];</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L479">            float v = paramsList.get(i).getTranslationX();</span>
<span class="nc" id="L480">            transX[i] = v;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (v &lt; minTX) {</span>
<span class="nc" id="L482">                minTX = v;</span>
            }
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (v &gt; maxTX) {</span>
<span class="nc" id="L485">                maxTX = v;</span>
            }
        }
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (minTX != 0) {</span>
            // shift the values so that '1' is the lowest value... 
            // dt in clustering runtime is O(dimension * lg_2(dimension))
<span class="nc" id="L491">            float offset = -1*minTX;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            for (int i = 0; i &lt; transX.length; ++i) {</span>
<span class="nc" id="L493">                transX[i] += (offset + 1);</span>
            }
<span class="nc" id="L495">            minTX += (offset + 1);</span>
<span class="nc" id="L496">            maxTX += (offset + 1);</span>
        }
        
<span class="nc" id="L499">        float minTY = Float.MAX_VALUE;</span>
<span class="nc" id="L500">        float maxTY = Float.MIN_VALUE;</span>
<span class="nc" id="L501">        float[] transY = new float[paramsList.size()];</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        for (int i = 0; i &lt; paramsList.size(); ++i) {</span>
<span class="nc" id="L503">            float v = paramsList.get(i).getTranslationY();</span>
<span class="nc" id="L504">            transY[i] = v;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if (v &lt; minTY) {</span>
<span class="nc" id="L506">                minTY = v;</span>
            }
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (v &gt; maxTY) {</span>
<span class="nc" id="L509">                maxTY = v;</span>
            }
        }
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (minTY != 0) {</span>
            // shift the values so that '1' is the lowest value... 
            // dt in clustering runtime is O(dimension * lg_2(dimension))
<span class="nc" id="L515">            float offset = -1*minTY;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            for (int i = 0; i &lt; transY.length; ++i) {</span>
<span class="nc" id="L517">                transY[i] += (offset + 1);</span>
            }
<span class="nc" id="L519">            minTY += (offset + 1);</span>
<span class="nc" id="L520">            maxTY += (offset + 1);</span>
        }
        
<span class="nc bnc" id="L523" title="All 4 branches missed.">        if ((maxTX &gt; 1000) || (maxTY &gt; 1000)) {</span>
            //TODO: implement a histogram version
        }
        
<span class="nc" id="L527">        Set&lt;PairIntWithIndex&gt; points = new HashSet&lt;PairIntWithIndex&gt;();</span>

<span class="nc bnc" id="L529" title="All 2 branches missed.">        for (int i = 0; i &lt; transX.length; ++i) {</span>
<span class="nc" id="L530">            float x = transX[i];</span>
<span class="nc" id="L531">            float y = transY[i];</span>
<span class="nc" id="L532">            PairIntWithIndex p = new PairIntWithIndex(Math.round(x),</span>
<span class="nc" id="L533">                Math.round(y), i);</span>
<span class="nc" id="L534">            points.add(p);</span>
        }

<span class="nc" id="L537">        int dimen1 = (int)(Math.ceil(maxTX) + 1);</span>
<span class="nc" id="L538">        int dimen2 = (int)(Math.ceil(maxTY) + 1);</span>

<span class="nc" id="L540">        DTClusterFinder&lt;PairIntWithIndex&gt; cFinder </span>
            = new DTClusterFinder&lt;PairIntWithIndex&gt;(points, dimen1, dimen2);
        //cFinder.setToDebug();
<span class="nc" id="L543">        cFinder.setThreshholdFactor(0.75f);</span>
<span class="nc" id="L544">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L546">        cFinder.findClusters();</span>

<span class="nc" id="L548">        int n = cFinder.getNumberOfClusters();</span>
        
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L551">            return new int[0];</span>
        }
        
<span class="nc" id="L554">        int maxN = Integer.MIN_VALUE;</span>
<span class="nc" id="L555">        int maxNIdx = -1;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L557">            int ns = cFinder.getCluster(i).size();</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (ns &gt; maxN) {</span>
<span class="nc" id="L559">                maxN = ns;</span>
<span class="nc" id="L560">                maxNIdx = i;</span>
            }
        }
<span class="nc" id="L563">        int[] indexes = new int[maxN];</span>
<span class="nc" id="L564">        int count = 0;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        for (PairIntWithIndex p : cFinder.getCluster(maxNIdx)) {</span>
<span class="nc" id="L566">            indexes[count] = p.getPixIndex();</span>
<span class="nc" id="L567">            count++;</span>
<span class="nc" id="L568">        }</span>
        
<span class="nc" id="L570">        return indexes;</span>
    }

    public static boolean standardDeviationsAreSmall(TransformationParameters params) {

<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (params.getStandardDeviations() == null) {</span>
<span class="fc" id="L576">            return false;</span>
        }
        
        // calculation
<span class="fc" id="L580">        float tS = (params.getStandardDeviations()[0] / params.getScale());</span>
<span class="fc" id="L581">        float tR = (float) (2. * Math.PI / params.getStandardDeviations()[1]);</span>

        // consider comparing stdev in translations to a fraction of the image
<span class="fc" id="L584">        int tTx = Math.round(params.getStandardDeviations()[2]);</span>
<span class="fc" id="L585">        int tTy = Math.round(params.getStandardDeviations()[3]);</span>

<span class="fc" id="L587">        float tXConstraint = 20;</span>
<span class="fc" id="L588">        float tYConstraint = 20;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (params.getNumberOfPointsUsed() &lt; 3) {</span>
<span class="fc" id="L590">            tXConstraint = 10;</span>
<span class="fc" id="L591">            tYConstraint = 10;</span>
        }

        //TODO: review these limits
<span class="pc bpc" id="L595" title="1 of 8 branches missed.">        if ((tS &lt; 0.2) &amp;&amp; (tR &gt;= 18.) &amp;&amp; (tTx &lt; tXConstraint)</span>
            &amp;&amp; (tTy &lt; tYConstraint)) {

<span class="fc" id="L598">            return true;</span>
        }

<span class="fc" id="L601">        return false;</span>
    }

    /**
     * comparing each parameter to others and keeping only if there are other
     * similar params and among the similar, only returning average of similar.
     * 
     * @param paramsMap
     * @return 
     */
    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets(
        Map&lt;PairInt, TransformationParameters&gt; paramsMap, int binFactor1,
        int binFactor2) {
        
<span class="fc" id="L615">        int transTol = 30;</span>
<span class="pc bpc" id="L616" title="1 of 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc" id="L617">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="fc" id="L620">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="fc" id="L623">        Set&lt;PairInt&gt; alreadyCombined = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry : paramsMap.entrySet()) {</span>
            
<span class="fc bfc" id="L627" title="All 2 branches covered.">            if (alreadyCombined.contains(entry.getKey())) {</span>
<span class="fc" id="L628">                continue;</span>
            }
                        
<span class="fc" id="L631">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
            
<span class="fc" id="L633">            TransformationParameters params0 = entry.getValue();</span>
            
<span class="fc bfc" id="L635" title="All 2 branches covered.">            for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry2 : paramsMap.entrySet()) {</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">                if (entry2.getKey().equals(entry.getKey()) || </span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">                    alreadyCombined.contains(entry2.getKey())) {</span>
<span class="fc" id="L638">                    continue;</span>
                }
<span class="fc" id="L640">                TransformationParameters compare = entry2.getValue();</span>
<span class="fc" id="L641">                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L642">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="fc" id="L644">                    continue;</span>
                }
<span class="fc" id="L646">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="fc" id="L648">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="fc" id="L652">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="fc" id="L653">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="fc bfc" id="L654" title="All 4 branches covered.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="fc" id="L655">                    continue;</span>
                }
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (!alreadyCombined.contains(entry.getKey())) {</span>
<span class="fc" id="L658">                    alreadyCombined.add(entry.getKey());</span>
                }
<span class="fc" id="L660">                alreadyCombined.add(entry2.getKey());</span>
                
<span class="fc" id="L662">                set.add(params0);</span>
<span class="fc" id="L663">                set.add(compare);</span>
<span class="fc" id="L664">            }</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L666">                similarSets.add(set);</span>
            }
<span class="fc" id="L668">        }</span>
                  
        // use histograms to remove translation outliers in similar sets
        
<span class="fc" id="L672">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();

<span class="fc bfc" id="L675" title="All 2 branches covered.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="fc" id="L677">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="fc" id="L679">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="fc" id="L680">            filter(similar, keep);</span>
<span class="fc" id="L681">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="fc" id="L682">            filter(similar, keep);</span>
            
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L685">                continue;</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">            } else if (similar.size() == 1) {</span>
<span class="fc" id="L687">                combinedParams.add(similar.get(0));</span>
<span class="fc" id="L688">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="fc" id="L693">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="fc" id="L694">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="fc" id="L695">            combinedParams.add(params);</span>
<span class="fc" id="L696">        }</span>
        
        // sometimes, the averaged params in similarSets are similar to one
        // another too, so one more round of checking for similarity
<span class="fc" id="L700">        List&lt;TransformationParameters&gt; combinedParams2 = new ArrayList&lt;TransformationParameters&gt;();</span>
        
<span class="fc" id="L702">        Set&lt;TransformationParameters&gt; alreadyCombined2 = new HashSet&lt;TransformationParameters&gt;();</span>
        
<span class="fc bfc" id="L704" title="All 2 branches covered.">        for (TransformationParameters params0 : combinedParams) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">            if (alreadyCombined2.contains(params0)) {</span>
<span class="fc" id="L706">                continue;</span>
            }
<span class="fc" id="L708">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
<span class="fc" id="L709">            set.add(params0);</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">            for (TransformationParameters compare : combinedParams) {</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">                if (compare.equals(params0)) {</span>
<span class="fc" id="L712">                    continue;</span>
                }
<span class="fc bfc" id="L714" title="All 2 branches covered.">                if (alreadyCombined2.contains(compare)) {</span>
<span class="fc" id="L715">                    continue;</span>
                }
<span class="fc" id="L717">                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L718">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="fc" id="L720">                    continue;</span>
                }
<span class="fc" id="L722">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="fc" id="L724">                    continue;</span>
                }
                //TODO: may need to revise translation tolerance...
<span class="fc" id="L727">                double diffX = Math.abs(params0.getTranslationX() - compare.getTranslationX());</span>
<span class="fc" id="L728">                double diffY = Math.abs(params0.getTranslationY() - compare.getTranslationY());</span>
<span class="fc bfc" id="L729" title="All 4 branches covered.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)) {</span>
<span class="fc" id="L730">                    continue;</span>
                }
<span class="fc" id="L732">                set.add(compare);</span>
<span class="fc" id="L733">            }</span>
<span class="fc" id="L734">            alreadyCombined2.addAll(set);</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if (set.size() &gt; 1) {</span>
<span class="fc" id="L736">                MatchedPointsTransformationCalculator tc = new MatchedPointsTransformationCalculator();</span>
<span class="fc" id="L737">                TransformationParameters params =  tc.averageWithoutRemoval(</span>
                    new ArrayList&lt;TransformationParameters&gt;(set));
<span class="fc" id="L739">                combinedParams2.add(params);</span>
<span class="fc" id="L740">            } else {</span>
<span class="fc" id="L741">                combinedParams2.addAll(set);</span>
            }
<span class="fc" id="L743">        }</span>
        
<span class="fc" id="L745">        return combinedParams2;</span>
    }
    
    /**
     * comparing each parameter to others and if there are other
     * similar params, averaging those.
     * 
     * @param paramsMap
     * @param binFactor1
     * @param binFactor2
     * @return 
     */
    public static List&lt;TransformationParameters&gt; filterToSimilarParamSets2(
        Map&lt;PairInt, TransformationParameters&gt; paramsMap, int binFactor1,
        int binFactor2) {
        
<span class="fc" id="L761">        int transTol = 30;</span>
<span class="pc bpc" id="L762" title="1 of 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc" id="L763">            transTol /= ((binFactor1 + binFactor2)/2.f);</span>
        }
        
<span class="fc" id="L766">        List&lt;TransformationParameters&gt; combinedParams = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="fc" id="L769">        List&lt;Set&lt;TransformationParameters&gt;&gt; similarSets = </span>
            new ArrayList&lt;Set&lt;TransformationParameters&gt;&gt;();
        
<span class="fc" id="L772">        Set&lt;PairInt&gt; alreadyCombined = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L774" title="All 2 branches covered.">        for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry : paramsMap.entrySet()) {</span>
            
<span class="fc bfc" id="L776" title="All 2 branches covered.">            if (alreadyCombined.contains(entry.getKey())) {</span>
<span class="fc" id="L777">                continue;</span>
            }
                      
<span class="fc" id="L780">            Set&lt;TransformationParameters&gt; set = new HashSet&lt;TransformationParameters&gt;();</span>
            
<span class="fc" id="L782">            TransformationParameters params0 = entry.getValue();</span>
            
<span class="fc bfc" id="L784" title="All 2 branches covered.">            for (Map.Entry&lt;PairInt, TransformationParameters&gt; entry2 : paramsMap.entrySet()) {</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">                if (entry2.getKey().equals(entry.getKey()) || </span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">                    alreadyCombined.contains(entry2.getKey())) {</span>
<span class="fc" id="L787">                    continue;</span>
                }
<span class="fc" id="L789">                TransformationParameters compare = entry2.getValue();</span>
<span class="fc" id="L790">                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L791">                    params0.getRotationInDegrees(), compare.getRotationInDegrees());</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                if (Math.abs(diff) &gt; 20) {</span>
<span class="fc" id="L793">                    continue;</span>
                }
<span class="fc" id="L795">                float avg = (params0.getScale() + compare.getScale())/2.f;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">                if (Math.abs(params0.getScale() - compare.getScale()) &gt; 0.2*avg) {</span>
<span class="fc" id="L797">                    continue;</span>
                }
                                
                //TODO: may need to revise translation tolerance...
<span class="fc" id="L801">                double diffX = Math.abs(params0.getTranslationX()- compare.getTranslationX());</span>
<span class="fc" id="L802">                double diffY = Math.abs(params0.getTranslationY()- compare.getTranslationY());</span>
<span class="fc bfc" id="L803" title="All 4 branches covered.">                if ((diffX &gt; transTol) || (diffY &gt; transTol)){</span>
<span class="fc" id="L804">                    continue;</span>
                }
<span class="fc bfc" id="L806" title="All 2 branches covered.">                if (!alreadyCombined.contains(entry.getKey())) {</span>
<span class="fc" id="L807">                    alreadyCombined.add(entry.getKey());</span>
                }
<span class="fc" id="L809">                alreadyCombined.add(entry2.getKey());</span>
                
<span class="fc" id="L811">                set.add(params0);</span>
<span class="fc" id="L812">                set.add(compare);</span>
<span class="fc" id="L813">            }</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (set.isEmpty()) {</span>
<span class="fc" id="L815">                combinedParams.add(params0);</span>
            } else {
<span class="fc" id="L817">                similarSets.add(set);</span>
            }
<span class="fc" id="L819">        }</span>
        
        // use histograms to remove translation outliers in similar sets

<span class="fc bfc" id="L823" title="All 2 branches covered.">        for (Set&lt;TransformationParameters&gt; similarSet : similarSets) {</span>
            
<span class="fc" id="L825">            List&lt;TransformationParameters&gt; similar = </span>
                new ArrayList&lt;TransformationParameters&gt;(similarSet);
<span class="fc" id="L827">            int[] keep = filterForTranslationXUsingHist(similar);</span>
<span class="fc" id="L828">            Set&lt;Integer&gt; unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            for (Integer ind : unique) {</span>
<span class="fc" id="L830">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="fc" id="L831">            }</span>
            
<span class="fc" id="L833">            filter(similar, keep);</span>
<span class="fc" id="L834">            keep = filterForTranslationYUsingHist(similar);</span>
<span class="fc" id="L835">            unique = MiscStats.indexesNotPresent(keep, similar.size());</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">            for (Integer ind : unique) {</span>
<span class="fc" id="L837">                combinedParams.add(similar.get(ind.intValue()));</span>
<span class="fc" id="L838">            }</span>
<span class="fc" id="L839">            filter(similar, keep);</span>
            
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">            if (similar.isEmpty()) {</span>
<span class="nc" id="L842">                continue;</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            } else if (similar.size() == 1) {</span>
<span class="fc" id="L844">                combinedParams.add(similar.get(0));</span>
<span class="fc" id="L845">                continue;</span>
            }
            
            //average them
            MatchedPointsTransformationCalculator
<span class="fc" id="L850">                tc = new MatchedPointsTransformationCalculator();</span>
<span class="fc" id="L851">            TransformationParameters params =  tc.averageWithoutRemoval(similar);</span>
<span class="fc" id="L852">            combinedParams.add(params);</span>
<span class="fc" id="L853">        }</span>
        
<span class="fc" id="L855">        return combinedParams;</span>
    }
    
    public static Set&lt;Integer&gt; indexesNotPresent(int[] indexes, int totalNumber) {
<span class="fc" id="L859">        int n = totalNumber = indexes.length;</span>
<span class="fc" id="L860">        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">        for (int index : indexes) {</span>
<span class="fc" id="L862">            set.add(Integer.valueOf(index));</span>
        }
<span class="fc" id="L864">        Set&lt;Integer&gt; diff = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">        for (int i = 0; i &lt; totalNumber; ++i) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">            if (!set.contains(Integer.valueOf(i))) {</span>
<span class="fc" id="L867">                diff.add(Integer.valueOf(i));</span>
            }
        }
<span class="fc" id="L870">        return diff;</span>
    }

    private static void filter(List&lt;TransformationParameters&gt; params, 
        int[] indexesToKeep) {
                
<span class="fc bfc" id="L876" title="All 2 branches covered.">        if (indexesToKeep.length &lt; 2) {</span>
<span class="fc" id="L877">            return;</span>
        }
        
<span class="fc" id="L880">        List&lt;TransformationParameters&gt; paramsList2 = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (int i = 0; i &lt; indexesToKeep.length;++i) {</span>
<span class="fc" id="L884">            int idx = indexesToKeep[i];</span>
<span class="fc" id="L885">            paramsList2.add(params.get(idx));</span>
        }
                
<span class="fc" id="L888">        params.clear();</span>
<span class="fc" id="L889">        params.addAll(paramsList2);</span>
<span class="fc" id="L890">    }</span>
    
    public static TransformationParameters calculateTransformation(int binFactor1, 
        int binFactor2, List&lt;FeatureComparisonStat&gt; compStats, 
        float[] outputScaleRotTransXYStDev) {
        
<span class="pc bpc" id="L896" title="3 of 4 branches missed.">        assert (compStats.isEmpty() == false);</span>
        
<span class="fc" id="L898">        FeatureMatcher.removeIntensityOutliers(compStats);</span>
        
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">        if (compStats.size() &lt; 2) {</span>
<span class="nc" id="L901">            return null;</span>
        }
        
<span class="fc" id="L904">        MatchedPointsTransformationCalculator tc = </span>
            new MatchedPointsTransformationCalculator();
        
<span class="fc" id="L907">        int centroidX1 = 0;</span>
<span class="fc" id="L908">        int centroidY1 = 0;</span>
        
<span class="fc" id="L910">        PairIntArray matchedXY1 = new PairIntArray();</span>
<span class="fc" id="L911">        PairIntArray matchedXY2 = new PairIntArray();</span>
        
<span class="fc" id="L913">        float[] weights = new float[compStats.size()];</span>
        
<span class="fc" id="L915">        double sum = 0;</span>
        
<span class="fc bfc" id="L917" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="fc" id="L919">            FeatureComparisonStat compStat = compStats.get(i);</span>
            
<span class="fc" id="L921">            int x1 = compStat.getImg1Point().getX() * binFactor1;</span>
<span class="fc" id="L922">            int y1 = compStat.getImg1Point().getY() * binFactor1;</span>
            
<span class="fc" id="L924">            matchedXY1.add(x1, y1);</span>
            
<span class="fc" id="L926">            int x2 = compStat.getImg2Point().getX() * binFactor2;</span>
<span class="fc" id="L927">            int y2 = compStat.getImg2Point().getY() * binFactor2;</span>
            
<span class="fc" id="L929">            matchedXY2.add(x2, y2);</span>
            
<span class="fc" id="L931">            weights[i] = compStat.getSumIntensitySqDiff();</span>
            
<span class="fc" id="L933">            sum += weights[i];</span>
        }

<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if (sum &gt; 0) {</span>
            
<span class="fc" id="L938">            double tot = 0;</span>

<span class="fc bfc" id="L940" title="All 2 branches covered.">            for (int i = 0; i &lt; compStats.size(); ++i) {</span>

<span class="fc" id="L942">                double div = (sum - weights[i]) / ((compStats.size() - 1) * sum);</span>

<span class="fc" id="L944">                weights[i] = (float) div;</span>

<span class="fc" id="L946">                tot += div;</span>
            }
 
<span class="pc bpc" id="L949" title="3 of 4 branches missed.">            assert(Math.abs(tot - 1.) &lt; 0.03);</span>
            
<span class="fc" id="L951">        } else {</span>
<span class="nc" id="L952">            float a = 1.f/weights.length;</span>
<span class="nc" id="L953">            Arrays.fill(weights, a);</span>
        }
        
<span class="fc" id="L956">        TransformationParameters params = tc.calulateEuclidean(matchedXY1, </span>
            matchedXY2, weights, centroidX1, centroidY1, 
            outputScaleRotTransXYStDev);
        
<span class="fc" id="L960">        return params;</span>
    }

    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param pointValueMap
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndValues(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L977">        int minTheta = Integer.MAX_VALUE;</span>
<span class="nc" id="L978">        int maxTheta = Integer.MIN_VALUE;</span>
                
<span class="nc bnc" id="L980" title="All 2 branches missed.">        for (Map.Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L981">            int v = Math.round(entry.getValue().floatValue());</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (v &lt; minTheta) {</span>
<span class="nc" id="L983">                minTheta = v;</span>
            }
<span class="nc bnc" id="L985" title="All 2 branches missed.">            if (v &gt; maxTheta) {</span>
<span class="nc" id="L986">                maxTheta = v;</span>
            }
<span class="nc" id="L988">        }</span>
                
<span class="nc bnc" id="L990" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // sort values and find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L995">            int[] values = new int[pointValueMap.size()];</span>
<span class="nc" id="L996">            int count = 0;</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            for (Map.Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L998">                values[count] = Math.round(entry.getValue().floatValue());</span>
<span class="nc" id="L999">                count++;</span>
<span class="nc" id="L1000">            }</span>
<span class="nc" id="L1001">            Arrays.sort(values);</span>
            
<span class="nc" id="L1003">            return determineStartEndValues(values, maxValueForWrapAround, </span>
                toleranceInValue);
        }
        
<span class="nc" id="L1007">        return new int[]{minTheta, maxTheta};</span>
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndValues(int[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1024">        int[] startEndIndexes = determineStartEndIndexes(sortedValues, </span>
            maxValueForWrapAround, toleranceInValue);
        
<span class="nc" id="L1027">        return new int[]{sortedValues[startEndIndexes[0]], </span>
            sortedValues[startEndIndexes[1]]};
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndIndexes(int[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1045">        int minTheta = sortedValues[0];</span>
<span class="nc" id="L1046">        int maxTheta = sortedValues[sortedValues.length - 1];</span>
         
<span class="nc bnc" id="L1048" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1053">            int endIdx = -1;</span>
<span class="nc" id="L1054">            int startIdx = -1;</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">            for (int i = 0; i &lt; (sortedValues.length - 1); ++i) {</span>
<span class="nc" id="L1056">                int diff = sortedValues[i + 1] - sortedValues[i];</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                if (diff &gt; (toleranceInValue + 1)) {</span>
<span class="nc" id="L1058">                    endIdx = i;</span>
<span class="nc" id="L1059">                    startIdx = i;</span>
<span class="nc" id="L1060">                    break;</span>
                }
            }
<span class="nc bnc" id="L1063" title="All 4 branches missed.">            if (startIdx &gt; -1 &amp;&amp; endIdx &gt; -1) {</span>
<span class="nc" id="L1064">                return new int[]{startIdx, endIdx};</span>
            }
        }
        
<span class="nc" id="L1068">        return new int[]{0, sortedValues.length - 1};</span>
    }
    
    /**
     * for a map of points whose values lie between 0 and maxValueForWrapAround,
     * find the boundaries of the range, knowing that each point in the 
     * contiguous range is separated by &lt;= toleranceInValue.  If the contiguous
     * portion wraps around from maxValueForWrapAround to 0 or beyond,
     * the returned int[]{start, end} will have a start &gt; end.
     * @param sortedValues
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @return 
     */
    public static int[] determineStartEndIndexes(float[] sortedValues, 
        int maxValueForWrapAround, int toleranceInValue) {
        
<span class="nc" id="L1085">        float minTheta = sortedValues[0];</span>
<span class="nc" id="L1086">        float maxTheta = sortedValues[sortedValues.length - 1];</span>
         
<span class="nc bnc" id="L1088" title="All 4 branches missed.">        if ((minTheta == 0) &amp;&amp; (maxTheta == maxValueForWrapAround)) {</span>
            
            // find where delta &gt; toleranceInValues.
            // that's the end of wrap around and beginning of wrap around
            
<span class="nc" id="L1093">            int endIdx = -1;</span>
<span class="nc" id="L1094">            int startIdx = -1;</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            for (int i = 0; i &lt; (sortedValues.length - 1); ++i) {</span>
<span class="nc" id="L1096">                float diff = sortedValues[i + 1] - sortedValues[i];</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if (diff &gt; (toleranceInValue + 1)) {</span>
<span class="nc" id="L1098">                    endIdx = i;</span>
<span class="nc" id="L1099">                    startIdx = i;</span>
<span class="nc" id="L1100">                    break;</span>
                }
            }
<span class="nc bnc" id="L1103" title="All 4 branches missed.">            if (startIdx &gt; -1 &amp;&amp; endIdx &gt; -1) {</span>
<span class="nc" id="L1104">                return new int[]{startIdx, endIdx};</span>
            }
        }
        
<span class="nc" id="L1108">        return new int[]{0, sortedValues.length - 1};</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
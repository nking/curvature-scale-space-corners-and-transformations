<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RANSACAlgorithmIterations.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.util</a> &gt; <span class="el_source">RANSACAlgorithmIterations.java</span></div><h1>RANSACAlgorithmIterations.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.util;

/**
 * estimates the number of iterations for a RANSAC type algorithm that 
 * should be used to ensure with 95% certainty that a set of points is 
 * findable as a subset of n matchable points.
 * 
 * @author nichole
 */
<span class="fc" id="L10">public class RANSACAlgorithmIterations {</span>
    
    /**
     The estimate assumes that at least 25 percent of the nMatchedPoints
     are outliers and determines the number of iterations needed for a 95%
     certainty that 8 points drawn randomly from nMatchedPoints will all be
     &quot;true&quot; matches, that is, not outliers.
     
     &lt;pre&gt;
     It uses this table generated below following the statistics in the comments
     at the end of this class.
     
                    | nInliers percentage of nTotal
     nMatchedPoints |   50       75       100
     ------------------------------------------------------
       30   |       | 0.001  | 0.05   |  1.0
       50   |       | 0.002  | 0.07   |  1.0
      100   |       | 0.003  | 0.09   |  1.0
      500   |       | 0.004  | 0.1    |  1.0
     1000   |       | 0.004  | 0.1    |  1.0
     &lt;/pre&gt;
     
     * @param nMatchedPoints
     * @return 
     */
    public int estimateNIterForTwentyFivePercentOutliersFor8Points(
        int nMatchedPoints) {
        
        double p;
<span class="nc bnc" id="L39" title="All 2 branches missed.">        if (nMatchedPoints &lt;= 30) {</span>
<span class="nc" id="L40">            p = 0.05;</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">        } else if (nMatchedPoints &lt;= 50) {</span>
<span class="nc" id="L42">            p = 0.07;</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">        } else if (nMatchedPoints &lt;= 100) {</span>
<span class="nc" id="L44">            p = 0.09;</span>
        } else  {
<span class="nc" id="L46">            p = 0.1;</span>
        }
        
<span class="nc" id="L49">        int nIter = (int)Math.round(1./p);</span>
        
<span class="nc" id="L51">        return nIter;</span>
    }
    
    /**
     The estimate assumes that at least 50 percent of the nMatchedPoints
     are outliers and determines the number of iterations needed for a 95%
     certainty that 8 points drawn randomly from nMatchedPoints will all be
     &quot;true&quot; matches, that is, not outliers.
     
     &lt;pre&gt;
     It uses this table generated below following the statistics in the comments
     at the end of this class.
     
                    | nInliers percentage of nTotal
     nMatchedPoints |   50       75       100
     ------------------------------------------------------
       30   |       | 0.001  | 0.05   |  1.0
       50   |       | 0.002  | 0.07   |  1.0
      100   |       | 0.003  | 0.09   |  1.0
      500   |       | 0.004  | 0.1    |  1.0
     1000   |       | 0.004  | 0.1    |  1.0
     &lt;/pre&gt;
     
     * @param nMatchedPoints
     * @return 
     */
    public int estimateNIterForFiftyPercentOutliersFor8Points(int nMatchedPoints) {
        
        double p;
<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (nMatchedPoints &lt;= 30) {</span>
<span class="nc" id="L81">            p = 0.001;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        } else if (nMatchedPoints &lt;= 50) {</span>
<span class="nc" id="L83">            p = 0.002;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        } else if (nMatchedPoints &lt;= 100) {</span>
<span class="nc" id="L85">            p = 0.003;</span>
        } else  {
<span class="nc" id="L87">            p = 0.004;</span>
        }
        
<span class="nc" id="L90">        int nIter = (int)Math.round(1./p);</span>
        
<span class="nc" id="L92">        return nIter;</span>
    }

    /**
     The estimate assumes that at least 50 percent of the nMatchedPoints
     are outliers and determines the number of iterations needed for a 95%
     certainty that 7 points drawn randomly from nMatchedPoints will all be
     &quot;true&quot; matches, that is, not outliers.
     
     &lt;pre&gt;
     It uses this table generated below following the statistics in the comments
     at the end of this class.
     
                    | nInliers percentage of nTotal
     nMatchedPoints |   50       75       100
     ------------------------------------------------------
       30   |       | 0.003  | 0.084  |  1.0
       50   |       | 0.0048 | 0.10   |  1.0
      100   |       | 0.006  | 0.124  |  1.0
      500   |       | 0.0075 | 0.132  |  1.0
     1000   |       | 0.0076 | 0.133  |  1.0
     &lt;/pre&gt;
     
     * @param nMatchedPoints
     * @return 
     */
    public int estimateNIterForFiftyPercentOutliersFor7Points(int nMatchedPoints) {
        
        double p;
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (nMatchedPoints &lt;= 30) {</span>
<span class="fc" id="L122">            p = 0.003;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        } else if (nMatchedPoints &lt;= 50) {</span>
<span class="fc" id="L124">            p = 0.0048;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        } else if (nMatchedPoints &lt;= 100) {</span>
<span class="fc" id="L126">            p = 0.006;</span>
        } else  {
<span class="fc" id="L128">            p = 0.0075;</span>
        }
        
<span class="fc" id="L131">        int nIter = (int)Math.round(1./p);</span>
        
<span class="fc" id="L133">        return nIter;</span>
    }

    /**
     The estimate assumes that at least 15 percent of the nPoints
     are true matches with points in another set of points
     and determines the number of iterations needed for a 95%
     certainty that 2 points drawn randomly from nPoints will all be
     &quot;truly matchable&quot; with points in set2 (whose characteristics are
     presumed to be similar).
     
     &lt;pre&gt;
     It uses this table generated below following the statistics in the comments
     at the end of this class.
     
             | nInliers percentage of nTotal
     nPoints |  15        25       50       75
     ------------------------------------------------------
       30    | 0.014  | 0.05   | 0.24   |  0.53
       50    | 0.017  | 0.054  | 0.245  |  0.54
      100    | 0.021  | 0.061  | 0.247  |  0.56
      177    | 0.021  | 0.061  | 0.246  |  0.56
      500    | 0.022  | 0.062  | 0.25   |  0.56
     1000    | 0.022  | 0.062  | 0.25   |  0.56
     &lt;/pre&gt;
     
     * @param nPoints
     * @return 
     */
    public int estimateNIterForFifteenPercentOutliersFor2Points(int nPoints) {
        
        double p;
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (nPoints &lt;= 30) {</span>
<span class="nc" id="L166">            p = 0.014;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        } else if (nPoints &lt;= 50) {</span>
<span class="nc" id="L168">            p = 0.017;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        } else if (nPoints &lt;= 100) {</span>
<span class="nc" id="L170">            p = 0.021;</span>
        } else  {
<span class="nc" id="L172">            p = 0.022;</span>
        }
        
<span class="nc" id="L175">        int nIter = (int)Math.round(1./p);</span>
        
<span class="nc" id="L177">        return nIter;</span>
    }
    
    /**
    using estimates for the number of iterations required to
    lower the probability that a set of nSet inliers is not found to 
    1-0.95=0.05 from:
    http://6.869.csail.mit.edu/fa12/lectures/lecture13ransac/lecture13ransac.pdf

    Note: this assumes that the user's nPoints &gt;&gt; nIter.

    g = probability of inliers in pairs of (unmatchedLeftXY, unmatchedRightXY)

    p = nSet

    0.05 = (1 - g^p)^nIter

    log(0.05) = nIter * log(1 - g^p) ==&gt; nIter = log(0.05) / log(1 - g^p)

    for g=0.5 and p=7, nIter = 382.
    int nIter = (int)Math.ceil(Math.log(0.05)/Math.log(1 - Math.pow(g, nSet)));
        
     * @return 
     */
    public int estimateNIterUsingStandardRANSACApproximation(
        double probabilityOfInliers, int nSubset) {
        
<span class="nc" id="L204">        int nIter = (int)Math.ceil(Math.log(0.05)/</span>
<span class="nc" id="L205">            Math.log(1 - Math.pow(probabilityOfInliers, nSubset)));</span>
        
<span class="nc" id="L207">        return nIter;</span>
    }

}

/*
&lt;pre&gt;
There are nTotal matches, that is nTotal sets of points thought to be matched.

nInliers is the number of points within nTotal that are within tolerance
of a good fit (which is defined as a 'true' match).

p = (nInliers/nTotal) inliers
1 - p = 1 - (nInliers/nTotal) outliers or (nOutliers/nTotal)

subset size is 8

8 points are drawn randomly from nTotal points.

probability of drawing 8 'true' inliers:

                             C(8 inliers of nInliers)
     p = 8 inliers =  -------------------------------------   
                       C(8 points drawn from nTotal points)

                      where C is C(n, k) = n! / ( k!*(n - k)! )

                       ( nInliers! / ( 8!*(nInliers - 8)! )
                   =  -------------------------------------------
                       ( nTotal! / ( 8!*(nTotal - 8)! )

what number of throws will result in 95% certainty that a subset of 8 contained 
all 'true' inliers?

(Bernoulli process:)
     throw nRequired number of times. 
     p above gives probability of success for a throw.
     we want to know the total probability that results in one of the 
     nRequired being a success (all inliers).

     P(k) = (n!/(k!(n-k)!)) * p^k * (1 - p)^(N-k)

     P(1) = (nRequired!/(1!(nRequired-1)!)) * p^1 * (1 - p)^(nRequired-1)

     PDesired = (nRequired!/(1!(nRequired-1)!)) * p^1 * (1 - p)^(nRequired-1)
                 nRequired!
              = -------------- * p * (1 - p)^(nRequired - 1)
                (nRequired-1)!

              = nRequired * p * (1 - p)^(nRequired - 1)

     set PDesired = 0.95;  estimate p for nInliers = 0%, 25%, 50%, 75%, 100%
     and estimate nRequired from those.

used the python scripts below for a quick fill of this table:

      p:
            | nInliers percentage of nTotal
     nToTal |  25       50       75       100
     ------------------------------------------------------
       30   |  ~0    | 0.001  | 0.05   |  1.0
       50   |  ~0    | 0.002  | 0.07   |  1.0
      100   |  ~0    | 0.003  | 0.09   |  1.0
      500   |  ~0    | 0.004  | 0.1    |  1.0
     1000   |  ~0    | 0.004  | 0.1    |  1.0

for PDesired = 0.95, nTotal=30, p=75%(=0.05)
     0.95 = nRequired * p * (1 - p)^(nRequired - 1)
     0.95 = nRequired * 0.05 * (0.95)^(nRequired - 1)
     19 = nRequired * (0.95)^(nRequired - 1)
        = nRequired * math.pow(0.95, (nRequired - 1))
        = nRequired * 0.95

====&gt; nRequired = 1/p &lt;====

python code for the table above:

def factorial(n) :
    result = 1;
    n = int(n)
    for i in range(1, n+1):
        result *= i;
    return result;

def factorialNDivNMinusK(n, k) :
    result = 1;
    n = int(n)
    for i in range((n-k)+1, n+1):
        result *= i;
    return result;

def tbl() :
    nTotal = [30, 50, 100, 500, 1000];
    nInFrac = [.25, .50, .75, 1.0];
    fracLen = len(nInFrac)
    for nT in nTotal:
        for ii in range(0, fracLen):
            nF = nInFrac[ii]
            nI = nT * nF
            f0 = factorialNDivNMinusK(nI, 7) * 1.0
            f2 = factorialNDivNMinusK(nT, 7) * 1.0
            f7 = factorial(7) * 1.0
            p = f0 / f2
            f0 = f0 / f7
            f2 = f2 / f7
            print &quot;nTotal=&quot;, nT, &quot; nInliers fraction=&quot;, nF, &quot; p=&quot;, p
    return;

==============

The same logic as above, used for finding 2 truly matchable points within set1:

      p:
            | nInliers percentage of nTotal
     nToTal |  15        25       50       75
     ------------------------------------------------------
       30   | 0.014  | 0.05   | 0.24   |  0.53
       50   | 0.017  | 0.054  | 0.245  |  0.54
      100   | 0.021  | 0.061  | 0.247  |  0.56
      177   | 0.021  | 0.061  | 0.246  |  0.56
      500   | 0.022  | 0.062  | 0.25   |  0.56
     1000   | 0.022  | 0.062  | 0.25   |  0.56

&lt;/pre&gt;
*/
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
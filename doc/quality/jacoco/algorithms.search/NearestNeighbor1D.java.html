<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NearestNeighbor1D.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.search</a> &gt; <span class="el_source">NearestNeighbor1D.java</span></div><h1>NearestNeighbor1D.java</h1><pre class="source lang-java linenums">package algorithms.search;

import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.hash.TIntIntHashMap;
import java.util.HashSet;
import java.util.Set;
import thirdparty.ods.Integerizer;
import thirdparty.ods.XFastTrie;
import thirdparty.ods.XFastTrieNode;

/**
 * a nearest neighbor's algorithm using XFastTrie
 * for predecessor and successor queries
 * on spatially indexed numbers.
 * 
 * The algorithm performs better on dense data
 * (that is because the base of the prefix tree
 * is filled, leaving smaller number of nodes to
 * create in linear time).
 * The queries depend upon the maximum of x to be queried.
 * 
 * @author nichole
 */
public class NearestNeighbor1D {
    
    private final XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt; xbt;
            
    private final int maxIndex;
    
    /**
     * 
     * @param maxX maximum x value of any data point including
     *    those to be queries
     */
<span class="fc" id="L39">    public NearestNeighbor1D(int maxX) {</span>

<span class="fc" id="L41">        maxIndex = maxX + 1;</span>
        
<span class="fc" id="L43">        Integerizer&lt;Integer&gt; it = new Integerizer&lt;Integer&gt;() {</span>
            @Override
            public int intValue(Integer x) {
                return x;
            }
        };
        
<span class="fc" id="L50">        int maxW = 1 + (int)Math.ceil(Math.log(maxIndex)/Math.log(2));</span>
<span class="fc" id="L51">        xbt = new XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt;(</span>
            new XFastTrieNode&lt;Integer&gt;(), it, maxW);
<span class="fc" id="L53">    }</span>
    
    public void insert(int index) {
<span class="fc" id="L56">        xbt.add(Integer.valueOf(index));</span>
<span class="fc" id="L57">    }</span>
    
    /**
    &lt;pre&gt;
      best case: O(1) if key exists in
         the trie, else 2 * O(log_2(maxW)).
            
     Note: maxW = 1 + Math.ceil(Math.log(maxX)/Math.log(2));            
     &lt;/ore&gt;
    
     * @param x
     */
    public TIntSet findClosest(final int x) {        
<span class="fc" id="L70">        return findClosest(x, Integer.MAX_VALUE);</span>
    }
    
    /**
    &lt;pre&gt;
      runtime complexity is
         best case: O(1) if key exists in
         the trie, else 2 * O(log_2(maxW)).
                     
      Note: maxW = 1 + Math.ceil(Math.log(maxX * maxY)/Math.log(2));
     &lt;/ore&gt;
    
     * @param x
     * @param dMax
     * @return a set of values within dMax that are the 
     * closest points, else returns an empty set
     */
    public TIntSet findClosest(int x, int dMax) {
        
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (x &gt;= maxIndex) {</span>
<span class="nc" id="L90">            throw new IllegalArgumentException(&quot;x cannot be larger than &quot;</span>
                + &quot; maxX given in constructor, &quot; + (maxIndex-1));
        }
         
<span class="fc" id="L94">        TIntSet closestIndexes = new TIntHashSet();</span>
        
<span class="fc" id="L96">        Integer srch = Integer.valueOf(x);</span>
        
        //O(1)
<span class="fc" id="L99">        Integer q = xbt.find(srch);</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (q != null) {</span>
<span class="nc" id="L101">            closestIndexes.add(srch.intValue());</span>
<span class="nc" id="L102">            return closestIndexes;</span>
        }
        
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (dMax == 0) {</span>
<span class="nc" id="L106">            return closestIndexes;</span>
        }
                        
        //O(log_2(maxW))
<span class="fc" id="L110">        Integer predecessor = xbt.predecessor(srch);</span>
<span class="fc" id="L111">        Integer successor = xbt.successor(srch);</span>
        
<span class="fc" id="L113">        double dp2 = dist(x, predecessor);</span>
<span class="fc" id="L114">        double ds2 = dist(x, successor);</span>
    
<span class="pc bpc" id="L116" title="1 of 4 branches missed.">        if (dp2 == ds2 &amp;&amp; (ds2 &lt;= dMax)) {</span>
<span class="fc" id="L117">            closestIndexes.add(predecessor.intValue());</span>
<span class="fc" id="L118">            closestIndexes.add(successor.intValue());</span>
<span class="pc bpc" id="L119" title="2 of 4 branches missed.">        } else if ((dp2 &lt; ds2) &amp;&amp; (dp2 &lt;= dMax)) {</span>
<span class="fc" id="L120">            closestIndexes.add(predecessor.intValue());</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">        } else if ((ds2 &lt; dp2) &amp;&amp; (ds2 &lt;= dMax)) {</span>
<span class="nc" id="L122">            closestIndexes.add(successor.intValue());</span>
        }
        
<span class="fc" id="L125">        return closestIndexes;</span>
    }

    private double dist(int x, Integer p2) {
        
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (p2 == null) {</span>
<span class="nc" id="L131">            return Double.MAX_VALUE;</span>
        }
        
<span class="fc" id="L134">        int diff = p2.intValue() - x;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (diff &lt; 0) {</span>
<span class="fc" id="L136">            diff *= -1;</span>
        }
        
<span class="fc" id="L139">        return diff;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
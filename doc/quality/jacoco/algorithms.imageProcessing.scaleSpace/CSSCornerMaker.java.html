<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSSCornerMaker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.scaleSpace</a> &gt; <span class="el_source">CSSCornerMaker.java</span></div><h1>CSSCornerMaker.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.scaleSpace;

import algorithms.QuickSort;
import algorithms.imageProcessing.ImageStatisticsHelper;
import algorithms.compGeometry.MiscellaneousCurveHelper;
import algorithms.imageProcessing.SIGMA;
import algorithms.imageProcessing.features.CornerRegion;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MinMaxPeakFinder;
import algorithms.util.CornerArray;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;

/**
 The code is implemented from interpreting several papers by the authors
 * Farzin Mokhtarian and Alan Mackworth.
 *
 * They prescribe a method for detecting features and corners that is scale
 * invariant, rotation and translation invariant and does not create
 * artifacts as a side effect.
 *
 * The method finds edges in an image and then calculates the curvature of
 * the edges to find &quot;inflection&quot; points along the curve.  Those points of
 * inflection as a function of scale parameter t are then findable in
 * another image that may have rotation or translation, for example, using
 * a search method such as A* to find the best matching features in t space.
 * The process of creating the scale based curves is repeated for increasing
 * sigma until no points are found with curvature = 0.
 *
 * The method uses the recursive and separable properties of Gaussians where
 * possible.  (NOTE, not finished implementing the recursive portion).
 * Also, the curves can be closed curves and derived from means other than
 * edge detectors.
 *
 * @author nichole
 */
public class CSSCornerMaker {

<span class="fc" id="L48">    protected float factorIncreaseForCurvatureMinimum = 1.f;</span>

<span class="fc" id="L50">    protected boolean performWholeImageCorners = true;</span>

<span class="fc" id="L52">    protected boolean doStoreCornerRegions = true;</span>

    protected final int width;

    protected final int height;

<span class="fc" id="L58">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L60">    public CSSCornerMaker(int imageWidth, int imageHeight) {</span>
<span class="fc" id="L61">        width = imageWidth;</span>
<span class="fc" id="L62">        height = imageHeight;</span>
<span class="fc" id="L63">    }</span>

    public void doNotStoreCornerRegions() {
<span class="fc" id="L66">        doStoreCornerRegions = false;</span>
<span class="fc" id="L67">    }</span>

    public void increaseFactorForCurvatureMinimum(float factor) {
<span class="nc" id="L70">        factorIncreaseForCurvatureMinimum = factor;</span>
<span class="nc" id="L71">    }</span>

    public void resetFactorForCurvatureMinimum() {
<span class="nc" id="L74">        factorIncreaseForCurvatureMinimum = 1.f;</span>
<span class="nc" id="L75">    }</span>
    
    public List&lt;CornerArray&gt; findCornersInScaleSpaceMaps(
        final List&lt;PairIntArray&gt; theEdges) {
        
        /*
        for each edge, create scale space maps for each sigma in the range.
            and calculate corners for the edges for each sigma.
        
        after all scale space curve corners are calculated for all sigma,
            select the representative sigma as the one in which a corner
            is seen at its maximum value.
        
        create an output list of the corners for each edge at that selected
            sigma.
        */
        
        // for each edge, an item is a list of the corners for a sigm odered 
        // from max to min sigma
<span class="fc" id="L94">        List&lt;List&lt;CornerArray&gt;&gt; edgeCornerLists = new ArrayList&lt;List&lt;CornerArray&gt;&gt;();</span>
       
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        for (PairIntArray edge : theEdges) {</span>
<span class="nc" id="L97">            List&lt;CornerArray&gt; scaleSpaceCorners = findCornersInScaleSpaceMaps(edge);</span>
<span class="nc" id="L98">            edgeCornerLists.add(scaleSpaceCorners);</span>
<span class="nc" id="L99">        }</span>
        
        // for each edge, find the maximum curvature and its sigma
<span class="nc" id="L102">        List&lt;Float&gt; maxKs = new ArrayList&lt;Float&gt;();</span>
<span class="nc" id="L103">        List&lt;SIGMA&gt; maxSigmas = new ArrayList&lt;SIGMA&gt;();</span>
        
<span class="nc bnc" id="L105" title="All 2 branches missed.">        for (List&lt;CornerArray&gt; scaleSpaceCorners : edgeCornerLists) {</span>
                        
            // find the maximum k for each point and the sigma for it
<span class="nc" id="L108">            Map&lt;Integer, Float&gt; maxKMap = new HashMap&lt;Integer, Float&gt;();</span>
<span class="nc" id="L109">            Map&lt;Integer, SIGMA&gt; maxKSigmasMap = new HashMap&lt;Integer, SIGMA&gt;();</span>
            
<span class="nc bnc" id="L111" title="All 2 branches missed.">            for (CornerArray corners : scaleSpaceCorners) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                for (int i = 0; i &lt; corners.getN(); ++i) {</span>
                    
<span class="nc" id="L114">                    float k = Math.abs(corners.getCurvature(i));</span>
<span class="nc" id="L115">                    Integer key = Integer.valueOf(i);</span>
                    
<span class="nc" id="L117">                    Float kMax = maxKMap.get(key);</span>
<span class="nc bnc" id="L118" title="All 4 branches missed.">                    if ((kMax == null) || (kMax.floatValue() &lt; k)) {</span>
<span class="nc" id="L119">                        maxKMap.put(key, Float.valueOf(k));</span>
<span class="nc" id="L120">                        maxKSigmasMap.put(key, corners.getSIGMA());</span>
                    }
                }
<span class="nc" id="L123">            }</span>
            
<span class="nc" id="L125">            float maxK = Float.NEGATIVE_INFINITY;</span>
<span class="nc" id="L126">            SIGMA maxKSigma = null;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            for (Entry&lt;Integer, Float&gt; entry : maxKMap.entrySet()) {</span>
<span class="nc" id="L128">                Float k = entry.getValue().floatValue();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                if (k &gt; maxK) {</span>
<span class="nc" id="L130">                    maxK = k;</span>
<span class="nc" id="L131">                    maxKSigma = maxKSigmasMap.get(entry.getKey());</span>
                }
<span class="nc" id="L133">            }</span>
<span class="nc" id="L134">            maxSigmas.add(maxKSigma);</span>
<span class="nc" id="L135">            maxKs.add(Float.valueOf(maxK));</span>
<span class="nc" id="L136">        }</span>
        
<span class="nc" id="L138">        QuickSort.&lt;SIGMA&gt;descendingSort(maxKs, maxSigmas);</span>
        
        // choose the most frequent sigma from the top quarter of k's
<span class="nc" id="L141">        int n = maxKs.size()/4;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L143">            n = maxKs.size();</span>
        }
<span class="nc" id="L145">        Map&lt;SIGMA, Integer&gt; sigmaCountMap = new HashMap&lt;SIGMA, Integer&gt;();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L147">            SIGMA sigma = maxSigmas.get(i);</span>
<span class="nc" id="L148">            Integer count = sigmaCountMap.get(sigma);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            if (count == null) {</span>
<span class="nc" id="L150">                sigmaCountMap.put(sigma, Integer.valueOf(1));</span>
            } else {
<span class="nc" id="L152">                sigmaCountMap.put(sigma, Integer.valueOf(count.intValue() + 1));</span>
            }
        }
<span class="nc" id="L155">        int maxCount = Integer.MIN_VALUE;</span>
<span class="nc" id="L156">        SIGMA selectedSigma = null;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        for (Entry&lt;SIGMA, Integer&gt; entry : sigmaCountMap.entrySet()) {</span>
<span class="nc" id="L158">            int c = entry.getValue().intValue();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (c &gt; maxCount) {</span>
<span class="nc" id="L160">                selectedSigma = entry.getKey();</span>
<span class="nc" id="L161">                maxCount = c;</span>
            }
<span class="nc" id="L163">        }</span>
        
<span class="nc" id="L165">        List&lt;CornerArray&gt; output = new ArrayList&lt;CornerArray&gt;();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        for (List&lt;CornerArray&gt; scaleSpaceCorners : edgeCornerLists) {</span>
<span class="nc" id="L167">            boolean found = false;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            for (CornerArray corners : scaleSpaceCorners) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                if (corners.getSIGMA() == selectedSigma) {</span>
<span class="nc" id="L170">                    output.add(corners);</span>
<span class="nc" id="L171">                    found = true;</span>
<span class="nc" id="L172">                    break;</span>
                }
<span class="nc" id="L174">            }</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L176">                output.add(new CornerArray(selectedSigma));</span>
            }
<span class="nc" id="L178">        }</span>
            
<span class="nc" id="L180">        output = filterCornersForMinResolvable(output);</span>
        
<span class="nc" id="L182">        output = filterCornersUsing2ndDerivatives(output);</span>
        
<span class="nc" id="L184">        return output;</span>
    }
    
    /**
     * calculate corners using curvature scale space 
     * @param edge list of curves to create scale space curves of and calculate
     * corners from.
     * @return list of corners where indexes are the same as for the edges list.
     */
    public List&lt;CornerArray&gt; findCornersInScaleSpaceMaps(final PairIntArray 
        edge) {
        
        // ordered from min sigma to max sigma:
<span class="fc" id="L197">        final List&lt;CornerArray&gt; scaleSpaceCurvesList  =</span>
<span class="nc" id="L198">            createLowUpperThresholdScaleSpaceMaps2(edge);</span>
       
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (scaleSpaceCurvesList.isEmpty()) {</span>
<span class="nc" id="L201">            return scaleSpaceCurvesList;</span>
        }
                
<span class="nc" id="L204">        List&lt;CornerArray&gt; output = new ArrayList&lt;CornerArray&gt;();</span>
        
        /*
        find the candidate corners in the largest sigma scale space
           then filter the smaller sigma scale space curves to keep
           those same points.
        */
        
<span class="nc" id="L212">        CornerArray scaleSpaceCurve = scaleSpaceCurvesList.get(</span>
<span class="nc" id="L213">            scaleSpaceCurvesList.size() - 1);</span>
<span class="nc" id="L214">        CornerArray maxCorners = findCornersInScaleSpaceCurve(scaleSpaceCurve);</span>
        //maxCorners = pruneCloseCorners(maxCorners, scaleSpaceCurve.getN());
<span class="nc" id="L216">        output.add(maxCorners);</span>
        
<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (int i = 0; i &lt; scaleSpaceCurvesList.size() - 1; ++i) {</span>
            
<span class="nc" id="L220">            scaleSpaceCurve = scaleSpaceCurvesList.get(i);</span>
            
<span class="nc" id="L222">            CornerArray corners = new CornerArray(scaleSpaceCurve.getSIGMA(), </span>
<span class="nc" id="L223">                 maxCorners.getN());</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (scaleSpaceCurve.isFromAClosedCurve()) {</span>
<span class="nc" id="L225">                corners.setIsClosedCurve();</span>
            }
            
<span class="nc bnc" id="L228" title="All 2 branches missed.">            for (int j = 0; j &lt; maxCorners.getN(); ++j) {</span>
                
<span class="nc" id="L230">                int idx = maxCorners.getInt(j);</span>
                
<span class="nc" id="L232">                corners.add(scaleSpaceCurve.getX(idx), scaleSpaceCurve.getY(idx),</span>
<span class="nc" id="L233">                    scaleSpaceCurve.getCurvature(idx), </span>
<span class="nc" id="L234">                    scaleSpaceCurve.getXFirstDeriv(idx),</span>
<span class="nc" id="L235">                    scaleSpaceCurve.getXSecondDeriv(idx),</span>
<span class="nc" id="L236">                    scaleSpaceCurve.getYFirstDeriv(idx),</span>
<span class="nc" id="L237">                    scaleSpaceCurve.getYSecondDeriv(idx), idx);</span>
            }
            
<span class="nc" id="L240">            output.add(corners);</span>
        }
                
<span class="nc" id="L243">        return output;</span>
    }
    
    /**
     * 
     * @param theEdges
     * @param outEdgeScaleSpaceMaps
     * @return 
     * @Deprecated 
     */
    public List&lt;CornerArray&gt; findCornersInScaleSpaceMaps(
        final List&lt;PairIntArray&gt; theEdges,
        List&lt;Map&lt;SIGMA, ScaleSpaceCurve&gt;&gt; outEdgeScaleSpaceMaps) {
        
<span class="fc" id="L257">        outEdgeScaleSpaceMaps.clear();</span>
        
        //NOTE: this method is calculating the scale space maps twice
        // in order to avoid adding more code for a deprecated method
        // to bridge deprecated methods.
        //    if the method is retained and used, it should be refactored
        //    to preserve the CorneryArrays from the first creationg
        //    of scale maps and then create the Map&lt;SIGMA, ScaleSpaceCurve&gt;
        //    frm those.
        
<span class="nc" id="L267">        List&lt;CornerArray&gt; corners = findCornersInScaleSpaceMaps(theEdges);</span>
        
<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (PairIntArray edge : theEdges) {</span>
            
<span class="nc" id="L271">            Map&lt;SIGMA, ScaleSpaceCurve&gt; sMap = </span>
<span class="nc" id="L272">                createLowUpperThresholdScaleSpaceMaps(edge);</span>
            
<span class="nc" id="L274">            outEdgeScaleSpaceMaps.add(sMap);</span>
<span class="nc" id="L275">        }</span>
        
<span class="nc" id="L277">        return corners;</span>
    }

    /**
     * Construct scale space images (that is X(t, sigma), y(t, sigma), and
     * k(t, sigma) where t is the intervals of spacing along the curve
     * and is valued from 0 to 1 and k is the curvature).
     *
     * The range of the scale space maps is from sigma = 0.5 up to a maximum
     * value determined in getMaxSIGMAForECSS.
     *
     * The results are returned as a map keyed by sigma.
     */
    private Map&lt;SIGMA, ScaleSpaceCurve&gt; createLowUpperThresholdScaleSpaceMaps(
        final PairIntArray edge) {

<span class="nc" id="L293">        ScaleSpaceCurvature scaleSpaceHelper = new ScaleSpaceCurvature();</span>

<span class="nc" id="L295">        Map&lt;SIGMA, ScaleSpaceCurve&gt; map = new HashMap&lt;SIGMA, ScaleSpaceCurve&gt;();</span>

<span class="nc" id="L297">        SIGMA sigma = SIGMA.ZEROPOINTFIVE;</span>

        //TODO: take a look at the highest resolution curvature array
        //   and see if can derive the same upper limit by S/N estimate
        //   and assuming want to smooth to 2 o3 3 times the noise
<span class="nc" id="L302">        SIGMA maxSIGMA = getMaxSIGMAForECSS(edge.getN());</span>

        // this increases by a factor of sqrt(2)
<span class="nc" id="L305">        float resultingSigma = SIGMA.getValue(sigma);</span>

<span class="nc" id="L307">        ScaleSpaceCurve lastCurve = null;</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">        while (sigma.compareTo(maxSIGMA) &lt; 1) {</span>

<span class="nc" id="L311">            ScaleSpaceCurve curve = scaleSpaceHelper.computeCurvature(edge, </span>
                sigma, resultingSigma);

<span class="nc" id="L314">            map.put(sigma, curve);</span>

<span class="nc" id="L316">            sigma = SIGMA.increaseToFactorBySQRT2(resultingSigma);</span>

<span class="nc" id="L318">            resultingSigma *= (float)Math.sqrt(2);</span>

<span class="nc" id="L320">            lastCurve = curve;</span>

<span class="nc" id="L322">        }</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (!map.containsKey(maxSIGMA)) {</span>

<span class="nc" id="L326">            ScaleSpaceCurve curve = scaleSpaceHelper.computeCurvature(edge,</span>
<span class="nc" id="L327">                maxSIGMA, SIGMA.getValue(maxSIGMA));</span>

<span class="nc" id="L329">            map.put(maxSIGMA, curve);</span>
        }

<span class="nc" id="L332">        return map;</span>
    }
    
    /**
     * Construct scale space images (that is X(t, sigma), y(t, sigma), and
     * k(t, sigma) where t is the intervals of spacing along the curve
     * and is valued from 0 to 1 and k is the curvature).
     *
     * The range of the scale space maps is from sigma = 0.5 up to a maximum
     * value determined in getMaxSIGMAForECSS.
     *
     * The results are returned as a list ordered from small to large sigma.
     */
    private List&lt;CornerArray&gt; createLowUpperThresholdScaleSpaceMaps2(
        final PairIntArray edge) {

<span class="fc" id="L348">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        boolean isClosedCurve = curveHelper.isAdjacent(edge, 0, </span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            edge.getN() - 1) &amp;&amp; (edge.getN() &gt; 2);</span>
        
<span class="fc" id="L352">        ScaleSpaceCurvature scaleSpaceHelper = new ScaleSpaceCurvature();</span>

<span class="fc" id="L354">        List&lt;CornerArray&gt; output = new ArrayList&lt;CornerArray&gt;();</span>
        
<span class="fc" id="L356">        SIGMA sigma = SIGMA.ZEROPOINTFIVE;</span>

<span class="fc" id="L358">        SIGMA maxSIGMA = getMaxSIGMAForECSS(edge.getN());</span>

        // this increases by a factor of sqrt(2)
<span class="fc" id="L361">        float resultingSigma = SIGMA.getValue(sigma);</span>

<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        while (sigma.compareTo(maxSIGMA) &lt; 1) {</span>

<span class="fc" id="L365">            CornerArray curve = scaleSpaceHelper.computeCurvature2(edge, sigma);</span>
            
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (isClosedCurve) {</span>
<span class="fc" id="L368">                curve.setIsClosedCurve();</span>
            }
            
<span class="fc" id="L371">            output.add(curve);</span>

<span class="fc" id="L373">            sigma = SIGMA.increaseToFactorBySQRT2(resultingSigma);</span>

<span class="fc" id="L375">            resultingSigma *= (float)Math.sqrt(2);</span>
<span class="fc" id="L376">        }</span>

<span class="nc" id="L378">        return output;</span>
    }
    
    /**
     * find the corners in the given scale space map.
     * The corners are found using the curvature minima and maxima points in
     * the curve.  A lower threshold is determined and used during the maxima
     * finding and minima comparison.  Each corner candidate is larger than one
     * of the adjacent minima by a factor such as 2 or 3.
     *
     * The returned variable is the set of (x,y) points for the candidate
     * corners found.
     *
     * @param scaleSpaceCurve scale space curve for an edge
     * @return
     */
    protected CornerArray findCornersInScaleSpaceCurve(final CornerArray 
        scaleSpaceCurve) {
        
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (scaleSpaceCurve.getN() == 0) {</span>
<span class="nc" id="L398">            return new CornerArray(scaleSpaceCurve.getSIGMA(), 0);</span>
        }

<span class="nc" id="L401">        float[] k = Arrays.copyOf(scaleSpaceCurve.getCurvature(), </span>
<span class="nc" id="L402">            scaleSpaceCurve.getN());</span>

<span class="nc" id="L404">        float[] outputLowThreshold = new float[1];</span>

<span class="nc" id="L406">        int[] minimaAndMaximaIdxs = findMinimaAndMaximaInCurvature(</span>
            k, outputLowThreshold);

<span class="nc" id="L409">        List&lt;Integer&gt; maxCandidateCornerIndexes = findCandidateCornerIndexes(</span>
            k, minimaAndMaximaIdxs, outputLowThreshold[0],
            this.factorIncreaseForCurvatureMinimum);

<span class="nc" id="L413">        CornerArray xy = new CornerArray(scaleSpaceCurve.getSIGMA(), </span>
<span class="nc" id="L414">            maxCandidateCornerIndexes.size());</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (scaleSpaceCurve.isFromAClosedCurve()) {</span>
<span class="nc" id="L416">            xy.setIsClosedCurve();</span>
        }

<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (maxCandidateCornerIndexes.isEmpty()) {</span>
<span class="nc" id="L420">            return xy;</span>
        }

<span class="nc" id="L423">        int minDistFromEnds = 2;//5;</span>
<span class="nc" id="L424">        int nPoints = scaleSpaceCurve.getN();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        for (int ii = 0; ii &lt; maxCandidateCornerIndexes.size(); ii++) {</span>

<span class="nc" id="L427">            int idx = maxCandidateCornerIndexes.get(ii);</span>

<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (!scaleSpaceCurve.isFromAClosedCurve()) {</span>
<span class="nc bnc" id="L430" title="All 4 branches missed.">                if ((idx &lt; minDistFromEnds)</span>
                    || (idx &gt; (nPoints - minDistFromEnds - 1))) {
<span class="nc" id="L432">                    continue;</span>
                }
            }
            
<span class="nc" id="L436">            xy.add(scaleSpaceCurve.getX(idx), scaleSpaceCurve.getY(idx),</span>
<span class="nc" id="L437">                scaleSpaceCurve.getCurvature(idx), </span>
<span class="nc" id="L438">                scaleSpaceCurve.getXFirstDeriv(idx),</span>
<span class="nc" id="L439">                scaleSpaceCurve.getXSecondDeriv(idx),</span>
<span class="nc" id="L440">                scaleSpaceCurve.getYFirstDeriv(idx),</span>
<span class="nc" id="L441">                scaleSpaceCurve.getYSecondDeriv(idx), idx);</span>
        }

<span class="nc" id="L444">        return xy;</span>
    }

    /**
     * find the minima and maxima of the curvature k and return the low threshold
     * used in the in-out variable outputLowThreshold and a list of the
     * indexes for the minima as negative values and the maxima as positive
     * values.
     * @param k
     * @param outputLowThreshold array of size 1 to receive the low threshold used.
     * @return list of indexes of minima and maxima (minima have negative values).
     */
    public static int[] findMinimaAndMaximaInCurvature(float[] k,
        float[] outputLowThreshold) {

<span class="nc bnc" id="L459" title="All 4 branches missed.">        if ((k == null) || (k.length &lt; 5)) {</span>
<span class="nc" id="L460">            return new int[0];</span>
        }

<span class="nc bnc" id="L463" title="All 2 branches missed.">        for (int ii = 1; ii &lt; k.length; ii++) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (k[ii] &lt; 0.0f) {</span>
<span class="nc" id="L465">                k[ii] *= -1.0f;</span>
            }
        }

<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (k.length &lt; 3) {</span>
<span class="nc" id="L470">            return new int[0];</span>
        }
 
        // get quartiles of non-zero values
<span class="nc" id="L474">        int nz = 0;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        for (float ki : k) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (ki &gt; 0) {</span>
<span class="nc" id="L477">                nz++;</span>
            }
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (nz &lt; 4) {</span>
<span class="nc" id="L481">            return new int[0];</span>
        }
<span class="nc" id="L483">        float[] kNZ = new float[nz];</span>
<span class="nc" id="L484">        nz = 0;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        for (float ki : k) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (ki &gt; 0) {</span>
<span class="nc" id="L487">                kNZ[nz] = ki;</span>
<span class="nc" id="L488">                nz++;</span>
            }
        }
<span class="nc" id="L491">        float[] kQuartiles = ImageStatisticsHelper.getQuartiles(kNZ);</span>

        // determine lowThresh
<span class="nc" id="L494">        HistogramHolder h = Histogram.calculateSturgesHistogram(</span>
<span class="nc" id="L495">            0, 2 * kQuartiles[2], k, Errors.populateYErrorsBySqrt(k));</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (h.getXHist().length &lt; 2) {</span>
<span class="nc" id="L498">            return new int[0];</span>
        }

        /*
        try {
            h.plotHistogram(&quot;curvature&quot;, 283746);
        } catch (Exception e) {}
        */

<span class="nc" id="L507">        int[] firstPeakAndMinIdx = findFirstPeakAndMinimum(h);</span>

<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (firstPeakAndMinIdx[1] &gt; 3) {</span>
<span class="nc" id="L510">            firstPeakAndMinIdx[1] = firstPeakAndMinIdx[0] + 1;</span>
        }
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (firstPeakAndMinIdx[1] &gt;= (h.getYHist().length &gt;&gt; 1)) {</span>
<span class="nc" id="L513">            firstPeakAndMinIdx[1] = 1;</span>
        }

        // sum intensity &lt;= firstMinIdx and then after to compare
<span class="nc" id="L517">        long sum0 = 0;</span>
<span class="nc" id="L518">        long sum1 = 0;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        for (int i = 0; i &lt; h.getXHist().length; i++) {</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (i &lt;= firstPeakAndMinIdx[1]) {</span>
<span class="nc" id="L521">                sum0 += h.getYHist()[i];</span>
            } else {
<span class="nc" id="L523">                sum1 += h.getYHist()[i];</span>
            }
        }

<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (sum1 == 0) {</span>
<span class="nc" id="L528">            return new int[0];</span>
        }

<span class="nc" id="L531">        float divSum = (float)sum0/(float)sum1;</span>
<span class="nc" id="L532">        outputLowThreshold[0] = 0;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (divSum &gt; 10) {</span>
<span class="nc" id="L534">            outputLowThreshold[0] = h.getXHist()[firstPeakAndMinIdx[0]];</span>
<span class="nc bnc" id="L535" title="All 4 branches missed.">        } else if ((firstPeakAndMinIdx[1] &gt; 0) &amp;&amp; (sum1 &gt; 0)) {</span>
<span class="nc" id="L536">            outputLowThreshold[0] = (h.getXHist()[firstPeakAndMinIdx[1]]</span>
<span class="nc" id="L537">                + h.getXHist()[firstPeakAndMinIdx[1] - 1])/2;</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">        } else if ((firstPeakAndMinIdx[1] &gt; 0) &amp;&amp; (sum1 == 0)) {</span>
<span class="nc" id="L539">            firstPeakAndMinIdx[1]--;</span>
        }

        /*log.fine(&quot;lowThresh=&quot; + outputLowThreshold[0]
            + &quot; sum0=&quot; + sum0 + &quot; sum1=&quot; + sum1 + &quot; divsum=&quot; + divSum
            + &quot; firstPeakAndMinIdx[0]=&quot; + firstPeakAndMinIdx[0]
            + &quot; firstPeakAndMinIdx[1]=&quot; + firstPeakAndMinIdx[1]);*/

        /*
        storing the minima and maxima in the same array list.
        the minima have -1*index within k
        and the maxima keep their positive values of the index within k.
        */
<span class="nc" id="L552">        MinMaxPeakFinder minMaxFinder = new MinMaxPeakFinder();</span>
        
<span class="nc" id="L554">        int[] minMaxIdxs = minMaxFinder.findMinimaMaxima(k, outputLowThreshold[0]);</span>

<span class="nc" id="L556">        return minMaxIdxs;</span>
    }

    /**
     * given histogram h, find the first peak and the subsequent first minima
     * after it.
     *
     * @param h
     * @return
     */
    protected static int[] findFirstPeakAndMinimum(HistogramHolder h) {

<span class="nc" id="L568">        float[] xh = h.getXHist();</span>
<span class="nc" id="L569">        float[] yh = h.getYHistFloat();</span>

<span class="nc" id="L571">        int firstMinIdx = -1;</span>
<span class="nc" id="L572">        int yFirstPeakIdx = -1;</span>
<span class="nc" id="L573">        float lastY = yh[0];</span>
<span class="nc" id="L574">        boolean incr = true;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">        for (int i = 1; i &lt; xh.length; i++) {</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            if (yFirstPeakIdx &gt; -1) {</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">                if ((yh[i] &lt; lastY) &amp;&amp; incr) {</span>
<span class="nc" id="L578">                    incr = false;</span>
<span class="nc bnc" id="L579" title="All 4 branches missed.">                } else if ((yh[i] &gt; lastY) &amp;&amp; !incr) {</span>
<span class="nc" id="L580">                    firstMinIdx = i - 1;</span>
<span class="nc" id="L581">                    break;</span>
                }
            } else {
<span class="nc bnc" id="L584" title="All 4 branches missed.">                if ((yh[i] &lt; lastY) &amp;&amp; incr) {</span>
<span class="nc" id="L585">                    incr = false;</span>
<span class="nc" id="L586">                    yFirstPeakIdx = i - 1;</span>
                }
            }
<span class="nc" id="L589">            lastY = yh[i];</span>
        }
<span class="nc" id="L591">        firstMinIdx++;</span>

<span class="nc" id="L593">        return new int[]{yFirstPeakIdx, firstMinIdx};</span>
    }

    public static CornerRegion createCornerRegion(int edgeNumber, int cornerIdx,
        ScaleSpaceCurve scaleSpace, int imageWidth, int imageHeight) {

<span class="nc" id="L599">        final float[] k = scaleSpace.getK();</span>

        //for 2 neighboring points on each side, min k is 0.2
<span class="nc" id="L602">        float kCenterAbs = Math.abs(k[cornerIdx]);</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (kCenterAbs &lt; 0.14f) {//0.18</span>
<span class="nc" id="L604">            return null;</span>
        }

<span class="nc" id="L607">        int n = scaleSpace.getSize();</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (n &lt; 3) {</span>
<span class="nc" id="L610">            return null;</span>
        }

<span class="nc" id="L613">        boolean isClosedCurve = scaleSpace.curveIsClosed();</span>

<span class="nc" id="L615">        int nCR = 0;</span>
<span class="nc" id="L616">        int kMaxIdx = -1;</span>

<span class="nc" id="L618">        int count = 0;</span>
<span class="nc" id="L619">        int nH = 2;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (scaleSpace.getSize() &lt; 5) {</span>
<span class="nc" id="L621">            nH = 1;</span>
        }
<span class="nc" id="L623">        int[] pIdxs = new int[(2*nH) + 1];</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        for (int pIdx = (cornerIdx - nH); pIdx &lt;= (cornerIdx + nH); ++pIdx) {</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">            if ((pIdx &lt; 0) &amp;&amp; isClosedCurve) {</span>
<span class="nc" id="L626">                pIdxs[count] = n + pIdx;</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">            } else if ((pIdx &gt; (n - 1)) &amp;&amp; isClosedCurve) {</span>
<span class="nc" id="L628">                pIdxs[count] = pIdx - n;</span>
            } else {
<span class="nc" id="L630">                pIdxs[count] = pIdx;</span>
            }
<span class="nc" id="L632">            count++;</span>
        }

<span class="nc bnc" id="L635" title="All 2 branches missed.">        for (int pIdx : pIdxs) {</span>
<span class="nc bnc" id="L636" title="All 4 branches missed.">            if (pIdx &lt; 0 || (pIdx &gt; (n - 1))) {</span>
                // it's out of bounds only if it is not a closed curve
<span class="nc" id="L638">                continue;</span>
            }
<span class="nc bnc" id="L640" title="All 2 branches missed.">            if (pIdx == cornerIdx) {</span>
<span class="nc" id="L641">                kMaxIdx = nCR;</span>
            }
<span class="nc" id="L643">            int x = Math.round(scaleSpace.getX(pIdx));</span>
<span class="nc" id="L644">            int y = Math.round(scaleSpace.getY(pIdx));</span>

            // discard if out of bounds
<span class="nc bnc" id="L647" title="All 8 branches missed.">            if ((x &lt; 0) || (y &lt; 0) || (x &gt; (imageWidth - 1)) </span>
                || (y &gt; (imageHeight - 1))) {
<span class="nc" id="L649">                return null;</span>
            }
<span class="nc" id="L651">            nCR++;</span>
        }
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (nCR &lt; 3) {</span>
<span class="nc" id="L654">            return null;</span>
        }

<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (!isClosedCurve) {</span>
<span class="nc bnc" id="L658" title="All 4 branches missed.">            if (kMaxIdx == 0 || kMaxIdx == (nCR - 1)) {</span>
<span class="nc" id="L659">                return null;</span>
            }
        }

<span class="nc" id="L663">        CornerRegion cr = new CornerRegion(edgeNumber, nCR, kMaxIdx);</span>
<span class="nc" id="L664">        nCR = 0;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">        for (int pIdx : pIdxs) {</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">            if (pIdx &lt; 0 || (pIdx &gt; (n - 1))) {</span>
                // it's out of bounds only if it is not a closed curve
<span class="nc" id="L668">                continue;</span>
            }

<span class="nc" id="L671">            int x = Math.round(scaleSpace.getX(pIdx));</span>
<span class="nc" id="L672">            int y = Math.round(scaleSpace.getY(pIdx));</span>

<span class="nc" id="L674">            cr.set(nCR, k[pIdx], x, y);</span>

<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (kMaxIdx == nCR) {</span>
<span class="nc" id="L677">                cr.setIndexWithinCurve(pIdx);</span>
            }

<span class="nc" id="L680">            nCR++;</span>
        }
        
<span class="nc" id="L683">        return cr;</span>
    }

    /**
     * maxSigma is defined by the ECSS algorithm in:
     * 2006, &quot;Performance evaluation of corner detectors using consistency and
     * accuracy measures&quot; by Farzin Mokhtarian and Farahnaz Mohanna in
     * Computer Vision and Image Understanding, vol 102, pp 81-94.
     * @param nPoints
     * @return
     */
    protected SIGMA getMaxSIGMAForECSS(int nPoints) {

        //ECSS:
        //    &lt; 200, sigma = 2
        //    &lt;= 600, sigma=3
        //    else    sigma=4
<span class="fc bfc" id="L700" title="All 2 branches covered.">        if (nPoints &lt; 200) {</span>
<span class="fc" id="L701">            return SIGMA.TWO;</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">        } else if (nPoints &lt; 601) {</span>
<span class="nc" id="L703">            return SIGMA.THREE;</span>
        } else {
<span class="fc" id="L705">            return SIGMA.FOUR;</span>
        }
    }

    /**
     * given the curvature array and a list of the indexes of the
     * minima and maxima of the curvature array, find the candidate corner
     * indexes with respect to the k array.
     *
     * @param k
     * @param minMaxIdxs
     * @param lowThreshold
     * @param curvatureFactor2 factor which is multiplied by 2.0 to result
     * in the factor above minimum for a value to be significant.
     * @return
     */
    public static List&lt;Integer&gt; findCandidateCornerIndexes(float[] k,
        int[] minMaxIdxs, float lowThreshold, float curvatureFactor2) {

        // find peaks where k[ii] is &gt; factorAboveMin* adjacent local minima

<span class="nc" id="L726">        float factorAboveMin = curvatureFactor2 * 2.0f;//3.5f;// 10 misses some corners</span>

        //log.fine(&quot;using factorAboveMin=&quot; + factorAboveMin);

        //to limit k to curvature that shows a rise in 1 pixel over a run of 3,
        // use 0.2 for a lower limit.
        // TODO: it's not clear that kLowerLimit is a good idea.  the relative change
        // filter alone is good for all size scale corners, and adding this
        // limit biases the results.  may want to only use this bias if
        // the some amount of curvature points are &gt;= 0.2
<span class="nc" id="L736">        float kLowerLimit = 0.005f;</span>

<span class="nc" id="L738">        List&lt;Integer&gt; cornerCandidates = new ArrayList&lt;Integer&gt;();</span>

        // choose candidates from minMaxIndexes that are
        //     &gt;= factorAboveMin one adjacent min
<span class="nc bnc" id="L742" title="All 2 branches missed.">        for (int ii = 0; ii &lt; minMaxIdxs.length; ii++) {</span>

<span class="nc" id="L744">            int idx = minMaxIdxs[ii];</span>

<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (idx &gt; -1) {</span>
                // this is maximum

<span class="nc" id="L749">                boolean found = false;</span>
                
                // compare to preceding minimum
<span class="nc bnc" id="L752" title="All 2 branches missed.">                for (int iii = (ii - 1); iii &gt; -1; iii--) {</span>
<span class="nc" id="L753">                    int idx2 = minMaxIdxs[iii];</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                    if (idx2 &lt; 0) {</span>
<span class="nc" id="L755">                        float compare = k[-1*idx2];</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">                        if (compare &lt; lowThreshold) {</span>
                            // avoids divide by very small number sometimes
<span class="nc" id="L758">                            compare = lowThreshold;</span>
                        }
<span class="nc bnc" id="L760" title="All 4 branches missed.">                        if (k[idx] &gt;= kLowerLimit &amp;&amp; k[idx] &gt;= factorAboveMin * compare) {</span>
<span class="nc" id="L761">                            cornerCandidates.add(Integer.valueOf(idx));</span>
<span class="nc" id="L762">                            found = true;</span>
                        }
                        break;
                    }
                }
                
<span class="nc bnc" id="L768" title="All 4 branches missed.">                if (found &amp;&amp; (ii &gt; 0)) {</span>
<span class="nc" id="L769">                    continue;</span>
                }

                //compare to proceeding minimum
<span class="nc bnc" id="L773" title="All 2 branches missed.">                for (int iii = (ii + 1); iii &lt; minMaxIdxs.length; iii++) {</span>
<span class="nc" id="L774">                    int idx2 = minMaxIdxs[iii];</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                    if (idx2 &lt; 0) {</span>
<span class="nc" id="L776">                        float compare = k[-1*idx2];</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                        if (compare &lt; lowThreshold) {</span>
                            // avoids divide by very small number sometimes
<span class="nc" id="L779">                            compare = lowThreshold;</span>
                        }
<span class="nc bnc" id="L781" title="All 4 branches missed.">                        if (k[idx] &gt;= kLowerLimit &amp;&amp; k[idx] &gt;= factorAboveMin * compare) {</span>
<span class="nc" id="L782">                            cornerCandidates.add(Integer.valueOf(idx));</span>
                        }
                        break;
                    }
                }
            }
        }

<span class="nc" id="L790">        return cornerCandidates;</span>
    }

    private int distSq(int x, int y, PairInt p) {
        
<span class="nc" id="L795">        int diffX = x - p.getX();</span>
<span class="nc" id="L796">        int diffY = y - p.getY();</span>
        
<span class="nc" id="L798">        return (diffX * diffX) + (diffY * diffY);</span>
    }

    private CornerArray pruneCloseCorners(CornerArray corners, int curveLength) {
        
<span class="nc" id="L803">        int n = corners.getN();</span>
        
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (n &lt; 2) {</span>
<span class="nc" id="L806">            return corners;</span>
        }
        
<span class="nc" id="L809">        boolean isClosedCurve = corners.isFromAClosedCurve();</span>
        
<span class="nc" id="L811">        CornerArray output = new CornerArray(corners.getSIGMA());</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (isClosedCurve) {</span>
<span class="nc" id="L813">            output.setIsClosedCurve();</span>
        }
        
<span class="nc" id="L816">        int startIdx = 0;</span>
<span class="nc" id="L817">        int stopIdx = n;</span>
<span class="nc bnc" id="L818" title="All 4 branches missed.">        if (isClosedCurve &amp; (corners.getInt(0) == 0)) {</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (corners.getInt(n - 1) == (curveLength - 1)) {</span>
<span class="nc" id="L820">                float k0 = corners.getCurvature(0);</span>
<span class="nc" id="L821">                float kn1 = corners.getCurvature(n - 1);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                if (k0 &gt;= kn1) {</span>
<span class="nc" id="L823">                    stopIdx--;</span>
                } else {
<span class="nc" id="L825">                    startIdx++;</span>
                }
            }
        }
        
<span class="nc" id="L830">        double sqrt2 = Math.sqrt(2.);</span>
        
<span class="nc bnc" id="L832" title="All 2 branches missed.">        for (int i = startIdx; i &lt; stopIdx; ++i) {</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            if (i == (stopIdx - 1)) {</span>
<span class="nc" id="L834">                output.add(corners.getX(i), corners.getY(i),</span>
<span class="nc" id="L835">                    corners.getCurvature(i),</span>
<span class="nc" id="L836">                    corners.getXFirstDeriv(i),</span>
<span class="nc" id="L837">                    corners.getXSecondDeriv(i),</span>
<span class="nc" id="L838">                    corners.getYFirstDeriv(i),</span>
<span class="nc" id="L839">                    corners.getYSecondDeriv(i),</span>
<span class="nc" id="L840">                    corners.getInt(i));</span>
<span class="nc" id="L841">                continue;</span>
            }
<span class="nc" id="L843">            int idx1 = corners.getInt(i);</span>
<span class="nc" id="L844">            int idx2 = corners.getInt(i + 1);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">            if (idx2 &gt; (idx1 + 1)) {</span>
                // checking for adjacent diagonal that need to be averaged,
                // else can add the isolated corner
                /*int x1 = corners.getX(i);
                int y1 = corners.getY(i);
                int x2 = corners.getX(i + 1);
                int y2 = corners.getY(i + 1);
                int diffx = x2 - x1;
                int diffy = y2 - y1;
                double dist = Math.sqrt(diffx*diffx + diffy*diffy);
                if (dist &gt; sqrt2) { */               
<span class="nc" id="L856">                    output.add(corners.getX(i), corners.getY(i),</span>
<span class="nc" id="L857">                        corners.getCurvature(i),</span>
<span class="nc" id="L858">                        corners.getXFirstDeriv(i),</span>
<span class="nc" id="L859">                        corners.getXSecondDeriv(i),</span>
<span class="nc" id="L860">                        corners.getYFirstDeriv(i),</span>
<span class="nc" id="L861">                        corners.getYSecondDeriv(i),</span>
<span class="nc" id="L862">                        corners.getInt(i));</span>
            } else {
<span class="nc" id="L864">                float k1 = corners.getCurvature(i);</span>
<span class="nc" id="L865">                float k2 = corners.getCurvature(i + 1);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (k1 &gt;= k2) {</span>
                    // store this and skip next
<span class="nc" id="L868">                    output.add(corners.getX(i), corners.getY(i),</span>
<span class="nc" id="L869">                        corners.getCurvature(i),</span>
<span class="nc" id="L870">                        corners.getXFirstDeriv(i),</span>
<span class="nc" id="L871">                        corners.getXSecondDeriv(i),</span>
<span class="nc" id="L872">                        corners.getYFirstDeriv(i),</span>
<span class="nc" id="L873">                        corners.getYSecondDeriv(i),</span>
<span class="nc" id="L874">                        corners.getInt(i));</span>
<span class="nc" id="L875">                    ++i;</span>
                } else {
                    // store next and skip next
<span class="nc" id="L878">                    ++i;</span>
<span class="nc" id="L879">                    output.add(corners.getX(i), corners.getY(i),</span>
<span class="nc" id="L880">                        corners.getCurvature(i),</span>
<span class="nc" id="L881">                        corners.getXFirstDeriv(i),</span>
<span class="nc" id="L882">                        corners.getXSecondDeriv(i),</span>
<span class="nc" id="L883">                        corners.getYFirstDeriv(i),</span>
<span class="nc" id="L884">                        corners.getYSecondDeriv(i),</span>
<span class="nc" id="L885">                        corners.getInt(i));</span>
                }
            }
        }
<span class="nc" id="L889">        return output;</span>
    }

    private List&lt;CornerArray&gt; filterCornersForMinResolvable(List&lt;CornerArray&gt; cList) {
        
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (cList.isEmpty()) {</span>
<span class="nc" id="L895">            return cList;</span>
        }
        
        /*
        filtering by the minimum detectable angle and hence curvature for it.
        
         solid angle where r = radius of curvature.  k=1/r.
                   .
                  /|\
                 / | \
                / r-h \r
               /   |   \
              .----|----.
                   -     bottom portion is a triangle           w
                                                        .----.-----.
                                                          .  |h .
                                                             .
         the curvature is too small to determine slopes from neighboring
         points when h is less than 1 pixel and w is 3 or more.
       
         limit to k for h=1.0 and w=3:
       
              r^2 = (r-h)^2 + w^2
       
              r^2 = r^2 - 2*r*h + h^2 + w^2
              2*r*h = h^2 + w^2
                r = (h^2 + w^2)/(2*h)
                r = 5  which is k = 0.2 for no bluring
        
        gaussian bluring results in FWHM of size 2.35 * sigma.
        
        so with a sigma=1
        
        h = 1.0 * 2.35 * 1 = 2.35
        w = 3.0 * 2.35 * 1 = 7.05
        r = 11.75, so min absolute curvature = 1/r = 0.085
        */
        
<span class="nc" id="L933">        List&lt;CornerArray&gt; output = new ArrayList&lt;CornerArray&gt;();</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">        for (CornerArray corners : cList) {</span>
         
<span class="nc bnc" id="L936" title="All 2 branches missed.">            if (corners.getN() == 0) {</span>
<span class="nc" id="L937">                output.add(corners);</span>
<span class="nc" id="L938">                continue;</span>
            }
            
<span class="nc" id="L941">            SIGMA sigma = corners.getSIGMA();</span>
<span class="nc" id="L942">            CornerArray corners2 = new CornerArray(sigma);</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (corners.isFromAClosedCurve()) {</span>
<span class="nc" id="L944">                corners2.setIsClosedCurve();</span>
            }
            
<span class="nc" id="L947">            double h = 2.35 * SIGMA.getValue(sigma);</span>
<span class="nc" id="L948">            double w = 3.*h;</span>
            
<span class="nc" id="L950">            double minCurvature = (2. * h)/(h * h + w * w);</span>
            
<span class="nc bnc" id="L952" title="All 2 branches missed.">            for (int i = 0; i &lt; corners.getN(); ++i) {</span>
<span class="nc" id="L953">                double k = Math.abs(corners.getCurvature(i));</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (k &gt;= minCurvature) {</span>
<span class="nc" id="L955">                    corners2.add(</span>
<span class="nc" id="L956">                        corners.getX(i), corners.getY(i),</span>
<span class="nc" id="L957">                        corners.getCurvature(i),</span>
<span class="nc" id="L958">                        corners.getXFirstDeriv(i),</span>
<span class="nc" id="L959">                        corners.getXSecondDeriv(i),</span>
<span class="nc" id="L960">                        corners.getYFirstDeriv(i),</span>
<span class="nc" id="L961">                        corners.getYSecondDeriv(i), corners.getInt(i));</span>
                }
            }
            
<span class="nc" id="L965">            output.add(corners2);</span>
<span class="nc" id="L966">        }</span>
        
<span class="nc" id="L968">        return output;</span>
    }

    private List&lt;CornerArray&gt; filterCornersUsing2ndDerivatives(List&lt;CornerArray&gt; cList) {
        
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (cList.isEmpty()) {</span>
<span class="nc" id="L974">            return cList;</span>
        }
        
        /*
        filtering using the property derived by Harris and Stephens 
        R = det(G) − k(tr(G))^2 here k = 0.04
        
        and G is the matrix | I_x*I_x  I_x*I_y |
                            | I_x*I_y  I_y*I_y |
        where I_x and I_y are the 2nd derivtives of the intensity.
        see Eqn (11) in &quot;Phase Congruency Detects Corners and Edges&quot;
        by Kovesi.
        
        Note that the limit to use with this value is sensitive to image
        contrast, so one may prefer to use a related, but different
        measure of localizability that takes the measurements along the
        major and minor axes of the feature orienation.
        See FeatureHelper.filterByLocalizability(...)
        
        */
        
<span class="nc" id="L995">        List&lt;CornerArray&gt; output = new ArrayList&lt;CornerArray&gt;();</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        for (CornerArray corners : cList) {</span>
         
<span class="nc bnc" id="L998" title="All 2 branches missed.">            if (corners.getN() == 0) {</span>
<span class="nc" id="L999">                output.add(corners);</span>
<span class="nc" id="L1000">                continue;</span>
            }
            
<span class="nc" id="L1003">            SIGMA sigma = corners.getSIGMA();</span>
<span class="nc" id="L1004">            CornerArray corners2 = new CornerArray(sigma);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (corners.isFromAClosedCurve()) {</span>
<span class="nc" id="L1006">                corners2.setIsClosedCurve();</span>
            }
            
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            for (int i = 0; i &lt; corners.getN(); ++i) {</span>
                
<span class="nc" id="L1011">                float x2d = corners.getXSecondDeriv(i);</span>
<span class="nc" id="L1012">                float y2d = corners.getYSecondDeriv(i);</span>
                
<span class="nc" id="L1014">                float dxdx = x2d*x2d;</span>
<span class="nc" id="L1015">                float dydy = y2d*y2d;</span>
<span class="nc" id="L1016">                float dxdy = x2d*x2d;</span>
                
<span class="nc" id="L1018">                float det = dxdx * dydy - dxdy * dxdy;</span>
                
<span class="nc" id="L1020">                float trace = dxdx + dydy;</span>
                
<span class="nc" id="L1022">                float r = Math.abs(det - 0.04f * (trace * trace));</span>
                
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                if (r &gt; 2) {</span>
<span class="nc" id="L1025">                    corners2.add(</span>
<span class="nc" id="L1026">                        corners.getX(i), corners.getY(i),</span>
<span class="nc" id="L1027">                        corners.getCurvature(i),</span>
<span class="nc" id="L1028">                        corners.getXFirstDeriv(i),</span>
<span class="nc" id="L1029">                        corners.getXSecondDeriv(i),</span>
<span class="nc" id="L1030">                        corners.getYFirstDeriv(i),</span>
<span class="nc" id="L1031">                        corners.getYSecondDeriv(i), corners.getInt(i));</span>
                }
            }
            
<span class="nc" id="L1035">            output.add(corners2);</span>
<span class="nc" id="L1036">        }</span>
        
<span class="nc" id="L1038">        return output;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Grover.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.libquantum</a> &gt; <span class="el_source">Grover.java</span></div><h1>Grover.java</h1><pre class="source lang-java linenums">package thirdparty.libquantum;

import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Random;

/* 
An implementation of the grover search algorithm, 
ported here to java from the libquantum file grover.c.
The method calls have been adapted for re-use by
other algorithms and methods to accept a list of
numbers have been created.

The file grover.c has copyright:
Implementation of Grover's search algorithm

  Copyright 2003 Bjoern Butscher, Hendrik Weimer

  This file is a port to java from a c file in libquantum.

  libquantum is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation; either version 3 of the License,
  or (at your option) any later version.

  libquantum is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with libquantum; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  MA 02110-1301, USA

*/

<span class="fc" id="L38">public class Grover {</span>

    /*
            from wikipedia:

                           ------------------------
                          /   diffuser              \
                  _____   _____  ____________   _____
    |0&gt; -[H⊗n]---|     |--|H⊗n|--|2|0^n&gt; -I_n|--|H⊗n|---- ...measure
                 | U_w |  -----  ------------   ----
    |1&gt; -[H]-----|     |---------------------------------
                 ------|

                 Repeat U_w + diffuser O(sqrt(N)) times
     */
    
    /**
     * 
     * runtime complexity is O(reg.size * reg.width),
       (because decoherence lambda is 0.0).
     * 
     * @param state (f(x) == 1 when x == state, else f(x) == 0)
     * @param reg
     */
    private void oracle(int query, QuantumReg reg, Gates gates) {
        int i;
        
        /*
         function f(x)
                == 1 when x satisifies search criteria, 
                   that is, x == w
                   |U_w|x&gt; = -|x&gt;
                == 0 else is 0, that is, x != w
                   |U_w|x&gt; = |x&gt;

        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt;        
        */
        
        /*
        -- for each query bit: 
              if query bit i is 0, flips that bit in all states
        -- for each node state,
              if bits 0 and 1 are set, 
                  it flips the bit reg-&gt;width + 1
        -- for each node state,
              if bit reg-&gt;width + i is set, 
                  it flips the bit reg-&gt;width
        -- for each node.state (in reversed order): 
               if bits i and reg-&gt;width + i are set, 
                   it flips the bit reg.width + 1 + i
        -- for each node state,
               if bits 0 and 1 are set, 
                  it flips the bit reg-&gt;width + 1
        -- for each query bit:
               if query bit i is 0, 
                   flip bit i in all node states
        */
        
        //runtime complexity is O(reg.size * reg.width),
        // (because decoherence lambda is 0.0).
<span class="fc bfc" id="L98" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L101">                gates.quantum_sigma_x(i, reg);</span>
            }
        }

        //for each node.state: 
        // if bits 0 and 1 are set, it flips the bit reg-&gt;width + 1
<span class="fc" id="L107">        gates.quantum_toffoli(0, 1, reg.width + 1, reg);</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (i = 1; i &lt; reg.width; i++) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg-&gt;width + 1 + i
<span class="fc" id="L113">            gates.quantum_toffoli(i, reg.width + i, reg.width + i + 1, reg);</span>
        }

        //for each node.state: 
        // if bit reg-&gt;width + i is set, 
        // it flips the bit reg-&gt;width
<span class="fc" id="L119">        gates.quantum_cnot(reg.width + i, reg.width, reg);</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (i = reg.width - 1; i &gt; 0; i--) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg.width + 1 + i
<span class="fc" id="L125">            gates.quantum_toffoli(i, reg.width + i, reg.width + i + 1, reg);</span>
        }

        //for each node.state: 
        // if bits 0 and 1 are set, 
        // it flips the bit reg-&gt;width + 1
<span class="fc" id="L131">        gates.quantum_toffoli(0, 1, reg.width + 1, reg);</span>

<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L136">                gates.quantum_sigma_x(i, reg);</span>
            }
        }

<span class="fc" id="L140">    }</span>

    /**
      runtime complexity is O(reg.size * reg.width),
      (because decoherence lambda is 0.0).
     * @param reg
     */
    private void inversion(QuantumReg reg, Gates gates) {
        int i;

        //|2|0^n&gt; -I_n|
        
        
        //Flip the target bit of each basis state, i
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
<span class="fc" id="L155">            gates.quantum_sigma_x(i, reg);</span>
        }
       
<span class="fc" id="L158">        gates.quantum_hadamard(reg.width - 1, reg);</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (reg.width == 3) {</span>
        
<span class="fc" id="L162">            gates.quantum_toffoli(0, 1, 2, reg);</span>
        
        } else {
            
            //If bits 0 and 1 are set, it flips the target bit.
<span class="nc" id="L167">            gates.quantum_toffoli(0, 1, reg.width + 1, reg);</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">            for (i = 1; i &lt; reg.width - 1; i++) {</span>
                //If bits i and reg.width+i are set, it flips the target bit.
<span class="nc" id="L171">                gates.quantum_toffoli(i, reg.width + i, reg.width + i + 1, reg);</span>
            }

            //for each reg.state, 
            //   Flip the target bit of a basis state if 
            //   the control bit is set
<span class="nc" id="L177">            gates.quantum_cnot(reg.width + i, reg.width - 1, reg);</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">            for (i = reg.width - 2; i &gt; 0; i--) {</span>
                //If bits i and reg.width+i are set, it flips the target bit.
<span class="nc" id="L181">                gates.quantum_toffoli(i, reg.width + i, reg.width + i + 1, reg);</span>
            }

            //If bits 0 and 1 are set, it flips the target bit.
<span class="nc" id="L185">            gates.quantum_toffoli(0, 1, reg.width + 1, reg);</span>
        }

<span class="fc" id="L188">        gates.quantum_hadamard(reg.width - 1, reg);</span>
        
        //Flip the target bit of each basis state, i
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
<span class="fc" id="L192">            gates.quantum_sigma_x(i, reg);</span>
        }
        
<span class="fc" id="L195">    }</span>

    /**
     * runtime complexity is O(reg.size * reg.width)  (because decoherence lambda is 0.0).
     * 
     * @param target 
     *     (f(x) == 1 when x == target, else f(x) == 0)
     * @param reg
     */
    private void grover(int target, QuantumReg reg, Gates gates, QuReg qureg) {

        int i;   

        //unitary operator operating on two qubits, target and each i
        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt; 
        // (gives the found solutions negative signs)
<span class="fc" id="L211">        oracle(target, reg, gates);</span>

        //DEBUG
        //System.out.format(&quot;AFTER oracle target=%d  reg.size=%d  hash.length=%d\n&quot;, 
        //    target, reg.size, 1 &lt;&lt; reg.hashw);
        //qureg.quantum_print_qureg(reg);


        //   H⊗n   |2|0^n&gt; -I_n|  H⊗n


<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
<span class="fc" id="L223">            gates.quantum_hadamard(i, reg);</span>
        }


        //DEBUG
        //System.out.format(&quot;AFTER hadamard target=%d hadamard reg.size=%d\n&quot;, 
        //    target, reg.size);
        //qureg.quantum_print_qureg(reg);


<span class="fc" id="L233">        inversion(reg, gates);</span>


        //DEBUG
        //System.out.format(&quot;AFTER target=%d inversion reg.size=%d\n&quot;, 
        //    target, reg.size);
        //qureg.quantum_print_qureg(reg);


<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
<span class="fc" id="L243">            gates.quantum_hadamard(i, reg);</span>
        }


        //DEBUG
        //System.out.format(&quot;AFTER target=%d 2nd hadamard  reg.size=%d\n&quot;, 
        //    target, reg.size);
        //qureg.quantum_print_qureg(reg);
<span class="fc" id="L251">    }</span>

    /** runtime complexity is O(reg.size * reg.width) * nLoop
       (the runtime complexity of the preparation of the register 
     * is ignored.  it is O(2^width)).
     * Note that nLoop is (Math.PI / 4) * Math.sqrt(2^width)
     * where width is (the bit length of number) + 1
     * 
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^(number bit length + 1)
    */
    public int run(int number) {

<span class="nc" id="L264">        int width = MiscMath.numberOfBits(number + 1);</span>

<span class="nc" id="L266">        return run(number, width);</span>
    }

    /**
     * runtime complexity is O(reg.size * reg.width) * nLoop.
     * Note that nLoop is (Math.PI / 4) * Math.sqrt(2^width).
     * (the runtime complexity of the preparation of the register 
     * is ignored.  it is O(2^width)).
     * 
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^width.
     * @param width largest bit length to use in enumeration.
     * NOTE that if it is less than (the bit length of number) + 1,
     * it will be increased to that.
     */
    public int run(int number, int width) {

        int i;

<span class="fc" id="L285">        final int N = number;</span>

<span class="fc" id="L287">        Random rng = Misc.getSecureRandom();</span>

<span class="fc" id="L289">        Gates gates = new Gates(rng);</span>

<span class="fc" id="L291">        int tmp = MiscMath.numberOfBits(N + 1);</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (width &lt; tmp) {</span>
<span class="nc" id="L293">            width = tmp;</span>
        }
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (width &lt; 2) {</span>
<span class="nc" id="L296">            width = 2;</span>
        }

<span class="fc" id="L299">        System.out.format(&quot;N = %d, width=%d\n&quot;, N, width);</span>


<span class="fc" id="L302">        QuReg qureg = new QuReg();</span>

<span class="fc" id="L304">        QuantumReg reg = qureg.quantum_new_qureg(0, width);</span>

        //DEBUG
        //System.out.format(&quot;AFTER construction  reg.size=%d hash.length=%d\n&quot;, 
        //    reg.size, 1 &lt;&lt; reg.hashw);
        //qureg.quantum_print_qureg(reg);

        //Flip the target bit of each basis state, reg.width
        //runtime complexity is O(reg.size) (because decoherence lambda is 0.0).
<span class="fc" id="L313">        gates.quantum_sigma_x(reg.width, reg);</span>

        //DEBUG
        //System.out.format(&quot;AFTER sigma_x  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

        //runtime complexity is O(reg.size * reg.width)
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for (i = 0; i &lt; reg.width; i++) {</span>
<span class="fc" id="L321">            gates.quantum_hadamard(i, reg);</span>
        }

        //this expands the register to next highest bitstring, for the
        // work space to hold the low bit integer states after inversion.
<span class="fc" id="L326">        gates.quantum_hadamard(reg.width, reg);</span>

        //DEBUG
        //System.out.format(&quot;AFTER 1st hadamard gates  reg.size=%d hash.length=%d\n&quot;, 
        //    reg.size, 1 &lt;&lt; reg.hashw);
        //qureg.quantum_print_qureg(reg);

        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
<span class="fc" id="L335">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; reg.width));</span>

<span class="fc" id="L337">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="fc bfc" id="L340" title="All 2 branches covered.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="fc" id="L342">            System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            
<span class="fc" id="L344">            grover(N, reg, gates, qureg);</span>
        }


        //DEBUG
        //System.out.format(&quot;AFTER grover  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);


<span class="fc" id="L353">        gates.quantum_hadamard(reg.width, reg);</span>


        //DEBUG
        //System.out.format(&quot;AFTER last hadamard  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);


<span class="fc" id="L361">        reg.width++;</span>

<span class="fc" id="L363">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="fc" id="L366">        measure.quantum_bmeasure(reg.width - 1, reg, rng);</span>


        //DEBUG
<span class="fc" id="L370">        System.out.format(&quot;AFTER bmeasure reg.size=%d\n&quot;, reg.size);</span>
<span class="fc" id="L371">        qureg.quantum_print_qureg(reg);</span>


<span class="fc bfc" id="L374" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (reg.node[i].state == N) {</span>
<span class="fc" id="L376">                System.out.format(</span>
<span class="fc" id="L377">                    &quot;\nFound %d with a probability of %f\n\n&quot;, N,</span>
<span class="fc" id="L378">                    reg.node[i].amplitude.squareSum());</span>
            }
        }

<span class="fc" id="L382">        return 0;</span>
    }
    
    // ---- adding ability to find number within a list of numbers for use 
    //      within the quantum min algorithm ----
    
    /**
     * Initialize the register with a list of numbers.
     * Note, that the register, as the possible states of superposition of
     * qubits, will have all possible permutation of the qubits up to the
     * power of 2 or next higher power of 2 in the list.
     * a straight sequence of numbers from 0 up to a power of 2 is valid input for
     * the current logic (can be unordered).
     * 
     *
     * 
     * @param qureg
     * @param list
     * @param width
     * @return 
     */
    public QuantumReg initializeRegister(QuReg qureg, int[] list,
        int width) {
        
<span class="fc" id="L406">        final int initSize = 2 * list.length;</span>

<span class="fc" id="L408">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width);</span>

        /*
        handle list:
        
        need to initialize a register:
           size = 2.*list.length
        
        each node has state == value in list
        
        an extra set of the states is needed if width != 3 so it's performed for all.
        that extra set of states should have states starting
           at the next power of 2 .gte. (1 &lt;&lt; list.length).
        
        superposition is the implied result of the normalization
           of all states such that sum of ampl^2 = 1
        
        then the rest of the algorithm should proceed in same manner.
        */
        
        //  in the enumerated run method,
        //  the extra set of nodes has state that is identical
        //  to first set except that it begins at 1&lt;&lt;width
        //  so it is shifted by width
<span class="fc" id="L432">        int idx = list.length;</span>
<span class="fc" id="L433">        int offset = 1 &lt;&lt; width;</span>
        
        int i;
        
<span class="fc" id="L437">        double norm = 1./Math.sqrt(initSize);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="fc" id="L439">            reg.node[i].state = list[i] + offset;</span>
<span class="fc" id="L440">            reg.node[i].amplitude.setReal(-norm);</span>
        }
        
<span class="fc bfc" id="L443" title="All 2 branches covered.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="fc" id="L444">            reg.node[idx].state = list[i];</span>
<span class="fc" id="L445">            reg.node[idx].amplitude.setReal(norm);</span>
<span class="fc" id="L446">            idx++;</span>
        }
        
<span class="fc" id="L449">        return reg;</span>
    }
    
    /**
     * runtime complexity for the search 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N), 
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^width.
     * @param width largest bit length to use in enumeration.
     * NOTE that if it is less than (the bit length of number) + 1,
     * it will be increased to that.
     * @param list a list of unordered numbers to search for number within
     * @return 
     */
    public int run(int number, int width, int[] list) {

<span class="fc" id="L472">        int N = number;</span>
        int i;
        
<span class="fc" id="L475">        int tmp = MiscMath.numberOfBits(N + 1);</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        if (width &lt; tmp) {</span>
<span class="nc" id="L477">            width = tmp;</span>
        }
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        if (width &lt; 2) {</span>
<span class="nc" id="L480">            width = 2;</span>
        }

<span class="fc" id="L483">        System.out.format(&quot;N = %d, list.length=%d, width=%d\n&quot;, N, </span>
<span class="fc" id="L484">            list.length, width);</span>
        
<span class="fc" id="L486">        QuReg qureg = new QuReg();</span>

<span class="fc" id="L488">        QuantumReg reg = initializeRegister(qureg, list, width);</span>
        
<span class="fc" id="L490">        Random rng = Misc.getSecureRandom();</span>
        
<span class="fc" id="L492">        int ret = processInitialized(number, reg, rng);</span>
        
        
<span class="fc" id="L495">        reg.width++;</span>

<span class="fc" id="L497">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="fc" id="L500">        measure.quantum_bmeasure(reg.width - 1, reg, rng);</span>


        //DEBUG
<span class="fc" id="L504">        System.out.format(&quot;AFTER bmeasure reg.size=%d\n&quot;, reg.size);</span>
<span class="fc" id="L505">        qureg.quantum_print_qureg(reg);</span>


<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (reg.node[i].state == N) {</span>
<span class="fc" id="L510">                System.out.format(</span>
<span class="fc" id="L511">                    &quot;\nFound %d with a probability of %f\n\n&quot;, N,</span>
<span class="fc" id="L512">                    reg.node[i].amplitude.squareSum());</span>
            }
        }

<span class="fc" id="L516">        return ret;</span>
    }
    
    /**
     * runtime complexity for the processing 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N),
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * NOTE that measurements of register reg are not taken.
     * @param number a number to search for within the initialized register reg
     * @param reg initialized register which holds nodes of state which are 
     * searched and have amplitudes which when squared and summed over register 
     * are equal to 1.
     * @param rng
     * @return
     */
    public int processInitialized(int number, QuantumReg reg, Random rng) {

<span class="fc" id="L539">        int width = reg.width;</span>
        
        int i;

<span class="fc" id="L543">        final int N = number;</span>

<span class="fc" id="L545">        QuReg qureg = new QuReg();</span>
        
        //DEBUG
        //System.out.format(&quot;AFTER construction  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
        //  NOTE that if the number of times number will appear in list
        //     is known ahead of time,
        //     the term in the sqrt can be divided by that multiplicity.
<span class="fc" id="L556">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; reg.width));</span>

<span class="fc" id="L558">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

<span class="fc" id="L560">        Gates gates = new Gates(rng);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="fc bfc" id="L563" title="All 2 branches covered.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="fc" id="L565">            System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            
<span class="fc" id="L567">            grover(N, reg, gates, qureg);</span>
        }


        //DEBUG
        //System.out.format(&quot;AFTER grover  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);


<span class="fc" id="L576">        gates.quantum_hadamard(reg.width, reg);</span>


        //DEBUG
        //System.out.format(&quot;AFTER last hadamard  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

<span class="fc" id="L583">        return 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
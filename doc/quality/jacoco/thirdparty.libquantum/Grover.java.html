<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Grover.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.libquantum</a> &gt; <span class="el_source">Grover.java</span></div><h1>Grover.java</h1><pre class="source lang-java linenums">package thirdparty.libquantum;

import algorithms.misc.ComplexModifiable;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Random;

/* 
An implementation of the grover search algorithm, 
ported here to java from the libquantum file grover.c.
The method calls have been adapted for re-use by
other algorithms and methods to accept a list of
numbers have been created and an alternate oracle
and diffuser have been implemented by this project.

The file grover.c has copyright:
Implementation of Grover's search algorithm

  Copyright 2003 Bjoern Butscher, Hendrik Weimer

  This file is a port to java from a c file in libquantum.

  libquantum is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation; either version 3 of the License,
  or (at your option) any later version.

  libquantum is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with libquantum; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  MA 02110-1301, USA

*/

<span class="fc" id="L40">public class Grover {</span>
    
<span class="fc" id="L42">    private boolean debug = false;</span>
    
<span class="fc" id="L44">    private int width0 = 0;</span>

    /*
            from wikipedia:

                           ------------------------
                          /   diffuser              \
                  _____   _____  ____________   _____
    |0&gt; -[H⊗n]---|     |--|H⊗n|--|2|0^n&gt; -I_n|--|H⊗n|---- ...measure
                 | U_w |  -----  ------------   ----
    |1&gt; -[H]-----|     |---------------------------------
                 ------|

                 Repeat U_w + diffuser O(sqrt(N)) times
     */
    
    /**
     * 
     * runtime complexity is O(reg.size * reg.width),
       (because decoherence lambda is 0.0).
     * 
     * @param state (f(x) == 1 when x == state, else f(x) == 0)
     * @param reg
     */
    private void oracle(int query, QuantumReg reg, Gates gates) {
        int i;
        
        //NOTE: none of the quantum api methods has to check for unique
        //   quantum numbers before making a change, that is they do not 
        //   necessarily check pauli exclusion principle, or check for Cooper pairs.
	//   TODO: walk through consistency for bosons and fermions where needed.
	//   Bose-Einstein statistics are used for photons (bosons) and
	//   Fermi-Dirac statistics and Pauli-Excl principle are used for fermions (particles).
        
        /*
         function f(x)
                == 1 when x satisifies search criteria, 
                   that is, x == w
                   |U_w|x&gt; = -|x&gt;
                == 0 else is 0, that is, x != w
                   |U_w|x&gt; = |x&gt;

        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt;        
        */
        
        /*
        -- for each query bit: 
              if query bit i is 0, flips that bit in all states
        -- for each node state,
              if bits 0 and 1 are set, 
                  it flips the bit reg-&gt;width + 1
        -- for each node state,
              if bit reg-&gt;width + i is set, 
                  it flips the bit reg-&gt;width
        -- for each node.state (in reversed order): 
               if bits i and reg-&gt;width + i are set, 
                   it flips the bit reg.width + 1 + i
        -- for each node state,
               if bits 0 and 1 are set, 
                  it flips the bit reg-&gt;width + 1
        -- for each query bit:
               if query bit i is 0, 
                   flip bit i in all node states
        */
             
        //DEBUG
<span class="fc" id="L110">        StringBuilder[] sbs = new StringBuilder[reg.size];</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L113">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L114">                sbs[ii] = sb;</span>
            }
<span class="nc bnc" id="L116" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L117">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L118">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L120">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L122">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //runtime complexity is O(reg.size * reg.width),
        // (because decoherence lambda is 0.0).
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L131">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
        
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L138">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L139">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L141">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L143">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }

        //for each node.state: 
        // if bits 0 and 1 are set, it flips the bit reg-&gt;width + 1
<span class="fc" id="L149">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>
        
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L153">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L154">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L156">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L158">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (i = 1; i &lt; width0; i++) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg-&gt;width + 1 + i
           
<span class="fc" id="L167">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L172">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L173">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L175">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L177">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bit reg-&gt;width + i is set, 
        // it flips the bit reg-&gt;width
<span class="fc" id="L184">        gates.quantum_cnot(width0 + i, width0, reg);</span>
        
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L188">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L189">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L191">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L193">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (i = width0 - 1; i &gt; 0; i--) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg.width + 1 + i
            
<span class="fc" id="L202">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L207">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L208">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L210">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L212">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bits 0 and 1 are set, 
        // it flips the bit reg-&gt;width + 1
<span class="fc" id="L219">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L223">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L224">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L226">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L228">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L235">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L241">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L242">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L244">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L246">                sb.append(str).append(&quot;  &quot;);</span>
            }
            
<span class="nc" id="L249">            System.out.println(&quot;END STATES&quot;);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L251">                System.out.println(sbs[ii]);</span>
            }
        }
<span class="fc" id="L254">    }   </span>
    
    /*
    private void oracle3(int query, QuantumReg reg, Gates gates) {
        int i;
        
        //NOTE: since none of the quantum api methods has to check for unique
        //   quantum numbers before making a change, that is they do not 
        //   necessarily check pauli exclusion principle, or check for Cooper pairs
        //   it should be just as valid to
        //   use test and set bit operations alone rather than
        //   purely test and toggle bit operations as nicely demonstrated
        //   in oracle(...)
        
        //function f(x)
        //       == 1 when x satisifies search criteria, 
        //         that is, x == w
        //         |U_w|x&gt; = -|x&gt;
        //      == 0 else is 0, that is, x != w
        //         |U_w|x&gt; = |x&gt;
        //
        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt;        
             
        //DEBUG
        StringBuilder[] sbs = new StringBuilder[reg.size];
        if (debug) {//DEBUG
            for (int ii = 0; ii &lt; reg.size; ii++) {
                StringBuilder sb = new StringBuilder();
                sbs[ii] = sb;
            }
            for (int ii = 0; ii &lt; reg.size; ii++) {
                StringBuilder sb = sbs[ii];
                String str = Long.toBinaryString(reg.node[ii].state);
                while (str.length() &lt; reg.width) {
                    str = &quot;0&quot; + str;
                }
                sb.append(str).append(&quot;  &quot;);
            }
        }
        
        // if 0 bit is same in query and state, set high bit
        for (i = 0; i &lt; reg.size; ++i) {
            int qs = query &amp; (1 &lt;&lt; 0);
            long vs = reg.node[i].state &amp; (1 &lt;&lt; 0);
            if (((qs == 0) &amp;&amp; (vs == 0)) || ((qs != 0) &amp;&amp; (vs != 0))
                ) {
                reg.node[i].state  |= (1L &lt;&lt; (reg.width - 1));
            }
        }
        
        // if high bit is set and query bit is same in query and state, 
        // keep high bit else unset.
        // NOTE: all of this conditional logic might not be available in
        //  a gate
        for (i = 0; i &lt; reg.size; ++i) {
            if ((reg.node[i].state  &amp; (1L &lt;&lt; (reg.width - 1))) != 0) {
                int qs = query &amp; (1 &lt;&lt; 0);
                long vs = reg.node[i].state &amp; (1 &lt;&lt; 0);
                if (!(((qs == 0) &amp;&amp; (vs == 0)) || ((qs != 0) &amp;&amp; (vs != 0))
                    )) {
                    reg.node[i].state  &amp;= ~(1L &lt;&lt; (reg.width - 1));
                }
            }
        }
        
        // rotate by pi if high bit is set
        gates.quantum_phase_kick(reg.width - 1, Math.PI, reg);
        
        // unset the highest bit.
        // not reversible.
        for (i = 0; i &lt; reg.size; i++) {
            reg.node[i].state  &amp;= ~(1L &lt;&lt; (reg.width - 1));
        }
        
        if (debug) {//DEBUG
            for (int ii = 0; ii &lt; reg.size; ii++) {
                StringBuilder sb = sbs[ii];
                String str = Long.toBinaryString(reg.node[ii].state);
                while (str.length() &lt; reg.width) {
                    str = &quot;0&quot; + str;
                }
                sb.append(str).append(&quot;  &quot;);
            }
            
            System.out.println(&quot;END STATES&quot;);
            for (int ii = 0; ii &lt; reg.size; ii++) {
                System.out.println(sbs[ii]);
            }
        }
    }
    */
    
    private void oracle2(int query, QuantumReg reg, Gates gates) {
        int i;
        
        //function f(x)
        //       == 1 when x satisifies search criteria, 
        //         that is, x == w
        //         |U_w|x&gt; = -|x&gt;
        //      == 0 else is 0, that is, x != w
        //         |U_w|x&gt; = |x&gt;
        //
        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt;        
             
        //DEBUG
<span class="fc" id="L359">        StringBuilder[] sbs = new StringBuilder[reg.size];</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L362">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L363">                sbs[ii] = sb;</span>
            }
<span class="nc bnc" id="L365" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L366">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L367">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L369">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L371">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //runtime complexity is O(reg.size * reg.width),
        // (because decoherence lambda is 0.0).
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L380">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
        
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L387">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L388">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L390">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L392">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }

        //for each node.state: 
        // if bits 0 and 1 are set, it flips the bit reg-&gt;width + 1
<span class="fc" id="L398">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>
        
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L402">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L403">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L405">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L407">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (i = 1; i &lt; width0; i++) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg-&gt;width + 1 + i
           
<span class="fc" id="L416">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L421">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L422">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L424">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L426">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bit reg-&gt;width + i is set, 
        // it flips the bit reg-&gt;width
<span class="fc" id="L433">        gates.quantum_cnot(width0 + i, width0, reg);</span>
        
             
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L438">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L439">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L441">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L443">                sb.append(&quot;*&quot;).append(str).append(&quot;  &quot;);</span>
            }
        }
        
        
        // anything that is all 1's at this point is the found number.
        // (all 1's except the high bit)
        
        // not reversible
        // set high bit if all bits are set
<span class="fc" id="L453">        gates.quantum_ccand(0, 0, reg.width-1, reg);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        for (i = 1; i &lt; reg.width-2; i++) {</span>
<span class="fc" id="L455">            gates.quantum_ccand(i, reg.width-1, reg.width-1, reg);</span>
        }
        
        
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L461">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L462">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L464">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L466">                sb.append(&quot;*&quot;).append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L470" title="All 2 branches covered.">        for (i = width0 - 1; i &gt; 0; i--) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg.width + 1 + i
            
<span class="fc" id="L475">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L480">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L481">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L483">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L485">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bits 0 and 1 are set, 
        // it flips the bit reg-&gt;width + 1
<span class="fc" id="L492">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>

<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L496">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L497">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L499">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L501">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L505" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L508">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
        
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L515">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L516">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L518">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L520">                sb.append(str).append(&quot;  &quot;);</span>
            }
            
        }
        
        //NOTE: since none of the quantum api methods has to check for unique
        //   quantum numbers before making a change, that is they do not 
        //   necessarily check pauli exclusion principle, or check for Cooper pairs
        //   it should be just as valid to
        //   use test and set pr clear bit operations rather than
        //   purely test and toggle bit operations as nicely demonstrated
        //   in oracle(...)
        
        // not reversible
        // unset the width0 bit
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc" id="L536">            reg.node[i].state  &amp;= ~(1L &lt;&lt; width0);</span>
        }
       
        // rotate by pi if high bit is set
<span class="fc" id="L540">        gates.quantum_phase_kick(reg.width - 1, Math.PI, reg);</span>
        
        // unset the highest bit.
        // not reversible.
<span class="fc bfc" id="L544" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc" id="L545">            reg.node[i].state  &amp;= ~(1L &lt;&lt; (reg.width - 1));</span>
        }
        
        
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L551">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L552">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L554">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L556">                sb.append(str).append(&quot;  &quot;);</span>
            }
            
<span class="nc" id="L559">            System.out.println(&quot;END STATES&quot;);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L561">                System.out.println(sbs[ii]);</span>
            }
        }
<span class="fc" id="L564">    }</span>
    
    /**
      runtime complexity is O(reg.size * reg.width),
      (because decoherence lambda is 0.0).
     * @param reg
     */
    private void inversion(QuantumReg reg, Gates gates) {
        int i;

        //|2|0^n&gt; -I_n|
        
        //Flip the target bit of each basis state, i
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L578">            gates.quantum_sigma_x(i, reg);</span>
        }
       
<span class="fc" id="L581">        gates.quantum_hadamard(width0 - 1, reg);</span>

<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (width0 == 3) {</span>
        
<span class="fc" id="L585">            gates.quantum_toffoli(0, 1, 2, reg);</span>
        
        } else {
            
            //If bits 0 and 1 are set, it flips the target bit.
<span class="nc" id="L590">            gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>

<span class="nc bnc" id="L592" title="All 2 branches missed.">            for (i = 1; i &lt; width0 - 1; i++) {</span>
                //If bits i and reg.width+i are set, it flips the target bit.
<span class="nc" id="L594">                gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
            }

            //for each reg.state, 
            //   Flip the target bit of a basis state if 
            //   the control bit is set
<span class="nc" id="L600">            gates.quantum_cnot(width0 + i, width0 - 1, reg);</span>

<span class="nc bnc" id="L602" title="All 2 branches missed.">            for (i = width0 - 2; i &gt; 0; i--) {</span>
                //If bits i and reg.width+i are set, it flips the target bit.
<span class="nc" id="L604">                gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
            }

            //If bits 0 and 1 are set, it flips the target bit.
<span class="nc" id="L608">            gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>
        }

<span class="fc" id="L611">        gates.quantum_hadamard(width0 - 1, reg);</span>
        
        //Flip the target bit of each basis state, i
<span class="fc bfc" id="L614" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L615">            gates.quantum_sigma_x(i, reg);</span>
        }
        
<span class="fc" id="L618">    }</span>

    /**
     * runtime complexity is O(reg.size * reg.width)  (because decoherence lambda is 0.0).
     * 
     * @param target 
     *     (f(x) == 1 when x == target, else f(x) == 0)
     * @param reg
     */
    private void grover(int target, QuantumReg reg, Gates gates, QuReg qureg) {
        
        int i;  
        
        //unitary operator operating on two qubits, target and each i
        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt; 
        // (gives the found solutions negative signs)
<span class="fc" id="L634">        oracle(target, reg, gates);</span>

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L637">            System.out.format(</span>
                &quot;AFTER oracle target=%d  reg.size=%d  hash.length=%d\n&quot;, 
<span class="nc" id="L639">                target, reg.size, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L640">            qureg.quantum_print_qureg(reg);</span>
        }

        //   H⊗n   |2|0^n&gt; -I_n|  H⊗n

<span class="fc bfc" id="L645" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L646">            gates.quantum_hadamard(i, reg);</span>
        }

<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L650">            System.out.format(</span>
                &quot;AFTER hadamard target=%d hadamard reg.size=%d\n&quot;, 
<span class="nc" id="L652">                target, reg.size);</span>
<span class="nc" id="L653">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="fc" id="L656">        inversion(reg, gates);</span>

<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L659">            System.out.format(</span>
                &quot;AFTER target=%d inversion reg.size=%d\n&quot;, 
<span class="nc" id="L661">                target, reg.size);</span>
<span class="nc" id="L662">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L666">            gates.quantum_hadamard(i, reg);</span>
        }

<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L670">            System.out.format(&quot;AFTER target=%d 2nd hadamard  reg.size=%d\n&quot;, </span>
<span class="nc" id="L671">                target, reg.size);</span>
<span class="nc" id="L672">            qureg.quantum_print_qureg(reg);</span>
        }
       
<span class="fc" id="L675">    }</span>
    
    /**
     * runtime complexity is O(reg.size * reg.width)  (because decoherence lambda is 0.0).
     * 
     * @param target 
     *     (f(x) == 1 when x == target, else f(x) == 0)
     * @param reg states with the high bit set are the found items
     */
    private void grover2(int target, QuantumReg reg, Gates gates, QuReg qureg) {
             
        int i;
        
        // matching state is rotated by PI
<span class="fc" id="L689">        oracle2(target, reg, gates);</span>

<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L692">            System.out.format(</span>
                &quot;AFTER oracle2 target=%d  reg.size=%d  hash.length=%d\n&quot;, 
<span class="nc" id="L694">                target, reg.size, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L695">            qureg.quantum_print_qureg(reg);</span>
        }

        // amplify the state with high bit set       
                
        /*
        double avg = 0;
        for (int j = 0; j &lt; reg.size; ++j) {
            avg += reg.node[j].amplitude.re();
        }
        avg /= (double) reg.size;
        */
        
        // NOTE: not knowing the avg from quantum methods, assume it
        //       to be the normalization
        // NOTE: also, assuming that an amplifier is available and a
        //       beam splitter or the equivalent
<span class="fc" id="L712">        double avg = 1./Math.sqrt(reg.size);</span>

        // change amplitudes by their difference from avg
<span class="fc bfc" id="L715" title="All 2 branches covered.">        for (int j = 0; j &lt; reg.size; ++j) {</span>
<span class="fc" id="L716">            double a = reg.node[j].amplitude.re();</span>
            // a = 2*avg - a
<span class="fc" id="L718">            reg.node[j].amplitude.setReal(2. * avg - a);</span>
<span class="fc" id="L719">            reg.node[j].amplitude.times(1./Math.sqrt(2.));</span>
        }
        
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L723">            double sum = 0;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            for (i = 0; i &lt; reg.size; ++i) {</span>
<span class="nc" id="L725">                sum += reg.node[i].amplitude.squareSum();</span>
            }
<span class="nc" id="L727">            System.out.println(&quot;sum of squares=&quot; + sum);</span>
        }
        
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L731">            System.out.format(</span>
                &quot;AFTER grover target=%d reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L733">                target, reg.size, reg.width);</span>
<span class="nc" id="L734">            qureg.quantum_print_qureg(reg);</span>
        }
<span class="fc" id="L736">    }</span>

    /** runtime complexity is O(reg.size * reg.width) * nLoop
       (the runtime complexity of the preparation of the register 
     * is ignored.  it is O(2^width)).
     * Note that nLoop is (Math.PI / 4) * Math.sqrt(2^width)
     * where width is (the bit length of number) + 1
     * 
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^(number bit length + 1)
    */
    public int run(int number) {

<span class="nc" id="L749">        int width = MiscMath.numberOfBits(number + 1);</span>

<span class="nc" id="L751">        return run(number, width);</span>
    }

    /**
     * runtime complexity is O(reg.size * reg.width) * nLoop.
     * Note that nLoop is (Math.PI / 4) * Math.sqrt(2^width).
     * (the runtime complexity of the preparation of the register 
     * is ignored.  it is O(2^width)).
     * 
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^width.
     * @param width largest bit length to use in enumeration.
     * NOTE that if it is less than (the bit length of number) + 1,
     * it will be increased to that.
     * @return 
     */
    public int run(int number, int width) {

        int i;

<span class="fc" id="L771">        final int N = number;</span>

<span class="fc" id="L773">        Random rng = Misc.getSecureRandom();</span>

<span class="fc" id="L775">        Gates gates = new Gates(rng);</span>

<span class="fc" id="L777">        int tmp = MiscMath.numberOfBits(N + 1);</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        if (width &lt; tmp) {</span>
<span class="nc" id="L779">            width = tmp;</span>
        }
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        if (width &lt; 2) {</span>
<span class="nc" id="L782">            width = 2;</span>
        }
<span class="fc" id="L784">        width0 = width;</span>

<span class="fc" id="L786">        QuReg qureg = new QuReg();</span>

<span class="fc" id="L788">        QuantumReg reg = qureg.quantum_new_qureg(0, width0);</span>

<span class="pc bpc" id="L790" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L791">            System.out.format(</span>
                &quot;AFTER construction  reg.size=%d reg.width=%d hash.length=%d\n&quot;, 
<span class="nc" id="L793">                reg.size, reg.width, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L794">            qureg.quantum_print_qureg(reg);</span>
        }
        
        //Flip the target bit of each basis state, reg.width
        //runtime complexity is O(reg.size) (because decoherence lambda is 0.0).
<span class="fc" id="L799">        qureg.quantum_addscratch(1, reg);</span>
<span class="fc" id="L800">        reg.width *= 2;</span>
<span class="fc" id="L801">        reg.width += 2;</span>
<span class="fc" id="L802">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
<span class="fc" id="L803">        gates.quantum_sigma_x(width0, reg);</span>
        
<span class="fc" id="L805">        System.out.format(&quot;N = %d, width0=%d reg.width=%d\n&quot;, N, width0,</span>
<span class="fc" id="L806">            reg.width);</span>

<span class="pc bpc" id="L808" title="1 of 2 branches missed.">        if (debug) {</span>
            //DEBUG
<span class="nc" id="L810">            System.out.format(&quot;AFTER sigma_x  reg.size=%d reg.width=%d\n&quot;, </span>
<span class="nc" id="L811">                reg.size, reg.width);</span>
<span class="nc" id="L812">            qureg.quantum_print_qureg(reg);</span>
        }

        //runtime complexity is O(reg.size * reg.width)
<span class="fc bfc" id="L816" title="All 2 branches covered.">        for (i = 0; i &lt; width0 + 1; i++) {</span>
<span class="fc" id="L817">            gates.quantum_hadamard(i, reg);</span>
        }
        
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L821">            System.out.format(</span>
                &quot;AFTER 1st hadamard gates  reg.size=%d reg.width=%d hash.length=%d\n&quot;, 
<span class="nc" id="L823">                reg.size, reg.width, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L824">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L828">            System.out.format(&quot;AFTER 2 1st hadamard gates  reg.size=%d reg.width=%d hash.length=%d\n&quot;, </span>
<span class="nc" id="L829">                reg.size, reg.width, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L830">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="fc" id="L833">        return search(number, rng, gates, qureg, reg);</span>
    }
    
    private int search(int number, Random rng, Gates gates, QuReg qureg, 
        QuantumReg reg) {
        
        int i;
        
        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
<span class="fc" id="L843">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; width0));</span>

<span class="fc" id="L845">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="fc bfc" id="L848" title="All 2 branches covered.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L851">                System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            }
            
<span class="fc" id="L854">            grover(number, reg, gates, qureg);</span>
        }

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">        if (debug) { //DEBUG</span>
<span class="nc" id="L858">            System.out.format(</span>
                &quot;AFTER grover  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L860">                reg.size, reg.width);</span>
<span class="nc" id="L861">            qureg.quantum_print_qureg(reg);</span>
        }
        

<span class="fc" id="L865">        gates.quantum_hadamard(width0, reg);</span>


<span class="pc bpc" id="L868" title="1 of 2 branches missed.">        if (debug) {//DEBUG//DEBUG</span>
<span class="nc" id="L869">            System.out.format(</span>
                &quot;AFTER last hadamard  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L871">                reg.size, reg.width);</span>
<span class="nc" id="L872">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="fc" id="L875">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="fc" id="L878">        measure.quantum_bmeasure(width0, reg, rng);</span>

        //DEBUG
<span class="fc" id="L881">        System.out.format(</span>
            &quot;AFTER bmeasure reg.size=%d reg.width=%d\n&quot;, 
<span class="fc" id="L883">            reg.size, reg.width);</span>
<span class="fc" id="L884">        qureg.quantum_print_qureg(reg);</span>


<span class="pc bpc" id="L887" title="1 of 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">            if (reg.node[i].state == number) {</span>
<span class="fc" id="L889">                System.out.format(</span>
<span class="fc" id="L890">                    &quot;\nFound %d with a probability of %f\n\n&quot;, number,</span>
<span class="fc" id="L891">                    reg.node[i].amplitude.squareSum());</span>
<span class="fc" id="L892">                return number;</span>
            }
        }

<span class="nc" id="L896">        return -1;</span>
    }
    
    // ---- adding ability to find number within a list of numbers for use 
    //      within the quantum min algorithm ----
    
    /**
     * runtime complexity for the search 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N), 
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^width.
     * @param width largest bit length to use in enumeration.
     * NOTE that if it is less than (the bit length of number) + 1,
     * it will be increased to that.
     * @param list a list of unordered numbers to search for number within.
     * NOTE that the list must be valid input.
     * @return 
     */
    public int run(int number, int width, int[] list) {

<span class="fc" id="L923">        int N = number;</span>
        int i;
        
<span class="fc" id="L926">        int tmp = MiscMath.numberOfBits(N);</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (width &lt; tmp) {</span>
<span class="nc" id="L928">            width = tmp;</span>
        }
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (width &lt; 2) {</span>
<span class="nc" id="L931">            width = 2;</span>
        }
<span class="fc" id="L933">        width0 = width;</span>
        
<span class="fc" id="L935">        QuReg qureg = new QuReg();</span>

<span class="fc" id="L937">        Random rng = Misc.getSecureRandom();</span>
        
        int ret;
        
        if (false) {
            
            QuantumReg reg = initializeRegister(qureg, list);

            System.out.format(&quot;N = %d, list.length=%d, width0=%d reg.width=%d\n&quot;, N, 
                list.length, width0, reg.width);

            ret = processInitialized(number, reg, rng);

        } else {
            
<span class="fc" id="L952">            QuantumReg reg = initializeRegister2(qureg, list);</span>

<span class="fc" id="L954">            System.out.format(&quot;N = %d, list.length=%d, width0=%d reg.width=%d\n&quot;, N, </span>
<span class="fc" id="L955">                list.length, width0, reg.width);</span>

<span class="fc" id="L957">            ret = processInitialized2(number, reg, rng);</span>
        }
        
<span class="fc" id="L960">        return ret;</span>
    }
    
    public int run(int number, int width, int setQuBits) {
    
<span class="fc" id="L965">        width0 = width;</span>
        
<span class="fc" id="L967">        QuReg qureg = new QuReg();</span>
<span class="fc" id="L968">        QuantumReg reg = initializeRegister(qureg, setQuBits);</span>
        
<span class="fc" id="L970">        System.out.format(&quot;N = %d, width0=%d reg.width=%d\n&quot;, number, </span>
<span class="fc" id="L971">            width0, reg.width);</span>
        
<span class="fc" id="L973">        Random rng = Misc.getSecureRandom();</span>
        
<span class="fc" id="L975">        int ret = processInitialized2(number, reg, rng);</span>
        
<span class="fc" id="L977">        return ret;</span>
    }
    
    /**
     * Initialize the register with a list of numbers.
     * Note, that the register, as the possible states of superposition of
     * qubits, will have all possible permutation of the qubits up to the
     * power of 2 or next higher power of 2 in the list.
     * A continuous sequence of numbers from 0 up to a power of 2 is valid 
     * input for the current logic (can be unordered).
     * A continuous sequence of numbers from a power of 2 up to a power of 2.
     * is valid input.
     */
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param stateList
     * @param amplList amplitudes associated with the eigenstate at same index
     * in stateList
     * @return 
     */
    public QuantumReg initializeRegister(QuReg qureg, 
        ComplexModifiable[] amplList, int[] stateList) {
      
<span class="nc" id="L1004">        final int initSize = 2 * amplList.length;</span>

<span class="nc" id="L1006">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width0);</span>
<span class="nc" id="L1007">        reg.width *= 2;</span>
<span class="nc" id="L1008">        reg.width += 2;</span>
<span class="nc" id="L1009">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
        //need to initialize a register to have the given states from list
        //and a set of the same numbers but with negative amplitude and
        //the next highest bit set, that is width + 1
        //    rest of the algorithm should proceed in same manner.
        
<span class="nc" id="L1016">        int offset = 1 &lt;&lt; width0;</span>
        
        int i;
<span class="nc" id="L1019">        double invSqrt = 1./Math.sqrt(2.);</span>
        
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        for (i = 0; i &lt; amplList.length; ++i) {</span>
<span class="nc" id="L1022">            reg.node[i].state = stateList[i];</span>
<span class="nc" id="L1023">            reg.node[i].state |= offset;</span>
<span class="nc" id="L1024">            reg.node[i].amplitude.resetTo(amplList[i]);</span>
<span class="nc" id="L1025">            reg.node[i].amplitude.times(-invSqrt);</span>
        }
        
<span class="nc" id="L1028">        int idx = amplList.length;</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        for (i = 0; i &lt; amplList.length; ++i) {</span>
<span class="nc" id="L1030">            reg.node[idx].state = stateList[i];</span>
<span class="nc" id="L1031">            reg.node[idx].amplitude.resetTo(amplList[i]);</span>
<span class="nc" id="L1032">            reg.node[idx].amplitude.times(invSqrt);</span>
<span class="nc" id="L1033">            idx++;</span>
        }
        
<span class="nc" id="L1036">        return reg;</span>
    }
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param setBits
     * @return 
     */
    public QuantumReg initializeRegister(QuReg qureg, int setBits) {
       
<span class="fc" id="L1049">        int nBits = MiscMath.numberOfBits(setBits);</span>
        
        int i;
        
<span class="fc" id="L1053">        int nSetBits = 0;</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        for (i = 0; i &lt; nBits; ++i) {</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">            if ((setBits &amp; (1 &lt;&lt; i)) != 0) {</span>
<span class="fc" id="L1056">                nSetBits++;</span>
            }
        }
        
<span class="fc" id="L1060">        QuantumReg reg = qureg.quantum_new_qureg_size(</span>
            nSetBits, width0);

<span class="fc" id="L1063">        reg.width *= 2;</span>
<span class="fc" id="L1064">        reg.width += 2;</span>
<span class="fc" id="L1065">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
<span class="fc" id="L1067">        double norm = 1./Math.sqrt(nSetBits);  </span>
<span class="fc" id="L1068">        int ii = 0;</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (i = 0; i &lt; nBits; ++i) {</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">            if ((setBits &amp; (1 &lt;&lt; i)) != 0) {</span>
                //initializing with same state + highbit off of register
<span class="fc" id="L1072">                reg.node[ii].state = (1 &lt;&lt; i);</span>
<span class="fc" id="L1073">                reg.node[ii].amplitude.setReal(norm);</span>
<span class="fc" id="L1074">                ++ii;</span>
            }
        }
                
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L1079">            System.out.format(&quot;initialized  reg.size=%d reg.width=%d\n&quot;, </span>
<span class="nc" id="L1080">                reg.size, reg.width);</span>
<span class="nc" id="L1081">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="fc" id="L1084">        return reg;</span>
    }
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param setBits
     * @param width
     * @return 
     */
    private QuantumReg initializeRegister(QuReg qureg, int[] list) {
        
<span class="nc" id="L1098">        int listLen = list.length;</span>
        
<span class="nc" id="L1100">        final int initSize = 2 * listLen;</span>

<span class="nc" id="L1102">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width0);</span>

<span class="nc" id="L1104">        reg.width *= 2;</span>
<span class="nc" id="L1105">        reg.width += 2;</span>
<span class="nc" id="L1106">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
        //need to initialize a register to have the given states from list
        //and a set of the same numbers but with negative amplitude and
        //the next highest bit set, that is width + 1
        //    rest of the algorithm should proceed in same manner.
                
<span class="nc" id="L1113">        int offset = 1 &lt;&lt; width0;</span>
        
        int i;
        
<span class="nc" id="L1117">        double norm = 1./Math.sqrt(initSize);  </span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="nc" id="L1119">            reg.node[i].state = list[i] + offset;</span>
<span class="nc" id="L1120">            reg.node[i].amplitude.setReal(-norm);</span>
        }
<span class="nc" id="L1122">        int ii = list.length;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="nc" id="L1124">            reg.node[ii].state = list[i];</span>
<span class="nc" id="L1125">            reg.node[ii].amplitude.setReal(norm);</span>
<span class="nc" id="L1126">            ii++;</span>
        }
        
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L1130">            System.out.format(&quot;AFTER init reg.size=%d &quot;</span>
<span class="nc" id="L1131">                + &quot; width0=%d reg.width=%d reg.hash.length=%d\n&quot;, reg.size,</span>
<span class="nc" id="L1132">                width0, reg.width, (1 &lt;&lt; reg.hashw));</span>
<span class="nc" id="L1133">            qureg.quantum_print_qureg(reg);</span>
        }
       
<span class="nc" id="L1136">        return reg;</span>
    }
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param setBits
     * @param width
     * @return 
     */
    private QuantumReg initializeRegister2(QuReg qureg, int[] list) {
        
<span class="fc" id="L1150">        int listLen = list.length;</span>
        
<span class="fc" id="L1152">        final int initSize = listLen;</span>

<span class="fc" id="L1154">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width0);</span>

<span class="fc" id="L1156">        reg.width *= 2;</span>
<span class="fc" id="L1157">        reg.width += 2;</span>
<span class="fc" id="L1158">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
        //need to initialize a register to have the given states from list
        //and a set of the same numbers but with negative amplitude and
        //the next highest bit set, that is width + 1
        //    rest of the algorithm should proceed in same manner.
                
        int i;
        
<span class="fc" id="L1167">        double norm = 1./Math.sqrt(initSize);  </span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="fc" id="L1169">            reg.node[i].state = list[i];</span>
<span class="fc" id="L1170">            reg.node[i].amplitude.setReal(norm);</span>
        }
        
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L1174">            System.out.format(&quot;AFTER init reg.size=%d &quot;</span>
<span class="nc" id="L1175">                + &quot; width0=%d reg.width=%d reg.hash.length=%d\n&quot;, reg.size,</span>
<span class="nc" id="L1176">                width0, reg.width, (1 &lt;&lt; reg.hashw));</span>
<span class="nc" id="L1177">            qureg.quantum_print_qureg(reg);</span>
        }
       
<span class="fc" id="L1180">        return reg;</span>
    }
    
    /**
     * runtime complexity for the processing 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N),
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * NOTE that measurements of register reg are not taken.
     * @param number a number to search for within the initialized register reg
     * @param reg initialized register which holds nodes of state which are 
     * searched and have amplitudes which when squared and summed over register 
     * are equal to 1.
     * @param rng
     * @return
     */
    public int processInitialized(int number, QuantumReg reg, Random rng) {
        
        int i;

<span class="nc" id="L1205">        final int N = number;</span>

<span class="nc" id="L1207">        QuReg qureg = new QuReg();</span>
        
        //DEBUG
        //System.out.format(&quot;AFTER construction  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
        //  NOTE that if the number of times number will appear in list
        //     is known ahead of time,
        //     the term in the sqrt can be divided by that multiplicity.
<span class="nc" id="L1218">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; width0));</span>

<span class="nc" id="L1220">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

<span class="nc" id="L1222">        Gates gates = new Gates(rng);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="nc bnc" id="L1227" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L1228">                System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            }
            
<span class="nc" id="L1231">            grover(N, reg, gates, qureg);</span>
        }

<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (debug) { //DEBUG</span>
<span class="nc" id="L1235">            System.out.format(</span>
                &quot;AFTER grover  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1237">                reg.size, reg.width);</span>
<span class="nc" id="L1238">            qureg.quantum_print_qureg(reg);</span>
        }
        

<span class="nc" id="L1242">        gates.quantum_hadamard(width0, reg);</span>


<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (debug) {//DEBUG//DEBUG</span>
<span class="nc" id="L1246">            System.out.format(</span>
                &quot;AFTER last hadamard  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1248">                reg.size, reg.width);</span>
<span class="nc" id="L1249">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="nc" id="L1252">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="nc" id="L1255">        measure.quantum_bmeasure(width0, reg, rng);</span>

        //DEBUG
<span class="nc" id="L1258">        System.out.format(</span>
            &quot;AFTER bmeasure reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1260">            reg.size, reg.width);</span>
<span class="nc" id="L1261">        qureg.quantum_print_qureg(reg);</span>


<span class="nc bnc" id="L1264" title="All 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">            if (reg.node[i].state == N) {</span>
<span class="nc" id="L1266">                System.out.format(</span>
<span class="nc" id="L1267">                    &quot;\nFound %d with a probability of %f\n\n&quot;, N,</span>
<span class="nc" id="L1268">                    reg.node[i].amplitude.squareSum());</span>
<span class="nc" id="L1269">                return number;</span>
            }
        }

<span class="nc" id="L1273">        return -1;</span>
    }

    /**
     * runtime complexity for the processing 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N),
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * NOTE that measurements of register reg are not taken.
     * @param number a number to search for within the initialized register reg
     * @param reg initialized register which holds nodes of state which are 
     * searched and have amplitudes which when squared and summed over register 
     * are equal to 1.
     * @param rng
     * @return
     */
    public int processInitialized2(int number, QuantumReg reg, Random rng) {
        
        int i;

<span class="fc" id="L1298">        final int N = number;</span>

<span class="fc" id="L1300">        QuReg qureg = new QuReg();</span>
        
        //DEBUG
        //System.out.format(&quot;AFTER construction  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
        //  NOTE that if the number of times number will appear in list
        //     is known ahead of time,
        //     the term in the sqrt can be divided by that multiplicity.
<span class="fc" id="L1311">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; width0));</span>

<span class="fc" id="L1313">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

<span class="fc" id="L1315">        Gates gates = new Gates(rng);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L1321">                System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            }
            
<span class="fc" id="L1324">            grover2(N, reg, gates, qureg);</span>
        }

<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">        if (debug) { //DEBUG</span>
<span class="nc" id="L1328">            System.out.format(</span>
                &quot;AFTER grover  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1330">                reg.size, reg.width);</span>
<span class="nc" id="L1331">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="fc" id="L1334">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="fc" id="L1337">        measure.quantum_bmeasure(width0, reg, rng);</span>

        //DEBUG
<span class="fc" id="L1340">        System.out.format(</span>
            &quot;AFTER bmeasure reg.size=%d reg.width=%d\n&quot;, 
<span class="fc" id="L1342">            reg.size, reg.width);</span>
<span class="fc" id="L1343">        qureg.quantum_print_qureg(reg);</span>


<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">            if (reg.node[i].state == N) {</span>
<span class="fc" id="L1348">                System.out.format(</span>
<span class="fc" id="L1349">                    &quot;\nFound %d with a probability of %f\n\n&quot;, N,</span>
<span class="fc" id="L1350">                    reg.node[i].amplitude.squareSum());</span>
<span class="fc" id="L1351">                return number;</span>
            }
        }

<span class="fc" id="L1355">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>
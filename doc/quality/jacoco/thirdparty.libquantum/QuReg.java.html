<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QuReg.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.libquantum</a> &gt; <span class="el_source">QuReg.java</span></div><h1>QuReg.java</h1><pre class="source lang-java linenums">package thirdparty.libquantum;

import algorithms.misc.ComplexModifiable;
import algorithms.misc.MiscMath;
import java.util.Arrays;

/* qureg
Quantum register management

   Copyright 2003, 2004 Bjoern Butscher, Hendrik Weimer

   This file is part of libquantum

   libquantum is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 3 of the License,
   or (at your option) any later version.

   libquantum is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with libquantum; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA

 */

<span class="pc bpc" id="L31" title="1 of 2 branches missed.">public class QuReg {</span>

    /**
     * Our 64-bit multiplicative hash function
     * that is actually 31 bit.
     * TODO: refactor name when refactor for camel case.
     */
    /*static inline unsigned int quantum_hash64(MAX_UNSIGNED key, int width) {
        unsigned int k32;
        k32 = (key &amp; 0xFFFFFFFF) ^ (key &gt;&gt; 32);
        k32 *= 0x9e370001UL;
        k32 = k32 &gt;&gt; (32 - width);
        return k32;
    }*/
    static int quantum_hash64(long key, int width) {

        //this will always be == key value unless allow key type to be long
<span class="fc" id="L48">        long k = (key &amp; 0x7FFFFFFF) ^ (key &gt;&gt; 31);</span>
<span class="fc" id="L49">        k *= 1327202304L; // factor is 0x9e370001UL &gt;&gt; 1 which is 30.3057</span>
<span class="fc" id="L50">        k &amp;= ((1 &lt;&lt; 31) - 1);</span>
<span class="fc" id="L51">        k = k &gt;&gt; (31L - width);</span>
        
<span class="fc" id="L53">        return (int) k;</span>
    }
    
    /**
     * Get the position of a given base state via the hash table
     */
    //static inline int quantum_get_state(MAX_UNSIGNED a, quantum_reg reg) {
    static int quantum_get_state(long a, QuantumReg reg) {
        int i;

<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (reg.hashw == 0) {</span>
<span class="nc" id="L64">            return (int)a;</span>
        }

<span class="fc" id="L67">        i = quantum_hash64(a, reg.hashw);</span>

<span class="pc bpc" id="L69" title="1 of 2 branches missed.">        while (reg.hash[i] != 0) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">            if (reg.node[reg.hash[i] - 1].state == a) {</span>
<span class="nc" id="L71">                return reg.hash[i] - 1;</span>
            }
<span class="nc" id="L73">            i++;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            if (i == (1 &lt;&lt; reg.hashw)) {</span>
<span class="nc" id="L75">                i = 0;</span>
            }
        }

<span class="fc" id="L79">        return -1;</span>

    }

    /**
     * Add an element to the hash table
     */
    //static inline void quantum_add_hash(MAX_UNSIGNED a, int pos, quantum_reg *reg) {
    static void quantum_add_hash(long a, int pos, QuantumReg reg) {

<span class="fc" id="L89">        int i, mark = 0;</span>

<span class="fc" id="L91">        i = quantum_hash64(a, reg.hashw);</span>
        
<span class="fc" id="L93">        int end = 1 &lt;&lt; reg.hashw;</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        while (reg.hash[i] != 0) {</span>
<span class="nc" id="L95">            i++;</span>
            // if i is &gt; last index
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (i == end) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (mark == 0) {</span>
<span class="nc" id="L99">                    i = 0;</span>
<span class="nc" id="L100">                    mark = 1;</span>
                } else {
<span class="nc" id="L102">                    StackTraceElement[] st = Thread.currentThread().getStackTrace();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                    for (StackTraceElement s : st) {</span>
<span class="nc" id="L104">                        System.out.println(s);</span>
                    }
<span class="nc" id="L106">                    throw new IllegalStateException(&quot;hash is full.  i=&quot; + i + </span>
                         &quot; hash.lrngth=&quot; + end);
                }
            }
        }
        
        //NOTE: since this value is the index of reg.node,
        //      the last entry is an invalid value.
        //      should the value be pos?
<span class="fc" id="L115">        reg.hash[i] = pos + 1;</span>
<span class="fc" id="L116">    }</span>

    /**
     * Reconstruct hash table
     */
    static void quantum_reconstruct_hash(QuantumReg reg) {
  
        int i;

        /* Check whether register is sorted */
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (reg.hashw == 0) {</span>
<span class="nc" id="L127">            return;</span>
        }

<span class="fc" id="L130">        int end = 1 &lt;&lt; reg.hashw;</span>
<span class="fc" id="L131">        Arrays.fill(reg.hash, 0, end, 0);</span>
   
<span class="pc bpc" id="L133" title="3 of 4 branches missed.">        assert(reg.node.length &gt;= reg.size);</span>
        
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc" id="L136">            quantum_add_hash(reg.node[i].state, i, reg);</span>
        }
<span class="fc" id="L138">    }</span>
    
    /**
     * Return the reduced bitmask of a basis state
     */
    //static int quantum_bitmask(MAX_UNSIGNED a, int width, int  *bits) {
    static int quantum_bitmask(long a, int width, int[] bits) {
        
        int i;
<span class="nc" id="L147">        int mask = 0;</span>

<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (i = 0; i &lt; width; i++) {</span>
            //if (a &amp; ((MAX_UNSIGNED) 1 &lt;&lt; bits[i])) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if ((a &amp; (1L &lt;&lt; bits[i])) != 0) {</span>
<span class="nc" id="L152">                mask += (1 &lt;&lt; i);</span>
            }
        }

<span class="nc" id="L156">        return mask;</span>
    }

    /**
     * Convert a vector to a quantum register
     */
    QuantumReg quantum_matrix2qureg(QuantumMatrix m, int w) {
  
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (m.cols != 1) {</span>
<span class="nc" id="L165">            throw new IllegalArgumentException(&quot;m nCols must == 1&quot;);</span>
        }
        
<span class="nc" id="L168">        QuantumReg reg = new QuantumReg();</span>
<span class="nc" id="L169">        int i, j, size = 0;</span>

<span class="nc" id="L171">        reg.width = w;</span>

        // Determine the size of the quantum register 
<span class="nc bnc" id="L174" title="All 2 branches missed.">        for (i = 0; i &lt; m.rows; i++) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (m.t[i].squareSum()!= 0.0) {</span>
<span class="nc" id="L176">                size++;</span>
            }
        }

        // Allocate the required memory 
<span class="nc" id="L181">        reg.size = size;</span>
<span class="nc" id="L182">        reg.hashw = w + 2;</span>

<span class="nc" id="L184">        reg.node = new QuantumRegNode[size];</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (int ii = 0; ii &lt; reg.node.length; ii++) {</span>
<span class="nc" id="L186">            reg.node[ii] = new QuantumRegNode();</span>
<span class="nc" id="L187">            reg.node[ii].state = 0;</span>
<span class="nc" id="L188">            reg.node[ii].amplitude = new ComplexModifiable(0, 0);</span>
        }
        
        // Allocate the hash table 
<span class="nc" id="L192">        int nHash = 1 &lt;&lt; reg.hashw;</span>
<span class="nc" id="L193">        reg.hash = new int[nHash];</span>

        // Copy the nonzero amplitudes of the vector into the 
        //quantum register 
<span class="nc bnc" id="L197" title="All 2 branches missed.">        for (i = 0, j = 0; i &lt; m.rows; i++) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (m.t[i].squareSum() != 0.0) {</span>
<span class="nc" id="L199">                reg.node[j].state = i;</span>
<span class="nc" id="L200">                reg.node[j].amplitude.resetTo(m.t[i]);</span>
<span class="nc" id="L201">                j++;</span>
            }
        }

<span class="nc" id="L205">        return reg;</span>
    }

    /**
     * Create a new quantum register from scratch
     */
    //QuantumReg quantum_new_qureg(MAX_UNSIGNED initval, int width) {
    QuantumReg quantum_new_qureg(long initval, int w) {
        
<span class="fc" id="L214">        QuantumReg reg = new QuantumReg();</span>

<span class="fc" id="L216">        reg.width = w;</span>
<span class="fc" id="L217">        reg.size = 1;</span>
<span class="fc" id="L218">        reg.hashw = w + 2;</span>
        
        // Allocate memory for 1 base state 
<span class="fc" id="L221">        reg.node = new QuantumRegNode[1];</span>

        // Allocate the hash table 
<span class="fc" id="L224">        int nHash = 1 &lt;&lt; reg.hashw;</span>
<span class="fc" id="L225">        reg.hash = new int[nHash];</span>

        // Initialize the quantum register 
<span class="fc" id="L228">        reg.node[0] = new QuantumRegNode();</span>
<span class="fc" id="L229">        reg.node[0].state = initval;</span>
<span class="fc" id="L230">        reg.node[0].amplitude =  new ComplexModifiable(1, 0);</span>

<span class="fc" id="L232">        System.out.format(</span>
            &quot;init reg: %d qubits, 1 node, and %d hash table length, hashw=%d\n&quot;,
<span class="fc" id="L234">            reg.width, nHash, reg.hashw);</span>
        
<span class="fc" id="L236">        return reg;</span>
    }

    /**
     * Returns an empty quantum register of size N
     * with instantiated nodes.
     */
    QuantumReg quantum_new_qureg_size(int n, int w) {
        
<span class="nc" id="L245">        QuantumReg reg = new QuantumReg();</span>

<span class="nc" id="L247">        reg.width = w;</span>
<span class="nc" id="L248">        reg.size = n;</span>
<span class="nc" id="L249">        reg.hashw = 0;</span>
<span class="nc" id="L250">        reg.hash = null;</span>

        // Allocate memory for n basis states 
<span class="nc" id="L253">        reg.node = new QuantumRegNode[n];</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        for (int ii = 0; ii &lt; reg.node.length; ii++) {</span>
<span class="nc" id="L255">            reg.node[ii] = new QuantumRegNode();</span>
<span class="nc" id="L256">            reg.node[ii].state = 0;</span>
<span class="nc" id="L257">            reg.node[ii].amplitude = new ComplexModifiable(0, 0);</span>
        }
        
<span class="nc" id="L260">        return reg;</span>
    }

    /**
     * Convert a quantum register to a vector
     */
    QuantumMatrix quantum_qureg2matrix(QuantumReg reg) {
        
        int i;

<span class="nc" id="L270">        Matrix matrix = new Matrix();</span>
<span class="nc" id="L271">        int sz = 1 &lt;&lt; reg.width;</span>
<span class="nc" id="L272">        QuantumMatrix m = matrix.quantum_new_matrix(1, sz);</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="nc" id="L275">            m.t[(int)reg.node[i].state].resetTo(reg.node[i].amplitude);</span>
        }

<span class="nc" id="L278">        return m;</span>
    }

    /**
     * Copy the contents of src to dst
     */
    void quantum_copy_qureg(QuantumReg src, QuantumReg dst) {
   
<span class="fc" id="L286">        dst.hash = Arrays.copyOf(src.hash, src.hash.length);</span>
<span class="fc" id="L287">        dst.hashw = src.hashw;</span>
<span class="fc" id="L288">        dst.node = Arrays.copyOf(src.node, src.node.length);</span>
<span class="fc" id="L289">        dst.size = src.size;</span>
<span class="fc" id="L290">        dst.width = src.width;</span>
<span class="fc" id="L291">    }</span>

    /**
     * Print the contents of a quantum register to stdout
     */
    void quantum_print_qureg(QuantumReg reg) {
        
        int i, j;

<span class="fc bfc" id="L300" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc" id="L301">            System.out.format(&quot;%f %fi|%d&gt; (%f) (|&quot;, </span>
<span class="fc" id="L302">                reg.node[i].amplitude.re(),</span>
<span class="fc" id="L303">                reg.node[i].amplitude.im(), </span>
<span class="fc" id="L304">                reg.node[i].state,</span>
<span class="fc" id="L305">                reg.node[i].amplitude.squareSum());</span>
            
            //write bitstring of node's state from msb to lsb
<span class="fc bfc" id="L308" title="All 2 branches covered.">            for (j = reg.width - 1; j &gt;= 0; j--) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                if (j % 4 == 3) {</span>
<span class="fc" id="L310">                    System.out.format(&quot; &quot;);</span>
                }
                // test if bit j is set in node[i]'s state:
<span class="fc" id="L313">                long bitJ = 1L &lt;&lt; j;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                int b = ((bitJ &amp; reg.node[i].state) &gt; 0) ? 1 : 0;</span>
<span class="fc" id="L315">                System.out.format(&quot;%d&quot;, b);</span>
            }

<span class="fc" id="L318">            System.out.format(&quot;&gt;)\n&quot;);</span>
        }

<span class="fc" id="L321">        System.out.format(&quot;\n&quot;);</span>
<span class="fc" id="L322">    }</span>

    /**
     * Print the output of the modular exponentiation algorithm
     */
    void quantum_print_expn(QuantumReg reg) {
        int i;
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="nc" id="L330">            long tmp = 1L &lt;&lt; (reg.width / 2);</span>
<span class="nc" id="L331">            System.out.format(&quot;%d: %d\n&quot;, i, </span>
<span class="nc" id="L332">                reg.node[i].state - i * tmp);</span>
        }
<span class="nc" id="L334">    }</span>

    /**
     * Add additional space to a qureg. It is initialized to zero and 
     * can be used as scratch space. Note that the space gets added at the LSB
     makes current bitstrings in reg.node states larger by a 
     * left bitshift of size bits.
     */
    void quantum_addscratch(int bits, QuantumReg reg) {
        
        int i, oldwidth;
        //MAX_UNSIGNED l;
        long l;

<span class="fc" id="L348">        oldwidth = reg.width;</span>
<span class="fc" id="L349">        reg.width += bits;</span>

<span class="fc" id="L351">        long shift = bits;</span>
        
<span class="fc bfc" id="L353" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
            
<span class="fc" id="L355">            l = reg.node[i].state &lt;&lt; shift;</span>
            
            //System.out.format(&quot;--&gt;%d (%d)\n&quot;, (int)l, i);
            
<span class="fc" id="L359">            reg.node[i].state = l;</span>
        }
<span class="fc" id="L361">    }</span>

    /**
     * Print the hash table to stdout and test if the hash table is corrupted
     */
    void quantum_print_hash(QuantumReg reg) {
        int i;
<span class="nc" id="L368">        long tmp = 1L &lt;&lt; reg.hashw;</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">        assert(reg.hash.length == tmp);</span>
<span class="nc" id="L370">        int hashMax = MiscMath.findMax(reg.hash);</span>
<span class="nc" id="L371">        System.out.println(&quot;hash length=&quot; + reg.hash.length + &quot; max value=&quot; </span>
            + hashMax + &quot; node.length=&quot; + reg.node.length);
<span class="nc bnc" id="L373" title="All 4 branches missed.">        assert(reg.node.length &gt;= reg.size);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        for (i = 0; i &lt; tmp; i++) {</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">            if (i &gt; 0 &amp;&amp; reg.hash[i] &gt; 0) {</span>
<span class="nc" id="L376">                int idx = reg.hash[i] - 1;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (idx &lt; reg.node.length) {</span>
<span class="nc" id="L378">                    System.out.format(&quot;%d: %d %d\n&quot;, i, idx,</span>
<span class="nc" id="L379">                        reg.node[idx].state);</span>
                }
            }
        }
<span class="nc" id="L383">    }</span>

    /**
     * Compute the Kronecker product of two quantum registers.
     * 
     * &lt;pre&gt;
     *   if reg1 is A which is a 2^n vector and 
     *   reg2 is B which is a 2^m vector,
     *  
     *      the kronecker product is
     * 
     *      |A&gt; âŠ— |B&gt; is  | A_1 * B_1         |
     *                    | A_1 * B_2         |
     *                       ...
     *                    | A_1 * B_(2^m)     |
     *                        ...
     *                    | A_2 * B_1         |
     *                        ...
     *                    | A_(2^n) * B_(2^m) |
     * &lt;/pre&gt;
     *
     */
    QuantumReg quantum_kronecker(QuantumReg reg1, QuantumReg reg2) {
  
        int i, j;
<span class="nc" id="L408">        QuantumReg reg = new QuantumReg();</span>

<span class="nc" id="L410">        reg.width = reg1.width + reg2.width;</span>
<span class="nc" id="L411">        reg.size = reg1.size * reg2.size;</span>
<span class="nc" id="L412">        reg.hashw = reg.width + 2;</span>

        // allocate memory for the new basis states 
<span class="nc" id="L415">        reg.node = new QuantumRegNode[reg.size];</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        for (int ii = 0; ii &lt; reg.node.length; ii++) {</span>
<span class="nc" id="L417">            reg.node[ii] = new QuantumRegNode();</span>
<span class="nc" id="L418">            reg.node[ii].state = 0;</span>
<span class="nc" id="L419">            reg.node[ii].amplitude = new ComplexModifiable(0, 0);</span>
        }
        
        // Allocate the hash table 
<span class="nc" id="L423">        int nHash = 1 &lt;&lt; reg.hashw;</span>
<span class="nc" id="L424">        reg.hash = new int[nHash];</span>
        
<span class="nc bnc" id="L426" title="All 2 branches missed.">        for (i = 0; i &lt; reg1.size; i++) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            for (j = 0; j &lt; reg2.size; j++) {</span>
                // printf(&quot;processing |%lli&gt; x |%lli&gt;\n&quot;, reg1-&gt;node[i].state, 
                //reg2 -&gt; node[j].state
                //);
                //printf(&quot;%lli\n&quot;, (reg1 -&gt; node[i].state) &lt;&lt; reg2 -&gt; width);
                
<span class="nc" id="L433">                long tmp = reg1.node[i].state &lt;&lt; reg2.width;</span>
<span class="nc" id="L434">                reg.node[i * reg2.size + j].state = ( </span>
                    tmp | reg2.node[j].state);
                
<span class="nc" id="L437">                reg.node[i * reg2.size + j].amplitude.resetTo(reg1.node[i].amplitude);</span>
<span class="nc" id="L438">                reg.node[i * reg2.size + j].amplitude.times(reg2.node[j].amplitude);</span>
            }
        }

<span class="nc" id="L442">        return reg;</span>
    }

    /**
     * Reduce the state vector after measurement or partial trace
     */
    QuantumReg quantum_state_collapse(int pos, int value, QuantumReg reg) {
        int i, j, k;
<span class="fc" id="L450">        int size = 0;</span>
<span class="fc" id="L451">        double d = 0;</span>
        
<span class="fc" id="L453">        QuantumReg out = new QuantumReg();</span>
        
        //MAX_UNSIGNED lpat = 0, rpat = 0, pos2;
        //pos2 = (MAX_UNSIGNED) 1 &lt;&lt; pos;
<span class="fc" id="L457">        long pos2 = 1L &lt;&lt; pos;</span>
        
        // Eradicate all amplitudes of base states which have been ruled out
        //   by the measurement and get the norm of the new register 
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
        
<span class="fc" id="L463">            long posBit = reg.node[i].state &amp; pos2;</span>
            
<span class="fc bfc" id="L465" title="All 8 branches covered.">            if (((posBit != 0) &amp;&amp; (value != 0))</span>
                || ((posBit == 0) &amp;&amp; (value == 0))) {
                
<span class="fc" id="L468">                d += reg.node[i].amplitude.squareSum();</span>
<span class="fc" id="L469">                size++;</span>
            }
        }

        // Build the new quantum register 
<span class="fc" id="L474">        out.width = reg.width - 1;</span>
<span class="fc" id="L475">        out.size = size;</span>
<span class="fc" id="L476">        out.node = new QuantumRegNode[size];</span>
<span class="fc" id="L477">        out.hashw = reg.hashw;</span>
<span class="fc" id="L478">        out.hash = reg.hash;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">        for (int ii = 0; ii &lt; out.node.length; ii++) {</span>
<span class="fc" id="L480">            out.node[ii] = new QuantumRegNode();</span>
<span class="fc" id="L481">            out.node[ii].state = 0;</span>
<span class="fc" id="L482">            out.node[ii].amplitude = new ComplexModifiable(0, 0);</span>
        }
        
        // ---- if value == 0, keep the states with set bit pos
        //      else keep the states where bit pos is not set.
        //      d becomes the new normalization for the out states.
        
<span class="fc" id="L489">        long lpat = 0;</span>
<span class="fc" id="L490">        long rpat = 0;</span>
        
        // Determine the numbers of the new base states and norm 
        // the quantum register 
<span class="fc bfc" id="L494" title="All 2 branches covered.">        for (i = 0, j = 0; i &lt; reg.size; i++) {</span>
            
<span class="fc" id="L496">            long posBit = reg.node[i].state &amp; pos2;</span>
            
<span class="fc bfc" id="L498" title="All 8 branches covered.">            if (((posBit != 0) &amp;&amp; (value != 0))</span>
                || ((posBit == 0) &amp;&amp; (value == 0))) {
             
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">                for (k = 0, rpat = 0; k &lt; pos; k++) {</span>
<span class="nc" id="L502">                    rpat += 1L &lt;&lt; k;</span>
                }

<span class="fc" id="L505">                rpat &amp;= reg.node[i].state;</span>
                                
<span class="fc bfc" id="L507" title="All 2 branches covered.">                for (k = 63 - 1, lpat = 0; k &gt; pos; k--) {</span>
<span class="fc" id="L508">                    lpat += 1L &lt;&lt; k;</span>
                }

<span class="fc" id="L511">                lpat &amp;= reg.node[i].state;</span>

<span class="fc" id="L513">                out.node[j].state = ((lpat &gt;&gt; 1) | rpat);</span>
                
<span class="fc" id="L515">                out.node[j].amplitude.resetTo(reg.node[i].amplitude);</span>
<span class="fc" id="L516">                out.node[j].amplitude.times(1./Math.sqrt(d));</span>
                
<span class="fc" id="L518">                j++;</span>
            }
        }

<span class="fc" id="L522">        return out;</span>
    }

    /**
     * Compute the dot product of two quantum registers.
     * 
     * &lt;pre&gt;
     * |psi&gt; = summation over j of alpha*_j * |j&gt;
     * 
     * |phi&gt; = summation over j of beta*_j * |j&gt;
     * 
     * dot product
     * (psi|phi&gt; = summation over j of alpha*_j * beta_j
     * 
     * &lt;/pre&gt;
     *
     */
    ComplexModifiable quantum_dot_product(QuantumReg reg1, QuantumReg reg2) {
        
        int i, j;
<span class="nc" id="L542">        ComplexModifiable f = new ComplexModifiable(0, 0);</span>

        // Check whether quantum registers are sorted 
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (reg2.hashw &gt; 0) {</span>
<span class="nc" id="L546">            quantum_reconstruct_hash(reg2);</span>
        }
        
<span class="nc bnc" id="L549" title="All 2 branches missed.">        for (i = 0; i &lt; reg1.size; i++) {</span>
            
<span class="nc" id="L551">            j = quantum_get_state(reg1.node[i].state, reg2);</span>

            // state exists in reg2 
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (j &gt; -1) {</span>
<span class="nc" id="L555">                ComplexModifiable tmp2 = reg1.node[i].amplitude.copy();</span>
<span class="nc" id="L556">                tmp2.conjugate();</span>
<span class="nc" id="L557">                tmp2.times(reg2.node[j].amplitude);</span>
                
<span class="nc" id="L559">                f.plus(tmp2);</span>
            }
        }
<span class="nc" id="L562">        return f;</span>
    }

    /**
     * Same as above, but without complex conjugation
     */
    ComplexModifiable quantum_dot_product_noconj(QuantumReg reg1, QuantumReg reg2) {
  
        int i, j;
<span class="nc" id="L571">        ComplexModifiable f = new ComplexModifiable(0, 0);</span>

        // Check whether quantum registers are sorted 
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (reg2.hashw != 0) {</span>
<span class="nc" id="L575">            quantum_reconstruct_hash(reg2);</span>
        }

<span class="nc bnc" id="L578" title="All 2 branches missed.">        for (i = 0; i &lt; reg1.size; i++) {</span>
<span class="nc" id="L579">            j = quantum_get_state(reg1.node[i].state, reg2);</span>

            // state exists in reg2 
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (j &gt; -1) {</span>
<span class="nc" id="L583">                ComplexModifiable tmp2 = reg1.node[i].amplitude.copy();</span>
<span class="nc" id="L584">                tmp2.times(reg2.node[j].amplitude);</span>
<span class="nc" id="L585">                f.plus(tmp2);</span>
            }
        }
<span class="nc" id="L588">        return f;</span>
    }

    /**
     * Vector addition of two quantum registers. This is a purely mathematical
     * operation without any physical meaning, so only use it if you know what
     * you are doing.
     */
    QuantumReg quantum_vectoradd(QuantumReg reg1, QuantumReg reg2) {
  
        int i, j, k;
<span class="nc" id="L599">        int addsize = 0;</span>
<span class="nc" id="L600">        QuantumReg reg = new QuantumReg();</span>

<span class="nc" id="L602">        quantum_copy_qureg(reg1, reg);</span>

<span class="nc bnc" id="L604" title="All 4 branches missed.">        if ((reg1.hashw != 0) || (reg2.hashw != 0)) {</span>
<span class="nc" id="L605">            quantum_reconstruct_hash(reg1);</span>
<span class="nc" id="L606">            quantum_copy_qureg(reg1, reg);</span>

            // Calculate the number of additional basis states 
<span class="nc bnc" id="L609" title="All 2 branches missed.">            for (i = 0; i &lt; reg2.size; i++) {</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                if (quantum_get_state(reg2.node[i].state, reg1) == -1) {</span>
<span class="nc" id="L611">                    addsize++;</span>
                }
            }
        }

<span class="nc" id="L616">        reg.size += addsize;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (reg.node.length != reg.size) {</span>
<span class="nc" id="L618">            int len1 = reg.node.length;</span>
<span class="nc" id="L619">            reg.node = Arrays.copyOf(reg.node, reg.size);</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            for (i = len1; i &lt; reg.size; i++) {</span>
<span class="nc" id="L621">                reg.node[i] = new QuantumRegNode();</span>
<span class="nc" id="L622">                reg.node[i].state = 0;</span>
<span class="nc" id="L623">                reg.node[i].amplitude = new ComplexModifiable(0, 0);</span>
            }
        }
        
<span class="nc" id="L627">        k = reg1.size;</span>

<span class="nc bnc" id="L629" title="All 2 branches missed.">        for (i = 0; i &lt; reg2.size; i++) {</span>
<span class="nc" id="L630">            j = quantum_get_state(reg2.node[i].state, reg1);</span>

<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (j &gt;= 0) {</span>
<span class="nc" id="L633">                reg.node[j].amplitude.plus(reg2.node[i].amplitude);</span>
            } else {
<span class="nc" id="L635">                reg.node[k].state = reg2.node[i].state;</span>
<span class="nc" id="L636">                reg.node[k].amplitude.resetTo(reg2.node[i].amplitude);</span>
<span class="nc" id="L637">                k++;</span>
            }
        }

<span class="nc" id="L641">        return reg;</span>
    }

    /**
     * Same as above, but the result is stored in the first register
     */
    void quantum_vectoradd_inplace(QuantumReg reg1, QuantumReg reg2) {
  
        int i, j, k;
<span class="nc" id="L650">        int addsize = 0;</span>

<span class="nc bnc" id="L652" title="All 4 branches missed.">        if ((reg1.hashw != 0) || (reg2.hashw != 0)) {</span>
<span class="nc" id="L653">            quantum_reconstruct_hash(reg1);</span>

            // Calculate the number of additional basis states 
<span class="nc bnc" id="L656" title="All 2 branches missed.">            for (i = 0; i &lt; reg2.size; i++) {</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                if (quantum_get_state(reg2.node[i].state, reg1) == -1) {</span>
<span class="nc" id="L658">                    addsize++;</span>
                }
            }
        }
        // Allocate memory for basis states 

<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (reg1.node.length != (reg1.size + addsize)) {</span>
<span class="nc" id="L665">            int len1 = reg1.node.length;</span>
<span class="nc" id="L666">            reg1.node = Arrays.copyOf(reg1.node, reg1.size + addsize);</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            for (int ii = len1; ii &lt; (reg1.size + addsize); ii++) {</span>
<span class="nc" id="L668">                reg1.node[ii] = new QuantumRegNode();</span>
<span class="nc" id="L669">                reg1.node[ii].state = 0;</span>
<span class="nc" id="L670">                reg1.node[ii].amplitude = new ComplexModifiable(0, 0);</span>
            }
        }
        
        // Allocate the hash table 
<span class="nc" id="L675">        k = reg1.size;</span>

<span class="nc bnc" id="L677" title="All 2 branches missed.">        for (i = 0; i &lt; reg2.size; i++) {</span>
<span class="nc" id="L678">            j = quantum_get_state(reg2.node[i].state, reg1);</span>

<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (j &gt;= 0) {</span>
<span class="nc" id="L681">                reg1.node[j].amplitude.plus(reg2.node[i].amplitude);</span>
            } else {
<span class="nc" id="L683">                reg1.node[k].state = reg2.node[i].state;</span>
<span class="nc" id="L684">                reg1.node[k].amplitude.resetTo(reg2.node[i].amplitude);</span>
<span class="nc" id="L685">                k++;</span>
            }
        }
<span class="nc" id="L688">        reg1.size += addsize;</span>
<span class="nc" id="L689">    }</span>

    /**
     * Matrix-vector multiplication for a quantum register. A is a function
     * returning a quantum register containing the row given in the first
     * parameter. An additional parameter (e.g. time) may be supplied as well.
     */
    /*
    QuantumReg quantum_matrix_qureg(
        QuantumReg A (MAX_UNSIGNED, double), double t, QuantumReg reg) {
  
        MAX_UNSIGNED i;
        QuantumReg reg2 = new QuantumReg();
        QuantumReg tmp = new QuantumReg();

        reg2.width = reg.width;
        reg2.size = 1 &lt;&lt; reg2.width;
        reg2.hashw = 0;
        reg2.hash = null;

        reg2.node = calloc(reg2.size, sizeof(quantum_reg_node));
        if (!reg2.node) {
            quantum_error(QUANTUM_ENOMEM);
        }

        quantum_memman(reg2.size * sizeof(quantum_reg_node));

        for (i = 0; i &lt; (1 &lt;&lt; reg -&gt; width); i++) {
            reg2.node[i].state = i;
            tmp = A(i, t);
            reg2.node[i].amplitude = quantum_dot_product_noconj( &amp; tmp, reg);
            quantum_delete_qureg( &amp; tmp);
        }

        return reg2;

    }
    */
    
    /**
     * Scalar multiplication of a quantum register. This is a purely
     * mathematical operation without any physical meaning, so only use it if
     * you know what you are doing.
     */
    void quantum_scalar_qureg(ComplexModifiable r, QuantumReg reg) {
  
        int i;

<span class="nc bnc" id="L737" title="All 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="nc" id="L738">            reg.node[i].amplitude.times(r);</span>
        }
<span class="nc" id="L740">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
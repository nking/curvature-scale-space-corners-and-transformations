<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KMeansHSV.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry.clustering</a> &gt; <span class="el_source">KMeansHSV.java</span></div><h1>KMeansHSV.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry.clustering;

import algorithms.imageProcessing.GroupPixelRGB0;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.util.PairInt;
import algorithms.util.TrioInt;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 * k-means clustering is a method of cluster analysis to partition n
 * observations into k clusters in which each observation belongs to the cluster
 * with the nearest mean.
 * This results in a partitioning of the data space into Voronoi cells, which
 * for this single parameter analysis, is 1-D.
 * 
 * This version of k-means needs to be given seeds and hence k from those.
 * 
 * Useful reading:
 * http://en.wikipedia.org/wiki/K-means_clustering
 * and
 * &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
   by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Su Ìˆsstrunk,
   
 * @author nichole
 */
<span class="nc bnc" id="L33" title="All 2 branches missed.">public class KMeansHSV {</span>
    
<span class="nc" id="L35">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
           
    /**
     * this is k and is chosen by the user
     */
    protected final int nSeeds;
    
    protected final static int nMaxIter = 100;
<span class="nc" id="L43">    protected int nIter = 0;</span>
    protected final ImageExt img;
    
    // [nSeeds][h, s, v, x, y]
    protected final float[][] seeds;
    
    /**
     * note that an internal method binPoints makes an assumption that the
     * minimum values in an img pixel is 0 and a maximum is 255.
     * 
     * This class is experimental and specific to a use case of merging
     * segmented cells.
     * 
     * @param starterSeeds
     * @param starterSeedColors
     * @param img
     * 
     */
    public KMeansHSV(List&lt;PairInt&gt; starterSeeds,
<span class="nc" id="L62">        List&lt;GroupPixelRGB0&gt; starterSeedColors, ImageExt img) {</span>
        
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (starterSeeds.size() != starterSeedColors.size()) {</span>
<span class="nc" id="L65">            throw new IllegalArgumentException(&quot;starterSeeds and&quot;</span>
                + &quot; starterSeedColors must be same size&quot;);
        }
        
<span class="nc" id="L69">        this.nSeeds = starterSeeds.size();</span>
<span class="nc" id="L70">        this.nIter = 0;</span>
        
        // starter seeds, sorted by increasing value
        // [index][r,g,b, x, y]
<span class="nc" id="L74">        this.seeds = createStartSeeds(img, starterSeeds, starterSeedColors);</span>
        
<span class="nc" id="L76">        this.img = img;</span>
        
<span class="nc" id="L78">        System.out.println(&quot;k=&quot; + nSeeds);</span>
<span class="nc" id="L79">    }</span>
        
    /**
     *
     * @param unitSets sets to be merged using k-means.  note that
     * a set is never split into a smaller unit.
     */
    public TIntList computeMeans(List&lt;Set&lt;PairInt&gt;&gt; unitSets) {
    
        // x, y, n
<span class="nc" id="L89">        List&lt;TrioInt&gt; unitCentroids = new ArrayList&lt;TrioInt&gt;();</span>
        
        // r, g, b, n
<span class="nc" id="L92">        List&lt;GroupPixelRGB0&gt; unitClrs = new ArrayList&lt;GroupPixelRGB0&gt;();</span>
        
<span class="nc" id="L94">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="nc bnc" id="L96" title="All 2 branches missed.">        for (int i = 0; i &lt; unitSets.size(); ++i) {</span>
            
<span class="nc" id="L98">            Set&lt;PairInt&gt; set = unitSets.get(i);</span>
            
<span class="nc" id="L100">            GroupPixelRGB0 clr = new GroupPixelRGB0();</span>
<span class="nc" id="L101">            clr.calculateColors(set, img, 0, 0);</span>
<span class="nc" id="L102">            unitClrs.add(clr);</span>
        
<span class="nc" id="L104">            double[] xyCen = curveHelper.calculateXYCentroids(set);</span>
            
<span class="nc" id="L106">            unitCentroids.add(new TrioInt((int)Math.round(xyCen[0]),</span>
<span class="nc" id="L107">                (int)Math.round(xyCen[1]), set.size()));</span>
        }
        
<span class="nc" id="L110">        boolean hasConverged = false;</span>
            
        //TODO: have changed maxError to exit at nIter=0
        //   while testing...
<span class="nc" id="L114">        float normXY = img.getNPixels()/nSeeds;</span>
<span class="nc" id="L115">        double maxError //= 0.01 * Math.sqrt(this.nSeeds * (3. + normXY));</span>
<span class="nc" id="L116">            = 1.42 * Math.sqrt(this.nSeeds * (3. + normXY));</span>
        
<span class="nc" id="L118">        TIntList unitLabels = null;</span>
        
<span class="nc bnc" id="L120" title="All 4 branches missed.">        while (!hasConverged &amp;&amp; (nIter &lt; nMaxIter)) {</span>
            
<span class="nc" id="L122">            unitLabels = binUnitSets(unitSets, unitClrs, unitCentroids);</span>
            
<span class="nc" id="L124">            double l2Norm = calculateMeanOfSeedPoints(unitSets, unitClrs, </span>
                unitCentroids, unitLabels);

<span class="nc" id="L127">            System.out.println(&quot;nIter=&quot; + nIter + &quot; l2Norm=&quot; </span>
                + l2Norm + &quot; maxError=&quot; + maxError);
            
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (l2Norm == Double.POSITIVE_INFINITY) {</span>
<span class="nc" id="L131">                break;</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            } else if (l2Norm &lt; maxError) {</span>
<span class="nc" id="L133">                break;</span>
            }
            
<span class="nc" id="L136">            nIter++;</span>
<span class="nc" id="L137">        }</span>
        
<span class="nc" id="L139">        return unitLabels;</span>
    }
    
    /**
     * calculate the mean value of all points within a seed bin and return them
     *   as new seed bin centers.  note that if there is a bin without points
     *   in it, null is returned.
     *
     */
    private double calculateMeanOfSeedPoints(List&lt;Set&lt;PairInt&gt;&gt; unitSets, 
        List&lt;GroupPixelRGB0&gt; unitClrs, List&lt;TrioInt&gt; unitCentroids,
        TIntList unitLabels) {

<span class="nc" id="L152">        int[][] sum = new int[nSeeds][5];</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L154">            sum[i] = new int[5];</span>
        }
<span class="nc" id="L156">        int[] count = new int[nSeeds];</span>
        
<span class="nc" id="L158">        float[] hsv = new float[3];</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">        for (int i = 0; i &lt; unitSets.size(); i++) {</span>

            /*
            GroupPixelRGB0 clr = unitClrs.get(i);
            Color.RGBtoHSB(Math.round(clr.getAvgRed()), 
                Math.round(clr.getAvgGreen()), 
                Math.round(clr.getAvgBlue()), hsv);
            
            TrioInt xy = unitCentroids.get(i);
            int seedIdx = unitLabels.get(i);

            sum[seedIdx][0] += (xy.getZ() * hsv[0]);
            sum[seedIdx][1] += (xy.getZ() * hsv[1]);
            sum[seedIdx][2] += (xy.getZ() * hsv[2]);
            sum[seedIdx][3] += (xy.getZ() * xy.getX());
            sum[seedIdx][4] += (xy.getZ() * xy.getY());
        
            count[seedIdx] += xy.getZ();
            */
            
<span class="nc" id="L180">            int seedIdx = unitLabels.get(i);</span>
            
<span class="nc bnc" id="L182" title="All 2 branches missed.">            for (PairInt p : unitSets.get(i)) {</span>
<span class="nc" id="L183">                int r = img.getR(p);</span>
<span class="nc" id="L184">                int g = img.getG(p);</span>
<span class="nc" id="L185">                int b = img.getB(p);</span>
<span class="nc" id="L186">                Color.RGBtoHSB(r, g, b, hsv);</span>
<span class="nc" id="L187">                sum[seedIdx][0] += hsv[0];</span>
<span class="nc" id="L188">                sum[seedIdx][1] += hsv[1];</span>
<span class="nc" id="L189">                sum[seedIdx][2] += hsv[2];</span>
<span class="nc" id="L190">                sum[seedIdx][3] += p.getX();</span>
<span class="nc" id="L191">                sum[seedIdx][4] += p.getY();</span>
<span class="nc" id="L192">            }</span>
            
<span class="nc" id="L194">            count[seedIdx] += unitSets.get(i).size();</span>
        }
        
<span class="nc" id="L197">        double l2Norm = 0;</span>
        
        // TODO: adding experimental logic here to stop the merging when
        // a cluster count == 0.
        // the invoker must recognize return value as specific to end of merging.
        
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (int i = 0; i &lt; nSeeds; i++) {</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            for (int j = 0; j &lt; 5; ++j) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (count[i] == 0) {</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">                    assert(sum[i][j] == 0);</span>
<span class="nc" id="L207">                    return Double.POSITIVE_INFINITY;</span>
                } else {
<span class="nc" id="L209">                    sum[i][j] /= count[i];</span>
                }
<span class="nc" id="L211">                double diff = seeds[i][j] - sum[i][j];</span>
<span class="nc" id="L212">                l2Norm += (diff * diff);</span>
<span class="nc" id="L213">                seeds[i][j] = sum[i][j];</span>
            }
        }
        
<span class="nc" id="L217">        return Math.sqrt(l2Norm);</span>
    }
    
    protected TIntList binUnitSets(List&lt;Set&lt;PairInt&gt;&gt; unitSets,
        List&lt;GroupPixelRGB0&gt; unitColors, List&lt;TrioInt&gt; unitCentroids) {
        
<span class="nc" id="L223">        TIntList unitLabels = new TIntArrayList();</span>
        
<span class="nc bnc" id="L225" title="All 2 branches missed.">        for (int i = 0; i &lt; unitSets.size(); ++i) {</span>
            
<span class="nc" id="L227">            Set&lt;PairInt&gt; set = unitSets.get(i);</span>
            
<span class="nc" id="L229">            GroupPixelRGB0 clrs = unitColors.get(i);</span>
            
<span class="nc" id="L231">            int seedIdx = findNearestNeighbor(clrs, unitCentroids.get(i));</span>
            
<span class="nc" id="L233">            unitLabels.add(seedIdx);</span>
        }

<span class="nc" id="L236">        return unitLabels;</span>
    }
 
    private int findNearestNeighbor(GroupPixelRGB0 unitColors, 
        TrioInt unitCentroid) {
        
        /*
        [nSeeds][h, s, v, x, y]
        float[][] seeds;
        */
        
<span class="nc" id="L247">        float[] hsv = new float[3];</span>
<span class="nc" id="L248">        Color.RGBtoHSB(Math.round(unitColors.getAvgRed()), </span>
<span class="nc" id="L249">            Math.round(unitColors.getAvgGreen()), </span>
<span class="nc" id="L250">            Math.round(unitColors.getAvgBlue()), hsv);</span>
        
<span class="nc" id="L252">        int x = unitCentroid.getX();</span>
<span class="nc" id="L253">        int y = unitCentroid.getY();</span>
        
<span class="nc" id="L255">        double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L256">        int minDistIdx = -1;</span>
        
        // TODO: need normalization for 
        // diffX * diffX + diffY * diffY.
        // slic super pixels uses the super pixel area s X s.
        // will use average as area/k
<span class="nc" id="L262">        float norm = img.getNPixels()/nSeeds;</span>
        
<span class="nc bnc" id="L264" title="All 2 branches missed.">        for (int i = 0; i &lt; seeds.length; ++i) {            </span>
<span class="nc" id="L265">            float diffH = seeds[i][0] - hsv[0];</span>
<span class="nc" id="L266">            float diffS = seeds[i][1] - hsv[1];</span>
<span class="nc" id="L267">            float diffV = seeds[i][2] - hsv[2];</span>
<span class="nc" id="L268">            float diffX = seeds[i][3] - x;</span>
<span class="nc" id="L269">            float diffY = seeds[i][4] - y;</span>
            
<span class="nc" id="L271">            double distSq = </span>
                diffH * diffH + diffS * diffS + diffV * diffV +
                ((diffX * diffX + diffY * diffY)/(norm*norm));
            
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L276">                minDistSq = distSq;</span>
<span class="nc" id="L277">                minDistIdx = i;</span>
            }
        }
        
<span class="nc" id="L281">        return minDistIdx;</span>
    }

    /**
     [nSeeds][h, s, v, x, y]
     int[][] seeds;
    
     * @param img
     * @param starterSeeds
     * @param starterSeedColors
     * @return 
     */
    private float[][] createStartSeeds(ImageExt img, List&lt;PairInt&gt; starterSeeds, 
        List&lt;GroupPixelRGB0&gt; starterSeedColors) {
        
<span class="nc" id="L296">        int k = starterSeeds.size();</span>
        
<span class="nc" id="L298">        float[] hsv = new float[3];</span>
        
<span class="nc" id="L300">        float[][] s = new float[k][];</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        for (int i = 0; i &lt; k; ++i) {</span>
<span class="nc" id="L302">            GroupPixelRGB0 rgb = starterSeedColors.get(i);</span>
<span class="nc" id="L303">            PairInt xy = starterSeeds.get(i);</span>
            
<span class="nc" id="L305">            Color.RGBtoHSB((int)Math.round(rgb.getAvgRed()), </span>
<span class="nc" id="L306">                (int)Math.round(rgb.getAvgGreen()), </span>
<span class="nc" id="L307">                (int)Math.round(rgb.getAvgBlue()), hsv);</span>
            
<span class="nc" id="L309">            s[i] = new float[5];</span>
<span class="nc" id="L310">            s[i][0] = hsv[0];</span>
<span class="nc" id="L311">            s[i][1] = hsv[1];</span>
<span class="nc" id="L312">            s[i][2] = hsv[2];</span>
<span class="nc" id="L313">            s[i][3] = xy.getX();</span>
<span class="nc" id="L314">            s[i][4] = xy.getY();</span>
        }
        
<span class="nc" id="L317">        return s;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
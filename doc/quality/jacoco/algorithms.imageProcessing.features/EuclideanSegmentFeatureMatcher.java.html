<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EuclideanSegmentFeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">EuclideanSegmentFeatureMatcher.java</span></div><h1>EuclideanSegmentFeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.compGeometry.HoughTransform;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.SegmentationType;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.util.MiscStats;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 class whose goal is to find best single euclidean transformation for 
 image1 to image2.  It uses segmentation to create blobs.
 It solves for transformation of each blob in one image against the other.
 It keeps the best transformation solution of each blob in image1.
 Then evaluates all blob1 best transformations to find the best overall
 for the image corners.
 -- pros: for panorama and stereo images it does lead to a solution and it
          solves for rotation too.
 -- cons: has long runtime due to curve to curve transformation comparisons.
          also, it sometimes discards very good matching points
          because the curve needs at least 3 in order to
          estimate a euclidean transformation so any curves w/ fewer than 
          2 points are skipped.
 
 Prefer to use EuclideanSegmentFeatureMatcher2 which is faster, excepting
 for images like the checkerboard tests.  The checkerboard tests do not
 have unique features so a solution is better found by 
 EuclideanSegmentFeatureMatcher which tries many combinations from detailed
 to larger level groupings.
 
 * @author nichole
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public class EuclideanSegmentFeatureMatcher extends AbstractFeatureMatcher { </span>

<span class="fc" id="L40">    protected TransformationParameters solutionTransformation = null;</span>
    
    public EuclideanSegmentFeatureMatcher(ImageExt image1, ImageExt image2,
        FeatureMatcherSettings settings) {
        
<span class="fc" id="L45">        super(image1, image2, settings);</span>
<span class="fc" id="L46">    }</span>
    
    @Override
    protected void prepareCorners(SegmentationType type, boolean useBinned) 
        throws IOException, NoSuchAlgorithmException {
        
        // overriding to add logic for settings for 2nd deriv points
        
<span class="fc" id="L54">        super.prepareCorners(type, useBinned);</span>
        
<span class="pc bpc" id="L56" title="3 of 4 branches missed.">        if (settings.doUse2ndDerivCorners() &amp;&amp; type.equals(SegmentationType.NONE)) {</span>
            
            // create blobs, and associate 2nd deriv pts with the blobs.
            // Note that this is repeating some work.
            // these feature matchers will be refactored soon.
            
<span class="nc" id="L62">            SegmentationType type2 = SegmentationType.GREYSCALE_WAVELET;</span>

<span class="nc" id="L64">            img1Helper.applySegmentation(type2, useBinned);</span>
<span class="nc" id="L65">            img2Helper.applySegmentation(type2, useBinned);</span>

<span class="nc" id="L67">            img1Helper.extractSecondDerivativeCorners(type2, useBinned);</span>
<span class="nc" id="L68">            img2Helper.extractSecondDerivativeCorners(type2, useBinned);</span>
        }
        
<span class="fc" id="L71">    }</span>

    @Override
    protected boolean match(SegmentationType type, boolean useBinned) {
        
<span class="pc bpc" id="L76" title="3 of 4 branches missed.">        if (settings.doUse2ndDerivCorners() &amp;&amp; type.equals(SegmentationType.NONE)) {</span>
            // for 2nd pt derivs, need to override the type to wavelet.
            // this should be handled better after refacoring.
<span class="nc" id="L79">            type = SegmentationType.GREYSCALE_WAVELET;</span>
        }
        
        int binFactor1, binFactor2;
        GreyscaleImage img1, img2;
        IntensityFeatures f1, f2;
        
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (useBinned) {</span>
<span class="fc" id="L87">            binFactor1 = img1Helper.getBinFactor(useBinned);</span>
<span class="fc" id="L88">            binFactor2 = img2Helper.getBinFactor(useBinned);</span>
<span class="fc" id="L89">            img1 = img1Helper.getGreyscaleImageBinned();</span>
<span class="fc" id="L90">            img2 = img2Helper.getGreyscaleImageBinned();</span>
<span class="fc" id="L91">            f1 = featuresBinned1;</span>
<span class="fc" id="L92">            f2 = featuresBinned2;</span>
        } else {
<span class="fc" id="L94">            binFactor1 = 1;</span>
<span class="fc" id="L95">            binFactor2 = 1;</span>
<span class="fc" id="L96">            img1 = img1Helper.getGreyscaleImage();</span>
<span class="fc" id="L97">            img2 = img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L98">            f1 = features1;</span>
<span class="fc" id="L99">            f2 = features2;</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">            if (!f1.gradientWasCreated()) {</span>
<span class="nc" id="L101">                f1.calculateGradientWithGreyscale(</span>
<span class="nc" id="L102">                    img1Helper.getGreyscaleImage().copyImage());</span>
            }
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">            if (!f2.gradientWasCreated()) {</span>
<span class="nc" id="L105">                f2.calculateGradientWithGreyscale(</span>
<span class="nc" id="L106">                    img2Helper.getGreyscaleImage().copyImage());</span>
            }
        }
        
        int dither2;
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (settings.doUse2ndDerivCorners()) {</span>
<span class="nc" id="L112">            dither2 = 1;</span>
        } else {
<span class="fc" id="L114">            dither2 = DitherDefault.dither;</span>
        }

        //long t0 = System.currentTimeMillis();
        
<span class="fc" id="L119">        BlobCornersEuclideanCalculator bsFinder = new BlobCornersEuclideanCalculator();</span>

        // the solution for the binFactor modified images:
<span class="fc" id="L122">        MatchingSolution soln = bsFinder.solveTransformation(img1Helper, f1,</span>
            type, useBinned, img2Helper, f2, type, useBinned, dither2);

        //int n1 = img1Helper.sumPointsOfInterest(type, useBinned);
        //int n2 = img2Helper.sumPointsOfInterest(type, useBinned);
        // long t1 = System.currentTimeMillis();
        //long t1Sec = (t1 - t0)/1000;
        //Logger.getLogger(this.getClass().getName()).info(&quot;matching(sec)=&quot; + t1Sec);
              
<span class="pc bpc" id="L131" title="2 of 4 branches missed.">        if (soln == null || soln.getComparisonStats() == null || </span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">            soln.getComparisonStats().isEmpty()) {</span>
<span class="nc" id="L133">            return false;</span>
        }
        
        // transform images to full size
<span class="fc" id="L137">        soln = transformSolutionToFullFrames(soln, img1Helper, img2Helper, </span>
            binFactor1, binFactor2);

<span class="pc bpc" id="L140" title="1 of 4 branches missed.">        if (soln == null || soln.getComparisonStats() == null || </span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            soln.getComparisonStats().isEmpty()) {</span>
<span class="fc" id="L142">            return false;</span>
        }
            
<span class="fc" id="L145">        TransformationParameters params = soln.getParams();</span>
                
<span class="pc bpc" id="L147" title="3 of 4 branches missed.">        assert(params.getStandardDeviations() != null);</span>

<span class="fc" id="L149">        log.info(&quot;params for type&quot;</span>
<span class="fc" id="L150">            + &quot; (&quot; + type.name() + &quot;, binned=&quot; + useBinned + &quot;)&quot;</span>
<span class="fc" id="L151">            + &quot; (&quot; + type.name() + &quot;, binned=&quot; + useBinned + &quot;)&quot;</span>
<span class="fc" id="L152">            + &quot; : &quot; + params.toString());</span>

<span class="fc" id="L154">        log.info(String.format(</span>
            &quot;stDev scale=%.1f  stDev rot=%.0f  stDev tX=%.0f  stDev tY=%.0f&quot;,
<span class="fc" id="L156">            params.getStandardDeviations()[0], </span>
<span class="fc" id="L157">            params.getStandardDeviations()[1],</span>
<span class="fc" id="L158">            params.getStandardDeviations()[2], </span>
<span class="fc" id="L159">            params.getStandardDeviations()[3]));</span>
       
<span class="fc" id="L161">        List&lt;FeatureComparisonStat&gt; solnStats = soln.getComparisonStats();</span>
        
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (type.equals(SegmentationType.GREYSCALE_CANNY)) {</span>
            //extractMoreCorners uses canny, so exit here
<span class="nc" id="L165">            copyToInstanceVars(solnStats);</span>
            
<span class="nc" id="L167">            solutionTransformation = soln.getParams().copy();</span>
                
<span class="nc" id="L169">            return true;</span>
        }
        
        // look at intersection of solution to see if need more corners

        int tolXY;
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (params.getStandardDeviations() != null) {</span>
<span class="fc" id="L176">            tolXY = Math.round(Math.max(params.getStandardDeviations()[2],</span>
<span class="fc" id="L177">                params.getStandardDeviations()[3]));</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            if (tolXY &lt; 3) {</span>
<span class="nc" id="L179">                tolXY = 3;</span>
            }
        } else {
<span class="nc" id="L182">            tolXY = 10;</span>
        }

<span class="fc" id="L185">        int nLimit = 16;</span>
        
<span class="fc" id="L187">        boolean covers = MiscStats.statsCoverIntersection(solnStats, params,</span>
<span class="fc" id="L188">            img1.getWidth(), img1.getHeight(), img2.getWidth(), img2.getHeight()</span>
        );
        
<span class="pc bpc" id="L191" title="2 of 4 branches missed.">        boolean extractMoreCorners = (solnStats.size() &lt; nLimit) || !covers;</span>
        
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (!extractMoreCorners) {</span>

<span class="nc" id="L195">            copyToInstanceVars(solnStats);</span>
            
<span class="nc" id="L197">            solutionTransformation = soln.getParams().copy();</span>
                
<span class="nc" id="L199">            return true;</span>
        }
            
<span class="fc" id="L202">        Set&lt;CornerRegion&gt; cr1 = new HashSet&lt;CornerRegion&gt;(); </span>
<span class="fc" id="L203">        Set&lt;CornerRegion&gt; cr2 = new HashSet&lt;CornerRegion&gt;(); </span>
<span class="fc" id="L204">        extractCannyCornerRegions(img1, img2, cr1, cr2);</span>

<span class="fc" id="L206">        float scaleTol = 0.2f;</span>
<span class="fc" id="L207">        float rotationInRadiansTol = (float)(20. * Math.PI/180.);</span>
<span class="fc" id="L208">        List&lt;FeatureComparisonStat&gt; extraStats = findCorrespondence(img1, img2, </span>
<span class="fc" id="L209">            cr1, cr2, params, f1.getRotatedOffsets(), dither2, tolXY, scaleTol, </span>
            rotationInRadiansTol);
        
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (extraStats == null) {</span>
            
<span class="fc" id="L214">            log.severe(&quot;error finding more points to add to solution&quot;);</span>
            
<span class="fc" id="L216">            copyToInstanceVars(solnStats);</span>
            
<span class="fc" id="L218">            solutionTransformation = soln.getParams().copy();</span>
                
<span class="fc" id="L220">            return true;</span>
        }
        
<span class="fc" id="L223">        solnStats.addAll(extraStats);</span>
        
<span class="fc" id="L225">        MiscStats.filterForDegeneracy(solnStats);</span>
                    
<span class="fc" id="L227">        copyToInstanceVars(solnStats);</span>
            
<span class="fc" id="L229">        solutionTransformation = soln.getParams().copy();</span>
        
<span class="fc" id="L231">        return true;</span>
    }
    
    public TransformationParameters getSolutionTransformation() {
<span class="fc" id="L235">        return solutionTransformation;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
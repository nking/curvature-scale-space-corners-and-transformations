<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObjectMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">ObjectMatcher.java</span></div><h1>ObjectMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.QuickSort;
import algorithms.compGeometry.PerimeterFinder2;
import algorithms.imageProcessing.ColorHistogram;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.Image;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.ImageIOHelper;
import algorithms.imageProcessing.ImageProcessor;
import algorithms.imageProcessing.TrimmedImage;
import algorithms.imageProcessing.features.mser.Canonicalizer;
import algorithms.imageProcessing.features.mser.Canonicalizer.RegionPoints;
import algorithms.imageProcessing.features.mser.MSER;
import algorithms.imageProcessing.features.mser.MSER.Threshold;
import algorithms.imageProcessing.features.mser.Region;
import algorithms.imageProcessing.matching.CMODE;
import algorithms.imageProcessing.matching.MSERMatcher;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairInt;
import algorithms.util.PixelHelper;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.TLongSet;
import gnu.trove.set.hash.TIntHashSet;
import gnu.trove.set.hash.TLongHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * a class that finds a template object in another image where the
 * object may have changed poses, may have different lighting, or
 * may have different foreground or background.
 *
 * NOTE that future options might include ability to choose between
 * 3 or more different light sources and the ability to use an
 * articulated search for small object matches.
 *
 * @author nichole
 */
<span class="fc" id="L52">public class ObjectMatcher {</span>

<span class="fc" id="L54">    private boolean debug = false;</span>

    public void setToDebug() {
<span class="nc" id="L57">        debug = true;</span>
<span class="nc" id="L58">    }</span>

    /***
     * 
     * @param img0
     * @param shape0
     * @param img1
     * @param settings for the method
     * @return
     */
    public List&lt;CorrespondenceList&gt; findObject12(ImageExt img0, 
        Set&lt;PairInt&gt; shape0, ImageExt img1, Settings settings) {

<span class="fc" id="L71">        long ts = 0;</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L73">            ts = MiscDebug.getCurrentTimeFormatted();</span>
        }

<span class="fc" id="L76">        TrimmedImage img0Trim = trim(img0, shape0, 20);</span>

<span class="fc" id="L78">        Set&lt;PairInt&gt; shape0Trimmed = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (PairInt p : shape0) {</span>
<span class="fc" id="L80">            PairInt p2 = new PairInt(p.getX() - img0Trim.getXOffset(),p.getY() - img0Trim.getYOffset());</span>
<span class="fc" id="L81">            shape0Trimmed.add(p2);</span>
<span class="fc" id="L82">        }</span>

<span class="fc" id="L84">        ImageExt img0Trimmed = (ImageExt)img0Trim.getTrimmed();</span>

<span class="fc" id="L86">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="fc" id="L88">        mask(img0Trimmed, shape0Trimmed);</span>
<span class="fc" id="L89">        CMODE clrMode = CMODE.determineColorMode(img0Trimmed, shape0Trimmed);</span>
        
        /*
        convert the image to cie luv and then calculate polar angle of u and v
        around 0 in degrees (a.k.a. the &quot;H&quot; of LCH color space, but with
        the 1976 CIE LAB which is LUV).
        If maxV of 360, returns full value image,
        */
        //System.out.println(&quot;template clrMode=&quot; + clrMode.name());
        GreyscaleImage luvTheta0;
        GreyscaleImage luvTheta1;
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (clrMode.equals(CMODE.WHITE)) {</span>
<span class="fc" id="L101">            luvTheta0 = imageProcessor.createCIELUVTheta_WideRangeLightness(img0Trimmed, 255);</span>
<span class="fc" id="L102">            luvTheta1 = imageProcessor.createCIELUVTheta_WideRangeLightness(img1, 255);</span>
        } else {
<span class="fc" id="L104">            luvTheta0 = imageProcessor.createCIELUVTheta(img0Trimmed, 255);</span>
<span class="fc" id="L105">            luvTheta1 = imageProcessor.createCIELUVTheta(img1, 255);</span>
        }
        
<span class="fc" id="L108">        imageProcessor.singlePixelFilter(luvTheta0);</span>
<span class="fc" id="L109">        imageProcessor.singlePixelFilter(luvTheta1);</span>

<span class="fc" id="L111">        mask(luvTheta0, shape0Trimmed);</span>
<span class="fc" id="L112">        CMODE ptMode = CMODE.determinePolarThetaMode(luvTheta0, shape0Trimmed);</span>
        
        // ----- create the cRegions for a masked image pyramid of img 0 ====
        
<span class="fc" id="L116">        GreyscaleImage gsImg0 = img0Trimmed.copyToGreyscale2();</span>
<span class="fc" id="L117">        GreyscaleImage gsImg1 = img1.copyToGreyscale2();</span>
        
<span class="fc" id="L119">        boolean fewerMSER = false;//true;</span>
       
<span class="fc" id="L121">        GreyscaleImage tmp00 = gsImg0.copyImage();</span>
<span class="fc" id="L122">        imageProcessor.enhanceContrast(tmp00, 4);</span>
<span class="fc" id="L123">        GreyscaleImage tmp01 = luvTheta0.copyImage();</span>
<span class="fc" id="L124">        imageProcessor.enhanceContrast(tmp01, 4);</span>
        
        // build combined list of regions
<span class="fc" id="L127">        List&lt;Region&gt; regionsComb0 = createCombinedMSERRegions(</span>
            tmp00, tmp01,
            //gsImg0, luvTheta0, 
            clrMode, ptMode,
<span class="fc" id="L131">            Threshold.LESS_SENSITIVE, Threshold.LESS_SENSITIVE, settings.getDebugLabel() + &quot;_0_&quot;);</span>

<span class="fc" id="L133">        int[] xy = new int[2];</span>
        //remove all regions with centers outside of shape0 points
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int i = (regionsComb0.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L136">            Region r = regionsComb0.get(i);</span>
<span class="fc" id="L137">            r.calculateXYCentroid(xy, img0Trimmed.getWidth(), img0Trimmed.getHeight());</span>
<span class="fc" id="L138">            PairInt p = new PairInt(xy[0], xy[1]);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (!shape0Trimmed.contains(p)) {</span>
<span class="nc" id="L140">                regionsComb0.remove(i);</span>
            }
        }

<span class="fc" id="L144">        fewerMSER = true;</span>
        
<span class="fc" id="L146">        GreyscaleImage tmp10 = gsImg1.copyImage();</span>
<span class="fc" id="L147">        imageProcessor.enhanceContrast(tmp10, 4);</span>
<span class="fc" id="L148">        GreyscaleImage tmp11 = luvTheta1.copyImage();</span>
<span class="fc" id="L149">        imageProcessor.enhanceContrast(tmp11, 4);</span>
        
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (debug) {            </span>
            //MiscDebug.writeImage(img0Trimmed, &quot;_shape0_mask_&quot;);
<span class="nc" id="L153">            MiscDebug.writeImage(luvTheta0, &quot;_luv_mask_&quot; + ts);</span>
<span class="nc" id="L154">            MiscDebug.writeImage(luvTheta1, &quot;_luv_srch_&quot; + ts);</span>
            
            //MiscDebug.writeImage(tmp00, &quot;_gs_enhanced_0_&quot;);
            //MiscDebug.writeImage(tmp01, &quot;_luv_enhanced_0_&quot;);
<span class="nc" id="L158">            MiscDebug.writeImage(tmp10, &quot;_gs_enhanced_1_&quot;);</span>
            //MiscDebug.writeImage(tmp11, &quot;_luv_enhanced_1_&quot;);
        }

<span class="fc" id="L162">        CMODE clrMode1 = CMODE.determineColorMode(img1);</span>
<span class="fc" id="L163">        CMODE ptMode1 = CMODE.determinePolarThetaMode(luvTheta1);</span>
        
<span class="fc" id="L165">        List&lt;Region&gt; regionsComb1 = createCombinedMSERRegions(</span>
            tmp10, tmp11,
            //gsImg1, luvTheta1,
            //CMODE.determineColorMode(img1),
            //CMODE.determinePolarThetaMode(luvTheta1),
            clrMode, ptMode,
            Threshold.DEFAULT, Threshold.LESS_SENSITIVE,
<span class="fc" id="L172">            settings.getDebugLabel() + &quot;_1_&quot;);</span>
                
<span class="fc" id="L174">        int critSep = 1;//5;</span>
<span class="fc" id="L175">        Canonicalizer.filterBySpatialProximity(critSep, regionsComb0, </span>
<span class="fc" id="L176">            img0Trimmed.getWidth(), img0Trimmed.getHeight());</span>
        
<span class="fc" id="L178">        Canonicalizer.filterBySpatialProximity(critSep, regionsComb1, </span>
<span class="fc" id="L179">            img1.getWidth(), img1.getHeight());</span>
        
<span class="fc" id="L181">        Canonicalizer canonicalizer = new Canonicalizer();</span>

        // ----- create the cRegions for a masked image pyramid of img 0 ====

        //TODO: add filter here for patterns in the MSER regions that
        // are strong, and if present in reference frame1, then
        // anything without it mughr be removable.
        // use of this feature should be a Setting option.

        /*
        if (debug) {
            int[] xyCen = new int[2];
            Image im0Cp, im1Cp;
            im0Cp = img0Trimmed.copyImage();
            int n9 = regionsComb0.size();
            for (int i = 0; i &lt; n9; ++i) {
                Region r = regionsComb0.get(i);
                int[] clr = ImageIOHelper.getNextRGB(i);
                r.drawEllipse(im0Cp, 0, clr[0], clr[1], clr[2]);
                r.calculateXYCentroid(xyCen, im0Cp.getWidth(), im0Cp.getHeight());
                ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], im0Cp,
                    1, 255, 0, 0);
            }
            MiscDebug.writeImage(im0Cp, &quot;_&quot; + settings.getDebugLabel() + 
                &quot;___regions_0_&quot;);

            im1Cp = img1.copyImage();
            n9 = regionsComb1.size();
            for (int i = 0; i &lt; n9; ++i) {
                Region r = regionsComb1.get(i);
                int[] clr = ImageIOHelper.getNextRGB(i);
                r.drawEllipse(im1Cp, 0, clr[0], clr[1], clr[2]);
                r.calculateXYCentroid(xyCen, im1Cp.getWidth(), im1Cp.getHeight());
                ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], im1Cp,
                    1, 255, 0, 0);
            //    System.out.println(&quot;regIdx1=&quot; + i + &quot; x=&quot;+xyCen[0] + &quot; y=&quot; + xyCen[1]);
            }
            MiscDebug.writeImage(im1Cp, &quot;_&quot; + settings.getDebugLabel() 
                + &quot;___regions_1_&quot;);
        }
        */
        
<span class="fc" id="L223">        TIntObjectMap&lt;RegionPoints&gt; regionPoints0 =</span>
<span class="fc" id="L224">            canonicalizer.canonicalizeRegions2(regionsComb0, </span>
<span class="fc" id="L225">            img0Trimmed.getWidth(), img0Trimmed.getHeight());</span>
   
<span class="fc" id="L227">        TIntObjectMap&lt;RegionPoints&gt; regionPoints1 =</span>
<span class="fc" id="L228">            canonicalizer.canonicalizeRegions2(regionsComb1, img1.getWidth(),</span>
<span class="fc" id="L229">            img1.getHeight());</span>
  
        // filter by color hist of hsv, cielab and CIECH
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (settings.useColorFilter()) {</span>
<span class="fc" id="L233">            filterByColorHistograms(img0Trimmed, shape0Trimmed, img1, </span>
                regionPoints1);
        }
        
        //NOTE: not sure this is the best approach, but wanting to keep the 
        //   template shapes as 1 full shape and then the 2 largest 
        //   parts of it to allow a finer fragmented search.
<span class="fc" id="L240">        filterToLargestPartitions(regionPoints0, img0Trimmed, shape0Trimmed);</span>
        
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L243">            int[] xyCen = new int[2];</span>
            Image im0Cp, im1Cp;
<span class="nc" id="L245">            im0Cp = img0Trimmed.copyImage();</span>
<span class="nc" id="L246">            TIntObjectIterator&lt;RegionPoints&gt; iter = regionPoints0.iterator();</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            for (int i = 0; i &lt; regionPoints0.size(); ++i) {</span>
<span class="nc" id="L248">                iter.advance();</span>
<span class="nc" id="L249">                int rIdx = iter.key();</span>
<span class="nc" id="L250">                Region r = regionsComb0.get(rIdx);</span>
<span class="nc" id="L251">                int[] clr = ImageIOHelper.getNextRGB(i);</span>
<span class="nc" id="L252">                r.drawEllipse(im0Cp, 0, clr[0], clr[1], clr[2]);</span>
<span class="nc" id="L253">                r.calculateXYCentroid(xyCen, im0Cp.getWidth(), im0Cp.getHeight());</span>
<span class="nc" id="L254">                ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], im0Cp,</span>
                    1, 255, 0, 0);
            }
<span class="nc" id="L257">            MiscDebug.writeImage(im0Cp, &quot;_&quot; + settings.getDebugLabel() + </span>
                &quot;_regions_0_filterP_&quot;);
        }
        
        /*
        NOTE: tried 2 changes in the region points to see if they improved the
        results.
        (1) modified the ellipse boundaries inward to the nearest bounding edges
            of the accumulated points.
        (2) used just the accumulated points instead of the ellipse filled points.
        */
        
<span class="fc" id="L269">        replaceWithAccumulatedPoints(regionPoints1);</span>
        
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L272">            int[] xyCen = new int[2];</span>
<span class="nc" id="L273">            Image im1Cp = img1.copyImage();</span>
<span class="nc" id="L274">            TIntObjectIterator&lt;RegionPoints&gt; iter = regionPoints1.iterator();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            for (int i = 0; i &lt; regionPoints1.size(); ++i) {</span>
<span class="nc" id="L276">                iter.advance();</span>
<span class="nc" id="L277">                int rIdx = iter.key();</span>
<span class="nc" id="L278">                Region r = regionsComb1.get(rIdx);</span>
<span class="nc" id="L279">                int[] clr = ImageIOHelper.getNextRGB(i);</span>
<span class="nc" id="L280">                r.drawEllipse(im1Cp, 0, clr[0], clr[1], clr[2]);</span>
<span class="nc" id="L281">                r.calculateXYCentroid(xyCen, im1Cp.getWidth(), im1Cp.getHeight());</span>
<span class="nc" id="L282">                ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], im1Cp,</span>
                    1, 255, 0, 0);
            }
<span class="nc" id="L285">            MiscDebug.writeImage(im1Cp, &quot;_&quot; + settings.getDebugLabel() </span>
                + &quot;_regions_1_filtered_&quot;);
            
            /*
            iter = regionPoints1.iterator();
            for (int i = 0; i &lt; regionPoints1.size(); ++i) {
                iter.advance();
                int rIdx = iter.key();
                RegionPoints rp = iter.value();
                Region r = regionsComb1.get(rIdx);
                int[] clr = ImageIOHelper.getNextRGB(i);

                im1Cp = img1.copyImage();
                r.drawEllipse(im1Cp, 0, 255, 0, 0);
                for (PairInt p : rp.points) {
                    ImageIOHelper.addPointToImage(p.getX(), p.getY(), 
                        im1Cp, 0, 10, 255, 10);
                }
                r.calculateXYCentroid(xyCen, im1Cp.getWidth(), im1Cp.getHeight());
                ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], im1Cp,
                    1, 255, 0, 0);
                MiscDebug.writeImage(im1Cp, &quot;_&quot; + settings.getDebugLabel() 
                    + &quot;_regions_1_acc_&quot; + i + &quot;_&quot;);
            }
            */
        }
        
          //DEBUG: mask out all pixels not in a region
<span class="fc" id="L313">        TLongSet pix0 = createAccumulatedPixels(regionPoints0, img0Trimmed.getWidth());</span>
<span class="fc" id="L314">        TLongSet pix1 = createAccumulatedPixels(regionPoints1, img1.getWidth());</span>
<span class="fc" id="L315">        maskOutNonRegion(img0Trimmed, pix0);</span>
<span class="fc" id="L316">        maskOutNonRegion(luvTheta0, pix0);</span>
<span class="fc" id="L317">        maskOutNonRegion(img1, pix1);</span>
<span class="fc" id="L318">        maskOutNonRegion(luvTheta1, pix1);</span>
                
<span class="fc" id="L320">        List&lt;List&lt;GreyscaleImage&gt;&gt; pyrRGB0 = imageProcessor.buildColorPyramid(</span>
            img0Trimmed, settings.useLargerPyramid0);
        
<span class="fc" id="L323">        List&lt;GreyscaleImage&gt; pyrPT0 = imageProcessor.buildPyramid(</span>
            luvTheta0, settings.useLargerPyramid0);

<span class="fc" id="L326">        List&lt;List&lt;GreyscaleImage&gt;&gt; pyrRGB1 = imageProcessor.buildColorPyramid(</span>
            img1, settings.useLargerPyramid1);

<span class="fc" id="L329">        List&lt;GreyscaleImage&gt; pyrPT1 = imageProcessor.buildPyramid(</span>
            luvTheta1, settings.useLargerPyramid1);
       
        //// applyWindowedMean(pyrRGB0, 1);
        ////applyWindowedMean(pyrRGB1, 1);
        ////applyWindowedMean2(pyrPT0, 1);
        ////applyWindowedMean2(pyrPT1, 1);
        
<span class="fc" id="L337">        MSERMatcher matcher = new MSERMatcher();</span>

<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L340">            matcher.setToDebug();</span>
        }
        
<span class="fc" id="L343">        List&lt;CorrespondenceList&gt; corList = matcher.matchObject0(</span>
            clrMode, pyrRGB0, pyrPT0, regionPoints0,
            pyrRGB1, pyrPT1, regionPoints1, settings);
        
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (corList == null) {</span>
<span class="fc" id="L348">            return null;</span>
        }
        
        // apply offsets for having trimmed image 0
<span class="fc bfc" id="L352" title="All 2 branches covered.">        for (int i0 = 0; i0 &lt; corList.size(); ++i0) {</span>
<span class="fc" id="L353">            CorrespondenceList topC = corList.get(i0);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            for (int i = 0; i &lt; topC.getPoints1().size(); ++i) {</span>
<span class="fc" id="L355">                PairInt p = topC.getPoints1().get(i);</span>
<span class="fc" id="L356">                int x = p.getX();</span>
<span class="fc" id="L357">                int y = p.getY();</span>
<span class="fc" id="L358">                p.setX(x + img0Trim.getXOffset());</span>
<span class="fc" id="L359">                p.setY(y + img0Trim.getYOffset());</span>
            }
        }

<span class="fc" id="L363">        return corList;</span>
    }
    
    
    private void filterCloseToBounds2(List&lt;Region&gt; regions,
        int width, int height, int border) {

<span class="fc" id="L370">        int[] xy = new int[2];</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (int i = (regions.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L372">            Region r = regions.get(i);</span>
<span class="fc" id="L373">            r.calculateXYCentroid(xy, width, height);</span>
<span class="fc bfc" id="L374" title="All 8 branches covered.">            if (xy[0] &lt; border || xy[1] &lt; border ||</span>
                (xy[0] &gt;= (width - border)) ||
                (xy[1] &gt;= (height - border))) {
<span class="fc" id="L377">                regions.remove(i);</span>
            }
        }
<span class="fc" id="L380">    }</span>

    private TrimmedImage trim(ImageExt img, Set&lt;PairInt&gt; shape,
        int buffer) {

<span class="fc" id="L385">        int[] minMaxXY = MiscMath.findMinMaxXY(shape);</span>

<span class="fc" id="L387">        int x0 = minMaxXY[0] - buffer;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (x0 &lt; 0) {</span>
<span class="fc" id="L389">            x0 = 0;</span>
        }
<span class="fc" id="L391">        int x1 = minMaxXY[1] + buffer;</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (x1 &gt; img.getWidth()) {</span>
<span class="nc" id="L393">            x1 = img.getWidth();</span>
        }
<span class="fc" id="L395">        int y0 = minMaxXY[2] - buffer;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (y0 &lt; 0) {</span>
<span class="fc" id="L397">            y0 = 0;</span>
        }
<span class="fc" id="L399">        int y1 = minMaxXY[3] + buffer;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (y1 &gt; img.getHeight()) {</span>
<span class="fc" id="L401">            y1 = img.getHeight();</span>
        }

<span class="fc" id="L404">        TrimmedImage trImg = new TrimmedImage(img, x0, x1, y0, y1);</span>

<span class="fc" id="L406">        return trImg;</span>
    }

    private void mask(Image img, Set&lt;PairInt&gt; shape0) {

<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L413">                PairInt p = new PairInt(i, j);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">                if (!shape0.contains(p)) {</span>
<span class="fc" id="L415">                    img.setRGB(i, j, 0, 0, 0);</span>
                }
            }
        }
<span class="fc" id="L419">    }</span>

    private void mask(GreyscaleImage img, Set&lt;PairInt&gt; shape0) {

<span class="fc bfc" id="L423" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L425">                PairInt p = new PairInt(i, j);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                if (!shape0.contains(p)) {</span>
<span class="fc" id="L427">                    img.setValue(i, j, 0);</span>
                }
            }
        }
<span class="fc" id="L431">    }</span>

    private List&lt;Region&gt; createCombinedMSERRegions(GreyscaleImage gsImg,
        GreyscaleImage luvTheta, CMODE clrMode, CMODE ptMode,
        Threshold thrGs, Threshold thrPt, String debugLabel) {

<span class="fc" id="L437">        MSER mser = new MSER();</span>

<span class="fc" id="L439">        List&lt;List&lt;Region&gt;&gt; regionsT = new ArrayList&lt;List&lt;Region&gt;&gt;();</span>
<span class="fc" id="L440">        List&lt;List&lt;Region&gt;&gt; regions = new ArrayList&lt;List&lt;Region&gt;&gt;();</span>
        
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L443">            System.out.println(debugLabel + &quot;  clrMode=&quot; + clrMode.name() </span>
<span class="nc" id="L444">                + &quot; ptMode=&quot; + ptMode.name());</span>
        }
        
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (clrMode.equals(CMODE.WHITE)) {</span>
<span class="fc" id="L448">            int[] gsA = MSER.readIntoArray(gsImg);</span>
<span class="fc" id="L449">            List&lt;Region&gt; list = mser.findRegionsNeg(gsA,</span>
<span class="fc" id="L450">                gsImg.getWidth(), gsImg.getHeight(), thrGs);</span>
<span class="fc" id="L451">            regions.add(new ArrayList&lt;Region&gt;());</span>
<span class="fc" id="L452">            regions.add(list);</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        } else if (clrMode.equals(CMODE.BLACK)) {</span>
<span class="nc" id="L454">            int[] gsA = MSER.readIntoArray(gsImg);</span>
<span class="nc" id="L455">            List&lt;Region&gt; list = mser.findRegionsPos(gsA,</span>
<span class="nc" id="L456">                gsImg.getWidth(), gsImg.getHeight(), thrGs);</span>
<span class="nc" id="L457">            regions.add(list);</span>
<span class="nc" id="L458">            regions.add(new ArrayList&lt;Region&gt;());</span>
<span class="nc" id="L459">        } else {</span>
            // was using:
            //regions = mser.findRegions(gsImg, thrGs);
            // now using both pos and neg:
<span class="fc" id="L463">            int[] gsA = MSER.readIntoArray(gsImg);</span>
<span class="fc" id="L464">            System.out.println(&quot;GS POS:&quot;);</span>
<span class="fc" id="L465">            regions.add(mser.findRegionsPos(gsA, gsImg.getWidth(), gsImg.getHeight(), thrGs));</span>
<span class="fc" id="L466">            System.out.println(&quot;GS NEG:&quot;);</span>
<span class="fc" id="L467">            regions.add(mser.findRegionsNeg(gsA, gsImg.getWidth(), gsImg.getHeight(), thrGs));</span>
        }
        
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (ptMode.equals(CMODE.WHITE)) {</span>
<span class="nc" id="L471">            int[] ptA = MSER.readIntoArray(luvTheta);</span>
<span class="nc" id="L472">            List&lt;Region&gt; list = mser.findRegionsNeg(ptA,</span>
<span class="nc" id="L473">                luvTheta.getWidth(), luvTheta.getHeight(), thrPt);</span>
<span class="nc" id="L474">            regionsT.add(new ArrayList&lt;Region&gt;());</span>
<span class="nc" id="L475">            regionsT.add(list);</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        } else if (ptMode.equals(CMODE.BLACK)) {</span>
<span class="nc" id="L477">            int[] ptA = MSER.readIntoArray(luvTheta);</span>
<span class="nc" id="L478">            List&lt;Region&gt; list = mser.findRegionsPos(ptA,</span>
<span class="nc" id="L479">                luvTheta.getWidth(), luvTheta.getHeight(), thrPt);</span>
<span class="nc" id="L480">            regionsT.add(list);</span>
<span class="nc" id="L481">            regionsT.add(new ArrayList&lt;Region&gt;());</span>
<span class="nc" id="L482">        } else {</span>
            // was using
            //regionsT = mser.findRegions(luvTheta, thrPt);
            // now reading pos and neg
<span class="fc" id="L486">            int[] ptA = MSER.readIntoArray(luvTheta);</span>
<span class="fc" id="L487">            System.out.println(&quot;PT POS:&quot;);</span>
<span class="fc" id="L488">            regionsT.add(mser.findRegionsPos(ptA, luvTheta.getWidth(), luvTheta.getHeight(), thrPt));</span>
<span class="fc" id="L489">            System.out.println(&quot;PT NEG:&quot;);</span>
<span class="fc" id="L490">            regionsT.add(mser.findRegionsNeg(ptA, luvTheta.getWidth(), luvTheta.getHeight(), thrPt));</span>
        
<span class="fc" id="L492">            int[] xyCen = new int[2];</span>
            
            // filter to remove all w/ variation &gt; 0
<span class="fc bfc" id="L495" title="All 2 branches covered.">            for (int type = 0; type &lt; 2; ++type) {</span>
<span class="fc" id="L496">                List&lt;Region&gt; list = regionsT.get(type);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                for (int i = (list.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L498">                    Region r = list.get(i);</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">                    if ((type == 1) &amp;&amp; r.getVariation() &gt; 0.001) {</span>
<span class="fc" id="L500">                        list.remove(i);</span>
<span class="fc bfc" id="L501" title="All 4 branches covered.">                    } else if ((type == 0) &amp;&amp; r.getVariation() == 0.0) {</span>
                        //r.calculateXYCentroid(xyCen, gsImg.getWidth(), 
                        //    gsImg.getHeight());
                       // list.remove(i);
                        
//variation;  First and second moments of the region 
//            (x, y, x^2, xy, y^2)
//0;        1255, 941, 105035, 78724, 59043
                    }
                }
            }
        }

        ///*
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">        if (debug){</span>
<span class="nc" id="L516">            long ts = MiscDebug.getCurrentTimeFormatted();</span>
<span class="nc" id="L517">            int[] xyCen = new int[2];</span>
            Image imCp;
<span class="nc bnc" id="L519" title="All 2 branches missed.">            for (int type = 0; type &lt; 2; ++type) {</span>
<span class="nc" id="L520">                imCp = gsImg.copyToColorGreyscale();</span>
<span class="nc" id="L521">                int n9 = regions.get(type).size();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                for (int i = 0; i &lt; n9; ++i) {</span>
<span class="nc" id="L523">                    Region r = regions.get(type).get(i);</span>
<span class="nc" id="L524">                    int[] clr = ImageIOHelper.getNextRGB(i);</span>
<span class="nc" id="L525">                    r.drawEllipse(imCp, 0, clr[0], clr[1], clr[2]);</span>
<span class="nc" id="L526">                    r.calculateXYCentroid(xyCen, imCp.getWidth(), imCp.getHeight());</span>
<span class="nc" id="L527">                    ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], imCp,</span>
                        1, 255, 0, 0);

                    //r.calculateXYCentroid(xyCen, imCp.getWidth(), imCp.getHeight());
                    //System.out.println(&quot;r=&quot; + r.toString() + &quot; &quot; + Arrays.toString(xyCen));
                }
<span class="nc" id="L533">                MiscDebug.writeImage(imCp, debugLabel + &quot;__regions_gs_&quot;+ type + &quot;_&quot; + ts);</span>
            }

<span class="nc bnc" id="L536" title="All 2 branches missed.">            for (int type = 0; type &lt; 2; ++type) {</span>
<span class="nc" id="L537">                imCp = luvTheta.copyToColorGreyscale();</span>
<span class="nc" id="L538">                int n9 = regionsT.get(type).size();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                for (int i = 0; i &lt; n9; ++i) {</span>
<span class="nc" id="L540">                    Region r = regionsT.get(type).get(i);</span>
<span class="nc" id="L541">                    int[] clr = ImageIOHelper.getNextRGB(i);</span>
<span class="nc" id="L542">                    r.drawEllipse(imCp, 0, clr[0], clr[1], clr[2]);</span>
<span class="nc" id="L543">                    r.calculateXYCentroid(xyCen, imCp.getWidth(), imCp.getHeight());</span>
<span class="nc" id="L544">                    ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], imCp,</span>
                        1, 255, 0, 0);
                    //System.out.println(type + &quot; xy=&quot; + xyCen[0] + &quot;,&quot; + xyCen[1]
                    //    + &quot; variation=&quot; + r.getVariation());
                }
<span class="nc" id="L549">                MiscDebug.writeImage(imCp, debugLabel + &quot;__regions_pt_&quot;+ type + &quot;_&quot; + ts);</span>
            }
        }
        //*/
 
<span class="fc" id="L554">        List&lt;Region&gt; combined = new ArrayList&lt;Region&gt;();</span>
        
<span class="fc bfc" id="L556" title="All 2 branches covered.">        for (int i = 0; i &lt; 2; ++i) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            for (Region r : regions.get(i)) {</span>
<span class="fc" id="L558">                combined.add(r);</span>
<span class="fc" id="L559">            }</span>
        }
        
<span class="fc bfc" id="L562" title="All 2 branches covered.">        for (int i = 0; i &lt; 2; ++i) {</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            for (Region r : regionsT.get(i)) {</span>
<span class="fc" id="L564">                combined.add(r);</span>
<span class="fc" id="L565">            }</span>
        }

<span class="fc" id="L568">        filterCloseToBounds2(combined, gsImg.getWidth(), gsImg.getHeight(), 10);</span>

<span class="fc" id="L570">        return combined;</span>
    }

    private void filterByColorHistograms(ImageExt img0, Set&lt;PairInt&gt; shape0, 
        ImageExt img1, TIntObjectMap&lt;RegionPoints&gt; regions1) {
        
        //filter by color hist of hsv, cielab and by CIECH

<span class="fc" id="L578">        ColorHistogram clrHist = new ColorHistogram();</span>

<span class="fc" id="L580">        float upperLimit = 0.27f;// 0.33f;</span>
        
        // make the template histograms from the first scale only
<span class="fc" id="L583">        int[][] template_ch_HSV = clrHist.histogramHSV(img0, shape0);</span>
<span class="fc" id="L584">        int[][] template_ch_LAB = clrHist.histogramCIELAB(img0, shape0);</span>
<span class="fc" id="L585">        int[] tHist = clrHist.histogramCIECH64(img0, shape0);</span>
        
<span class="fc" id="L587">        TIntObjectIterator&lt;RegionPoints&gt; iter = regions1.iterator();</span>
        
<span class="fc" id="L589">        TIntSet rmSet = new TIntHashSet();</span>
        
<span class="fc bfc" id="L591" title="All 2 branches covered.">        for (int i = 0; i &lt; regions1.size(); ++i) {</span>
<span class="fc" id="L592">            iter.advance();</span>
            
<span class="fc" id="L594">            int rIdx = iter.key();</span>
<span class="fc" id="L595">            RegionPoints r = iter.value();</span>
            
<span class="fc" id="L597">            int[][] ch = clrHist.histogramHSV(img1, r.accX, r.accY);</span>
<span class="fc" id="L598">            float intersection = clrHist.intersection(template_ch_HSV, ch);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">            if (intersection &lt; upperLimit) {</span>
<span class="fc" id="L600">                rmSet.add(rIdx);</span>
            } else {
<span class="fc" id="L602">                ch = clrHist.histogramCIELAB(img1, r.accX, r.accY);</span>
<span class="fc" id="L603">                intersection = clrHist.intersection(template_ch_LAB, ch);</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">                if (intersection &lt; upperLimit) {</span>
<span class="fc" id="L605">                    rmSet.add(rIdx);</span>
                } else {
<span class="fc" id="L607">                    int[] tHist1 = clrHist.histogramCIECH64(img1, r.accX, r.accY);</span>
<span class="fc" id="L608">                    intersection = clrHist.intersection(tHist, tHist1);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">                    if (intersection &lt; upperLimit) {</span>
<span class="fc" id="L610">                        rmSet.add(rIdx);</span>
                    }
                }
            }
        }
        
<span class="fc" id="L616">        TIntIterator iter2 = rmSet.iterator();</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        while (iter2.hasNext()) {</span>
<span class="fc" id="L618">            int rmIdx = iter2.next();</span>
<span class="fc" id="L619">            regions1.remove(rmIdx);</span>
<span class="fc" id="L620">        }</span>
        
<span class="fc" id="L622">        System.out.println(&quot;chist filter removed &quot; + rmSet.size());</span>
<span class="fc" id="L623">    }</span>

    static void replaceWithAccumulatedPoints(TIntObjectMap&lt;RegionPoints&gt; regionPoints) {
    
<span class="fc" id="L627">        PerimeterFinder2 finder = new PerimeterFinder2();</span>
        
<span class="fc" id="L629">        TIntObjectIterator&lt;RegionPoints&gt; iter = regionPoints.iterator();</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">        for (int i = 0; i &lt; regionPoints.size(); ++i) {</span>
            
<span class="fc" id="L632">            iter.advance();</span>
<span class="fc" id="L633">            int rIdx = iter.key();</span>
            
<span class="fc" id="L635">            RegionPoints rp = iter.value();</span>
            
            //NOTE this may need to be revised.
            //  wanting to trim down the points outside of the ellipse if
            //  they are too far away, such as a line of pixels blended into
            //  what is otherwise a more compact object.
            
<span class="fc" id="L642">            TIntList xPointsE = new TIntArrayList();</span>
<span class="fc" id="L643">            TIntList yPointsE = new TIntArrayList();</span>
            
<span class="fc" id="L645">            Set&lt;PairInt&gt; ellipse = new HashSet&lt;PairInt&gt;(rp.accX.size());</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">            for (int ii = 0; ii &lt; rp.accX.size(); ++ii) {</span>
<span class="fc" id="L647">                ellipse.add(new PairInt(rp.accX.get(ii), rp.accY.get(ii)));</span>
            }
                        
<span class="fc bfc" id="L650" title="All 2 branches covered.">            for (int j = 0; j &lt; rp.accX.size(); ++j) {</span>
<span class="fc" id="L651">                int x = rp.accX.get(j);</span>
<span class="fc" id="L652">                int y = rp.accY.get(j);</span>
<span class="fc" id="L653">                PairInt p2 = new PairInt(x, y);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                if (!ellipse.contains(p2)) {</span>
                    // if far away from center, past major axis, do not add
<span class="nc" id="L656">                    int diffX = x - rp.ellipseParams.xC;</span>
<span class="nc" id="L657">                    int diffY = y - rp.ellipseParams.yC;</span>
<span class="nc" id="L658">                    double d = Math.sqrt(diffX * diffX + diffY * diffY);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                    if (d &gt; 1.2 * rp.ellipseParams.major) {</span>
<span class="nc" id="L660">                        continue;</span>
                    }
                }
<span class="fc" id="L663">                xPointsE.add(x);</span>
<span class="fc" id="L664">                yPointsE.add(y);</span>
            }
            
            // fill in embedded spaces.
            // NOTE: this may need to be reconsidered in special cases.
<span class="fc" id="L669">            Set&lt;PairInt&gt; embedded = finder.findEmbeddedGaps(rp.accX, rp.accY);</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">            if (embedded != null) {</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                for (PairInt pE : embedded) {</span>
<span class="nc" id="L672">                    xPointsE.add(pE.getX());</span>
<span class="nc" id="L673">                    yPointsE.add(pE.getY());</span>
<span class="nc" id="L674">                }</span>
            }
<span class="fc" id="L676">            rp.accX.clear();</span>
<span class="fc" id="L677">            rp.accY.clear();</span>
<span class="fc" id="L678">            rp.accX.addAll(xPointsE);</span>
<span class="fc" id="L679">            rp.accY.addAll(yPointsE);</span>
        }
<span class="fc" id="L681">    }</span>

    private void filterToLargestPartitions(TIntObjectMap&lt;RegionPoints&gt; 
        regionPoints, ImageExt img, Set&lt;PairInt&gt; shape) {
        
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (regionPoints.size() &lt; 4) {</span>
<span class="nc" id="L687">            return;</span>
        }
        
        // keep the largest region, which is usually the entire shape
        // and keep the largest 2 regions which sum to a union equal to the whole
        
        // some original regions are present in multiplocity due to having 
        // diferent orientation angles, so need to extract only the unique
        // centers
<span class="fc" id="L696">        Map&lt;PairInt, TIntList&gt; centerRIdxMap = new HashMap&lt;PairInt, TIntList&gt;();</span>
        
<span class="fc" id="L698">        int maxV = Integer.MIN_VALUE;</span>
<span class="fc" id="L699">        PairInt maxVXY = null;</span>
<span class="fc" id="L700">        TIntObjectIterator&lt;RegionPoints&gt; iter = regionPoints.iterator();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (int i = 0; i &lt; regionPoints.size(); ++i) {</span>
<span class="fc" id="L702">            iter.advance();</span>
<span class="fc" id="L703">            RegionPoints r = iter.value();</span>
<span class="fc" id="L704">            int rIdx = iter.key();</span>
<span class="fc" id="L705">            PairInt xy = new PairInt(r.ellipseParams.xC, r.ellipseParams.yC);</span>
<span class="fc" id="L706">            TIntList rList = centerRIdxMap.get(xy);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">            if (rList == null) {</span>
<span class="fc" id="L708">                rList = new TIntArrayList();</span>
<span class="fc" id="L709">                centerRIdxMap.put(xy, rList);</span>
            }
<span class="fc" id="L711">            rList.add(rIdx);</span>
<span class="fc" id="L712">            int n = r.accX.size();</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            if (n &gt; maxV) {</span>
<span class="fc" id="L714">                maxV = n;</span>
<span class="fc" id="L715">                maxVXY = xy;</span>
            }
        }
        
<span class="fc" id="L719">        TIntList keep = new TIntArrayList();</span>
<span class="fc" id="L720">        keep.add(centerRIdxMap.get(maxVXY).iterator().next());</span>
       
        // skipping the max value, single partition
<span class="fc" id="L723">        int[] ns = new int[centerRIdxMap.size() - 1];</span>
<span class="fc" id="L724">        int[] rIdxs = new int[ns.length];</span>
<span class="fc" id="L725">        int count = 0;</span>
        
<span class="fc" id="L727">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L729">        iter = regionPoints.iterator();</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">        for (int i = 0; i &lt; regionPoints.size(); ++i) {</span>
<span class="fc" id="L731">            iter.advance();</span>
<span class="fc" id="L732">            RegionPoints r = iter.value();</span>
<span class="fc" id="L733">            int rIdx = iter.key();</span>
<span class="fc" id="L734">            PairInt xy = new PairInt(r.ellipseParams.xC, r.ellipseParams.yC);</span>
<span class="pc bpc" id="L735" title="1 of 4 branches missed.">            if (xy.equals(maxVXY) || added.contains(xy)) {</span>
<span class="nc" id="L736">                continue;</span>
            }
<span class="fc" id="L738">            added.add(xy);</span>
            
<span class="fc" id="L740">            ns[count] = r.accX.size();</span>
<span class="fc" id="L741">            rIdxs[count] = rIdx;</span>
<span class="fc" id="L742">            count++;</span>
        }
<span class="pc bnc" id="L744" title="All 2 branches missed.">        assert(ns.length == count);</span>
        
<span class="fc" id="L746">        QuickSort.sortBy1stArg(ns, rIdxs);</span>
         
<span class="fc" id="L748">        int sum = 0;</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        for (int i = 0; i &lt; ns.length; ++i) {</span>
<span class="fc" id="L750">            sum += ns[i];</span>
        }
<span class="fc" id="L752">        int half = sum/2;</span>
        
<span class="fc" id="L754">        int mIdx = Arrays.binarySearch(ns, half);</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">        if (mIdx &lt; 0) {</span>
            //(-(insertion point) - 1)
<span class="fc" id="L757">            mIdx = -mIdx - 2;</span>
        }
<span class="fc bfc" id="L759" title="All 2 branches covered.">        if (mIdx == (ns.length - 1)) {</span>
<span class="fc" id="L760">            mIdx--;</span>
        }
        
        // the sum is actually the sum of non-intersecting points to the
        //   definition of middle of sum at mIdx is an approximate
        //   place to make a partition to choose one from either side
        //   which total to max sum.
        
<span class="fc" id="L768">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L769">        int imgW = img.getWidth();</span>
        
<span class="fc" id="L771">        int maxSum = Integer.MIN_VALUE;</span>
<span class="fc" id="L772">        int maxIdxA = -1;</span>
<span class="fc" id="L773">        int maxIdxB = -1;</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        for (int i = 0; i &lt;= mIdx; ++i) {</span>
<span class="fc" id="L775">            int rIdxA = rIdxs[i];</span>
<span class="fc" id="L776">            TLongSet setA = regionPoints.get(rIdxA).createAccPixelCoords(imgW);</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">            for (int j = (mIdx + 1); j &lt; ns.length; ++j) {</span>
<span class="fc" id="L778">                int rIdxB = rIdxs[j];</span>
<span class="fc" id="L779">                TLongSet setB = regionPoints.get(rIdxB).createAccPixelCoords(imgW);</span>
<span class="fc" id="L780">                TLongSet aMinusB = new TLongHashSet(setA);</span>
<span class="fc" id="L781">                aMinusB.removeAll(setB);</span>
                
<span class="fc" id="L783">                TLongSet bMinusA = new TLongHashSet(setB);</span>
<span class="fc" id="L784">                bMinusA.removeAll(setA);</span>
                
<span class="fc" id="L786">                int sum2 = aMinusB.size() + bMinusA.size();</span>
                
<span class="fc bfc" id="L788" title="All 2 branches covered.">                if (sum2 &gt; maxSum) {</span>
<span class="fc" id="L789">                    maxSum = sum2;</span>
<span class="fc" id="L790">                    maxIdxA = rIdxA;</span>
<span class="fc" id="L791">                    maxIdxB = rIdxB;</span>
                }
            }
        }
<span class="pc bnc" id="L795" title="All 2 branches missed.">        assert(maxIdxA &gt; -1);</span>
<span class="pc bnc" id="L796" title="All 2 branches missed.">        assert(maxIdxB &gt; -1);</span>
<span class="fc" id="L797">        keep.add(maxIdxA);</span>
<span class="fc" id="L798">        keep.add(maxIdxB);</span>
        
<span class="fc" id="L800">        TIntObjectMap&lt;RegionPoints&gt; regionPoints2 </span>
            = new TIntObjectHashMap&lt;RegionPoints&gt;();
<span class="fc bfc" id="L802" title="All 2 branches covered.">        for (int i = 0; i &lt; keep.size(); ++i) {</span>
<span class="fc" id="L803">            int idx = keep.get(i);</span>
<span class="fc" id="L804">            RegionPoints r = regionPoints.get(idx);</span>
<span class="fc" id="L805">            PairInt xy = new PairInt(r.ellipseParams.xC, r.ellipseParams.yC);</span>
<span class="fc" id="L806">            TIntList idxs = centerRIdxMap.get(xy);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">            for (int j = 0; j &lt; idxs.size(); ++j) {</span>
<span class="fc" id="L808">                int idx2 = idxs.get(j);</span>
<span class="fc" id="L809">                regionPoints2.put(idx2, regionPoints.get(idx2));</span>
            }
        }
<span class="fc" id="L812">        regionPoints.clear();</span>
<span class="fc" id="L813">        regionPoints.putAll(regionPoints2);</span>
<span class="fc" id="L814">    }</span>

    private TLongSet createAccumulatedPixels(TIntObjectMap&lt;RegionPoints&gt; 
        regionPoints, int width) {
        
<span class="fc" id="L819">        TLongSet out = new TLongHashSet();</span>
<span class="fc" id="L820">        PixelHelper ph = new PixelHelper();</span>
        
<span class="fc" id="L822">        TIntObjectIterator&lt;RegionPoints&gt; iter = regionPoints.iterator();</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">        for (int i = 0; i &lt; regionPoints.size(); ++i) {</span>
<span class="fc" id="L824">            iter.advance();</span>
<span class="fc" id="L825">            RegionPoints r = iter.value();</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">            for (int j = 0; j &lt; r.accX.size(); ++j) {</span>
<span class="fc" id="L827">                long pixIdx = ph.toPixelIndex(r.accX.get(j), r.accY.get(j), width);</span>
<span class="fc" id="L828">                out.add(pixIdx);</span>
            }
        }
        
<span class="fc" id="L832">        return out;</span>
    }

    private void maskOutNonRegion(ImageExt img, TLongSet pixs) {
<span class="fc" id="L836">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L837">        int w = img.getWidth();</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">            for (int y = 0; y &lt; img.getHeight(); ++y) {</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">                if (!pixs.contains(ph.toPixelIndex(x, y, w))) {</span>
<span class="fc" id="L841">                    img.setRGB(x, y, 0, 0, 0);</span>
                }
            }
        }
<span class="fc" id="L845">    }</span>

    private void maskOutNonRegion(GreyscaleImage img, TLongSet pixs) {
<span class="fc" id="L848">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L849">        int w = img.getWidth();</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">            for (int y = 0; y &lt; img.getHeight(); ++y) {</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">                if (!pixs.contains(ph.toPixelIndex(x, y, w))) {</span>
<span class="fc" id="L853">                    img.setValue(x, y, 0);</span>
                }
            }
        }
<span class="fc" id="L857">    }</span>

    public static class Settings {
        private boolean useLargerPyramid0 = false;
        private boolean useLargerPyramid1 = false;

        //TODO: refactor to use an enum to avoid inconsistent state
        private boolean useSmallObjectMethod = false;
        private boolean useShapeFinder = false;

        private boolean findVanishingPoints = false;
        
        private boolean useColorFilter = true;
         
        private String lbl = &quot;&quot;;
        
        /**
         * @return the useLargerPyramid0
         */
        public boolean isUseLargerPyramid0() {
            return useLargerPyramid0;
        }
        
        public void setDebugLabel(String dbgLabel) {
            this.lbl = dbgLabel;
        }
        
        public String getDebugLabel() {
            return lbl;
        }

        /**
         if this is set, the default number of pyramid
         image 0 images separated by a factor of 2 in scale is increased
         in number to include finer scales, allowing better descriptor
         * matches at the cost of increased runtime.
         */
        public void setToUseLargerPyramid0() {
            this.useLargerPyramid0 = true;
        }

        /**
         * @return the useLargerPyramid1
         */
        public boolean isUseLargerPyramid1() {
            return useLargerPyramid1;
        }

        public void setToFindVanishingPoints() {
            this.findVanishingPoints = true;
        }

        /**
         if this is set, the default number of pyramid
         image 1 images separated by a factor of 2 in scale is increased
         in number to include finer scales, allowing better descriptor
         * matches at the cost of increased runtime.
         */
        public void setToUseLargerPyramid1() {
            this.useLargerPyramid1 = true;
        }

        /**
         * @return the useSmallObjectMethod
         */
        public boolean isUseSmallObjectMethod() {
            return useSmallObjectMethod;
        }

        public boolean isUseShapeFinder() {
            return useShapeFinder;
        }

        public void setToUseShapeFinderMethod() {
            useShapeFinder = true;
        }

        /**
         * changes the method used to one without descriptors and instead
         * uses a shape matcher and color histograms.
         * This should only be used on images where the object to find
         * is thought to be small (16 or so pixels for example in width
         * and height)...the shape matching needs the segmentation to
         * contain the object shape in one labeled region rather than in
         * more than one over segmented regions.
         */
        public void setToUseSmallObjectMethod() {
            this.useSmallObjectMethod = true;
        }

        private boolean isFindVanishingPoints() {
            return findVanishingPoints;
        }

        public void setToExcludeColorFilter() {
            useColorFilter = false;
        }
        public boolean useColorFilter() {
            return useColorFilter;
        }
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>
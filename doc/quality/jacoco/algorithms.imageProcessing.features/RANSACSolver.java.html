<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RANSACSolver.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">RANSACSolver.java</span></div><h1>RANSACSolver.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.imageProcessing.matching.ErrorType;
import algorithms.imageProcessing.transform.EpipolarTransformationFit;
import algorithms.imageProcessing.transform.EpipolarTransformer;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.imageProcessing.util.RANSACAlgorithmIterations;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;

/**
 * given matched point lists, determine the best epipolar solution using a
 * 7-point epipolar calculation and random draws of 7 points from the
 * matched point lists under the assumption that some of the matched points
 * are not true (correct) matches.
 *
 * &lt;pre&gt;
 * useful reading:
 * http://6.869.csail.mit.edu/fa12/lectures/lecture13ransac/lecture13ransac.pdf
 * and
 * http://www.dtic.mil/dtic/tr/fulltext/u2/a460585.pdf
 * &lt;/pre&gt;
 *
 * @author nichole
 */
<span class="fc" id="L32">public class RANSACSolver {</span>

<span class="fc" id="L34">    private boolean debug = true;</span>

<span class="fc" id="L36">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * NOT COMPLETELY READY FOR USE YET
     * calculate the epipolar projection among the given points with the
     * assumption that some of the points in the matched lists are not
     * true matches.
     *
     * @param matchedLeftXY
     * @param matchedRightXY
     * @param outputLeftXY
     * @param outputRightXY
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarProjection(
        PairIntArray matchedLeftXY, PairIntArray matchedRightXY,
        PairIntArray outputLeftXY, PairIntArray outputRightXY) {

<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (matchedLeftXY == null) {</span>
<span class="nc" id="L55">            throw new IllegalArgumentException(&quot;matchedLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (matchedRightXY == null) {</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;matchedRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (matchedLeftXY.getN() &lt; 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L62">            throw new IllegalArgumentException(</span>
            &quot;the algorithms require 7 or more points.  matchedLeftXY.n=&quot; 
<span class="nc" id="L64">            + matchedLeftXY.getN());</span>
        }

<span class="fc" id="L67">        EpipolarTransformer spTransformer = new EpipolarTransformer();</span>
        
<span class="fc" id="L69">        DenseMatrix input1 =</span>
<span class="fc" id="L70">            spTransformer.rewriteInto3ColumnMatrix(matchedLeftXY);</span>

<span class="fc" id="L72">        DenseMatrix input2 =</span>
<span class="fc" id="L73">            spTransformer.rewriteInto3ColumnMatrix(matchedRightXY);</span>
        
<span class="fc" id="L75">        return calculateEpipolarProjection(input1, input2,</span>
            outputLeftXY, outputRightXY);
    }

    /**
     * calculate the epipolar projection among the given points with the
     * assumption that some of the points in the matched lists are not
     * true matches.
     *
     * @param matchedLeftXY
     * @param matchedRightXY
     * @param outputLeftXY
     * @param outputRightXY
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarProjection(
        DenseMatrix matchedLeftXY, DenseMatrix matchedRightXY,
        PairIntArray outputLeftXY, PairIntArray outputRightXY) {

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (matchedLeftXY == null) {</span>
<span class="nc" id="L95">            throw new IllegalArgumentException(&quot;matchedLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (matchedRightXY == null) {</span>
<span class="nc" id="L98">            throw new IllegalArgumentException(&quot;matchedRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (matchedLeftXY.numColumns() &lt; 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L102">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot;
<span class="nc" id="L104">                + &quot; matchedLeftXY.n=&quot; + matchedLeftXY.numColumns());</span>
        }
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (matchedLeftXY.numColumns() != matchedRightXY.numColumns()) {</span>
<span class="nc" id="L107">            throw new IllegalArgumentException(</span>
                &quot;matchedLeftXY and right bmust be the same size&quot;);
        }

        /*
        -- randomly sample 7 points from nPoints
        -- calculate the epipolar fundamental matrix from the 7
        -- evaluate all nPoints against the epipolar projected lines
           and keep each point which has error &lt; tolerance.
           those points are a consensus of this model (the fundamental matrix)
        -- if the number of points in the consensus is &gt; required, exit loop,
           else repeat (note that each consensus is stored separately for
           each iteration.  note that the loop is terminated if the number of
           iterations has exceeded a predetermined maximum.
        -- after exit from the loop, the largest consensus is used to
           re-calculate the fundamental matrix as the last result.
           note that if there aren't enough points in a consensus to
           calculate the fundamental matrix, the result is null.
        */

<span class="fc" id="L127">        int nSet = 7;</span>

<span class="fc" id="L129">        int nPoints = matchedLeftXY.numColumns();</span>
        
<span class="fc" id="L131">        ErrorType errorType = ErrorType.SAMPSONS;</span>

<span class="fc" id="L133">        EpipolarTransformer spTransformer = new EpipolarTransformer();</span>
            
<span class="fc" id="L135">        SecureRandom sr = Misc.getSecureRandom();</span>
<span class="fc" id="L136">        long seed = System.currentTimeMillis();</span>
<span class="fc" id="L137">        log.fine(&quot;SEED=&quot; + seed + &quot; nPoints=&quot; + nPoints);</span>
<span class="fc" id="L138">        sr.setSeed(seed);</span>

<span class="fc" id="L140">        int tolerance = 5;</span>

        // consensus indexes
<span class="fc" id="L143">        EpipolarTransformationFit bestFit = null;</span>
        
<span class="fc" id="L145">        RANSACAlgorithmIterations nEstimator = new RANSACAlgorithmIterations();</span>

        /*
        could consider a threshold max iteration based upon the image size such
        as in (http://phototour.cs.washington.edu/ModelingTheWorld_ijcv07.pdf)
        which uses 0.6% of the maximum image dimension.
        */
<span class="fc" id="L152">        long nMaxIter = nEstimator.estimateNIterFor99PercentConfidence(nPoints, 7, 0.5);</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (nPoints == 7) {</span>
<span class="fc" id="L155">            nMaxIter = 1;</span>
        }

<span class="fc" id="L158">        int nIter = 0;</span>
        
<span class="fc" id="L160">        int[] selectedIndexes = new int[nSet];</span>
        
<span class="fc" id="L162">        DenseMatrix sampleLeft = new DenseMatrix(3, nSet);</span>
<span class="fc" id="L163">        DenseMatrix sampleRight = new DenseMatrix(3, nSet);</span>
        
<span class="fc bfc" id="L165" title="All 4 branches covered.">        while ((nIter &lt; nMaxIter) &amp;&amp; (nIter &lt; 2000)) {</span>
            
<span class="fc" id="L167">            MiscMath.chooseRandomly(sr, selectedIndexes, nPoints);</span>

<span class="fc" id="L169">            int count = 0;</span>
            
<span class="fc bfc" id="L171" title="All 2 branches covered.">            for (int bitIndex : selectedIndexes) {</span>

<span class="fc" id="L173">                int idx = bitIndex;</span>

<span class="fc" id="L175">                sampleLeft.set(0, count, matchedLeftXY.get(0, idx));</span>
<span class="fc" id="L176">                sampleLeft.set(1, count, matchedLeftXY.get(1, idx));</span>
<span class="fc" id="L177">                sampleLeft.set(2, count, 1);</span>
                                
<span class="fc" id="L179">                sampleRight.set(0, count, matchedRightXY.get(0, idx));</span>
<span class="fc" id="L180">                sampleRight.set(1, count, matchedRightXY.get(1, idx));</span>
<span class="fc" id="L181">                sampleRight.set(2, count, 1);</span>
                
<span class="fc" id="L183">                count++;</span>
            }

            // determine matrix from 7 points.
<span class="fc" id="L187">            List&lt;DenseMatrix&gt; fms =</span>
<span class="fc" id="L188">                spTransformer.calculateEpipolarProjectionFor7Points(sampleLeft, </span>
                    sampleRight);

<span class="pc bpc" id="L191" title="2 of 4 branches missed.">            if (fms == null || fms.isEmpty()) {</span>
<span class="nc" id="L192">                nIter++;</span>
<span class="nc" id="L193">                continue;</span>
            }

            // use point dist to epipolar lines to estimate errors of sample
<span class="fc" id="L197">            EpipolarTransformationFit fit = null;</span>
            
<span class="fc bfc" id="L199" title="All 2 branches covered.">            for (DenseMatrix fm : fms) {</span>
<span class="fc" id="L200">                EpipolarTransformationFit fitI = </span>
<span class="fc" id="L201">                    spTransformer.calculateError(fm, matchedLeftXY, </span>
                        matchedRightXY, errorType, tolerance);
                
<span class="fc bfc" id="L204" title="All 2 branches covered.">                if (fitI.isBetter(fit)) {</span>
<span class="fc" id="L205">                    fit = fitI;</span>
                }
<span class="fc" id="L207">            }</span>
            
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (fit == null) {</span>
<span class="nc" id="L210">                nIter++;</span>
<span class="nc" id="L211">                continue;</span>
            }
            
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (fit.isBetter(bestFit)) {</span>
<span class="fc" id="L215">                bestFit = fit;</span>
            }
            
<span class="fc" id="L218">            nIter++;</span>
            
            // recalculate nMaxIter
<span class="pc bpc" id="L221" title="1 of 4 branches missed.">            if ((bestFit != null) &amp;&amp; ((nIter % 10) == 0)) {</span>
<span class="fc" id="L222">                double ratio = (double)bestFit.getInlierIndexes().size()</span>
<span class="fc" id="L223">                    /(double)matchedLeftXY.numColumns();</span>
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">                if (ratio &gt;= 0.0000001 &amp;&amp; (ratio &lt;= 1.0)) {</span>
<span class="fc" id="L225">                    nMaxIter = nEstimator.estimateNIterFor99PercentConfidence(nPoints, </span>
                        nSet, ratio);
                }
            }
<span class="fc" id="L229">        }</span>

<span class="pc bpc" id="L231" title="1 of 4 branches missed.">        if (bestFit == null || bestFit.getInlierIndexes().isEmpty()) {</span>
<span class="fc" id="L232">            log.info(&quot;no solution.  nIter=&quot; + nIter);</span>
<span class="fc" id="L233">            return null;</span>
        }

        // store inliers in outputLeftXY and outputRightXY and redo the
        // entire fit using only the inliers to determine the fundamental
        // matrix.
<span class="fc" id="L239">        int n = bestFit.getInlierIndexes().size();</span>
<span class="fc" id="L240">        DenseMatrix inliersLeftXY = new DenseMatrix(3, n);</span>
<span class="fc" id="L241">        DenseMatrix inliersRightXY = new DenseMatrix(3, n);</span>
        
<span class="fc" id="L243">        int count = 0;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (Integer idx : bestFit.getInlierIndexes()) {</span>
<span class="fc" id="L245">            int idxInt = idx.intValue();            </span>
<span class="fc" id="L246">            inliersLeftXY.set(0, count, matchedLeftXY.get(0, idxInt));</span>
<span class="fc" id="L247">            inliersLeftXY.set(1, count, matchedLeftXY.get(1, idxInt));</span>
<span class="fc" id="L248">            inliersLeftXY.set(2, count, 1);</span>
<span class="fc" id="L249">            inliersRightXY.set(0, count, matchedRightXY.get(0, idxInt));</span>
<span class="fc" id="L250">            inliersRightXY.set(1, count, matchedRightXY.get(1, idxInt));</span>
<span class="fc" id="L251">            inliersRightXY.set(2, count, 1);</span>
<span class="fc" id="L252">            count++;</span>
<span class="fc" id="L253">        }</span>

<span class="fc" id="L255">        EpipolarTransformationFit consensusFit = null;</span>
        
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (inliersRightXY.numColumns() == 7) {</span>
            
<span class="nc" id="L259">            List&lt;DenseMatrix&gt; fms = spTransformer.calculateEpipolarProjectionFor7Points(</span>
                inliersLeftXY, inliersRightXY);
<span class="nc bnc" id="L261" title="All 4 branches missed.">            if (fms == null || fms.isEmpty()) {</span>
<span class="nc" id="L262">                return null;</span>
            }
<span class="nc" id="L264">            EpipolarTransformationFit fit = null;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            for (DenseMatrix fm : fms) {</span>
<span class="nc" id="L266">                EpipolarTransformationFit fitI = </span>
<span class="nc" id="L267">                    spTransformer.calculateError(fm, matchedLeftXY, </span>
                        matchedRightXY, errorType, tolerance);
<span class="nc bnc" id="L269" title="All 2 branches missed.">                if (fitI.isBetter(fit)) {</span>
<span class="nc" id="L270">                    fit = fitI;</span>
                }
<span class="nc" id="L272">            }</span>
<span class="nc" id="L273">            consensusFit = fit;</span>
            
<span class="nc" id="L275">        } else {</span>
            
<span class="fc" id="L277">            DenseMatrix fm = </span>
<span class="fc" id="L278">                spTransformer.calculateEpipolarProjection(</span>
                inliersLeftXY, inliersRightXY);
            
<span class="fc" id="L281">            EpipolarTransformationFit fit = </span>
<span class="fc" id="L282">                spTransformer.calculateError(fm, matchedLeftXY, </span>
                    matchedRightXY, errorType, tolerance);
            
<span class="fc" id="L285">            consensusFit = fit;</span>
        }
    
        // write to output and convert the coordinate indexes to the original point indexes
<span class="fc" id="L289">        List&lt;Integer&gt; inlierIndexes = consensusFit.getInlierIndexes();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int i = 0; i &lt; inlierIndexes.size(); ++i) {</span>
<span class="fc" id="L291">            Integer index = inlierIndexes.get(i);</span>
<span class="fc" id="L292">            int idx = index.intValue();</span>
<span class="fc" id="L293">            outputLeftXY.add(</span>
<span class="fc" id="L294">                (int)Math.round(matchedLeftXY.get(0, idx)),</span>
<span class="fc" id="L295">                (int)Math.round(matchedLeftXY.get(1, idx)));</span>
<span class="fc" id="L296">            outputRightXY.add(</span>
<span class="fc" id="L297">                (int)Math.round(matchedRightXY.get(0, idx)),</span>
<span class="fc" id="L298">                (int)Math.round(matchedRightXY.get(1, idx)));</span>
        }
        
        /*
        to approximate the error in using this fundamental matrix to estimate
        distances to epipolar lines,
        will calculate distances from the outputleftXY to 
            offsets from outputReightXY where the offsets are
            the same value as &quot;tolerance&quot; and applied in 45 degree
            directions to get roughly near perpendicular to the epipolar
            line.
        */
<span class="fc" id="L310">        float[] toleranceErrors =</span>
<span class="fc" id="L311">            calculateErrorsAsOffsets(consensusFit.getFundamentalMatrix(), </span>
                outputLeftXY, outputRightXY, tolerance);
        
<span class="fc" id="L314">        consensusFit.setTolerance(toleranceErrors[0],</span>
            toleranceErrors[1]);
        
<span class="fc" id="L317">        log.fine(&quot;nIter=&quot; + nIter);</span>

<span class="fc" id="L319">        log.fine(&quot;final fit: &quot; + consensusFit.toString());</span>

<span class="fc" id="L321">        return consensusFit;</span>
    }

    private float[] calculateErrorsAsOffsets(DenseMatrix fm,
        PairIntArray xy1, PairIntArray xy2, int tolerance) {

        /*
        -- make copies of xy2, displacing the point from center by
        radius of tolerance and angles 45, 90, 135, 180, 225, 270, 315 
        and storing them in separate xy2Offset arrays.
        -- choose the max error for each offset of the same point
        -- calc the mean and standard deviation of the max offset
           errors
        this should be a rough estimate of the ability to associate a point
        with an epipolar line.
        */
                
<span class="fc" id="L338">        EpipolarTransformer eTransformer = new EpipolarTransformer();</span>
        
<span class="fc" id="L340">        DenseMatrix m1m = eTransformer.rewriteInto3ColumnMatrix(xy1);</span>
        
<span class="fc" id="L342">        float[] xErrors = new float[xy1.getN()];</span>
<span class="fc" id="L343">        float[] yErrors = new float[xy1.getN()];</span>
<span class="fc" id="L344">        Arrays.fill(xErrors, Float.MAX_VALUE);</span>
<span class="fc" id="L345">        Arrays.fill(yErrors, Float.MAX_VALUE);</span>
        
<span class="fc" id="L347">        float[] outputDist = new float[2];</span>
        
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for (int i = 0; i &lt; 7; ++i) {</span>
            
<span class="fc" id="L351">            double angle = (i + 1) * Math.PI/4.;</span>
            
<span class="fc" id="L353">            int xOff = (int)Math.round(tolerance * Math.cos(angle));</span>
<span class="fc" id="L354">            int yOff = (int)Math.round(tolerance * Math.sin(angle));</span>
            
<span class="fc" id="L356">            PairIntArray xy2Offset = new PairIntArray(xy2.getN());</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            for (int j = 0; j &lt; xy2.getN(); ++j) {</span>
<span class="fc" id="L358">                int x = xy2.getX(j) + xOff;</span>
<span class="fc" id="L359">                int y = xy2.getY(j) + yOff;</span>
<span class="fc" id="L360">                xy2Offset.add(x, y);</span>
            }
         
<span class="fc" id="L363">            DenseMatrix m2m = eTransformer.rewriteInto3ColumnMatrix(xy2Offset);</span>
        
<span class="fc" id="L365">            DenseMatrix m2EpipolarLines = MatrixUtil.multiply(fm, m1m);</span>
<span class="fc" id="L366">            DenseMatrix m1EpipolarLines = MatrixUtil.multiply(fm, m2m);</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">            for (int j = 0; j &lt; xy2Offset.getN(); ++j) {</span>
<span class="fc" id="L369">                eTransformer.calculatePerpDistFromLines(</span>
                    m1m, m2m, 
                    m2EpipolarLines, m1EpipolarLines, 
                    j, j, outputDist);
            
<span class="fc" id="L374">                float d1 = Math.abs(outputDist[0]);</span>
<span class="fc" id="L375">                float d2 = Math.abs(outputDist[1]);</span>
<span class="fc bfc" id="L376" title="All 4 branches covered.">                if (xErrors[j] == Float.MAX_VALUE || xErrors[j] &lt; d1) {</span>
<span class="fc" id="L377">                    xErrors[j] = d1;</span>
                }
<span class="fc bfc" id="L379" title="All 4 branches covered.">                if (yErrors[j] == Float.MAX_VALUE || yErrors[j] &lt; d2) {</span>
<span class="fc" id="L380">                    yErrors[j] = d2;</span>
                }
            }
        }
        
        // calc mean and stdev of tolerance size offsets
<span class="fc" id="L386">        float[] xAvgStDv = MiscMath.getAvgAndStDev(xErrors);</span>
<span class="fc" id="L387">        float[] yAvgStDv = MiscMath.getAvgAndStDev(yErrors);</span>
    
<span class="fc" id="L389">        float combinedAvgTol = (xAvgStDv[0] + yAvgStDv[0])/2.f;</span>
<span class="fc" id="L390">        float combinedStdvTol = (float)Math.sqrt(xAvgStDv[1]*xAvgStDv[1] </span>
            + yAvgStDv[1]*yAvgStDv[1]);
        
<span class="fc" id="L393">        return new float[]{combinedAvgTol, combinedStdvTol};</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
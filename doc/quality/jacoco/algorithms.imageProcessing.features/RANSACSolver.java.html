<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RANSACSolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">RANSACSolver.java</span></div><h1>RANSACSolver.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.SubsetChooser;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.imageProcessing.transform.Distances;
import algorithms.imageProcessing.transform.EpipolarTransformationFit;
import algorithms.imageProcessing.transform.EpipolarTransformer;
import algorithms.imageProcessing.transform.Util;
import algorithms.imageProcessing.util.RANSACAlgorithmIterations;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;

/**
 * given matched point lists, determine the best epipolar solution using a
 * 7-point epipolar calculation and random draws of 7 points from the
 * matched point lists under the assumption that some of the matched points
 * are not true (correct) matches.
 *
 * &lt;pre&gt;
 * useful reading:
 * add references in comments below here..
 * 
 * http://6.869.csail.mit.edu/fa12/lectures/lecture13ransac/lecture13ransac.pdf
 * and
 * http://www.dtic.mil/dtic/tr/fulltext/u2/a460585.pdf
 * &lt;/pre&gt;
 *
 * Note: to compare different geometric model results:
 * &lt;pre&gt;
    The plunder-dl scoring can be used for comparison between different models.
    for example, comparing results of the 7-point and 8-point 
    solutions or comparing 7-point projection to 6-point affine, etc.

    plunder-dl is from equation 33 of
    Torr, Zisserman, &amp; Maybank 1996, 
    â€œRobust Detection of Degenerate Configurations whilst Estimating 
    the Fundamental Matrix&quot;
    https://www.robots.ox.ac.uk/~phst/Papers/CVIU97/m.ps.gz
     EQN 33: PL = DOF + (4*n_o + n_i dimension of model)
                   where n_i = number of inliers
                   n_o = number of outliers
                   DOF = 7 for this solver
    n=7               PL = DOF + 4*n_o + n_i* (model_dimension)
         ni=7, no=0   PL = 7   + 0     + 0 * md
         ni=5, no=2   PL = 7   + 8     + 8 * md
         ni=4, no=3   PL = 7   + 12    + 28 * md
    PLUNDER stands for Pick Least UNDEgenerate Randomly, Description Length

    For nPoints=8, model_dimension = 1.
    for nPoints=7 amd only 1 solution in the cubic constraints, model_dimension=2,
    else for nPoints=7, model_dimension = 3.
 * &lt;/pre&gt;
 * @author nichole
 */
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">public class RANSACSolver {</span>
    
    //TODO: edit to be able to choose nSet = 8 or 7

<span class="fc" id="L65">    private boolean debug = true;</span>

<span class="fc" id="L67">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * calculate the epipolar transformation among the given points with the
     * assumption that some of the points in the matched lists are not
     * true matches.   NOTE: for best results, one should perform unit standard
     * normalization on the correspondence first.
     *
     * @param leftCorres left correspondence holding (x,y) points from left image
     * in format 3 X nData matrix with rows being x, y, and 1's respectively
     * @param rightCorres right correspondence holding (x,y) points from left image
     * in format 3 X nData matrix with rows being x, y, and 1's respectively
     * @param errorType algorithm used to evaluate the fit of the fundamental matrix solutions.
     * @param useToleranceAsStatFactor if set to false, tolerance is used as
     * a fixed number in outlier removal, else if set to true, tolerance
     * is used as the chi-squared statistic factor for the standard deviation
     * of errors use in outlier removal.
     * @param tolerance tolerance in distance from epipolar line for a point to 
     * be an inlier in the final fit.   NOTE: if useToleranceAsStatFactor is true,
     * it is interpreted as a chiSqStatFactor which is then used as 
     * tolerance = tolerance * standard deviation of the mean distance errors.
     * @param reCalcIterations if true, upon each better fit found, the 
     * outlier percentage is re-estimated and then the number of iterations necessary for 95%
     * probability that sample has all good points.
     * @param calibrated if true, solves for the Essential Matrix, else solves
     * for the Fundamental Matrix.  The difference is in the diagonal used for
     * dimension reduction.
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarProjection(
        final DenseMatrix leftCorres, final DenseMatrix rightCorres,
        ErrorType errorType,
        boolean useToleranceAsStatFactor, final double tolerance,
        boolean reCalcIterations, boolean calibrated) {
        
<span class="fc" id="L102">        int nPoints = leftCorres.numColumns();</span>
<span class="fc" id="L103">        final int nSet = 7;</span>
        
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (nPoints &lt; nSet) {</span>
            // cannot use this algorithm.
<span class="nc" id="L107">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot;
<span class="nc" id="L109">                + &quot; leftCorres.n=&quot; + leftCorres.numColumns());</span>
        }
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (leftCorres.numRows() != 3) {</span>
            // cannot use this algorithm.
<span class="nc" id="L113">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 3 rows representing x, y, and '1' values.&quot;
<span class="nc" id="L115">                + &quot; leftCorres.n=&quot; + leftCorres.numColumns());</span>
        }
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (leftCorres.numColumns() != rightCorres.numColumns() ||</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            leftCorres.numRows() != rightCorres.numRows()) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(</span>
                &quot;leftCorres and rightCorres bmust be the same size&quot;);
        }

        /*        
        Using 7 point samples for epipolar transformation fits.
        -- the number of iterations for testing sub-samples of nPoints 
           (each of size 7) and finding one to be a good sub-sample with an
           excess of probability of 95% is estimated for a given
           percent of bad data.
           NOTE, the algorithm proceeds by assuming 50% bad data and improves
           that upon each best fitting sub-sample.
        -- for each iteration of solving epipolar transformation using a sample
           of size 7, the resulting fundamental matrix is evaluated on the
           all points of the dataset.
           If the number of inliers is T or more, the fit is re-done with all
           of the points, where 
               T = (1. - outlierPercentage) * (total number of data points)
           The best fitting for all iterations as defined by number of inliers 
           and standard deviation from an epipolar line, is kept each time.
        -- at the end of each iteration, the number of iterations is then 
           re-calculated if it can be reduced.
        
        NOTE that the sub-samples are selected randomly from all possible
        sub-samples of the nPoints unless the number of all possible 
        sub-samples is smaller than the expected number of iterations for 95%
        probability of a good sub-sample.  In the later case, all sub-samples
        are tried.
        
        */
       
        // n!/(k!*(n-k)!
<span class="fc" id="L151">        final long nPointsSubsets = MiscMath.computeNDivKTimesNMinusK(nPoints, nSet);</span>
<span class="fc" id="L152">        boolean useAllSubsets = false;</span>
        
<span class="fc" id="L154">        SecureRandom sr = Misc.getSecureRandom();</span>
<span class="fc" id="L155">        long seed = System.currentTimeMillis();</span>
<span class="fc" id="L156">        log.info(&quot;SEED=&quot; + seed + &quot; nPoints=&quot; + nPoints);</span>
<span class="fc" id="L157">        sr.setSeed(seed);</span>

<span class="fc" id="L159">        EpipolarTransformer spTransformer = new EpipolarTransformer();</span>
                
        // consensus best fit and inlier indexes
<span class="fc" id="L162">        EpipolarTransformationFit bestFit = null;</span>
        
        /*
        could consider a threshold max iteration based upon the image size such
        as in (http://phototour.cs.washington.edu/ModelingTheWorld_ijcv07.pdf)
        which uses 0.6% of the maximum image dimension.
        */
        
<span class="fc" id="L170">        int outlierPercent = 50;</span>
<span class="fc" id="L171">        int t = (int)Math.ceil((1. - outlierPercent)*nPoints);</span>
        
        long nMaxIter;
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (nPoints == nSet) {</span>
<span class="fc" id="L175">            nMaxIter = 1;</span>
<span class="fc" id="L176">            useAllSubsets = true;</span>
        } else {
            /* The number of subsamples required to ensure T &gt;= 0.95 
            for given outlierPercent as fraction of contaminated data, 
            where T is the probability that all the data 
            points selected in one subsample are non-outliers.
            */
<span class="fc" id="L183">            nMaxIter = RANSACAlgorithmIterations</span>
<span class="fc" id="L184">                .numberOfSubsamplesOfSize7For95PercentInliers(outlierPercent);</span>
            
        }
        
<span class="fc" id="L188">        System.out.println(&quot;nPoints=&quot; + nPoints + &quot; estimate for nMaxIter=&quot; +</span>
            nMaxIter + &quot;, (n!/(k!*(n-k)!)=&quot; + nPointsSubsets);

<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (nMaxIter &gt; nPointsSubsets) {</span>
<span class="fc" id="L192">            nMaxIter = nPointsSubsets;</span>
<span class="fc" id="L193">            useAllSubsets = true;</span>
        }
        
<span class="fc" id="L196">        int nIter = 0;</span>
        
<span class="fc" id="L198">        int[] selectedIndexes = new int[nSet];</span>
        
<span class="fc" id="L200">        DenseMatrix sampleLeft = new DenseMatrix(3, nSet);</span>
<span class="fc" id="L201">        DenseMatrix sampleRight = new DenseMatrix(3, nSet);</span>
        // initialize the unchanging 3rd dimension
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (int i = 0; i &lt; nSet; ++i) {</span>
<span class="fc" id="L204">            sampleLeft.set(2, i, 1);</span>
<span class="fc" id="L205">            sampleRight.set(2, i, 1);</span>
        }
        
<span class="fc" id="L208">        SubsetChooser chooser = new SubsetChooser(nPoints, nSet);</span>
        
<span class="fc" id="L210">        Distances distances = new Distances();</span>
        
<span class="fc bfc" id="L212" title="All 2 branches covered.">        while (nIter &lt; nMaxIter) {</span>
            
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (useAllSubsets) {</span>
<span class="fc" id="L215">                int chk = chooser.getNextSubset(selectedIndexes);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                if (chk == -1) {</span>
<span class="nc" id="L217">                    throw new IllegalStateException(&quot;have overrun subsets in chooser.&quot;);</span>
                }                
<span class="fc" id="L219">            } else {</span>
<span class="fc" id="L220">                MiscMath.chooseRandomly(sr, selectedIndexes, nPoints);</span>
            }
            
<span class="fc" id="L223">            Arrays.sort(selectedIndexes);</span>

<span class="fc" id="L225">            int count = 0;</span>
            
<span class="fc bfc" id="L227" title="All 2 branches covered.">            for (int bitIndex : selectedIndexes) {</span>

<span class="fc" id="L229">                int idx = bitIndex;</span>

<span class="fc" id="L231">                sampleLeft.set(0, count, leftCorres.get(0, idx));</span>
<span class="fc" id="L232">                sampleLeft.set(1, count, leftCorres.get(1, idx));</span>
                                
<span class="fc" id="L234">                sampleRight.set(0, count, rightCorres.get(0, idx));</span>
<span class="fc" id="L235">                sampleRight.set(1, count, rightCorres.get(1, idx));</span>
                
<span class="fc" id="L237">                count++;</span>
            }
            
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (EpipolarTransformer.isDegenerate(sampleLeft, sampleRight)) {</span>
<span class="fc" id="L241">                nIter++;</span>
<span class="fc" id="L242">                continue;</span>
            }
            
            // calculates 7-point solutions then filters using chirality checks.
<span class="fc" id="L246">            List&lt;DenseMatrix&gt; fms = spTransformer</span>
<span class="fc" id="L247">                .calculateEpipolarProjectionFor7Points(sampleLeft, sampleRight);</span>
            
<span class="pc bpc" id="L249" title="1 of 4 branches missed.">            if (fms == null || fms.isEmpty()) {</span>
<span class="fc" id="L250">                nIter++;</span>
<span class="fc" id="L251">                continue;</span>
            }
            
            // evaluate fms solutions on all points and keep best and compare
            // that to best overall solution
            
<span class="fc" id="L257">            EpipolarTransformationFit fit = null;</span>
            
            // fit.isBetter() : comparison to other fit by the number of 
            //     inliers, else if tie, mean of errors, else if tie, 
            //     mean of standard deviation of mean of errors, else 
            //     returns false
<span class="fc bfc" id="L263" title="All 2 branches covered.">            for (DenseMatrix fm : fms) {</span>
                
<span class="fc" id="L265">                EpipolarTransformationFit fitI = null;</span>
                // evaluate all points using the solution from the sub-sample
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">                if (useToleranceAsStatFactor) {</span>
<span class="fc" id="L268">                    fitI = distances.calculateError2(fm,</span>
                        leftCorres, rightCorres, errorType, tolerance);
                } else {
<span class="nc" id="L271">                    fitI = distances.calculateError(fm,</span>
                        leftCorres, rightCorres, errorType, tolerance);
                }
                
<span class="fc" id="L275">                int nInliers = fitI.getInlierIndexes().size();</span>
<span class="fc bfc" id="L276" title="All 4 branches covered.">                if (nInliers &gt;= nSet &amp;&amp; fitI.isBetter(fit)) {</span>
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">                    if (nInliers &gt; t &amp;&amp; nInliers &gt; nSet) {</span>
                        // redo the FM transformation with all inliers
<span class="fc" id="L279">                        DenseMatrix inliersLeftXY = EpipolarTransformer</span>
<span class="fc" id="L280">                            .extractIndices(leftCorres, fitI.getInlierIndexes());</span>
<span class="fc" id="L281">                        DenseMatrix inliersRightXY = EpipolarTransformer</span>
<span class="fc" id="L282">                            .extractIndices(rightCorres, fitI.getInlierIndexes());</span>
                        
<span class="fc" id="L284">                        DenseMatrix fm2 = spTransformer.calculateEpipolarProjection(</span>
                            inliersLeftXY, inliersRightXY, calibrated);
                        
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                        if (fm2 != null) {</span>
<span class="fc" id="L288">                            EpipolarTransformationFit fit2 = null;</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                            if (useToleranceAsStatFactor) {</span>
<span class="fc" id="L290">                                fit2 = distances.calculateError2(fm2,</span>
                                    leftCorres, rightCorres, errorType, tolerance);
                            } else {
<span class="nc" id="L293">                                fit2 = distances.calculateError(fm2,</span>
                                    leftCorres, rightCorres, errorType, tolerance);
                            }
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">                            if (fit2 != null &amp;&amp; fit2.isBetter(fitI)) {</span>
<span class="fc" id="L297">                                fitI = fit2;</span>
                            }
                        }
                    }
                    //System.out.println(&quot; new local best fit: &quot; + fitI.toString());
                    //System.out.flush();
<span class="fc" id="L303">                    fit = fitI;</span>
                }
<span class="fc" id="L305">            }</span>
                        
<span class="fc bfc" id="L307" title="All 2 branches covered.">            if (fit == null) {</span>
<span class="fc" id="L308">                nIter++;</span>
<span class="fc" id="L309">                continue;</span>
            }
                        
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (fit.isBetter(bestFit)) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">                int nb = (bestFit != null) ? bestFit.getInlierIndexes().size() : nSet+1;</span>
<span class="fc" id="L314">                int nf = fit.getInlierIndexes().size();</span>
                
<span class="fc" id="L316">                bestFit = fit;</span>
                
                //System.out.println(&quot;**best fit: &quot; + bestFit.toString());
                //System.out.flush();
                
                // recalculate nMaxIter
<span class="pc bpc" id="L322" title="1 of 6 branches missed.">                if (reCalcIterations &amp;&amp; (nf &gt; nb) &amp;&amp; nMaxIter &gt; 1) {</span>
<span class="fc" id="L323">                    double outlierPercentI = 100.*</span>
<span class="fc" id="L324">                        (double)(nPoints - bestFit.getInlierIndexes().size()) / (double)nPoints;</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                    if (outlierPercentI &lt; outlierPercent) {</span>
<span class="fc" id="L326">                        outlierPercent = (int)Math.ceil(outlierPercentI);</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">                        if (outlierPercent &lt; 5) {</span>
<span class="fc" id="L328">                            outlierPercent = 5;</span>
                        }
<span class="pc bpc" id="L330" title="3 of 4 branches missed.">                        assert(outlierPercent &lt; 50);</span>
<span class="fc" id="L331">                        nMaxIter = RANSACAlgorithmIterations</span>
<span class="fc" id="L332">                            .numberOfSubsamplesOfSize7For95PercentInliers(outlierPercent);</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                        if (nMaxIter &gt; nPointsSubsets) {</span>
<span class="nc" id="L334">                            nMaxIter = nPointsSubsets;</span>
<span class="nc" id="L335">                            useAllSubsets = true;</span>
                        }
                    }
                }
            }                
            
<span class="fc" id="L341">            nIter++;</span>
<span class="fc" id="L342">        }</span>
        
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (bestFit == null) {</span>
<span class="fc" id="L345">            log.info(&quot;no solution.  nIter=&quot; + nIter);</span>
<span class="fc" id="L346">            return null;</span>
        }
        
<span class="fc" id="L349">        log.info(&quot;nIter=&quot; + nIter);</span>
        
<span class="fc" id="L351">        log.fine(&quot;final best fit to all points: &quot; + bestFit.toString());</span>

<span class="fc" id="L353">        return bestFit;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
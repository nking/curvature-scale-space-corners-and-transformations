<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RANSACSolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">RANSACSolver.java</span></div><h1>RANSACSolver.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.SubsetChooser;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.imageProcessing.transform.Distances;
import algorithms.imageProcessing.transform.EpipolarTransformationFit;
import algorithms.imageProcessing.transform.EpipolarTransformer;
import algorithms.imageProcessing.transform.Util;
import algorithms.imageProcessing.util.RANSACAlgorithmIterations;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;

/**
 * given matched point lists, determine the best epipolar solution using a
 * 7-point epipolar calculation and random draws of 7 points from the
 * matched point lists under the assumption that some of the matched points
 * are not true (correct) matches.
 *
 * from wikipedia:
Random sample consensus (RANSAC) is an iterative method to estimate parameters 
of a mathematical model from a set of observed data that contains outliers, 
when outliers are to be accorded no influence on the values of the estimates. 
Subsets are drawn from the sample a number of times such that the probability of drawing
a sample that is a specified percentage of inliers is met.  The best model is determined from the best fitting
subset and that model is then applied to all data.
calculating the number of iterations needed for finding a subset that is all inliers is
an important part of the algorithm to keep the runtime tractable.
* 
 * &lt;pre&gt;
 * useful reading:
 * add references in comments below here..
 * 
 * http://6.869.csail.mit.edu/fa12/lectures/lecture13ransac/lecture13ransac.pdf
 * and
 * http://www.dtic.mil/dtic/tr/fulltext/u2/a460585.pdf
 * &lt;/pre&gt;
 *
 * Note: to compare different geometric model results:
 * &lt;pre&gt;
    The plunder-dl scoring can be used for comparison between different models.
    for example, comparing results of the 7-point and 8-point 
    solutions or comparing 7-point projection to 6-point affine, etc.

    plunder-dl is from equation 33 of
    Torr, Zisserman, &amp; Maybank 1996, 
    â€œRobust Detection of Degenerate Configurations whilst Estimating 
    the Fundamental Matrix&quot;
    https://www.robots.ox.ac.uk/~phst/Papers/CVIU97/m.ps.gz
     EQN 33: PL = DOF + (4*n_o + n_i dimension of model)
                   where n_i = number of inliers
                   n_o = number of outliers
                   DOF = 7 for this solver
    n=7               PL = DOF + 4*n_o + n_i* (model_dimension)
         ni=7, no=0   PL = 7   + 0     + 0 * md
         ni=5, no=2   PL = 7   + 8     + 8 * md
         ni=4, no=3   PL = 7   + 12    + 28 * md
    PLUNDER stands for Pick Least UNDEgenerate Randomly, Description Length

    For nPoints=8, model_dimension = 1.
    for nPoints=7 amd only 1 solution in the cubic constraints, model_dimension=2,
    else for nPoints=7, model_dimension = 3.
 * &lt;/pre&gt;
 * @author nichole
 */
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">public class RANSACSolver {</span>
    
    //TODO: edit to be able to choose nSet = 8 or 7

<span class="fc" id="L75">    private boolean debug = true;</span>

<span class="fc" id="L77">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * calculate the epipolar transformation among the given points with the
     * assumption that some of the points in the matched lists are not
     * true matches.   NOTE: for best results, one should perform unit standard
     * normalization on the correspondence first.
     *
     * @param leftCorres left correspondence holding (x,y) points from left image
     * in format 3 X nData matrix with rows being x, y, and 1's respectively
     * @param rightCorres right correspondence holding (x,y) points from left image
     * in format 3 X nData matrix with rows being x, y, and 1's respectively
     * @param errorType algorithm used to evaluate the fit of the fundamental matrix solutions.
     * @param useToleranceAsStatFactor if set to false, tolerance is used as
     * a fixed number in outlier removal, else if set to true, tolerance
     * is used as the chi-squared statistic factor for the standard deviation
     * of errors use in outlier removal.
     * @param tolerance tolerance in distance from epipolar line for a point to 
     * be an inlier in the final fit.   NOTE: if useToleranceAsStatFactor is true,
     * it is interpreted as a chiSqStatFactor which is then used as 
     * tolerance = tolerance * standard deviation of the mean distance errors.
     * @param reCalcIterations if true, upon each better fit found, the 
     * outlier percentage is re-estimated and then the number of iterations necessary for 95%
     * probability that sample has all good points.
     * @param calibrated if true, solves for the Essential Matrix, else solves
     * for the Fundamental Matrix.  The difference is in the diagonal used for
     * dimension reduction.
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarProjection(
        final DenseMatrix leftCorres, final DenseMatrix rightCorres,
        ErrorType errorType,
        boolean useToleranceAsStatFactor, final double tolerance,
        boolean reCalcIterations, boolean calibrated) {
        
<span class="fc" id="L112">        int nPoints = leftCorres.numColumns();</span>
<span class="fc" id="L113">        final int nSet = 7;</span>
        
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (nPoints &lt; nSet) {</span>
            // cannot use this algorithm.
<span class="nc" id="L117">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot;
<span class="nc" id="L119">                + &quot; leftCorres.n=&quot; + leftCorres.numColumns());</span>
        }
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (leftCorres.numRows() != 3) {</span>
            // cannot use this algorithm.
<span class="nc" id="L123">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 3 rows representing x, y, and '1' values.&quot;
<span class="nc" id="L125">                + &quot; leftCorres.n=&quot; + leftCorres.numColumns());</span>
        }
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (leftCorres.numColumns() != rightCorres.numColumns() ||</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">            leftCorres.numRows() != rightCorres.numRows()) {</span>
<span class="nc" id="L129">            throw new IllegalArgumentException(</span>
                &quot;leftCorres and rightCorres bmust be the same size&quot;);
        }

        /*        
        Using 7 point samples for epipolar transformation fits.
        -- the number of iterations for testing sub-samples of nPoints 
           (each of size 7) and finding one to be a good sub-sample with an
           excess of probability of 95% is estimated for a given
           percent of bad data.
           NOTE, the algorithm proceeds by assuming 50% bad data and improves
           that upon each best fitting sub-sample.
        -- for each iteration of solving epipolar transformation using a sample
           of size 7, the resulting fundamental matrix is evaluated on the
           all points of the dataset.
           If the number of inliers is T or more, the fit is re-done with all
           of the points, where 
               T = (1. - outlierPercentage) * (total number of data points)
           The best fitting for all iterations as defined by number of inliers 
           and standard deviation from an epipolar line, is kept each time.
        -- at the end of each iteration, the number of iterations is then 
           re-calculated if it can be reduced.
        
        NOTE that the sub-samples are selected randomly from all possible
        sub-samples of the nPoints unless the number of all possible 
        sub-samples is smaller than the expected number of iterations for 95%
        probability of a good sub-sample.  In the later case, all sub-samples
        are tried.
        
        */
       
        // n!/(k!*(n-k)!
<span class="fc" id="L161">        final long nPointsSubsets = MiscMath.computeNDivKTimesNMinusK(nPoints, nSet);</span>
<span class="fc" id="L162">        boolean useAllSubsets = false;</span>
        
<span class="fc" id="L164">        SecureRandom sr = Misc.getSecureRandom();</span>
<span class="fc" id="L165">        long seed = System.currentTimeMillis();</span>
<span class="fc" id="L166">        log.info(&quot;SEED=&quot; + seed + &quot; nPoints=&quot; + nPoints);</span>
<span class="fc" id="L167">        sr.setSeed(seed);</span>

<span class="fc" id="L169">        EpipolarTransformer spTransformer = new EpipolarTransformer();</span>
                
        // consensus best fit and inlier indexes
<span class="fc" id="L172">        EpipolarTransformationFit bestFit = null;</span>
        
        /*
        could consider a threshold max iteration based upon the image size such
        as in (http://phototour.cs.washington.edu/ModelingTheWorld_ijcv07.pdf)
        which uses 0.6% of the maximum image dimension.
        */
        
<span class="fc" id="L180">        int outlierPercent = 50;</span>
<span class="fc" id="L181">        int t = (int)Math.ceil((1. - (outlierPercent/100.))*nPoints);</span>
        
        long nMaxIter;
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (nPoints == nSet) {</span>
<span class="fc" id="L185">            nMaxIter = 1;</span>
<span class="fc" id="L186">            useAllSubsets = true;</span>
        } else {
            /* The number of subsamples required to ensure T &gt;= 0.95 
            for given outlierPercent as fraction of contaminated data, 
            where T is the probability that all the data 
            points selected in one subsample are non-outliers.
            */
<span class="fc" id="L193">            nMaxIter = RANSACAlgorithmIterations</span>
<span class="fc" id="L194">                .numberOfSubsamplesOfSize7For95PercentInliers(outlierPercent);</span>
            
        }
        
<span class="fc" id="L198">        System.out.println(&quot;nPoints=&quot; + nPoints + &quot; estimate for nMaxIter=&quot; +</span>
            nMaxIter + &quot;, (n!/(k!*(n-k)!)=&quot; + nPointsSubsets);

<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (nMaxIter &gt; nPointsSubsets) {</span>
<span class="fc" id="L202">            nMaxIter = nPointsSubsets;</span>
<span class="fc" id="L203">            useAllSubsets = true;</span>
        }
        
<span class="fc" id="L206">        int nIter = 0;</span>
        
<span class="fc" id="L208">        int[] selectedIndexes = new int[nSet];</span>
        
<span class="fc" id="L210">        DenseMatrix sampleLeft = new DenseMatrix(3, nSet);</span>
<span class="fc" id="L211">        DenseMatrix sampleRight = new DenseMatrix(3, nSet);</span>
        // initialize the unchanging 3rd dimension
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (int i = 0; i &lt; nSet; ++i) {</span>
<span class="fc" id="L214">            sampleLeft.set(2, i, 1);</span>
<span class="fc" id="L215">            sampleRight.set(2, i, 1);</span>
        }
        
<span class="fc" id="L218">        SubsetChooser chooser = new SubsetChooser(nPoints, nSet);</span>
        
<span class="fc" id="L220">        Distances distances = new Distances();</span>
        
<span class="fc bfc" id="L222" title="All 2 branches covered.">        while (nIter &lt; nMaxIter) {</span>
            
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (useAllSubsets) {</span>
<span class="fc" id="L225">                int chk = chooser.getNextSubset(selectedIndexes);</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                if (chk == -1) {</span>
<span class="nc" id="L227">                    throw new IllegalStateException(&quot;have overrun subsets in chooser.&quot;);</span>
                }                
<span class="fc" id="L229">            } else {</span>
<span class="fc" id="L230">                MiscMath.chooseRandomly(sr, selectedIndexes, nPoints);</span>
            }
            
<span class="fc" id="L233">            Arrays.sort(selectedIndexes);</span>

<span class="fc" id="L235">            int count = 0;</span>
            
<span class="fc bfc" id="L237" title="All 2 branches covered.">            for (int bitIndex : selectedIndexes) {</span>

<span class="fc" id="L239">                int idx = bitIndex;</span>

<span class="fc" id="L241">                sampleLeft.set(0, count, leftCorres.get(0, idx));</span>
<span class="fc" id="L242">                sampleLeft.set(1, count, leftCorres.get(1, idx));</span>
                                
<span class="fc" id="L244">                sampleRight.set(0, count, rightCorres.get(0, idx));</span>
<span class="fc" id="L245">                sampleRight.set(1, count, rightCorres.get(1, idx));</span>
                
<span class="fc" id="L247">                count++;</span>
            }
            
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (EpipolarTransformer.isDegenerate(sampleLeft, sampleRight)) {</span>
<span class="fc" id="L251">                nIter++;</span>
<span class="fc" id="L252">                continue;</span>
            }
            
            // calculates 7-point solutions then filters using chirality checks.
<span class="fc" id="L256">            List&lt;DenseMatrix&gt; fms = spTransformer</span>
<span class="fc" id="L257">                .calculateEpipolarProjectionFor7Points(sampleLeft, sampleRight);</span>
            
<span class="pc bpc" id="L259" title="1 of 4 branches missed.">            if (fms == null || fms.isEmpty()) {</span>
<span class="fc" id="L260">                nIter++;</span>
<span class="fc" id="L261">                continue;</span>
            }
            
            // evaluate fms solutions on all points and keep best and compare
            // that to best overall solution
            
<span class="fc" id="L267">            EpipolarTransformationFit fit = null;</span>
            
            // fit.isBetter() : comparison to other fit by the number of 
            //     inliers, else if tie, mean of errors, else if tie, 
            //     mean of standard deviation of mean of errors, else 
            //     returns false
<span class="fc bfc" id="L273" title="All 2 branches covered.">            for (DenseMatrix fm : fms) {</span>
                
<span class="fc" id="L275">                EpipolarTransformationFit fitI = null;</span>
                // evaluate all points using the solution from the sub-sample
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                if (useToleranceAsStatFactor) {</span>
<span class="fc" id="L278">                    fitI = distances.calculateError2(fm,</span>
                        leftCorres, rightCorres, errorType, tolerance);
                } else {
<span class="nc" id="L281">                    fitI = distances.calculateError(fm,</span>
                        leftCorres, rightCorres, errorType, tolerance);
                }
                
<span class="fc" id="L285">                int nInliers = fitI.getInlierIndexes().size();</span>
<span class="fc bfc" id="L286" title="All 4 branches covered.">                if (nInliers &gt;= nSet &amp;&amp; fitI.isBetter(fit)) {</span>
<span class="fc bfc" id="L287" title="All 4 branches covered.">                    if (nInliers &gt; t &amp;&amp; nInliers &gt; nSet) {</span>
                        // redo the FM transformation with all inliers
<span class="fc" id="L289">                        DenseMatrix inliersLeftXY = EpipolarTransformer</span>
<span class="fc" id="L290">                            .extractIndices(leftCorres, fitI.getInlierIndexes());</span>
<span class="fc" id="L291">                        DenseMatrix inliersRightXY = EpipolarTransformer</span>
<span class="fc" id="L292">                            .extractIndices(rightCorres, fitI.getInlierIndexes());</span>
                        
<span class="fc" id="L294">                        DenseMatrix fm2 = spTransformer.calculateEpipolarProjection(</span>
                            inliersLeftXY, inliersRightXY, calibrated);
                        
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">                        if (fm2 != null) {</span>
<span class="fc" id="L298">                            EpipolarTransformationFit fit2 = null;</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">                            if (useToleranceAsStatFactor) {</span>
<span class="fc" id="L300">                                fit2 = distances.calculateError2(fm2,</span>
                                    leftCorres, rightCorres, errorType, tolerance);
                            } else {
<span class="nc" id="L303">                                fit2 = distances.calculateError(fm2,</span>
                                    leftCorres, rightCorres, errorType, tolerance);
                            }
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">                            if (fit2 != null &amp;&amp; fit2.isBetter(fitI)) {</span>
<span class="fc" id="L307">                                fitI = fit2;</span>
                            }
                        }
                    }
                    //System.out.println(&quot; new local best fit: &quot; + fitI.toString());
                    //System.out.flush();
<span class="fc" id="L313">                    fit = fitI;</span>
                }
<span class="fc" id="L315">            }</span>
                        
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if (fit == null) {</span>
<span class="nc" id="L318">                nIter++;</span>
<span class="nc" id="L319">                continue;</span>
            }
                        
<span class="fc bfc" id="L322" title="All 2 branches covered.">            if (fit.isBetter(bestFit)) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                int nb = (bestFit != null) ? bestFit.getInlierIndexes().size() : nSet+1;</span>
<span class="fc" id="L324">                int nf = fit.getInlierIndexes().size();</span>
                
<span class="fc" id="L326">                bestFit = fit;</span>
                
                //System.out.println(&quot;**best fit: &quot; + bestFit.toString());
                //System.out.flush();
                
                // recalculate nMaxIter
<span class="pc bpc" id="L332" title="1 of 6 branches missed.">                if (reCalcIterations &amp;&amp; (nf &gt; nb) &amp;&amp; nMaxIter &gt; 1) {</span>
<span class="fc" id="L333">                    double outlierPercentI = 100.*</span>
<span class="fc" id="L334">                        (double)(nPoints - bestFit.getInlierIndexes().size()) / (double)nPoints;</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                    if (outlierPercentI &lt; outlierPercent) {</span>
<span class="fc" id="L336">                        outlierPercent = (int)Math.ceil(outlierPercentI);</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                        if (outlierPercent &lt; 5) {</span>
<span class="fc" id="L338">                            outlierPercent = 5;</span>
                        }
<span class="pc bpc" id="L340" title="3 of 4 branches missed.">                        assert(outlierPercent &lt; 50);</span>
<span class="fc" id="L341">                        nMaxIter = RANSACAlgorithmIterations</span>
<span class="fc" id="L342">                            .numberOfSubsamplesOfSize7For95PercentInliers(outlierPercent);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                        if (nMaxIter &gt; nPointsSubsets) {</span>
<span class="nc" id="L344">                            nMaxIter = nPointsSubsets;</span>
<span class="nc" id="L345">                            useAllSubsets = true;</span>
                        }
                    }
                }
            }                
            
<span class="fc" id="L351">            nIter++;</span>
<span class="fc" id="L352">        }</span>
        
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (bestFit == null) {</span>
<span class="nc" id="L355">            log.info(&quot;no solution.  nIter=&quot; + nIter);</span>
<span class="nc" id="L356">            return null;</span>
        }
        
<span class="fc" id="L359">        log.info(&quot;nIter=&quot; + nIter);</span>
        
<span class="fc" id="L361">        log.fine(&quot;final best fit to all points: &quot; + bestFit.toString());</span>

<span class="fc" id="L363">        return bestFit;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
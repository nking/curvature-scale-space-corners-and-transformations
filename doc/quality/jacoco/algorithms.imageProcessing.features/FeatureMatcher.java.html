<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">FeatureMatcher.java</span></div><h1>FeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.compGeometry.PointInPolygon;
import algorithms.compGeometry.RotatedOffsets;
import algorithms.compGeometry.convexHull.GrahamScanPairInt;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.features.CornerRegion.CornerRegionDegneracyException;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.imageProcessing.transform.MatchedPointsTransformationCalculator;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;

<span class="pc bpc" id="L34" title="1 of 2 branches missed.">public class FeatureMatcher {</span>

<span class="fc" id="L36">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L38">    public FeatureMatcher() {</span>
<span class="fc" id="L39">    }</span>
      
    /**
     * same as ditherAndRotateForBestLocation2 except have added a filter
     * to remove matches with a cosine similarity larger than 0.95.
     * 
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1
     * @param img2
     * @return 
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation3(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L59">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L60">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L61">        int y1 = region1.getY()[kMaxIdx1];</span>

<span class="fc" id="L63">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L64">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L65">        int y2 = region2.getY()[kMaxIdx2];</span>

<span class="fc" id="L67">        return ditherAndRotateForBestLocation3(features1, features2,</span>
            x1, y1, x2, y2, dither, img1, img2);
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation2(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L76">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L77">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L78">        int y1 = region1.getY()[kMaxIdx1];</span>

<span class="fc" id="L80">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L81">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L82">        int y2 = region2.getY()[kMaxIdx2];</span>

<span class="fc" id="L84">        return ditherAndRotateForBestLocation2(features1, features2,</span>
            x1, y1, x2, y2, dither, img1, img2);
    }
    
    protected FeatureComparisonStat ditherAndRotateForBestLocation2(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int x2, final int y2,      
        int dither, GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L93">        FeatureComparisonStat best = null;</span>
        
        int rot2;
        try {
<span class="fc" id="L97">            rot2 = features2.calculateOrientation(x2, y2);</span>
<span class="nc" id="L98">        } catch (CornerRegionDegneracyException e) {</span>
<span class="nc" id="L99">            return null;</span>
<span class="fc" id="L100">        }</span>
        
<span class="fc" id="L102">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, rot2);</span>
        
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L105">            return null;</span>
        }
        
<span class="fc" id="L108">        int[] rotations = new int[3];</span>
        
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="fc" id="L112">                continue;</span>
            }
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="fc" id="L116">                    continue;</span>
                }
                
                int rot1;
                try {
<span class="fc" id="L121">                    rot1 = features1.calculateOrientation(x1d, y1d);</span>
<span class="nc" id="L122">                } catch (CornerRegionDegneracyException e) {</span>
<span class="nc" id="L123">                    continue;</span>
<span class="fc" id="L124">                }</span>
                // fetch rotation for this point (x1d, y1d) and try this
                // rotation and -20, -10, +10 and +20
<span class="fc" id="L127">                rotations[0] = rot1;</span>
<span class="fc" id="L128">                rotations[1] = rot1 - 10;</span>
<span class="fc" id="L129">                rotations[2] = rot1 + 10;</span>
                //rotations[3] = rot1 - 20;
                //rotations[4] = rot1 + 20;
        
<span class="fc bfc" id="L133" title="All 2 branches covered.">                for (int rotD1 : rotations) {</span>
                    
<span class="fc bfc" id="L135" title="All 2 branches covered.">                    if (rotD1 &gt; 359) {</span>
<span class="fc" id="L136">                        rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                    } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L138">                        rotD1 += 360;</span>
                    }
<span class="fc" id="L140">                    IntensityDescriptor desc1 = features1.extractIntensity(</span>
                        img1, x1d, y1d, rotD1);
        
<span class="fc bfc" id="L143" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L144">                        continue;</span>
                    }
                    
<span class="fc" id="L147">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L150" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L152" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L153">                            best = stat;</span>
<span class="fc" id="L154">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L155">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L157" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L158">                                best = stat;</span>
<span class="fc" id="L159">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L160">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L168">        return best;</span>
    }
    
    protected FeatureComparisonStat ditherAndRotateForBestLocation3(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int x2, final int y2,      
        int dither, GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L176">        FeatureComparisonStat best = null;</span>
        
        int rot2;
        try {
<span class="fc" id="L180">            rot2 = features2.calculateOrientation(x2, y2);</span>
<span class="nc" id="L181">        } catch (CornerRegionDegneracyException e) {</span>
<span class="nc" id="L182">            return null;</span>
<span class="fc" id="L183">        }</span>
        
<span class="fc" id="L185">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, rot2);</span>
        
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L188">            return null;</span>
        }
        
<span class="fc" id="L191">        int[] rotations = new int[3];</span>
        
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">            if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="nc" id="L195">                continue;</span>
            }
<span class="fc bfc" id="L197" title="All 2 branches covered.">            for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="nc" id="L199">                    continue;</span>
                }
                
                int rot1;
                try {
<span class="fc" id="L204">                    rot1 = features1.calculateOrientation(x1d, y1d);</span>
<span class="nc" id="L205">                } catch (CornerRegionDegneracyException e) {</span>
<span class="nc" id="L206">                    continue;</span>
<span class="fc" id="L207">                }</span>
                // fetch rotation for this point (x1d, y1d) and try this
                // rotation and -20, -10, +10 and +20
<span class="fc" id="L210">                rotations[0] = rot1;</span>
<span class="fc" id="L211">                rotations[1] = rot1 - 10;</span>
<span class="fc" id="L212">                rotations[2] = rot1 + 10;</span>
                //rotations[3] = rot1 - 20;
                //rotations[4] = rot1 + 20;
        
<span class="fc bfc" id="L216" title="All 2 branches covered.">                for (int rotD1 : rotations) {</span>
                    
<span class="fc bfc" id="L218" title="All 2 branches covered.">                    if (rotD1 &gt; 359) {</span>
<span class="fc" id="L219">                        rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                    } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L221">                        rotD1 += 360;</span>
                    }
<span class="fc" id="L223">                    IntensityDescriptor desc1 = features1.extractIntensity(</span>
                        img1, x1d, y1d, rotD1);
        
<span class="fc bfc" id="L226" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L227">                        continue;</span>
                    }
                    
<span class="fc" id="L230">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                    
<span class="fc" id="L233">                    float cSim = desc1.calculateCosineSimilarity(desc2);</span>
                    
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                    if (cSim &lt; 0.95) {</span>
<span class="nc" id="L236">                        continue;</span>
                    }
                   
<span class="fc bfc" id="L239" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L241" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L242">                            best = stat;</span>
<span class="fc" id="L243">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L244">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L246" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L247">                                best = stat;</span>
<span class="fc" id="L248">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L249">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L257">        return best;</span>
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation2(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        final int expectedRotationInDegrees, final int rotationTol,
        GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L266">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L267">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L268">        int y1 = region1.getY()[kMaxIdx1];</span>

<span class="fc" id="L270">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L271">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L272">        int y2 = region2.getY()[kMaxIdx2];</span>
        
<span class="fc" id="L274">        return ditherAndRotateForBestLocation2(features1, features2, </span>
            x1, y1, x2, y2, dither,
            expectedRotationInDegrees, rotationTol, img1, img2);
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation2(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int x2, final int y2,      
        int dither, int expectedRotationInDegrees,
        final int rotationTol, GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L285">        FeatureComparisonStat best = null;</span>
        
        int rot2;
        try {
<span class="fc" id="L289">            rot2 = features2.calculateOrientation(x2, y2);</span>
<span class="nc" id="L290">        } catch (CornerRegionDegneracyException e) {</span>
<span class="nc" id="L291">            return null;</span>
<span class="fc" id="L292">        }</span>
        
<span class="fc" id="L294">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, rot2);</span>
     
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L297">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="fc" id="L302">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
<span class="fc" id="L305">        int[] rotations = new int[3];</span>
        
<span class="fc bfc" id="L307" title="All 2 branches covered.">        for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">            if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="fc" id="L309">                continue;</span>
            }
<span class="fc bfc" id="L311" title="All 2 branches covered.">            for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="fc" id="L313">                    continue;</span>
                }
                
                int rot1;
                try {
<span class="fc" id="L318">                    rot1 = features1.calculateOrientation(x1d, y1d);</span>
<span class="nc" id="L319">                } catch (CornerRegionDegneracyException e) {</span>
<span class="nc" id="L320">                    continue;</span>
<span class="fc" id="L321">                }</span>
                // fetch rotation for this point (x1d, y1d) and try this
                // rotation and -20, -10, +10 and +20
<span class="fc" id="L324">                rotations[0] = rot1;</span>
<span class="fc" id="L325">                rotations[1] = rot1 - 10;</span>
<span class="fc" id="L326">                rotations[2] = rot1 + 10;</span>
                //rotations[3] = rot1 - 20;
                //rotations[4] = rot1 + 20;
                        
<span class="fc bfc" id="L330" title="All 2 branches covered.">                for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                    if (rotD1 &gt; 359) {</span>
<span class="fc" id="L332">                        rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                    } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L334">                        rotD1 += 360;</span>
                    }
            
                    // only try rotations within expected rotation limits
<span class="fc" id="L338">                    float rotDiffs = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                    if (rotDiffs &lt; 0) {</span>
<span class="fc" id="L340">                        rotDiffs *= -1;</span>
                    }
 //NOTE: change to rotDiffs to use -1* instead of 360+=             
<span class="fc" id="L343">                    float rotDiff = AngleUtil.getAngleDifference(</span>
                        expectedRotationInDegrees, rotDiffs);
<span class="fc bfc" id="L345" title="All 2 branches covered.">                    if (Math.abs(rotDiff) &gt; rotationTol) {</span>
<span class="fc" id="L346">                        continue;</span>
                    }
            
<span class="fc" id="L349">                    IntensityDescriptor desc1 = features1.extractIntensity(img1, </span>
                        x1d, y1d, rotD1);
        
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L353">                        continue;</span>
                    }
                    
<span class="fc" id="L356">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L359" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &gt; stat.getImg2PointIntensityErr()) {</span>
<span class="fc" id="L360">                        continue;</span>
                    }
<span class="fc bfc" id="L362" title="All 4 branches covered.">                    if ((best == null) || (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff())) {</span>
<span class="fc" id="L363">                        best = stat;</span>
<span class="fc" id="L364">                        best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L365">                        best.setImg2PointRotInDegrees(rot2);</span>
                    }
                }
            }
        }
        
<span class="fc" id="L371">        return best;</span>
    }
    
    public CorrespondenceList findSimilarFeatures(GreyscaleImage gsImg1, 
        CornerRegion[] cr1, GreyscaleImage gsImg2, 
        CornerRegion[] cr2, TransformationParameters params, float scaleTol, 
        float rotationInRadiansTol, int transXYTol, int dither,
        RotatedOffsets rotatedOffsets) {
      
<span class="nc" id="L380">        List&lt;FeatureComparisonStat&gt; stats = </span>
<span class="nc" id="L381">            findSimilarFeaturesAsStats(gsImg1, cr1, gsImg2, cr2, params, </span>
                scaleTol, rotationInRadiansTol, transXYTol, dither,
                rotatedOffsets);
        
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (stats == null) {</span>
<span class="nc" id="L386">            return null;</span>
        }
            
<span class="nc" id="L389">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L390">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="nc" id="L393">            matched1.add(stat.getImg1Point());</span>
<span class="nc" id="L394">            matched2.add(stat.getImg2Point());</span>
<span class="nc" id="L395">        }</span>
        
<span class="nc" id="L397">        int rangeRotation = Math.round(params.getStandardDeviations()[1]);</span>
<span class="nc" id="L398">        int rangeTranslationX = Math.round(params.getStandardDeviations()[2]);</span>
<span class="nc" id="L399">        int rangeTranslationY = Math.round(params.getStandardDeviations()[3]);</span>

<span class="nc" id="L401">        CorrespondenceList cl = new CorrespondenceList(params.getScale(),</span>
<span class="nc" id="L402">            Math.round(params.getRotationInDegrees()),</span>
<span class="nc" id="L403">            Math.round(params.getTranslationX()), Math.round(params.getTranslationY()),</span>
            rangeRotation, rangeTranslationX, rangeTranslationY,
            matched1, matched2);

<span class="nc" id="L407">        return cl;</span>
    }    
        
    public List&lt;FeatureComparisonStat&gt; findSimilarFeaturesAsStats(GreyscaleImage gsImg1, 
        CornerRegion[] cr1, GreyscaleImage gsImg2, 
        CornerRegion[] cr2, TransformationParameters params, float scaleTol, 
        float rotationInRadiansTol, int transXYTol, int dither,
        RotatedOffsets rotatedOffsets) {
        
<span class="fc" id="L416">        final int blockHalfWidth = 5;</span>
<span class="fc" id="L417">        final boolean useNormalizedIntensities = true;</span>
        
<span class="fc" id="L419">        IntensityFeatures features1 = new IntensityFeatures(blockHalfWidth, </span>
            useNormalizedIntensities, rotatedOffsets);
<span class="fc" id="L421">        features1.calculateGradientWithGreyscale(gsImg1);</span>
<span class="fc" id="L422">        IntensityFeatures features2 = new IntensityFeatures(blockHalfWidth,</span>
            useNormalizedIntensities, rotatedOffsets);
<span class="fc" id="L424">        features2.calculateGradientWithGreyscale(gsImg2);</span>
        
<span class="fc" id="L426">        List&lt;FeatureComparisonStat&gt; stats = findSimilarFeaturesAsStats(gsImg1, </span>
            cr1, gsImg2, cr2, features1, features2, params, scaleTol, 
            rotationInRadiansTol, transXYTol, dither, rotatedOffsets);
        
<span class="fc" id="L430">        return stats;</span>
    }    
    
    public List&lt;FeatureComparisonStat&gt; findSimilarFeaturesAsStats(
        GreyscaleImage gsImg1, CornerRegion[] cr1s, CornerRegion[] cr1Trs, 
        GreyscaleImage gsImg2, CornerRegion[] cr2s, 
        IntensityFeatures features1, IntensityFeatures features2, 
        TransformationParameters parameters, int dither, int transXYTol,  
        RotatedOffsets rotatedOffsets) {
        
        //for each combination of cr1 and cr2, find best stat if any between filters
        
<span class="nc" id="L442">        List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (int idx1 = 0; idx1 &lt; cr1s.length; ++idx1) {</span>
            
<span class="nc" id="L446">            CornerRegion cr1 = cr1s[idx1];</span>
<span class="nc" id="L447">            CornerRegion cr1Tr = cr1Trs[idx1];</span>
            
<span class="nc" id="L449">            int x1 = cr1.getX()[cr1.getKMaxIdx()];</span>
<span class="nc" id="L450">            int y1 = cr1.getY()[cr1.getKMaxIdx()];</span>
            
<span class="nc" id="L452">            FeatureComparisonStat bestStat = null;</span>
            
<span class="nc bnc" id="L454" title="All 2 branches missed.">            for (int idx2 = 0; idx2 &lt; cr2s.length; ++idx2) {</span>
                
<span class="nc" id="L456">                CornerRegion cr2 = cr2s[idx2];</span>
                
<span class="nc" id="L458">                int x2 = cr2.getX()[cr2.getKMaxIdx()];</span>
<span class="nc" id="L459">                int y2 = cr2.getY()[cr2.getKMaxIdx()];</span>
                
<span class="nc" id="L461">                double diffX = cr1Tr.getX()[cr1Tr.getKMaxIdx()] - x2;</span>
<span class="nc" id="L462">                double diffY = cr1Tr.getY()[cr1Tr.getKMaxIdx()] - y2;</span>
                                
<span class="nc bnc" id="L464" title="All 4 branches missed.">                if ((diffX &gt; transXYTol) || (diffY &gt; transXYTol)) {</span>
<span class="nc" id="L465">                    continue;</span>
                }
                                
<span class="nc" id="L468">                FeatureComparisonStat stat = ditherAndRotateForBestLocation2(</span>
                    features1, features2, x1, y1, x2, y2, dither, gsImg1, gsImg2);
                
<span class="nc bnc" id="L471" title="All 2 branches missed.">                if ((stat == null) || </span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                    (stat.getSumIntensitySqDiff() &gt; stat.getImg2PointIntensityErr())) {</span>
<span class="nc" id="L473">                    continue;</span>
                }
                
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if ((bestStat == null) ||</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                    stat.getSumIntensitySqDiff() &lt; bestStat.getSumIntensitySqDiff()) {</span>
                    
<span class="nc" id="L479">                    bestStat = stat;</span>
                }
            }
            
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (bestStat != null) {</span>
<span class="nc" id="L484">                stats.add(bestStat);</span>
            }
        }
        
<span class="nc" id="L488">        return stats;</span>
    }
    
    public List&lt;FeatureComparisonStat&gt; findSimilarFeaturesAsStats(GreyscaleImage gsImg1, 
        CornerRegion[] cr1, GreyscaleImage gsImg2, 
        CornerRegion[] cr2, IntensityFeatures features1, IntensityFeatures features2,
        TransformationParameters params, float scaleTol, 
        float rotationInRadiansTol, int transXYTol, int dither,
        RotatedOffsets rotatedOffsets) {
        
<span class="fc" id="L498">        List&lt;CornerRegion&gt; filteredTransformedC1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L499">        List&lt;CornerRegion&gt; filteredC1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L500">        List&lt;CornerRegion&gt; filteredC2 = new ArrayList&lt;CornerRegion&gt;();</span>
        
<span class="fc" id="L502">        filterForIntersection4(params, transXYTol, </span>
            cr1, cr2, filteredTransformedC1, filteredC1, filteredC2,
<span class="fc" id="L504">            gsImg1.getWidth(), gsImg1.getHeight(), gsImg2.getWidth(), gsImg2.getHeight());</span>

        if (true) {
            try {
<span class="fc" id="L508">                MiscDebug.writeImage(filteredC1, gsImg1.copyToColorGreyscale(),</span>
                    &quot;filtered_1_corners_&quot;);
<span class="fc" id="L510">                MiscDebug.writeImage(filteredC2, gsImg2.copyToColorGreyscale(), </span>
                    &quot;filtered_2_corners_&quot;);
<span class="fc" id="L512">                MiscDebug.writeImage(filteredTransformedC1, gsImg2.copyToColorGreyscale(), </span>
                    &quot;filtered_1_trans_corners_&quot;);
<span class="nc" id="L514">            } catch (IOException ex) {</span>
<span class="nc" id="L515">                Logger.getLogger(FeatureMatcher.class.getName()).log(</span>
                    Level.SEVERE, null, ex);
<span class="fc" id="L517">            }</span>
        }
        
<span class="fc" id="L520">        int n1 = filteredC1.size();</span>
<span class="fc" id="L521">        int n2 = filteredC2.size();</span>
        
        /*
        when transformation params are known ahead of time:
        cr1 can be transformed into crTr1 (including the internal points).
        then the matching is faster than n1 * n2 because can discard some 
        possible matches immediately.
        bipartite matching when points are present within tolerance.
        
        bipartite is n^3 but the n is &lt; n1.
        */
               
<span class="fc" id="L533">        Map&lt;PairInt, FeatureComparisonStat&gt; statMap = null;</span>
<span class="fc" id="L534">        float[][] cost = null;</span>
                
<span class="fc" id="L536">        final boolean useBipartite = false;//(nMaxMatchable &lt; 251);</span>
        
<span class="fc" id="L538">        Map&lt;Integer, Integer&gt; index1Map = null;</span>
<span class="fc" id="L539">        Map&lt;Integer, Set&lt;Integer&gt;&gt; index2Map = null;</span>
<span class="fc" id="L540">        Map&lt;Integer, FeatureComparisonStat&gt; index1StatMap = null;</span>
        
        if (useBipartite) {
            cost = new float[n1][n2];
            statMap = new HashMap&lt;PairInt, FeatureComparisonStat&gt;();
        } else {
<span class="fc" id="L546">            index1Map = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L547">            index2Map = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L548">            index1StatMap = new HashMap&lt;Integer, FeatureComparisonStat&gt;();</span>
        }
        
<span class="fc" id="L551">        int rotationInDegrees = Math.round(params.getRotationInDegrees());</span>
<span class="fc" id="L552">        int rotationToleranceInDegrees = (int)Math.round(rotationInRadiansTol * 180/Math.PI);</span>
                
<span class="fc" id="L554">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L556">        int count = 0;</span>
        
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n1; ++i1) {</span>
            
            if (useBipartite) {
                cost[i1] = new float[n2];
                Arrays.fill(cost[i1], Float.MAX_VALUE);
            }
            
<span class="fc" id="L565">            CornerRegion c1Tr = filteredTransformedC1.get(i1);</span>
<span class="fc" id="L566">            CornerRegion c1 = filteredC1.get(i1);</span>
            
<span class="fc" id="L568">            int x1Tr = c1Tr.getX()[c1Tr.getKMaxIdx()];</span>
<span class="fc" id="L569">            int y1Tr = c1Tr.getY()[c1Tr.getKMaxIdx()];</span>
            
<span class="fc" id="L571">            int x1 = c1.getX()[c1.getKMaxIdx()];</span>
<span class="fc" id="L572">            int y1 = c1.getY()[c1.getKMaxIdx()];</span>
            
            // additional tolerance due to rotation error of 10 degrees
<span class="fc" id="L575">            double[] errTr = transformer.applyTransformation(params.getScale(),</span>
<span class="fc" id="L576">                params.getRotationInRadians() + 0.1745,</span>
<span class="fc" id="L577">                params.getOriginX(), params.getOriginY(),</span>
<span class="fc" id="L578">                params.getTranslationX(), params.getTranslationY(), x1, y1);</span>
            
<span class="fc" id="L580">            double xTolAdd = Math.abs(errTr[0] - x1Tr);</span>
<span class="fc" id="L581">            double yTolAdd = Math.abs(errTr[1] - y1Tr);</span>
            
<span class="fc" id="L583">            double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L584">            int bestIdx2 = -1;</span>
<span class="fc" id="L585">            FeatureComparisonStat bestStat = null;</span>
            
//TODO: replace w/ a nearest neighbors structure ***** &lt;=====
            
<span class="fc bfc" id="L589" title="All 2 branches covered.">            for (int i2 = 0; i2 &lt; n2; ++i2) {</span>
                
<span class="fc" id="L591">                CornerRegion c2 = filteredC2.get(i2);</span>
                
<span class="fc" id="L593">                int x2 = c2.getX()[c2.getKMaxIdx()];</span>
<span class="fc" id="L594">                int y2 = c2.getY()[c2.getKMaxIdx()];</span>
                                
<span class="fc" id="L596">                int diffX = Math.abs(x1Tr - x2);</span>
<span class="fc" id="L597">                int diffY = Math.abs(y1Tr - y2);</span>
<span class="fc bfc" id="L598" title="All 4 branches covered.">                if (diffX &gt; (transXYTol + xTolAdd) || diffY &gt; (transXYTol + yTolAdd)) {</span>
<span class="fc" id="L599">                    continue;</span>
                }
                // use the untransformed cr1 to be able to filter by rotation
<span class="fc" id="L602">                FeatureComparisonStat stat = ditherAndRotateForBestLocation2(</span>
                    features1, features2, c1, c2, dither,
                    rotationInDegrees, rotationToleranceInDegrees,
                    gsImg1, gsImg2);

<span class="fc bfc" id="L607" title="All 2 branches covered.">                if (stat != null &amp;&amp; </span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">                    (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr())) {</span>

                    if (useBipartite) {
                        cost[i1][i2] = stat.getSumIntensitySqDiff();
                        PairInt p = new PairInt(i1, i2);
                        statMap.put(p, stat);
                    } else {
<span class="fc bfc" id="L615" title="All 4 branches covered.">                        if ((bestIdx2 == -1) || (bestCost &gt; stat.getSumIntensitySqDiff())) {</span>
<span class="fc" id="L616">                            bestIdx2 = i2;</span>
<span class="fc" id="L617">                            bestCost = stat.getSumIntensitySqDiff();</span>
<span class="fc" id="L618">                            bestStat = stat;</span>
<span class="fc" id="L619">                            bestStat.setIndex1(i1);</span>
<span class="fc" id="L620">                            bestStat.setIndex2(i2);</span>
                        }
                    }

<span class="fc" id="L624">                    count++;</span>
                }
            }
            
<span class="fc bfc" id="L628" title="All 2 branches covered.">            if (!useBipartite &amp;&amp; (bestStat != null)) {</span>
<span class="fc" id="L629">                Integer key1 = Integer.valueOf(i1);</span>
<span class="fc" id="L630">                Integer key2 = Integer.valueOf(bestIdx2);</span>
<span class="fc" id="L631">                index1Map.put(key1, key2);</span>
<span class="fc" id="L632">                Set&lt;Integer&gt; set = index2Map.get(key2);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">                if (set == null) {</span>
<span class="fc" id="L634">                    set = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L635">                    index2Map.put(key2, set);</span>
                }
<span class="fc" id="L637">                set.add(key1);</span>
                
<span class="fc" id="L639">                index1StatMap.put(key1, bestStat);</span>
            }
        }
        
        if (useBipartite) {
            return useBipartiteMatchingAsStats(cost, statMap, params);
        }
        
        // resolve any double matchings, but discard the higher cost matches
        //   from conflicted matches rather than re-trying a solution for them
        
<span class="fc" id="L650">        Set&lt;Integer&gt; resolved = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : index2Map.entrySet()) {</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">            if (resolved.contains(entry.getKey())) {</span>
<span class="fc" id="L653">                continue;</span>
            }
<span class="fc" id="L655">            Set&lt;Integer&gt; set = entry.getValue();</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">            if (set.size() &gt; 1) {</span>
<span class="fc" id="L657">                double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L658">                Integer bestIndex1 = -1;</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">                for (Integer index1 : set) {</span>
<span class="fc" id="L660">                    FeatureComparisonStat fcs = index1StatMap.get(index1);</span>
<span class="pc bpc" id="L661" title="3 of 4 branches missed.">                    assert(fcs != null);</span>
<span class="fc" id="L662">                    double cost2 = fcs.getSumIntensitySqDiff();</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">                    if (cost2 &lt; bestCost) {</span>
<span class="fc" id="L664">                        bestCost = cost2;</span>
<span class="fc" id="L665">                        bestIndex1 = index1;</span>
                    }
<span class="fc" id="L667">                    resolved.add(index1);</span>
<span class="fc" id="L668">                }</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                for (Integer index1 : set) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                    if (index1.equals(bestIndex1)) {</span>
<span class="fc" id="L671">                        continue;</span>
                    }
<span class="fc" id="L673">                    index1Map.remove(index1);</span>
<span class="fc" id="L674">                    index1StatMap.remove(index1);</span>
<span class="fc" id="L675">                }</span>
            }
<span class="fc" id="L677">        }</span>
        
<span class="fc" id="L679">        int nc = index1StatMap.size();</span>
        
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (nc &lt; 7) {</span>
<span class="fc" id="L682">            return null;</span>
        }
        
<span class="fc" id="L685">        List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="fc" id="L687">        float[] weights = new float[nc];</span>
<span class="fc" id="L688">        double sumW = 0;</span>

<span class="fc" id="L690">        nc = 0;</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">        for (Entry&lt;Integer, FeatureComparisonStat&gt; entry : index1StatMap.entrySet()) {</span>
<span class="fc" id="L692">            FeatureComparisonStat fcs = entry.getValue();</span>
<span class="fc" id="L693">            stats.add(fcs);</span>
<span class="fc" id="L694">            weights[nc] = fcs.getSumIntensitySqDiff();</span>
<span class="fc" id="L695">            sumW += weights[nc];</span>
<span class="fc" id="L696">            nc++;</span>
<span class="fc" id="L697">        }</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        if (sumW &gt; 0) {</span>
<span class="fc" id="L699">            double tot = 0;</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">            for (int i = 0; i &lt; nc; ++i) {</span>
<span class="fc" id="L701">                double div = (sumW - weights[i]) / ((nc - 1) * sumW);</span>
<span class="fc" id="L702">                weights[i] = (float) div;</span>
<span class="fc" id="L703">                tot += div;</span>
            }
<span class="pc bpc" id="L705" title="3 of 4 branches missed.">            assert (Math.abs(tot - 1.) &lt; 0.03);</span>
<span class="fc" id="L706">        } else {</span>
<span class="nc" id="L707">            float a = 1.f / (float) nc;</span>
<span class="nc" id="L708">            Arrays.fill(weights, a);</span>
        }

<span class="fc" id="L711">        return stats;</span>
    }
    
    public static float[] calculateThetaDiff(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="nc bnc" id="L716" title="All 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L717">            return null;</span>
        }
        
<span class="nc" id="L720">        float[] values = new float[compStats.size()];</span>
        
<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="nc" id="L724">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="nc" id="L726">            float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L727">                stat.getImg1PointRotInDegrees(), stat.getImg2PointRotInDegrees());</span>
            
<span class="nc" id="L729">            values[i] = diff;</span>
        }
        
<span class="nc" id="L732">        return values;</span>
    }

    public static void filterForIntersection3(TransformationParameters params, 
        int transXYTol, CornerRegion[] c1, CornerRegion[] c2, 
        List&lt;CornerRegion&gt; outFilteredTransformedC1, 
        List&lt;CornerRegion&gt; outFilteredC1, 
        List&lt;CornerRegion&gt; outFilteredC2,
        int img1Width, int img1Height, int img2Width, int img2Height) {
        
        /*
        transform corners1 to image2 reference frame and trim any points
           in it that are out of the image2 frame.
        then make a
        */
        
<span class="nc" id="L748">        MatchedPointsTransformationCalculator tc = </span>
            new MatchedPointsTransformationCalculator();
        
<span class="nc" id="L751">        Transformer transformer = new Transformer();</span>
        
<span class="nc" id="L753">        TransformationParameters revParams = tc.swapReferenceFrames(params);</span>
        
<span class="nc bnc" id="L755" title="All 2 branches missed.">        for (int i = 0; i &lt; c1.length; ++i) {</span>
                        
<span class="nc" id="L757">            CornerRegion ctr = transformer.applyTransformation(params, c1[i]);</span>
                
<span class="nc" id="L759">            int xTr = ctr.getX()[ctr.getKMaxIdx()];</span>
<span class="nc" id="L760">            int yTr = ctr.getY()[ctr.getKMaxIdx()];</span>

<span class="nc bnc" id="L762" title="All 4 branches missed.">            if ((xTr &lt; 0) || (xTr &gt; (img2Width - 1))) {</span>
<span class="nc" id="L763">                continue;</span>
            }
<span class="nc bnc" id="L765" title="All 4 branches missed.">            if ((yTr &lt; 0) || (yTr &gt; (img2Height - 1))) {</span>
<span class="nc" id="L766">                continue;</span>
            }

<span class="nc" id="L769">            outFilteredTransformedC1.add(ctr);</span>
<span class="nc" id="L770">            outFilteredC1.add(c1[i]);</span>
            
        }

<span class="nc bnc" id="L774" title="All 2 branches missed.">        for (int i = 0; i &lt; c2.length; ++i) {</span>
                        
<span class="nc" id="L776">            int x = c2[i].getX()[c2[i].getKMaxIdx()];</span>
<span class="nc" id="L777">            int y = c2[i].getY()[c2[i].getKMaxIdx()];</span>
            
<span class="nc" id="L779">            double[] xyTr = transformer.applyTransformation(revParams, x, y);</span>
                            
<span class="nc bnc" id="L781" title="All 4 branches missed.">            if ((xyTr[0] &lt; 0) || (xyTr[0] &gt; (img1Width - 1))) {</span>
<span class="nc" id="L782">                continue;</span>
            }
<span class="nc bnc" id="L784" title="All 4 branches missed.">            if ((xyTr[1] &lt; 0) || (xyTr[1] &gt; (img1Height - 1))) {</span>
<span class="nc" id="L785">                continue;</span>
            }

<span class="nc" id="L788">            outFilteredC2.add(c2[i]);</span>
        }
<span class="nc" id="L790">    }</span>

    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="nc bnc" id="L795" title="All 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L796">            return null;</span>
        }
        
<span class="nc" id="L799">        float[] values = calculateThetaDiff(compStats);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (values[i] &lt; 0) {</span>
<span class="nc" id="L802">                values[i] += 360;</span>
            }
        }
        
        // 20 degree wide bins
<span class="nc" id="L807">        HistogramHolder hist = Histogram.createSimpleHistogram(20.f, values, </span>
<span class="nc" id="L808">            Errors.populateYErrorsBySqrt(values));</span>
        
<span class="nc" id="L810">        int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="nc bnc" id="L811" title="All 4 branches missed.">        if ((yMaxIdx &gt; -1) &amp;&amp; (hist.getYHist()[yMaxIdx] == 1)) {</span>
<span class="nc" id="L812">            hist = Histogram.createSimpleHistogram(40.f, values, </span>
<span class="nc" id="L813">                Errors.populateYErrorsBySqrt(values));</span>
<span class="nc" id="L814">            yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
        }
        
        float thetaDiff;
<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (yMaxIdx == -1) {</span>
<span class="nc" id="L819">            float[] thetaDiffMeanStDev = MiscMath.getAvgAndStDev(values);</span>
<span class="nc" id="L820">            thetaDiff = thetaDiffMeanStDev[0];</span>
<span class="nc" id="L821">        } else {</span>
<span class="nc" id="L822">            thetaDiff = hist.getXHist()[yMaxIdx];</span>
        }
        
        //TODO: consider a bin larger than 20 degrees... 25
<span class="nc" id="L826">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L828" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc" id="L829">            float diffRot = AngleUtil.getAngleDifference(values[i], thetaDiff);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (diffRot &gt; 20) {</span>
<span class="nc" id="L831">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="nc bnc" id="L835" title="All 2 branches missed.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="nc" id="L836">            int idx = remove.get(i);</span>
<span class="nc" id="L837">            compStats.remove(idx);</span>
        }
        
<span class="nc" id="L840">        return remove;</span>
    }
    
    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats, float rotationInDegrees) {
        
<span class="nc bnc" id="L846" title="All 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L847">            return null;</span>
        }
        
<span class="nc" id="L850">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="nc" id="L852">        float[] values = calculateThetaDiff(compStats);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
            
<span class="nc bnc" id="L855" title="All 2 branches missed.">            if (values[i] &lt; 0) {</span>
<span class="nc" id="L856">                values[i] += 360;</span>
            }
            
<span class="nc" id="L859">            int diffRot = Math.round(AngleUtil.getAngleDifference(values[i], </span>
                rotationInDegrees));
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (diffRot &gt; 20) {</span>
<span class="nc bnc" id="L862" title="All 4 branches missed.">                if ((diffRot &lt; 30) &amp;&amp; compStats.get(i).getSumIntensitySqDiff() &lt; 100) {</span>
<span class="nc" id="L863">                    continue;</span>
                }
<span class="nc" id="L865">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="nc bnc" id="L869" title="All 2 branches missed.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="nc" id="L870">            int idx = remove.get(i);</span>
<span class="nc" id="L871">            compStats.remove(idx);</span>
        }
        
<span class="nc" id="L874">        return remove;</span>
    }
    
    public static float[] calcIntensitySSDMeanAndStDev(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc" id="L879">        int n = compStats.size();</span>
        
<span class="fc" id="L881">        float[] ssds = new float[n];</span>
        
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L885">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L887">            ssds[i] = stat.getSumIntensitySqDiff();</span>
        }
        
<span class="fc" id="L890">        float[] meanStDv = MiscMath.getAvgAndStDev(ssds);</span>
        
<span class="fc" id="L892">        return meanStDv;</span>
    }
    
    public static List&lt;Integer&gt; removeIntensityOutliers(List&lt;FeatureComparisonStat&gt; 
        compStats) {
        
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">        if (compStats.size() &lt; 3) {</span>
<span class="nc" id="L899">            return new ArrayList&lt;Integer&gt;();</span>
        }
        
<span class="fc" id="L902">        float sigmaFactor = 1.25f;</span>
        
<span class="fc" id="L904">        return removeIntensityOutliers(compStats, sigmaFactor);</span>
    }

    public static List&lt;Integer&gt; removeIntensityOutliers(List&lt;FeatureComparisonStat&gt; 
        compStats, float sigmaFactor) {
        
<span class="fc bfc" id="L910" title="All 2 branches covered.">        if (compStats.size() &lt; 3) {</span>
<span class="fc" id="L911">            return new ArrayList&lt;Integer&gt;();</span>
        }
        
<span class="fc" id="L914">        int n = compStats.size();</span>
        
<span class="fc" id="L916">        float[] meanStDv = calcIntensitySSDMeanAndStDev(compStats);</span>
        
<span class="fc" id="L918">        List&lt;Integer&gt; rm = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L920" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L922">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L924">            float diff = stat.getSumIntensitySqDiff() - meanStDv[0];</span>
            
<span class="fc bfc" id="L926" title="All 2 branches covered.">            if (diff &gt; (sigmaFactor * meanStDv[1])) {</span>
<span class="fc" id="L927">                rm.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L931" title="All 2 branches covered.">        for (int i = rm.size() - 1; i &gt; -1; --i) {</span>
            
<span class="fc" id="L933">            int idx = rm.get(i).intValue();</span>
            
<span class="fc" id="L935">            compStats.remove(idx);</span>
        }
        
<span class="fc" id="L938">        return rm;</span>
    }

    private List&lt;FeatureComparisonStat&gt; useBipartiteMatchingAsStats(float[][] cost,
        Map&lt;PairInt, FeatureComparisonStat&gt; statMap, 
        TransformationParameters params) {

<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (cost == null) {</span>
<span class="nc" id="L946">            return null;</span>
        }
        
<span class="nc" id="L949">        boolean transposed = false;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (cost.length &gt; cost[0].length) {</span>
<span class="nc" id="L951">            cost = MatrixUtil.transpose(cost);</span>
<span class="nc" id="L952">            transposed = true;</span>
        }

        // one pass thru to count for array sizes
<span class="nc" id="L956">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="nc" id="L957">        int[][] match = b.computeAssignments(cost);</span>

<span class="nc bnc" id="L959" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="nc" id="L960">            int idx1 = match[i][0];</span>
<span class="nc" id="L961">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L962" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L963">                continue;</span>
            }
<span class="nc bnc" id="L965" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L966">                int swap = idx1;</span>
<span class="nc" id="L967">                idx1 = idx2;</span>
<span class="nc" id="L968">                idx2 = swap;</span>
            }
<span class="nc" id="L970">            PairInt pI = new PairInt(idx1, idx2);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (!statMap.containsKey(pI)) {</span>
<span class="nc" id="L972">                continue;</span>
            }
        }

<span class="nc" id="L976">        List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="nc" id="L978">        int nc = 0;</span>

<span class="nc bnc" id="L980" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="nc" id="L981">            int idx1 = match[i][0];</span>
<span class="nc" id="L982">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L983" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L984">                continue;</span>
            }
<span class="nc bnc" id="L986" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L987">                int swap = idx1;</span>
<span class="nc" id="L988">                idx1 = idx2;</span>
<span class="nc" id="L989">                idx2 = swap;</span>
            }

<span class="nc" id="L992">            PairInt pI = new PairInt(idx1, idx2);</span>
<span class="nc" id="L993">            FeatureComparisonStat stat = statMap.get(pI);</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">            if (stat == null) {</span>
<span class="nc" id="L995">                continue;</span>
            }
            
<span class="nc" id="L998">            stats.add(stat);</span>
            
<span class="nc" id="L1000">            nc++;</span>
        }

<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (stats.size() &lt; 7) {</span>
<span class="nc" id="L1004">            return null;</span>
        }
        
<span class="nc" id="L1007">        return stats;</span>
    }
    
    public static void filterForIntersection4(TransformationParameters params, 
        int transXYTol, CornerRegion[] c1, CornerRegion[] c2, 
        List&lt;CornerRegion&gt; outFilteredTransformedC1, 
        List&lt;CornerRegion&gt; outFilteredC1, 
        List&lt;CornerRegion&gt; outFilteredC2,
        int img1Width, int img1Height, int img2Width, int img2Height) {
        
<span class="pc bpc" id="L1017" title="2 of 4 branches missed.">        if (c1.length &lt; 3 || c2.length &lt; 3) {</span>
<span class="nc" id="L1018">            return;</span>
        }
        
        /*
        make convex hull of corners1 and transform the hull to corners2
           where will only keep the corners2 that are within the transformed
           hull.
        then will do the same with corners2 to corners1
        */
        
<span class="fc" id="L1028">        Transformer transformer = new Transformer();</span>
<span class="fc" id="L1029">        PointInPolygon pip = new PointInPolygon();</span>
        
        try {
            
<span class="fc" id="L1033">            PairInt[] corners1 = Misc.convert(c1);</span>
<span class="fc" id="L1034">            GrahamScanPairInt&lt;PairInt&gt; scan = new GrahamScanPairInt&lt;PairInt&gt;();</span>
<span class="fc" id="L1035">            scan.computeHull(corners1);</span>
<span class="fc" id="L1036">            List&lt;PairInt&gt; hull = scan.getHull();</span>
            
<span class="fc" id="L1038">            float[] xTr1 = new float[hull.size()];</span>
<span class="fc" id="L1039">            float[] yTr1 = new float[hull.size()];</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">            for (int i = 0; i &lt; hull.size(); ++i) {</span>
<span class="fc" id="L1041">                PairInt xy = hull.get(i);</span>
<span class="fc" id="L1042">                double[] xyTr = transformer.applyTransformation(params, xy.getX(), xy.getY());</span>
<span class="fc" id="L1043">                xTr1[i] = (float)xyTr[0];</span>
<span class="fc" id="L1044">                yTr1[i] = (float)xyTr[1];</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">                if (xTr1[i] &lt; 0) {</span>
<span class="fc" id="L1046">                    xTr1[i] = 0;</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">                } else if (xTr1[i] &gt; (img2Width - 1)) {</span>
<span class="fc" id="L1048">                    xTr1[i] = img2Width - 1;</span>
                }
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">                if (yTr1[i] &lt; 0) {</span>
<span class="nc" id="L1051">                    yTr1[i] = 0;</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">                } else if (yTr1[i] &gt; (img2Height - 1)) {</span>
<span class="fc" id="L1053">                    yTr1[i] = img2Height - 1;</span>
                }
            }
            
<span class="fc bfc" id="L1057" title="All 2 branches covered.">            for (int i = 0; i &lt; c2.length; ++i) {</span>
<span class="fc" id="L1058">                CornerRegion cr = c2[i];</span>
<span class="fc" id="L1059">                int x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L1060">                int y = cr.getY()[cr.getKMaxIdx()];</span>
                
<span class="fc bfc" id="L1062" title="All 2 branches covered.">                if (pip.isInSimpleCurve(x, y, xTr1, yTr1, yTr1.length)) {</span>
<span class="fc" id="L1063">                    outFilteredC2.add(cr);</span>
                }
            }
            
<span class="fc" id="L1067">            MatchedPointsTransformationCalculator tc</span>
                = new MatchedPointsTransformationCalculator();

<span class="fc" id="L1070">            TransformationParameters revParams = tc.swapReferenceFrames(params);</span>
        
<span class="fc bfc" id="L1072" title="All 2 branches covered.">            if (outFilteredC2.size() &lt; 3) {</span>
<span class="fc" id="L1073">                return;</span>
            }
            
<span class="fc" id="L1076">            PairInt[] corners2 = Misc.convert(outFilteredC2);</span>
<span class="fc" id="L1077">            scan = new GrahamScanPairInt&lt;PairInt&gt;();</span>
<span class="fc" id="L1078">            scan.computeHull(corners2);</span>
<span class="fc" id="L1079">            hull = scan.getHull();</span>
            
<span class="fc" id="L1081">            float[] xTr2 = new float[hull.size()];</span>
<span class="fc" id="L1082">            float[] yTr2 = new float[hull.size()];</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">            for (int i = 0; i &lt; hull.size(); ++i) {</span>
<span class="fc" id="L1084">                PairInt xy = hull.get(i);</span>
<span class="fc" id="L1085">                double[] xyTr = transformer.applyTransformation(revParams, </span>
<span class="fc" id="L1086">                    xy.getX(), xy.getY());</span>
<span class="fc" id="L1087">                xTr2[i] = (float)xyTr[0];</span>
<span class="fc" id="L1088">                yTr2[i] = (float)xyTr[1];</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                if (xTr2[i] &lt; 0) {</span>
<span class="fc" id="L1090">                    xTr2[i] = 0;</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">                } else if (xTr2[i] &gt; (img1Width - 1)) {</span>
<span class="nc" id="L1092">                    xTr2[i] = img1Width - 1;</span>
                }
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">                if (yTr2[i] &lt; 0) {</span>
<span class="nc" id="L1095">                    yTr2[i] = 0;</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">                } else if (yTr2[i] &gt; (img1Height - 1)) {</span>
<span class="nc" id="L1097">                    yTr2[i] = img1Height - 1;</span>
                }
            }
            
<span class="fc bfc" id="L1101" title="All 2 branches covered.">            for (int i = 0; i &lt; c1.length; ++i) {</span>
<span class="fc" id="L1102">                CornerRegion cr = c1[i];</span>
<span class="fc" id="L1103">                int x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L1104">                int y = cr.getY()[cr.getKMaxIdx()];</span>
                
<span class="fc bfc" id="L1106" title="All 2 branches covered.">                if (pip.isInSimpleCurve(x, y, xTr2, yTr2, yTr2.length)) {</span>
<span class="fc" id="L1107">                    CornerRegion ctr = transformer.applyTransformation(params, c1[i]);</span>
<span class="fc" id="L1108">                    outFilteredTransformedC1.add(ctr);</span>
<span class="fc" id="L1109">                    outFilteredC1.add(c1[i]);</span>
                }
            }
            
<span class="nc" id="L1113">        } catch (GrahamScanTooFewPointsException e) {</span>
<span class="fc" id="L1114">        }</span>
<span class="fc" id="L1115">    }</span>

    public List&lt;FeatureComparisonStat&gt; reviseStatsForFullImages(
        GreyscaleImage img1, GreyscaleImage img2,
        FeatureMatcherSettings settings,
        TransformationParameters params,
        List&lt;FeatureComparisonStat&gt; stats, 
        int prevBinFactor1, int prevBinFactor2,
        RotatedOffsets rotatedOffsets) {

<span class="fc" id="L1125">        log.info(&quot;refine stats for full image reference frames&quot;);</span>

<span class="fc" id="L1127">        List&lt;FeatureComparisonStat&gt; revised = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L1129">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

<span class="fc" id="L1131">        IntensityFeatures features1 = new IntensityFeatures(5,</span>
<span class="fc" id="L1132">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L1133">        features1.calculateGradientWithGreyscale(img1);</span>

<span class="fc" id="L1135">        IntensityFeatures features2 = new IntensityFeatures(5,</span>
<span class="fc" id="L1136">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L1137">        features2.calculateGradientWithGreyscale(img2);</span>

<span class="fc" id="L1139">        int dither2 = 1 * (Math.max(prevBinFactor1, prevBinFactor2));</span>
<span class="pc bpc" id="L1140" title="2 of 4 branches missed.">        if (params.getStandardDeviations()[2] &gt; 25 || params.getStandardDeviations()[3] &gt; 25) {</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            if (dither2 &lt; 3) {</span>
<span class="nc" id="L1142">                dither2 = 3;</span>
            }
        }

<span class="fc" id="L1146">        int rotD = Math.round(params.getRotationInDegrees());</span>

<span class="fc" id="L1148">        final int rotationTolerance = 20;</span>

<span class="fc bfc" id="L1150" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>

<span class="fc" id="L1152">            FeatureComparisonStat stat = stats.get(i);</span>

<span class="fc" id="L1154">            int x1 = stat.getImg1Point().getX() * stat.getBinFactor1();</span>
<span class="fc" id="L1155">            int y1 = stat.getImg1Point().getY() * stat.getBinFactor1();</span>
<span class="fc" id="L1156">            int x2 = stat.getImg2Point().getX() * stat.getBinFactor2();</span>
<span class="fc" id="L1157">            int y2 = stat.getImg2Point().getY() * stat.getBinFactor2();</span>

            // have to discard the best angles found in stat and derive new
            // for these higher resolution images
<span class="fc" id="L1161">            FeatureComparisonStat compStat =</span>
<span class="fc" id="L1162">                featureMatcher.ditherAndRotateForBestLocation2(</span>
                    features1, features2, x1, y1, x2, y2, dither2, rotD,
                    rotationTolerance, img1, img2);

<span class="fc bfc" id="L1166" title="All 2 branches covered.">            if (compStat == null ||</span>
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">                (compStat.getSumIntensitySqDiff() &gt; compStat.getImg2PointIntensityErr())) {</span>
<span class="nc" id="L1168">                continue;</span>
            }

<span class="fc" id="L1171">            revised.add(compStat);</span>
        }
        
<span class="fc" id="L1174">        return revised;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
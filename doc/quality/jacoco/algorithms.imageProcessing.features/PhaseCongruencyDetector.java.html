<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PhaseCongruencyDetector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">PhaseCongruencyDetector.java</span></div><h1>PhaseCongruencyDetector.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.QuickSort;
import algorithms.imageProcessing.AdaptiveThresholding;
import algorithms.imageProcessing.DistanceTransform;
import algorithms.imageProcessing.FFTUtil;
import algorithms.imageProcessing.FilterGrid;
import algorithms.imageProcessing.FilterGrid.FilterGridProducts;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.Image;
import algorithms.imageProcessing.ImageIOHelper;
import algorithms.imageProcessing.ImageProcessor;
import algorithms.imageProcessing.LowPassFilter;
import algorithms.imageProcessing.MorphologicalFilter;
import algorithms.imageProcessing.NonMaximumSuppression;
import algorithms.imageProcessing.PeriodicFFT;
import algorithms.misc.Complex;
import algorithms.misc.ComplexModifiable;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PixelHelper;
import com.climbwithyourfeet.clustering.ClusterFinder;
import gnu.trove.iterator.TLongIterator;
import gnu.trove.set.TLongSet;
import gnu.trove.set.hash.TLongHashSet;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 An edge detector that uses principles of phase congruency to create an edge
 * map and orientation and phase angle images - it uses monogenic filters to
 * decrease the runtime.
 * Phase congruency operates in the frequency domain of fourier transforms and
 * with the inverse FFT produces an image that is summed over scales and
 * cleaned of some of the noise.
 * The phase congruency refers to the overlapping of sine waves at same phases
 * in the frequency domain produced from feature edges in the spatial domain.
 * &lt;pre&gt;
 * The phase congruency method is thought to be better able to find edges
 * under varying illumination conditions.  It also has the characteristic of
 * producing a single response to an edge (in contrast to many spatial gradient
 * methods which for blurry edges, especially, produce a double response in
 * the gradient image).
 * &lt;/pre&gt;
 * 
 * For further reading other than the references below, a summary of band-pass
 * quadrature filters is in
 * https://www.utc.fr/~dboukerr/Papers/Qf_JMIV_2004.pdf
 *
 * Listings of copyrights for the original source codes in languages Matlab and
 * python follow:
 *
 adapted from
  http://www.peterkovesi.com/matlabfns/PhaseCongruency/phasecongmono.m
  which has copyright:
  -------- begin Kovesi copyright --------
  Copyright (c) 1996-2013 Peter Kovesi
  Centre for Exploration Targeting
  The University of Western Australia
  peter.kovesi at uwa edu au

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the &quot;Software&quot;), to deal
  in the Software without restriction, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  The Software is provided &quot;as is&quot;, without warranty of any kind.
  -------- end Kovesi copyright --------
 
 * useful also was the python phasepack port by Alistair Muldal
 *  http://pydoc.net/Python/phasepack/1.4/phasepack.phasecongmono/
 * which has the following copyright:
 * # MIT License:
-------- begin phasepack copyright --------
# Permission is hereby  granted, free of charge, to any  person obtaining a
# copy of this software and associated  documentation files (the &quot;Software&quot;),
# to deal in the Software without restriction, subject to the following
# conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# The software is provided &quot;as is&quot;, without warranty of any kind.
-------- end phasepack copyright --------
* 
% =========================================
*
% Notes on specifying parameters:
%
% The convolutions are done via the FFT.  Many of the parameters relate to the
% specification of the filters in the frequency plane.  The values do not seem
% to be very critical and the defaults are usually fine.  You may want to
% experiment with the values of 'nscales' and 'k', the noise compensation
% factor.
*
% Notes on filter settings to obtain even coverage of the spectrum
% sigmaOnf       .85   mult 1.3
% sigmaOnf       .75   mult 1.6     (filter bandwidth ~1 octave)
% sigmaOnf       .65   mult 2.1
% sigmaOnf       .55   mult 3       (filter bandwidth ~2 octaves)
%
% Note that better results are achieved using the large bandwidth filters.
% I generally use a sigmaOnf value of 0.55 or even smaller.
%
% References:
%
%     Peter Kovesi, &quot;Image Features From Phase Congruency&quot;. Videre: A
%     Journal of Computer Vision Research. MIT Press. Volume 1, Number 3,
%     Summer 1999 http://mitpress.mit.edu/e-journals/Videre/001/v13.html
*
*     Michael Felsberg and Gerald Sommer, &quot;A New Extension of Linear Signal
%     Processing for Estimating Local Properties and Detecting Features&quot;. DAGM
%     Symposium 2000, Kiel
%
%     Michael Felsberg and Gerald Sommer. &quot;The Monogenic Signal&quot; IEEE
%     Transactions on Signal Processing, 49(12):3136-3144, December 2001
%
%     Peter Kovesi, &quot;Phase Congruency Detects Corners and Edges&quot;. Proceedings
%     DICTA 2003, Sydney Dec 10-12
* 
   Additions by Nichole King:
    -- use of an adaptive binary threshold in a 2-layer filter.
       That algorithm is in class AdaptiveThresholding.java and it is from
       &quot;Efficient Implementation of Local Adaptive Thresholding
       Techniques Using Integral Images&quot;
           by Shafaita, Keysersa, and Breuelb
    -- a flag 'extract noise' to extract the noise as a difference of the
       result of k factors and to extract a subset of the noise as candidates
       for finding textures.  It uses a  
       density based clustering algorithm
       http://nking.github.io/two-point-correlation/
       which has an MIT license
      ---- begin nking copyright ----
      The MIT License (MIT)
      Copyright (c) 2013-* Nichole King
      http://nking.github.io/two-point-correlation/

        Permission is hereby granted, free of charge, to any person obtaining 
        a copy of this software and associated documentation files 
        (the &quot;Software&quot;), to deal in the Software without restriction, 
        including without limitation the rights to use, copy, modify, merge, 
        publish, distribute, sublicense, and/or sell copies of the Software, 
        and to permit persons to whom the Software is furnished to do so, 
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included 
        in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS 
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     ---- end nking copyright ---- 
    
     runtime complexity of majority of algorithm is a constant factor, that
     depends upon parameters chosen, times O(N*lg_2(N)),
     but each operation uses a transcendental function.

     the advantage to using phase congruency is that it's possible to produce
     consistent clean edges with less noise and representing a wide range in
     intensity contrast.

 */
<span class="fc" id="L179">public class PhaseCongruencyDetector {</span>

    final private static double epsilon = 1E-4;

<span class="fc" id="L183">    private boolean doPlot = false;</span>

<span class="fc" id="L185">    private boolean extractNoise = false;</span>

    /**
     * number of wavelet scales.  a lower value reveals more fine
     * scale features.  The default is 5.
     */
<span class="fc" id="L191">    private int nScale = 5;</span>
    /**
     * wavelength of smallest scale filter.  The default is 3.
     */
<span class="fc" id="L195">    private int minWavelength = 3;</span>
    /**
     * scaling factor between successive filters.  The default is 2.1.
     */
<span class="fc" id="L199">    private float mult = 2.1f;</span>
    /**
     * ratio of standard deviation of Gaussian describing the
     * log Gabor's filter's transfer function in the frequency domain to the
     * filter center frequency.  The default is 0.55f.
     */
<span class="fc" id="L205">    private float sigmaOnf = 0.55f;</span>
    /**
     * number of standard deviations of the noise energy beyond the
     * mean at which we set the noise threshold point.  You may want to vary this
       up to a value of 10 or 20 for noisy images.
       The default is 5.
     */
<span class="fc" id="L212">    private int k = 5;//2;</span>
    /**
     * The fractional measure of frequency spread below which phase
     * congruency values get penalized.  The default is 0.5f.
     */
<span class="fc" id="L217">    private float cutOff = 0.5f;</span>
    /**
     * Controls the sharpness of the transition in the sigmoid function
     * used to weight phase congruency for frequency spread.  The default is 10.
     */
<span class="fc" id="L222">    private float g = 10;</span>
    /**
     * factor to apply to the calculated phase
     * deviation result.  Increasing this sharpens the edge responses, but can
     * also attenuate their magnitude if the gain is too large.  Sensible values
     * to use lie in the range 1-2.  The default is 1.5f.
     */
<span class="fc" id="L229">    private float deviationGain = 1.5f;</span>
    /**
     * Parameter specifies method used to determine noise
     * statistics: -1 use median of smallest scale filter responses;
     * -2 use mode of smallest scale filter responses;
     * 0 turns off all noise compensation; and
     * &gt; 0 use noiseMethod value as the fixed noise threshold.
     * The default is -1.
     */
<span class="fc" id="L238">    private int noiseMethod = -1;</span>
    /**
     * the low threshold fraction of 1
     */
<span class="fc" id="L242">    private double tLow = 0.1;</span>
    /**
     * the high threshold fraction of 1.  The default is 0.3.
     * Note that this is ignored if useAdaptiveThreshold is true, which it is
     * by default.
     */
<span class="fc" id="L248">    private double tHigh = 0.3;</span>
    /**
     * a flag indicating use of adaptive thresholds in the 2 layer filter
     */
<span class="fc" id="L252">    private boolean useAdaptiveThreshold = true;</span>

<span class="fc" id="L254">    public PhaseCongruencyDetector() {</span>

<span class="fc" id="L256">    }</span>

    public void setToDebug() {
<span class="fc" id="L259">        doPlot = true;</span>
<span class="fc" id="L260">    }</span>

    /**
     * noise is extracted and textures are examined.  this
     * feature name may change depending upon results in progress.
     * Note that k must be the default of 5 or less for this feature.
     */
    public void setToExtractNoise() {
<span class="pc bpc" id="L268" title="2 of 4 branches missed.">        if (k &gt; 5 || noiseMethod != -1) {</span>
<span class="nc" id="L269">            throw new IllegalStateException(&quot;currently, the algorihm needs&quot;</span>
                + &quot; k &lt;= 5 and noiseMethod == -1 for the differencing of pixels.  &quot;
                + &quot; k=&quot; + k + &quot; and noiseMethod=&quot; + noiseMethod);
        }
<span class="fc" id="L273">        this.extractNoise = true;</span>
<span class="fc" id="L274">    }</span>

    /**
     * set the number of wavelet scales.
     * @param n number of wavelet scales.  a lower value reveals more fine
     * scale features.  The default is 5.
     */
    public void setNScales(int n) {
<span class="nc" id="L282">        nScale = n;</span>
<span class="nc" id="L283">    }</span>

    /**
     * set the scale number of the smallest scale filter.
     * @param m wavelength of smallest scale filter.  The default is 3.
     */
    public void setMinWavelength(int m) {
<span class="nc" id="L290">        minWavelength = m;</span>
<span class="nc" id="L291">    }</span>

    /**
     *
     * @param f scaling factor between successive filters.  The default is 2.1.
     */
    public void setMult(float f) {
<span class="nc" id="L298">        mult = f;</span>
<span class="nc" id="L299">    }</span>

    /**
     *
     * @param s ratio of standard deviation of Gaussian describing the
     * log Gabor's filter's transfer function in the frequency domain to the
     * filter center frequency.  The default is 0.55f.
     */
    public void setSigmaOnf(float s) {
<span class="nc" id="L308">        sigmaOnf = s;</span>
<span class="nc" id="L309">    }</span>

    /**
     *
     * @param k number of standard deviations of the noise energy beyond the
     * mean at which we set the noise threshold point.  You may want to vary
     * this up to a value of 10 or 20 for noisy images.
       The default is 5.
     */
    public void setK(int k) {
<span class="pc bpc" id="L319" title="3 of 4 branches missed.">        if (extractNoise &amp;&amp; k &gt; 5) {</span>
<span class="nc" id="L320">            throw new IllegalStateException(&quot;currently, the algorihm needs&quot;</span>
                + &quot; k &lt;= 5 for the differencing of pixels requested by&quot;
                + &quot; 'extractNoise'.&quot;);
        }
<span class="fc" id="L324">        this.k = k;</span>
<span class="fc" id="L325">    }</span>

    /**
     *
     * @param c The fractional measure of frequency spread below which phase
     * congruency values get penalized.  The default is 0.5f.
     */
    public void setCutOff(float c) {
<span class="nc" id="L333">        cutOff = c;</span>
<span class="nc" id="L334">    }</span>

    /**
     *
     * @param g Controls the sharpness of the transition in the sigmoid function
     * used to weight phase congruency for frequency spread.  The default is 10.
     */
    public void setG(int g) {
<span class="nc" id="L342">        this.g = g;</span>
<span class="nc" id="L343">    }</span>

    /**
     *
     * @param d Amplification to apply to the calculated phase
     * deviation result.  Increasing this sharpens the edge responses, but can
     * also attenuate their magnitude if the gain is too large.  Sensible values
     * to use lie in the range 1-2.  The default is 1.5f.
     */
    public void setDevitionGain(float d) {
<span class="nc" id="L353">        deviationGain = d;</span>
<span class="nc" id="L354">    }</span>

    /**
     *
     * @param m Parameter specifies method used to determine noise
     * statistics: -1 use median of smallest scale filter responses;
     * -2 use mode of smallest scale filter responses;
     * 0 turns off all noise compensation; and
     * &gt; 0 use noiseMethod value as the fixed noise threshold.
     * The default is -1.
     */
    public void setNoiseMethod(int m) {
<span class="nc bnc" id="L366" title="All 4 branches missed.">        if (extractNoise &amp;&amp; (m != -1)) {</span>
<span class="nc" id="L367">            throw new IllegalStateException(&quot;the 'extract noise' feature is set&quot;</span>
                + &quot; and this requires noiseMethod==-1.&quot;);
        }
<span class="nc" id="L370">        this.noiseMethod = m;</span>
<span class="nc" id="L371">    }</span>

    /**
     *
     * @param tLow the low threshold fraction of 1.
     * The default is 0.1.
     */
    public void setLowThreshold(double tLow) {
<span class="nc" id="L379">        this.tLow = tLow;</span>
<span class="nc" id="L380">    }</span>

    /**
     *
     * @param t the high threshold fraction of 1.  The default is 0.3.
     * Note that this is ignored if useAdaptiveThreshold is true, which it is
     * by default.
     */
    public void setHighThreshold(double t) {
<span class="nc" id="L389">        this.tHigh = t;</span>
<span class="nc" id="L390">    }</span>

    /**
     * turn off the use of adaptive thresholds in the 2 layer filter, and
     * instead use tLow and tHigh only.
     */
    public void setToNotUseAdaptiveThreshold() {
<span class="nc" id="L397">        this.useAdaptiveThreshold = false;</span>
<span class="nc" id="L398">    }</span>

    /**
     * use the phase congruency method of transformations to create
     * edge maps, orientation, phase angle and a suggested threshold.
     * @param img
     * @return
       &lt;pre&gt;
       NOTE: the return products use row major and column major notation, so
       read the method products getters carefully.

       Returned values:
         phaseCongruency  - Phase congruency indicating edge significance
                            (values are in range 0 to 1.)
         orientation      - Orientation image in integer degrees 0-180,
                            positive anticlockwise.
                            0 corresponds to a vertical edge, 90 is horizontal.
         phaseAngle       - Local weighted mean phase angle at every point in
                            the image. A value of
                                pi/2 corresponds to a bright line,
                                0 corresponds to a step and
                                -pi/2 is a dark line.
         threshold        - Calculated noise threshold (can be useful for
                            diagnosing noise characteristics of images).
                            Once you know this you can then specify fixed
                            thresholds and save some computation time.
      &lt;/pre&gt;
     */
    public PhaseCongruencyProducts phaseCongMono(GreyscaleImage img) {

<span class="fc" id="L428">        long t0 = System.currentTimeMillis();</span>

<span class="fc" id="L430">        int nCols = img.getWidth();</span>
<span class="fc" id="L431">        int nRows = img.getHeight();</span>

        //Periodic Fourier transform of image, using default normalization
        // perfft2 results use notation a[row][col]
<span class="fc" id="L435">        PeriodicFFT perfft2 = new PeriodicFFT();</span>
        //IM = perfft2(im);                   %
        //S, P, s, p where S = FFT of smooth, P = FFT of periodic, s=spatial smooth, p = spatial p
<span class="fc" id="L438">        Complex[][][] perfResults = perfft2.perfft2(img, false);</span>
<span class="fc" id="L439">        Complex[][] capIm = perfResults[1];</span>

        /*
        sumAn  = zeros(rows,cols);          % Matrix for accumulating filter response
                                            % amplitude values.
        sumf   = zeros(rows,cols);          % ft is phase angle
        sumh1  = zeros(rows,cols);
        sumh2  = zeros(rows,cols);
        */
<span class="fc" id="L448">        double[][] sumAn = new double[nRows][];</span>
<span class="fc" id="L449">        double[][] sumF = new double[sumAn.length][];</span>
<span class="fc" id="L450">        double[][] sumH1 = new double[sumAn.length][];</span>
<span class="fc" id="L451">        double[][] sumH2 = new double[sumAn.length][];</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L453">            sumAn[row] = new double[nCols];</span>
<span class="fc" id="L454">            sumF[row] = new double[nCols];</span>
<span class="fc" id="L455">            sumH1[row] = new double[nCols];</span>
<span class="fc" id="L456">            sumH2[row] = new double[nCols];</span>
        }

        /*
        Generate grid data for constructing filters in the frequency domain
        [radius, u1, u2] = filtergrid(rows, cols);
        */
        // results use notation a[row][col]
<span class="fc" id="L464">        FilterGrid fg = new FilterGrid();</span>
<span class="fc" id="L465">        FilterGridProducts fgProducts = fg.filtergrid(nRows, nCols);</span>

        /*
        Get rid of the 0 radius value in the middle (at top left corner after
        fftshifting) so that taking the log of the radius, or dividing by the
        radius, will not cause trouble.
         radius(1,1) = 1;
        */
<span class="fc" id="L473">        fgProducts.getRadius()[0][0] = 1;</span>

        /*
         % Construct the monogenic filters in the frequency domain.  The two
         % filters would normally be constructed as follows
         %    H1 = i*u1./radius;
         %    H2 = i*u2./radius;
         % However the two filters can be packed together as a complex valued
         % matrix, one in the real part and one in the imaginary part.  Do this by
         % multiplying H2 by i and then adding it to H1 (note the subtraction
         % because i*i = -1).  When the convolution is performed via the fft the
         % real part of the result will correspond to the convolution with H1 and
         % the imaginary part with H2.  This allows the two convolutions to be
         % done as one in the frequency domain, saving time and memory.
         H = (1i*u1 - u2)./radius;
        */
        // results use notation a[row][col]
<span class="fc" id="L490">        double[][] u1 = fgProducts.getU1();</span>
<span class="fc" id="L491">        double[][] u2 = fgProducts.getU2();</span>
<span class="fc" id="L492">        double[][] radius = fgProducts.getRadius();</span>
<span class="fc" id="L493">        Complex[][] capH = new Complex[nRows][];</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L495">            capH[row] = new Complex[nCols];</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L497">                double re = -u2[row][col]/radius[row][col];</span>
<span class="fc" id="L498">                double im = u1[row][col]/radius[row][col];</span>
<span class="fc" id="L499">                capH[row][col] = new Complex(re, im);</span>
            }
        }

        /*
         % First construct a low-pass filter that is as large as possible, yet falls
         % away to zero at the boundaries.  All filters are multiplied by
         % this to ensure no extra frequencies at the 'corners' of the FFT are
         % incorporated as this can upset the normalisation process when
         % calculating phase congruency
         lp = lowpassfilter([rows,cols],.45,15);    % Radius .4, 'sharpness' 15
        */
        // results use notation a[row][col]
<span class="fc" id="L512">        LowPassFilter lpFilter = new LowPassFilter();</span>
<span class="fc" id="L513">        double[][] lp = lpFilter.lowpassfilter(nRows, nCols, 0.45f, 15);</span>

<span class="fc" id="L515">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="fc" id="L517">        double[][] maxAN = null;</span>

<span class="fc" id="L519">        double tau = noiseMethod;</span>
        // keeping taus in case need to increase noise estimate
<span class="fc" id="L521">        double sqml4 = Math.sqrt(Math.log(4));</span>
<span class="fc" id="L522">        double logGaborDenom = 2. * Math.pow(Math.log(sigmaOnf), 2);</span>

<span class="fc" id="L524">        double[][] width = new double[nRows][];</span>
<span class="fc" id="L525">        double[][] weight = new double[nRows][];</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L527">            width[row] = new double[nCols];</span>
<span class="fc" id="L528">            weight[row] = new double[nCols];</span>
        }

<span class="fc bfc" id="L531" title="All 2 branches covered.">        for (int s = 0; s &lt; nScale; ++s) {</span>

            // Centre frequency of filter.
<span class="fc" id="L534">            double wavelength = minWavelength * Math.pow(mult, s);</span>

<span class="fc" id="L536">            double fo = 1.0/wavelength;</span>

            // use notation a[row][col]
<span class="fc" id="L539">            double[][] logGabor = new double[nRows][];</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L541">                logGabor[row] = new double[nCols];</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L543">                    double v = Math.log(radius[row][col]/fo);</span>
<span class="fc" id="L544">                    v *= v;</span>
<span class="fc" id="L545">                    v = Math.exp(-v/logGaborDenom);</span>
                    //logGabor = logGabor.*lp;
<span class="fc" id="L547">                    logGabor[row][col] = lp[row][col] * v;</span>
                }
            }
<span class="fc" id="L550">            logGabor[0][0] = 0;</span>

            //DEBUG(logGabor, &quot;s=&quot; + s + &quot; logGabor*low pass filter&quot;, s);

            // uses notation a[row][col]
            //Bandpassed image in the frequency domain
<span class="fc" id="L556">            Complex[][] capIMF = new Complex[nRows][];</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L558">                capIMF[row] = new Complex[nCols];</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L560">                   capIMF[row][col] = capIm[row][col].times(logGabor[row][col]);</span>
                }
            }

            // uses notation a[row][col]
            //  Bandpassed image in spatial domain.
            //  f = real(ifft2(IMF));
            // the functions used in other code are not normalized on fft,
            // but are by inverse fft so need a combined division here by nomr=nRows*nCols
<span class="fc" id="L569">            FFTUtil fftUtil = new FFTUtil();</span>
<span class="fc" id="L570">            Complex[][] fComplex = fftUtil.create2DFFT(capIMF, false, false);</span>

<span class="fc" id="L572">            double norm = nRows * nCols;</span>

            //h = ifft2(IMF.*H);
<span class="fc" id="L575">            Complex[][] capIMFH = new Complex[nRows][];</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L577">                capIMFH[row] = new Complex[nCols];</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L579">                    capIMFH[row][col] = capIMF[row][col].times(capH[row][col]);</span>
                }
            }
            // result needs to be divided by norm=nRows*nCols
<span class="fc" id="L583">            Complex[][] h = fftUtil.create2DFFT(capIMFH, false, false);</span>

            /*
            h1 = real(h);
            h2 = imag(h);
            An = sqrt(f.^2 + h1.^2 + h2.^2); % Amplitude of this scale component.
            sumAn = sumAn + An;              % Sum of component amplitudes over scale.
            sumf  = sumf  + f;
            sumh1 = sumh1 + h1;
            sumh2 = sumh2 + h2;
            */
            // uses notation a[row][col]
<span class="fc" id="L595">            double[][] aN = new double[nRows][];</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L597">                aN[row] = new double[nCols];</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
                    // results of inverse transforms need normalization
<span class="fc" id="L600">                    double f0 = fComplex[row][col].re()/norm;</span>
<span class="fc" id="L601">                    double h1 = h[row][col].re()/norm;</span>
<span class="fc" id="L602">                    double h2 = h[row][col].im()/norm;</span>
<span class="fc" id="L603">                    aN[row][col] = Math.sqrt(f0*f0 + h1*h1 + h2*h2);</span>
<span class="fc" id="L604">                    sumAn[row][col] += aN[row][col];</span>
<span class="fc" id="L605">                    sumF[row][col] += f0;</span>
<span class="fc" id="L606">                    sumH1[row][col] += h1;</span>
<span class="fc" id="L607">                    sumH2[row][col] += h2;</span>
                }
            }

            /*
            At the smallest scale estimate noise characteristics from the
            distribution of the filter amplitude responses stored in sumAn.
            tau is the Rayleigh parameter that is used to describe the
            distribution.
            */
<span class="fc bfc" id="L617" title="All 2 branches covered.">            if (s == 0) {</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">                if (noiseMethod == -1) {</span>
                    //Use median to estimate noise statistics
                    //tau = median(sumAn(:))/sqrt(log(4));
                    //TODO: could improve this below O(N*lg2(N)) with histograms
                    //      and assumptions of bin sizes...when have an
                    //      implementation of Multi-Level-Buckets, revisit this
<span class="fc" id="L624">                    double median = MiscMath.findMedian(sumAn);</span>
<span class="fc" id="L625">                    tau = median/sqml4;</span>
<span class="pc bnc" id="L626" title="All 2 branches missed.">                } else if (noiseMethod == -2) {</span>
                    //Use mode to estimate noise statistics
                    //tau = rayleighmode(sumAn(:));
<span class="nc" id="L629">                    tau = rayleighMode(sumAn);</span>
                }
<span class="fc" id="L631">                maxAN = aN;</span>
            } else {
                // Record maximum amplitude of components across scales.  This is needed
                // to determine the frequency spread weighting.
                //maxAN = max(maxAN, An);
                // uses notation a[row][col]
<span class="fc bfc" id="L637" title="All 2 branches covered.">                for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">                    for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L639">                        maxAN[row][col] = Math.max(maxAN[row][col], aN[row][col]);</span>
                    }
                }
            }

            /*
            Form weighting that penalizes frequency distributions that are
            particularly narrow.  Calculate fractional 'width' of the frequencies
            present by taking the sum of the filter response amplitudes and dividing
            by the maximum component amplitude at each point on the image.  If
            there is only one non-zero component width takes on a value of 0, if
            all components are equal width is 1.
            width = (sumAn./(maxAn + epsilon) - 1) / (nscale-1);

            Now calculate the sigmoidal weighting function.
            weight = 1.0 ./ (1 + exp( (cutOff - width)*g));
            */
            // uses notation a[row][col]

<span class="fc" id="L658">            double dn = (double)nScale - 1.;</span>

<span class="pc bpc" id="L660" title="1 of 2 branches missed.">            if (dn &gt; 0) {</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">                for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                    for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L663">                        double a = sumAn[row][col]/(maxAN[row][col] + epsilon);</span>
<span class="fc" id="L664">                        width[row][col] = (a - 1.)/dn;</span>
<span class="fc" id="L665">                        double v = Math.exp(g*(cutOff - width[row][col]));</span>
<span class="fc" id="L666">                        weight[row][col] = 1./(1. + v);</span>
                    }
                }
            }
        } // end for each scale

        /*
        Automatically determine noise threshold

        Assuming the noise is Gaussian the response of the filters to noise will
        form Rayleigh distribution.  We use the filter responses at the smallest
        scale as a guide to the underlying noise level because the smallest scale
        filters spend most of their time responding to noise, and only
        occasionally responding to features. Either the median, or the mode, of
        the distribution of filter responses can be used as a robust statistic to
        estimate the distribution mean and standard deviation as these are related
        to the median or mode by fixed constants.  The response of the larger
        scale filters to noise can then be estimated from the smallest scale
        filter response according to their relative bandwidths.

        This code assumes that the expected reponse to noise on the phase
        congruency calculation is simply the sum of the expected noise responses
        of each of the filters.  This is a simplistic overestimate, however these
        two quantities should be related by some constant that will depend on the
        filter bank being used.  Appropriate tuning of the parameter 'k' will
        allow you to produce the desired output. (though the value of k seems to
        be not at all critical)
        */

        // uses notation a[row][col]
        // ft is phase angle
<span class="fc" id="L697">        double[][] orientation = new double[nRows][];</span>
<span class="fc" id="L698">        double[][] ft = new double[nRows][];</span>
<span class="fc" id="L699">        double[][] energy = new double[nRows][];</span>
<span class="fc" id="L700">        double[][] pc = new double[nRows][];</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L702">            orientation[row] = new double[nCols];</span>
<span class="fc" id="L703">            ft[row] = new double[nCols];</span>
<span class="fc" id="L704">            energy[row] = new double[nCols];</span>
<span class="fc" id="L705">            pc[row] = new double[nCols];</span>
        }

<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L710">                double gY = -sumH2[row][col];</span>
<span class="fc" id="L711">                double gX = sumH1[row][col];</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">                if (gY &lt; 0) {</span>
<span class="fc" id="L713">                    gX *= -1;</span>
<span class="fc" id="L714">                    gY *= -1;</span>
                }
<span class="fc" id="L716">                orientation[row][col] = Math.atan2(gY, gX);</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">                if (orientation[row][col] == Math.PI) {</span>
<span class="nc" id="L718">                    orientation[row][col] = 0;</span>
                }
                // orientation values now range 0 - pi
                // Quantize to 0 - 180 degrees (for NONMAXSUP)
<span class="fc" id="L722">                orientation[row][col] = (int)(orientation[row][col]*180./Math.PI);</span>

<span class="fc" id="L724">                double h1Sq = sumH1[row][col];</span>
<span class="fc" id="L725">                h1Sq *= h1Sq;</span>
<span class="fc" id="L726">                double h2Sq = sumH2[row][col];</span>
<span class="fc" id="L727">                h2Sq *= h2Sq;</span>

                //Feature type - a phase angle -pi/2 to pi/2.
<span class="fc" id="L730">                ft[row][col] = Math.atan2(sumF[row][col], Math.sqrt(h1Sq + h2Sq));</span>

                //overall energy
<span class="fc" id="L733">                double v0 = sumF[row][col];</span>
<span class="fc" id="L734">                v0 *= v0;</span>
<span class="fc" id="L735">                energy[row][col] = Math.sqrt(v0 + h1Sq + h2Sq);</span>
            }
        }

        /*
        % Compute phase congruency.  The original measure,
        % PC = energy/sumAn
        % is proportional to the weighted cos(phasedeviation).  This is not very
        % localised so this was modified to
        % PC = cos(phasedeviation) - |sin(phasedeviation)|
        % (Note this was actually calculated via dot and cross products.)  This measure
        % approximates
        % PC = 1 - phasedeviation.

        % However, rather than use dot and cross products it is simpler and more
        % efficient to simply use acos(energy/sumAn) to obtain the weighted phase
        % deviation directly.  Note, in the expression below the noise threshold is
        % not subtracted from energy immediately as this would interfere with the
        % phase deviation computation.  Instead it is applied as a weighting as a
        % fraction by which energy exceeds the noise threshold.  This weighting is
        % applied in addition to the weighting for frequency spread.  Note also the
        % phase deviation gain factor which acts to sharpen up the edge response. A
        % value of 1.5 seems to work well.  Sensible values are from 1 to about 2.

        PC = weight.*max(1 - deviationGain*acos(energy./(sumAn + epsilon)),0) ...
              .* max(energy-T,0)./(energy+epsilon);
        */

        double threshold;
<span class="fc" id="L764">        double thresholdLowNz = -1;</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">        if (noiseMethod &gt;= 0) {</span>
            //fixed noise threshold
<span class="nc" id="L767">            threshold = noiseMethod;</span>
        } else {
            //Estimate the effect of noise on the sum of the filter responses as
            //the sum of estimated individual responses (this is a simplistic
            //overestimate). As the estimated noise response at succesive scales
            //is scaled inversely proportional to bandwidth we have a simple
            //geometric sum.
            //totalTau = tau * (1 - (1/mult)^nscale)/(1-(1/mult));
<span class="fc" id="L775">            double totalTau = tau * (1. - Math.pow((1./mult), nScale))/(1. - (1./mult));</span>

            // Calculate mean and std dev from tau using fixed relationship
            // between these parameters and tau. See
            // http://mathworld.wolfram.com/RayleighDistribution.html
<span class="fc" id="L780">            double EstNoiseEnergyMean = totalTau * Math.sqrt(Math.PI/2.);</span>
<span class="fc" id="L781">            double EstNoiseEnergySigma = totalTau * Math.sqrt((4. - Math.PI)/2.);</span>

<span class="fc" id="L783">            threshold = Math.max(EstNoiseEnergyMean</span>
                + ((float)k) * EstNoiseEnergySigma, epsilon);

<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (extractNoise) {</span>
                // empirically, k=10 is chosen
<span class="fc" id="L788">                thresholdLowNz = Math.max(EstNoiseEnergyMean</span>
                    + 7.f * EstNoiseEnergySigma, epsilon);
            }
        }

<span class="fc" id="L793">        double[][] lowNzFactors = null;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (extractNoise) {</span>
<span class="fc" id="L795">            lowNzFactors = new double[nRows][];</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L797">                lowNzFactors[row] = new double[nCols];</span>
            }
        }

<span class="fc bfc" id="L801" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; ++col) {</span>

<span class="fc" id="L804">                double eDiv = Math.acos(energy[row][col]/(sumAn[row][col] + epsilon));</span>

<span class="fc" id="L806">                double a = weight[row][col]</span>
<span class="fc" id="L807">                    * Math.max(1. - deviationGain * eDiv, 0)</span>
                    / (energy[row][col] + epsilon);

<span class="fc" id="L810">                double eMax = Math.max(energy[row][col] - threshold, 0);</span>

<span class="fc" id="L812">                pc[row][col] = a * eMax;</span>

<span class="fc bfc" id="L814" title="All 2 branches covered.">                if (extractNoise) {</span>
<span class="fc" id="L815">                    lowNzFactors[row][col] = Math.max(energy[row][col] -</span>
                        thresholdLowNz, 0);
<span class="fc" id="L817">                    lowNzFactors[row][col] /= eMax;</span>
                }
            }
        }

<span class="fc" id="L822">        PhaseCongruencyProducts products = new PhaseCongruencyProducts(pc,</span>
            orientation, ft, threshold);

<span class="fc" id="L825">        NonMaximumSuppression ns = new NonMaximumSuppression();</span>

<span class="fc" id="L827">        double[][] thinnedPC = ns.nonmaxsup(products.getPhaseCongruency(),</span>
<span class="fc" id="L828">            products.getOrientation(), 1.2, new HashSet&lt;PairInt&gt;());</span>

<span class="fc" id="L830">        products.setParameters(nScale, minWavelength, mult, sigmaOnf, k, cutOff,</span>
            g, deviationGain, noiseMethod, tLow, tHigh);

<span class="fc" id="L833">        int[][] thinned = createEdges(products.getPhaseCongruency(), thinnedPC,</span>
<span class="fc" id="L834">            products.getPhaseAngle(), tLow, tHigh);</span>

<span class="fc" id="L836">        products.setThinnedImage(thinned);</span>

<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (extractNoise) {</span>

<span class="fc" id="L840">            int distMinimum = 70;</span>
            
            /*
            using a higher k=7, subtracting the thinned results from the default
            thinned image.
            */

<span class="fc" id="L847">            double[][] pcLowNz = copy(products.getPhaseCongruency());</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">                    if (thinned[row][col] == 0) {</span>
<span class="fc" id="L851">                        pcLowNz[row][col] = 0;</span>
                    } else {
<span class="fc" id="L853">                        pcLowNz[row][col] *= lowNzFactors[row][col];</span>
                    }
                }
            }

<span class="fc" id="L858">            int[][] thinnedLowNz = applyHysThresh(pcLowNz,</span>
<span class="fc" id="L859">                products.getPhaseAngle(), tLow, tHigh, true);</span>

<span class="fc" id="L861">            Set&lt;PairInt&gt; noisePoints = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L863">            products.setNoiseyPixels(new HashSet&lt;PairInt&gt;());</span>
            
<span class="fc" id="L865">            int dtN = 0;</span>
<span class="fc" id="L866">            int[][] dt = new int[nRows][];</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc" id="L868">                dt[row] = new int[nCols];</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
                    // where thinned is &gt; 0 and thinnedLowNz == 0 is a noise pixel
<span class="fc" id="L871">                    int v = thinned[row][col] - thinnedLowNz[row][col];</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">                    if (v &gt; 0) {</span>
                        // noise = points in thinned, but not in low noise thinned
<span class="fc" id="L874">                        noisePoints.add(new PairInt(row, col));</span>
<span class="fc" id="L875">                        products.getNoiseyPixels().add(new PairInt(col, row));</span>
                    } else {
                        // points that are signal in both
<span class="fc bfc" id="L878" title="All 2 branches covered.">                        if (thinnedLowNz[row][col] &gt; 0) {</span>
<span class="fc" id="L879">                            dt[row][col] = 1;</span>
<span class="fc" id="L880">                            dtN++;</span>
                        }
                    }
                }
            }

<span class="fc" id="L886">            products.setThinnedLowNoise(thinnedLowNz);            </span>

<span class="pc bpc" id="L888" title="1 of 2 branches missed.">            if (doPlot) {</span>
<span class="fc" id="L889">                int count = 0;</span>
<span class="fc" id="L890">                Image dbg0 = new Image(nCols, nRows);</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">                for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">                    for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L893">                        int v = thinnedLowNz[row][col];</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">                        if (v &gt; 0) {</span>
<span class="fc" id="L895">                            dbg0.setRGB(col, row, v, v, v);</span>
                        }
                    }
                }
<span class="fc bfc" id="L899" title="All 2 branches covered.">                for (PairInt p : noisePoints) {</span>
<span class="fc" id="L900">                    int[] clr = ImageIOHelper.getNextRGB(count);</span>
<span class="fc" id="L901">                    ImageIOHelper.addPointToImage(p.getY(), p.getX(), dbg0,</span>
                        1, clr[0], clr[1], clr[2]);
<span class="fc" id="L903">                    count++;</span>
<span class="fc" id="L904">                }</span>
<span class="fc" id="L905">                MiscDebug.writeImage(dbg0, &quot;_a_noise_&quot;);</span>
            }

            /*
            -- finding distance to non-noise points of the thinned default image
               from the noise points using a distance transform
            -- sorting those points by decreasing distance.
            */

<span class="fc" id="L914">            DistanceTransform dTrans = new DistanceTransform();</span>
<span class="fc" id="L915">            dt = dTrans.applyMeijsterEtAl(dt);</span>

<span class="fc" id="L917">            PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L918">            int[] xy = new int[2];</span>
            //int w = nCols;
<span class="fc" id="L920">            int h = nRows;</span>
<span class="fc" id="L921">            TLongSet pixIdxs = new TLongHashSet();</span>
            
<span class="fc bfc" id="L923" title="All 2 branches covered.">            for (PairInt p : noisePoints) {</span>
<span class="fc" id="L924">                long pixIdx = ph.toPixelIndex(p, h);</span>
<span class="fc" id="L925">                pixIdxs.add(pixIdx);</span>
<span class="fc" id="L926">            }</span>
                        
<span class="fc" id="L928">            ClusterFinder cFinder = new ClusterFinder(pixIdxs,</span>
                nRows, nCols);
            //cFinder.setToDebug();
<span class="fc" id="L931">            cFinder.setThreshholdFactor(1.f);</span>
<span class="fc" id="L932">            cFinder.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L933">            cFinder.calculateBackgroundSeparation();</span>
<span class="fc" id="L934">            cFinder.findClusters();</span>
<span class="fc" id="L935">            List&lt;TLongSet&gt; groupList = cFinder.getGroups();</span>
<span class="fc" id="L936">            final int n = groupList.size();</span>

<span class="fc" id="L938">            float[] clusterSizes = new float[n];</span>
<span class="fc" id="L939">            Image dbg = new Image(nCols, nRows);</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L941">                TLongSet groupPixs = groupList.get(i);</span>
<span class="fc" id="L942">                clusterSizes[i] = groupPixs.size();</span>
<span class="fc" id="L943">                int[] clr = ImageIOHelper.getNextRGB(i);</span>
                
<span class="fc" id="L945">                TLongIterator iter3 = groupPixs.iterator();</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">                while (iter3.hasNext()) {</span>
<span class="fc" id="L947">                    long pixIdx = iter3.next();</span>
<span class="fc" id="L948">                    ph.toPixelCoords(pixIdx, h, xy);</span>
                    
<span class="fc" id="L950">                    ImageIOHelper.addPointToImage(xy[1], xy[0], dbg,</span>
                        1, clr[0], clr[1], clr[2]);
<span class="fc" id="L952">                }</span>
            }
<span class="fc" id="L954">            MiscDebug.writeImage(dbg, &quot;_a_noise_clusters_&quot;);</span>
            
<span class="fc" id="L956">            HistogramHolder hist = Histogram.createSimpleHistogram(</span>
                0, 40, 20, clusterSizes, 
<span class="fc" id="L958">                Errors.populateYErrorsBySqrt(clusterSizes));</span>
<span class="fc" id="L959">            int peakIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="pc bnc" id="L960" title="All 2 branches missed.">            assert(peakIdx != -1); </span>
<span class="fc" id="L961">            float sizeLimit = hist.getXHist()[peakIdx];</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">            if (peakIdx &lt; (hist.getXHist().length - 2)) {</span>
<span class="fc" id="L963">                sizeLimit = hist.getXHist()[peakIdx + 2];</span>
            }
            
<span class="fc" id="L966">            System.out.println(&quot;nClusters=&quot; + n </span>
<span class="fc" id="L967">                + &quot; peakHist y=&quot; + hist.getYHist()[peakIdx] </span>
<span class="fc" id="L968">                + &quot; peakHist x=&quot; + hist.getXHist()[peakIdx] </span>
<span class="fc" id="L969">                + &quot; nPix=&quot; + img.getNPixels() + </span>
                &quot; peakX/nPix=&quot; + 
<span class="fc" id="L971">                hist.getXHist()[peakIdx]/(float)img.getNPixels() +</span>
                &quot; peakY/nPix=&quot; + 
<span class="fc" id="L973">                (float)hist.getYHist()[peakIdx]/(float)img.getNPixels()</span>
                + &quot; peakY/peakX=&quot; +
<span class="fc" id="L975">                (float)hist.getYHist()[peakIdx]/hist.getXHist()[peakIdx]</span>
            );
            
            try {
<span class="fc" id="L979">                hist.plotHistogram(&quot;cluster sizes&quot;, &quot;_cluster_sizes_&quot;);</span>
<span class="nc" id="L980">            } catch (IOException ex) {</span>
<span class="nc" id="L981">                Logger.getLogger(PhaseCongruencyDetector.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L982">            }</span>

<span class="fc" id="L984">            int[] dist = new int[n];           </span>
<span class="fc" id="L985">            int[] indexes = new int[n];</span>
<span class="fc" id="L986">            int count = 0;</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L988">                TLongSet groupPixs = groupList.get(i);</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">                if (groupPixs.size() &gt; sizeLimit) {</span>
<span class="fc" id="L990">                    continue;</span>
                }
<span class="fc" id="L992">                int sumD = 0;</span>
<span class="fc" id="L993">                int countD = 0;</span>
                
<span class="fc" id="L995">                TLongIterator iter3 = groupPixs.iterator();</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">                while (iter3.hasNext()) {</span>
<span class="fc" id="L997">                    long pixIdx = iter3.next();</span>
<span class="fc" id="L998">                    ph.toPixelCoords(pixIdx, h, xy);</span>
<span class="pc bpc" id="L999" title="3 of 4 branches missed.">                    if (noisePoints.contains(new PairInt(xy[1], xy[0])) </span>
                        &amp;&amp; dt[xy[1]][xy[0]] &gt; 0) {
<span class="nc" id="L1001">                        sumD += dt[xy[1]][xy[0]];</span>
<span class="nc" id="L1002">                        countD++;</span>
                    }
<span class="fc" id="L1004">                }</span>
                
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">                if (countD &gt; 0) {</span>
<span class="nc" id="L1007">                    indexes[count] = i;</span>
<span class="nc" id="L1008">                    sumD /= countD;</span>
<span class="nc" id="L1009">                    dist[count] = sumD;</span>
<span class="nc" id="L1010">                    count++;</span>
                }
            }
<span class="fc" id="L1013">            indexes = Arrays.copyOf(indexes, count);</span>
<span class="fc" id="L1014">            dist = Arrays.copyOf(dist, count);</span>
            
            // sort by decr dist
<span class="fc" id="L1017">            QuickSort.descendingSort(dist, indexes);</span>
            
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">            if (doPlot) {</span>
                //histogram of point distances
<span class="fc" id="L1021">                float[] values = new float[n];</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">                for (int i = 0; i &lt; dist.length; ++i) {</span>
<span class="nc" id="L1023">                    values[i] = dist[i];</span>
                }
                //TODO: consider xmax based on image size
<span class="fc" id="L1026">                hist = Histogram.createSimpleHistogram(</span>
                    0, 400, 20, values,
<span class="fc" id="L1028">                    Errors.populateYErrorsBySqrt(values));</span>

                try {
<span class="fc" id="L1031">                    hist.plotHistogram(&quot;dist from edges&quot;, &quot;_noise_distances_&quot;);</span>
<span class="nc" id="L1032">                } catch (IOException ex) {</span>
<span class="nc" id="L1033">                    Logger.getLogger(PhaseCongruencyDetector.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1034">                }</span>
            }

<span class="fc" id="L1037">            int end = 100;</span>
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">            if (end &gt; dist.length) {</span>
<span class="fc" id="L1039">                end = dist.length;</span>
            }

<span class="fc" id="L1042">            int np = 0;</span>

<span class="fc" id="L1044">            List&lt;Set&lt;PairInt&gt;&gt; subsetNoise = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="fc" id="L1045">            Image dbg0 = new Image(nCols, nRows);</span>
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">            for (int i = 0; i &lt; end; ++i) {</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                if (dist[i] &lt; distMinimum) {</span>
<span class="nc" id="L1048">                    break;</span>
                }
<span class="nc" id="L1050">                int idx = indexes[i];</span>
<span class="nc" id="L1051">                int[] clr = ImageIOHelper.getNextRGB(i);</span>
                
<span class="nc" id="L1053">                TLongSet groupPixs = groupList.get(idx);</span>
                
<span class="nc" id="L1055">                Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L1056">                TLongIterator iter3 = groupPixs.iterator();</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                while (iter3.hasNext()) {</span>
<span class="nc" id="L1058">                    long pixIdx = iter3.next();</span>
<span class="nc" id="L1059">                    ph.toPixelCoords(pixIdx, h, xy);</span>
                
<span class="nc" id="L1061">                    ImageIOHelper.addPointToImage(xy[1], xy[0], dbg0,</span>
                        1, clr[0], clr[1], clr[2]);
<span class="nc" id="L1063">                    set2.add(new PairInt(xy[1], xy[0]));</span>
<span class="nc" id="L1064">                }</span>
                
<span class="nc" id="L1066">                subsetNoise.add(set2);</span>
<span class="nc" id="L1067">                np += set2.size();</span>
            }
<span class="fc bfc" id="L1069" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L1071">                    int v = thinnedLowNz[row][col];</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                    if (v &gt; 0) {</span>
<span class="fc" id="L1073">                        dbg0.setRGB(col, row, 255, 255, 255);</span>
                    }
                }
            }
<span class="fc" id="L1077">            MiscDebug.writeImage(dbg0, &quot;_a_texture_candidates_&quot;);</span>
         
<span class="fc" id="L1079">            System.out.println(&quot;np=&quot; + np);</span>
            
<span class="fc" id="L1081">            products.setSubsetNoise(subsetNoise);</span>
        }

<span class="fc" id="L1084">        long t1 = System.currentTimeMillis();</span>

<span class="fc" id="L1086">        System.out.println(((t1 - t0)*1E-3) + &quot; seconds for phasecongmono&quot;);</span>

<span class="fc" id="L1088">        return products;</span>
    }

    private double[][] copy(double[][] a) {
<span class="fc" id="L1092">        double[][] cp = new double[a.length][];</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L1094">            cp[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }
<span class="fc" id="L1096">        return cp;</span>
    }

    /**
     * creating edges using thinned phase angle image.
     * @param pc
     * @param thinnedPC
     * @param phaseAngle
     * @param tLow
     * @param tHigh
     * @return
     */
    public int[][] createEdges(double[][] pc, double[][] thinnedPC,
        double[][] phaseAngle, double tLow, double tHigh) {

<span class="fc" id="L1111">        int nRows = phaseAngle.length;</span>
<span class="fc" id="L1112">        int nCols = phaseAngle[0].length;</span>

<span class="fc" id="L1114">        Set&lt;PairInt&gt; brightLinePoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1115">        Set&lt;PairInt&gt; darkLinePoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1116">        Set&lt;PairInt&gt; stepPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1118">        double piDiv4 = Math.PI/4.;</span>
<span class="fc" id="L1119">        double tolerance = piDiv4/2.;</span>

<span class="fc bfc" id="L1121" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; ++col) {</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">                if (thinnedPC[row][col] &lt; tLow) {</span>
<span class="fc" id="L1125">                    continue;</span>
                }
                // placing values closer to -pi/2 than 0 are darklines
                //         values closer to +p1/2 than 0 are brightlines
                //         else they are closer to 0 are steps
<span class="fc" id="L1130">                double v = phaseAngle[row][col];</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                if (Math.abs(-piDiv4 - v) &lt; tolerance) {</span>
<span class="fc" id="L1132">                    darkLinePoints.add(new PairInt(row, col));</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">                } else if (Math.abs(piDiv4 - v) &lt; tolerance) {</span>
<span class="fc" id="L1134">                    brightLinePoints.add(new PairInt(row, col));</span>
                } else {
<span class="fc" id="L1136">                    stepPoints.add(new PairInt(row, col));</span>
                }
            }
        }

        //DEBUG
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        if (doPlot) {</span>
<span class="fc" id="L1143">            Image paImage = new Image(nCols, nRows);</span>
<span class="fc" id="L1144">            int nExtraForDot = 0;</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">            for (PairInt p : brightLinePoints) {</span>
<span class="fc" id="L1146">                int x = p.getY();</span>
<span class="fc" id="L1147">                int y = p.getX();</span>
<span class="fc" id="L1148">                ImageIOHelper.addPointToImage(x, y, paImage, nExtraForDot,</span>
                    0, 255, 0);
<span class="fc" id="L1150">            }</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">            for (PairInt p : stepPoints) {</span>
<span class="fc" id="L1152">                int x = p.getY();</span>
<span class="fc" id="L1153">                int y = p.getX();</span>
<span class="fc" id="L1154">                ImageIOHelper.addPointToImage(x, y, paImage, nExtraForDot,</span>
                    255, 0, 0);
<span class="fc" id="L1156">            }</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">            for (PairInt p : darkLinePoints) {</span>
<span class="fc" id="L1158">                int x = p.getY();</span>
<span class="fc" id="L1159">                int y = p.getX();</span>
<span class="fc" id="L1160">                ImageIOHelper.addPointToImage(x, y, paImage, nExtraForDot,</span>
                    127, 0, 255);
<span class="fc" id="L1162">            }</span>
<span class="fc" id="L1163">            MiscDebug.writeImage(paImage, &quot;_a_0_pa_components_&quot; +</span>
<span class="fc" id="L1164">                MiscDebug.getCurrentTimeFormatted());</span>
        }

<span class="fc" id="L1167">        stepPoints.addAll(brightLinePoints);</span>
<span class="fc" id="L1168">        stepPoints.addAll(darkLinePoints);</span>

<span class="fc" id="L1170">        double[][] thinned1 = new double[nRows][nCols];</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L1172">            thinned1[i] = new double[nCols];</span>
        }
<span class="fc bfc" id="L1174" title="All 2 branches covered.">        for (PairInt p : stepPoints) {</span>
<span class="fc" id="L1175">            thinned1[p.getX()][p.getY()] = pc[p.getX()][p.getY()];</span>
<span class="fc" id="L1176">        }</span>
<span class="fc" id="L1177">        stepPoints = null;</span>

<span class="fc" id="L1179">        int[][] thinned = applyHysThresh(thinned1, phaseAngle, tLow, tHigh, true);</span>

<span class="fc bfc" id="L1181" title="All 2 branches covered.">        if (doPlot) {</span>
<span class="fc" id="L1182">            Image pImage = new Image(nCols, nRows);</span>
<span class="fc" id="L1183">            Image tImage = new Image(nCols, nRows);</span>
<span class="fc" id="L1184">            int nExtraForDot = 0;</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="fc" id="L1187">                    int v = (int)Math.round(255 * pc[row][col]);</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">                    if (thinned[row][col] &gt; 0) {</span>
<span class="fc" id="L1189">                        ImageIOHelper.addPointToImage(col, row, pImage,</span>
                            nExtraForDot, 255, 255, 255);
<span class="fc" id="L1191">                        ImageIOHelper.addPointToImage(col, row, tImage,</span>
                            nExtraForDot, v, v, v);
                    } else {
<span class="fc" id="L1194">                        ImageIOHelper.addPointToImage(col, row, tImage,</span>
                            nExtraForDot, v, 0, 0);
                    }
                }
            }
<span class="fc" id="L1199">            MiscDebug.writeImage(pImage, &quot;_a_1_thinned_1_&quot; +</span>
<span class="fc" id="L1200">                MiscDebug.getCurrentTimeFormatted());</span>
<span class="fc" id="L1201">            MiscDebug.writeImage(tImage, &quot;_a_2_pc_1_&quot; +</span>
<span class="fc" id="L1202">                MiscDebug.getCurrentTimeFormatted());</span>
        }

<span class="fc" id="L1205">        int[][] thinnedbw = new int[nRows][nCols];</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L1207">            thinnedbw[i] = new int[nCols];</span>
<span class="fc bfc" id="L1208" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc bfc" id="L1209" title="All 2 branches covered.">                if (thinned[i][j] &gt; 0) {</span>
<span class="fc" id="L1210">                    thinnedbw[i][j] = 1;</span>
                }
            }
        }

<span class="fc" id="L1215">        MorphologicalFilter mFilter = new MorphologicalFilter();</span>
<span class="fc" id="L1216">        int[][] skel = mFilter.bwMorphThin(thinnedbw, Integer.MAX_VALUE);</span>

<span class="fc" id="L1218">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc" id="L1221">                int m = skel[i][j];</span>
<span class="fc" id="L1222">                thinned[i][j] *= m;</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">                if (thinned[i][j] &gt; 0) {</span>
<span class="fc" id="L1224">                    points.add(new PairInt(i, j));</span>
                }
            }
        }

        //DEBUG
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        if (doPlot) {</span>
<span class="fc" id="L1231">            Image paImage = new Image(nCols, nRows);</span>
<span class="fc" id="L1232">            int nExtraForDot = 0;</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">            for (PairInt p : points) {</span>
<span class="fc" id="L1234">                int x = p.getY();</span>
<span class="fc" id="L1235">                int y = p.getX();</span>
<span class="fc" id="L1236">                ImageIOHelper.addPointToImage(x, y, paImage, nExtraForDot,</span>
                    255, 255, 255);
<span class="fc" id="L1238">            }</span>
<span class="fc" id="L1239">            MiscDebug.writeImage(paImage, &quot;_a_3_edge_from_phase_angle_thin_0_&quot; +</span>
<span class="fc" id="L1240">                MiscDebug.getCurrentTimeFormatted());</span>
        }

        //ImageProcessor imageProcessor = new ImageProcessor();
        //imageProcessor.applyThinning(points,nRows, nCols);

        //pltc.correctForLineHatHoriz(points, nRows, nCols);
        //pltc.correctForLineHatVert(points, nRows, nCols);

        // there are a very small number of clumps thicker than 1 pixel.
        //ZhangSuenLineThinner lt = new ZhangSuenLineThinner();
        //lt.applyLineThinner(points, 0, nRows - 1, 0, nCols - 1);

        /*
        PostLineThinnerCorrections pltc = new PostLineThinnerCorrections();
        pltc.correctForIsolatedPixels(stepPoints);

        for (int i = 0; i &lt; nRows; ++i) {
            Arrays.fill(thinned[i], 0);
        }
        for (PairInt p : points) {
            thinned[p.getX()][p.getY()] = 255;
        }

        //DEBUG
        if (doPlot) {
            Image paImage = new Image(nCols, nRows);
            int nExtraForDot = 0;
            for (PairInt p : points) {
                int x = p.getY();
                int y = p.getX();
                ImageIOHelper.addPointToImage(x, y, paImage, nExtraForDot,
                    255, 0, 0);
            }
            MiscDebug.writeImage(paImage, &quot;_a_3_edge_from_phase_angle_thin_1_&quot; +
                MiscDebug.getCurrentTimeFormatted());
        }
        */

<span class="fc" id="L1279">        return thinned;</span>
    }

    /**
     * creating edges using thinned phase angle image.
     * @param products
     * @param tLow
     * @param tHigh
     */
    private int countEdgePoints(PhaseCongruencyProducts products,
        double[][] thinnedPC, double tLow, double tHigh) {

<span class="nc" id="L1291">        double[][] phaseAngle = products.getPhaseAngle();</span>

<span class="nc" id="L1293">        int nRows = phaseAngle.length;</span>
<span class="nc" id="L1294">        int nCols = phaseAngle[0].length;</span>

<span class="nc" id="L1296">        int count = 0;</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">                if (thinnedPC[row][col] &lt; tLow) {</span>
<span class="nc" id="L1301">                    continue;</span>
                }
<span class="nc" id="L1303">                count++;</span>
            }
        }

<span class="nc" id="L1307">        return count;</span>
    }

    public class PhaseCongruencyProducts {

        /**
         * indicates edge significance
         */
        private final double[][] phaseCongruency;

        /**
         * Orientation image in integer degrees 0-180 with positive anticlockwise.
         */
        private final double[][] orientation;

        /**
         * Local weighted mean phase angle at every point in the image.
         * A value of pi/2 corresponds to a bright line, 0 corresponds to a
         * step and -pi/2 is a dark line.
         */
        private final double[][] phaseAngle;

        /**
         * Calculated noise threshold (can be useful for diagnosing noise
         * characteristics of images).  Once you know this you can then specify
         * fixed thresholds and save some computation time.
         */
        private final double threshold;

        private int[][] thinned = null;
        
        private int[][] thinnedLowNoise = null;

        /**
         * noisey pixels are found during the 2 level threshold hysteresis
         * phase and they sometimes contain textures such as vegetation or
         * bricks and sometimes contain edge points that should be restored
         * before this stage.
         */
        private Set&lt;PairInt&gt; noiseyPixels = null;

        /**
         * these are a subset of noiseyPixels that are the smallest
           clusters of points and furthest away from edges
           in the lower noise image
         */
        private List&lt;Set&lt;PairInt&gt;&gt; subsetNoise = null;
        
        private PhaseCongruencyParameters parameters = null;

        public PhaseCongruencyProducts(double[][] pc, double[][] or,
            double[][] ft, double thr) {
            this.phaseCongruency = copy(pc);
            this.orientation = copy(or);
            this.phaseAngle = copy(ft);
            this.threshold = thr;
        }

        /**
         * set the thinned phase congruence image, a.k.a. the edge image.
         * the image should be in row-major notation.
         * @param thImg
         */
        public void setThinnedImage(int[][] thImg) {
            thinned = copy(thImg);
        }
        
        /**
         * set the thinned low noise image (created if the user specified
         * 'extract noise').
         * the image should be in row-major notation.
         * @param thinnedLowNz 
         */
        private void setThinnedLowNoise(int[][] thinnedLowNz) {
            thinnedLowNoise = thinnedLowNz;
        }

        /**
         * get the thinned phase congruence image, a.k.a. the edge image.
         * Note that the array is accessed as a[row][column], row major notation.
         * @@return edgeImg
         */
        public int[][] getThinned() {
            return thinned;
        }
        
        /**
         * get the thinned phase congruence image that was built if the
         * user specified 'extract noise'.
         * Note that the array is accessed as a[row][column], row major notation.
         * @return 
         */
        public int[][] getThinnedLowNoise() {
            return thinnedLowNoise;
        }

        /**
         * @return noisey pixels are found by subtracting the resulting pc image
         * made with the user given k from a default k which allows
         * more noise into the image.  The resulting &quot;noisey&quot; pixels
         * may be useful for designing texture filters to remove
         * such pixels from better keypoints.
         * Note that the coordinates are in the reference frame
         * of the GreyscaleImage instance, col major notation.
         */
        public Set&lt;PairInt&gt; getNoiseyPixels(){
            return noiseyPixels;
        }
        
        /**
         * @return the subset of noiseyPixels that are the smallest
           clusters of points and furthest away from edges
           in the lower noise image.
           Note that the coordinates are in the reference frame
         * of the GreyscaleImage instance, col major notation.
         */
        public List&lt;Set&lt;PairInt&gt;&gt; getSubsetNoise() {
            return subsetNoise;
        }

        /**
         * set pixels derived from the 'extract noise' feature of the phase
         * congruency detector.
         * Note that the
         * points should be using coordinates that are in the reference frame
         * of the GreyscaleImage instance, col major notation.
         * @param pixels 
         */
        public void setNoiseyPixels(Set&lt;PairInt&gt; pixels){
            noiseyPixels = pixels;
        }

        /**
         * these are a subset of noiseyPixels that are the smallest
           clusters of points and furthest away from edges
           in the lower noise image.  Note that the
         * points should be using coordinates that are in the reference frame
         * of the GreyscaleImage instance, col major notation.
         * @param subsetNoise 
         */
        private void setSubsetNoise(List&lt;Set&lt;PairInt&gt;&gt; subsetNoise) {
            this.subsetNoise = subsetNoise;
        }

        /**
         * return the gradient image produced by phase congruency as a double
         * array of values in range 0 to 1.0.
         * Note that the array is accessed as a[row][column], row major notation.
         * @return the phaseCongruency
         */
        public double[][] getPhaseCongruency() {
            return phaseCongruency;
        }

        /**
         * return the orientation image.
         * Note that the array is accessed as a[row][column], row major notation.
         * @return the orientation
         */
        public double[][] getOrientation() {
            return orientation;
        }

        /**
         * return the phase angle image.
         * &lt;pre&gt;
         * Local weighted mean phase angle at every point in the image.
         * A value of
                pi/2 corresponds to a bright line,
                0 corresponds to a step and
                -pi/2 is a dark line.
         * &lt;/pre&gt;
         * Note that the array is accessed as a[row][column], row major notation
         * @return the phaseAngle
         */
        public double[][] getPhaseAngle() {
            return phaseAngle;
        }

        /**
         *
         * @return the threshold
         */
        public double getThreshold() {
            return threshold;
        }

        public PhaseCongruencyParameters getParameters() {
            return parameters;
        }

        private void setParameters(int nScale, int minWavelength, float mult,
            float sigmaOnf, int k, float cutOff, float g, float deviationGain,
            int noiseMethod, double tLow, double tHigh) {

            this.parameters = new PhaseCongruencyParameters();

            parameters.setParameters(nScale, minWavelength, mult, sigmaOnf, k,
                cutOff, g, deviationGain, noiseMethod, tLow, tHigh);
        }

        private void setParameters(PhaseCongruencyParameters params) {
            this.parameters = params;
        }

    }

    private Complex[][] copy(Complex[][] a) {

<span class="nc" id="L1516">        Complex[][] b = new Complex[a.length][];</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        for (int i = 0; i &lt; b.length; ++i) {</span>
<span class="nc" id="L1518">            b[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="nc" id="L1521">        return b;</span>
    }
    private int[][] copy(int[][] a) {

<span class="fc" id="L1525">        int[][] b = new int[a.length][];</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        for (int i = 0; i &lt; b.length; ++i) {</span>
<span class="fc" id="L1527">            b[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="fc" id="L1530">        return b;</span>
    }

    /**
    adapted from Kovesis phasecongmono.m as documented in class comments above.

      Mode is computed by forming a histogram of the data over 50 bins and then
      finding the maximum value in the histogram.  Mean and standard deviation
      can then be calculated from the mode as they are related by fixed
      constants.

      mean = mode * sqrt(pi/2)
      std dev = mode * sqrt((4-pi)/2)

      See
      http://mathworld.wolfram.com/RayleighDistribution.html
      http://en.wikipedia.org/wiki/Rayleigh_distribution

     * @param data data assumed to come from a Rayleigh distribution
     * @return
     */
    private double rayleighMode(double[][] data) {

<span class="nc" id="L1553">        int nBins = 50;</span>

<span class="nc" id="L1555">        float[] values = new float[data.length];</span>
<span class="nc" id="L1556">        float max = Float.NEGATIVE_INFINITY;</span>
<span class="nc" id="L1557">        int count = 0;</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">        for (int j = 0; j &lt; data.length; ++j) {</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">            for (int i = 0; i &lt; data[j].length; ++i) {</span>
<span class="nc" id="L1560">                values[count] = (float)data[j][i];</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">                if (values[count] &gt; max) {</span>
<span class="nc" id="L1562">                    max = values[i];</span>
                }
<span class="nc" id="L1564">                count++;</span>
            }
        }
<span class="nc" id="L1567">        float[] errs = Errors.populateYErrorsBySqrt(values);</span>

<span class="nc" id="L1569">        HistogramHolder hist = Histogram.createSimpleHistogram(0, max, nBins,</span>
            values, errs);

<span class="nc" id="L1572">        int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>

<span class="nc bnc" id="L1574" title="All 2 branches missed.">        if (yMaxIdx == -1) {</span>
            //should not happen
<span class="nc" id="L1576">            throw new IllegalStateException(&quot;Error in algorithm for extreme data case. &quot;</span>
                + &quot; yMaxIdx=&quot; + yMaxIdx);
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        } else if (yMaxIdx == (hist.getXHist().length - 1)) {</span>
<span class="nc" id="L1579">            return hist.getXHist()[yMaxIdx];</span>
        }

<span class="nc" id="L1582">        double rMode = (hist.getXHist()[yMaxIdx] + hist.getXHist()[yMaxIdx + 1])/2.;</span>

<span class="nc" id="L1584">        return rMode;</span>
    }

    /**
     * apply a 2 level threshold hysteresis filter to the image and use an
     * association radius of 2 and value &gt; t1 from any pixel within a
     * radius of 2 of a pixel with value &gt; t2.
     *
     * @param img the phase congruence image
     * @param t1 low threshold
     * @param t2 high threshold
     * @param restore
     * @return
     */
    int[][] applyHysThresh(double[][] img, double[][] pa, double t1, double t2,
        boolean restore) {

        // note that the kovesi code uses the octave bwselect and bwfill,
        // which results in points &gt; t2 which is thresholding just for
        // the high value.
        // here instead will use an adaptive 2-layer threshold for values &gt; t1.

<span class="fc" id="L1606">        int w = img.length;</span>
<span class="fc" id="L1607">        int h = img[0].length;</span>
<span class="fc" id="L1608">        int n = w * h;</span>

<span class="pc bpc" id="L1610" title="2 of 4 branches missed.">        if (w &lt; 3 || h &lt; 3) {</span>
<span class="nc" id="L1611">            throw new IllegalArgumentException(&quot;images should be &gt;= 3x3 in size&quot;);</span>
        }

<span class="fc" id="L1614">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="fc" id="L1616">        double[][] threshImg = null;</span>
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">        if (useAdaptiveThreshold) {</span>
<span class="fc" id="L1618">            AdaptiveThresholding th = new AdaptiveThresholding();</span>
<span class="fc" id="L1619">            threshImg = th.createAdaptiveThresholdImage(img, 15, 0.2);</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">            if (doPlot) {//DEBUG</span>
<span class="fc" id="L1621">                double[][] imgCp = imageProcessor.copy(img);</span>
<span class="fc" id="L1622">                double[][] imgCp2 = imageProcessor.copy(threshImg);</span>
<span class="fc bfc" id="L1623" title="All 2 branches covered.">                for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">                    for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L1625">                        double t = threshImg[i][j];</span>
<span class="fc bfc" id="L1626" title="All 4 branches covered.">                        if (imgCp[i][j] &gt; t &amp;&amp; imgCp[i][j] &gt; t1) {</span>
<span class="fc" id="L1627">                            imgCp[i][j] = 255.;</span>
                        } else {
<span class="fc" id="L1629">                            imgCp[i][j] = 0;</span>
                        }
<span class="fc" id="L1631">                        imgCp2[i][j] *= 255.;</span>
                    }
                }
<span class="fc" id="L1634">                MiscDebug.writeImage(imgCp, &quot;img_a_thresholded_.png&quot;);</span>
<span class="fc" id="L1635">                MiscDebug.writeImage(imgCp2, &quot;img_a_adaptive_threshold_.png&quot;);</span>
            }
        }

<span class="fc" id="L1639">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1640">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1642">        double tHigh = t2;</span>
<span class="fc" id="L1643">        double tLow = t1;</span>

<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">        System.out.println(&quot;tHigh=&quot; + tHigh +</span>
            &quot; replace with adaptive threshold image = &quot; + (threshImg != null));

<span class="fc" id="L1648">        int[][] img2 = new int[w][];</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L1650">            img2[i] = new int[h];</span>
        }

        // store pixels w/ v &gt; tHigh
        // and store any of it's neighbors w/ v &gt; tLow

<span class="fc bfc" id="L1656" title="All 2 branches covered.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="fc bfc" id="L1657" title="All 2 branches covered.">            for (int y = 0; y &lt; h; ++y) {</span>

<span class="fc" id="L1659">                double v = img[x][y];</span>

                double tHigh0, tLow0;
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">                if (threshImg != null) {</span>
<span class="fc" id="L1663">                    tHigh0 = threshImg[x][y];</span>
<span class="fc" id="L1664">                    tLow0 = tHigh0/2;</span>
                } else {
<span class="nc" id="L1666">                    tHigh0 = tHigh;</span>
<span class="nc" id="L1667">                    tLow0 = tLow;</span>
                }

<span class="fc bfc" id="L1670" title="All 4 branches covered.">                if (v &lt; tHigh0 || v &lt; tLow) {</span>
<span class="fc" id="L1671">                    continue;</span>
                }

<span class="fc" id="L1674">                img2[x][y] = 255;</span>

                // store any adjacent w/ v &gt; tLow
<span class="fc bfc" id="L1677" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1678">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L1679">                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L1680" title="4 of 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L1681">                        continue;</span>
                    }
<span class="fc" id="L1683">                    double v2 = img[x2][y2];</span>
<span class="fc bfc" id="L1684" title="All 2 branches covered.">                    if (v2 &gt; tLow0) {</span>
<span class="fc" id="L1685">                        img2[x2][y2] = 255;</span>
                    }
                }
            }
        }

<span class="fc" id="L1691">        return img2;</span>
    }

    private void DEBUG(Complex[][] tmp, String label) {

        try {
<span class="nc" id="L1697">            algorithms.util.PolygonAndPointPlotter plotter</span>
                = new algorithms.util.PolygonAndPointPlotter();

<span class="nc" id="L1700">            int nc = tmp[0].length;</span>
<span class="nc" id="L1701">            int nr = tmp.length;</span>

<span class="nc" id="L1703">            float[] x = new float[nc];</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">            for (int ii = 0; ii &lt; nc; ++ii) {</span>
<span class="nc" id="L1705">                x[ii] = ii;</span>
            }
<span class="nc" id="L1707">            float[] y = new float[nc];</span>
<span class="nc" id="L1708">            float[] xPolygon = null;</span>
<span class="nc" id="L1709">            float[] yPolygon = null;</span>

            // plot rows 0.25*nRows, 0.5*nRows, and 0.75*nRows
<span class="nc bnc" id="L1712" title="All 2 branches missed.">            for (int nf = 1; nf &lt; 4; nf++) {</span>
<span class="nc" id="L1713">                int rowNumber = (int) (((float) nf) * 0.25f * nr);</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                for (int ii = 0; ii &lt; nc; ++ii) {</span>
<span class="nc" id="L1715">                    y[ii] = (float) tmp[rowNumber][ii].re();</span>
                }
<span class="nc" id="L1717">                float minY = MiscMath.findMin(y);</span>
<span class="nc" id="L1718">                float maxY = MiscMath.findMax(y);</span>
<span class="nc" id="L1719">                plotter.addPlot(-1, nc + 1, minY, maxY, x, y, xPolygon,</span>
                    yPolygon, label + &quot; row=&quot; + rowNumber + &quot; REAL&quot;);
            }

            // do same for complex
<span class="nc bnc" id="L1724" title="All 2 branches missed.">            for (int nf = 1; nf &lt; 4; nf++) {</span>
<span class="nc" id="L1725">                int rowNumber = (int) (((float) nf) * 0.25f * nr);</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">                for (int ii = 0; ii &lt; nc; ++ii) {</span>
<span class="nc" id="L1727">                    y[ii] = (float) tmp[rowNumber][ii].im();</span>
                }
<span class="nc" id="L1729">                float minY = MiscMath.findMin(y);</span>
<span class="nc" id="L1730">                float maxY = MiscMath.findMax(y);</span>
<span class="nc" id="L1731">                plotter.addPlot(-1, nc + 1, minY, maxY, x, y, xPolygon,</span>
                    yPolygon, label + &quot; row=&quot; + rowNumber + &quot; IMAGINARY&quot;);
            }

<span class="nc" id="L1735">            plotter.writeFile();</span>
<span class="nc" id="L1736">        } catch (Exception e) {</span>
<span class="nc" id="L1737">        }</span>
<span class="nc" id="L1738">        int z = 1;</span>
<span class="nc" id="L1739">    }</span>

    private void DEBUG(double[][] tmp, String label, long fileNumber) {

        try {
<span class="nc" id="L1744">            algorithms.util.PolygonAndPointPlotter plotter</span>
                = new algorithms.util.PolygonAndPointPlotter();

<span class="nc" id="L1747">            int nc = tmp[0].length;</span>
<span class="nc" id="L1748">            int nr = tmp.length;</span>

<span class="nc" id="L1750">            float[] x = new float[nc];</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">            for (int ii = 0; ii &lt; nc; ++ii) {</span>
<span class="nc" id="L1752">                x[ii] = ii;</span>
            }
<span class="nc" id="L1754">            float[] y = new float[nc];</span>
<span class="nc" id="L1755">            float[] xPolygon = null;</span>
<span class="nc" id="L1756">            float[] yPolygon = null;</span>

<span class="nc" id="L1758">            float minY = (float)MiscMath.findMin(tmp);</span>
<span class="nc" id="L1759">            float maxY = (float)MiscMath.findMax(tmp);</span>

            // plot rows 0.25*nRows, 0.5*nRows, and 0.75*nRows
<span class="nc bnc" id="L1762" title="All 2 branches missed.">            for (int nf = 1; nf &lt; 4; nf++) {</span>
<span class="nc" id="L1763">                int rowNumber = (int) (((float) nf) * 0.25f * nr);</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">                for (int ii = 0; ii &lt; nc; ++ii) {</span>
<span class="nc" id="L1765">                    y[ii] = (float) tmp[rowNumber][ii];</span>
                }
<span class="nc" id="L1767">                plotter.addPlot(-1, nc + 1, minY, maxY, x, y, xPolygon,</span>
                    yPolygon, label + &quot; row=&quot; + rowNumber);
            }
<span class="nc" id="L1770">            plotter.writeFile(fileNumber);</span>
<span class="nc" id="L1771">            MiscDebug.writeImage(tmp, label.replaceAll(&quot;\\s&quot;, &quot;&quot;) + &quot;.png&quot;);</span>
<span class="nc" id="L1772">        } catch (Exception e) {</span>
<span class="nc" id="L1773">        }</span>
<span class="nc" id="L1774">        int z = 1;</span>
<span class="nc" id="L1775">    }</span>

    /**
     * for single purpose use to examine the monogenic transform
     * in domain space before inverse transform to frequency space.
     * @param img
     * @param minWavelength
     * @param mult
     * @param sigmaOnf
     * @return
     */
    public static double[][] logGaborFreqDomainFilter(GreyscaleImage img,
        final int minWavelength, final float mult, final float sigmaOnf,
        int s) {

<span class="nc" id="L1790">        int noiseMethod = -1;</span>

<span class="nc" id="L1792">        int nCols = img.getWidth();</span>
<span class="nc" id="L1793">        int nRows = img.getHeight();</span>

<span class="nc" id="L1795">        FilterGrid fg = new FilterGrid();</span>
<span class="nc" id="L1796">        FilterGrid.FilterGridProducts fgProducts = fg.filtergrid(nRows, nCols);</span>
<span class="nc" id="L1797">        fgProducts.getRadius()[0][0] = 1;</span>
<span class="nc" id="L1798">        double[][] radius = fgProducts.getRadius();</span>

<span class="nc" id="L1800">        LowPassFilter lpFilter = new LowPassFilter();</span>
<span class="nc" id="L1801">        double[][] lp = lpFilter.lowpassfilter(nRows, nCols, 0.45f, 15);</span>

        // keeping taus in case need to increase noise estimate
<span class="nc" id="L1804">        double logGaborDenom = 2. * Math.pow(Math.log(sigmaOnf), 2);</span>

        // Centre frequency of filter.
<span class="nc" id="L1807">        double wavelength = minWavelength * Math.pow(mult, s);</span>

<span class="nc" id="L1809">        double fo = 1.0/wavelength;</span>

        // use notation a[row][col]
<span class="nc" id="L1812">        double[][] logGabor = new double[nRows][];</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="nc" id="L1814">            logGabor[row] = new double[nCols];</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">            for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="nc" id="L1816">                double v = Math.log(radius[row][col]/fo);</span>
<span class="nc" id="L1817">                v *= v;</span>
<span class="nc" id="L1818">                v = Math.exp(-v/logGaborDenom);</span>
                //logGabor = logGabor.*lp;
<span class="nc" id="L1820">                logGabor[row][col] = lp[row][col] * v;</span>
            }
        }
<span class="nc" id="L1823">        logGabor[0][0] = 0;</span>

<span class="nc" id="L1825">        return logGabor;</span>
    }

    /**
     * for single purpose use to examine creating a filter that can be
     * applied to other images in frequency domain space before
     * transforming back to spatial domain.
     * @param img
     * @return row major result
     */
    public static Complex[][] createLowPassFreqDomainFilter(GreyscaleImage img) {

<span class="nc" id="L1837">        int nCols = img.getWidth();</span>
<span class="nc" id="L1838">        int nRows = img.getHeight();</span>

<span class="nc" id="L1840">        FilterGrid fg = new FilterGrid();</span>
<span class="nc" id="L1841">        FilterGrid.FilterGridProducts fgProducts = fg.filtergrid(nRows, nCols);</span>
<span class="nc" id="L1842">        fgProducts.getRadius()[0][0] = 1;</span>
<span class="nc" id="L1843">        double[][] radius = fgProducts.getRadius();</span>

<span class="nc" id="L1845">        LowPassFilter lpFilter = new LowPassFilter();</span>
<span class="nc" id="L1846">        double[][] lp = lpFilter.lowpassfilter(nRows, nCols, 0.45f, 15);</span>


        //Periodic Fourier transform of image, using default normalization
        // perfft2 results use notation a[row][col]
<span class="nc" id="L1851">        PeriodicFFT perfft2 = new PeriodicFFT();</span>
        //IM = perfft2(im);                   %
        //S, P, s, p where S = FFT of smooth, P = FFT of periodic, s=spatial smooth, p = spatial p
<span class="nc" id="L1854">        Complex[][][] perfResults = perfft2.perfft2(img, false);</span>
<span class="nc" id="L1855">        Complex[][] capIm = perfResults[1];</span>

<span class="nc" id="L1857">        ComplexModifiable sumAbs = new ComplexModifiable(0, 0);</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="nc" id="L1860">                capIm[row][col] = capIm[row][col].times(lp[row][col]);</span>
<span class="nc" id="L1861">                sumAbs.plus(capIm[row][col]);</span>
            }
        }

        //normalize this to sum of zero and unit standard deviation
<span class="nc" id="L1866">        sumAbs.times(1./((double)nCols * nRows));</span>
<span class="nc" id="L1867">        Complex mean = new Complex(sumAbs.re(), sumAbs.im());</span>
<span class="nc" id="L1868">        Complex factor = new Complex(sumAbs.re(), sumAbs.im());</span>
<span class="nc" id="L1869">        factor = factor.times(1./Math.sqrt(2));</span>

<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if (sumAbs.abs() != 0) {</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">            for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">                for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="nc" id="L1874">                    Complex v = capIm[row][col].minus(mean);</span>
<span class="nc" id="L1875">                    capIm[row][col] = v.times(factor);</span>
                }
            }
        }

<span class="nc" id="L1880">        return capIm;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
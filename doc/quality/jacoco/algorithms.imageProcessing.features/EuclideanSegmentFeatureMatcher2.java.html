<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EuclideanSegmentFeatureMatcher2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">EuclideanSegmentFeatureMatcher2.java</span></div><h1>EuclideanSegmentFeatureMatcher2.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.compGeometry.RotatedOffsets;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.SegmentationType;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 class whose goal is to find best single euclidean transformation for 
 image1 to image2.  It uses segmentation to create blobs.
 The &quot;points of interest&quot; are either made from the blob perimeters or
 from 2nd derivatives of gaussian convolution with greyscale image.
 It matches the points from image1 against points from image 2
 using features and those with a close 2nd best SSD match are discarded.
 The points are then associated with the enclosing blobs and
 then combinations of the blobs are made to create euclidean transformations.
 The transformations are evaluated against all points.
 (Note if that is successful, will try to evaluate against only the
 matched points which are fewer in number and will change class to use that
 logic if tests pass).
 
 The checkerboard tests do not match well with this one because the points are
 not unique enough, but EuclideanSegmentFeatureMatcher does solve it.
 SO, when this method returns very few or no matched points, the invoker
 should then follow with EuclideanSegmentFeatureMatcher.
 
 * @author nichole
 */
public class EuclideanSegmentFeatureMatcher2 extends AbstractFeatureMatcher {

<span class="fc" id="L44">    protected TransformationParameters solutionTransformation = null;</span>
    
    public EuclideanSegmentFeatureMatcher2(ImageExt image1, ImageExt image2,
        FeatureMatcherSettings settings) {
        
<span class="fc" id="L49">          super(image1, image2, settings);</span>
<span class="fc" id="L50">    }</span>
    
    @Override
    protected void prepareCorners(SegmentationType type, boolean useBinned) 
        throws IOException, NoSuchAlgorithmException {
        
        // overriding to add logic for settings for 2nd deriv points
        
<span class="fc" id="L58">        super.prepareCorners(type, useBinned);</span>
        
<span class="pc bpc" id="L60" title="3 of 4 branches missed.">        if (settings.doUse2ndDerivCorners() &amp;&amp; type.equals(SegmentationType.NONE)) {</span>
            
            // create blobs, and associate 2nd deriv pts with the blobs.
            // Note that this is repeating some work.
            // these feature matchers will be refactored soon.
            
<span class="nc" id="L66">            SegmentationType type2 = SegmentationType.GREYSCALE_WAVELET;</span>

<span class="nc" id="L68">            img1Helper.applySegmentation(type2, useBinned);</span>
<span class="nc" id="L69">            img2Helper.applySegmentation(type2, useBinned);</span>

<span class="nc" id="L71">            img1Helper.extractSecondDerivativeCorners(type2, useBinned);</span>
<span class="nc" id="L72">            img2Helper.extractSecondDerivativeCorners(type2, useBinned);</span>
        }
        
<span class="fc" id="L75">    }</span>

    @Override
    protected boolean match(SegmentationType type, boolean useBinned) {
        
<span class="pc bpc" id="L80" title="3 of 4 branches missed.">        if (settings.doUse2ndDerivCorners() &amp;&amp; type.equals(SegmentationType.NONE)) {</span>
            // for 2nd pt derivs, need to override the type to wavelet.
            // this should be handled better after refacoring.
<span class="nc" id="L83">            type = SegmentationType.GREYSCALE_WAVELET;</span>
        }
        
        int binFactor1, binFactor2;
        GreyscaleImage img1, img2;
        IntensityFeatures f1, f2;
        
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (useBinned) {</span>
<span class="fc" id="L91">            binFactor1 = img1Helper.getBinFactor(useBinned);</span>
<span class="fc" id="L92">            binFactor2 = img2Helper.getBinFactor(useBinned);</span>
<span class="fc" id="L93">            img1 = img1Helper.getGreyscaleImageBinned();</span>
<span class="fc" id="L94">            img2 = img2Helper.getGreyscaleImageBinned();</span>
<span class="fc" id="L95">            f1 = featuresBinned1;</span>
<span class="fc" id="L96">            f2 = featuresBinned2;</span>
        } else {
<span class="nc" id="L98">            binFactor1 = 1;</span>
<span class="nc" id="L99">            binFactor2 = 1;</span>
<span class="nc" id="L100">            img1 = img1Helper.getGreyscaleImage();</span>
<span class="nc" id="L101">            img2 = img2Helper.getGreyscaleImage();</span>
<span class="nc" id="L102">            f1 = features1;</span>
<span class="nc" id="L103">            f2 = features2;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (!f1.gradientWasCreated()) {</span>
<span class="nc" id="L105">                f1.calculateGradientWithGreyscale(</span>
<span class="nc" id="L106">                    img1Helper.getGreyscaleImage().copyImage());</span>
            }
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (!f2.gradientWasCreated()) {</span>
<span class="nc" id="L109">                f2.calculateGradientWithGreyscale(</span>
<span class="nc" id="L110">                    img2Helper.getGreyscaleImage().copyImage());</span>
            }
        }
        
<span class="fc" id="L114">        List&lt;List&lt;CornerRegion&gt;&gt; corners1List = img1Helper.getPerimeterCorners(</span>
            type, useBinned);
        
<span class="fc" id="L117">        List&lt;List&lt;CornerRegion&gt;&gt; corners2List = img2Helper.getPerimeterCorners(</span>
            type, useBinned);
                 
<span class="fc" id="L120">        int dither = 1;        </span>
        
<span class="fc" id="L122">        List&lt;CornerRegion&gt; corners1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L123">        List&lt;CornerRegion&gt; corners2 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (int i = 0; i &lt; corners1List.size(); ++i) {</span>
<span class="fc" id="L125">            corners1.addAll(corners1List.get(i));</span>
        }
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (int i = 0; i &lt; corners2List.size(); ++i) {</span>
<span class="fc" id="L128">            corners2.addAll(corners2List.get(i));</span>
        }

<span class="fc" id="L131">        CornerMatcher&lt;CornerRegion&gt; matcher = new CornerMatcher&lt;CornerRegion&gt;(dither);</span>

<span class="fc" id="L133">        boolean matched = matcher.matchCorners(f1, f2, corners1, corners2, </span>
            img1, img2, binFactor1, binFactor2);

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (!matched) {</span>
<span class="nc" id="L137">            return false;</span>
        }
        
        /*MiscDebug.writeImagesInAlternatingColor(img1.copyToColorGreyscaleExt(), 
            img2.copyToColorGreyscaleExt(), matcher.getSolutionStats(), 
            &quot;_matched_non_euclid_&quot; + MiscDebug.getCurrentTimeFormatted(), 2);
        */
        
<span class="fc" id="L145">        List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;(); </span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (FeatureComparisonStat stat :  matcher.getSolutionStats()) {</span>
<span class="fc" id="L147">            stats.add(stat.copy());</span>
<span class="fc" id="L148">        }</span>
        
<span class="fc" id="L150">        matcher = null;</span>
        
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (stats.isEmpty()) {</span>
<span class="nc" id="L153">            return false;</span>
        }
        
        /*
        matched1 and matched2 are both associated with blobs.
        
        key = index1, index2
        value = all matches for those 2 blobs
        
        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; 
        */
        
<span class="fc" id="L165">        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; index1Index2Matches </span>
<span class="fc" id="L166">            = associateMatchesWithBlobs(stats, </span>
<span class="fc" id="L167">            img1Helper.getBlobs(type, useBinned),</span>
<span class="fc" id="L168">            img2Helper.getBlobs(type, useBinned));</span>
        
<span class="fc" id="L170">        filterForLocalization(img1Helper.getGreyscaleImage(useBinned),</span>
<span class="fc" id="L171">            img2Helper.getGreyscaleImage(useBinned), f1, f2,</span>
            index1Index2Matches);
        /*
        if (true) {
            GreyscaleImage im1 = img1Helper.getGreyscaleImage(useBinned);
            GreyscaleImage im2 = img2Helper.getGreyscaleImage(useBinned);
            List&lt;FeatureComparisonStat&gt; blobAssoc = new ArrayList&lt;FeatureComparisonStat&gt;();
            for (java.util.Map.Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : index1Index2Matches.entrySet()) {
                blobAssoc.addAll(entry.getValue());
            }
            MiscDebug.writeImagesInAlternatingColor(img1.copyToColorGreyscaleExt(), 
                img2.copyToColorGreyscaleExt(), blobAssoc, 
                &quot;_matched_assoc_blobs_&quot; + MiscDebug.getCurrentTimeFormatted(), 2);
            log.info(index1Index2Matches.size() + &quot; blob pairs to match from&quot;);
            log.info(blobAssoc.size() + &quot; matched points associated w/ blobs&quot;);
        }*/
                
<span class="fc" id="L188">        BlobCornersEuclideanCalculator2 calculator = </span>
            new BlobCornersEuclideanCalculator2();
        
<span class="fc" id="L191">        MatchingSolution soln = calculator.solveTransformation(</span>
<span class="fc" id="L192">            img1Helper.getGreyscaleImage(useBinned),</span>
<span class="fc" id="L193">            img2Helper.getGreyscaleImage(useBinned),</span>
            f1, f2, dither, index1Index2Matches,
            corners1, corners2, binFactor1, binFactor2);
        
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (soln == null) {</span>
<span class="nc" id="L198">            return false;</span>
        }
        
<span class="fc" id="L201">        log.info(soln.getParams().toString());</span>
            
        // transform images to full size
<span class="fc" id="L204">        soln = transformSolutionToFullFrames(soln, img1Helper, img2Helper, </span>
            binFactor1, binFactor2);

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (soln == null) {</span>
<span class="nc" id="L208">            return false;</span>
        }
            
<span class="fc" id="L211">        log.info(&quot;full frame soln: &quot; + soln.getParams().toString());</span>
        
<span class="fc" id="L213">        copyToInstanceVars(soln.getComparisonStats());</span>
        
<span class="fc" id="L215">        solutionTransformation = soln.getParams().copy();</span>
                
<span class="fc" id="L217">        return true;</span>
    }

    public TransformationParameters getSolutionTransformationParameters() {
<span class="fc" id="L221">        return solutionTransformation;</span>
    }

    private Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; associateMatchesWithBlobs(
        List&lt;FeatureComparisonStat&gt; stats, List&lt;Set&lt;PairInt&gt;&gt; blobs1, 
        List&lt;Set&lt;PairInt&gt;&gt; blobs2) {
        
        /*
        to make the lookups for stats points O(1), could make a large map for each
        blobs collection w/ key = coord and value= list index.  iterating over
        all blob points is nBlobs * avgBlobSize * 2 where 2 is once for image1,
        and then image2.
        
        if there are 100 stats and blobs1 size = blobs2 = 50,
        then finding indexes for all stats is at most 100*50 + 100*50 = 10,000
        
        if make large map, and if each blob has n points,
          50*n*2 + 100*2  is number of lookups, so it's only a better runtime if
        avg size of blobs is &lt; 100 for this example.
        */
        
<span class="fc" id="L242">        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; matchedBlobs = </span>
            new HashMap&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt;();

<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
            
<span class="fc" id="L247">            FeatureComparisonStat stat = stats.get(i);</span>
            
<span class="fc" id="L249">            PairInt p1 = stat.getImg1Point();</span>
<span class="fc" id="L250">            PairInt p2 = stat.getImg2Point();</span>
            
<span class="fc" id="L252">            PairInt indexes = new PairInt(0, 0);</span>
            
<span class="fc" id="L254">            boolean found = false;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            for (int j = 0; j &lt; blobs1.size(); ++j) {</span>
<span class="fc" id="L256">                Set&lt;PairInt&gt; blob = blobs1.get(j);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">                if (blob.contains(p1)) {</span>
<span class="fc" id="L258">                    indexes.setX(j);</span>
<span class="fc" id="L259">                    found = true;</span>
<span class="fc" id="L260">                    break;</span>
                }
            }
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L264">                continue;</span>
            }
<span class="fc" id="L266">            found = false;</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            for (int j = 0; j &lt; blobs2.size(); ++j) {</span>
<span class="fc" id="L268">                Set&lt;PairInt&gt; blob = blobs2.get(j);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (blob.contains(p2)) {</span>
<span class="fc" id="L270">                    indexes.setY(j);</span>
<span class="fc" id="L271">                    found = true;</span>
<span class="fc" id="L272">                    break;</span>
                }
            }
            
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L277">                continue;</span>
            }
            
<span class="fc" id="L280">            List&lt;FeatureComparisonStat&gt; list = matchedBlobs.get(indexes);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L282">                list = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L283">                matchedBlobs.put(indexes, list);</span>
            }
<span class="fc" id="L285">            list.add(stat);</span>
        }
        
<span class="fc" id="L288">        return matchedBlobs;</span>
    }

    private void filterForLocalization(GreyscaleImage img1, 
        GreyscaleImage img2, IntensityFeatures features1, 
        IntensityFeatures features2, Map&lt;PairInt, 
            List&lt;FeatureComparisonStat&gt;&gt; index1Index2Matches) {
        
<span class="fc" id="L296">        Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : index1Index2Matches.entrySet()) {</span>
<span class="fc" id="L299">            List&lt;FeatureComparisonStat&gt; stats = entry.getValue();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            for (int i = (stats.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L301">                FeatureComparisonStat stat = stats.get(i);</span>
<span class="fc" id="L302">                PairInt p1 = stat.getImg1Point();</span>
                try {
<span class="fc bfc" id="L304" title="All 2 branches covered.">                    if (features1.removeDueToLocalization(img1, p1.getX(), p1.getY(),</span>
<span class="fc" id="L305">                        features1.calculateOrientation(p1.getX(), p1.getY()))) {</span>
<span class="fc" id="L306">                        stats.remove(i);</span>
<span class="fc" id="L307">                        continue;</span>
                    }
<span class="fc" id="L309">                    PairInt p2 = stat.getImg2Point();</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if (features2.removeDueToLocalization(img2, p2.getX(), p2.getY(),</span>
<span class="fc" id="L311">                        features2.calculateOrientation(p2.getX(), p2.getY()))) {</span>
<span class="fc" id="L312">                        stats.remove(i);</span>
<span class="fc" id="L313">                        continue;</span>
                    }
<span class="nc" id="L315">                } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L316">                }</span>
            }
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (stats.isEmpty()) {</span>
<span class="fc" id="L319">                remove.add(entry.getKey());</span>
            }
<span class="fc" id="L321">        }</span>
        
<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (PairInt key : remove) {</span>
<span class="fc" id="L324">            index1Index2Matches.remove(key);</span>
<span class="fc" id="L325">        }</span>
<span class="fc" id="L326">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
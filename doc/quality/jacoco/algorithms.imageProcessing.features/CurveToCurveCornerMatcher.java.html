<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CurveToCurveCornerMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">CurveToCurveCornerMatcher.java</span></div><h1>CurveToCurveCornerMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;

/**
 * class to invoke methods needed to solve for euclidean scale between
 * image1 and image2 using methods specific to corners on closed curves.
 *
 * @author nichole
 */
public class CurveToCurveCornerMatcher &lt;T extends CornerRegion&gt; {
    
<span class="fc" id="L21">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L23">    private List&lt;FeatureComparisonStat&gt; solutionStats = null;</span>
    
<span class="fc" id="L25">    private List&lt;PairInt&gt; matched1 = null;</span>
    
<span class="fc" id="L27">    private List&lt;PairInt&gt; matched2 = null;</span>

    /**
     * @return the solutionStats
     */
    public List&lt;FeatureComparisonStat&gt; getSolutionStats() {
<span class="fc" id="L33">        return solutionStats;</span>
    }

    /**
     * @return the matched1
     */
    public List&lt;PairInt&gt; getMatched1() {
<span class="nc" id="L40">        return matched1;</span>
    }

    /**
     * @return the matched2
     */
    public List&lt;PairInt&gt; getMatched2() {
<span class="nc" id="L47">        return matched2;</span>
    }

    private enum State {
        INITIALIZED, FAILED, SOLVED
    }

<span class="fc" id="L54">    private State state = null;</span>
    
    private final int dither;

<span class="fc" id="L58">    public CurveToCurveCornerMatcher(int dither) {</span>
<span class="fc" id="L59">        this.dither = dither;</span>
<span class="fc" id="L60">    }</span>
    
    private void resetDefaults() {
<span class="nc" id="L63">        state = null;</span>
<span class="nc" id="L64">        solutionStats = null;</span>
<span class="nc" id="L65">        matched1 = null;</span>
<span class="nc" id="L66">        matched2 = null;</span>
<span class="nc" id="L67">    }</span>
    
    public boolean matchCorners(
        final IntensityFeatures features1, final IntensityFeatures features2,
        final List&lt;List&lt;T&gt;&gt; cornerLists1, final List&lt;List&lt;T&gt;&gt; cornerLists2, 
        GreyscaleImage img1, GreyscaleImage img2, int binFactor1, int binFactor2) {
        
<span class="fc" id="L74">        int n1 = 0;</span>
<span class="fc" id="L75">        int n2 = 0;</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        for (List&lt;T&gt; list : cornerLists1) {</span>
<span class="fc" id="L77">            n1 += list.size();</span>
<span class="fc" id="L78">        }</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (List&lt;T&gt; list : cornerLists2) {</span>
<span class="fc" id="L80">            n2 += list.size();</span>
<span class="fc" id="L81">        }</span>

<span class="pc bpc" id="L83" title="2 of 4 branches missed.">        if (n1 == 0 || n2 == 0) {</span>
<span class="nc" id="L84">            state = State.FAILED;</span>
<span class="nc" id="L85">            return false;</span>
        }
        
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        if (state != null) {</span>
<span class="nc" id="L89">            resetDefaults();</span>
        }
/*        
MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();
float[] xPoints1 = new float[cornerLists1.size()];
float[] yPoints1 = new float[cornerLists1.size()];
double[][] xy1 = new double[cornerLists1.size()][2];
for (int i = 0; i &lt; cornerLists1.size(); ++i) {
xy1[i] = curveHelper.calculateXYCentroids0(cornerLists1.get(i));
xPoints1[i] = (float)xy1[i][0];
yPoints1[i] = (float)xy1[i][1];
}
float[] xPoints2 = new float[cornerLists2.size()];
float[] yPoints2 = new float[cornerLists2.size()];
double[][] xy2 = new double[cornerLists2.size()][2];
for (int i = 0; i &lt; cornerLists2.size(); ++i) {
xy2[i] = curveHelper.calculateXYCentroids0(cornerLists2.get(i));
xPoints2[i] = (float)xy2[i][0];
yPoints2[i] = (float)xy2[i][1];
}
StringBuilder sb = new StringBuilder(&quot;xy1:\n&quot;);
for (int i = 0; i &lt; xy1.length; ++i) {
    sb.append(String.format(&quot;[%2d] (%3d, %3d)\n&quot;, i,
        (int)Math.round(xy1[i][0]), (int)Math.round(xy1[i][1])));
}
sb.append(&quot;xy2:\n&quot;);
for (int i = 0; i &lt; xy2.length; ++i) {
    sb.append(String.format(&quot;[%2d] (%3d, %3d)\n&quot;, i,
        (int)Math.round(xy2[i][0]), (int)Math.round(xy2[i][1])));
}
System.out.println(sb.toString());
*/
<span class="fc" id="L121">        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; statsMap = </span>
            new HashMap&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt;();
        
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (int idx1 = 0; idx1 &lt; cornerLists1.size(); ++idx1) {</span>

<span class="fc" id="L126">            List&lt;T&gt; corners1 = cornerLists1.get(idx1);</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (corners1.size() &lt; 1) {</span>
<span class="fc" id="L129">                continue;</span>
            }

<span class="fc" id="L132">            int maxNEval = Integer.MIN_VALUE;</span>
<span class="fc" id="L133">            Integer maxNEvalIndex2 = null;</span>
<span class="fc" id="L134">            double minCost = Double.MAX_VALUE;</span>
<span class="fc" id="L135">            List&lt;FeatureComparisonStat&gt; minCostStats = null;</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">            for (int idx2 = 0; idx2 &lt; cornerLists2.size(); ++idx2) {</span>

<span class="fc" id="L139">                List&lt;T&gt; corners2 = cornerLists2.get(idx2);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">                if (corners2.size() &lt; 1) {</span>
<span class="fc" id="L142">                    continue;</span>
                }

<span class="fc" id="L145">                Integer index2 = Integer.valueOf(idx2);</span>
        
<span class="fc" id="L147">                CornerMatcher&lt;T&gt; matcher = new CornerMatcher&lt;T&gt;(dither);</span>
        
<span class="fc" id="L149">                boolean matched = matcher.matchCorners(features1, features2,</span>
                    corners1, corners2, img1, img2, binFactor1, binFactor2);

<span class="fc bfc" id="L152" title="All 2 branches covered.">                if (!matched) {</span>
<span class="fc" id="L153">                    continue;</span>
                }
                
<span class="fc" id="L156">                List&lt;FeatureComparisonStat&gt; stats2 = matcher.getSolutionStats();</span>
                
<span class="fc" id="L158">                int nEval = stats2.size();</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                if (nEval &lt; 1) {</span>
<span class="nc" id="L161">                    continue;</span>
                }
                
<span class="fc" id="L164">                double cost = MiscStats.calculateCombinedIntensityStat(stats2);</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (cost &lt; minCost) {</span>
<span class="fc" id="L167">                    maxNEval = nEval;</span>
<span class="fc" id="L168">                    maxNEvalIndex2 = index2;</span>
<span class="fc" id="L169">                    minCost = cost;</span>
<span class="fc" id="L170">                    minCostStats = stats2;</span>
<span class="fc bfc" id="L171" title="All 4 branches covered.">                } else if ((maxNEval == 2) &amp;&amp; (nEval &gt; 3)) {</span>
                    //TODO: may need to revise this
<span class="fc" id="L173">                    double avgCost = (cost + minCost)/2.;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                    if ((Math.abs(cost - avgCost)/(0.1*avgCost)) &lt; 2) {</span>
<span class="fc" id="L175">                        maxNEval = nEval;</span>
<span class="fc" id="L176">                        maxNEvalIndex2 = index2;</span>
<span class="fc" id="L177">                        minCost = cost;</span>
<span class="fc" id="L178">                        minCostStats = stats2;</span>
                    }
                }
            }

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (minCostStats != null) {</span>
<span class="fc" id="L184">                statsMap.put(new PairInt(idx1, maxNEvalIndex2.intValue()),</span>
                    minCostStats);
            }
        }
        
        // might need to consider homology except that want to be able
        // to identify an object whose position has changed relative to
        // other objects due to motion or perspective change or different
        // camera perspective, etc.
        
<span class="fc" id="L194">        List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : statsMap.entrySet()) {</span>
<span class="fc" id="L196">            stats.addAll(entry.getValue());</span>
<span class="fc" id="L197">        }</span>
        
<span class="fc" id="L199">        MiscStats.filterForDegeneracy(stats);</span>
        
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (stats.isEmpty()) {</span>
<span class="nc" id="L202">            state = State.FAILED;</span>
<span class="nc" id="L203">            return false;</span>
        }
        
<span class="fc" id="L206">        solutionStats = stats;</span>
    
<span class="fc" id="L208">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
    
<span class="fc" id="L210">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="fc" id="L213">            PairInt p1 = stat.getImg1Point();</span>
<span class="fc" id="L214">            PairInt p2 = stat.getImg2Point();</span>
<span class="fc" id="L215">            matched1.add(p1);</span>
<span class="fc" id="L216">            matched2.add(p2);</span>
<span class="fc" id="L217">        }</span>

<span class="fc" id="L219">        return true;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
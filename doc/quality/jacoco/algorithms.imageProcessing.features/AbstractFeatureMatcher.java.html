<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractFeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">AbstractFeatureMatcher.java</span></div><h1>AbstractFeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.imageProcessing.*;
import algorithms.compGeometry.HoughTransform;
import algorithms.compGeometry.HoughTransform.HoughTransformLines;
import algorithms.compGeometry.RotatedOffsets;
import algorithms.imageProcessing.scaleSpace.CurvatureScaleSpaceCornerDetector;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public abstract class AbstractFeatureMatcher {</span>
    
<span class="fc" id="L28">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L30">    protected final int binnedImageMaxDimension = 512;</span>
    
    protected final BlobPerimeterCornerHelper img1Helper;
    
    protected final BlobPerimeterCornerHelper img2Helper;
    
    // use with img1Helper.getImage() or getGreyscaleImage(), but not both
    protected final IntensityFeatures features1;
    
    // use img2Helper.getGreyscaleImageBinned(),
    protected final IntensityFeatures featuresBinned1;
    
    protected final IntensityFeatures features2;
    
    protected final IntensityFeatures featuresBinned2;
    
    protected final FeatureMatcherSettings settings;
    
<span class="fc" id="L48">    protected boolean useSameSegmentation = false;</span>
    
<span class="fc" id="L50">    protected List&lt;FeatureComparisonStat&gt; solutionStats = null;</span>
    
<span class="fc" id="L52">    protected List&lt;PairInt&gt; solutionMatched1 = null;</span>
    
<span class="fc" id="L54">    protected List&lt;PairInt&gt; solutionMatched2 = null;</span>
    
    public AbstractFeatureMatcher(ImageExt img1, ImageExt img2, 
<span class="fc" id="L57">        FeatureMatcherSettings settings) {</span>
        
<span class="fc" id="L59">        RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
        
<span class="fc" id="L61">        this.settings = settings.copy();</span>
                
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
            
<span class="fc" id="L65">            img1Helper = new BlobPerimeterCornerHelper(img1, settings.getDebugTag() + &quot;_1&quot;);</span>

<span class="fc" id="L67">            img2Helper = new BlobPerimeterCornerHelper(img2, settings.getDebugTag() + &quot;_2&quot;);</span>
            
        } else {
            
<span class="nc" id="L71">            img1Helper = new BlobPerimeterCornerHelper(img1);</span>

<span class="nc" id="L73">            img2Helper = new BlobPerimeterCornerHelper(img2);</span>
        }
              
        // delaying creation of gradient images for full images until needed:
<span class="fc" id="L77">        features1 = new IntensityFeatures(5, settings.useNormalizedFeatures(),</span>
            rotatedOffsets);

<span class="fc" id="L80">        features2 = new IntensityFeatures(5, settings.useNormalizedFeatures(),</span>
            rotatedOffsets);
                        
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (settings.startWithBinnedImages()) {</span>
            
<span class="fc" id="L85">            img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            
<span class="fc" id="L87">            img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
                        
<span class="fc" id="L89">            featuresBinned1 = new IntensityFeatures(5, </span>
<span class="fc" id="L90">                settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L91">            featuresBinned1.calculateGradientWithGreyscale(img1Helper.getGreyscaleImageBinned());</span>
            
<span class="fc" id="L93">            featuresBinned2 = new IntensityFeatures(5, </span>
<span class="fc" id="L94">                settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L95">            featuresBinned2.calculateGradientWithGreyscale(img2Helper.getGreyscaleImageBinned());</span>
            
        } else {
            
<span class="nc" id="L99">            featuresBinned1 = null;</span>
            
<span class="nc" id="L101">            featuresBinned2 = null;  </span>
        }
<span class="fc" id="L103">    }</span>

    public boolean match() throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L107">        ImageStatistics statsR1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L108">            img1Helper.getImage().getRValues(), true);</span>
<span class="fc" id="L109">        ImageStatistics statsB1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L110">            img1Helper.getImage().getBValues(), true);</span>
<span class="fc" id="L111">        ImageStatistics statsG1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L112">            img1Helper.getImage().getGValues(), true);</span>
<span class="fc" id="L113">        ImageStatistics statsR2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L114">            img2Helper.getImage().getRValues(), true);</span>
<span class="fc" id="L115">        ImageStatistics statsB2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L116">            img2Helper.getImage().getBValues(), true);</span>
<span class="fc" id="L117">        ImageStatistics statsG2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L118">            img2Helper.getImage().getGValues(), true);</span>
        
<span class="fc" id="L120">        log.info(&quot;stats R1=&quot; + statsR1.toString());</span>
<span class="fc" id="L121">        log.info(&quot;stats G1=&quot; + statsG1.toString());</span>
<span class="fc" id="L122">        log.info(&quot;stats B1=&quot; + statsB1.toString());</span>
<span class="fc" id="L123">        log.info(&quot;stats R2=&quot; + statsR2.toString());</span>
<span class="fc" id="L124">        log.info(&quot;stats G2=&quot; + statsG2.toString());</span>
<span class="fc" id="L125">        log.info(&quot;stats B2=&quot; + statsB2.toString());</span>
<span class="fc" id="L126">        int limit = 20;</span>
<span class="fc" id="L127">        useSameSegmentation = false;</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if ((Math.abs(statsR1.getMode() - statsR2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            (Math.abs(statsG1.getMode() - statsG2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            (Math.abs(statsB1.getMode() - statsB2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            (Math.abs(statsR1.getMedian() - statsR2.getMedian()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">            (Math.abs(statsG1.getMedian() - statsG2.getMedian()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            (Math.abs(statsB1.getMedian() - statsB2.getMedian()) &lt; limit)) {</span>
<span class="fc" id="L134">            useSameSegmentation = true;</span>
        }
        
        //TODO: document this logic for the user
<span class="fc" id="L138">        SegmentationType type = SegmentationType.GREYSCALE_WAVELET;</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (settings.doOverrideWithCannySegmentation()) {</span>
<span class="nc" id="L140">            type = SegmentationType.GREYSCALE_CANNY;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        } else if (settings.doUse2ndDerivCorners()) {</span>
<span class="fc" id="L142">            type = SegmentationType.NONE;</span>
        }
        
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        boolean[] useBinned = settings.startWithBinnedImages() ? </span>
            new boolean[]{true, false} : new boolean[]{false};
        
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        for (boolean ub : useBinned) {</span>
            
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (!ub) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">                if (!features1.gradientWasCreated()) {</span>
<span class="fc" id="L152">                    features1.calculateGradientWithGreyscale(</span>
<span class="fc" id="L153">                        img1Helper.getGreyscaleImage());</span>
                }
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">                if (!features2.gradientWasCreated()) {</span>
<span class="fc" id="L156">                    features2.calculateGradientWithGreyscale(</span>
<span class="fc" id="L157">                        img2Helper.getGreyscaleImage());</span>
                }
            }
            
<span class="fc" id="L161">            boolean solved = generateAndMatchCornerRegions(type, ub);</span>
            
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (solved) {</span>
<span class="fc" id="L164">                return true;</span>
            }
        }
        
<span class="nc" id="L168">        return false;</span>
    }

    protected void prepareCorners(SegmentationType type, boolean useBinned) 
        throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L174">        log.info(type.name() + &quot; binned=&quot; + useBinned + &quot; useSameSegmentation=&quot; </span>
            + useSameSegmentation);
        
        IntensityFeatures f1, f2;
        
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (useBinned) {</span>
<span class="fc" id="L180">            img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
<span class="fc" id="L181">            img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
<span class="fc" id="L182">            f1 = featuresBinned1;</span>
<span class="fc" id="L183">            f2 = featuresBinned2;</span>
        } else {
<span class="fc" id="L185">            f1 = features1;</span>
<span class="fc" id="L186">            f2 = features2;</span>
        }
        
<span class="fc" id="L189">        img1Helper.applySegmentation(type, useBinned);</span>
<span class="fc" id="L190">        img2Helper.applySegmentation(type, useBinned);</span>
        
        List&lt;HoughTransformLines&gt; houghTransformLines1;
        List&lt;HoughTransformLines&gt; houghTransformLines2;
                
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (type.equals(SegmentationType.GREYSCALE_CANNY)) {</span>
            
<span class="nc" id="L197">            boolean filterOutImageBoundaryBlobs = true;</span>
<span class="nc" id="L198">            boolean filterOutZeroPixels = false;</span>
<span class="nc" id="L199">            boolean doNotAddPoints = true;</span>
            
            // pre-make the blobs using non-default variables:
<span class="nc" id="L202">            img1Helper.getBlobs(type, useBinned, filterOutImageBoundaryBlobs, </span>
                filterOutZeroPixels);
            
<span class="nc" id="L205">            img2Helper.getBlobs(type, useBinned, filterOutImageBoundaryBlobs, </span>
                filterOutZeroPixels); 
            
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (settings.doUse2ndDerivCorners()) {</span>
                //TODO: consider using extractSecondDerivativeCornersithoutBlobs instead
<span class="nc" id="L210">                img1Helper.extractSecondDerivativeCorners(type, useBinned);</span>
<span class="nc" id="L211">                img2Helper.extractSecondDerivativeCorners(type, useBinned);</span>
            } else {
<span class="nc" id="L213">                img1Helper.extractBlobPerimeterAsCornerRegions(type, useBinned, </span>
                    doNotAddPoints);
<span class="nc" id="L215">                img2Helper.extractBlobPerimeterAsCornerRegions(type, useBinned, </span>
                    doNotAddPoints);
            }
        }
        
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (settings.doUse2ndDerivCorners()) {</span>
<span class="fc" id="L221">            img1Helper.extractSecondDerivativeCornersWithoutBlobs(type, useBinned);</span>
<span class="fc" id="L222">            img2Helper.extractSecondDerivativeCornersWithoutBlobs(type, useBinned);</span>
        } else {
<span class="fc" id="L224">            img1Helper.extractBlobPerimeterAsCornerRegions(type, useBinned);</span>
<span class="fc" id="L225">            img2Helper.extractBlobPerimeterAsCornerRegions(type, useBinned);</span>
        
<span class="fc" id="L227">            houghTransformLines1 = findLinesUsingHoughTransform(img1Helper, </span>
                type, useBinned);
<span class="fc" id="L229">            houghTransformLines2 = findLinesUsingHoughTransform(img2Helper, </span>
                type, useBinned);
<span class="fc" id="L231">            removeLineArtifactCorners(houghTransformLines1, img1Helper, type, </span>
                useBinned);
<span class="fc" id="L233">            removeLineArtifactCorners(houghTransformLines2, img2Helper, type, </span>
                useBinned);
        }
<span class="fc" id="L236">    }</span>

    protected boolean generateAndMatchCornerRegions(SegmentationType type, 
        boolean useBinned) throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L241">        log.info(type.name() + &quot; binned=&quot; + useBinned + &quot; useSameSegmentation=&quot; </span>
            + useSameSegmentation);
        
<span class="fc" id="L244">        prepareCorners(type, useBinned);</span>
                        
<span class="fc" id="L246">        return match(type, useBinned);</span>
    }
    
    protected abstract boolean match(SegmentationType type, boolean useBinned);

    protected List&lt;HoughTransform.HoughTransformLines&gt; 
        findLinesUsingHoughTransform(BlobPerimeterCornerHelper blobCornerHelper, 
        SegmentationType segmentationType, boolean useBinnedImage) {
        
<span class="fc" id="L255">        List&lt;PairIntArray&gt; perimeterLists = blobCornerHelper.getBlobPerimeters(</span>
            segmentationType, useBinnedImage);
        
<span class="fc bfc" id="L258" title="All 2 branches covered.">        int imageWidth = useBinnedImage ? </span>
<span class="fc" id="L259">            blobCornerHelper.getGreyscaleImageBinned().getWidth() : </span>
<span class="fc" id="L260">            blobCornerHelper.getGreyscaleImage().getWidth();</span>
        
<span class="fc bfc" id="L262" title="All 2 branches covered.">        int imageHeight = useBinnedImage ? </span>
<span class="fc" id="L263">            blobCornerHelper.getGreyscaleImageBinned().getHeight() : </span>
<span class="fc" id="L264">            blobCornerHelper.getGreyscaleImage().getHeight();</span>
        
<span class="fc" id="L266">        int thetaTol = 1;</span>
<span class="fc" id="L267">        int radiusTol = 7;</span>
        
<span class="fc" id="L269">        HoughTransform ht = new HoughTransform();</span>
        
<span class="fc" id="L271">        List&lt;HoughTransform.HoughTransformLines&gt; lineList = </span>
            new ArrayList&lt;HoughTransform.HoughTransformLines&gt;();
        
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (int ii = 0; ii &lt; perimeterLists.size(); ++ii) {</span>
            
            // NOTE: in testable method for this, should allow ability to
            // pass in junctions and not delete corners that are in
            // junctions.
            // For these blob perimeters, there are not junctions.
<span class="fc" id="L280">            PairIntArray edge = perimeterLists.get(ii);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (edge.getN() == 0) {</span>
<span class="nc" id="L282">                HoughTransformLines htl = ht.new HoughTransformLines(</span>
                    new HashMap&lt;PairInt, PairInt&gt;(), new ArrayList&lt;Set&lt;PairInt&gt;&gt;());
<span class="nc" id="L284">                lineList.add(htl);</span>
<span class="nc" id="L285">                continue;</span>
            }
            
<span class="fc" id="L288">            Map&lt;PairInt, Set&lt;PairInt&gt;&gt; outputPolarCoordsPixMap = </span>
<span class="fc" id="L289">                ht.calculateLineGivenEdge(edge, imageWidth, imageHeight);</span>
            
<span class="fc" id="L291">            List&lt;PairInt&gt; outSortedKeys = ht.sortByVotes(outputPolarCoordsPixMap);</span>
            
            // === find indiv lines within the edge ====
<span class="fc" id="L294">            HoughTransform.HoughTransformLines htl = </span>
<span class="fc" id="L295">                ht.createPixTRMapsFromSorted(outSortedKeys, </span>
                outputPolarCoordsPixMap, thetaTol, radiusTol);
            
<span class="fc" id="L298">            lineList.add(htl);</span>
        }
<span class="fc" id="L300">        return lineList;</span>
    }

    protected void removeLineArtifactCorners(List&lt;HoughTransformLines&gt; 
        houghTransformLines, BlobPerimeterCornerHelper blobCornerHelper, 
        SegmentationType segmentationType, boolean useBinnedImage) {
        
<span class="fc" id="L307">        List&lt;PairIntArray&gt; perimeterLists = blobCornerHelper.getBlobPerimeters(</span>
            segmentationType, useBinnedImage);
        
<span class="fc" id="L310">        List&lt;List&lt;CornerRegion&gt;&gt; cornerRegionLists = </span>
<span class="fc" id="L311">            blobCornerHelper.getPerimeterCorners(segmentationType, useBinnedImage);</span>
        
<span class="fc bfc" id="L313" title="All 2 branches covered.">        int imageWidth = useBinnedImage ? </span>
<span class="fc" id="L314">            blobCornerHelper.getGreyscaleImageBinned().getWidth() : </span>
<span class="fc" id="L315">            blobCornerHelper.getGreyscaleImage().getWidth();</span>
        
<span class="fc bfc" id="L317" title="All 2 branches covered.">        int imageHeight = useBinnedImage ? </span>
<span class="fc" id="L318">            blobCornerHelper.getGreyscaleImageBinned().getHeight() : </span>
<span class="fc" id="L319">            blobCornerHelper.getGreyscaleImage().getHeight();</span>
        
<span class="fc" id="L321">        int thetaTol = 1;</span>
<span class="fc" id="L322">        int radiusTol = 7;</span>
        
        //use hough transform for lines to remove corners from line artifacts
<span class="fc" id="L325">        CornerCorrector.removeCornersFromLineArtifacts(houghTransformLines, </span>
            perimeterLists, cornerRegionLists, thetaTol, radiusTol, imageWidth, 
            imageHeight);
<span class="fc" id="L328">    }</span>

    protected List&lt;FeatureComparisonStat&gt; reviseStatsForFullImages(
        GreyscaleImage gsImg1, GreyscaleImage gsImg2, 
        List&lt;FeatureComparisonStat&gt; stats, int prevBinFactor1, 
        int prevBinFactor2, RotatedOffsets rotatedOffsets) {
        
<span class="fc" id="L335">        log.info(&quot;refine stats for full image reference frames&quot;);</span>
        
<span class="fc" id="L337">        List&lt;FeatureComparisonStat&gt; revised = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="fc" id="L339">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
        
<span class="fc" id="L341">        IntensityFeatures f1 = new IntensityFeatures(5, </span>
<span class="fc" id="L342">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L343">        f1.calculateGradientWithGreyscale(gsImg1);</span>
        
<span class="fc" id="L345">        IntensityFeatures f2 = new IntensityFeatures(5, </span>
<span class="fc" id="L346">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L347">        f2.calculateGradientWithGreyscale(gsImg2);</span>
        
<span class="fc" id="L349">        int dither = 2;</span>
        
<span class="fc bfc" id="L351" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
            
<span class="fc" id="L353">            FeatureComparisonStat stat = stats.get(i);</span>
            
<span class="fc" id="L355">            int x1 = stat.getImg1Point().getX() * prevBinFactor1;</span>
<span class="fc" id="L356">            int y1 = stat.getImg1Point().getY() * prevBinFactor1;</span>
<span class="fc" id="L357">            int x2 = stat.getImg2Point().getX() * prevBinFactor2;</span>
<span class="fc" id="L358">            int y2 = stat.getImg2Point().getY() * prevBinFactor2;</span>
            
            // have to discard the best angles found in stat and derive new
            // for these higher resolution images
<span class="fc" id="L362">            FeatureComparisonStat compStat = </span>
<span class="fc" id="L363">                featureMatcher.ditherAndRotateForBestLocation2(f1, </span>
                    f2, x1, y1, x2, y2, dither, gsImg1, gsImg2);
            
<span class="fc bfc" id="L366" title="All 2 branches covered.">            if (compStat == null || (compStat.getSumIntensitySqDiff() &gt; </span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                compStat.getImg2PointIntensityErr())) {</span>
<span class="nc" id="L368">                continue;</span>
            }
            
<span class="fc" id="L371">            revised.add(compStat);</span>
        }
        
<span class="fc" id="L374">        return revised;</span>
    }

    public void copyToInstanceVars(List&lt;FeatureComparisonStat&gt; stats) {
        
<span class="fc" id="L379">        this.solutionStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L380">        this.solutionMatched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L381">        this.solutionMatched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L383" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="fc" id="L384">            solutionStats.add(stat.copy());</span>
<span class="fc" id="L385">            solutionMatched1.add(stat.getImg1Point().copy());</span>
<span class="fc" id="L386">            solutionMatched2.add(stat.getImg2Point().copy());</span>
<span class="fc" id="L387">        }</span>
<span class="fc" id="L388">    }</span>
    
    protected void extractCannyCornerRegions(GreyscaleImage img1,
        GreyscaleImage img2, Set&lt;CornerRegion&gt; outputCornerRegions1,
        Set&lt;CornerRegion&gt; outputCornerRegions2) {

<span class="fc" id="L394">        GreyscaleImage gsImg1 = img1.copyImage();</span>
<span class="fc" id="L395">        GreyscaleImage gsImg2 = img2.copyImage();</span>

<span class="fc" id="L397">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L398">        imageProcessor.blur(gsImg1, SIGMA.ONE);</span>

<span class="fc" id="L400">        CurvatureScaleSpaceCornerDetector detector = new CurvatureScaleSpaceCornerDetector(gsImg1);</span>
<span class="fc" id="L401">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L402">        detector.findCorners();</span>

<span class="fc" id="L404">        Set&lt;CornerRegion&gt; cornerRegions1 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions1 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);

<span class="fc" id="L407">        outputCornerRegions1.addAll(cornerRegions1);</span>

<span class="fc" id="L409">        imageProcessor.blur(gsImg2, SIGMA.ONE);</span>

<span class="fc" id="L411">        detector = new CurvatureScaleSpaceCornerDetector(gsImg2);</span>
<span class="fc" id="L412">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L413">        detector.findCorners();</span>
<span class="fc" id="L414">        Set&lt;CornerRegion&gt; cornerRegions2 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions2 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);

<span class="fc" id="L417">        outputCornerRegions2.addAll(cornerRegions2);</span>
<span class="fc" id="L418">    }</span>
    
    protected List&lt;FeatureComparisonStat&gt; findCorrespondence(GreyscaleImage img1,
        GreyscaleImage img2, Set&lt;CornerRegion&gt; cornerRegions1,
        Set&lt;CornerRegion&gt; cornerRegions2, TransformationParameters parameters,
        RotatedOffsets rotatedOffsets, int dither2, int transXYTol,
        float scaleTol, float rotationInRadiansTol) {

<span class="fc" id="L426">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

<span class="fc" id="L428">        List&lt;FeatureComparisonStat&gt; stats = </span>
<span class="fc" id="L429">            featureMatcher.findSimilarFeaturesAsStats(img1,</span>
<span class="fc" id="L430">            cornerRegions1.toArray(new CornerRegion[cornerRegions1.size()]),</span>
<span class="fc" id="L431">            img2, cornerRegions2.toArray(new CornerRegion[cornerRegions2.size()]),</span>
            parameters, scaleTol, rotationInRadiansTol, transXYTol,
            dither2, rotatedOffsets);
        
<span class="fc" id="L435">        return stats;</span>
    }

    protected MatchingSolution transformSolutionToFullFrames(MatchingSolution 
        soln, BlobPerimeterCornerHelper img1Helper, 
        BlobPerimeterCornerHelper img2Helper, int binFactor1, int binFactor2) {
        
<span class="pc bpc" id="L442" title="1 of 4 branches missed.">        if (binFactor1 == 1 &amp;&amp; binFactor2 == 1) {</span>
<span class="fc" id="L443">            return soln;</span>
        }
       
<span class="fc" id="L446">        RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
        
<span class="pc bpc" id="L448" title="3 of 4 branches missed.">        assert(rotatedOffsets.containsData());</span>
        
<span class="fc" id="L450">        List&lt;FeatureComparisonStat&gt; stats = soln.getComparisonStats();</span>
        
<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
<span class="fc" id="L453">            FeatureComparisonStat stat = stats.get(i);</span>
<span class="fc" id="L454">            stat.setBinFactor1(binFactor1);</span>
<span class="fc" id="L455">            stat.setBinFactor2(binFactor2);</span>
        }
        
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            GreyscaleImage im1 = (binFactor1 != 1) ? </span>
<span class="pc" id="L460">                img1Helper.getGreyscaleImageBinned() :</span>
<span class="pc" id="L461">                img1Helper.getGreyscaleImage();</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            GreyscaleImage im2 = (binFactor2 != 1) ? </span>
<span class="pc" id="L463">                img2Helper.getGreyscaleImageBinned() :</span>
<span class="pc" id="L464">                img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L465">            MiscDebug.writeImages(im1, im2, stats, </span>
<span class="fc" id="L466">                &quot;_matched_binned_&quot; + settings.getDebugTag() </span>
<span class="fc" id="L467">                + MiscDebug.getCurrentTimeFormatted(), 1);</span>
        }
        
<span class="fc" id="L470">        FeatureMatcher matcher = new FeatureMatcher();</span>
        
<span class="fc" id="L472">        List&lt;FeatureComparisonStat&gt; fullStats = matcher.reviseStatsForFullImages(</span>
<span class="fc" id="L473">            img1Helper.getGreyscaleImage(),</span>
<span class="fc" id="L474">            img2Helper.getGreyscaleImage(),</span>
            settings,
<span class="fc" id="L476">            soln.getParams(), soln.getComparisonStats(),</span>
            binFactor1, binFactor2, rotatedOffsets);
            
<span class="pc bpc" id="L479" title="2 of 4 branches missed.">        if ((fullStats == null) || fullStats.isEmpty()) {</span>
<span class="nc" id="L480">            return null;</span>
        }
        
<span class="fc" id="L483">        TransformationParameters revisedParams = </span>
<span class="fc" id="L484">            MiscStats.calculateTransformation(1, 1, fullStats,</span>
                new float[4], false);
        
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (revisedParams == null) {</span>
<span class="fc" id="L488">            return null;</span>
        }
        
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="fc" id="L492">            GreyscaleImage im1 = img1Helper.getGreyscaleImage();</span>
<span class="fc" id="L493">            GreyscaleImage im2 = img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L494">            MiscDebug.writeImages(im1, im2, fullStats, </span>
<span class="fc" id="L495">                &quot;_matched_&quot; + settings.getDebugTag() +</span>
<span class="fc" id="L496">                MiscDebug.getCurrentTimeFormatted(), 2);</span>
        }
        
<span class="fc" id="L499">        MatchingSolution fullSoln = new MatchingSolution(revisedParams, </span>
            fullStats, 1, 1);
        
<span class="fc" id="L502">        return fullSoln;</span>
    }

    protected void filterForLocalization(GreyscaleImage img, 
        IntensityFeatures f, List&lt;CornerRegion&gt; corners) {
                
<span class="fc" id="L508">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L510" title="All 2 branches covered.">        for (int i = 0; i &lt; corners.size(); ++i) {</span>
<span class="fc" id="L511">            CornerRegion cr = corners.get(i);</span>
            
            try {
<span class="fc" id="L514">                int x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L515">                int y = cr.getY()[cr.getKMaxIdx()];</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                if (f.removeDueToLocalization(img, x, y,</span>
<span class="fc" id="L517">                    f.calculateOrientation(x, y))) {</span>
<span class="fc" id="L518">                    remove.add(Integer.valueOf(i));</span>
                }
<span class="nc" id="L520">            } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L521">            }</span>
        }
        
<span class="fc bfc" id="L524" title="All 2 branches covered.">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L525">            int idx = remove.get(i);</span>
<span class="fc" id="L526">            corners.remove(idx);</span>
        }
<span class="fc" id="L528">    }</span>
    
    protected void filterForLocalization2(GreyscaleImage img, 
        IntensityFeatures f, List&lt;List&lt;CornerRegion&gt;&gt; corners) {
                        
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (int i = 0; i &lt; corners.size(); ++i) {</span>
<span class="fc" id="L534">            List&lt;CornerRegion&gt; cr = corners.get(i);</span>
<span class="fc" id="L535">            filterForLocalization(img, f, cr);</span>
        }
<span class="fc" id="L537">    }</span>
    
    /**
     * get a copy of the solution's feature stats.
     * @return 
     */
    public List&lt;FeatureComparisonStat&gt; getSolutionStats() {
<span class="fc" id="L544">        return solutionStats;</span>
    }

    /**
     * get the matched points from image 1
     * @return the solutionMatched1
     */
    public List&lt;PairInt&gt; getSolutionMatched1() {
<span class="fc" id="L552">        return solutionMatched1;</span>
    }

    /**
     * get the matched points from image 2
     * @return the solutionMatched2
     */
    public List&lt;PairInt&gt; getSolutionMatched2() {
<span class="fc" id="L560">        return solutionMatched2;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
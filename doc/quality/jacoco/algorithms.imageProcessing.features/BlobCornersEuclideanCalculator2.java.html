<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BlobCornersEuclideanCalculator2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features</a> &gt; <span class="el_source">BlobCornersEuclideanCalculator2.java</span></div><h1>BlobCornersEuclideanCalculator2.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features;

import algorithms.imageProcessing.*;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.CountingSort;
import algorithms.SubsetChooser;
import algorithms.compGeometry.NearestPoints;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 * given a map of lists of blob matched points, calculate euclidean
 * transformations and evaluate them against all points.
 *
 * @author nichole
 */
<span class="fc" id="L25">public class BlobCornersEuclideanCalculator2 {</span>

<span class="fc" id="L27">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    /**
     * returns a solution for given images and their binFactors.  Note that
     * corrections to make the solution full frame transformation have not
     * occurred, the solution is in the given binned reference frames.
     * 
     * @param image1
     * @param image2
     * @param features1
     * @param features2
     * @param dither
     * @param matchedLists a map with keys=pairint of index1, index2 of matched
     * blob lists and values=lists of features for that index1 index2 match.
     * @param allCorners1
     * @param allCorners2
     * @param binFactor1
     * @param binFactor2
     * @return 
     */
    public MatchingSolution solveTransformation(
        GreyscaleImage image1, GreyscaleImage image2,
        IntensityFeatures features1, IntensityFeatures features2, int dither,
        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; matchedLists, 
        List&lt;CornerRegion&gt; allCorners1, List&lt;CornerRegion&gt; allCorners2,
        int binFactor1, int binFactor2) {
        
        // calculate all transformations, returns transformations from all
        // combinations of 2 if enough points per blob, else combinations of 3
<span class="fc" id="L56">        List&lt;TransformationParameters&gt; params = calculateTransformations(</span>
            matchedLists);
        
<span class="fc" id="L59">        params = MiscStats.filterToSimilarParamSets2(params, binFactor1, </span>
            binFactor2);
        
<span class="fc" id="L62">        boolean evalWithAllCorners = true;</span>
        
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (evalWithAllCorners) {</span>
            
<span class="fc" id="L66">            return evaluateWithAllCorners(image1, image2, features1, features2, </span>
                dither, params, allCorners1, allCorners2, 
                binFactor1, binFactor2);
            
        } else {
            
<span class="nc" id="L72">            return evaluateWithMatchedLists(image1, image2, features1, </span>
                features2, dither, params, matchedLists, binFactor1, binFactor2);
        }
    }
    
    protected MatchingSolution evaluateWithMatchedLists(
        GreyscaleImage image1, GreyscaleImage image2,
        IntensityFeatures features1, IntensityFeatures features2, int dither,
        List&lt;TransformationParameters&gt; paramsList, 
        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; matchedLists,
        int binFactor1, int binFactor2) {
     
<span class="nc" id="L84">        throw new UnsupportedOperationException(&quot;not yet implemented&quot;);</span>
    }

    private List&lt;TransformationParameters&gt; calculateTransformations(
        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; matchedLists) {
        
        /*
        ways to calculate:
        
        (1) if there are usually at least two points per matchedLists values,
            then can use the points within to calculate transformations.
            use combinations of each 2 keys in matchedLists to create
            transformations.
        (2) if there is only one point per values of matchedLists, then can
            use combinations of 3 keys in matchedLists to create transformations.        
        */
        
<span class="fc" id="L101">        List&lt;List&lt;FeatureComparisonStat&gt;&gt; listsOfMatchedBlobStats = </span>
            new ArrayList&lt;List&lt;FeatureComparisonStat&gt;&gt;();
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : matchedLists.entrySet()) {</span>
<span class="fc" id="L104">            listsOfMatchedBlobStats.add(entry.getValue());</span>
<span class="fc" id="L105">        }</span>

<span class="fc" id="L107">        List&lt;PairInt&gt; descendingNFreq = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L108">        List&lt;PairInt&gt; descendingNMembers = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L109">        countFrequencyThenSortDesc(listsOfMatchedBlobStats, descendingNFreq,</span>
            descendingNMembers);
        
<span class="fc" id="L112">        List&lt;TransformationParameters&gt; parametersList = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
        // if there are 2 or more blobs with 3 or more members, make a sublist
        // and calculate transformations for those.  
        // testing whether can use only those instead of all combinations below it
<span class="fc" id="L118">        List&lt;List&lt;FeatureComparisonStat&gt;&gt; matchedBlobStatsSublist = </span>
            new ArrayList&lt;List&lt;FeatureComparisonStat&gt;&gt;();
<span class="fc bfc" id="L120" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : matchedLists.entrySet()) {</span>
<span class="fc" id="L121">            List&lt;FeatureComparisonStat&gt; list = entry.getValue();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (list.size() &gt; 2) {</span>
<span class="fc" id="L123">                matchedBlobStatsSublist.add(list);</span>
            }
<span class="fc" id="L125">        }</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (matchedBlobStatsSublist.size() == 1) {</span>
<span class="fc" id="L127">            TransformationParameters params = MiscStats.calculateTransformation(</span>
<span class="fc" id="L128">                1, 1, matchedBlobStatsSublist.get(0), new float[4], true);</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            if (params != null) {</span>
<span class="fc" id="L130">                parametersList.add(params);</span>
<span class="fc" id="L131">                log.info(&quot;single high matching params=&quot; + params.toString());</span>
            }
<span class="fc bfc" id="L133" title="All 2 branches covered.">        } else if (matchedBlobStatsSublist.size() &gt; 1) {</span>
<span class="fc" id="L134">            calculateWithCombinations(matchedBlobStatsSublist, 2, parametersList);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            for (TransformationParameters params : parametersList) {</span>
<span class="fc" id="L136">                log.info(&quot;blob high n matches params=&quot; + params.toString());</span>
<span class="fc" id="L137">            }</span>
        }
        
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (parametersList.size() &lt; 10) {</span>
<span class="fc" id="L141">            int k = 3;</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if ((descendingNFreq.get(0).getX() &gt; 1) &amp;&amp; </span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                (descendingNFreq.get(0).getY() &gt; (matchedLists.size()/2))) {</span>
<span class="nc" id="L144">                k = 2;</span>
            }

<span class="fc" id="L147">            calculateWithCombinations(listsOfMatchedBlobStats, k, parametersList);</span>
        }
        
<span class="fc" id="L150">        return parametersList;</span>
    }

    /**
     * count the number of keys have size of values and return in descending
     * order, pairints holding the sizes of the values in matchedList and the
     * numbers of keys for those sizes.
     * runtime complexity is at most O(N) where N is matchedLists.size().
     * @param listsOfMatchedBlobStats
     * @param outputDescendingNFreq - list of pairints with 
     *     x=size of lists of stats, y=number of blobs with that size,
     *     sorted by decreasing value of y
     * @param outputDescendingNMembers - list of pairints with 
     *     x=size of lists of stats, y=number of blobs with that size,
     *     sorted by decreasing value of x
     */
    protected void countFrequencyThenSortDesc(
        List&lt;List&lt;FeatureComparisonStat&gt;&gt; listsOfMatchedBlobStats,
        List&lt;PairInt&gt; outputDescendingNFreq, List&lt;PairInt&gt; outputDescendingNMembers) {
        
<span class="fc" id="L170">        Map&lt;Integer, Integer&gt; valueCounts = new HashMap&lt;Integer, Integer&gt;();</span>
        
<span class="fc bfc" id="L172" title="All 2 branches covered.">        for (List&lt;FeatureComparisonStat&gt; list : listsOfMatchedBlobStats) {</span>
            
<span class="fc" id="L174">            int n = list.size();</span>
            
<span class="fc" id="L176">            Integer key = Integer.valueOf(n);</span>
            
<span class="fc" id="L178">            Integer c = valueCounts.get(key);</span>
            
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (c == null) {</span>
<span class="fc" id="L181">                valueCounts.put(key, Integer.valueOf(1));</span>
            } else {
<span class="fc" id="L183">                valueCounts.put(key, Integer.valueOf(c.intValue() + 1));</span>
            }
<span class="fc" id="L185">        }</span>
        
<span class="fc" id="L187">        int[] v = new int[valueCounts.size()];</span>
<span class="fc" id="L188">        int[] c = new int[v.length];</span>
<span class="fc" id="L189">        int count = 0;</span>
<span class="fc" id="L190">        int maxC = Integer.MIN_VALUE;</span>
<span class="fc" id="L191">        int maxV = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        for (Entry&lt;Integer, Integer&gt; entry : valueCounts.entrySet()) {</span>
<span class="fc" id="L193">            v[count] = entry.getKey().intValue();</span>
<span class="fc" id="L194">            c[count] = entry.getValue().intValue();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (c[count] &gt; maxC) {</span>
<span class="fc" id="L196">                maxC = c[count];</span>
            }
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if (v[count] &gt; maxV) {</span>
<span class="fc" id="L199">                maxV = v[count];</span>
            }
<span class="fc" id="L201">            count++;</span>
<span class="fc" id="L202">        }</span>
        
<span class="fc" id="L204">        CountingSort.sortByDecr(c, v, maxC);</span>
        
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="fc" id="L207">            outputDescendingNFreq.add(new PairInt(v[i], c[i]));</span>
        }
        
<span class="fc" id="L210">        CountingSort.sortByDecr(v, c, maxV);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (int i = 0; i &lt; v.length; ++i) {</span>
<span class="fc" id="L212">            outputDescendingNMembers.add(new PairInt(v[i], c[i]));</span>
        }
<span class="fc" id="L214">    }</span>

    private List&lt;TransformationParameters&gt; calculateWithCombinations(
        List&lt;List&lt;FeatureComparisonStat&gt;&gt; listsOfMatchedBlobStats, 
        int k, List&lt;TransformationParameters&gt; output) {
                
<span class="fc" id="L220">        boolean removeIntensityOutliers = false;</span>
<span class="fc" id="L221">        float[] outputScaleRotTransXYStDev = new float[4];</span>
        
<span class="fc" id="L223">        int nPoints = listsOfMatchedBlobStats.size();</span>
        
<span class="fc" id="L225">        int[] selectedIndexes = new int[k];</span>
        
<span class="fc" id="L227">        SubsetChooser subsetChooser = new SubsetChooser(nPoints, k);</span>
            
<span class="fc" id="L229">        int nV = subsetChooser.getNextSubset(selectedIndexes);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">        while (nV != -1) {</span>
            
<span class="fc" id="L233">            List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">            for (int bitIndex : selectedIndexes) {</span>

<span class="fc" id="L237">                int idx = bitIndex;</span>

<span class="fc" id="L239">                List&lt;FeatureComparisonStat&gt; list = listsOfMatchedBlobStats.get(idx);</span>

<span class="fc" id="L241">                stats.addAll(list);                </span>
            }
            
<span class="fc" id="L244">            TransformationParameters params = MiscStats.calculateTransformation(</span>
                1, 1, stats, outputScaleRotTransXYStDev, 
                removeIntensityOutliers);
            
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (params != null) {</span>
<span class="fc" id="L249">                output.add(params);</span>
            }

<span class="fc" id="L252">            nV = subsetChooser.getNextSubset(selectedIndexes);</span>
<span class="fc" id="L253">        }</span>
        
<span class="fc" id="L255">        return output;</span>
    }
      
    protected MatchingSolution evaluateWithAllCorners(
        GreyscaleImage image1, GreyscaleImage image2,
        IntensityFeatures features1, IntensityFeatures features2, int dither,
        List&lt;TransformationParameters&gt; parameterList, 
        List&lt;CornerRegion&gt; allCorners1, List&lt;CornerRegion&gt; allCorners2,
        int binFactor1, int binFactor2) {
        
<span class="fc" id="L265">        int n2c = allCorners2.size();</span>
<span class="fc" id="L266">        int[] xC2 = new int[n2c];</span>
<span class="fc" id="L267">        int[] yC2 = new int[n2c];</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (int i = 0; i &lt; n2c; ++i) {</span>
<span class="fc" id="L269">            CornerRegion cr2 = allCorners2.get(i);</span>
<span class="fc" id="L270">            xC2[i] = cr2.getX()[cr2.getKMaxIdx()];</span>
<span class="fc" id="L271">            yC2[i] = cr2.getY()[cr2.getKMaxIdx()];</span>
        }
               
<span class="fc" id="L274">        NearestPoints np2 = new NearestPoints(xC2, yC2);</span>
        
<span class="fc" id="L276">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
<span class="fc" id="L277">        Transformer transformer = new Transformer();</span>

<span class="fc" id="L279">        final int rotationTolerance = 20;</span>
<span class="fc" id="L280">        int tolTransXY = 5;</span>

<span class="fc" id="L282">        TransformationParameters bestParams = null;</span>
<span class="fc" id="L283">        float bestCost = Float.MAX_VALUE;</span>
<span class="fc" id="L284">        float bestCost1Norm = Float.MAX_VALUE;</span>
<span class="fc" id="L285">        List&lt;FeatureComparisonStat&gt; bestStats = null;</span>
<span class="fc" id="L286">        int bestTolTransXY2 = -1;</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (TransformationParameters params : parameterList) {</span>

<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            if (!paramsAreValid(params)) {</span>
<span class="nc" id="L291">                continue;</span>
            }
            
<span class="fc" id="L294">            double rotInRadians = params.getRotationInRadians();</span>
<span class="fc" id="L295">            double cos = Math.cos(rotInRadians);</span>
<span class="fc" id="L296">            double sin = Math.sin(rotInRadians);</span>

<span class="fc" id="L298">            int rotD = Math.round(params.getRotationInDegrees());</span>

<span class="fc" id="L300">            int tolTransXY2 = tolTransXY;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">            if (params.getScale() &lt; 1) {</span>
<span class="fc" id="L302">                tolTransXY2 = Math.round(tolTransXY * params.getScale());</span>
            }
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (tolTransXY2 == 0) {</span>
<span class="fc" id="L305">                tolTransXY2 = 1;</span>
            }
<span class="fc" id="L307">            int dither2 = Math.round(dither * params.getScale());</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">            if (dither2 == 0) {</span>
<span class="fc" id="L309">                dither2 = 1;</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">            } else if (dither2 &gt; dither) {</span>
                // large dither makes runtime larger
<span class="fc" id="L312">                dither2 = dither;</span>
            }

<span class="fc" id="L315">            int nEval = 0;</span>
<span class="fc" id="L316">            double sumSSD = 0;</span>
<span class="fc" id="L317">            double sumDist = 0;</span>
<span class="fc" id="L318">            List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L319">            List&lt;Double&gt; distances = new ArrayList&lt;Double&gt;();</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">            for (CornerRegion cr : allCorners1) {</span>

<span class="fc" id="L323">                CornerRegion crTr = transformer.applyTransformation(params, cr, cos, sin);</span>

<span class="fc" id="L325">                Set&lt;Integer&gt; indexes2 = np2.findNeighborIndexes(</span>
<span class="fc" id="L326">                    crTr.getX()[crTr.getKMaxIdx()],</span>
<span class="fc" id="L327">                    crTr.getY()[crTr.getKMaxIdx()], tolTransXY2);</span>

<span class="fc" id="L329">                double bestCostPerIndex = Double.MAX_VALUE;</span>
<span class="fc" id="L330">                Integer bestCostPerIndexIndex = null;</span>
<span class="fc" id="L331">                FeatureComparisonStat bestCostPerIndexStat = null;</span>
<span class="fc" id="L332">                double bestCostPerIndexDist = Double.MAX_VALUE;</span>
                    
<span class="fc bfc" id="L334" title="All 2 branches covered.">                for (Integer index : indexes2) {</span>

<span class="fc" id="L336">                    int idx2 = index.intValue();</span>

<span class="fc" id="L338">                    CornerRegion corner2 = allCorners2.get(idx2);</span>

<span class="fc" id="L340">                    FeatureComparisonStat compStat =</span>
<span class="fc" id="L341">                        featureMatcher.ditherAndRotateForBestLocation2(</span>
                        features1, features2, cr, corner2, dither2,
                        rotD, rotationTolerance, image1, image2);

<span class="fc bfc" id="L345" title="All 2 branches covered.">                    if ((compStat == null) ||</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                        (compStat.getSumIntensitySqDiff() &gt; compStat.getImg2PointIntensityErr())</span>
                        ) {
<span class="nc" id="L348">                        continue;</span>
                    }

<span class="fc" id="L351">                    double xTr = (compStat.getImg1Point().getX() *</span>
<span class="fc" id="L352">                        params.getScale() * cos) +</span>
<span class="fc" id="L353">                        (compStat.getImg1Point().getY() *</span>
<span class="fc" id="L354">                        params.getScale() * sin);</span>
<span class="fc" id="L355">                    xTr += params.getTranslationX();</span>

<span class="fc" id="L357">                    double yTr = (-compStat.getImg1Point().getX() *</span>
<span class="fc" id="L358">                        params.getScale() * sin) +</span>
<span class="fc" id="L359">                        (compStat.getImg1Point().getY() *</span>
<span class="fc" id="L360">                        params.getScale()* cos);</span>
<span class="fc" id="L361">                    yTr += params.getTranslationY();</span>

<span class="fc" id="L363">                    double dist = distance(xTr, yTr,</span>
<span class="fc" id="L364">                        compStat.getImg2Point().getX(),</span>
<span class="fc" id="L365">                        compStat.getImg2Point().getY());</span>

<span class="fc" id="L367">                    double cost = </span>
                        (((float)dist + 0.01f)/(float)tolTransXY2) *
<span class="fc" id="L369">                        (compStat.getSumIntensitySqDiff() + 1);</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">                    if (cost &lt; bestCostPerIndex) {</span>
<span class="fc" id="L372">                        bestCostPerIndex = cost;</span>
<span class="fc" id="L373">                        bestCostPerIndexIndex = index;</span>
<span class="fc" id="L374">                        bestCostPerIndexStat = compStat;</span>
<span class="fc" id="L375">                        bestCostPerIndexDist = dist;</span>
                    }
<span class="fc" id="L377">                }</span>

<span class="fc bfc" id="L379" title="All 2 branches covered.">                if (bestCostPerIndexIndex != null) {</span>
                    // cost is 
<span class="fc" id="L381">                    stats.add(bestCostPerIndexStat);</span>
<span class="fc" id="L382">                    distances.add(Double.valueOf(bestCostPerIndexDist));</span>
<span class="fc" id="L383">                    sumDist += bestCostPerIndexDist;</span>
<span class="fc" id="L384">                    sumSSD += bestCostPerIndexStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L385">                    nEval++;</span>
                }
<span class="fc" id="L387">            }</span>
            
<span class="fc" id="L389">            List&lt;Integer&gt; removedIndexes = MiscStats.filterForDegeneracy(stats);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">            for (int i = (removedIndexes.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L391">                int rmIdx = removedIndexes.get(i);</span>
<span class="fc" id="L392">                distances.remove(rmIdx);</span>
            }
            
<span class="fc" id="L395">            removedIndexes = FeatureMatcher.removeIntensityOutliers(stats, 1.25f); </span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (removedIndexes.size() &lt; distances.size()) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                for (int i = (removedIndexes.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L398">                    int rmIdx = removedIndexes.get(i);</span>
<span class="fc" id="L399">                    distances.remove(rmIdx);</span>
                }
<span class="fc" id="L401">                sumSSD = 0;</span>
<span class="fc" id="L402">                sumDist = 0;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">                for (int i = 0; i &lt; stats.size(); ++i) {</span>
<span class="fc" id="L404">                    sumSSD += stats.get(i).getSumIntensitySqDiff();</span>
<span class="fc" id="L405">                    sumDist += distances.get(i).doubleValue();</span>
                }
<span class="fc" id="L407">                nEval = stats.size();</span>
            }
            
<span class="fc bfc" id="L410" title="All 2 branches covered.">            if (nEval == 0) {</span>
<span class="fc" id="L411">                continue;</span>
            }

            // distance needs to be adjusted by scale, else the cost prefers
            // small scale solutions
<span class="fc" id="L416">            sumDist /= params.getScale();</span>

<span class="fc" id="L418">            sumSSD /= (double)nEval;</span>
<span class="fc" id="L419">            sumDist /= (double)nEval;</span>

            // add eps to sums so a zero doesn't cancel out the result of the other cost components
<span class="fc" id="L422">            float cost1Norm = 1.f/(float)nEval;</span>
<span class="fc" id="L423">            float cost2Norm = (float)sumSSD + 1;</span>
<span class="fc" id="L424">            float cost3Norm = ((float)sumDist + 0.01f)/(float)tolTransXY2;</span>
<span class="fc" id="L425">            float normalizedCost = cost1Norm * cost2Norm * cost3Norm;</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">            boolean t1 = (normalizedCost &lt; bestCost);</span>
/*      
float diffRot = AngleUtil.getAngleDifference(params.getRotationInDegrees(), 350);
StringBuilder sb = new StringBuilder();
if ((Math.abs(diffRot) &lt; 20) &amp;&amp; (Math.abs(params.getScale() - 1) &lt; 0.15) &amp;&amp; 
(Math.abs(params.getTranslationX() - -125) &lt; 30) &amp;&amp; 
(Math.abs(params.getTranslationY() - -45) &lt; 30)) {
    sb.append(&quot;*** &quot;);
}
sb.append(String.format(&quot; nEval=%d  normCost=%.1f  %s&quot;, nEval, normalizedCost, params.toString()));
log.info(sb.toString());
*/
<span class="fc bfc" id="L439" title="All 4 branches covered.">            if (t1 &amp;&amp; (nEval &gt; 2)) {</span>
<span class="fc" id="L440">                bestCost = normalizedCost;</span>
<span class="fc" id="L441">                bestParams = params;</span>
<span class="fc" id="L442">                bestStats = stats;</span>
<span class="fc" id="L443">                bestCost1Norm = cost1Norm;</span>
<span class="fc" id="L444">                params.setNumberOfPointsUsed(stats.size());</span>
<span class="fc" id="L445">                bestTolTransXY2 = tolTransXY2;</span>
            }
<span class="fc" id="L447">        }</span>
            
        // calculate the quality array
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (bestParams != null) {</span>
<span class="fc" id="L451">            int n = bestStats.size();</span>
            
<span class="fc" id="L453">            double[] sumDistSSD = null;</span>
<span class="fc" id="L454">            float sigmaFactor = 1.5f;            </span>
<span class="fc" id="L455">            int nIter = 0;</span>
<span class="fc" id="L456">            int nMaxIter = 5;</span>
<span class="pc bpc" id="L457" title="3 of 4 branches missed.">            while ((nIter == 0) || (nIter &lt; nMaxIter)) {   </span>
<span class="fc" id="L458">                log.info(&quot;before bestStats.size()=&quot; + bestStats.size());</span>
<span class="fc" id="L459">                sumDistSSD = MiscStats.filterStatsForTranslation(bestParams, </span>
                    bestStats, sigmaFactor);
<span class="fc" id="L461">                log.info(&quot;after bestStats.size()=&quot; + bestStats.size());</span>
<span class="pc bpc" id="L462" title="2 of 4 branches missed.">                if (sumDistSSD != null &amp;&amp; !bestStats.isEmpty()) {</span>
<span class="fc" id="L463">                    break;</span>
                }                
<span class="nc" id="L465">                sigmaFactor += 1;</span>
<span class="nc" id="L466">                nIter++;</span>
            }            
            
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">            if (sumDistSSD != null) {</span>
                                
<span class="fc" id="L471">                TransformationParameters combinedParams =</span>
<span class="fc" id="L472">                    MiscStats.calculateTransformation(1, 1, bestStats,</span>
                        new float[4], false);
                
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">                if (combinedParams != null) {</span>
<span class="fc" id="L476">                    bestParams = combinedParams;</span>
<span class="fc" id="L477">                    float cost1Norm = 1.f/(float)bestStats.size();</span>
<span class="fc" id="L478">                    float cost2Norm = (float)sumDistSSD[1] + 1;</span>
<span class="fc" id="L479">                    float cost3Norm = ((float)sumDistSSD[0] + 0.01f)/(float)bestTolTransXY2;</span>
<span class="fc" id="L480">                    bestCost = cost1Norm * cost2Norm * cost3Norm;</span>
                }
            }
        }
        
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        if (bestParams != null) {</span>
            
<span class="pc bpc" id="L487" title="3 of 4 branches missed.">            if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                for (int i = 0; i &lt; bestStats.size(); ++i) {</span>
<span class="fc" id="L489">                    FeatureComparisonStat stat = bestStats.get(i);</span>
<span class="fc" id="L490">                    stat.setBinFactor1(binFactor1);</span>
<span class="fc" id="L491">                    stat.setBinFactor2(binFactor2);</span>
                }
            }

<span class="fc" id="L495">            MatchingSolution soln = new MatchingSolution(bestParams, bestStats,</span>
                binFactor1, binFactor2);
<span class="fc" id="L497">            return soln;</span>
        }

<span class="nc" id="L500">        return null;</span>
    }
    
    private boolean paramsAreValid(TransformationParameters params) {
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L505">            return false;</span>
        }
<span class="pc bpc" id="L507" title="2 of 4 branches missed.">        if (Float.isNaN(params.getScale())  || Float.isNaN(params.getRotationInRadians())) {</span>
<span class="nc" id="L508">            return false;</span>
        }
<span class="fc" id="L510">        return true;</span>
    }
    
    private double distance(double x1, double y1, double x2, double y2) {

<span class="fc" id="L515">        double diffX = x1 - x2;</span>
<span class="fc" id="L516">        double diffY = y1 - y2;</span>

<span class="fc" id="L518">        double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>

<span class="fc" id="L520">        return dist;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
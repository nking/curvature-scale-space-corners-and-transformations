<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DFSConnectedGroupsFinder3.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">DFSConnectedGroupsFinder3.java</span></div><h1>DFSConnectedGroupsFinder3.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 * a class to find contiguous pixels having a value within
 * tolerance of the given value and using
 * logic to wrap around a set of values (0 to 360, for example, should see
 * 0 and 359 is being within a tolerance of '1' from one another). Note that
 * the minimum possible value is always 0.
 * 
 * @author nichole
 */
<span class="nc bnc" id="L24" title="All 2 branches missed.">class DFSConnectedGroupsFinder3 {</span>
    
    /**
     * find contiguous pixels having a value within tolerance of the given value and 
     * using logic to
     * wrap around a set of values (0 to 360, for example, should see 0 and 359
     * ss being within a tolerance of '1' from one another). Note that the
     * minimum possible value is always 0.
     * To correct for a group that has wandered from a total range of tolerance,
     * setTheCorrectForWandering to true
     *
     * @param pointValueMap
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @param imageWidth
     * @param imageHeight
     */
    public List&lt;Set&lt;PairInt&gt;&gt; findConnectedPointGroups(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue,
        int imageWidth, int imageHeight) {
        
<span class="nc" id="L45">        return findContiguousGroupsWithRangesWithinTolerance(</span>
            pointValueMap, maxValueForWrapAround, toleranceInValue, 
            imageWidth, imageHeight);
    }
  
    private List&lt;Set&lt;PairInt&gt;&gt; findContiguousGroupsWithRangesWithinTolerance(
        Map&lt;PairInt, Float&gt; thetaMap,
        int maxValueForWrapAround, int toleranceInValue, 
        int imageWidth, int imageHeight) {
        
<span class="nc" id="L55">        int n0 = thetaMap.size();</span>
        
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (n0 &lt;= 1) {</span>
<span class="nc" id="L58">            List&lt;Set&lt;PairInt&gt;&gt; list = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc" id="L59">            list.add(thetaMap.keySet());</span>
<span class="nc" id="L60">            return list;</span>
        }
        
<span class="nc" id="L63">        float[] values = new float[n0];</span>
<span class="nc" id="L64">        int count = 0;</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        for (Entry&lt;PairInt, Float&gt; entry : thetaMap.entrySet()) {</span>
<span class="nc" id="L66">            values[count] = entry.getValue().floatValue();</span>
<span class="nc" id="L67">            count++;</span>
<span class="nc" id="L68">        }</span>
<span class="nc" id="L69">        Arrays.sort(values);</span>
        
<span class="nc" id="L71">        int[] startEndIndexes = MiscStats.determineStartEndIndexes(values, </span>
            maxValueForWrapAround, toleranceInValue);
        
<span class="nc bnc" id="L74" title="All 2 branches missed.">        boolean isWrapAround = (startEndIndexes[0] &gt; startEndIndexes[1]);</span>
                
<span class="nc bnc" id="L76" title="All 2 branches missed.">        float range = isWrapAround ?</span>
            (values[startEndIndexes[1]] 
                + (maxValueForWrapAround - values[startEndIndexes[0]])) :
            (values[startEndIndexes[1]] - values[startEndIndexes[0]]);
        
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (range == toleranceInValue) {</span>
<span class="nc" id="L82">            List&lt;Set&lt;PairInt&gt;&gt; list = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc" id="L83">            list.add(thetaMap.keySet());</span>
<span class="nc" id="L84">            return list;</span>
        }
                      
<span class="nc" id="L87">        int nDividers = (int)(range/toleranceInValue);</span>
        
<span class="nc" id="L89">        int nSeeds = nDividers + 1;</span>
        
<span class="nc" id="L91">        float binWidth = (range/(float)nSeeds)/2.f;</span>
                
<span class="nc" id="L93">        float[] seeds = new float[nSeeds];</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        for (int i = 0; i &lt; nSeeds; ++i) {</span>
<span class="nc" id="L95">            float v = values[startEndIndexes[0]] + (((2 * i) + 1) * binWidth);</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (v &gt; maxValueForWrapAround) {</span>
<span class="nc" id="L97">                v -= maxValueForWrapAround;</span>
            }
<span class="nc" id="L99">            seeds[i] = v;</span>
        }
        
<span class="nc bnc" id="L102" title="All 4 branches missed.">        assert(seeds[seeds.length -1] != 0);</span>
    
<span class="nc" id="L104">        int n2 = 0;</span>
        
<span class="nc" id="L106">        List&lt;Set&lt;PairInt&gt;&gt; output = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
        
<span class="nc" id="L108">        Map&lt;PairInt, List&lt;Integer&gt;&gt; pointGroupMap = new HashMap&lt;PairInt, List&lt;Integer&gt;&gt;();</span>
        
<span class="nc bnc" id="L110" title="All 2 branches missed.">        for (int i = 0; i &lt; seeds.length; ++i) {</span>
            
<span class="nc" id="L112">            float seed = seeds[i];</span>
            
<span class="nc" id="L114">            ContiguousFinder finder = new ContiguousFinder();</span>
            
<span class="nc" id="L116">            finder.findConnectedPointGroups(thetaMap, seed,</span>
                maxValueForWrapAround, toleranceInValue, imageWidth, 
                imageHeight);
            
<span class="nc" id="L120">            int n = finder.getNumberOfGroups();</span>
            
<span class="nc bnc" id="L122" title="All 2 branches missed.">            for (int j = 0; j &lt; n; ++j) {</span>
                
<span class="nc" id="L124">                Set&lt;PairInt&gt; group = finder.getXY(j);</span>
              
<span class="nc" id="L126">                n2 += group.size();</span>
                
<span class="nc" id="L128">                Integer groupIndex = Integer.valueOf(output.size());</span>
                
<span class="nc" id="L130">                output.add(group);</span>
                
<span class="nc bnc" id="L132" title="All 2 branches missed.">                for (PairInt p : group) {</span>
<span class="nc" id="L133">                    List&lt;Integer&gt; list = pointGroupMap.get(p);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                    if (list == null) {</span>
<span class="nc" id="L135">                        list = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L136">                        pointGroupMap.put(p, list);</span>
                    }
<span class="nc" id="L138">                    list.add(groupIndex);</span>
<span class="nc" id="L139">                }</span>
            }
        }
        
<span class="nc bnc" id="L143" title="All 4 branches missed.">        assert(n2 &gt;= n0);</span>
        
<span class="nc" id="L145">        resolveMultipleMappings(output, pointGroupMap, thetaMap);</span>
        
<span class="nc" id="L147">        return output;</span>
        /*
        Because groups that were found by DFSConnectedGroupsFinder2
        were found by an offset from each pixel's value,
        those groups may have a range of min value to max value that is larger
        than tolerance.
        
        This method finds the &quot;seeds&quot; that result in contiguous subsets 
        whose min to max values are less than or equal to tolerance.
        
        Ideally, the algorithm finds the fewest subsets that each have a 
        range &lt;= tolerance.  the total subsets equal the total membership
        of the super set.
        
        a solution:
           create seeds that are within tolerance of one another and span
        the range
        
        The optimal solution would be able to determine the &quot;seed&quot; values such
        that the fewest contiguous point groups meet the goal.
        
        /*
        The Voronoi algorithm is useful for 1D data, but this is 3D data
        and the other 2Ds require adjacency for all members within a
        seed's cell, so will not use Voronoi.
        
        The optimal value of median seeds is not obvious because of the need
        for adjacency for the membership of pixels.  In other words, it isn't
        a partition problem either because of the need for contiguous 
        membership.
        
        A solution which may not be optimal, would be to make connected groups
        for each seed ignoring whether the point is already present in another
        seed group (but noting dual membership).
        Then to resolve the best membership for the ambiguous points that are
        present in more than one group.
           -- the ambiguous points can choose the seed they are closer to in
              value, and ties can be broken by avg rgb difference of the group
              and the ambiguous point, and further ties can be broken by
              proximity to group centroid.
              -- a caveat is to avoid breaking the connection for an adjacent
                 pixel which does not have another group it could be a member of.
        This solution thus far would be nSeeds times 
        semi-linear in npoints of group, then less than semi-linear for resolving
        ambigous point memberships.
        
        It's possible to repeat that solution for all possible combinations of
        seeds within each side of the median divider(s) and find the best
        solution among those. 
        For 4 seeds on one side and 3 on another, that would be 4*3 combinations.
        For the worse case scenario the range of the entire group would be 360
        and the tolerance would be very small so that the number of seeds
        possible on each side of a divider would factor to a large number of
        combinations n0*n1*n2*n3...
       
        leaning towards using the non ideal solution as it does separate 
        different value sets as defined by tolerance,
        but the solution might not provide the smallest number of contiguous
        groups.
        
        looking at graph cuts algorithms next...
        */

    }

    private void resolveMultipleMappings(List&lt;Set&lt;PairInt&gt;&gt; output, 
        Map&lt;PairInt, List&lt;Integer&gt;&gt; pointGroupMap, 
        Map&lt;PairInt, Float&gt; thetaMap) {
        
        //TODO: consider using rgb to resolve best group for ambiguous matchings
        // and a tie in thetaAvg difference
        
<span class="nc" id="L219">        float[] thetaAvg = new float[output.size()];</span>
<span class="nc" id="L220">        PairInt[] centroids = new PairInt[output.size()];</span>
<span class="nc" id="L221">        Arrays.fill(thetaAvg, -1);</span>
        
<span class="nc" id="L223">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
        // for first implementation, do not perform check for whether moving
        // a point out of a group disconnects another point.
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (Entry&lt;PairInt, List&lt;Integer&gt;&gt; entry : pointGroupMap.entrySet()) {</span>
<span class="nc" id="L228">            List&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (indexes.size() &gt; 1) {</span>
                
<span class="nc" id="L231">                PairInt p = entry.getKey();</span>
                
                // choose between groups
<span class="nc" id="L234">                float minDiffTheta = Float.MAX_VALUE;</span>
<span class="nc" id="L235">                int minDiffThetaIdx = -1;</span>
<span class="nc" id="L236">                int minDiffThetaDistSq = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                for (int i = 0; i &lt; indexes.size(); ++i) {</span>
<span class="nc" id="L238">                    int idx = indexes.get(i).intValue();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                    if (thetaAvg[idx] == -1) {</span>
<span class="nc" id="L240">                        thetaAvg[idx] = calculateAvg(output.get(idx), thetaMap);</span>
                    }
<span class="nc bnc" id="L242" title="All 2 branches missed.">                    if (centroids[idx] == null) {</span>
<span class="nc" id="L243">                        double[] xyCen = curveHelper.calculateXYCentroids(output.get(idx));</span>
<span class="nc" id="L244">                        centroids[idx] = new PairInt((int)Math.round(xyCen[0]),</span>
<span class="nc" id="L245">                            (int)Math.round(xyCen[1]));</span>
                    }
<span class="nc" id="L247">                    float theta = thetaMap.get(p).floatValue();</span>
<span class="nc" id="L248">                    float diffT = Math.abs(thetaAvg[idx] - theta);</span>
<span class="nc" id="L249">                    int diffX = p.getX() - centroids[idx].getX();</span>
<span class="nc" id="L250">                    int diffY = p.getY() - centroids[idx].getY();</span>
<span class="nc" id="L251">                    int distSq = (diffX * diffX) + (diffY * diffY);</span>
<span class="nc bnc" id="L252" title="All 6 branches missed.">                    if ((diffT &lt; minDiffTheta) ||  ((diffT == minDiffTheta) &amp;&amp;</span>
                        (distSq &lt; minDiffThetaDistSq))) {
<span class="nc" id="L254">                        minDiffTheta = diffT;</span>
<span class="nc" id="L255">                        minDiffThetaIdx = idx;</span>
<span class="nc" id="L256">                        minDiffThetaDistSq = distSq;</span>
                    }
                }
<span class="nc bnc" id="L259" title="All 2 branches missed.">                for (int i = (indexes.size() - 1); i &gt; -1 ; --i) {</span>
<span class="nc" id="L260">                    int idx = indexes.get(i).intValue();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                    if (idx == minDiffThetaIdx) {</span>
<span class="nc" id="L262">                        continue;</span>
                    }
<span class="nc" id="L264">                    output.get(idx).remove(p);</span>
<span class="nc" id="L265">                    indexes.remove(indexes.get(i));</span>
                }
<span class="nc" id="L267">int z = 1;                </span>
            }
<span class="nc" id="L269">        }</span>
<span class="nc" id="L270">int z = 1;</span>
<span class="nc" id="L271">    }</span>

    private float calculateAvg(Set&lt;PairInt&gt; points, Map&lt;PairInt, Float&gt; thetaMap) {
        
<span class="nc" id="L275">        float sum = 0;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L277">            sum += thetaMap.get(p).floatValue();</span>
<span class="nc" id="L278">        }</span>
<span class="nc" id="L279">        sum /= (float)points.size();</span>
        
<span class="nc" id="L281">        return sum;</span>
    }

<span class="nc" id="L284">    protected static class ContiguousFinder extends AbstractDFSConnectedGroupsFinder {</span>

        public ContiguousFinder() {
            minimumNumberInCluster = 1;        
        }
    
        public void findConnectedPointGroups(Map&lt;PairInt, Float&gt; pointValueMap,
            float value, int maxValueForWrapAround, int toleranceInValue,
            int imageWidth, int imageHeight) {

            findClustersIterative(pointValueMap, value, maxValueForWrapAround,
                toleranceInValue, imageWidth, imageHeight);

            prune();
        }
        
        private void findClustersIterative(Map&lt;PairInt, Float&gt; pointValueMap,
            float value, int maxValueForWrapAround, int toleranceInValue,
            int imageWidth, int imageHeight) {

            Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();

            java.util.Stack&lt;PairInt&gt; stack = new java.util.Stack&lt;PairInt&gt;();

            //O(N)
            for (Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {
                stack.add(entry.getKey());
            }

            visited.add(stack.peek());

            while (!stack.isEmpty()) {

                PairInt uPoint = stack.pop();

                int uX = uPoint.getX();
                int uY = uPoint.getY();

                boolean foundANeighbor = false;

                float uValue = pointValueMap.get(uPoint).floatValue();

                boolean similar = false;
                if (Math.abs(uValue - value) &lt;= toleranceInValue) {
                    similar = true;
                }
                if (!similar) {
                    if (Math.abs(uValue - (value - maxValueForWrapAround)) &lt;= toleranceInValue) {
                        similar = true;
                    }
                }
                if (!similar) {
                    if (Math.abs(value - (uValue - maxValueForWrapAround)) &lt;= toleranceInValue) {
                        similar = true;
                    }
                }
                if (!similar) {
                    continue;
                } 

                for (int vX = (uX - 1); vX &lt;= (uX + 1); vX++) {
                    if ((vX &lt; 0) || (vX &gt; (imageWidth - 1))) {
                        continue;
                    }

                    for (int vY = (uY - 1); vY &lt;= (uY + 1); vY++) {
                        if ((vY &lt; 0) || (vY &gt; (imageHeight - 1))) {
                            continue;
                        }

                        PairInt vPoint = new PairInt(vX, vY);

                        if (vPoint.equals(uPoint)) {
                            continue;
                        }

                        if (!pointValueMap.containsKey(vPoint)) {
                            continue;
                        }

                        if (visited.contains(vPoint)) {
                            continue;
                        }

                        float vValue = pointValueMap.get(vPoint).floatValue();
                        similar = false;
                        if (Math.abs(vValue - value) &lt;= toleranceInValue) {
                            similar = true;
                        }
                        if (!similar) {
                            if (Math.abs(vValue - (value - maxValueForWrapAround)) &lt;= toleranceInValue) {
                                similar = true;
                            }
                        }
                        if (!similar) {
                            if (Math.abs(value - (vValue - maxValueForWrapAround)) &lt;= toleranceInValue) {
                                similar = true;
                            }
                        }
                        if (!similar) {
                            continue;
                        }

                        visited.add(vPoint);

                        processPair(uPoint, vPoint);

                        stack.add(vPoint);

                        foundANeighbor = true;
                    }
                }

                if (!foundANeighbor &amp;&amp; (minimumNumberInCluster == 1)) {

                    process(uPoint);
                }
            }
        }

        @Override
        Logger constructLogger() {
            return Logger.getLogger(DFSConnectedGroupsFinder2.class.getName());
        }
    
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
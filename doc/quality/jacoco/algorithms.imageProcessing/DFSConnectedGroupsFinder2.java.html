<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DFSConnectedGroupsFinder2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">DFSConnectedGroupsFinder2.java</span></div><h1>DFSConnectedGroupsFinder2.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 * a class to find contiguous pixels near one another in value and including
 * logic to wrap around a set of values (0 to 360, for example, should see
 * 0 and 359 is being within a tolerance of '1' from one another). Note that
 * the minimum possible value is always 0.
 * 
 * @author nichole
 */
<span class="pc bpc" id="L22" title="1 of 2 branches missed.">public class DFSConnectedGroupsFinder2 extends AbstractDFSConnectedGroupsFinder {</span>

    private enum State {
        INITIALIZED, GROUPS_FOUND, GROUPS_PRUNED, POST_GROUP_CORRECTED
    }
    
<span class="fc" id="L28">    private State state = null;</span>
    
<span class="fc" id="L30">    public DFSConnectedGroupsFinder2() {</span>
        
<span class="fc" id="L32">        minimumNumberInCluster = 1;</span>
        
<span class="fc" id="L34">        state = State.INITIALIZED;</span>
<span class="fc" id="L35">    }</span>
    
    Logger constructLogger() {
<span class="fc" id="L38">        return Logger.getLogger(DFSConnectedGroupsFinder2.class.getName());</span>
    }
    
    /**
     * find contiguous pixels near one another in value and including logic to
     * wrap around a set of values (0 to 360, for example, should see 0 and 359
     * ss being within a tolerance of '1' from one another). Note that the
     * minimum possible value is always 0.
     * To correct for a group that has wandered from a total range of tolerance,
     * setTheCorrectForWandering to true
     *
     * @param pointValueMap
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @param imageWidth
     * @param imageHeight
     * @param correctForWandering if true, uses another algorithm after the
     * groups are found to make subsets within each if the range is larger 
     * than tolerance.
     */
    public void findConnectedPointGroups(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue,
        int imageWidth, int imageHeight, boolean correctForWandering) {
          
<span class="fc" id="L62">        findClustersIterative(pointValueMap, maxValueForWrapAround, </span>
            toleranceInValue, imageWidth, imageHeight);
        
<span class="fc" id="L65">        prune();</span>
                
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (correctForWandering) {</span>
<span class="nc" id="L68">            correctRangesIfNeeded(pointValueMap, maxValueForWrapAround,</span>
                toleranceInValue, imageWidth, imageHeight);
        }
<span class="fc" id="L71">    }</span>

    @Override
    protected void prune() {
        
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (!state.equals(State.GROUPS_FOUND)) {</span>
<span class="nc" id="L77">            throw new IllegalStateException(</span>
                &quot;findClustersIterative must be used before this&quot;);
        }
        
<span class="fc" id="L81">        super.prune();</span>
        
<span class="fc" id="L83">        state = State.GROUPS_PRUNED;</span>
<span class="fc" id="L84">    }</span>
  
    protected void findClustersIterative(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue,
        int imageWidth, int imageHeight) {
        
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (pointValueMap.isEmpty()) {</span>
<span class="nc" id="L91">            state = State.GROUPS_FOUND;</span>
<span class="nc" id="L92">            return;</span>
        }
        
<span class="fc" id="L95">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L97">        java.util.Stack&lt;PairInt&gt; stack = new java.util.Stack&lt;PairInt&gt;();</span>
        
        //O(N)
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="fc" id="L101">            stack.add(entry.getKey());</span>
<span class="fc" id="L102">        }</span>
               
<span class="fc" id="L104">        visited.add(stack.peek());</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>

<span class="fc" id="L108">            PairInt uPoint = stack.pop();</span>
            
<span class="fc" id="L110">            int uX = uPoint.getX();</span>
<span class="fc" id="L111">            int uY = uPoint.getY();</span>

<span class="fc" id="L113">            boolean foundANeighbor = false;</span>
            
<span class="fc" id="L115">            float uValue = pointValueMap.get(uPoint).floatValue();</span>
            
            //(1 + frac)*O(N) where frac is the fraction added back to stack
            
<span class="fc bfc" id="L119" title="All 2 branches covered.">            for (int vX = (uX - 1); vX &lt;= (uX + 1); vX++) {</span>
<span class="fc bfc" id="L120" title="All 4 branches covered.">                if ((vX &lt; 0) || (vX &gt; (imageWidth - 1))) {</span>
<span class="fc" id="L121">                    continue;</span>
                }
                
<span class="fc bfc" id="L124" title="All 2 branches covered.">                for (int vY = (uY - 1); vY &lt;= (uY + 1); vY++) {</span>
<span class="fc bfc" id="L125" title="All 4 branches covered.">                    if ((vY &lt; 0) || (vY &gt; (imageHeight - 1))) {</span>
<span class="fc" id="L126">                        continue;</span>
                    }
                    
<span class="fc" id="L129">                    PairInt vPoint = new PairInt(vX, vY);</span>
                    
<span class="fc bfc" id="L131" title="All 2 branches covered.">                    if (vPoint.equals(uPoint)) {</span>
<span class="fc" id="L132">                        continue;</span>
                    }
                    
<span class="fc bfc" id="L135" title="All 2 branches covered.">                    if (!pointValueMap.containsKey(vPoint)) {</span>
<span class="fc" id="L136">                        continue;</span>
                    }
                    
<span class="fc bfc" id="L139" title="All 2 branches covered.">                    if (visited.contains(vPoint)) {</span>
<span class="fc" id="L140">                        continue;</span>
                    }
                    
<span class="fc" id="L143">                    boolean similar = false;</span>
                    
<span class="fc" id="L145">                    float vValue = pointValueMap.get(vPoint).floatValue();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                    if (Math.abs(uValue - vValue) &lt;= toleranceInValue) {</span>
<span class="fc" id="L147">                        similar = true;</span>
                    }
                    
                    // test wrap around
<span class="fc bfc" id="L151" title="All 2 branches covered.">                    if (!similar) {</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">                        if (Math.abs(uValue - (vValue - maxValueForWrapAround)) &lt;= toleranceInValue) {</span>
<span class="nc" id="L153">                            similar = true;</span>
                        }
                        /*
                            0        360
                            |  u    v |
                          v |  u      |
                        */
                    }
<span class="fc bfc" id="L161" title="All 2 branches covered.">                    if (!similar) {</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                        if (Math.abs(vValue - (uValue - maxValueForWrapAround)) &lt;= toleranceInValue) {</span>
<span class="nc" id="L163">                            similar = true;</span>
                        }
                        /*
                            0        360
                            |  v    u |
                          u |  v      |
                        */
                    }
                    
<span class="fc bfc" id="L172" title="All 2 branches covered.">                    if (!similar) {</span>
<span class="fc" id="L173">                        continue;</span>
                    }
                    
<span class="fc" id="L176">                    visited.add(vPoint);</span>
                    
<span class="fc" id="L178">                    processPair(uPoint, vPoint);</span>
                
<span class="fc" id="L180">                    stack.add(vPoint);</span>
                    
<span class="fc" id="L182">                    foundANeighbor = true;</span>
                }
            }
            
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">            if (!foundANeighbor &amp;&amp; (minimumNumberInCluster == 1)) {</span>
                
<span class="fc" id="L188">                process(uPoint);</span>
            }
<span class="fc" id="L190">        }</span>
        
<span class="fc" id="L192">        state = State.GROUPS_FOUND;</span>
<span class="fc" id="L193">    }</span>

    private void correctRangesIfNeeded(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue, int imageWidth, 
        int imageHeight) {
          
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (!state.equals(State.GROUPS_PRUNED)) {</span>
<span class="nc" id="L200">            throw new IllegalStateException(</span>
                &quot;prune() must be used before this&quot;);
        }
        
        // traverse the range from largest index to smallest so can append
        // to lists without affecting smaller indexes
<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (int idx = (getNumberOfGroups() - 1); idx &gt; -1; --idx) {</span>
            
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (groupMembership.get(idx).size() &lt; 2) {</span>
<span class="nc" id="L209">                continue;</span>
            }
             
<span class="nc" id="L212">            Map&lt;PairInt, Float&gt; thetaMap = createSubMap(groupMembership.get(idx),</span>
                pointValueMap);
            
<span class="nc" id="L215">            int[] startEndValues = MiscStats.determineStartEndValues(thetaMap, </span>
                maxValueForWrapAround, toleranceInValue);
            
<span class="nc bnc" id="L218" title="All 2 branches missed.">            int range = (startEndValues[0] &lt;= startEndValues[1]) ?</span>
                (startEndValues[1] - startEndValues[0]) :
                (startEndValues[1] + (maxValueForWrapAround - startEndValues[0]));
            
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (range &lt;= toleranceInValue) {</span>
<span class="nc" id="L223">                continue;</span>
            }
            
<span class="nc" id="L226">            int nBefore = groupMembership.get(idx).size();</span>
            
<span class="nc" id="L228">            List&lt;Set&lt;PairInt&gt;&gt; subsetsWithinTolerance = </span>
<span class="nc" id="L229">                findSubsetsOfRangesWithinTolerance(thetaMap, </span>
                maxValueForWrapAround, toleranceInValue, imageWidth, 
                imageHeight);
            
<span class="nc bnc" id="L233" title="All 4 branches missed.">            assert(subsetsWithinTolerance.size() &gt; 0);            </span>
            
            // replace current group:
<span class="nc" id="L236">            groupMembership.set(idx, subsetsWithinTolerance.get(0));</span>
            
<span class="nc" id="L238">            int nAfterTot = groupMembership.get(idx).size();</span>
            
            // append remaining and update pointToGroupMap
<span class="nc bnc" id="L241" title="All 2 branches missed.">            for (int j = 1; j &lt; subsetsWithinTolerance.size(); ++j) {</span>
                
<span class="nc" id="L243">                Set&lt;PairInt&gt; group = subsetsWithinTolerance.get(j);</span>
                
<span class="nc" id="L245">                nAfterTot += group.size();</span>
                
<span class="nc" id="L247">                int idx2 = groupMembership.size();</span>
                
<span class="nc" id="L249">                groupMembership.add(group);</span>
                
                // update Map&lt;PairInt, Integer&gt; pointToGroupMap
<span class="nc" id="L252">                updatePointToGroupMap(group, idx2);</span>
            }
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (nBefore != nAfterTot) {</span>
<span class="nc" id="L255">                int z = 1;</span>
            }
<span class="nc bnc" id="L257" title="All 4 branches missed.">            assert(nBefore == nAfterTot);</span>
        }
       
<span class="nc" id="L260">        state = State.POST_GROUP_CORRECTED;</span>
<span class="nc" id="L261">    }</span>
    
    private void updatePointToGroupMap(Set&lt;PairInt&gt; group, int idx) {
        
<span class="nc" id="L265">        Integer index = Integer.valueOf(idx);</span>
        
<span class="nc bnc" id="L267" title="All 2 branches missed.">        for (PairInt p : group) {</span>
<span class="nc" id="L268">            this.pointToGroupMap.put(p, index);</span>
<span class="nc" id="L269">        }</span>
<span class="nc" id="L270">    }</span>
    
    private Map&lt;PairInt, Float&gt; createSubMap(Set&lt;PairInt&gt; points, 
        Map&lt;PairInt, Float&gt; pointValueMap) {
        
<span class="nc" id="L275">        Map&lt;PairInt, Float&gt; subMap = new HashMap&lt;PairInt, Float&gt;();</span>
        
<span class="nc bnc" id="L277" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L278">            subMap.put(p, pointValueMap.get(p));</span>
<span class="nc" id="L279">        }</span>
        
<span class="nc" id="L281">        return subMap;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; findSubsetsOfRangesWithinTolerance( 
        Map&lt;PairInt, Float&gt; thetaMap,
        int maxValueForWrapAround, int toleranceInValue, 
        int imageWidth, int imageHeight) {
        
<span class="nc" id="L289">        DFSConnectedGroupsFinder3 finder = new DFSConnectedGroupsFinder3();</span>
        
<span class="nc" id="L291">        List&lt;Set&lt;PairInt&gt;&gt; sets = finder.findConnectedPointGroups(thetaMap, </span>
            maxValueForWrapAround, toleranceInValue, imageWidth, imageHeight);
        
<span class="nc" id="L294">        return sets;</span>
    }
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
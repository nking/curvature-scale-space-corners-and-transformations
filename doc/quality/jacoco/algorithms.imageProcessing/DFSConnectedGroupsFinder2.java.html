<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DFSConnectedGroupsFinder2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">DFSConnectedGroupsFinder2.java</span></div><h1>DFSConnectedGroupsFinder2.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 * a class to find contiguous pixels near one another in value and including
 * logic to wrap around a set of values (0 to 360, for example, should see
 * 0 and 359 is being within a tolerance of '1' from one another). Note that
 * the minimum possible value is always 0.
 * 
 * @author nichole
 */
<span class="nc bnc" id="L22" title="All 2 branches missed.">public class DFSConnectedGroupsFinder2 extends AbstractDFSConnectedGroupsFinder {</span>

    private enum State {
        INITIALIZED, GROUPS_FOUND, GROUPS_PRUNED, POST_GROUP_CORRECTED
    }
    
<span class="nc" id="L28">    private State state = null;</span>
    
    public DFSConnectedGroupsFinder2() {
    
<span class="nc" id="L32">        super();</span>
        
<span class="nc" id="L34">        minimumNumberInCluster = 1;</span>
        
<span class="nc" id="L36">        state = State.INITIALIZED;</span>
<span class="nc" id="L37">    }</span>
    
    @Override
    Logger constructLogger() {
<span class="nc" id="L41">        return Logger.getLogger(DFSConnectedGroupsFinder2.class.getName());</span>
    }
    
    /**
     * find contiguous pixels near one another in value and including logic to
     * wrap around a set of values (0 to 360, for example, should see 0 and 359
     * ss being within a tolerance of '1' from one another). Note that the
     * minimum possible value is always 0.
     * To correct for a group that has wandered from a total range of tolerance,
     * setTheCorrectForWandering to true
     *
     * @param pointValueMap
     * @param maxValueForWrapAround
     * @param toleranceInValue
     * @param imageWidth
     * @param imageHeight
     * @param correctForWandering if true, uses another algorithm after the
     * groups are found to make subsets within each if the range is larger 
     * than tolerance.
     */
    public void findConnectedPointGroups(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue,
        int imageWidth, int imageHeight, boolean correctForWandering) {
          
<span class="nc" id="L65">        findClustersIterative(pointValueMap, maxValueForWrapAround, </span>
            toleranceInValue, imageWidth, imageHeight);
        
<span class="nc" id="L68">        prune();</span>
                
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (correctForWandering) {</span>
<span class="nc" id="L71">            correctRangesIfNeeded(pointValueMap, maxValueForWrapAround,</span>
                toleranceInValue, imageWidth, imageHeight);
        }
<span class="nc" id="L74">    }</span>

    @Override
    protected void prune() {
        
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (!state.equals(State.GROUPS_FOUND)) {</span>
<span class="nc" id="L80">            throw new IllegalStateException(</span>
                &quot;findClustersIterative must be used before this&quot;);
        }
        
<span class="nc" id="L84">        super.prune();</span>
        
<span class="nc" id="L86">        state = State.GROUPS_PRUNED;</span>
<span class="nc" id="L87">    }</span>
  
    protected void findClustersIterative(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue,
        int imageWidth, int imageHeight) {
        
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (pointValueMap.isEmpty()) {</span>
<span class="nc" id="L94">            state = State.GROUPS_FOUND;</span>
<span class="nc" id="L95">            return;</span>
        }
        
<span class="nc" id="L98">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L100">        java.util.Stack&lt;PairInt&gt; stack = new java.util.Stack&lt;PairInt&gt;();</span>
        
        //O(N)
<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (Entry&lt;PairInt, Float&gt; entry : pointValueMap.entrySet()) {</span>
<span class="nc" id="L104">            stack.add(entry.getKey());</span>
<span class="nc" id="L105">        }</span>
               
<span class="nc" id="L107">        visited.add(stack.peek());</span>

<span class="nc bnc" id="L109" title="All 2 branches missed.">        while (!stack.isEmpty()) {</span>

<span class="nc" id="L111">            PairInt uPoint = stack.pop();</span>
            
<span class="nc" id="L113">            int uX = uPoint.getX();</span>
<span class="nc" id="L114">            int uY = uPoint.getY();</span>

<span class="nc" id="L116">            boolean foundANeighbor = false;</span>
            
<span class="nc" id="L118">            float uValue = pointValueMap.get(uPoint).floatValue();</span>
            
            //(1 + frac)*O(N) where frac is the fraction added back to stack
            
<span class="nc bnc" id="L122" title="All 2 branches missed.">            for (int vX = (uX - 1); vX &lt;= (uX + 1); vX++) {</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">                if ((vX &lt; 0) || (vX &gt; (imageWidth - 1))) {</span>
<span class="nc" id="L124">                    continue;</span>
                }
                
<span class="nc bnc" id="L127" title="All 2 branches missed.">                for (int vY = (uY - 1); vY &lt;= (uY + 1); vY++) {</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">                    if ((vY &lt; 0) || (vY &gt; (imageHeight - 1))) {</span>
<span class="nc" id="L129">                        continue;</span>
                    }
                    
<span class="nc" id="L132">                    PairInt vPoint = new PairInt(vX, vY);</span>
                    
<span class="nc bnc" id="L134" title="All 2 branches missed.">                    if (vPoint.equals(uPoint)) {</span>
<span class="nc" id="L135">                        continue;</span>
                    }
                    
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    if (!pointValueMap.containsKey(vPoint)) {</span>
<span class="nc" id="L139">                        continue;</span>
                    }
                    
<span class="nc bnc" id="L142" title="All 2 branches missed.">                    if (visited.contains(vPoint)) {</span>
<span class="nc" id="L143">                        continue;</span>
                    }
                    
<span class="nc" id="L146">                    boolean similar = false;</span>
                    
<span class="nc" id="L148">                    float vValue = pointValueMap.get(vPoint).floatValue();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                    if (Math.abs(uValue - vValue) &lt;= toleranceInValue) {</span>
<span class="nc" id="L150">                        similar = true;</span>
                    }
                    
                    // test wrap around
<span class="nc bnc" id="L154" title="All 2 branches missed.">                    if (!similar) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                        if (Math.abs(uValue - (vValue - maxValueForWrapAround)) &lt;= toleranceInValue) {</span>
<span class="nc" id="L156">                            similar = true;</span>
                        }
                        /*
                            0        360
                            |  u    v |
                          v |  u      |
                        */
                    }
<span class="nc bnc" id="L164" title="All 2 branches missed.">                    if (!similar) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                        if (Math.abs(vValue - (uValue - maxValueForWrapAround)) &lt;= toleranceInValue) {</span>
<span class="nc" id="L166">                            similar = true;</span>
                        }
                        /*
                            0        360
                            |  v    u |
                          u |  v      |
                        */
                    }
                    
<span class="nc bnc" id="L175" title="All 2 branches missed.">                    if (!similar) {</span>
<span class="nc" id="L176">                        continue;</span>
                    }
                    
<span class="nc" id="L179">                    visited.add(vPoint);</span>
                    
<span class="nc" id="L181">                    processPair(uPoint, vPoint);</span>
                
<span class="nc" id="L183">                    stack.add(vPoint);</span>
                    
<span class="nc" id="L185">                    foundANeighbor = true;</span>
                }
            }
            
<span class="nc bnc" id="L189" title="All 4 branches missed.">            if (!foundANeighbor &amp;&amp; (minimumNumberInCluster == 1)) {</span>
                
<span class="nc" id="L191">                process(uPoint);</span>
            }
<span class="nc" id="L193">        }</span>
        
<span class="nc" id="L195">        state = State.GROUPS_FOUND;</span>
<span class="nc" id="L196">    }</span>

    private void correctRangesIfNeeded(Map&lt;PairInt, Float&gt; pointValueMap, 
        int maxValueForWrapAround, int toleranceInValue, int imageWidth, 
        int imageHeight) {
          
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (!state.equals(State.GROUPS_PRUNED)) {</span>
<span class="nc" id="L203">            throw new IllegalStateException(</span>
                &quot;prune() must be used before this&quot;);
        }
        
        // traverse the range from largest index to smallest so can append
        // to lists without affecting smaller indexes
<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int idx = (getNumberOfGroups() - 1); idx &gt; -1; --idx) {</span>
            
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (groupMembership.get(idx).size() &lt; 2) {</span>
<span class="nc" id="L212">                continue;</span>
            }
             
<span class="nc" id="L215">            Map&lt;PairInt, Float&gt; thetaMap = createSubMap(groupMembership.get(idx),</span>
                pointValueMap);
            
<span class="nc" id="L218">            int[] startEndValues = MiscStats.determineStartEndValues(thetaMap, </span>
                maxValueForWrapAround, toleranceInValue);
            
<span class="nc bnc" id="L221" title="All 2 branches missed.">            int range = (startEndValues[0] &lt;= startEndValues[1]) ?</span>
                (startEndValues[1] - startEndValues[0]) :
                (startEndValues[1] + (maxValueForWrapAround - startEndValues[0]));
            
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (range &lt;= toleranceInValue) {</span>
<span class="nc" id="L226">                continue;</span>
            }
            
<span class="nc" id="L229">            int nBefore = groupMembership.get(idx).size();</span>
            
<span class="nc" id="L231">            List&lt;Set&lt;PairInt&gt;&gt; subsetsWithinTolerance = </span>
<span class="nc" id="L232">                findSubsetsOfRangesWithinTolerance(thetaMap, </span>
                maxValueForWrapAround, toleranceInValue, imageWidth, 
                imageHeight);
            
<span class="nc bnc" id="L236" title="All 4 branches missed.">            assert(subsetsWithinTolerance.size() &gt; 0);            </span>
            
            // replace current group:
<span class="nc" id="L239">            groupMembership.set(idx, subsetsWithinTolerance.get(0));</span>
            
<span class="nc" id="L241">            int nAfterTot = groupMembership.get(idx).size();</span>
            
            // append remaining and update pointToGroupMap
<span class="nc bnc" id="L244" title="All 2 branches missed.">            for (int j = 1; j &lt; subsetsWithinTolerance.size(); ++j) {</span>
                
<span class="nc" id="L246">                Set&lt;PairInt&gt; group = subsetsWithinTolerance.get(j);</span>
                
<span class="nc" id="L248">                nAfterTot += group.size();</span>
                
<span class="nc" id="L250">                int idx2 = groupMembership.size();</span>
                
<span class="nc" id="L252">                groupMembership.add(group);</span>
                
                // update Map&lt;PairInt, Integer&gt; pointToGroupMap
<span class="nc" id="L255">                updatePointToGroupMap(group, idx2);</span>
            }
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (nBefore != nAfterTot) {</span>
<span class="nc" id="L258">                int z = 1;</span>
            }
<span class="nc bnc" id="L260" title="All 4 branches missed.">            assert(nBefore == nAfterTot);</span>
        }
       
<span class="nc" id="L263">        state = State.POST_GROUP_CORRECTED;</span>
<span class="nc" id="L264">    }</span>
    
    private void updatePointToGroupMap(Set&lt;PairInt&gt; group, int idx) {
        
<span class="nc" id="L268">        Integer index = Integer.valueOf(idx);</span>
        
<span class="nc bnc" id="L270" title="All 2 branches missed.">        for (PairInt p : group) {</span>
<span class="nc" id="L271">            this.pointToGroupMap.put(p, index);</span>
<span class="nc" id="L272">        }</span>
<span class="nc" id="L273">    }</span>
    
    private Map&lt;PairInt, Float&gt; createSubMap(Set&lt;PairInt&gt; points, 
        Map&lt;PairInt, Float&gt; pointValueMap) {
        
<span class="nc" id="L278">        Map&lt;PairInt, Float&gt; subMap = new HashMap&lt;PairInt, Float&gt;();</span>
        
<span class="nc bnc" id="L280" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L281">            subMap.put(p, pointValueMap.get(p));</span>
<span class="nc" id="L282">        }</span>
        
<span class="nc" id="L284">        return subMap;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; findSubsetsOfRangesWithinTolerance( 
        Map&lt;PairInt, Float&gt; thetaMap,
        int maxValueForWrapAround, int toleranceInValue, 
        int imageWidth, int imageHeight) {
        
<span class="nc" id="L292">        DFSConnectedGroupsFinder3 finder = new DFSConnectedGroupsFinder3();</span>
        
<span class="nc" id="L294">        List&lt;Set&lt;PairInt&gt;&gt; sets = finder.findConnectedPointGroups(thetaMap, </span>
            maxValueForWrapAround, toleranceInValue, imageWidth, imageHeight);
        
<span class="nc" id="L297">        return sets;</span>
    }
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
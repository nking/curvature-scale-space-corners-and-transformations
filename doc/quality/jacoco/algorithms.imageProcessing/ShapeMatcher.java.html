<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShapeMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ShapeMatcher.java</span></div><h1>ShapeMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.PointInPolygon;
import algorithms.compGeometry.convexHull.GrahamScan;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.misc.Histogram;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.PairIntArrayDescendingComparator;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

public class ShapeMatcher {

<span class="fc" id="L26">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L28">    public ShapeMatcher() {</span>
<span class="fc" id="L29">    }</span>

    /**
     * NOT READY FOR USE
    method to extract general shapes from the images and compare them in order to 
    match points.  It returns a fit to a rough Euclidean transformation.
    NOTE that the images may need pre-processing steps before using this.  For example,
    the Brown &amp; Lowe 200? panoramic images of a mountain need to have the sky masked
    out of the image first.
     * @param image1
     * @param image2
     * @param outputMatched1
     * @param outputMatched2
    */
    public TransformationPointFit findMatchingShapes(ImageExt image1, ImageExt image2,
    PairIntArray outputMatched1, PairIntArray outputMatched2) throws 
        IOException, NoSuchAlgorithmException {
                
<span class="fc" id="L47">        GreyscaleImage img1Grey = image1.copyToGreyscale();</span>
<span class="fc" id="L48">        GreyscaleImage img2Grey = image2.copyToGreyscale();</span>
        
<span class="fc" id="L50">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L51">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
        
<span class="fc" id="L53">        final boolean performBinning = false;</span>
<span class="fc" id="L54">        int binFactor1 = 1;</span>
        
<span class="fc" id="L56">        int kN = 4;</span>
<span class="fc" id="L57">        boolean performBinarySegmentation = true;</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        if (performBinarySegmentation) {</span>
<span class="fc" id="L59">            kN = 2;</span>
        }
        
        /*
        one could start with essentially no limits here and then
        looks at the distribution of resulting contiguous group
        sizes to decide the range to keep.
        For now, choosing limits.
        */
<span class="fc" id="L68">        int smallestGroupLimit = 100;</span>
        //TODO: consider scaling this by image size or by size and res if one
        //  day that information is passed to this method
<span class="fc" id="L71">        int largestGroupLimit = 5000;</span>
        
<span class="fc" id="L73">        ImageExt img1Cp = (ImageExt)image1.copyImage();</span>
<span class="fc" id="L74">        ImageExt img2Cp = (ImageExt)image2.copyImage();</span>
        
<span class="fc" id="L76">        ImageStatistics stats1 = ImageStatisticsHelper.examineImage(img1Grey, true); </span>
<span class="fc" id="L77">        ImageStatistics stats2 = ImageStatisticsHelper.examineImage(img2Grey, true); </span>

<span class="fc" id="L79">        log.info(&quot;stats1=&quot; + stats1.toString());</span>
<span class="fc" id="L80">        log.info(&quot;stats2=&quot; + stats2.toString());</span>
        
<span class="fc" id="L82">        boolean performHistEq = false;        </span>
<span class="fc" id="L83">        double median1DivMedian2 = stats1.getMedian()/stats2.getMedian();</span>
<span class="fc" id="L84">        double meanDivMedian1 = stats1.getMean()/stats1.getMedian();        </span>
<span class="fc" id="L85">        double meanDivMedian2 = stats2.getMean()/stats2.getMedian();</span>
<span class="pc bpc" id="L86" title="6 of 8 branches missed.">        if (</span>
            ((median1DivMedian2 &gt; 1) &amp;&amp; ((median1DivMedian2 - 1) &gt; 0.2)) ||
            ((median1DivMedian2 &lt; 1) &amp;&amp; (median1DivMedian2 &lt; 0.8))) {
<span class="nc" id="L89">            performHistEq = true;</span>
<span class="pc bpc" id="L90" title="6 of 8 branches missed.">        } else if (</span>
            ((meanDivMedian1 &gt; 1) &amp;&amp; ((meanDivMedian1 - 1) &gt; 0.2)) ||
            ((meanDivMedian1 &lt; 1) &amp;&amp; (meanDivMedian1 &lt; 0.8))) {
<span class="fc" id="L93">            performHistEq = true;</span>
<span class="nc bnc" id="L94" title="All 8 branches missed.">        } else if (</span>
            ((meanDivMedian2 &gt; 1) &amp;&amp; ((meanDivMedian2 - 1) &gt; 0.2)) ||
            ((meanDivMedian2 &lt; 1) &amp;&amp; (meanDivMedian2 &lt; 0.8))) {
<span class="nc" id="L97">            performHistEq = true;</span>
        }
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (performHistEq) {</span>
<span class="fc" id="L100">            log.info(&quot;use histogram equalization on the greyscale images&quot;);</span>
<span class="fc" id="L101">            HistogramEqualization hEq = new HistogramEqualization(img1Grey);</span>
<span class="fc" id="L102">            hEq.applyFilter();</span>
<span class="fc" id="L103">            hEq = new HistogramEqualization(img2Grey);</span>
<span class="fc" id="L104">            hEq.applyFilter();</span>
            /*HistogramEqualizationForColor hEqC = new HistogramEqualizationForColor(img1Cp);
            hEqC.applyFilter();
            hEqC = new HistogramEqualizationForColor(img2Cp);
            hEqC.applyFilter();*/
        }
        
        if (performBinning) {
            binFactor1 = (int) Math.ceil(
                Math.max((float)img1Grey.getWidth()/200.f,
                (float)img2Grey.getHeight()/200.));
            smallestGroupLimit /= (binFactor1*binFactor1);
            largestGroupLimit /= (binFactor1*binFactor1);
            
            log.info(&quot;binFactor1=&quot; + binFactor1);
            
            // prevent from being smaller than needed for a convex hull
            if (smallestGroupLimit &lt; 4) {
                smallestGroupLimit = 4;
            }
            img1Grey = imageProcessor.binImage(img1Grey, binFactor1);
            img2Grey = imageProcessor.binImage(img2Grey, binFactor1);
            img1Cp = imageProcessor.binImage(img1Cp, binFactor1);
            img2Cp = imageProcessor.binImage(img2Cp, binFactor1);
        }

<span class="fc" id="L130">        imageSegmentation.applyUsingKMPP(img1Grey, kN);</span>
<span class="fc" id="L131">        imageSegmentation.applyUsingKMPP(img2Grey, kN);</span>

        // == contiguous regions within size limits become blobs of interest,
        //    indexed by their intensity levels
        
<span class="fc" id="L136">        Map&lt;Integer, Integer&gt; freqMap1 = Histogram.createAFrequencyMap(img1Grey);</span>
<span class="fc" id="L137">        Map&lt;Integer, Integer&gt; freqMap2 = Histogram.createAFrequencyMap(img2Grey);</span>
        
<span class="fc" id="L139">        Map&lt;Integer, List&lt;PairIntArray&gt;&gt; contigMap1 </span>
            = new HashMap&lt;Integer, List&lt;PairIntArray&gt;&gt;();
<span class="fc" id="L141">        Map&lt;Integer, List&lt;PairIntArray&gt;&gt; contigMap2 </span>
            = new HashMap&lt;Integer, List&lt;PairIntArray&gt;&gt;();
        
<span class="fc" id="L144">        Map&lt;Integer, List&lt;GrahamScan&gt;&gt; hulls1 = </span>
            new HashMap&lt;Integer, List&lt;GrahamScan&gt;&gt;();
<span class="fc" id="L146">        Map&lt;Integer, List&lt;GrahamScan&gt;&gt; hulls2 = </span>
            new HashMap&lt;Integer, List&lt;GrahamScan&gt;&gt;();
        
<span class="fc" id="L149">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L151">        Map&lt;Integer, PairIntArray&gt; hullCentroids1Map = </span>
            new HashMap&lt;Integer, PairIntArray&gt;();
<span class="fc" id="L153">        Map&lt;Integer, PairIntArray&gt; hullCentroids2Map = </span>
            new HashMap&lt;Integer, PairIntArray&gt;();
<span class="fc" id="L155">        PairIntArray allHullCentroids1 = new PairIntArray();</span>
<span class="fc" id="L156">        PairIntArray allHullCentroids2 = new PairIntArray();</span>
        
<span class="fc bfc" id="L158" title="All 2 branches covered.">        for (int im = 0; im &lt; 2; ++im) {</span>
            
<span class="fc" id="L160">            Map&lt;Integer, Integer&gt; freqMap = freqMap1;</span>
<span class="fc" id="L161">            Map&lt;Integer, List&lt;PairIntArray&gt;&gt; contigMap = contigMap1;</span>
<span class="fc" id="L162">            Map&lt;Integer, List&lt;GrahamScan&gt;&gt; hulls = hulls1;</span>
<span class="fc" id="L163">            GreyscaleImage imgGrey = img1Grey;</span>
<span class="fc" id="L164">            PairIntArray hullCentroids = allHullCentroids1;</span>
<span class="fc" id="L165">            Map&lt;Integer, PairIntArray&gt; hullCentroidsMap = hullCentroids1Map;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (im == 1) {</span>
<span class="fc" id="L167">                freqMap = freqMap2;</span>
<span class="fc" id="L168">                contigMap = contigMap2;</span>
<span class="fc" id="L169">                hulls = hulls2;</span>
<span class="fc" id="L170">                hullCentroids = allHullCentroids2;</span>
<span class="fc" id="L171">                imgGrey = img2Grey;</span>
<span class="fc" id="L172">                hullCentroidsMap = hullCentroids2Map;</span>
            }
 
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (Entry&lt;Integer, Integer&gt; entry : freqMap.entrySet()) {</span>

<span class="fc" id="L177">                Integer pixValue = entry.getKey();</span>

<span class="fc" id="L179">                DFSContiguousValueFinder finder = new DFSContiguousValueFinder(</span>
                    imgGrey);
<span class="fc" id="L181">                finder.setMinimumNumberInCluster(smallestGroupLimit);</span>
<span class="fc" id="L182">                finder.findGroups(pixValue.intValue());</span>

<span class="fc" id="L184">                int nGroups = finder.getNumberOfGroups();</span>
<span class="fc" id="L185">                List&lt;PairIntArray&gt; list = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                for (int i = 0; i &lt; nGroups; i++) {</span>
<span class="fc" id="L187">                    PairIntArray xy = finder.getXY(i);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                    if (xy.getN() &lt; largestGroupLimit) {</span>
<span class="fc" id="L189">                        list.add(xy);</span>
                    }
                }
<span class="fc" id="L192">                Collections.sort(list, new PairIntArrayDescendingComparator());</span>
                
                // storing the centroids for this intensity level hulls separateley
<span class="fc" id="L195">                PairIntArray pvHullCentroids = new PairIntArray();</span>
                
                // remove hulls with large area on image bounds
<span class="fc" id="L198">                List&lt;Integer&gt; rm = new ArrayList&lt;Integer&gt;();</span>
                
<span class="fc" id="L200">                List&lt;GrahamScan&gt; listHulls = new ArrayList&lt;GrahamScan&gt;();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                for (int i = 0; i &lt; list.size(); ++i) {</span>
                    
<span class="fc" id="L203">                    PairIntArray xy = list.get(i);</span>
                    
<span class="fc" id="L205">                    GrahamScan scan = new GrahamScan();</span>
                    try {
<span class="fc" id="L207">                        float[] x = new float[xy.getN()];</span>
<span class="fc" id="L208">                        float[] y = new float[x.length];</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                        for (int ii = 0; ii &lt; x.length; ++ii) {</span>
<span class="fc" id="L210">                            x[ii] = xy.getX(ii);</span>
<span class="fc" id="L211">                            y[ii] = xy.getY(ii);</span>
                        }
                        
<span class="fc" id="L214">                        double[] centroidXY = </span>
<span class="fc" id="L215">                            curveHelper.calculateXYCentroids(x, y);</span>

<span class="fc" id="L217">                        scan.computeHull(x, y);</span>
                        
                        // if more than one hull point touches the bounds of the
                        // image, the hull is removed because it may be
                        // incomplete.  may need to change this rule later
                        // if it makes the solution too shallow in terms of 
                        // very close points
                        
<span class="fc" id="L225">                        int nBounds = 0;</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                        for (int ii = 0; ii &lt; scan.getXHull().length; ++ii) {</span>
<span class="fc" id="L227">                            float xh = scan.getXHull()[ii];</span>
<span class="fc" id="L228">                            float yh = scan.getYHull()[ii];</span>
<span class="pc bpc" id="L229" title="2 of 6 branches missed.">                            if ((xh == 0) || xh == (imgGrey.getWidth() - 1) ||</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                                (yh == 0) || yh == (imgGrey.getHeight() - 1)) {</span>
<span class="fc" id="L231">                                nBounds++;</span>
                            }
                        }
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                        if (nBounds &gt; 3) {                            </span>
<span class="nc" id="L235">                            rm.add(Integer.valueOf(i));</span>
                        } else {
<span class="fc" id="L237">                            listHulls.add(scan);</span>
<span class="fc" id="L238">                            int xh = (int)Math.round(centroidXY[0]);</span>
<span class="fc" id="L239">                            int yh = (int)Math.round(centroidXY[1]);</span>
<span class="fc" id="L240">                            hullCentroids.add(xh, yh);</span>
<span class="fc" id="L241">                            pvHullCentroids.add(xh, yh);</span>
                        }
                        
<span class="nc" id="L244">                    } catch (GrahamScanTooFewPointsException e) {</span>
<span class="nc" id="L245">                        log.severe(e.getMessage());</span>
<span class="fc" id="L246">                    }</span>
                }
                
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                for (int i = (rm.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L250">                    int rmIdx = rm.get(i).intValue();</span>
<span class="nc" id="L251">                    list.remove(rmIdx);</span>
                }

<span class="fc" id="L254">                log.info(&quot;nHulls&quot; + (im + 1) + &quot;=&quot; + listHulls.size() + &quot; for intensity=&quot; + pixValue.toString());</span>
                
<span class="fc" id="L256">                contigMap.put(pixValue, list);</span>
<span class="fc" id="L257">                hulls.put(pixValue, listHulls);</span>
<span class="fc" id="L258">                hullCentroidsMap.put(pixValue, pvHullCentroids);</span>
<span class="fc" id="L259">            }</span>
        }
        
<span class="fc" id="L262">        MiscDebug.writeHullImages(img1Grey, hulls1, &quot;1_binned_hulls&quot;);</span>
<span class="fc" id="L263">        MiscDebug.writeHullImages(img2Grey, hulls2, &quot;2_binned_hulls&quot;);</span>
<span class="fc" id="L264">        MiscDebug.writeImage(img1Cp, &quot;1_binned_clr&quot;);</span>
<span class="fc" id="L265">        MiscDebug.writeImage(img2Cp, &quot;2_binned_clr&quot;);</span>
       
        // make corners
        
        if (!performBinning) {
<span class="fc" id="L270">            imageProcessor.blur(img1Grey, 2);</span>
<span class="fc" id="L271">            imageProcessor.blur(img2Grey, 2);</span>
        }
        
<span class="fc" id="L274">        CurvatureScaleSpaceCornerDetector detector = new</span>
            CurvatureScaleSpaceCornerDetector(img1Grey);
<span class="fc" id="L276">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L277">        detector.findCorners();</span>
<span class="fc" id="L278">        PairIntArray corners1 = detector.getCornersInOriginalReferenceFrame();</span>
        
<span class="fc" id="L280">        CurvatureScaleSpaceCornerDetector detector2 = new</span>
            CurvatureScaleSpaceCornerDetector(img2Grey);
<span class="fc" id="L282">        detector2.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L283">        detector2.findCorners();</span>
<span class="fc" id="L284">        PairIntArray corners2 = detector2.getCornersInOriginalReferenceFrame();</span>
        
<span class="fc" id="L286">        log.info(&quot;n1Corners=&quot; + corners1.getN() + &quot; n2Corners2=&quot; </span>
<span class="fc" id="L287">            + corners2.getN());</span>
        
        // experimenting with a slightly different definition for theta:
<span class="fc" id="L290">        GreyscaleImage theta1360 = imageProcessor.computeTheta360(</span>
<span class="fc" id="L291">            detector.getEdgeFilterProducts().getGradientX(), </span>
<span class="fc" id="L292">            detector.getEdgeFilterProducts().getGradientY());</span>
<span class="fc" id="L293">        GreyscaleImage theta2360 = imageProcessor.computeTheta360(</span>
<span class="fc" id="L294">            detector2.getEdgeFilterProducts().getGradientX(), </span>
<span class="fc" id="L295">            detector2.getEdgeFilterProducts().getGradientY());</span>
<span class="fc" id="L296">        MiscDebug.writeImage(theta1360, &quot;1_theta360&quot;);</span>
<span class="fc" id="L297">        MiscDebug.writeImage(theta2360, &quot;2_theta360&quot;);</span>

        
        //log.info(&quot;corners1=&quot; + corners1.toString());
        //log.info(&quot;corners2=&quot; + corners2.toString());

<span class="fc" id="L303">        MiscDebug.plotCorners(img1Grey, corners1, &quot;1_corners&quot;);</span>
<span class="fc" id="L304">        MiscDebug.plotCorners(img2Grey, corners2, &quot;2_corners&quot;);</span>
        
        /*
        If make an assumption that the histogram equalization and then color
        segmentation leaves the images in consistent state w.r.t. similar 
        colors and intensities being displayed similarly, then selection of
        blobs in this way should lead to comparable lists (which are
        subsets of the total, that is the blobs found for intensity level i0
        in image 1 are the ones to match to similar intensity level in image 2).
        
        Using the blobs, that is the hulls above, has reduced the number of
        regions to compare.
        
        Using the centroids of the blobs is appealling, but these will likely
        be in regions free of large gradients so are difficult to distinguish.
        
        Corners filtered to be only those that cross those blob hulls, however,
        should be good features to use.
        
        The problem is that the corners filtered to those lists are still too
        many to use pairwise transformation calculation from every possible
        pair (the process is approx n^4).
        
        So feature matching using patches surrounding the corners is needed and 
        this is an N^2 process but accompanied by many steps for the comparisons.
        
        Note that feature matching instead of straight pairwise transformation
        calculation unfortunately needs an assumption made about the
        scale.
        
        TODO: For sets with &lt; a dozen or two dozen members each, could 
        consider using pairwise calculation checked by feature matches.
        
        TODO: refactor to be able to use gaussian pyramids if scale=1 is not
              known, then fit to find scale (for sets with large number of members).
             see Lindenberg 1998 and Lowe 2004
        */
        
<span class="fc" id="L342">        List&lt;PairIntArray&gt; filteredCornersList1 = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc" id="L343">        List&lt;PairIntArray&gt; filteredCornersList2 = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc" id="L344">        filterCornersAndOrderByMatchingIntensity(</span>
            corners1, hulls1,
            corners2, hulls2, 
            filteredCornersList1, filteredCornersList2);
        
<span class="fc" id="L349">        boolean useFiltered = true;</span>
        
<span class="fc" id="L351">        int nFiltered1Tot = 0;</span>
<span class="fc" id="L352">        int nFiltered2Tot = 0;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        for (PairIntArray p : filteredCornersList1) {</span>
<span class="fc" id="L354">            nFiltered1Tot += p.getN();</span>
<span class="fc" id="L355">        }</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        for (PairIntArray p : filteredCornersList2) {</span>
<span class="fc" id="L357">            nFiltered2Tot += p.getN();</span>
<span class="fc" id="L358">        }</span>
        
<span class="pc bpc" id="L360" title="2 of 4 branches missed.">        if ((nFiltered1Tot &lt; 12) || (nFiltered2Tot &lt; 12)) {</span>
<span class="nc" id="L361">            useFiltered = false;</span>
        }
        
        /*
        use feature description to find similar looking features within
        image2 filtered corners.
        */
        
        /*
        key = intensity level of image 1 contiguous region
        value = map with
                key = point in filteredCorners1
                value = list of similar looking points in filteredCorners2
                        for the same intensity level.
        */
        
<span class="fc" id="L377">        List&lt;Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt;&gt; similarCorners</span>
            = new ArrayList&lt;Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt;&gt;();
        
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (useFiltered) {</span>
            
<span class="fc bfc" id="L382" title="All 2 branches covered.">            for (int i = 0; i &lt; filteredCornersList1.size(); ++i) {</span>
                // sets with keys pixValue1 and pixValues should hold common blobs
                // and details
<span class="fc" id="L385">                PairIntArray filtered1 = filteredCornersList1.get(i);</span>
<span class="fc" id="L386">                PairIntArray filtered2 = filteredCornersList2.get(i);</span>

<span class="fc" id="L388">                log.info(&quot;nFiltered1=&quot; + filtered1.getN());</span>
<span class="fc" id="L389">                log.info(&quot;nFiltered2=&quot; + filtered2.getN());</span>

<span class="fc" id="L391">                log.info(&quot;filtered1=&quot; + filtered1.toString());</span>
<span class="fc" id="L392">                log.info(&quot;filtered2=&quot; + filtered2.toString());</span>

<span class="fc" id="L394">                MiscDebug.plotCorners(img1Grey, filtered1, &quot;1_&quot; + i + &quot;_filtered&quot;);</span>
<span class="fc" id="L395">                MiscDebug.plotCorners(img2Grey, filtered2, &quot;2_&quot; + i + &quot;_filtered&quot;);</span>

<span class="fc" id="L397">                Set&lt;CornerRegion&gt; cornerRegions1 = </span>
<span class="fc" id="L398">                    detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);</span>
<span class="fc" id="L399">                CornerRegion[] cr1 = findCornerRegions(filtered1, cornerRegions1);</span>
<span class="fc" id="L400">                Set&lt;CornerRegion&gt; cornerRegions2 = </span>
<span class="fc" id="L401">                    detector2.getEdgeCornerRegionsInOriginalReferenceFrame(true);</span>
<span class="fc" id="L402">                CornerRegion[] cr2 = findCornerRegions(filtered2, cornerRegions2);</span>
                
                //log.info(&quot;corner region1:&quot;);
                //MiscDebug.printCornerRegion(cr1);
                //log.info(&quot;corner region2:&quot;);
                //MiscDebug.printCornerRegion(cr2);
                /*
                Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; similar = 
                    findSimilarFeatures(
                        img1Cp, detector.getGradientXY(), theta1360, cr1,
                        img2Cp, detector2.getGradientXY(), theta2360, cr2
                    );
                    findSimilarFeatures(img1Cp, 
                        img2Cp, filtered1, filtered2);

                similarCorners.add(similar);*/
            }
            
        } else {
            
<span class="nc" id="L422">            Set&lt;CornerRegion&gt; cornerRegions1 = </span>
<span class="nc" id="L423">                detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);</span>
<span class="nc" id="L424">            CornerRegion[] cr1 = findCornerRegions(corners1, cornerRegions1);</span>
<span class="nc" id="L425">            Set&lt;CornerRegion&gt; cornerRegions2 = </span>
<span class="nc" id="L426">                detector2.getEdgeCornerRegionsInOriginalReferenceFrame(true);</span>
<span class="nc" id="L427">            CornerRegion[] cr2 = findCornerRegions(corners2, cornerRegions2);</span>
            
            /*
            Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; similar = 
                findSimilarFeatures(
                    img1Cp, detector.getGradientXY(), theta1360, cr1,
                    img2Cp, detector2.getGradientXY(), theta2360, cr2);
                //findSimilarFeatures(img1Cp, img2Cp, corners1, corners2);

            similarCorners.add(similar);*/
        }
        
if (true) {
<span class="fc" id="L440">    return null;</span>
}        
        
        /*
        if need to calculate for all hull centroids, can use the rotation 
        and translation grid based search followed by downhill simplex:
        
        boolean useGreedyMatching = true;
        boolean searchScaleToo = true;
        float scale = 1;
        TransformationPointFit[] starterPoints = pointMatcher.preSearch0Small(
            allHullCentroids1, allHullCentroids2, scale,
            0, 359, useGreedyMatching);
        TransformationPointFit[] fits2 =
            pointMatcher.refineTransformationWithDownhillSimplexWrapper(
            starterPoints, allHullCentroids1, allHullCentroids2, searchScaleToo, 
            useGreedyMatching);
        
        log.info(&quot;fit3=&quot; + fits2[0].toString());
        */
        
        TransformationPointFit bestFit00 = null;

        float toleranceTransX = 20;//30;
        float toleranceTransY = toleranceTransX;
        boolean useGreedyMatching = true;
        boolean earlyConvergeReturn = true;
        boolean setsAreMatched = false;
        
        log.info(&quot;nAllHulls1=&quot; + allHullCentroids1.getN() 
            + &quot; nAllHulls2=&quot; + allHullCentroids2.getN());
        
        PointMatcher pointMatcher = new PointMatcher();
        
        if ((bestFit00 == null) ||
            (((float)bestFit00.getNumberOfMatchedPoints()
            /(float)bestFit00.getNMaxMatchable()) &lt; 0.5)) {
                        
            // unfortunately, the quicker solution didn't work so need to try
            // to solve it using all corners (though the internal implementation
            // does not try all permutations).
            
            long t0 = System.currentTimeMillis();
            List&lt;TransformationPointFit&gt; fits
                = pointMatcher.calculateEuclideanTransformationUsingPairs(
                    corners1, corners2, toleranceTransX, toleranceTransY,
                    earlyConvergeReturn, useGreedyMatching);
            long t1 = System.currentTimeMillis();
            log.info(&quot;calculateEuclideanTransformationUsingPairs seconds=&quot;
                + ((t1 - t0) * 1e-3));
            
            // the evaluation has already been tried against all corners
            // so only need to compare the fits.
            
            // this finds best that is usually a scale that is not 1, so
            // if one knows that the scale should be '1', should use the
            // method that solves mostly vertical transformations specifically
            
            for (TransformationPointFit fit : fits) {
                if (pointMatcher.fitIsBetter(bestFit00, fit)) {
                    bestFit00 = fit;
                }
            }
            log.info(&quot;best from all corners=&quot; + bestFit00.toString());
        }
        
        // refine the solution 
        float rotHalfRangeInDegrees = 20;
        float rotDeltaInDegrees = 2;
        float transXHalfRange = 40; 
        float transXDelta = 4;
        float transYHalfRange = transXHalfRange; 
        float transYDelta = transXDelta;
        
        long t0 = System.currentTimeMillis();
        TransformationPointFit bestFit = pointMatcher.refineTheTransformation(
            bestFit00.getParameters(), corners1, corners2,
            rotHalfRangeInDegrees, rotDeltaInDegrees,
            transXHalfRange, transXDelta,
            transYHalfRange, transYDelta,
            useGreedyMatching);
        long t1 = System.currentTimeMillis();
        
        log.info(((t1-t0)*1e-3) + &quot;seconds) refined solution=&quot; + bestFit.toString());
        
        //TODO: use the transformation to make matching corner lists, 
        //   perhaps from larger images
        
        return bestFit;
    }

    private Map&lt;Integer, PairIntArray&gt; filterToHulls(PairIntArray corners, 
        Map&lt;Integer, List&lt;GrahamScan&gt;&gt; hulls) {
        
<span class="fc" id="L534">        PointInPolygon poly = new PointInPolygon();</span>
        
<span class="fc" id="L536">        Map&lt;Integer, PairIntArray&gt; filteredCorners = new HashMap&lt;Integer, PairIntArray&gt;();</span>
                
<span class="fc bfc" id="L538" title="All 2 branches covered.">        for (Entry&lt;Integer, List&lt;GrahamScan&gt;&gt; entry : hulls.entrySet()) {</span>
            
<span class="fc" id="L540">            Integer pixValue = entry.getKey();</span>
            
<span class="fc" id="L542">            List&lt;GrahamScan&gt; hullList = entry.getValue();</span>
           
<span class="fc" id="L544">            Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
            
<span class="fc" id="L546">            PairIntArray cornersH = new PairIntArray();</span>
            
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (GrahamScan scan : hullList) {</span>
                
<span class="fc bfc" id="L550" title="All 2 branches covered.">                for (int i = 0; i &lt; corners.getN(); ++i) {</span>
                    
<span class="fc" id="L552">                    int x = corners.getX(i);</span>
<span class="fc" id="L553">                    int y = corners.getY(i);</span>
                    
<span class="fc" id="L555">                    PairInt p = new PairInt(x, y);</span>
                    
<span class="fc bfc" id="L557" title="All 2 branches covered.">                    if (added.contains(p)) {</span>
<span class="fc" id="L558">                        continue;</span>
                    }
                    
<span class="fc bfc" id="L561" title="All 2 branches covered.">                    if (poly.isInSimpleCurve(x, y, scan.getXHull(), </span>
<span class="fc" id="L562">                        scan.getYHull(), scan.getXHull().length)) {</span>
                        
<span class="fc" id="L564">                        cornersH.add(x, y);</span>
<span class="fc" id="L565">                        added.add(p);</span>
                    } else {
<span class="fc bfc" id="L567" title="All 2 branches covered.">                        for (int ii = 0; ii &lt; scan.getXHull().length; ++ii) {</span>
<span class="fc" id="L568">                            float diffX = Math.abs(x - scan.getXHull()[ii]);</span>
<span class="fc" id="L569">                            float diffY = Math.abs(y - scan.getYHull()[ii]);</span>
<span class="fc bfc" id="L570" title="All 4 branches covered.">                            if (diffX &lt; 2 &amp;&amp; diffY &lt; 2) {</span>
<span class="fc" id="L571">                                cornersH.add(x, y);</span>
<span class="fc" id="L572">                                added.add(p);</span>
<span class="fc" id="L573">                                break;</span>
                            }
                        }
                    }
                }
<span class="fc" id="L578">            }</span>
        
            // because convex hulls are used, there may be some points that are
            // in more than one map entry
<span class="fc" id="L582">            filteredCorners.put(pixValue, cornersH);</span>
<span class="fc" id="L583">        }</span>
        
<span class="fc" id="L585">        return filteredCorners;</span>
    }

    protected void filterCornersAndOrderByMatchingIntensity(
        PairIntArray corners1, Map&lt;Integer, List&lt;GrahamScan&gt;&gt; hulls1, 
        PairIntArray corners2, Map&lt;Integer, List&lt;GrahamScan&gt;&gt; hulls2, 
        List&lt;PairIntArray&gt; outputFilteredCornersList1, 
        List&lt;PairIntArray&gt; outputFilteredCornersList2) {
        
<span class="fc" id="L594">        Map&lt;Integer, PairIntArray&gt; filteredCorners1 = filterToHulls(</span>
            corners1, hulls1);
        
<span class="fc" id="L597">        Map&lt;Integer, PairIntArray&gt; filteredCorners2 = filterToHulls(</span>
            corners2, hulls2);
        
<span class="fc" id="L600">        Set&lt;Integer&gt; matchedFilter2Keys = new HashSet&lt;Integer&gt;();</span>
        
        // iterate over intensity keys to find the closest matching in intensities
        // to compare those lists
<span class="fc bfc" id="L604" title="All 2 branches covered.">        for (Entry&lt;Integer, PairIntArray&gt; entry : filteredCorners1.entrySet()) {</span>
            
<span class="fc" id="L606">            Integer pixValue1 = entry.getKey();</span>
            
            // find the closest value to it in the image2 map.  should be very
            // similar if image content is similar and pre-processing the same.
            // else, may need to use allHullCentroids1 and allHullCentroids2
            // in one calculation
            
<span class="fc" id="L613">            Integer pixValue2 = null;</span>
<span class="fc" id="L614">            Iterator&lt;Entry&lt;Integer, PairIntArray&gt;&gt; iter = </span>
<span class="fc" id="L615">                filteredCorners2.entrySet().iterator();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L617">                Integer pV = iter.next().getKey();</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                if (matchedFilter2Keys.contains(pV)) {</span>
<span class="fc" id="L619">                    continue;</span>
                }
<span class="fc bfc" id="L621" title="All 2 branches covered.">                if (pixValue2 == null) {</span>
<span class="fc" id="L622">                    pixValue2 = pV;</span>
                } else {
<span class="fc" id="L624">                    int diff = Math.abs(pixValue1.intValue() - pixValue2.intValue());</span>
<span class="fc" id="L625">                    int diffV = Math.abs(pV.intValue() - pixValue2.intValue());</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">                    if (diffV &lt; diff) {</span>
<span class="fc" id="L627">                        pixValue2 = pV;</span>
                    }
                }
<span class="fc" id="L630">            }</span>
            
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            if (pixValue2 == null) {</span>
<span class="nc" id="L633">                continue;</span>
            }
<span class="fc" id="L635">            matchedFilter2Keys.add(pixValue2);</span>
            
            // sets with keys pixValue1 and pixValues should hold common blobs
            // and details
<span class="fc" id="L639">            PairIntArray filtered1 = entry.getValue();</span>
<span class="fc" id="L640">            PairIntArray filtered2 = filteredCorners2.get(pixValue2);</span>
            
<span class="fc" id="L642">            outputFilteredCornersList1.add(filtered1);</span>
<span class="fc" id="L643">            outputFilteredCornersList2.add(filtered2);</span>
<span class="fc" id="L644">        }</span>
        
<span class="fc" id="L646">    } </span>

    private CornerRegion[] findCornerRegions(PairIntArray corners, 
        Set&lt;CornerRegion&gt; cornerRegions) {
        
<span class="fc" id="L651">        int n = corners.getN();</span>
        
<span class="fc" id="L653">        CornerRegion[] out = new CornerRegion[n];</span>
        
<span class="fc bfc" id="L655" title="All 2 branches covered.">        for (int i = 0; i &lt; corners.getN(); ++i) {</span>
            
<span class="fc" id="L657">            int x = corners.getX(i);</span>
<span class="fc" id="L658">            int y = corners.getY(i);</span>
            
<span class="fc" id="L660">            CornerRegion cr = null;</span>
<span class="fc" id="L661">            int diffSqMin = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">            for (CornerRegion cornerRegion : cornerRegions) {</span>
<span class="fc" id="L663">                int kMaxIdx = cornerRegion.getKMaxIdx();</span>
<span class="fc" id="L664">                int xcr = cornerRegion.getX()[kMaxIdx];</span>
<span class="fc" id="L665">                int ycr = cornerRegion.getY()[kMaxIdx];</span>
<span class="fc" id="L666">                int diffX = Math.abs(xcr - x);</span>
<span class="fc" id="L667">                int diffY = Math.abs(ycr - y);</span>
<span class="fc bfc" id="L668" title="All 4 branches covered.">                if (diffX &gt; 4 || diffY &gt; 4) {</span>
<span class="fc" id="L669">                    continue;</span>
                }
<span class="fc" id="L671">                int diffSq = diffX * diffX + diffY * diffY;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                if (diffSq &lt; diffSqMin) {</span>
<span class="fc" id="L673">                    diffSqMin = diffSq;</span>
<span class="fc" id="L674">                    cr = cornerRegion;</span>
                }
<span class="fc" id="L676">            }</span>
            
<span class="fc" id="L678">            out[i] = cr ;</span>
        }
        
<span class="fc" id="L681">        return out;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Features.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">Features.java</span></div><h1>Features.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.AngleUtil;
import algorithms.util.PairInt;
import java.util.HashMap;
import java.util.Map;

/**
 * NOT READY FOR USE.  NOT TESTED YET.
 * class to help extract and reuse feature descriptors.
 * @author nichole
 */
public class Features extends IntensityFeatures {

    /**
     * the gradient image of gsImg or clrImg.
     */
    protected final GreyscaleImage gradientImg;

    /**
     * the gradient orientation image
     */
    protected final GreyscaleImage thetaImg;

    //TODO: add this to a setter:
<span class="fc" id="L26">    protected final Image clrGradientImg = null;</span>

    // can use as false with bHalfW=5
<span class="fc" id="L29">    protected final boolean useBinnedCellGradients = true;</span>

    /*
    for theta descriptors, 1 of 3 choices:
       (1) PixelThetaDescriptor: each pixel in 5x5 block stored.
           comparion is pixel by pixel angular differences
       (2) PixelThetaDescriptor: pixels binned into 2x2 cells and 16 total
           surrounding the center.
           comparison is item by item angular differences
       (3) HistogramThetaDescriptor: pixels within mxm cells are made into
           histograms of w bin width, and 8 or 16 such cells surrounding the
           center.
           each histogram before compared is normalized by peak?
           corrections for wrap around during comparisons?
           comparisons are then similar to SSD?

       Note that use of (1) does not have S/N correction and it requires
       very good rotation alignment to achieve reasonable results, so the
       &quot;dominant orientation&quot; as a stable relative angle for comparing frames
       would need a refinement such as trying small degrees around it within
       a range to find best match for better use of (1).
    */
<span class="fc" id="L51">    protected final int thetaType = 2;</span>

    /**
    key = pixel coordinates of center of frame;
    value = map with key = rotation (in degrees) of the frame and value = the
    *     extracted descriptor
    */
<span class="fc" id="L58">    protected Map&lt;PairInt, Map&lt;Integer, GradientDescriptor&gt;&gt; gradientBlocks =</span>
        new HashMap&lt;PairInt, Map&lt;Integer, GradientDescriptor&gt;&gt;();

    /**
    key = pixel coordinates of center of frame;
    value = map with key = rotation (in degrees) of the frame and value = the
    *     extracted descriptor
    */
<span class="fc" id="L66">    protected Map&lt;PairInt, Map&lt;Integer, ThetaDescriptor&gt;&gt; thetaBlocks =</span>
        new HashMap&lt;PairInt, Map&lt;Integer, ThetaDescriptor&gt;&gt;();

    /**
     *
     * @param image
     * @param theGradientImg gradient image of the image region (usually
     * from the process of creating corners).
     * @param theThetaImg the gradient orientation angle image
     * @param blockHalfWidths the half width of a block.  For example, to
     * extract the 25 pixels centered on (xc, yc), bHalfW would be '2'
     * @param useNormalizedIntensities normalize the intensities extracted
     * from image if true (NOT YET IMPLEMENTED)
     */
    public Features(final GreyscaleImage image, final GreyscaleImage theGradientImg,
        final GreyscaleImage theThetaImg, final int blockHalfWidths,
        final boolean useNormalizedIntensities) {

<span class="fc" id="L84">        super(image, blockHalfWidths, useNormalizedIntensities);</span>
        
<span class="fc" id="L86">        this.gradientImg = theGradientImg;</span>
<span class="fc" id="L87">        this.thetaImg = theThetaImg;</span>
<span class="fc" id="L88">    }</span>

    /**
     *
     * @param image
     * @param theGradientImg gradient image of the image region (usually
     * from the process of creating corners).
     * @param theThetaImg the gradient orientation angle image
     * @param blockHalfWidths the half width of a block.  For example, to
     * extract the 25 pixels centered on (xc, yc), bHalfW would be '2'
     * @param useNormalizedIntensities normalize the intensities extracted
     * from image if true (NOT YET IMPLEMENTED)
     */
    public Features(final Image image, final GreyscaleImage theGradientImg,
        final GreyscaleImage theThetaImg, final int blockHalfWidths,
        final boolean useNormalizedIntensities) {

<span class="fc" id="L105">        super(image, blockHalfWidths, useNormalizedIntensities);</span>
        
<span class="fc" id="L107">        this.gradientImg = theGradientImg;</span>
<span class="fc" id="L108">        this.thetaImg = theThetaImg;</span>
<span class="fc" id="L109">    }</span>

    /**
     *
     * @param xCenter
     * @param yCenter
     * @param rotation dominant orientation in degrees for feature at
     * (xCenter, yCenter)
     * @return descriptor holding gradient rotated.  NOTE that the method may
     * return null if ant part of the center coordinate cell was was rotated
     * out of the frame.
     */
    public GradientDescriptor extractGradient(int xCenter, int yCenter,
        int rotation) {

<span class="fc" id="L124">        checkBounds(xCenter, yCenter);</span>

<span class="fc" id="L126">        PairInt p = new PairInt(xCenter, yCenter);</span>

<span class="fc" id="L128">        Integer rotKey = Integer.valueOf(rotation);</span>

<span class="fc" id="L130">        Map&lt;Integer, GradientDescriptor&gt; descriptors = gradientBlocks.get(p);</span>

<span class="fc" id="L132">        GradientDescriptor descriptor = null;</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (descriptors != null) {</span>
<span class="fc" id="L135">            descriptor = descriptors.get(rotKey);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (descriptor != null) {</span>
<span class="fc" id="L137">                return descriptor;</span>
            }
        } else {
<span class="fc" id="L140">            descriptors = new HashMap&lt;Integer, GradientDescriptor&gt;();</span>
<span class="fc" id="L141">            gradientBlocks.put(p, descriptors);</span>
        }

        if (useBinnedCellGradients) {
<span class="fc" id="L145">            descriptor = extractGsGradientForCells(xCenter, yCenter, rotation);</span>
        } else {
            descriptor = extractGsGradientForBlock(xCenter, yCenter, rotation);
        }

<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (descriptor != null) {</span>
<span class="fc" id="L151">            descriptors.put(rotKey, descriptor);</span>
        }

<span class="fc" id="L154">        return descriptor;</span>
    }

    /**
     * extract theta orientation from the image for (xCenter, yCenter) and
     * return it in a descriptor.
     * @param xCenter
     * @param yCenter
     * @param rotation dominant orientation in degrees for feature at
     * (xCenter, yCenter)
     * @return descriptor for theta extracted from the image.  NOTE that this
     * method may return null if the (xCenter, yCenter) frame is rotated in
     * part out of the frame.
     */
    public ThetaDescriptor extractTheta(final int xCenter, final int yCenter,
        final int rotation) {

<span class="fc" id="L171">        checkBounds(xCenter, yCenter);</span>

<span class="fc" id="L173">        PairInt p = new PairInt(xCenter, yCenter);</span>

<span class="fc" id="L175">        Integer rotationKey = Integer.valueOf(rotation);</span>

<span class="fc" id="L177">        Map&lt;Integer, ThetaDescriptor&gt; descriptors = thetaBlocks.get(p);</span>

<span class="fc" id="L179">        ThetaDescriptor descriptor = null;</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (descriptors != null) {</span>
<span class="fc" id="L182">            descriptor = descriptors.get(rotationKey);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (descriptor != null) {</span>
<span class="fc" id="L184">                return descriptor;</span>
            }
        } else {
<span class="fc" id="L187">            descriptors = new HashMap&lt;Integer, ThetaDescriptor&gt;();</span>
<span class="fc" id="L188">            thetaBlocks.put(p, descriptors);</span>
        }

        /*
        this will be one of 3 types of theta descriptors and the
        choice will be set in constructor
        */

<span class="fc" id="L196">        descriptor = extractThetaForType(xCenter, yCenter, rotation);</span>

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (descriptor != null) {</span>
<span class="fc" id="L199">            descriptors.put(rotationKey, descriptor);</span>
        }

<span class="fc" id="L202">        return descriptor;</span>
    }

    private GradientDescriptor extractGsGradientForBlock(int xCenter,
        int yCenter, int rotation) {

<span class="nc" id="L208">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L210">        float[][] frameOffsets = transformer.transformXY(rotation, xyOffsets);</span>

<span class="nc" id="L212">        GradientDescriptor descriptor = null;</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (gradientImg != null) {</span>
<span class="nc" id="L215">            descriptor = extractGsGradientForBlock(xCenter, yCenter,</span>
                frameOffsets);
        } /*else {
            descriptor = extractClrGradientForBlock(xCenter, yCenter,
                frameOffsets);
        }*/

<span class="nc" id="L222">        return descriptor;</span>
    }

    private ThetaDescriptor extractThetaForType(int xCenter,
        int yCenter, int rotation) {

<span class="fc" id="L228">        Transformer transformer = new Transformer();</span>

<span class="fc" id="L230">        float[][] frameOffsets = transformer.transformXY(rotation, xyOffsets);</span>

<span class="fc" id="L232">        ThetaDescriptor descriptor = null;</span>

        if (thetaType == 1) {
            GradientDescriptor gradDesc = null;
            if (useBinnedCellGradients) {
                gradDesc = extractGsGradientForCells(xCenter, yCenter, rotation);
            } else {
                gradDesc = extractGradient(xCenter, yCenter, rotation);
            }
            if (gradDesc == null) {
                return null;
            }
            descriptor = extractThetaForBlock(gradDesc, xCenter, yCenter,
                rotation, frameOffsets);
        } else if (thetaType == 2) {
<span class="fc" id="L247">            descriptor = extractThetaForCells(xCenter, yCenter, rotation);</span>
        } else if (thetaType == 3) {
            throw new UnsupportedOperationException(&quot;not yet implemented&quot;);
            //descriptor = extractThetaHistograms(xCenter, yCenter, rotation);
        }

<span class="fc" id="L253">        return descriptor;</span>
    }

    /**
     * extract theta orientation for the (xCenter, yCenter) region
     * and place in the descriptor.
     * Note that if the transformed pixel is out of bounds of the image,
     * a sentinel is the value for that location in the descriptor.
     * @param xCenter
     * @param yCenter
     * @param rotation
     * @return
     */
    private ThetaDescriptor extractThetaForBlock(GradientDescriptor gradientDesc,
        int xCenter, int yCenter, int rotation, float[][] offsets) {

<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (gradientDesc == null) {</span>
<span class="nc" id="L270">            throw new IllegalArgumentException(&quot;gradientDesc cannot be null&quot;);</span>
        }

<span class="nc" id="L273">        int centralPixelIndex = offsets.length &gt;&gt; 1;</span>

<span class="nc" id="L275">        int[] output = new int[offsets.length];</span>

<span class="nc" id="L277">        int sentinel = PixelThetaDescriptor.sentinel;</span>

<span class="nc" id="L279">        int count = 0;</span>

<span class="nc" id="L281">        int maxGradient = gradientDesc.getMaximum();</span>

<span class="nc" id="L283">        float limitGradient = 0.1f * maxGradient;</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">        for (int i = 0; i &lt; offsets.length; ++i) {</span>

<span class="nc" id="L287">            float x1P = xCenter + offsets[i][0];</span>

<span class="nc" id="L289">            float y1P = yCenter + offsets[i][1];</span>

<span class="nc bnc" id="L291" title="All 6 branches missed.">            if ((x1P &lt; 0) || (Math.ceil(x1P) &gt; (thetaImg.getWidth() - 1)) ||</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                (y1P &lt; 0) || (Math.ceil(y1P) &gt; (thetaImg.getHeight() - 1))) {</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">                if (count == centralPixelIndex) {</span>
<span class="nc" id="L295">                    return null;</span>
                }
<span class="nc" id="L297">                output[count] = sentinel;</span>

            } else {

<span class="nc" id="L301">                double gradV = gradientImg.getValue(Math.round(x1P), Math.round(y1P));</span>
<span class="nc" id="L302">                int gradientV = ((GsGradientDescriptor)gradientDesc).grey[count];</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (gradV &lt; limitGradient) {</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">                    if (count == centralPixelIndex) {</span>
                        // warning, S/N is too low to calc auto-correlation error
                        // and algorithm will find a neaighbor to use instead
                    }

<span class="nc" id="L311">                    output[count] = sentinel;</span>

                } else {

                    //non-adaptive algorithms: nearest neighbor or bilinear

                    // bilinear: (needs to be adapted for angular addition)
                    //double v = imageProcessor.biLinearInterpolation(thetaImg, x1P, y1P);

                    // nearest neighbor
<span class="nc" id="L321">                    double v = thetaImg.getValue(Math.round(x1P), Math.round(y1P));</span>

                    // subtract &quot;dominant orientation&quot;
<span class="nc" id="L324">                    v -= rotation;</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">                    if (v &gt;= 360) {</span>
<span class="nc" id="L327">                        v = v % 360;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                    } else if (v &lt; 0) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">                        while (v &lt; 0) {</span>
<span class="nc" id="L330">                            v += 360;</span>
                        }
                    }

<span class="nc" id="L334">                    output[count] = (int)Math.round(v);</span>
                }
            }

<span class="nc" id="L338">            count++;</span>
        }

<span class="nc" id="L341">        ThetaDescriptor desc = new PixelThetaDescriptor(output,</span>
            offsets.length &gt;&gt; 1);

<span class="nc" id="L344">        return desc;</span>
    }

    /**
     * extract from the image and place in the descriptor.
     * Note that if the transformed pixel is out of bounds of the image,
     * a sentinel is the value for that location in the descriptor.
     * @param xCenter
     * @param yCenter
     * @param rotation
     * @return
     */
    private GradientDescriptor extractGsGradientForBlock(int xCenter,
        int yCenter, float[][] offsets) {

<span class="nc" id="L359">        int sentinel = GsGradientDescriptor.sentinel;</span>

<span class="nc" id="L361">        int[] output = new int[offsets.length];</span>

<span class="nc" id="L363">        int count = 0;</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">        for (int i = 0; i &lt; offsets.length; ++i) {</span>

<span class="nc" id="L367">            float x1P = xCenter + offsets[i][0];</span>

<span class="nc" id="L369">            float y1P = yCenter + offsets[i][1];</span>

<span class="nc bnc" id="L371" title="All 6 branches missed.">            if ((x1P &lt; 0) || (Math.ceil(x1P) &gt; (gradientImg.getWidth() - 1)) ||</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                (y1P &lt; 0) || (Math.ceil(y1P) &gt; (gradientImg.getHeight() - 1))) {</span>

<span class="nc" id="L374">                output[count] = sentinel;</span>

            } else {

                //non-adaptive algorithms: nearest neighbor or bilinear

                // bilinear:
                //double v = imageProcessor.biLinearInterpolation(gradientImg, x1P, y1P);

                // nearest neighbor
<span class="nc" id="L384">                double v = gradientImg.getValue(Math.round(x1P), Math.round(y1P));</span>

<span class="nc" id="L386">                output[count] = (int)Math.round(v);</span>
            }

<span class="nc" id="L389">            count++;</span>
        }

<span class="nc" id="L392">        GradientDescriptor desc = new GsGradientDescriptor(output,</span>
            offsets.length &gt;&gt; 1);

<span class="nc" id="L395">        return desc;</span>
    }

    /**
     * extract the gradient from the image in 2X2 cells surrounding
     * (xCenter, yCenter) for 16 cells.
     * @param xCenter
     * @param yCenter
     * @param rotation
     * @return
     */
    private GradientDescriptor extractGsGradientForCells(int xCenter,
        int yCenter, int rotation) {

        /*
          3 [-][-][.][.][-][-][.][.]
          2 [-][-][.][.][-][-][.][.]
          1 [.][.][-][-][.][.][-][-]
          0 [.][.][-][-] @ [.][-][-]
         -1 [-][-][.][.][-][-][.][.]
         -2 [-][-][.][.][-][-][.][.]
         -3 [.][.][-][-][.][.][-][-]
         -4 [.][.][-][-][.][.][-][-]
            -4 -3 -2 -1  0  1  2  3

          3
          2  3     7    11     15
          1
          0  2     6   10@     14
         -1
         -2  1     5     9     13
         -3
         -4  0     4     8     12
            -4 -3 -2 -1  0  1  2  3
        */

<span class="fc" id="L431">        int sentinel = GsGradientDescriptor.sentinel;</span>

<span class="fc" id="L433">        int cellDim = 2;</span>
<span class="fc" id="L434">        int nCellsAcross = 6;</span>
<span class="fc" id="L435">        int range0 = (int)(cellDim * ((float)nCellsAcross/2.f));</span>

<span class="fc" id="L437">        int nColsHalf = (nCellsAcross/2);</span>
<span class="fc" id="L438">        int centralPixelIndex = (nColsHalf * nCellsAcross) + nColsHalf;</span>
        
<span class="fc" id="L440">        int[] output = new int[nCellsAcross * nCellsAcross];</span>
<span class="fc" id="L441">        float[] xT = new float[cellDim * cellDim];</span>
<span class="fc" id="L442">        float[] yT = new float[xT.length];</span>

<span class="fc" id="L444">        int count = 0;</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        for (int dx = -range0; dx &lt; range0; dx+=cellDim) {</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">            for (int dy = -range0; dy &lt; range0; dy+=cellDim) {</span>

                // --- calculate values for the cell ---
<span class="fc" id="L449">                boolean withinBounds = transformCellCoordinates(</span>
                    rotation, xCenter, yCenter, dx, dy, cellDim, 
<span class="fc" id="L451">                    gradientImg.getWidth(), gradientImg.getHeight(),</span>
                    xT, yT);

<span class="fc bfc" id="L454" title="All 2 branches covered.">                if (!withinBounds) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                    if (count == centralPixelIndex) {</span>
<span class="fc" id="L456">                        return null;</span>
                    }
<span class="fc" id="L458">                    output[count] = sentinel;</span>
<span class="fc" id="L459">                    count++;</span>
<span class="fc" id="L460">                    continue;</span>
                }

<span class="fc" id="L463">                int cCount = 0;</span>
<span class="fc" id="L464">                int v = 0;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                for (int i = 0; i &lt; xT.length; ++i) {</span>
<span class="fc" id="L466">                    int x = Math.round(xT[i]);</span>
<span class="fc" id="L467">                    int y = Math.round(yT[i]);</span>
<span class="fc" id="L468">                    v += gradientImg.getValue(x, y);</span>
<span class="fc" id="L469">                    cCount++;</span>
                }

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">                if (cCount == 0) {</span>
<span class="nc" id="L473">                    output[count] = sentinel;</span>
<span class="nc" id="L474">                    count++;</span>
<span class="nc" id="L475">                    continue;</span>
                }

<span class="fc" id="L478">                v /= (float)cCount;</span>

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                if (v &gt; 359) {</span>
<span class="nc" id="L481">                    v = v % 360;</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                } else if (v &lt; 0) {</span>
<span class="nc" id="L483">                    v = v + 360;</span>
                }

<span class="fc" id="L486">                output[count] = v;</span>

<span class="fc" id="L488">                count++;</span>
            }
        }

<span class="fc" id="L492">        GradientDescriptor desc = new GsGradientDescriptor(output,</span>
            centralPixelIndex);

<span class="fc" id="L495">        return desc;</span>
    }
    
    /**
     * extract theta in angular degrees from the image in 2X2 cells surrounding
     * (xCenter, yCenter) for 16 cells, making the value correction for
     * &quot;dominant orientation&quot; too.
     * @param xCenter
     * @param yCenter
     * @param rotation
     * @return descriptor for the region given and orientation given.  NOTE
     * that it can return null if the central region is shifted out of the
     * image frame.  If any other cells excepting the center are shifted
     * out, an object is returned with those cells holding the sentinel as a
     * value (further code interprets those as a skip instruction).
     */
    private ThetaDescriptor extractThetaForCells(int xCenter, int yCenter,
        int rotation) {

        /*
          3 [-][-][.][.][-][-][.][.]
          2 [-][-][.][.][-][-][.][.]
          1 [.][.][-][-][.][.][-][-]
          0 [.][.][-][-] @ [.][-][-]
         -1 [-][-][.][.][-][-][.][.]
         -2 [-][-][.][.][-][-][.][.]
         -3 [.][.][-][-][.][.][-][-]
         -4 [.][.][-][-][.][.][-][-]
            -4 -3 -2 -1  0  1  2  3

          3
          2  3     7    11     15
          1
          0  2     6   10@     14
         -1
         -2  1     5     9     13
         -3
         -4  0     4     8     12
            -4 -3 -2 -1  0  1  2  3
        */

<span class="fc" id="L536">        int sentinel = ThetaDescriptor.sentinel;</span>

<span class="fc" id="L538">        int cellDim = 2;</span>
<span class="fc" id="L539">        int nCellsAcross = 6;</span>
<span class="fc" id="L540">        int range0 = (int)(cellDim * ((float)nCellsAcross/2.f));</span>

<span class="fc" id="L542">        int nColsHalf = (nCellsAcross/2);</span>
<span class="fc" id="L543">        int centralPixelIndex = (nColsHalf * nCellsAcross) + nColsHalf;</span>
        
<span class="fc" id="L545">        int[] output = new int[nCellsAcross * nCellsAcross];</span>
<span class="fc" id="L546">        float[] xT = new float[cellDim * cellDim];</span>
<span class="fc" id="L547">        float[] yT = new float[xT.length];</span>

<span class="fc" id="L549">        int count = 0;</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (int dx = -range0; dx &lt; range0; dx+=cellDim) {</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">            for (int dy = -range0; dy &lt; range0; dy+=cellDim) {</span>

                // --- calculate values for the cell ---
<span class="fc" id="L554">                boolean withinBounds = transformCellCoordinates(</span>
                    rotation, xCenter, yCenter, dx, dy, cellDim, 
<span class="fc" id="L556">                    thetaImg.getWidth(), thetaImg.getHeight(),</span>
                    xT, yT);

<span class="fc bfc" id="L559" title="All 2 branches covered.">                if (!withinBounds) {</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                    if (count == centralPixelIndex) {</span>
<span class="nc" id="L561">                        return null;</span>
                    }
<span class="fc" id="L563">                    output[count] = sentinel;</span>
<span class="fc" id="L564">                    count++;</span>
<span class="fc" id="L565">                    continue;</span>
                }

<span class="fc" id="L568">                int maxGrd = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                for (int i = 0; i &lt; xT.length; ++i) {</span>
<span class="fc" id="L570">                    int x = Math.round(xT[i]);</span>
<span class="fc" id="L571">                    int y = Math.round(yT[i]);</span>
<span class="fc" id="L572">                    int v = gradientImg.getValue(x, y);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                    if (v &gt; maxGrd) {</span>
<span class="fc" id="L574">                        maxGrd = v;</span>
                    }
                }

<span class="fc" id="L578">                float lowLimit = 0.1f * maxGrd;</span>

                /*
                store the image values above the critical limit then
                use angle util to average the values with consideration
                for their quadrants.
                */

<span class="fc" id="L586">                int cCount = 0;</span>

<span class="fc" id="L588">                int[] vs = new int[xT.length];</span>
<span class="fc" id="L589">                int[] gradients = new int[xT.length];</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                for (int i = 0; i &lt; xT.length; ++i) {</span>
<span class="fc" id="L591">                    int x = Math.round(xT[i]);</span>
<span class="fc" id="L592">                    int y = Math.round(yT[i]);</span>
<span class="fc" id="L593">                    int vGradient = gradientImg.getValue(x, y);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                    if (vGradient &lt; lowLimit) {</span>
<span class="fc" id="L595">                        continue;</span>
                    }
<span class="fc" id="L597">                    vs[cCount] = thetaImg.getValue(x, y);</span>
<span class="fc" id="L598">                    gradients[cCount] = vGradient;</span>
<span class="fc" id="L599">                    cCount++;</span>
                }

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                if (cCount == 0) {</span>
<span class="nc" id="L603">                    output[count] = sentinel;</span>
<span class="nc" id="L604">                    count++;</span>
<span class="nc" id="L605">                    continue;</span>
                }
                
                /* 
                using the weighted values reduces the &quot;outlier&quot; differences
                when comparing to another set of cells in other image.
                */

                //runtime complexity for the angular average is about 3 * O(cCount).
                //float avg = AngleUtil.calculateAverageWithQuadrantCorrections(
                //    vs, cCount - 1);

<span class="fc" id="L617">                float avg =</span>
<span class="fc" id="L618">                    AngleUtil.calculateWeightedAverageWithQuadrantCorrections(</span>
                        vs, gradients, cCount - 1);

                // subtract the &quot;dominant orientation&quot;
<span class="fc" id="L622">                avg -= rotation;</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">                if (avg &gt; 359) {</span>
<span class="fc" id="L625">                    avg = avg % 360;</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">                } else if (avg &lt; 0) {</span>
<span class="fc" id="L627">                    avg = avg + 360;</span>
                }

<span class="fc" id="L630">                output[count] = Math.round(avg);</span>

<span class="fc" id="L632">                count++;</span>
            }
        }

<span class="fc" id="L636">        ThetaDescriptor desc = new PixelThetaDescriptor(output,</span>
            centralPixelIndex);

<span class="fc" id="L639">        return desc;</span>
    }

    /**
     * extract the gradient from the image in 2X2 cells surrounding
     * (xCenter, yCenter) for 16 cells.
     * @param xCenter
     * @param yCenter
     * @param rotation
     * @return an instance of ThetaHistogramDescriptor.  Note that it's
     * internal array may contain null values if a cell was out of bounds
     * so any comparison methods should check for null.
     */
    private ThetaDescriptor extractThetaHistograms(int xCenter, int yCenter,
        int rotation) {

        /*
          3 [-][-][.][.][-][-][.][.]
          2 [-][-][.][.][-][-][.][.]
          1 [.][.][-][-][.][.][-][-]
          0 [.][.][-][-] @ [.][-][-]
         -1 [-][-][.][.][-][-][.][.]
         -2 [-][-][.][.][-][-][.][.]
         -3 [.][.][-][-][.][.][-][-]
         -4 [.][.][-][-][.][.][-][-]
            -4 -3 -2 -1  0  1  2  3

          3
          2  3     7    11     15
          1
          0  2     6   10@     14
         -1
         -2  1     5     9     13
         -3
         -4  0     4     8     12
            -4 -3 -2 -1  0  1  2  3
        */

        /*
         theta' histogram is made for each group (subdivisions of the block)
         for n=8 intervals of 45 degrees each.
         group is 4x4... or so.  above, still using 2x2 which would be
         too small for a histogram

         S/N corrections:

         consider discarding values that have gradientXY &lt; critical value
         (suggested as 0.1 * maximum of gradientXY in this cell.  reference?)

         create a weight for each pixel within the 4x4 group based upon the gradient value:
         w[pix] = gXY[pix] / sqrt(sum of squares of gXY[pix] in 4x4 group) + eps)
         where eps is a small number to avoid divide by zero errors

         then the contribution of the pixel to the histogram bin is
         weighted by that value, that is histogram increments are fractional
         not integer.
         (the bin the pixel is placed in is the same, just its contribution
         that is weighted by fraction of total intensity).
        */

<span class="nc" id="L699">        int sentinel = ThetaDescriptor.sentinel;</span>

<span class="nc" id="L701">        int cellDim = 2;</span>
<span class="nc" id="L702">        int nCellsAcross = 6;</span>
<span class="nc" id="L703">        int range0 = (int)(cellDim * ((float)nCellsAcross/2.f));</span>

<span class="nc" id="L705">        int nColsHalf = (nCellsAcross/2);</span>
<span class="nc" id="L706">        int centralPixelIndex = (nColsHalf * nCellsAcross) + nColsHalf;</span>
        
<span class="nc" id="L708">        int nHistBins = 36;</span>
<span class="nc" id="L709">        float binSize = 360.f/(float)nHistBins;</span>

        // TODO: change the output here to be an array of histograms
<span class="nc" id="L712">        float[][] output = new float[nCellsAcross * nCellsAcross][];</span>

<span class="nc" id="L714">        float[] xT = new float[cellDim * cellDim];</span>
<span class="nc" id="L715">        float[] yT = new float[xT.length];</span>

<span class="nc" id="L717">        int count = 0;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        for (int dx = -range0; dx &lt; range0; dx+=cellDim) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            for (int dy = -range0; dy &lt; range0; dy+=cellDim) {</span>

                // --- calculate values for the cell ---
<span class="nc" id="L722">                boolean withinBounds = transformCellCoordinates(</span>
                    rotation, xCenter, yCenter, dx, dy, cellDim, 
<span class="nc" id="L724">                    thetaImg.getWidth(), thetaImg.getHeight(),</span>
                    xT, yT);

<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (!withinBounds) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    if (count == centralPixelIndex) {</span>
<span class="nc" id="L729">                        return null;</span>
                    }
<span class="nc" id="L731">                    output[count] = null;</span>
<span class="nc" id="L732">                    count++;</span>
<span class="nc" id="L733">                    continue;</span>
                }

<span class="nc" id="L736">                int maxGrd = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                for (int i = 0; i &lt; xT.length; ++i) {</span>
<span class="nc" id="L738">                    int x = Math.round(xT[i]);</span>
<span class="nc" id="L739">                    int y = Math.round(yT[i]);</span>
<span class="nc" id="L740">                    int v = gradientImg.getValue(x, y);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                    if (v &gt; maxGrd) {</span>
<span class="nc" id="L742">                        maxGrd = v;</span>
                    }
                }

<span class="nc" id="L746">                float lowLimit = 0.1f*maxGrd;</span>
<span class="nc" id="L747">                int cellGrdSum = 0;</span>
<span class="nc" id="L748">                int cCount = 0;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                for (int i = 0; i &lt; xT.length; ++i) {</span>
<span class="nc" id="L750">                    int x = Math.round(xT[i]);</span>
<span class="nc" id="L751">                    int y = Math.round(yT[i]);</span>
<span class="nc" id="L752">                    int v = gradientImg.getValue(x, y);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                    if (v &lt; lowLimit) {</span>
<span class="nc" id="L754">                        continue;</span>
                    }
<span class="nc" id="L756">                    cellGrdSum += v;</span>
<span class="nc" id="L757">                    cCount++;</span>
                }

<span class="nc bnc" id="L760" title="All 2 branches missed.">                if (cCount == 0) {</span>
<span class="nc" id="L761">                    output[count] = null;</span>
<span class="nc" id="L762">                    count++;</span>
<span class="nc" id="L763">                    continue;</span>
                }

<span class="nc" id="L766">                cCount = 0;</span>

<span class="nc" id="L768">                output[count] = new float[nHistBins];</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">                for (int i = 0; i &lt; xT.length; ++i) {</span>
<span class="nc" id="L771">                    int x = Math.round(xT[i]);</span>
<span class="nc" id="L772">                    int y = Math.round(yT[i]);</span>
<span class="nc" id="L773">                    int vGradient = gradientImg.getValue(x, y);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                    if (vGradient &lt; lowLimit) {</span>
<span class="nc" id="L775">                        continue;</span>
                    }

                    // subtract &quot;dominant orientation&quot;
<span class="nc" id="L779">                    int v = thetaImg.getValue(x, y) - rotation;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">                    if (v &lt; 0) {</span>
<span class="nc" id="L781">                        v += 360;</span>
                    }

<span class="nc" id="L784">                    float weightedContrib = (float)vGradient/(float)cellGrdSum;</span>

                    //TODO: add weightedContrib to the histogram
                    //  bin the v belongs in

<span class="nc" id="L789">                    cCount++;</span>
                }
            }
        }

<span class="nc" id="L794">        ThetaDescriptor desc = new HistogramThetaDescriptor(output,</span>
            centralPixelIndex);

<span class="nc" id="L797">        return desc;</span>
    }

    /**
     * extract the gradient from the image in 2X2 cells surrounding
     * (xCenter, yCenter) for 16 cells.
     * @param xCenter
     * @param yCenter
     * @param offsets
     * @return
     */
    private GradientDescriptor extractClrGradientForCells(int xCenter,
        int yCenter) {

<span class="nc" id="L811">        throw new UnsupportedOperationException(&quot;color gradient not yet implemented&quot;);</span>

        /*
          3 [-][-][.][.][-][-][.][.]
          2 [-][-][.][.][-][-][.][.]
          1 [.][.][-][-][.][.][-][-]
          0 [.][.][-][-] @ [.][-][-]
         -1 [-][-][.][.][-][-][.][.]
         -2 [-][-][.][.][-][-][.][.]
         -3 [.][.][-][-][.][.][-][-]
         -4 [.][.][-][-][.][.][-][-]
            -4 -3 -2 -1  0  1  2  3
        */
        /*
        int[] red = new int[16];
        int[] green = new int[16];
        int[] blue = new int[16];

        int sentinel = GsGradientDescriptor.sentinel;


        GradientDescriptor desc = new ClrGradientDescriptor(red, green, blue);

        return desc;
        */
    }

    /**
     * calculate the intensity and gradient based statistics between the two
     * descriptors with the caveat that the 2nd descriptor is the one used to
     * calculate the error (so make sure that pattern is consistently used by
     * invoker).
     *
     * @param descIntensity1
     * @param descGradient1
     * @param x1
     * @param y1
     * @param descIntensity2
     * @param descGradient2
     * @param x2
     * @param y2
     * @return
     */
    public static FeatureComparisonStat calculateStats(
        IntensityDescriptor descIntensity1, GradientDescriptor descGradient1,
        final int x1, final int y1,
        IntensityDescriptor descIntensity2, GradientDescriptor descGradient2,
        final int x2, final int y2) {

<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (descIntensity1 == null) {</span>
<span class="nc" id="L861">            throw new IllegalArgumentException(&quot;descIntensity1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (descGradient1 == null) {</span>
<span class="nc" id="L864">            throw new IllegalArgumentException(&quot;descGradient1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (descIntensity2 == null) {</span>
<span class="nc" id="L867">            throw new IllegalArgumentException(&quot;descIntensity2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (descGradient2 == null) {</span>
<span class="nc" id="L870">            throw new IllegalArgumentException(&quot;descGradient2 cannot be null&quot;);</span>
        }

<span class="nc" id="L873">        float err2SqIntensity = descIntensity2.sumSquaredError();</span>

<span class="nc" id="L875">        float ssdIntensity = descIntensity1.calculateSSD(descIntensity2);</span>

<span class="nc" id="L877">        float err2SqGradient = descGradient2.sumSquaredError();</span>

<span class="nc" id="L879">        float ssdGradient = descGradient1.calculateSSD(descGradient2);</span>

<span class="nc" id="L881">        FeatureComparisonStat stat = new FeatureComparisonStat();</span>
<span class="nc" id="L882">        stat.setImg1Point(new PairInt(x1, y1));</span>
<span class="nc" id="L883">        stat.setImg2Point(new PairInt(x2, y2));</span>
<span class="nc" id="L884">        stat.setSumIntensitySqDiff(ssdIntensity);</span>
<span class="nc" id="L885">        stat.setImg2PointIntensityErr(err2SqIntensity);</span>
<span class="nc" id="L886">        stat.setSumGradientSqDiff(ssdGradient);</span>
<span class="nc" id="L887">        stat.setImg2PointGradientErr(err2SqGradient);</span>

<span class="nc" id="L889">        return stat;</span>
    }

    /**
     * calculate the intensity and gradient based statistics between the two
     * descriptors with the caveat that the 2nd descriptor is the one used to
     * calculate the error (so make sure that pattern is consistently used by
     * invoker).
     *
     * @param descGradient1
     * @param x1
     * @param y1
     * @param descGradient2
     * @param x2
     * @param y2
     * @return
     */
    public static FeatureComparisonStat calculateGradientStats(
        GradientDescriptor descGradient1, final int x1, final int y1,
        GradientDescriptor descGradient2, final int x2, final int y2) {

<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        if (descGradient1 == null) {</span>
<span class="nc" id="L911">            throw new IllegalArgumentException(&quot;descGradient1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">        if (descGradient2 == null) {</span>
<span class="nc" id="L914">            throw new IllegalArgumentException(&quot;descGradient2 cannot be null&quot;);</span>
        }

<span class="fc" id="L917">        float err2SqGradient = descGradient2.sumSquaredError();</span>

<span class="fc" id="L919">        float ssdGradient = descGradient1.calculateSSD(descGradient2);</span>

<span class="fc" id="L921">        FeatureComparisonStat stat = new FeatureComparisonStat();</span>
<span class="fc" id="L922">        stat.setImg1Point(new PairInt(x1, y1));</span>
<span class="fc" id="L923">        stat.setImg2Point(new PairInt(x2, y2));</span>
<span class="fc" id="L924">        stat.setSumGradientSqDiff(ssdGradient);</span>
<span class="fc" id="L925">        stat.setImg2PointGradientErr(err2SqGradient);</span>

<span class="fc" id="L927">        return stat;</span>
    }
    
    /**
     * calculate the intensity and gradient based statistics between the two
     * descriptors with the caveat that the 2nd descriptor is the one used to
     * calculate the error (so make sure that pattern is consistently used by
     * invoker).
     *
     * @param descIntensity1
     * @param descGradient1
     * @param descTheta1
     * @param x1
     * @param y1
     * @param descIntensity2
     * @param descGradient2
     * @param descTheta2
     * @param x2
     * @param y2
     * @return
     */
    public static FeatureComparisonStat calculateStats(
        IntensityDescriptor descIntensity1, GradientDescriptor descGradient1,
        ThetaDescriptor descTheta1,
        final int x1, final int y1,
        IntensityDescriptor descIntensity2, GradientDescriptor descGradient2,
        ThetaDescriptor descTheta2,
        final int x2, final int y2) {

<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (descIntensity1 == null) {</span>
<span class="nc" id="L957">            throw new IllegalArgumentException(&quot;descIntensity1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">        if (descGradient1 == null) {</span>
<span class="nc" id="L960">            throw new IllegalArgumentException(&quot;descGradient1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">        if (descIntensity2 == null) {</span>
<span class="nc" id="L963">            throw new IllegalArgumentException(&quot;descIntensity2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">        if (descGradient2 == null) {</span>
<span class="nc" id="L966">            throw new IllegalArgumentException(&quot;descGradient2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">        if (descTheta1 == null) {</span>
<span class="nc" id="L969">            throw new IllegalArgumentException(&quot;descTheta1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">        if (descTheta2 == null) {</span>
<span class="nc" id="L972">            throw new IllegalArgumentException(&quot;descTheta2 cannot be null&quot;);</span>
        }

<span class="fc" id="L975">        float err2SqIntensity = descIntensity2.sumSquaredError();</span>

<span class="fc" id="L977">        float err1SqIntensity = descIntensity1.sumSquaredError();</span>
        
        //TODO: revisit this:
        //float errSqIntensity = (err2SqIntensity &gt; err1SqIntensity) ?
        //    err2SqIntensity : err1SqIntensity;

<span class="fc" id="L983">        float ssdIntensity = descIntensity1.calculateSSD(descIntensity2);</span>

<span class="fc" id="L985">        float err2SqGradient = descGradient2.sumSquaredError();</span>

<span class="fc" id="L987">        float ssdGradient = descGradient1.calculateSSD(descGradient2);</span>

<span class="fc" id="L989">        float err2Theta = descTheta2.calculateError();</span>

<span class="fc" id="L991">        float compTheta = descTheta1.calculateDifference(descTheta2);</span>

<span class="fc" id="L993">        FeatureComparisonStat stat = new FeatureComparisonStat();</span>
<span class="fc" id="L994">        stat.setImg1Point(new PairInt(x1, y1));</span>
<span class="fc" id="L995">        stat.setImg2Point(new PairInt(x2, y2));</span>
<span class="fc" id="L996">        stat.setSumIntensitySqDiff(ssdIntensity);</span>
<span class="fc" id="L997">        stat.setImg2PointIntensityErr(err2SqIntensity);</span>
<span class="fc" id="L998">        stat.setSumGradientSqDiff(ssdGradient);</span>
<span class="fc" id="L999">        stat.setImg2PointGradientErr(err2SqGradient);</span>
<span class="fc" id="L1000">        stat.setSumThetaSqDiff(compTheta);</span>
<span class="fc" id="L1001">        stat.setImg2PointThetaErr(err2Theta);</span>

<span class="fc" id="L1003">        return stat;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
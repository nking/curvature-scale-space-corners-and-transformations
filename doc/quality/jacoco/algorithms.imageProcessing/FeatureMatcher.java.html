<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">FeatureMatcher.java</span></div><h1>FeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;

<span class="pc bpc" id="L24" title="1 of 2 branches missed.">public class FeatureMatcher {</span>

<span class="fc" id="L26">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L28">    public FeatureMatcher() {</span>
<span class="fc" id="L29">    }</span>

    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param gsImg1
     * @param gsImg2
     * @param features1
     * @param features2
     * @param cornerRegion1
     * @param cornerRegion2
     * @param rotationInRadians
     * @param tolRotationInRadians
     * @param dither
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    protected FeatureComparisonStat ditherAndRotateForCorner1Location(
        GreyscaleImage gsImg1, GreyscaleImage gsImg2, 
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion cornerRegion1, CornerRegion cornerRegion2, 
        float rotationInRadians, float tolRotationInRadians, 
        int dither) throws CornerRegion.CornerRegionDegneracyException {
                
<span class="fc" id="L54">        float expectedRotationInDegrees = rotationInRadians </span>
            * (float)(180./Math.PI);
<span class="fc" id="L56">        final float rotTol = tolRotationInRadians * (float)(180./Math.PI);</span>
                
<span class="fc" id="L58">        int kMaxIdx1 = cornerRegion1.getKMaxIdx();</span>
<span class="fc" id="L59">        final int x1 = cornerRegion1.getX()[kMaxIdx1];</span>
<span class="fc" id="L60">        final int y1 = cornerRegion1.getY()[kMaxIdx1];</span>
<span class="fc" id="L61">        int rot1 = Math.round(</span>
<span class="fc" id="L62">            cornerRegion1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L64">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="fc" id="L65">        final int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="fc" id="L66">        final int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="fc" id="L67">        int rot2 = Math.round(</span>
<span class="fc" id="L68">            cornerRegion2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L70">        FeatureComparisonStat best = null;</span>
                
<span class="fc" id="L72">        IntensityDescriptor desc2 = features2.extractIntensity(gsImg2, x2, y2, rot2);</span>
        
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L75">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="fc" id="L80">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        // TODO: could decide not to find best rotation here and just discard
        // false matches due to wrong orientation at end of comparisons
<span class="fc" id="L85">        int[] rotations = new int[11];</span>
<span class="fc" id="L86">        rotations[0] = angleForResultDiff(rot2, Math.round(expectedRotationInDegrees));</span>
<span class="fc" id="L87">        int i = 1;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L89">            rotations[i] = rotD1;</span>
<span class="fc" id="L90">            i++;</span>
        }
<span class="fc" id="L92">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L93">        i++;</span>
<span class="fc" id="L94">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L95">        i++;</span>
<span class="fc" id="L96">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L97">        i++;</span>
        
<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L101">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L103">                rotD1 += 360;</span>
            }
                        
<span class="fc" id="L106">            int len = IntensityFeatures.getDefaultLengthForCellExtractOffsets();</span>
<span class="fc" id="L107">            float[] xTrq0 = new float[len];</span>
<span class="fc" id="L108">            float[] yTrq0 = new float[xTrq0.length];</span>
<span class="fc" id="L109">            int cellDim = IntensityFeatures.getDefaultCellDimForExtract();</span>
<span class="fc" id="L110">            int nCellsAcross = IntensityFeatures.getDefaultNCellsAcrossForExtract();</span>
<span class="fc" id="L111">            IntensityFeatures.populateRotationOffsetsQ0(cellDim, nCellsAcross, </span>
                rotD1, xTrq0, yTrq0);
            
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (!features1.isWithinXBounds(gsImg1, x1d)) {</span>
<span class="fc" id="L116">                    continue;</span>
                }
<span class="fc bfc" id="L118" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(gsImg1, y1d)) {</span>
<span class="fc" id="L120">                        continue;</span>
                    }
                    
                    // only try rotations within expected rotation limits
<span class="fc" id="L124">                    float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                    if (rotDescriptors &lt; 0) {</span>
<span class="fc" id="L126">                        rotDescriptors += 360;</span>
                    }
<span class="fc" id="L128">                    float rotDiff = AngleUtil.getAngleDifference(</span>
                        expectedRotationInDegrees, rotDescriptors);
<span class="fc bfc" id="L130" title="All 2 branches covered.">                    if (Math.abs(rotDiff) &gt; rotTol) {</span>
<span class="fc" id="L131">                        continue;</span>
                    }
                    
                    //IntensityDescriptor desc1 = features1.extractIntensity(
                    //    gsImg1, x1d, y1d, rotD1);
                    
<span class="fc" id="L137">                    IntensityDescriptor desc1 = features1.extractIntensityCellDesc(</span>
                        gsImg1, x1d, y1d, rotD1, xTrq0, yTrq0);
        
<span class="fc bfc" id="L140" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L141">                        continue;</span>
                    }
                    
<span class="fc" id="L144">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                    
<span class="fc bfc" id="L147" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L149" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L150">                            best = stat;</span>
<span class="fc" id="L151">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L152">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L154" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L155">                                best = stat;</span>
<span class="fc" id="L156">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L157">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L165">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param cornerRegion1
     * @param cornerRegion2
     * @param rotationInRadians
     * @param tolRotationInRadians
     * @param dither
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    protected FeatureComparisonStat ditherAndRotateForCorner1Location(
        Features features1, Features features2, CornerRegion cornerRegion1, 
        CornerRegion cornerRegion2, 
        float rotationInRadians, float tolRotationInRadians, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L188">        float expectedRotationInDegrees = rotationInRadians </span>
            * (float)(180./Math.PI);
<span class="nc" id="L190">        final float rotTol = tolRotationInRadians * (float)(180./Math.PI);</span>
                
<span class="nc" id="L192">        int kMaxIdx1 = cornerRegion1.getKMaxIdx();</span>
<span class="nc" id="L193">        final int x1 = cornerRegion1.getX()[kMaxIdx1];</span>
<span class="nc" id="L194">        final int y1 = cornerRegion1.getY()[kMaxIdx1];</span>
<span class="nc" id="L195">        int rot1 = Math.round(</span>
<span class="nc" id="L196">            cornerRegion1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L198">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="nc" id="L199">        final int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="nc" id="L200">        final int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="nc" id="L201">        int rot2 = Math.round(</span>
<span class="nc" id="L202">            cornerRegion2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L204">        FeatureComparisonStat best = null;</span>
                
<span class="nc" id="L206">        GradientDescriptor gDesc2 = features2.extractGradient(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (gDesc2 == null) {</span>
<span class="nc" id="L209">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="nc" id="L214">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        // TODO: could decide not to find best rotation here and just discard
        // false matches due to wrong orientation at end of comparisons
<span class="nc" id="L219">        int[] rotations = new int[11];</span>
<span class="nc" id="L220">        rotations[0] = angleForResultDiff(rot2, Math.round(expectedRotationInDegrees));</span>
<span class="nc" id="L221">        int i = 1;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L223">            rotations[i] = rotD1;</span>
<span class="nc" id="L224">            i++;</span>
        }
<span class="nc" id="L226">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L227">        i++;</span>
<span class="nc" id="L228">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L229">        i++;</span>
<span class="nc" id="L230">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L231">        i++;</span>
        
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L235">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L237">                rotD1 += 360;</span>
            }
<span class="nc bnc" id="L239" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L241">                    continue;</span>
                }
<span class="nc bnc" id="L243" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L245">                        continue;</span>
                    }
                    
                    // only try rotations within expected rotation limits
<span class="nc" id="L249">                    float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                    if (rotDescriptors &lt; 0) {</span>
<span class="nc" id="L251">                        rotDescriptors += 360;</span>
                    }
<span class="nc" id="L253">                    float rotDiff = AngleUtil.getAngleDifference(</span>
                        expectedRotationInDegrees, rotDescriptors);
<span class="nc bnc" id="L255" title="All 2 branches missed.">                    if (Math.abs(rotDiff) &gt; rotTol) {</span>
<span class="nc" id="L256">                        continue;</span>
                    }
                    
<span class="nc" id="L259">                    GradientDescriptor gDesc1 = features1.extractGradient(x1d, </span>
                        y1d, rotD1);
                    
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    if (gDesc1 == null) {</span>
<span class="nc" id="L263">                        continue;</span>
                    }
                       
<span class="nc" id="L266">                    FeatureComparisonStat stat = Features.calculateGradientStats(</span>
                        gDesc1, x1d, y1d, gDesc2, x2, y2);
                   
<span class="nc bnc" id="L269" title="All 2 branches missed.">                    if (stat.getSumGradientSqDiff() &lt; stat.getImg2PointGradientErr()) {</span>
                       
<span class="nc bnc" id="L271" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L272">                            best = stat;</span>
<span class="nc" id="L273">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L274">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L276" title="All 2 branches missed.">                            if (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff()) {</span>
<span class="nc" id="L277">                                best = stat;</span>
<span class="nc" id="L278">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L279">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L287">        return best;</span>
    }

    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="nc" id="L306">        final int x1 = region1.getX()[1];</span>
<span class="nc" id="L307">        final int y1 = region1.getY()[1];</span>
<span class="nc" id="L308">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L310">        final int x2 = region2.getX()[1];</span>
<span class="nc" id="L311">        final int y2 = region2.getY()[1];</span>
<span class="nc" id="L312">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L314">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="nc" id="L337">        final int x1 = region1.getX()[1];</span>
<span class="nc" id="L338">        final int y1 = region1.getY()[1];</span>
<span class="nc" id="L339">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L341">        final int x2 = region2.getX()[1];</span>
<span class="nc" id="L342">        final int y2 = region2.getY()[1];</span>
<span class="nc" id="L343">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L345">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither, img1, img2);
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="fc" id="L355">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L356">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L357">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="fc" id="L358">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="fc" id="L360">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L361">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L362">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="fc" id="L363">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L365">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @param degreeIntervals a value &gt; 20 is not recommended
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2, int degreeIntervals) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="nc" id="L389">        final int x1 = region1.getX()[1];</span>
<span class="nc" id="L390">        final int y1 = region1.getY()[1];</span>
<span class="nc" id="L391">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L393">        final int x2 = region2.getX()[1];</span>
<span class="nc" id="L394">        final int y2 = region2.getY()[1];</span>
<span class="nc" id="L395">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L397">        int n = 360/degreeIntervals;</span>
<span class="nc" id="L398">        int[] rotations = new int[n];</span>
<span class="nc" id="L399">        int i = 0;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="nc" id="L401">            rotations[i] = rot1 + rotD1;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (rotations[i] &gt; 359) {</span>
<span class="nc" id="L403">                rotations[i] -= 360;</span>
            }
<span class="nc" id="L405">            i++;</span>
        }
        
<span class="nc" id="L408">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @param degreeIntervals a value &gt; 20 is not recommended
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2, int degreeIntervals) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="nc" id="L432">        final int x1 = region1.getX()[region1.getKMaxIdx()];</span>
<span class="nc" id="L433">        final int y1 = region1.getY()[region1.getKMaxIdx()];</span>
<span class="nc" id="L434">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L436">        final int x2 = region2.getX()[region2.getKMaxIdx()];</span>
<span class="nc" id="L437">        final int y2 = region2.getY()[region2.getKMaxIdx()];</span>
<span class="nc" id="L438">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L440">        int n = 360/degreeIntervals;</span>
<span class="nc" id="L441">        int[] rotations = new int[n];</span>
<span class="nc" id="L442">        int i = 0;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="nc" id="L444">            rotations[i] = rot1 + rotD1;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (rotations[i] &gt; 359) {</span>
<span class="nc" id="L446">                rotations[i] -= 360;</span>
            }
<span class="nc" id="L448">            i++;</span>
        }
        
<span class="nc" id="L451">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
        
<span class="nc" id="L476">        int[] rotations = new int[10];</span>
<span class="nc" id="L477">        int i = 0;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L479">            rotations[i] = rotD1;</span>
<span class="nc" id="L480">            i++;</span>
        }
<span class="nc" id="L482">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L483">        i++;</span>
<span class="nc" id="L484">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L485">        i++;</span>
<span class="nc" id="L486">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L487">        i++;</span>
        
<span class="nc" id="L489">        return ditherAndRotateForBestLocation(features1, features2, x1, y1, </span>
            rotations, x2, y2, rot2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, GreyscaleImage img1, GreyscaleImage img2) {
        
        
<span class="fc" id="L516">        int[] rotations = new int[10];</span>
<span class="fc" id="L517">        int i = 0;</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L519">            rotations[i] = rotD1;</span>
<span class="fc" id="L520">            i++;</span>
        }
<span class="fc" id="L522">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L523">        i++;</span>
<span class="fc" id="L524">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L525">        i++;</span>
<span class="fc" id="L526">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L527">        i++;</span>
        
<span class="fc" id="L529">        return ditherAndRotateForBestLocation(features1, features2, x1, y1, </span>
            rotations, x2, y2, rot2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rotations
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int[] rotations,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
<span class="nc" id="L553">        FeatureComparisonStat best = null;</span>
        
<span class="nc" id="L555">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L558">            return null;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="nc bnc" id="L566" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L568">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L570">                rotD1 += 360;</span>
            }
<span class="nc bnc" id="L572" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L574">                    continue;</span>
                }
<span class="nc bnc" id="L576" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L578">                        continue;</span>
                    }
                    
<span class="nc" id="L581">                    IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rotD1);</span>
        
<span class="nc bnc" id="L583" title="All 2 branches missed.">                    if (desc1 == null) {</span>
<span class="nc" id="L584">                        continue;</span>
                    }
                    
<span class="nc" id="L587">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="nc bnc" id="L590" title="All 2 branches missed.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="nc bnc" id="L592" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L593">                            best = stat;</span>
<span class="nc" id="L594">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L595">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L597" title="All 2 branches missed.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L598">                                best = stat;</span>
<span class="nc" id="L599">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L600">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L608">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rotations
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int[] rotations,
        final int x2, final int y2, final int rot2,        
        int dither, GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L633">        FeatureComparisonStat best = null;</span>
        
<span class="fc" id="L635">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, </span>
            rot2);
        
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L639">            return null;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="fc bfc" id="L647" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L649">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L651">                rotD1 += 360;</span>
            }
            
<span class="fc" id="L654">            int len = IntensityFeatures.getDefaultLengthForCellExtractOffsets();</span>
<span class="fc" id="L655">            float[] xTrq0 = new float[len];</span>
<span class="fc" id="L656">            float[] yTrq0 = new float[xTrq0.length];</span>
<span class="fc" id="L657">            int cellDim = IntensityFeatures.getDefaultCellDimForExtract();</span>
<span class="fc" id="L658">            int nCellsAcross = IntensityFeatures.getDefaultNCellsAcrossForExtract();</span>
<span class="fc" id="L659">            IntensityFeatures.populateRotationOffsetsQ0(cellDim, nCellsAcross, rotD1, </span>
                xTrq0, yTrq0);
            
<span class="fc bfc" id="L662" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">                if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="fc" id="L664">                    continue;</span>
                }
<span class="fc bfc" id="L666" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="fc" id="L668">                        continue;</span>
                    }
                    
                    //IntensityDescriptor desc1 = features1.extractIntensity(img1, 
                    //    x1d, y1d, rotD1);
        
<span class="fc" id="L674">                    IntensityDescriptor desc1 = features1.extractIntensityCellDesc(</span>
                        img1, x1d, y1d, rotD1, xTrq0, yTrq0);
                    
<span class="fc bfc" id="L677" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L678">                        continue;</span>
                    }
                    
<span class="fc" id="L681">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L684" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L686" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L687">                            best = stat;</span>
<span class="fc" id="L688">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L689">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L691" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L692">                                best = stat;</span>
<span class="fc" id="L693">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L694">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L702">        return best;</span>
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        final int expectedRotationInDegrees, final int rotationTol) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L711">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L712">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L713">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L714">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L716">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L717">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L718">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L719">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L721">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, expectedRotationInDegrees,
            rotationTol);
    }
    
    /**
     * 
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        final int expectedRotationInDegrees, final int rotationTol,
        GreyscaleImage img1, GreyscaleImage img2) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="fc" id="L747">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L748">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L749">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="fc" id="L750">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="fc" id="L752">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L753">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L754">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="fc" id="L755">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L757">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, expectedRotationInDegrees,
            rotationTol, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, int expectedRotationInDegrees, final int rotationTol) {
        
<span class="nc" id="L784">        FeatureComparisonStat best = null;</span>
        
<span class="nc" id="L786">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L789">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="nc" id="L794">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="nc" id="L802">        int[] rotations = new int[11];</span>
<span class="nc" id="L803">        rotations[0] = angleForResultDiff(rot2, expectedRotationInDegrees);</span>
<span class="nc" id="L804">        int i = 1;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L806">            rotations[i] = rotD1;</span>
<span class="nc" id="L807">            i++;</span>
        }
<span class="nc" id="L809">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L810">        i++;</span>
<span class="nc" id="L811">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L812">        i++;</span>
<span class="nc" id="L813">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L814">        i++;</span>
        
<span class="nc bnc" id="L816" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L818">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L820">                rotD1 += 360;</span>
            }
            
            // only try rotations within expected rotation limits
<span class="nc" id="L824">            float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">            if (rotDescriptors &lt; 0) {</span>
<span class="nc" id="L826">                rotDescriptors += 360;</span>
            }
<span class="nc" id="L828">            float rotDiff = AngleUtil.getAngleDifference(</span>
                expectedRotationInDegrees, rotDescriptors);
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (Math.abs(rotDiff) &gt; rotationTol) {</span>
<span class="nc" id="L831">                continue;</span>
            }
            
<span class="nc bnc" id="L834" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L836">                    continue;</span>
                }
<span class="nc bnc" id="L838" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L840">                        continue;</span>
                    }
                    
<span class="nc" id="L843">                    IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rotD1);</span>
        
<span class="nc bnc" id="L845" title="All 2 branches missed.">                    if (desc1 == null) {</span>
<span class="nc" id="L846">                        continue;</span>
                    }
                    
<span class="nc" id="L849">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="nc bnc" id="L852" title="All 2 branches missed.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L854">                            best = stat;</span>
<span class="nc" id="L855">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L856">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L858" title="All 2 branches missed.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L859">                                best = stat;</span>
<span class="nc" id="L860">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L861">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L869">        return best;</span>
    }
   
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, int expectedRotationInDegrees, final int rotationTol,
        GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L897">        FeatureComparisonStat best = null;</span>
        
<span class="fc" id="L899">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, </span>
            rot2);
        
<span class="fc bfc" id="L902" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L903">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="fc bfc" id="L907" title="All 2 branches covered.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="fc" id="L908">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
                
<span class="fc" id="L916">        int[] rotations = new int[11];</span>
<span class="fc" id="L917">        rotations[0] = angleForResultDiff(rot2, expectedRotationInDegrees);</span>
<span class="fc" id="L918">        int i = 1;</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L920">            rotations[i] = rotD1;</span>
<span class="fc" id="L921">            i++;</span>
        }
<span class="fc" id="L923">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L924">        i++;</span>
<span class="fc" id="L925">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L926">        i++;</span>
<span class="fc" id="L927">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L928">        i++;</span>
        
<span class="fc bfc" id="L930" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L932">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L934">                rotD1 += 360;</span>
            }
            
            // only try rotations within expected rotation limits
<span class="fc" id="L938">            float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">            if (rotDescriptors &lt; 0) {</span>
<span class="fc" id="L940">                rotDescriptors += 360;</span>
            }
<span class="fc" id="L942">            float rotDiff = AngleUtil.getAngleDifference(</span>
                expectedRotationInDegrees, rotDescriptors);
<span class="fc bfc" id="L944" title="All 2 branches covered.">            if (Math.abs(rotDiff) &gt; rotationTol) {</span>
<span class="fc" id="L945">                continue;</span>
            }
            
<span class="fc" id="L948">            int len = IntensityFeatures.getDefaultLengthForCellExtractOffsets();</span>
<span class="fc" id="L949">            float[] xTrq0 = new float[len];</span>
<span class="fc" id="L950">            float[] yTrq0 = new float[xTrq0.length];</span>
<span class="fc" id="L951">            int cellDim = IntensityFeatures.getDefaultCellDimForExtract();</span>
<span class="fc" id="L952">            int nCellsAcross = IntensityFeatures.getDefaultNCellsAcrossForExtract();</span>
<span class="fc" id="L953">            IntensityFeatures.populateRotationOffsetsQ0(cellDim, nCellsAcross, rotD1, xTrq0, yTrq0);</span>
            
<span class="fc bfc" id="L955" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">                if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="fc" id="L957">                    continue;</span>
                }
<span class="fc bfc" id="L959" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="fc" id="L961">                        continue;</span>
                    }
                    
                    //IntensityDescriptor desc1 = features1.extractIntensity(img1, 
                    //    x1d, y1d, rotD1);
                    
<span class="fc" id="L967">                    IntensityDescriptor desc1 = features1.extractIntensityCellDesc(</span>
                        img1, x1d, y1d, rotD1, xTrq0, yTrq0);
        
<span class="fc bfc" id="L970" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L971">                        continue;</span>
                    }
                    
<span class="fc" id="L974">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L977" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L979">                            best = stat;</span>
<span class="fc" id="L980">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L981">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L983" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L984">                                best = stat;</span>
<span class="fc" id="L985">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L986">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L994">        return best;</span>
    }
    
    public static float[] calculateThetaDiff(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="nc bnc" id="L999" title="All 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1000">            return null;</span>
        }
        
<span class="nc" id="L1003">        float[] values = new float[compStats.size()];</span>
        
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="nc" id="L1007">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="nc" id="L1009">            float diff = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L1010">                stat.getImg1PointRotInDegrees(), stat.getImg2PointRotInDegrees());</span>
            
<span class="nc" id="L1012">            values[i] = diff;</span>
        }
        
<span class="nc" id="L1015">        return values;</span>
    }

    public CorrespondenceList findSimilarFeatures(GreyscaleImage gsImg1, 
        CornerRegion[] cr1, GreyscaleImage gsImg2, 
        CornerRegion[] cr2, TransformationParameters params, float scaleTol, 
        float rotationInRadiansTol, int transXYTol, int dither) {
        
<span class="fc" id="L1023">        List&lt;CornerRegion&gt; filteredTransformedC1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L1024">        List&lt;CornerRegion&gt; filteredC1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L1025">        List&lt;CornerRegion&gt; filteredC2 = new ArrayList&lt;CornerRegion&gt;();</span>
        
<span class="fc" id="L1027">        filterForIntersection3(params, transXYTol, </span>
            cr1, cr2, filteredTransformedC1, filteredC1, filteredC2);
        
        if (true) {
            try {
<span class="fc" id="L1032">                MiscDebug.writeImage(filteredC1, gsImg1.copyToColorGreyscale(),</span>
                    &quot;filtered_1_corners_&quot;);
<span class="fc" id="L1034">                MiscDebug.writeImage(filteredC2, gsImg2.copyToColorGreyscale(), </span>
                    &quot;filtered_2_corners_&quot;);
<span class="nc" id="L1036">            } catch (IOException ex) {</span>
<span class="nc" id="L1037">                Logger.getLogger(FeatureMatcherWrapper.class.getName()).log(</span>
                    Level.SEVERE, null, ex);
<span class="fc" id="L1039">            }</span>
        }
        
        /*
        when transformation params are known ahead of time:
        cr1 can be transformed into crTr1 (including the internal points).
        then the matching is faster than n1 * n2 because can discard some 
        possible matches immediately.
        bipartite matching when points are present within tolerance.
        
        bipartite is n^3 but the n is &lt; n1.
        */
       
<span class="fc" id="L1052">        final int blockHalfWidth = 5;</span>
<span class="fc" id="L1053">        final boolean useNormalizedIntensities = true;</span>
        
<span class="fc" id="L1055">        IntensityFeatures features1 = new IntensityFeatures(blockHalfWidth, </span>
            useNormalizedIntensities);
        
<span class="fc" id="L1058">        IntensityFeatures features2 = new IntensityFeatures(blockHalfWidth,</span>
            useNormalizedIntensities);
        
        //Features features1 = new Features(gsImg1, gXY1, theta1, blockHalfWidth, 
        //    useNormalizedIntensities);
        //
        //Features features2 = new Features(gsImg2, gXY2, theta2, blockHalfWidth, 
        //    useNormalizedIntensities);
        
<span class="fc" id="L1067">        int n1 = filteredC1.size();</span>
<span class="fc" id="L1068">        int n2 = filteredC2.size();</span>
<span class="fc" id="L1069">        int nMaxMatchable = Math.min(n1, n2);</span>
        
<span class="fc" id="L1071">        Map&lt;PairInt, FeatureComparisonStat&gt; statMap = null;</span>
<span class="fc" id="L1072">        float[][] cost = null;</span>
                
<span class="fc" id="L1074">        final boolean useBipartite = false;//(nMaxMatchable &lt; 251);</span>
        
<span class="fc" id="L1076">        Map&lt;Integer, Integer&gt; index1Map = null;</span>
<span class="fc" id="L1077">        Map&lt;Integer, Set&lt;Integer&gt;&gt; index2Map = null;</span>
<span class="fc" id="L1078">        Map&lt;Integer, FeatureComparisonStat&gt; index1StatMap = null;</span>
        
        if (useBipartite) {
            cost = new float[n1][n2];
            statMap = new HashMap&lt;PairInt, FeatureComparisonStat&gt;();
        } else {
<span class="fc" id="L1084">            index1Map = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L1085">            index2Map = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L1086">            index1StatMap = new HashMap&lt;Integer, FeatureComparisonStat&gt;();</span>
        }
                
<span class="fc" id="L1089">        int count = 0;</span>
        
<span class="fc bfc" id="L1091" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n1; ++i1) {</span>
            
            if (useBipartite) {
                cost[i1] = new float[n2];
                Arrays.fill(cost[i1], Float.MAX_VALUE);
            }
            
<span class="fc" id="L1098">            CornerRegion c1Tr = filteredTransformedC1.get(i1);</span>
<span class="fc" id="L1099">            CornerRegion c1 = filteredC1.get(i1);</span>
            
<span class="fc" id="L1101">            int x1Tr = c1Tr.getX()[c1Tr.getKMaxIdx()];</span>
<span class="fc" id="L1102">            int y1Tr = c1Tr.getY()[c1Tr.getKMaxIdx()];</span>
            
<span class="fc" id="L1104">            int x1 = c1.getX()[c1.getKMaxIdx()];</span>
<span class="fc" id="L1105">            int y1 = c1.getY()[c1.getKMaxIdx()];</span>
            
<span class="fc" id="L1107">            double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L1108">            int bestIdx2 = -1;</span>
<span class="fc" id="L1109">            FeatureComparisonStat bestStat = null;</span>
            
<span class="fc bfc" id="L1111" title="All 2 branches covered.">            for (int i2 = 0; i2 &lt; n2; ++i2) {</span>
                
<span class="fc" id="L1113">                CornerRegion c2 = filteredC2.get(i2);</span>
                
<span class="fc" id="L1115">                int x2 = c2.getX()[c2.getKMaxIdx()];</span>
<span class="fc" id="L1116">                int y2 = c2.getY()[c2.getKMaxIdx()];</span>
                                
<span class="fc" id="L1118">                int diffX = Math.abs(x1Tr - x2);</span>
<span class="fc" id="L1119">                int diffY = Math.abs(y1Tr - y2);</span>
<span class="fc bfc" id="L1120" title="All 4 branches covered.">                if (diffX &gt; transXYTol || diffY &gt; transXYTol) {</span>
<span class="fc" id="L1121">                    continue;</span>
                }
                
                try {
                  
                    // use the untransformed cr1 to be able to filter by rotation
<span class="fc" id="L1127">                    FeatureComparisonStat stat = ditherAndRotateForCorner1Location(</span>
                        gsImg1, gsImg2, features1, features2, c1, c2,
<span class="fc" id="L1129">                        params.getRotationInRadians(), rotationInRadiansTol, dither);</span>
                    
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                    if (stat != null &amp;&amp; </span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">                        (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr())) {</span>

                        if (useBipartite) {
                            cost[i1][i2] = stat.getSumIntensitySqDiff();
                            PairInt p = new PairInt(i1, i2);
                            statMap.put(p, stat);
                        } else {
<span class="fc bfc" id="L1139" title="All 4 branches covered.">                            if ((bestIdx2 == -1) || (bestCost &gt; stat.getSumIntensitySqDiff())) {</span>
<span class="fc" id="L1140">                                bestIdx2 = i2;</span>
<span class="fc" id="L1141">                                bestCost = stat.getSumIntensitySqDiff();</span>
<span class="fc" id="L1142">                                bestStat = stat;</span>
<span class="fc" id="L1143">                                bestStat.setIndex1(i1);</span>
<span class="fc" id="L1144">                                bestStat.setIndex2(i2);</span>
                            }
                        }
                        
<span class="fc" id="L1148">                        count++;</span>
                    }
                    
<span class="fc" id="L1151">                } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L1152">                    log.fine(ex.getMessage());</span>
<span class="fc" id="L1153">                }</span>
            }
            
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            if (!useBipartite &amp;&amp; (bestStat != null)) {</span>
<span class="fc" id="L1157">                Integer key1 = Integer.valueOf(i1);</span>
<span class="fc" id="L1158">                Integer key2 = Integer.valueOf(bestIdx2);</span>
<span class="fc" id="L1159">                index1Map.put(key1, key2);</span>
<span class="fc" id="L1160">                Set&lt;Integer&gt; set = index2Map.get(key2);</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">                if (set == null) {</span>
<span class="fc" id="L1162">                    set = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1163">                    index2Map.put(key2, set);</span>
                }
<span class="fc" id="L1165">                set.add(key1);</span>
                
<span class="fc" id="L1167">                index1StatMap.put(key1, bestStat);</span>
            }
        }
        
        if (useBipartite) {
            return useBipartiteMatching(cost, statMap, params);
        }
        
        // resolve any double matchings, but discard the higher cost matches
        //   from conflicted matches rather than re-trying a solution for them
        
<span class="fc" id="L1178">        Set&lt;Integer&gt; resolved = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : index2Map.entrySet()) {</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">            if (resolved.contains(entry.getKey())) {</span>
<span class="fc" id="L1181">                continue;</span>
            }
<span class="fc" id="L1183">            Set&lt;Integer&gt; set = entry.getValue();</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">            if (set.size() &gt; 1) {</span>
<span class="fc" id="L1185">                double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L1186">                Integer bestIndex1 = -1;</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">                for (Integer index1 : set) {</span>
<span class="fc" id="L1188">                    FeatureComparisonStat fcs = index1StatMap.get(index1);</span>
<span class="pc bpc" id="L1189" title="3 of 4 branches missed.">                    assert(fcs != null);</span>
<span class="fc" id="L1190">                    double cost2 = fcs.getSumIntensitySqDiff();</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">                    if (cost2 &lt; bestCost) {</span>
<span class="fc" id="L1192">                        bestCost = cost2;</span>
<span class="fc" id="L1193">                        bestIndex1 = index1;</span>
                    }
<span class="fc" id="L1195">                    resolved.add(index1);</span>
<span class="fc" id="L1196">                }</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">                for (Integer index1 : set) {</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">                    if (index1.equals(bestIndex1)) {</span>
<span class="fc" id="L1199">                        continue;</span>
                    }
<span class="fc" id="L1201">                    index1Map.remove(index1);</span>
<span class="fc" id="L1202">                    index1StatMap.remove(index1);</span>
<span class="fc" id="L1203">                }</span>
            }
<span class="fc" id="L1205">        }</span>
        
<span class="fc" id="L1207">        int nc = index1StatMap.size();</span>
        
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        if (nc &lt; 7) {</span>
<span class="nc" id="L1210">            return null;</span>
        }
        
        //PairIntArray matchedXY1 = new PairIntArray(nc);
        //PairIntArray matchedXY2 = new PairIntArray(nc);
        
<span class="fc" id="L1216">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L1217">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>

<span class="fc" id="L1219">        float[] weights = new float[nc];</span>
<span class="fc" id="L1220">        double sumW = 0;</span>

<span class="fc" id="L1222">        nc = 0;</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        for (Entry&lt;Integer, FeatureComparisonStat&gt; entry : index1StatMap.entrySet()) {</span>
<span class="fc" id="L1224">            FeatureComparisonStat fcs = entry.getValue();</span>
<span class="fc" id="L1225">            int idx1 = fcs.getIndex1();</span>
<span class="fc" id="L1226">            int idx2 = fcs.getIndex2();</span>
<span class="fc" id="L1227">            PairInt p1 = fcs.getImg1Point();</span>
<span class="fc" id="L1228">            PairInt p2 = fcs.getImg2Point();</span>
<span class="fc" id="L1229">            matched1.add(p1.copy());</span>
<span class="fc" id="L1230">            matched2.add(p2.copy());</span>
<span class="fc" id="L1231">            weights[nc] = fcs.getSumIntensitySqDiff();</span>
<span class="fc" id="L1232">            sumW += weights[nc];</span>
<span class="fc" id="L1233">            nc++;</span>
<span class="fc" id="L1234">        }</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">        if (sumW &gt; 0) {</span>
<span class="fc" id="L1236">            double tot = 0;</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">            for (int i = 0; i &lt; nc; ++i) {</span>
<span class="fc" id="L1238">                double div = (sumW - weights[i]) / ((nc - 1) * sumW);</span>
<span class="fc" id="L1239">                weights[i] = (float) div;</span>
<span class="fc" id="L1240">                tot += div;</span>
            }
<span class="pc bpc" id="L1242" title="3 of 4 branches missed.">            assert (Math.abs(tot - 1.) &lt; 0.03);</span>
<span class="fc" id="L1243">        } else {</span>
<span class="nc" id="L1244">            float a = 1.f / (float) nc;</span>
<span class="nc" id="L1245">            Arrays.fill(weights, a);</span>
        }

<span class="fc" id="L1248">        int rangeRotation = Math.round(params.getStandardDeviations()[1]);</span>
<span class="fc" id="L1249">        int rangeTranslationX = Math.round(params.getStandardDeviations()[2]);</span>
<span class="fc" id="L1250">        int rangeTranslationY = Math.round(params.getStandardDeviations()[3]);</span>

<span class="fc" id="L1252">        CorrespondenceList cl = new CorrespondenceList(params.getScale(),</span>
<span class="fc" id="L1253">            Math.round(params.getRotationInDegrees()),</span>
<span class="fc" id="L1254">            Math.round(params.getTranslationX()), Math.round(params.getTranslationY()),</span>
            rangeRotation, rangeTranslationX, rangeTranslationY,
            matched1, matched2);

<span class="fc" id="L1258">        return cl;</span>
    }

    public static &lt;T extends CornerRegion&gt; void filterForIntersection(
        TransformationParameters params, float toleranceXY,
        List&lt;List&lt;T&gt;&gt; c1, List&lt;List&lt;T&gt;&gt; c2, 
        List&lt;List&lt;T&gt;&gt; outFilteredTransformedC1,
        List&lt;List&lt;T&gt;&gt; outFilteredC1, 
        List&lt;List&lt;T&gt;&gt; outFilteredC2) {
        
<span class="nc" id="L1268">        float[] minXY2 = MiscMath.findMinXY(c2);</span>
<span class="nc" id="L1269">        float[] maxXY2 = MiscMath.findMaxXY(c2);</span>
        
<span class="nc" id="L1271">        Transformer transformer = new Transformer();</span>
        
<span class="nc" id="L1273">        float[] minXY1 = new float[]{Float.MAX_VALUE, Float.MAX_VALUE};</span>
<span class="nc" id="L1274">        float[] maxXY1 = new float[]{Float.MIN_VALUE, Float.MIN_VALUE};</span>
   
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        for (int i = 0; i &lt; c1.size(); ++i) {</span>
<span class="nc" id="L1277">            List&lt;T&gt; outList = new ArrayList&lt;T&gt;();</span>
<span class="nc" id="L1278">            List&lt;T&gt; listTr = new ArrayList&lt;T&gt;();</span>
<span class="nc" id="L1279">            List&lt;T&gt; list = c1.get(i);</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">            for (int j = 0; j &lt; list.size(); ++j) {</span>
                
<span class="nc" id="L1282">                T ctr = transformer.applyTransformation(params, </span>
<span class="nc" id="L1283">                    list.get(j));</span>
                
<span class="nc" id="L1285">                int x = ctr.getX()[ctr.getKMaxIdx()];</span>
<span class="nc" id="L1286">                int y = ctr.getY()[ctr.getKMaxIdx()];</span>
                
<span class="nc bnc" id="L1288" title="All 4 branches missed.">                if ((x &lt; (minXY2[0] - toleranceXY)) || (x &gt; (maxXY2[0] + toleranceXY))) {</span>
<span class="nc" id="L1289">                    continue;</span>
                }
<span class="nc bnc" id="L1291" title="All 4 branches missed.">                if ((y &lt; (minXY2[1] - toleranceXY)) || (y &gt; (maxXY2[1] + toleranceXY))) {</span>
<span class="nc" id="L1292">                    continue;</span>
                }
<span class="nc" id="L1294">                listTr.add(ctr);</span>
<span class="nc" id="L1295">                outList.add(list.get(j));</span>
                
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                if (x &lt; minXY1[0]) {</span>
<span class="nc" id="L1298">                    minXY1[0] = x;</span>
                }
<span class="nc bnc" id="L1300" title="All 2 branches missed.">                if (y &lt; minXY1[1]) {</span>
<span class="nc" id="L1301">                    minXY1[1] = y;</span>
                }
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                if (x &gt; maxXY1[0]) {</span>
<span class="nc" id="L1304">                    maxXY1[0] = x;</span>
                }
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                if (y &gt; maxXY1[1]) {</span>
<span class="nc" id="L1307">                    maxXY1[1] = y;</span>
                }
            }
<span class="nc" id="L1310">            outFilteredTransformedC1.add(listTr);</span>
<span class="nc" id="L1311">            outFilteredC1.add(outList);</span>
        }

<span class="nc bnc" id="L1314" title="All 2 branches missed.">        for (int i = 0; i &lt; c2.size(); ++i) {</span>
<span class="nc" id="L1315">            List&lt;T&gt; outList = new ArrayList&lt;T&gt;();</span>
<span class="nc" id="L1316">            List&lt;T&gt; list = c2.get(i);</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            for (int j = 0; j &lt; list.size(); ++j) {</span>
<span class="nc" id="L1318">                T c = list.get(j);</span>
<span class="nc" id="L1319">                int x = c.getX()[c.getKMaxIdx()];</span>
<span class="nc" id="L1320">                int y = c.getY()[c.getKMaxIdx()];</span>
                
<span class="nc bnc" id="L1322" title="All 4 branches missed.">                if ((x &lt; (minXY1[0] - toleranceXY)) || (x &gt; (maxXY1[0] + toleranceXY))) {</span>
<span class="nc" id="L1323">                    continue;</span>
                }
<span class="nc bnc" id="L1325" title="All 4 branches missed.">                if ((y &lt; (minXY1[1] - toleranceXY)) || (y &gt; (maxXY1[1] + toleranceXY))) {</span>
<span class="nc" id="L1326">                    continue;</span>
                }
<span class="nc" id="L1328">                outList.add(list.get(j));</span>
            }
<span class="nc" id="L1330">            outFilteredC2.add(outList);</span>
        }        
<span class="nc" id="L1332">    }</span>
    
    public static void filterForIntersection3(TransformationParameters params, 
        int transXYTol, CornerRegion[] c1, CornerRegion[] c2, 
        List&lt;CornerRegion&gt; outFilteredTransformedC1, 
        List&lt;CornerRegion&gt; outFilteredC1, 
        List&lt;CornerRegion&gt; outFilteredC2) {
        
<span class="fc" id="L1340">        int[] minXY2 = MiscMath.findMinXY2(c2);</span>
<span class="fc" id="L1341">        int[] maxXY2 = MiscMath.findMaxXY2(c2);</span>
        
<span class="fc" id="L1343">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L1345">        float[] minXY1 = new float[]{Float.MAX_VALUE, Float.MAX_VALUE};</span>
<span class="fc" id="L1346">        float[] maxXY1 = new float[]{Float.MIN_VALUE, Float.MIN_VALUE};</span>
        
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        for (int i = 0; i &lt; c1.length; ++i) {</span>
                
<span class="fc" id="L1350">            CornerRegion ctr = transformer.applyTransformation(params, c1[i]);</span>
                
<span class="fc" id="L1352">            int x = ctr.getX()[ctr.getKMaxIdx()];</span>
<span class="fc" id="L1353">            int y = ctr.getY()[ctr.getKMaxIdx()];</span>

<span class="fc bfc" id="L1355" title="All 4 branches covered.">            if ((x &lt; (minXY2[0] - transXYTol)) || (x &gt; (maxXY2[0] + transXYTol))) {</span>
<span class="fc" id="L1356">                continue;</span>
            }
<span class="pc bpc" id="L1358" title="1 of 4 branches missed.">            if ((y &lt; (minXY2[1] - transXYTol)) || (y &gt; (maxXY2[1] + transXYTol))) {</span>
<span class="nc" id="L1359">                continue;</span>
            }
<span class="fc" id="L1361">            outFilteredTransformedC1.add(ctr);</span>
<span class="fc" id="L1362">            outFilteredC1.add(c1[i]);</span>
                
<span class="fc bfc" id="L1364" title="All 2 branches covered.">            if (x &lt; minXY1[0]) {</span>
<span class="fc" id="L1365">                minXY1[0] = x;</span>
            }
<span class="fc bfc" id="L1367" title="All 2 branches covered.">            if (y &lt; minXY1[1]) {</span>
<span class="fc" id="L1368">                minXY1[1] = y;</span>
            }
<span class="fc bfc" id="L1370" title="All 2 branches covered.">            if (x &gt; maxXY1[0]) {</span>
<span class="fc" id="L1371">                maxXY1[0] = x;</span>
            }
<span class="fc bfc" id="L1373" title="All 2 branches covered.">            if (y &gt; maxXY1[1]) {</span>
<span class="fc" id="L1374">                maxXY1[1] = y;</span>
            }
        }

<span class="fc bfc" id="L1378" title="All 2 branches covered.">        for (int i = 0; i &lt; c2.length; ++i) {</span>
<span class="fc" id="L1379">            CornerRegion c = c2[i];</span>
<span class="fc" id="L1380">            int x = c.getX()[c.getKMaxIdx()];</span>
<span class="fc" id="L1381">            int y = c.getY()[c.getKMaxIdx()];</span>
                
<span class="fc bfc" id="L1383" title="All 4 branches covered.">            if ((x &lt; (minXY1[0] - transXYTol)) || (x &gt; (maxXY1[0] + transXYTol))) {</span>
<span class="fc" id="L1384">                continue;</span>
            }
<span class="pc bpc" id="L1386" title="1 of 4 branches missed.">            if ((y &lt; (minXY1[1] - transXYTol)) || (y &gt; (maxXY1[1] + transXYTol))) {</span>
<span class="nc" id="L1387">                continue;</span>
            }
<span class="fc" id="L1389">            outFilteredC2.add(c);</span>
        }        
<span class="fc" id="L1391">    }</span>

    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="nc bnc" id="L1396" title="All 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1397">            return null;</span>
        }
        
<span class="nc" id="L1400">        float[] values = calculateThetaDiff(compStats);</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">            if (values[i] &lt; 0) {</span>
<span class="nc" id="L1403">                values[i] += 360;</span>
            }
        }
        
        // 20 degree wide bins
<span class="nc" id="L1408">        HistogramHolder hist = Histogram.createSimpleHistogram(20.f, values, </span>
<span class="nc" id="L1409">            Errors.populateYErrorsBySqrt(values));</span>
        
<span class="nc" id="L1411">        int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="nc bnc" id="L1412" title="All 4 branches missed.">        if ((yMaxIdx &gt; -1) &amp;&amp; (hist.getYHist()[yMaxIdx] == 1)) {</span>
<span class="nc" id="L1413">            hist = Histogram.createSimpleHistogram(40.f, values, </span>
<span class="nc" id="L1414">                Errors.populateYErrorsBySqrt(values));</span>
<span class="nc" id="L1415">            yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
        }
        
        float thetaDiff;
<span class="nc bnc" id="L1419" title="All 2 branches missed.">        if (yMaxIdx == -1) {</span>
<span class="nc" id="L1420">            float[] thetaDiffMeanStDev = MiscMath.getAvgAndStDev(values);</span>
<span class="nc" id="L1421">            thetaDiff = thetaDiffMeanStDev[0];</span>
<span class="nc" id="L1422">        } else {</span>
<span class="nc" id="L1423">            thetaDiff = hist.getXHist()[yMaxIdx];</span>
        }
        
        //TODO: consider a bin larger than 20 degrees... 25
<span class="nc" id="L1427">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L1429" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc" id="L1430">            float diffRot = AngleUtil.getAngleDifference(values[i], thetaDiff);</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if (diffRot &gt; 20) {</span>
<span class="nc" id="L1432">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="nc bnc" id="L1436" title="All 2 branches missed.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="nc" id="L1437">            int idx = remove.get(i);</span>
<span class="nc" id="L1438">            compStats.remove(idx);</span>
        }
        
<span class="nc" id="L1441">        return remove;</span>
    }
    
    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats, float rotationInDegrees) {
        
<span class="nc bnc" id="L1447" title="All 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1448">            return null;</span>
        }
        
<span class="nc" id="L1451">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="nc" id="L1453">        float[] values = calculateThetaDiff(compStats);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
            
<span class="nc bnc" id="L1456" title="All 2 branches missed.">            if (values[i] &lt; 0) {</span>
<span class="nc" id="L1457">                values[i] += 360;</span>
            }
            
<span class="nc" id="L1460">            int diffRot = Math.round(AngleUtil.getAngleDifference(values[i], </span>
                rotationInDegrees));
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if (diffRot &gt; 20) {</span>
<span class="nc bnc" id="L1463" title="All 4 branches missed.">                if ((diffRot &lt; 30) &amp;&amp; compStats.get(i).getSumIntensitySqDiff() &lt; 100) {</span>
<span class="nc" id="L1464">                    continue;</span>
                }
<span class="nc" id="L1466">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="nc" id="L1471">            int idx = remove.get(i);</span>
<span class="nc" id="L1472">            compStats.remove(idx);</span>
        }
        
<span class="nc" id="L1475">        return remove;</span>
    }
    
    public static float[] calcIntensitySSDMeanAndStDev(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc" id="L1480">        int n = compStats.size();</span>
        
<span class="fc" id="L1482">        float[] ssds = new float[n];</span>
        
<span class="fc bfc" id="L1484" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L1486">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L1488">            ssds[i] = stat.getSumIntensitySqDiff();</span>
        }
        
<span class="fc" id="L1491">        float[] meanStDv = MiscMath.getAvgAndStDev(ssds);</span>
        
<span class="fc" id="L1493">        return meanStDv;</span>
    }

    public static void removeIntensityOutliers(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (compStats.size() &lt; 3) {</span>
<span class="fc" id="L1499">            return;</span>
        }
        
<span class="fc" id="L1502">        int n = compStats.size();</span>
        
<span class="fc" id="L1504">        float[] meanStDv = calcIntensitySSDMeanAndStDev(compStats);</span>
        
<span class="fc" id="L1506">        List&lt;Integer&gt; rm = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L1510">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L1512">            float diff = Math.abs(stat.getSumIntensitySqDiff() - meanStDv[0]);</span>
            
<span class="fc bfc" id="L1514" title="All 2 branches covered.">            if (diff &gt; (1.25 * meanStDv[1])) {</span>
<span class="fc" id="L1515">                rm.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L1519" title="All 2 branches covered.">        for (int i = rm.size() - 1; i &gt; -1; --i) {</span>
            
<span class="fc" id="L1521">            int idx = rm.get(i).intValue();</span>
            
<span class="fc" id="L1523">            compStats.remove(idx);</span>
        }
<span class="fc" id="L1525">    }</span>

    private int angleForResultDiff(int rot2, int expectedRotationInDegrees) {
                
<span class="fc" id="L1529">        int r0 = rot2 - expectedRotationInDegrees;</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">        if (r0 &lt; 0) {</span>
<span class="fc" id="L1531">            r0 += 360;</span>
        }
        
<span class="fc" id="L1534">        int r = Math.abs(Math.round(AngleUtil.getAngleDifference(r0, rot2)));</span>
        
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">        if (r != expectedRotationInDegrees) {</span>
<span class="nc" id="L1537">            r0 = expectedRotationInDegrees - rot2;</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">            if (r0 &lt; 0) {</span>
<span class="nc" id="L1539">                r0 += 360;</span>
            }
<span class="nc" id="L1541">            r = Math.abs(Math.round(AngleUtil.getAngleDifference(r0, rot2)));</span>
        }
        
<span class="fc" id="L1544">        return r0;</span>
    }

    private CorrespondenceList useBipartiteMatching(float[][] cost,
        Map&lt;PairInt, FeatureComparisonStat&gt; statMap, 
        TransformationParameters params) {

<span class="nc bnc" id="L1551" title="All 2 branches missed.">        if (cost == null) {</span>
<span class="nc" id="L1552">            return null;</span>
        }
        
<span class="nc" id="L1555">        boolean transposed = false;</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        if (cost.length &gt; cost[0].length) {</span>
<span class="nc" id="L1557">            cost = MatrixUtil.transpose(cost);</span>
<span class="nc" id="L1558">            transposed = true;</span>
        }

        // one pass thru to count for array sizes
<span class="nc" id="L1562">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="nc" id="L1563">        int[][] match = b.computeAssignments(cost);</span>

<span class="nc bnc" id="L1565" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="nc" id="L1566">            int idx1 = match[i][0];</span>
<span class="nc" id="L1567">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L1568" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1569">                continue;</span>
            }
<span class="nc bnc" id="L1571" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1572">                int swap = idx1;</span>
<span class="nc" id="L1573">                idx1 = idx2;</span>
<span class="nc" id="L1574">                idx2 = swap;</span>
            }
<span class="nc" id="L1576">            PairInt pI = new PairInt(idx1, idx2);</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">            if (!statMap.containsKey(pI)) {</span>
<span class="nc" id="L1578">                continue;</span>
            }
        }

<span class="nc" id="L1582">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L1583">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="nc" id="L1585">        int nc = 0;</span>

<span class="nc bnc" id="L1587" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="nc" id="L1588">            int idx1 = match[i][0];</span>
<span class="nc" id="L1589">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L1590" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1591">                continue;</span>
            }
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1594">                int swap = idx1;</span>
<span class="nc" id="L1595">                idx1 = idx2;</span>
<span class="nc" id="L1596">                idx2 = swap;</span>
            }

<span class="nc" id="L1599">            PairInt pI = new PairInt(idx1, idx2);</span>
<span class="nc" id="L1600">            FeatureComparisonStat stat = statMap.get(pI);</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">            if (stat == null) {</span>
<span class="nc" id="L1602">                continue;</span>
            }
            
<span class="nc" id="L1605">            int x1 = stat.getImg1Point().getX();</span>
<span class="nc" id="L1606">            int y1 = stat.getImg1Point().getY();</span>
<span class="nc" id="L1607">            matched1.add(new PairInt(x1, y1));</span>
<span class="nc" id="L1608">            int x2 = stat.getImg2Point().getX();</span>
<span class="nc" id="L1609">            int y2 = stat.getImg2Point().getY();</span>
<span class="nc" id="L1610">            matched2.add(new PairInt(x2, y2));</span>

<span class="nc" id="L1612">            nc++;</span>
        }

<span class="nc bnc" id="L1615" title="All 2 branches missed.">        if (matched1.size() &lt; 7) {</span>
<span class="nc" id="L1616">            return null;</span>
        }
        
<span class="nc" id="L1619">        int rangeRotation = Math.round(params.getStandardDeviations()[1]);</span>
<span class="nc" id="L1620">        int rangeTranslationX = Math.round(params.getStandardDeviations()[2]);</span>
<span class="nc" id="L1621">        int rangeTranslationY = Math.round(params.getStandardDeviations()[3]);</span>

<span class="nc" id="L1623">        CorrespondenceList cl = new CorrespondenceList(params.getScale(),</span>
<span class="nc" id="L1624">            Math.round(params.getRotationInDegrees()),</span>
<span class="nc" id="L1625">            Math.round(params.getTranslationX()), Math.round(params.getTranslationY()),</span>
            rangeRotation, rangeTranslationX, rangeTranslationY,
            matched1, matched2);

<span class="nc" id="L1629">        return cl;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">FeatureMatcher.java</span></div><h1>FeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;

<span class="pc bpc" id="L24" title="1 of 2 branches missed.">public class FeatureMatcher {</span>

<span class="fc" id="L26">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L28">    public FeatureMatcher() {</span>
<span class="fc" id="L29">    }</span>

    protected void storeInMap(Map&lt;PairInt, Map&lt;PairInt, 
        Set&lt;FeatureComparisonStat&gt;&gt;&gt; comparisonMap, FeatureComparisonStat stat) {
        
<span class="nc bnc" id="L34" title="All 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L35">            return;</span>
        }
        
<span class="nc bnc" id="L38" title="All 2 branches missed.">        if (comparisonMap == null) {</span>
<span class="nc" id="L39">            throw new IllegalArgumentException(&quot;comparisonMap cannot be null&quot;);</span>
        }
        
<span class="nc" id="L42">        PairInt p1 = stat.getImg1Point();</span>
<span class="nc" id="L43">        PairInt p2 = stat.getImg2Point();</span>
        
<span class="nc" id="L45">        Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt; p1Map = comparisonMap.get(p1);</span>
        
<span class="nc bnc" id="L47" title="All 2 branches missed.">        if (p1Map == null) {</span>
<span class="nc" id="L48">            p1Map = new HashMap&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;();</span>
<span class="nc" id="L49">            comparisonMap.put(p1, p1Map);</span>
        }
        
<span class="nc" id="L52">        Set&lt;FeatureComparisonStat&gt; p2Map = p1Map.get(p2);</span>
        
<span class="nc bnc" id="L54" title="All 2 branches missed.">        if (p2Map == null) {</span>
<span class="nc" id="L55">            p2Map = new HashSet&lt;FeatureComparisonStat&gt;();</span>
<span class="nc" id="L56">            p1Map.put(p2, p2Map);</span>
        }
        
<span class="nc" id="L59">        p2Map.add(stat);</span>
<span class="nc" id="L60">    }</span>

    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param cornerRegion1
     * @param cornerRegion2
     * @param dither
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    protected FeatureComparisonStat ditherAndRotateForCorner1Location(
        Features features1, Features features2, CornerRegion cornerRegion1, 
        CornerRegion cornerRegion2, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
                
<span class="nc" id="L79">        int kMaxIdx1 = cornerRegion1.getKMaxIdx();</span>
<span class="nc" id="L80">        final int x1 = cornerRegion1.getX()[kMaxIdx1];</span>
<span class="nc" id="L81">        final int y1 = cornerRegion1.getY()[kMaxIdx1];</span>
<span class="nc" id="L82">        int rot1 = Math.round(</span>
<span class="nc" id="L83">            cornerRegion1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L85">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="nc" id="L86">        final int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="nc" id="L87">        final int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="nc" id="L88">        int rot2 = Math.round(</span>
<span class="nc" id="L89">            cornerRegion2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L91">        FeatureComparisonStat best = null;</span>
                
<span class="nc" id="L93">        GradientDescriptor gDesc2 = features2.extractGradient(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (gDesc2 == null) {</span>
<span class="nc" id="L96">            return null;</span>
        }
        
        // TODO: could decide not to find best rotation here and just discard
        // false matches due to wrong orientation at end of comparisons
<span class="nc" id="L101">        int[] rotations = new int[10];</span>
<span class="nc" id="L102">        int i = 0;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L104">            rotations[i] = rotD1;</span>
<span class="nc" id="L105">            i++;</span>
        }
<span class="nc" id="L107">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L108">        i++;</span>
<span class="nc" id="L109">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L110">        i++;</span>
<span class="nc" id="L111">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L112">        i++;</span>
        
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L116">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L118">                rotD1 += 360;</span>
            }
<span class="nc bnc" id="L120" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L122">                    continue;</span>
                }
<span class="nc bnc" id="L124" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L126">                        continue;</span>
                    }
                    
<span class="nc" id="L129">                    GradientDescriptor gDesc1 = features1.extractGradient(x1d, </span>
                        y1d, rotD1);
                    
<span class="nc bnc" id="L132" title="All 2 branches missed.">                    if (gDesc1 == null) {</span>
<span class="nc" id="L133">                        continue;</span>
                    }
                       
<span class="nc" id="L136">                    FeatureComparisonStat stat = Features.calculateGradientStats(</span>
                        gDesc1, x1d, y1d, gDesc2, x2, y2);
                   
<span class="nc bnc" id="L139" title="All 2 branches missed.">                    if (stat.getSumGradientSqDiff() &lt; stat.getImg2PointGradientErr()) {</span>
                       
<span class="nc bnc" id="L141" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L142">                            best = stat;</span>
<span class="nc" id="L143">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L144">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L146" title="All 2 branches missed.">                            if (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff()) {</span>
<span class="nc" id="L147">                                best = stat;</span>
<span class="nc" id="L148">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L149">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L157">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param gsImg1
     * @param gsImg2
     * @param features1
     * @param features2
     * @param cornerRegion1
     * @param cornerRegion2
     * @param rotationInRadians
     * @param tolRotationInRadians
     * @param dither
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    protected FeatureComparisonStat ditherAndRotateForCorner1Location(
        GreyscaleImage gsImg1, GreyscaleImage gsImg2, 
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion cornerRegion1, CornerRegion cornerRegion2, 
        float rotationInRadians, float tolRotationInRadians, 
        int dither) throws CornerRegion.CornerRegionDegneracyException {
                
<span class="fc" id="L183">        float expectedRotationInDegrees = rotationInRadians </span>
            * (float)(180./Math.PI);
<span class="fc" id="L185">        final float rotTol = tolRotationInRadians * (float)(180./Math.PI);</span>
                
<span class="fc" id="L187">        int kMaxIdx1 = cornerRegion1.getKMaxIdx();</span>
<span class="fc" id="L188">        final int x1 = cornerRegion1.getX()[kMaxIdx1];</span>
<span class="fc" id="L189">        final int y1 = cornerRegion1.getY()[kMaxIdx1];</span>
<span class="fc" id="L190">        int rot1 = Math.round(</span>
<span class="fc" id="L191">            cornerRegion1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L193">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="fc" id="L194">        final int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="fc" id="L195">        final int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="fc" id="L196">        int rot2 = Math.round(</span>
<span class="fc" id="L197">            cornerRegion2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L199">        FeatureComparisonStat best = null;</span>
                
<span class="fc" id="L201">        IntensityDescriptor desc2 = features2.extractIntensity(gsImg2, x2, y2, rot2);</span>
        
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L204">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="fc" id="L209">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        // TODO: could decide not to find best rotation here and just discard
        // false matches due to wrong orientation at end of comparisons
<span class="fc" id="L214">        int[] rotations = new int[11];</span>
<span class="fc" id="L215">        rotations[0] = angleForResultDiff(rot2, Math.round(expectedRotationInDegrees));</span>
<span class="fc" id="L216">        int i = 1;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L218">            rotations[i] = rotD1;</span>
<span class="fc" id="L219">            i++;</span>
        }
<span class="fc" id="L221">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L222">        i++;</span>
<span class="fc" id="L223">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L224">        i++;</span>
<span class="fc" id="L225">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L226">        i++;</span>
        
<span class="fc bfc" id="L228" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L230">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L232">                rotD1 += 360;</span>
            }
<span class="fc bfc" id="L234" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if (!features1.isWithinXBounds(gsImg1, x1d)) {</span>
<span class="fc" id="L236">                    continue;</span>
                }
<span class="fc bfc" id="L238" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(gsImg1, y1d)) {</span>
<span class="fc" id="L240">                        continue;</span>
                    }
                    
                    // only try rotations within expected rotation limits
<span class="fc" id="L244">                    float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                    if (rotDescriptors &lt; 0) {</span>
<span class="fc" id="L246">                        rotDescriptors += 360;</span>
                    }
<span class="fc" id="L248">                    float rotDiff = AngleUtil.getAngleDifference(</span>
                        expectedRotationInDegrees, rotDescriptors);
<span class="fc bfc" id="L250" title="All 2 branches covered.">                    if (Math.abs(rotDiff) &gt; rotTol) {</span>
<span class="fc" id="L251">                        continue;</span>
                    }
                    
<span class="fc" id="L254">                    IntensityDescriptor desc1 = features1.extractIntensity(</span>
                        gsImg1, x1d, y1d, rotD1);
        
<span class="fc bfc" id="L257" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L258">                        return null;</span>
                    }
                    
<span class="fc" id="L261">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                    
<span class="fc bfc" id="L264" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L266" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L267">                            best = stat;</span>
<span class="fc" id="L268">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L269">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L271" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L272">                                best = stat;</span>
<span class="fc" id="L273">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L274">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L282">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param cornerRegion1
     * @param cornerRegion2
     * @param rotationInRadians
     * @param tolRotationInRadians
     * @param dither
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    protected FeatureComparisonStat ditherAndRotateForCorner1Location(
        Features features1, Features features2, CornerRegion cornerRegion1, 
        CornerRegion cornerRegion2, 
        float rotationInRadians, float tolRotationInRadians, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L305">        float expectedRotationInDegrees = rotationInRadians </span>
            * (float)(180./Math.PI);
<span class="nc" id="L307">        final float rotTol = tolRotationInRadians * (float)(180./Math.PI);</span>
                
<span class="nc" id="L309">        int kMaxIdx1 = cornerRegion1.getKMaxIdx();</span>
<span class="nc" id="L310">        final int x1 = cornerRegion1.getX()[kMaxIdx1];</span>
<span class="nc" id="L311">        final int y1 = cornerRegion1.getY()[kMaxIdx1];</span>
<span class="nc" id="L312">        int rot1 = Math.round(</span>
<span class="nc" id="L313">            cornerRegion1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L315">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="nc" id="L316">        final int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="nc" id="L317">        final int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="nc" id="L318">        int rot2 = Math.round(</span>
<span class="nc" id="L319">            cornerRegion2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L321">        FeatureComparisonStat best = null;</span>
                
<span class="nc" id="L323">        GradientDescriptor gDesc2 = features2.extractGradient(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (gDesc2 == null) {</span>
<span class="nc" id="L326">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="nc" id="L331">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        // TODO: could decide not to find best rotation here and just discard
        // false matches due to wrong orientation at end of comparisons
<span class="nc" id="L336">        int[] rotations = new int[11];</span>
<span class="nc" id="L337">        rotations[0] = angleForResultDiff(rot2, Math.round(expectedRotationInDegrees));</span>
<span class="nc" id="L338">        int i = 1;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L340">            rotations[i] = rotD1;</span>
<span class="nc" id="L341">            i++;</span>
        }
<span class="nc" id="L343">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L344">        i++;</span>
<span class="nc" id="L345">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L346">        i++;</span>
<span class="nc" id="L347">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L348">        i++;</span>
        
<span class="nc bnc" id="L350" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L352">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L354">                rotD1 += 360;</span>
            }
<span class="nc bnc" id="L356" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L358">                    continue;</span>
                }
<span class="nc bnc" id="L360" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L362">                        continue;</span>
                    }
                    
                    // only try rotations within expected rotation limits
<span class="nc" id="L366">                    float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                    if (rotDescriptors &lt; 0) {</span>
<span class="nc" id="L368">                        rotDescriptors += 360;</span>
                    }
<span class="nc" id="L370">                    float rotDiff = AngleUtil.getAngleDifference(</span>
                        expectedRotationInDegrees, rotDescriptors);
<span class="nc bnc" id="L372" title="All 2 branches missed.">                    if (Math.abs(rotDiff) &gt; rotTol) {</span>
<span class="nc" id="L373">                        continue;</span>
                    }
                    
<span class="nc" id="L376">                    GradientDescriptor gDesc1 = features1.extractGradient(x1d, </span>
                        y1d, rotD1);
                    
<span class="nc bnc" id="L379" title="All 2 branches missed.">                    if (gDesc1 == null) {</span>
<span class="nc" id="L380">                        continue;</span>
                    }
                       
<span class="nc" id="L383">                    FeatureComparisonStat stat = Features.calculateGradientStats(</span>
                        gDesc1, x1d, y1d, gDesc2, x2, y2);
                   
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    if (stat.getSumGradientSqDiff() &lt; stat.getImg2PointGradientErr()) {</span>
                       
<span class="nc bnc" id="L388" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L389">                            best = stat;</span>
<span class="nc" id="L390">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L391">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L393" title="All 2 branches missed.">                            if (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff()) {</span>
<span class="nc" id="L394">                                best = stat;</span>
<span class="nc" id="L395">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L396">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L404">        return best;</span>
    }

    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="fc" id="L423">        final int x1 = region1.getX()[1];</span>
<span class="fc" id="L424">        final int y1 = region1.getY()[1];</span>
<span class="fc" id="L425">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L427">        final int x2 = region2.getX()[1];</span>
<span class="fc" id="L428">        final int y2 = region2.getY()[1];</span>
<span class="fc" id="L429">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L431">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="fc" id="L454">        final int x1 = region1.getX()[1];</span>
<span class="fc" id="L455">        final int y1 = region1.getY()[1];</span>
<span class="fc" id="L456">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L458">        final int x2 = region2.getX()[1];</span>
<span class="fc" id="L459">        final int y2 = region2.getY()[1];</span>
<span class="fc" id="L460">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L462">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither, img1, img2);
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L471">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L472">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L473">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L474">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L476">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L477">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L478">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L479">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L481">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither);
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="fc" id="L491">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L492">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L493">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="fc" id="L494">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="fc" id="L496">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L497">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L498">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="fc" id="L499">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L501">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, img1, img2);
    }
    
    /**
     * note that a degreeIntervals &gt; 20 is not recommended
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param degreeIntervals
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither, 
        int degreeIntervals) throws CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L521">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L522">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L523">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L524">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L526">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L527">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L528">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L529">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L531">        int n = 360/degreeIntervals;</span>
<span class="nc" id="L532">        int[] rotations = new int[n];</span>
<span class="nc" id="L533">        int i = 0;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="nc" id="L535">            rotations[i] = rot1 + rotD1;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (rotations[i] &gt; 359) {</span>
<span class="nc" id="L537">                rotations[i] -= 360;</span>
            }
<span class="nc" id="L539">            i++;</span>
        }
        
<span class="nc" id="L542">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param degreeIntervals a value &gt; 20 is not recommended
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither,
        int degreeIntervals) throws CornerRegion.CornerRegionDegneracyException {
     
<span class="nc" id="L563">        final int x1 = region1.getX()[1];</span>
<span class="nc" id="L564">        final int y1 = region1.getY()[1];</span>
<span class="nc" id="L565">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L567">        final int x2 = region2.getX()[1];</span>
<span class="nc" id="L568">        final int y2 = region2.getY()[1];</span>
<span class="nc" id="L569">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L571">        int n = 360/degreeIntervals;</span>
<span class="nc" id="L572">        int[] rotations = new int[n];</span>
<span class="nc" id="L573">        int i = 0;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="nc" id="L575">            rotations[i] = rot1 + rotD1;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            if (rotations[i] &gt; 359) {</span>
<span class="nc" id="L577">                rotations[i] -= 360;</span>
            }
<span class="nc" id="L579">            i++;</span>
        }
        
<span class="nc" id="L582">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @param degreeIntervals a value &gt; 20 is not recommended
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2, int degreeIntervals) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="fc" id="L606">        final int x1 = region1.getX()[1];</span>
<span class="fc" id="L607">        final int y1 = region1.getY()[1];</span>
<span class="fc" id="L608">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L610">        final int x2 = region2.getX()[1];</span>
<span class="fc" id="L611">        final int y2 = region2.getY()[1];</span>
<span class="fc" id="L612">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L614">        int n = 360/degreeIntervals;</span>
<span class="fc" id="L615">        int[] rotations = new int[n];</span>
<span class="fc" id="L616">        int i = 0;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="fc" id="L618">            rotations[i] = rot1 + rotD1;</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (rotations[i] &gt; 359) {</span>
<span class="fc" id="L620">                rotations[i] -= 360;</span>
            }
<span class="fc" id="L622">            i++;</span>
        }
        
<span class="fc" id="L625">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @param degreeIntervals a value &gt; 20 is not recommended
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        GreyscaleImage img1, GreyscaleImage img2, int degreeIntervals) 
        throws CornerRegion.CornerRegionDegneracyException {
     
<span class="nc" id="L649">        final int x1 = region1.getX()[region1.getKMaxIdx()];</span>
<span class="nc" id="L650">        final int y1 = region1.getY()[region1.getKMaxIdx()];</span>
<span class="nc" id="L651">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L653">        final int x2 = region2.getX()[region2.getKMaxIdx()];</span>
<span class="nc" id="L654">        final int y2 = region2.getY()[region2.getKMaxIdx()];</span>
<span class="nc" id="L655">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L657">        int n = 360/degreeIntervals;</span>
<span class="nc" id="L658">        int[] rotations = new int[n];</span>
<span class="nc" id="L659">        int i = 0;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="nc" id="L661">            rotations[i] = rot1 + rotD1;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (rotations[i] &gt; 359) {</span>
<span class="nc" id="L663">                rotations[i] -= 360;</span>
            }
<span class="nc" id="L665">            i++;</span>
        }
        
<span class="nc" id="L668">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
        
<span class="fc" id="L693">        int[] rotations = new int[10];</span>
<span class="fc" id="L694">        int i = 0;</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L696">            rotations[i] = rotD1;</span>
<span class="fc" id="L697">            i++;</span>
        }
<span class="fc" id="L699">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L700">        i++;</span>
<span class="fc" id="L701">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L702">        i++;</span>
<span class="fc" id="L703">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L704">        i++;</span>
        
<span class="fc" id="L706">        return ditherAndRotateForBestLocation(features1, features2, x1, y1, </span>
            rotations, x2, y2, rot2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, GreyscaleImage img1, GreyscaleImage img2) {
        
        
<span class="fc" id="L733">        int[] rotations = new int[10];</span>
<span class="fc" id="L734">        int i = 0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L736">            rotations[i] = rotD1;</span>
<span class="fc" id="L737">            i++;</span>
        }
<span class="fc" id="L739">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L740">        i++;</span>
<span class="fc" id="L741">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L742">        i++;</span>
<span class="fc" id="L743">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L744">        i++;</span>
        
<span class="fc" id="L746">        return ditherAndRotateForBestLocation(features1, features2, x1, y1, </span>
            rotations, x2, y2, rot2, dither, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rotations
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int[] rotations,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
<span class="fc" id="L770">        FeatureComparisonStat best = null;</span>
        
<span class="fc" id="L772">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L775">            return null;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="fc bfc" id="L783" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L785">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L787">                rotD1 += 360;</span>
            }
<span class="fc bfc" id="L789" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L791">                    continue;</span>
                }
<span class="fc bfc" id="L793" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L795">                        continue;</span>
                    }
                    
<span class="fc" id="L798">                    IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rotD1);</span>
        
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">                    if (desc1 == null) {</span>
<span class="nc" id="L801">                        return null;</span>
                    }
                    
<span class="fc" id="L804">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L807" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L809" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L810">                            best = stat;</span>
<span class="fc" id="L811">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L812">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L814" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L815">                                best = stat;</span>
<span class="fc" id="L816">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L817">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L825">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rotations
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int[] rotations,
        final int x2, final int y2, final int rot2,        
        int dither, GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L850">        FeatureComparisonStat best = null;</span>
        
<span class="fc" id="L852">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, </span>
            rot2);
        
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L856">            return null;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L866">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L868">                rotD1 += 360;</span>
            }
<span class="fc bfc" id="L870" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">                if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="fc" id="L872">                    continue;</span>
                }
<span class="fc bfc" id="L874" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="fc" id="L876">                        continue;</span>
                    }
                    
<span class="fc" id="L879">                    IntensityDescriptor desc1 = features1.extractIntensity(img1, </span>
                        x1d, y1d, rotD1);
        
<span class="fc bfc" id="L882" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L883">                        return null;</span>
                    }
                    
<span class="fc" id="L886">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L889" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L891" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L892">                            best = stat;</span>
<span class="fc" id="L893">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L894">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L896" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L897">                                best = stat;</span>
<span class="fc" id="L898">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L899">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L907">        return best;</span>
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        final int expectedRotationInDegrees, final int rotationTol) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L916">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L917">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L918">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L919">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L921">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L922">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L923">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L924">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L926">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, expectedRotationInDegrees,
            rotationTol);
    }
    
    /**
     * 
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        final int expectedRotationInDegrees, final int rotationTol,
        GreyscaleImage img1, GreyscaleImage img2) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="fc" id="L952">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L953">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L954">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="fc" id="L955">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="fc" id="L957">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L958">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L959">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="fc" id="L960">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L962">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, expectedRotationInDegrees,
            rotationTol, img1, img2);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, int expectedRotationInDegrees, final int rotationTol) {
        
<span class="nc" id="L989">        FeatureComparisonStat best = null;</span>
        
<span class="nc" id="L991">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L993" title="All 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L994">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="nc" id="L999">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="nc" id="L1007">        int[] rotations = new int[11];</span>
<span class="nc" id="L1008">        rotations[0] = angleForResultDiff(rot2, expectedRotationInDegrees);</span>
<span class="nc" id="L1009">        int i = 1;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L1011">            rotations[i] = rotD1;</span>
<span class="nc" id="L1012">            i++;</span>
        }
<span class="nc" id="L1014">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L1015">        i++;</span>
<span class="nc" id="L1016">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L1017">        i++;</span>
<span class="nc" id="L1018">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L1019">        i++;</span>
        
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L1023">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L1025">                rotD1 += 360;</span>
            }
            
            // only try rotations within expected rotation limits
<span class="nc" id="L1029">            float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">            if (rotDescriptors &lt; 0) {</span>
<span class="nc" id="L1031">                rotDescriptors += 360;</span>
            }
<span class="nc" id="L1033">            float rotDiff = AngleUtil.getAngleDifference(</span>
                expectedRotationInDegrees, rotDescriptors);
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (Math.abs(rotDiff) &gt; rotationTol) {</span>
<span class="nc" id="L1036">                continue;</span>
            }
            
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L1041">                    continue;</span>
                }
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L1045">                        continue;</span>
                    }
                    
<span class="nc" id="L1048">                    IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rotD1);</span>
        
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                    if (desc1 == null) {</span>
<span class="nc" id="L1051">                        return null;</span>
                    }
                    
<span class="nc" id="L1054">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L1059">                            best = stat;</span>
<span class="nc" id="L1060">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L1061">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L1064">                                best = stat;</span>
<span class="nc" id="L1065">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L1066">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L1074">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @param img1 image from which to extract descriptors for features1
     * @param img2 image from which to extract descriptors for features2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, int expectedRotationInDegrees, final int rotationTol,
        GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="fc" id="L1102">        FeatureComparisonStat best = null;</span>
        
<span class="fc" id="L1104">        IntensityDescriptor desc2 = features2.extractIntensity(img2, x2, y2, </span>
            rot2);
        
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L1108">            return null;</span>
        }
        
        // because anglediff compares closest angles:
<span class="fc bfc" id="L1112" title="All 2 branches covered.">        if (expectedRotationInDegrees &gt; 180.) {</span>
<span class="fc" id="L1113">            expectedRotationInDegrees = 360 - expectedRotationInDegrees;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
                
<span class="fc" id="L1121">        int[] rotations = new int[11];</span>
<span class="fc" id="L1122">        rotations[0] = angleForResultDiff(rot2, expectedRotationInDegrees);</span>
<span class="fc" id="L1123">        int i = 1;</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L1125">            rotations[i] = rotD1;</span>
<span class="fc" id="L1126">            i++;</span>
        }
<span class="fc" id="L1128">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L1129">        i++;</span>
<span class="fc" id="L1130">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L1131">        i++;</span>
<span class="fc" id="L1132">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L1133">        i++;</span>
        
<span class="fc bfc" id="L1135" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L1137">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L1139">                rotD1 += 360;</span>
            }
            
            // only try rotations within expected rotation limits
<span class="fc" id="L1143">            float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">            if (rotDescriptors &lt; 0) {</span>
<span class="fc" id="L1145">                rotDescriptors += 360;</span>
            }
<span class="fc" id="L1147">            float rotDiff = AngleUtil.getAngleDifference(</span>
                expectedRotationInDegrees, rotDescriptors);
<span class="fc bfc" id="L1149" title="All 2 branches covered.">            if (Math.abs(rotDiff) &gt; rotationTol) {</span>
<span class="fc" id="L1150">                continue;</span>
            }
            
<span class="fc bfc" id="L1153" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">                if (!features1.isWithinXBounds(img1, x1d)) {</span>
<span class="fc" id="L1155">                    continue;</span>
                }
<span class="fc bfc" id="L1157" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(img1, y1d)) {</span>
<span class="fc" id="L1159">                        continue;</span>
                    }
                    
<span class="fc" id="L1162">                    IntensityDescriptor desc1 = features1.extractIntensity(img1, </span>
                        x1d, y1d, rotD1);
        
<span class="fc bfc" id="L1165" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L1166">                        return null;</span>
                    }
                    
<span class="fc" id="L1169">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L1172" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L1174">                            best = stat;</span>
<span class="fc" id="L1175">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L1176">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L1178" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L1179">                                best = stat;</span>
<span class="fc" id="L1180">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L1181">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L1189">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither) 
        throws CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L1208">        final int x1 = region1.getX()[1];</span>
<span class="nc" id="L1209">        final int y1 = region1.getY()[1];</span>
<span class="nc" id="L1210">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L1212">        final int x2 = region2.getX()[1];</span>
<span class="nc" id="L1213">        final int y2 = region2.getY()[1];</span>
<span class="nc" id="L1214">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L1216">        return ditherForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither);
    }
    
    public FeatureComparisonStat ditherForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L1225">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L1226">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L1227">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L1228">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L1230">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L1231">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L1232">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L1233">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L1235">        return ditherForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param x1
     * @param y1
     * @param rot1
     * @param x2
     * @param y2
     * @param rot2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
<span class="nc" id="L1260">        FeatureComparisonStat best = null;</span>
        
<span class="nc" id="L1262">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L1264" title="All 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L1265">            return null;</span>
        }
                
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="nc bnc" id="L1273" title="All 2 branches missed.">        for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">            if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L1275">                continue;</span>
            }
<span class="nc bnc" id="L1277" title="All 2 branches missed.">            for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L1279">                    continue;</span>
                }
                    
<span class="nc" id="L1282">                IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rot1);</span>

<span class="nc bnc" id="L1284" title="All 2 branches missed.">                if (desc1 == null) {</span>
<span class="nc" id="L1285">                    return null;</span>
                }

<span class="nc" id="L1288">                FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                    desc1, x1d, y1d, desc2, x2, y2);

<span class="nc bnc" id="L1291" title="All 2 branches missed.">                if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>

<span class="nc bnc" id="L1293" title="All 2 branches missed.">                    if (best == null) {</span>
<span class="nc" id="L1294">                        best = stat;</span>
<span class="nc" id="L1295">                        best.setImg1PointRotInDegrees(rot1);</span>
<span class="nc" id="L1296">                        best.setImg2PointRotInDegrees(rot2);</span>
                    } else {
<span class="nc bnc" id="L1298" title="All 2 branches missed.">                        if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L1299">                            best = stat;</span>
<span class="nc" id="L1300">                            best.setImg1PointRotInDegrees(rot1);</span>
<span class="nc" id="L1301">                            best.setImg2PointRotInDegrees(rot2);</span>
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L1308">        return best;</span>
    }
    
    protected FeatureComparisonStat[] findBestMatch(Features features1, 
        Features features2, CornerRegion cornerRegion1, 
        CornerRegion[] cornerRegions2, int dither) {
        
<span class="nc" id="L1315">        FeatureComparisonStat best = null;</span>
        
        /*
        best3 ranks by intensity ssd only.  sometimes matches areas where
        projection has cause foreground or background changes that appear
        much more strongly in gradient and theta, so intensity alone may
        match, but the other two might not.
        */
<span class="nc" id="L1323">        FeatureComparisonStat best3 = null;</span>
        
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        for (int idx2 = 0; idx2 &lt; cornerRegions2.length; ++idx2) {</span>

<span class="nc" id="L1327">            CornerRegion cornerRegion2 = cornerRegions2[idx2];</span>

<span class="nc bnc" id="L1329" title="All 2 branches missed.">            if (cornerRegion2 == null) {</span>
<span class="nc" id="L1330">                continue;</span>
            }

            try {

                /*
                 for the given corner region1,
                 dither and make small rotation changes to find the 
                 best centering and rotation to minimize the differences
                 in gradient descriptors between cornerRegion1 and cornerRegion2.
                 */
<span class="nc" id="L1341">                FeatureComparisonStat stat = ditherAndRotateForCorner1Location(</span>
                    features1, features2, cornerRegion1, cornerRegion2,
                    dither);
               
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                if (stat != null) {</span>

<span class="nc" id="L1347">                    stat = populateOtherDescriptors(features1, features2, stat,</span>
                        cornerRegion2);
                    
<span class="nc bnc" id="L1350" title="All 2 branches missed.">                    if (stat == null) {</span>
<span class="nc" id="L1351">                        continue;</span>
                    }

<span class="nc" id="L1354">                    int rotD1 = Math.round(stat.getImg1PointRotInDegrees());</span>

<span class="nc" id="L1356">                    int rotD2 = Math.round(</span>
<span class="nc" id="L1357">                        cornerRegion2.getRelativeOrientationInDegrees());</span>

//float diffRot = AngleUtil.getAngleDifference(rotD1, rotD2);
//log.info(&quot;diffRot=&quot; + diffRot + &quot; stat=&quot; + stat.toString());

<span class="nc bnc" id="L1362" title="All 2 branches missed.">                    if (fitIsBetter(best, stat)) {</span>
<span class="nc" id="L1363">                        best = stat;</span>
<span class="nc" id="L1364">                        best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L1365">                        best.setImg2PointRotInDegrees(rotD2);</span>
                    }
                    
<span class="nc bnc" id="L1368" title="All 2 branches missed.">                    if (fitIsBetter3(best3, stat)) {</span>
<span class="nc" id="L1369">                        best3 = stat;</span>
<span class="nc" id="L1370">                        best3.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L1371">                        best3.setImg2PointRotInDegrees(rotD2);</span>
                    }
                }
<span class="nc" id="L1374">            } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
                //log.log(Level.SEVERE, null, ex);
<span class="nc" id="L1376">            }</span>
        }
        
<span class="nc" id="L1379">        int n = 0;</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (best != null) {</span>
<span class="nc" id="L1381">            n++;</span>
        }
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (best3 != null) {</span>
<span class="nc" id="L1384">            n++;</span>
        }
<span class="nc" id="L1386">        FeatureComparisonStat[] result = new FeatureComparisonStat[n];</span>
<span class="nc" id="L1387">        n = 0;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (best != null) {</span>
<span class="nc" id="L1389">            result[n] = best;</span>
<span class="nc" id="L1390">            n++;</span>
        }
<span class="nc bnc" id="L1392" title="All 2 branches missed.">        if (best3 != null) {</span>
<span class="nc" id="L1393">            result[n] = best3;</span>
<span class="nc" id="L1394">            n++;</span>
        }

<span class="nc" id="L1397">        return result;</span>
    }
    
    protected FeatureComparisonStat[] findBestMatch(Features features1, 
        Features features2, CornerRegion cornerRegion1, 
        CornerRegion[] cornerRegions2, 
        float rotationInRadians, float tolRotationInRadians, int dither) {
        
<span class="nc" id="L1405">        FeatureComparisonStat best = null;</span>
        
        /*
        best3 ranks by intensity ssd only.  sometimes matches areas where
        projection has cause foreground or background changes that appear
        much more strongly in gradient and theta, so intensity alone may
        match, but the other two might not.
        */
<span class="nc" id="L1413">        FeatureComparisonStat best3 = null;</span>
        
<span class="nc bnc" id="L1415" title="All 2 branches missed.">        for (int idx2 = 0; idx2 &lt; cornerRegions2.length; ++idx2) {</span>

<span class="nc" id="L1417">            CornerRegion cornerRegion2 = cornerRegions2[idx2];</span>

<span class="nc bnc" id="L1419" title="All 2 branches missed.">            if (cornerRegion2 == null) {</span>
<span class="nc" id="L1420">                continue;</span>
            }

            try {

                /*
                 for the given corner region1,
                 dither and make small rotation changes to find the 
                 best centering and rotation to minimize the differences
                 in gradient descriptors between cornerRegion1 and cornerRegion2.
                */
<span class="nc" id="L1431">                FeatureComparisonStat stat = ditherAndRotateForCorner1Location(</span>
                    features1, features2, cornerRegion1, cornerRegion2,
                    rotationInRadians, tolRotationInRadians, dither);

<span class="nc bnc" id="L1435" title="All 2 branches missed.">                if (stat != null) {</span>

                    //compare all descriptors to find best
<span class="nc" id="L1438">                    int x1 = stat.getImg1Point().getX();</span>
<span class="nc" id="L1439">                    int y1 = stat.getImg1Point().getY();</span>
<span class="nc" id="L1440">                    int rotD1 = Math.round(stat.getImg1PointRotInDegrees());</span>

<span class="nc" id="L1442">                    int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="nc" id="L1443">                    int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="nc" id="L1444">                    int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="nc" id="L1445">                    int rotD2 = Math.round(</span>
<span class="nc" id="L1446">                        cornerRegion2.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L1448">                    IntensityDescriptor iDesc1 = features1.extractIntensity(</span>
                        x1, y1, rotD1);
<span class="nc bnc" id="L1450" title="All 2 branches missed.">                    if (iDesc1 == null) {</span>
<span class="nc" id="L1451">                        continue;</span>
                    }

<span class="nc" id="L1454">                    ThetaDescriptor tDesc1 = features1.extractTheta(</span>
                        x1, y1, rotD1);
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                    if (tDesc1 == null) {</span>
<span class="nc" id="L1457">                        continue;</span>
                    }

<span class="nc" id="L1460">                    GradientDescriptor gDesc1 = features1.extractGradient(</span>
                        x1, y1, rotD1);
<span class="nc bnc" id="L1462" title="All 2 branches missed.">                    if (gDesc1 == null) {</span>
<span class="nc" id="L1463">                        continue;</span>
                    }

<span class="nc" id="L1466">                    IntensityDescriptor iDesc2 = features2.extractIntensity(</span>
                        x2, y2, rotD2);
<span class="nc bnc" id="L1468" title="All 2 branches missed.">                    if (iDesc2 == null) {</span>
<span class="nc" id="L1469">                        continue;</span>
                    }

<span class="nc" id="L1472">                    ThetaDescriptor tDesc2 = features2.extractTheta(</span>
                        x2, y2, rotD2);
<span class="nc bnc" id="L1474" title="All 2 branches missed.">                    if (tDesc2 == null) {</span>
<span class="nc" id="L1475">                        continue;</span>
                    }

<span class="nc" id="L1478">                    GradientDescriptor gDesc2 = features2.extractGradient(</span>
                        x2, y2, rotD2);
<span class="nc bnc" id="L1480" title="All 2 branches missed.">                    if (gDesc2 == null) {</span>
<span class="nc" id="L1481">                        continue;</span>
                    }

<span class="nc" id="L1484">                    stat = Features.calculateStats(iDesc1, gDesc1, tDesc1,</span>
                        x1, y1, iDesc2, gDesc2, tDesc2, x2, y2);

//float diffRot = AngleUtil.getAngleDifference(rotD1, rotD2);
//log.info(&quot;diffRot=&quot; + diffRot + &quot; stat=&quot; + stat.toString());

<span class="nc bnc" id="L1490" title="All 2 branches missed.">                    if (fitIsBetter(best, stat)) {</span>
<span class="nc" id="L1491">                        best = stat;</span>
<span class="nc" id="L1492">                        best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L1493">                        best.setImg2PointRotInDegrees(rotD2);</span>
                    }
                    
<span class="nc bnc" id="L1496" title="All 2 branches missed.">                    if (fitIsBetter3(best3, stat)) {</span>
<span class="nc" id="L1497">                        best3 = stat;</span>
<span class="nc" id="L1498">                        best3.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L1499">                        best3.setImg2PointRotInDegrees(rotD2);</span>
                    }
                }
<span class="nc" id="L1502">            } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
                //log.log(Level.SEVERE, null, ex);
<span class="nc" id="L1504">            }</span>
        }
        
<span class="nc" id="L1507">        int n = 0;</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        if (best != null) {</span>
<span class="nc" id="L1509">            n++;</span>
        }
<span class="nc bnc" id="L1511" title="All 2 branches missed.">        if (best3 != null) {</span>
<span class="nc" id="L1512">            n++;</span>
        }
<span class="nc" id="L1514">        FeatureComparisonStat[] result = new FeatureComparisonStat[n];</span>
<span class="nc" id="L1515">        n = 0;</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">        if (best != null) {</span>
<span class="nc" id="L1517">            result[n] = best;</span>
<span class="nc" id="L1518">            n++;</span>
        }
<span class="nc bnc" id="L1520" title="All 2 branches missed.">        if (best3 != null) {</span>
<span class="nc" id="L1521">            result[n] = best3;</span>
<span class="nc" id="L1522">            n++;</span>
        }

<span class="nc" id="L1525">        return result;</span>
    }

    /**
     * compares best to stat and returns true if stat is better.
     * comparison uses all 3 descriptors, that is intensity, gradient, and
     * theta.
     * @param best
     * @param stat
     * @return 
     */
    protected boolean fitIsBetter(FeatureComparisonStat best, 
        FeatureComparisonStat stat) {
        
<span class="nc bnc" id="L1539" title="All 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L1540">            return false;</span>
        }
        
<span class="nc bnc" id="L1543" title="All 2 branches missed.">        if ((stat.getSumIntensitySqDiff() &lt;= stat.getImg2PointIntensityErr()) &amp;&amp;</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">            (stat.getSumGradientSqDiff() &lt;= stat.getImg2PointGradientErr())</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">            &amp;&amp; (stat.getSumThetaSqDiff() &lt;= stat.getImg2PointThetaErr())</span>
            ) {

<span class="nc bnc" id="L1548" title="All 2 branches missed.">            if (best == null) {</span>
<span class="nc" id="L1549">                return true;</span>
            } else {
<span class="nc" id="L1551">                if (</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">                    (best.getSumIntensitySqDiff() &gt;= stat.getSumIntensitySqDiff())</span>
                    &amp;&amp; 
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                    (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff())</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                    &amp;&amp; (best.getSumThetaSqDiff() &gt; stat.getSumThetaSqDiff())</span>
                    ) {
<span class="nc" id="L1557">                    return true;</span>
                }
            }
        }
        
<span class="nc" id="L1562">        return false;</span>
    }

    /**
     * compares best to stat and returns true if stat is better.
     * comparison checks that all 3 descriptors are smaller than their errors,
     * then uses intensity, gradient to find best.
     * @param best
     * @param stat
     * @return 
     */
    protected boolean fitIsBetter2(FeatureComparisonStat best, 
        FeatureComparisonStat stat) {
        
<span class="nc bnc" id="L1576" title="All 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L1577">            return false;</span>
        }
        
<span class="nc bnc" id="L1580" title="All 2 branches missed.">        if ((stat.getSumIntensitySqDiff() &lt;= stat.getImg2PointIntensityErr()) &amp;&amp;</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">            (stat.getSumGradientSqDiff() &lt;= stat.getImg2PointGradientErr())</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">            &amp;&amp; (stat.getSumThetaSqDiff() &lt;= stat.getImg2PointThetaErr())</span>
            ) {

<span class="nc bnc" id="L1585" title="All 2 branches missed.">            if (best == null) {</span>
<span class="nc" id="L1586">                return true;</span>
            } else {
<span class="nc" id="L1588">                if (</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">                    (best.getSumIntensitySqDiff() &gt;= stat.getSumIntensitySqDiff())</span>
                    &amp;&amp; 
<span class="nc bnc" id="L1591" title="All 2 branches missed.">                    (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff())</span>
                    ) {
<span class="nc" id="L1593">                    return true;</span>
                }
            }
        }
        
<span class="nc" id="L1598">        return false;</span>
    }
    
    /**
     * compares best to stat and returns true if stat is better.
     * comparison checks that all 3 descriptors are smaller than their errors,
     * then uses intensity, gradient to find best.
     * @param best
     * @param stat
     * @return 
     */
    protected boolean fitIsBetter3(FeatureComparisonStat best, 
        FeatureComparisonStat stat) {
        
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L1613">            return false;</span>
        }
        
<span class="nc bnc" id="L1616" title="All 2 branches missed.">        if ((stat.getSumIntensitySqDiff() &lt;= stat.getImg2PointIntensityErr()) &amp;&amp;</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">            (stat.getSumGradientSqDiff() &lt;= stat.getImg2PointGradientErr())</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            &amp;&amp; (stat.getSumThetaSqDiff() &lt;= stat.getImg2PointThetaErr())</span>
            ) {

<span class="nc bnc" id="L1621" title="All 2 branches missed.">            if (best == null) {</span>
<span class="nc" id="L1622">                return true;</span>
            } else {
<span class="nc" id="L1624">                if (</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">                    (best.getSumIntensitySqDiff() &gt;= stat.getSumIntensitySqDiff())</span>
                    ) {
<span class="nc" id="L1627">                    return true;</span>
                }
            }
        }
        
<span class="nc" id="L1632">        return false;</span>
    }

    protected Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; 
        findMatchingFeatures(Features features1, Features features2, 
        CornerRegion[] cornerRegions1, CornerRegion[] cornerRegions2, 
        int blockHalfWidth, boolean useNormalizedIntensities) {
        
        Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt;
<span class="nc" id="L1641">            comparisonMap = new HashMap&lt;PairInt, Map&lt;PairInt, </span>
            Set&lt;FeatureComparisonStat&gt;&gt;&gt;();
                    
<span class="nc" id="L1644">        final int dither = 1;</span>
                
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        for (int idx1 = 0; idx1 &lt; cornerRegions1.length; ++idx1) {</span>
            
<span class="nc" id="L1648">            CornerRegion cornerRegion1 = cornerRegions1[idx1];</span>
            
<span class="nc bnc" id="L1650" title="All 2 branches missed.">            if (cornerRegion1 == null) {</span>
<span class="nc" id="L1651">                continue;</span>
            }
            
<span class="nc" id="L1654">            FeatureComparisonStat[] best = findBestMatch(features1, features2,</span>
                cornerRegion1, cornerRegions2, dither);
            
<span class="nc bnc" id="L1657" title="All 4 branches missed.">            if ((best != null) &amp;&amp; (best.length &gt; 0)) {</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">                for (FeatureComparisonStat stat : best) {</span>
<span class="nc" id="L1659">                    storeInMap(comparisonMap, stat);</span>
                }
            }
        }
        
<span class="nc" id="L1664">        return comparisonMap;</span>
    }
        
    protected Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; 
        findMatchingFeatures(Features features1, Features features2, 
        CornerRegion[] cornerRegions1, CornerRegion[] cornerRegions2, 
        float rotationInRadians, float tolRotationInRadians,
        int blockHalfWidth, boolean useNormalizedIntensities) {
        
        Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt;
<span class="nc" id="L1674">            comparisonMap = new HashMap&lt;PairInt, Map&lt;PairInt, </span>
            Set&lt;FeatureComparisonStat&gt;&gt;&gt;();
                    
<span class="nc" id="L1677">        final int dither = 1;</span>
                
<span class="nc bnc" id="L1679" title="All 2 branches missed.">        for (int idx1 = 0; idx1 &lt; cornerRegions1.length; ++idx1) {</span>
            
<span class="nc" id="L1681">            CornerRegion cornerRegion1 = cornerRegions1[idx1];</span>
            
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            if (cornerRegion1 == null) {</span>
<span class="nc" id="L1684">                continue;</span>
            }

<span class="nc" id="L1687">            FeatureComparisonStat[] best = findBestMatch(features1, features2,</span>
                cornerRegion1, cornerRegions2, rotationInRadians, 
                tolRotationInRadians, dither);
            
<span class="nc bnc" id="L1691" title="All 4 branches missed.">            if ((best != null) &amp;&amp; (best.length &gt; 0)) {</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">                for (FeatureComparisonStat stat : best) {</span>
<span class="nc" id="L1693">                    storeInMap(comparisonMap, stat);</span>
                }
            }
        }
        
<span class="nc" id="L1698">        return comparisonMap;</span>
    }

    public static float[] calculateThetaDiff(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="pc bpc" id="L1703" title="2 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1704">            return null;</span>
        }
        
<span class="fc" id="L1707">        float[] values = new float[compStats.size()];</span>
        
<span class="fc bfc" id="L1709" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="fc" id="L1711">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L1713">            float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L1714">                stat.getImg1PointRotInDegrees(), stat.getImg2PointRotInDegrees());</span>
            
<span class="fc" id="L1716">            values[i] = diff;</span>
        }
        
<span class="fc" id="L1719">        return values;</span>
    }

    public static float calculateDiffThetaMean(List&lt;FeatureComparisonStat&gt; 
        comparisonStats) {
        
<span class="nc" id="L1725">        float[] values = calculateThetaDiff(comparisonStats);</span>
        
<span class="nc bnc" id="L1727" title="All 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="nc" id="L1728">            return Float.POSITIVE_INFINITY;</span>
        }
        
<span class="nc" id="L1731">        double sum = 0;</span>
        
<span class="nc bnc" id="L1733" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc" id="L1734">            sum += values[i];</span>
        }
        
<span class="nc" id="L1737">        return (float) (sum / ((float) values.length));</span>
    }
    
    public CorrespondenceList findSimilarFeatures(GreyscaleImage gsImg1, 
        CornerRegion[] cr1, GreyscaleImage gsImg2, CornerRegion[] cr2, 
        TransformationParameters params, float scaleTol, 
        float rotationInRadiansTol, int transXYTol) { 
        
<span class="nc" id="L1745">        int dither = 1;</span>
        
<span class="nc" id="L1747">        return findSimilarFeatures(gsImg1, cr1, gsImg2, cr2, params, scaleTol, </span>
            rotationInRadiansTol, transXYTol, dither);
    }

    public CorrespondenceList findSimilarFeatures(GreyscaleImage gsImg1, 
        CornerRegion[] cr1, GreyscaleImage gsImg2, 
        CornerRegion[] cr2, TransformationParameters params, float scaleTol, 
        float rotationInRadiansTol, int transXYTol, int dither) {
        
<span class="fc" id="L1756">        List&lt;CornerRegion&gt; filteredTransformedC1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L1757">        List&lt;CornerRegion&gt; filteredC1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L1758">        List&lt;CornerRegion&gt; filteredC2 = new ArrayList&lt;CornerRegion&gt;();</span>
        
<span class="fc" id="L1760">        filterForIntersection3(params, transXYTol, </span>
            cr1, cr2, filteredTransformedC1, filteredC1, filteredC2);
        
        if (true) {
            try {
<span class="fc" id="L1765">                MiscDebug.writeImage(filteredC1, gsImg1.copyToColorGreyscale(),</span>
                    &quot;filtered_1_corners_&quot;);
<span class="fc" id="L1767">                MiscDebug.writeImage(filteredC2, gsImg2.copyToColorGreyscale(), </span>
                    &quot;filtered_2_corners_&quot;);
<span class="nc" id="L1769">            } catch (IOException ex) {</span>
<span class="nc" id="L1770">                Logger.getLogger(FeatureMatcherWrapper.class.getName()).log(</span>
                    Level.SEVERE, null, ex);
<span class="fc" id="L1772">            }</span>
        }
        
        /*
        when transformation params are known ahead of time:
        cr1 can be transformed into crTr1 (including the internal points).
        then the matching is faster than n1 * n2 because can discard some 
        possible matches immediately.
        bipartite matching when points are present within tolerance.
        
        bipartite is n^3 but the n is &lt; n1.
        */
       
<span class="fc" id="L1785">        final int blockHalfWidth = 5;</span>
<span class="fc" id="L1786">        final boolean useNormalizedIntensities = true;</span>
        
<span class="fc" id="L1788">        IntensityFeatures features1 = new IntensityFeatures(blockHalfWidth, </span>
            useNormalizedIntensities);
        
<span class="fc" id="L1791">        IntensityFeatures features2 = new IntensityFeatures(blockHalfWidth,</span>
            useNormalizedIntensities);
        
        //Features features1 = new Features(gsImg1, gXY1, theta1, blockHalfWidth, 
        //    useNormalizedIntensities);
        //
        //Features features2 = new Features(gsImg2, gXY2, theta2, blockHalfWidth, 
        //    useNormalizedIntensities);
        
<span class="fc" id="L1800">        int n1 = filteredC1.size();</span>
<span class="fc" id="L1801">        int n2 = filteredC2.size();</span>
<span class="fc" id="L1802">        int nMaxMatchable = Math.min(n1, n2);</span>
        
<span class="fc" id="L1804">        Map&lt;PairInt, FeatureComparisonStat&gt; statMap = null;</span>
<span class="fc" id="L1805">        float[][] cost = null;</span>
                
<span class="fc bfc" id="L1807" title="All 2 branches covered.">        final boolean useBipartite = (nMaxMatchable &lt; 251);</span>
        
<span class="fc" id="L1809">        Map&lt;Integer, Integer&gt; index1Map = null;</span>
<span class="fc" id="L1810">        Map&lt;Integer, Set&lt;Integer&gt;&gt; index2Map = null;</span>
<span class="fc" id="L1811">        Map&lt;Integer, FeatureComparisonStat&gt; index1StatMap = null;</span>
        
<span class="fc bfc" id="L1813" title="All 2 branches covered.">        if (useBipartite) {</span>
<span class="fc" id="L1814">            cost = new float[n1][n2];</span>
<span class="fc" id="L1815">            statMap = new HashMap&lt;PairInt, FeatureComparisonStat&gt;();</span>
        } else {
<span class="fc" id="L1817">            index1Map = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L1818">            index2Map = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L1819">            index1StatMap = new HashMap&lt;Integer, FeatureComparisonStat&gt;();</span>
        }
                
<span class="fc" id="L1822">        int count = 0;</span>
        
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n1; ++i1) {</span>
            
<span class="fc bfc" id="L1826" title="All 2 branches covered.">            if (useBipartite) {</span>
<span class="fc" id="L1827">                cost[i1] = new float[n2];</span>
<span class="fc" id="L1828">                Arrays.fill(cost[i1], Float.MAX_VALUE);</span>
            }
            
<span class="fc" id="L1831">            CornerRegion c1Tr = filteredTransformedC1.get(i1);</span>
<span class="fc" id="L1832">            CornerRegion c1 = filteredC1.get(i1);</span>
            
<span class="fc" id="L1834">            int x1Tr = c1Tr.getX()[c1Tr.getKMaxIdx()];</span>
<span class="fc" id="L1835">            int y1Tr = c1Tr.getY()[c1Tr.getKMaxIdx()];</span>
            
<span class="fc" id="L1837">            int x1 = c1.getX()[c1.getKMaxIdx()];</span>
<span class="fc" id="L1838">            int y1 = c1.getY()[c1.getKMaxIdx()];</span>
            
<span class="fc" id="L1840">            double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L1841">            int bestIdx2 = -1;</span>
<span class="fc" id="L1842">            FeatureComparisonStat bestStat = null;</span>
            
<span class="fc bfc" id="L1844" title="All 2 branches covered.">            for (int i2 = 0; i2 &lt; n2; ++i2) {</span>
                
<span class="fc" id="L1846">                CornerRegion c2 = filteredC2.get(i2);</span>
                
<span class="fc" id="L1848">                int x2 = c2.getX()[c2.getKMaxIdx()];</span>
<span class="fc" id="L1849">                int y2 = c2.getY()[c2.getKMaxIdx()];</span>
                                
<span class="fc" id="L1851">                int diffX = Math.abs(x1Tr - x2);</span>
<span class="fc" id="L1852">                int diffY = Math.abs(y1Tr - y2);</span>
<span class="fc bfc" id="L1853" title="All 4 branches covered.">                if (diffX &gt; transXYTol || diffY &gt; transXYTol) {</span>
<span class="fc" id="L1854">                    continue;</span>
                }
                
                try {
                  
                    // use the untransformed cr1 to be able to filter by rotation
<span class="fc" id="L1860">                    FeatureComparisonStat stat = ditherAndRotateForCorner1Location(</span>
                        gsImg1, gsImg2, features1, features2, c1, c2,
<span class="fc" id="L1862">                        params.getRotationInRadians(), rotationInRadiansTol, dither);</span>
                    
<span class="fc bfc" id="L1864" title="All 2 branches covered.">                    if (stat != null &amp;&amp; </span>
<span class="pc bpc" id="L1865" title="1 of 2 branches missed.">                        (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr())) {</span>

<span class="fc bfc" id="L1867" title="All 2 branches covered.">                        if (useBipartite) {</span>
<span class="fc" id="L1868">                            cost[i1][i2] = stat.getSumIntensitySqDiff();</span>
<span class="fc" id="L1869">                            PairInt p = new PairInt(i1, i2);</span>
<span class="fc" id="L1870">                            statMap.put(p, stat);</span>
<span class="fc" id="L1871">                        } else {</span>
<span class="fc bfc" id="L1872" title="All 4 branches covered.">                            if ((bestIdx2 == -1) || (bestCost &gt; stat.getSumIntensitySqDiff())) {</span>
<span class="fc" id="L1873">                                bestIdx2 = i2;</span>
<span class="fc" id="L1874">                                bestCost = stat.getSumIntensitySqDiff();</span>
<span class="fc" id="L1875">                                bestStat = stat;</span>
<span class="fc" id="L1876">                                bestStat.setIndex1(i1);</span>
<span class="fc" id="L1877">                                bestStat.setIndex2(i2);</span>
                            }
                        }
                        
<span class="fc" id="L1881">                        count++;</span>
                    }
                    
<span class="fc" id="L1884">                } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L1885">                    log.fine(ex.getMessage());</span>
<span class="fc" id="L1886">                }</span>
            }
            
<span class="fc bfc" id="L1889" title="All 4 branches covered.">            if (!useBipartite &amp;&amp; (bestStat != null)) {</span>
<span class="fc" id="L1890">                Integer key1 = Integer.valueOf(i1);</span>
<span class="fc" id="L1891">                Integer key2 = Integer.valueOf(bestIdx2);</span>
<span class="fc" id="L1892">                index1Map.put(key1, key2);</span>
<span class="fc" id="L1893">                Set&lt;Integer&gt; set = index2Map.get(key2);</span>
<span class="fc bfc" id="L1894" title="All 2 branches covered.">                if (set == null) {</span>
<span class="fc" id="L1895">                    set = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1896">                    index2Map.put(key2, set);</span>
                }
<span class="fc" id="L1898">                set.add(key1);</span>
                
<span class="fc" id="L1900">                index1StatMap.put(key1, bestStat);</span>
            }
        }
        
<span class="fc bfc" id="L1904" title="All 2 branches covered.">        if (useBipartite) {</span>
<span class="fc" id="L1905">            return useBipartiteMatching(cost, statMap, params);</span>
        }
        
        // resolve any double matchings, but discard the higher cost matches
        //   from conflicted matches rather than re-trying a solution for them
        
<span class="fc" id="L1911">        Set&lt;Integer&gt; resolved = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : index2Map.entrySet()) {</span>
<span class="fc bfc" id="L1913" title="All 2 branches covered.">            if (resolved.contains(entry.getKey())) {</span>
<span class="fc" id="L1914">                continue;</span>
            }
<span class="fc" id="L1916">            Set&lt;Integer&gt; set = entry.getValue();</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">            if (set.size() &gt; 1) {</span>
<span class="fc" id="L1918">                double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L1919">                Integer bestIndex1 = -1;</span>
<span class="fc bfc" id="L1920" title="All 2 branches covered.">                for (Integer index1 : set) {</span>
<span class="fc" id="L1921">                    FeatureComparisonStat fcs = index1StatMap.get(index1);</span>
<span class="pc bpc" id="L1922" title="3 of 4 branches missed.">                    assert(fcs != null);</span>
<span class="fc" id="L1923">                    double cost2 = fcs.getSumIntensitySqDiff();</span>
<span class="fc bfc" id="L1924" title="All 2 branches covered.">                    if (cost2 &lt; bestCost) {</span>
<span class="fc" id="L1925">                        bestCost = cost2;</span>
<span class="fc" id="L1926">                        bestIndex1 = index1;</span>
                    }
<span class="fc" id="L1928">                    resolved.add(index1);</span>
<span class="fc" id="L1929">                }</span>
<span class="fc bfc" id="L1930" title="All 2 branches covered.">                for (Integer index1 : set) {</span>
<span class="fc bfc" id="L1931" title="All 2 branches covered.">                    if (index1.equals(bestIndex1)) {</span>
<span class="fc" id="L1932">                        continue;</span>
                    }
<span class="fc" id="L1934">                    index1Map.remove(index1);</span>
<span class="fc" id="L1935">                    index1StatMap.remove(index1);</span>
<span class="fc" id="L1936">                }</span>
            }
<span class="fc" id="L1938">        }</span>
        
<span class="fc" id="L1940">        int nc = index1StatMap.size();</span>
        
<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">        if (nc &lt; 7) {</span>
<span class="nc" id="L1943">            return null;</span>
        }
        
        //PairIntArray matchedXY1 = new PairIntArray(nc);
        //PairIntArray matchedXY2 = new PairIntArray(nc);
        
<span class="fc" id="L1949">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L1950">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>

<span class="fc" id="L1952">        float[] weights = new float[nc];</span>
<span class="fc" id="L1953">        double sumW = 0;</span>

<span class="fc" id="L1955">        nc = 0;</span>
<span class="fc bfc" id="L1956" title="All 2 branches covered.">        for (Entry&lt;Integer, FeatureComparisonStat&gt; entry : index1StatMap.entrySet()) {</span>
<span class="fc" id="L1957">            FeatureComparisonStat fcs = entry.getValue();</span>
<span class="fc" id="L1958">            int idx1 = fcs.getIndex1();</span>
<span class="fc" id="L1959">            int idx2 = fcs.getIndex2();</span>
<span class="fc" id="L1960">            PairInt p1 = fcs.getImg1Point();</span>
<span class="fc" id="L1961">            PairInt p2 = fcs.getImg2Point();</span>
<span class="fc" id="L1962">            matched1.add(p1.copy());</span>
<span class="fc" id="L1963">            matched2.add(p2.copy());</span>
<span class="fc" id="L1964">            weights[nc] = fcs.getSumIntensitySqDiff();</span>
<span class="fc" id="L1965">            sumW += weights[nc];</span>
<span class="fc" id="L1966">            nc++;</span>
<span class="fc" id="L1967">        }</span>
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">        if (sumW &gt; 0) {</span>
<span class="fc" id="L1969">            double tot = 0;</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">            for (int i = 0; i &lt; nc; ++i) {</span>
<span class="fc" id="L1971">                double div = (sumW - weights[i]) / ((nc - 1) * sumW);</span>
<span class="fc" id="L1972">                weights[i] = (float) div;</span>
<span class="fc" id="L1973">                tot += div;</span>
            }
<span class="pc bpc" id="L1975" title="3 of 4 branches missed.">            assert (Math.abs(tot - 1.) &lt; 0.03);</span>
<span class="fc" id="L1976">        } else {</span>
<span class="nc" id="L1977">            float a = 1.f / (float) nc;</span>
<span class="nc" id="L1978">            Arrays.fill(weights, a);</span>
        }

<span class="fc" id="L1981">        int rangeRotation = Math.round(params.getStandardDeviations()[1]);</span>
<span class="fc" id="L1982">        int rangeTranslationX = Math.round(params.getStandardDeviations()[2]);</span>
<span class="fc" id="L1983">        int rangeTranslationY = Math.round(params.getStandardDeviations()[3]);</span>

<span class="fc" id="L1985">        CorrespondenceList cl = new CorrespondenceList(params.getScale(),</span>
<span class="fc" id="L1986">            Math.round(params.getRotationInDegrees()),</span>
<span class="fc" id="L1987">            Math.round(params.getTranslationX()), Math.round(params.getTranslationY()),</span>
            rangeRotation, rangeTranslationX, rangeTranslationY,
            matched1, matched2);

<span class="fc" id="L1991">        return cl;</span>
    }

    public CorrespondenceList findSimilarFeatures(GreyscaleImage gsImg1, 
        GreyscaleImage gXY1, GreyscaleImage theta1, CornerRegion[] cr1, 
        GreyscaleImage gsImg2, GreyscaleImage gXY2, GreyscaleImage theta2, 
        CornerRegion[] cr2, float scale, float rotationInRadians, 
        float scaleTol, float rotationInRadiansTol) {
        
        /*
        for this one, the rotation can be used in the feature matcher
        to discard some pairs
        */
        
<span class="nc bnc" id="L2005" title="All 2 branches missed.">        if (gsImg1 == null) {</span>
<span class="nc" id="L2006">            throw new IllegalArgumentException(&quot;gsImg1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2008" title="All 2 branches missed.">        if (gsImg2 == null) {</span>
<span class="nc" id="L2009">            throw new IllegalArgumentException(&quot;gsImg2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        if (gXY1 == null) {</span>
<span class="nc" id="L2012">            throw new IllegalArgumentException(&quot;gXY1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2014" title="All 2 branches missed.">        if (gXY2 == null) {</span>
<span class="nc" id="L2015">            throw new IllegalArgumentException(&quot;gXY2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2017" title="All 2 branches missed.">        if (theta1 == null) {</span>
<span class="nc" id="L2018">            throw new IllegalArgumentException(&quot;theta1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2020" title="All 2 branches missed.">        if (theta2 == null) {</span>
<span class="nc" id="L2021">            throw new IllegalArgumentException(&quot;theta2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2023" title="All 2 branches missed.">        if (cr1 == null) {</span>
<span class="nc" id="L2024">            throw new IllegalArgumentException(&quot;cr1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2026" title="All 2 branches missed.">        if (cr2 == null) {</span>
<span class="nc" id="L2027">            throw new IllegalArgumentException(&quot;cr2 cannot be null&quot;);</span>
        }
        
<span class="nc" id="L2030">        int blockHalfWidth = 5;</span>
<span class="nc" id="L2031">        boolean useNormalizedIntensities = true;</span>
        
        //NOTE: scale was not used in the feature descriptors, but
        // should be in the future.  For large scale factor, would want to
        // scale the grid sizes in the descriptor
        
<span class="nc" id="L2037">        Features features1 = new Features(gsImg1, gXY1, theta1, blockHalfWidth, </span>
            useNormalizedIntensities);
        
<span class="nc" id="L2040">        Features features2 = new Features(gsImg2, gXY2, theta2, blockHalfWidth, </span>
            useNormalizedIntensities);
        
<span class="nc" id="L2043">        Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; matchingMap =</span>
<span class="nc" id="L2044">            findMatchingFeatures(features1, features2, cr1, cr2, </span>
            rotationInRadians, rotationInRadiansTol, blockHalfWidth, 
            useNormalizedIntensities);
        
        // a quick rough look at the most frequent parameters of euclidean
        // transformations.
        
        //TODO: this may need alot of adjustment, espec for histogram bin sizes.
        
<span class="nc" id="L2053">        List&lt;PairInt&gt; points1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L2054">        List&lt;PairInt&gt; points2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L2055">        List&lt;Integer&gt; rotations = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2056">        List&lt;Integer&gt; translationsX = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2057">        List&lt;Integer&gt; translationsY = new ArrayList&lt;Integer&gt;();</span>
        
        for (Entry&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; entry 
<span class="nc bnc" id="L2060" title="All 2 branches missed.">            : matchingMap.entrySet()) {</span>
            
<span class="nc" id="L2062">            PairInt p1 = entry.getKey();</span>
            
<span class="nc" id="L2064">            Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt; p2Map = entry.getValue();</span>
            
<span class="nc bnc" id="L2066" title="All 2 branches missed.">            for (Entry&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt; entry2 : p2Map.entrySet()) {</span>
                
<span class="nc" id="L2068">                PairInt p2 = entry2.getKey();</span>
                
                //TODO: consider only writing all best solutions if they
                // are different here:
                
<span class="nc bnc" id="L2073" title="All 2 branches missed.">                for (FeatureComparisonStat stat : entry2.getValue()) {</span>
                   
<span class="nc" id="L2075">                    float rotation = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L2076">                        stat.getImg2PointRotInDegrees(), </span>
<span class="nc" id="L2077">                        stat.getImg1PointRotInDegrees());</span>
                    
<span class="nc bnc" id="L2079" title="All 2 branches missed.">                    if (rotation &lt; 0) {</span>
<span class="nc" id="L2080">                        rotation += 360;</span>
                    }
<span class="nc" id="L2082">                    double rotationRadians = rotation * Math.PI/180.;</span>
                    
<span class="nc" id="L2084">                    double cosine = Math.cos(rotationRadians);</span>
<span class="nc" id="L2085">                    double sine = Math.sin(rotationRadians);</span>
                    
                    //given scale and rotation, can calculate implied rotation
<span class="nc" id="L2088">                    double xr = (p1.getX() * scale * cosine)</span>
<span class="nc" id="L2089">                        + (p1.getY() * scale * sine);</span>

<span class="nc" id="L2091">                    double yr = -(p1.getX() * scale * sine)</span>
<span class="nc" id="L2092">                        + (p1.getY() * scale * cosine);</span>

<span class="nc" id="L2094">                    int xt = Math.round(p2.getX() - (float)xr);</span>
<span class="nc" id="L2095">                    int yt = Math.round(p2.getY() - (float)yr);</span>
                    
<span class="nc" id="L2097">                    rotations.add(Integer.valueOf(Math.round(rotation)));</span>
<span class="nc" id="L2098">                    translationsX.add(Integer.valueOf(xt));</span>
<span class="nc" id="L2099">                    translationsY.add(Integer.valueOf(yt));</span>
<span class="nc" id="L2100">                    points1.add(p1);</span>
<span class="nc" id="L2101">                    points2.add(p2);</span>
<span class="nc" id="L2102">                }</span>
<span class="nc" id="L2103">            }</span>
<span class="nc" id="L2104">        }</span>
        
<span class="nc" id="L2106">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L2107">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="nc" id="L2109">        HistogramHolder rHist = Histogram.createSimpleHistogram(20, rotations);</span>
<span class="nc" id="L2110">        List&lt;Integer&gt; subsetRotation = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2111">        List&lt;Integer&gt; subsetTransX = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2112">        List&lt;Integer&gt; subsetTransY = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2113">        List&lt;PairInt&gt; subsetPoints1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L2114">        List&lt;PairInt&gt; subsetPoints2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L2115">        int yMaxIdx = MiscMath.findYMaxIndex(rHist.getYHist());</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">        if (yMaxIdx != -1) {</span>
<span class="nc" id="L2117">            float rotMax = rHist.getXHist()[yMaxIdx];</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            for (int i = 0; i &lt; rotations.size(); ++i) {</span>
<span class="nc" id="L2119">                float rot = rotations.get(i);</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">                if (Math.abs(rot - rotMax) &lt;= 20) {</span>
<span class="nc" id="L2121">                    subsetRotation.add(Math.round(rot));</span>
<span class="nc" id="L2122">                    subsetTransX.add(translationsX.get(i));</span>
<span class="nc" id="L2123">                    subsetTransY.add(translationsY.get(i));</span>
<span class="nc" id="L2124">                    subsetPoints1.add(points1.get(i));</span>
<span class="nc" id="L2125">                    subsetPoints2.add(points2.get(i));</span>
                }
            }
            // A general euclidean transformation (possibly varying across
            // image due to projection effects) is needed to determine if
            // points are matched.
            
            // quick look at results to decide if need to use statistics of
            // fit here (as weights) or whether frequency of values is enough.
            
<span class="nc" id="L2135">            HistogramHolder txHist = Histogram.createSimpleHistogram(50, subsetTransX);</span>
            try {
<span class="nc" id="L2137">                txHist.plotHistogram(&quot;translationX&quot;, MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L2138">            } catch (IOException ex) {</span>
<span class="nc" id="L2139">                Logger.getLogger(FeatureMatcher.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L2140">            }</span>
<span class="nc" id="L2141">            int yMaxIdx2 = MiscMath.findYMaxIndex(txHist.getYHist());</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">            if (yMaxIdx2 != -1) {</span>
<span class="nc" id="L2143">                float txMax = txHist.getXHist()[yMaxIdx2];</span>
<span class="nc" id="L2144">                float txFWHM = Histogram.measureFWHM(txHist, yMaxIdx2);</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">                if (txFWHM &lt; 50) {</span>
<span class="nc" id="L2146">                    txFWHM = 50;</span>
                }
<span class="nc" id="L2148">                List&lt;Integer&gt; subset2Rotation = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2149">                List&lt;Integer&gt; subset2TransX = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2150">                List&lt;Integer&gt; subset2TransY = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L2151">                List&lt;PairInt&gt; subset2Points1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L2152">                List&lt;PairInt&gt; subset2Points2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2153" title="All 2 branches missed.">                for (int i = 0; i &lt; subsetTransX.size(); ++i) {</span>
<span class="nc" id="L2154">                    int tx = subsetTransX.get(i);</span>
<span class="nc bnc" id="L2155" title="All 2 branches missed.">                    if (Math.abs(tx - txMax) &lt;= (txFWHM/2.f)) {</span>
<span class="nc" id="L2156">                        subset2Rotation.add(subsetRotation.get(i));</span>
<span class="nc" id="L2157">                        subset2TransX.add(tx);</span>
<span class="nc" id="L2158">                        subset2TransY.add(subsetTransY.get(i));</span>
<span class="nc" id="L2159">                        subset2Points1.add(subsetPoints1.get(i));</span>
<span class="nc" id="L2160">                        subset2Points2.add(subsetPoints2.get(i));</span>
                    }
                }
<span class="nc" id="L2163">                HistogramHolder tyHist = Histogram.createSimpleHistogram(50, subset2TransY);</span>
                try {
<span class="nc" id="L2165">                    tyHist.plotHistogram(&quot;translationY&quot;, MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L2166">                } catch (IOException ex) {</span>
<span class="nc" id="L2167">                    Logger.getLogger(FeatureMatcher.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L2168">                }</span>
<span class="nc" id="L2169">                int yMaxIdx3 = MiscMath.findYMaxIndex(tyHist.getYHist());</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">                if (yMaxIdx3 != -1) {</span>
<span class="nc" id="L2171">                    float tyMax = tyHist.getXHist()[yMaxIdx3];</span>
<span class="nc" id="L2172">                    float tyFWHM = Histogram.measureFWHM(tyHist, yMaxIdx3);</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">                    if (tyFWHM &lt; 50) {</span>
<span class="nc" id="L2174">                        tyFWHM = 50;</span>
                    }
                    
<span class="nc" id="L2177">                    log.info(&quot;solution rotation=&quot; + rotMax + &quot;+-20 &quot;</span>
                    + &quot; translationX=&quot; + txMax + &quot;+-&quot; + (txFWHM/2.)
                    + &quot; translationY=&quot; + tyMax + &quot;+=&quot; + (tyFWHM/2.));
<span class="nc bnc" id="L2180" title="All 2 branches missed.">                    for (int i = 0; i &lt; subset2TransY.size(); ++i) {</span>
<span class="nc" id="L2181">                        int ty = subset2TransY.get(i);</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">                        if (Math.abs(ty - tyMax) &lt;= (tyFWHM/2.f)) {</span>
<span class="nc" id="L2183">                            matched1.add(subset2Points1.get(i));</span>
<span class="nc" id="L2184">                            matched2.add(subset2Points2.get(i));</span>
                        }
                    } 
                   
<span class="nc" id="L2188">                    CorrespondenceList cl = new CorrespondenceList(</span>
                        scale, 
<span class="nc" id="L2190">                        Math.round(rotMax), Math.round(txMax), Math.round(tyMax),</span>
<span class="nc" id="L2191">                        20, Math.round(txFWHM), Math.round(tyFWHM), </span>
                        matched1, matched2);
                    
<span class="nc" id="L2194">                    return cl;</span>
                }
            }
        }
        
<span class="nc" id="L2199">        return null;</span>
    }

    private FeatureComparisonStat populateOtherDescriptors(Features 
        features1, Features features2, FeatureComparisonStat stat, 
        CornerRegion cornerRegion2) throws CornerRegion.CornerRegionDegneracyException {

<span class="nc bnc" id="L2206" title="All 2 branches missed.">        if (features1 == null) {</span>
<span class="nc" id="L2207">            throw new IllegalArgumentException(&quot;features1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2209" title="All 2 branches missed.">        if (features2 == null) {</span>
<span class="nc" id="L2210">            throw new IllegalArgumentException(&quot;features2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2212" title="All 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L2213">            throw new IllegalArgumentException(&quot;stat cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2215" title="All 2 branches missed.">        if (cornerRegion2 == null) {</span>
<span class="nc" id="L2216">            throw new IllegalArgumentException(&quot;cornerRegion2 cannot be null&quot;);</span>
        }
        
        //compare all descriptors to find best
<span class="nc" id="L2220">        int x1 = stat.getImg1Point().getX();</span>
<span class="nc" id="L2221">        int y1 = stat.getImg1Point().getY();</span>
<span class="nc" id="L2222">        int rotD1 = Math.round(stat.getImg1PointRotInDegrees());</span>

<span class="nc" id="L2224">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="nc" id="L2225">        int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="nc" id="L2226">        int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="nc" id="L2227">        int rotD2 = Math.round(</span>
<span class="nc" id="L2228">            cornerRegion2.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L2230">        IntensityDescriptor iDesc1 = features1.extractIntensity(</span>
            x1, y1, rotD1);
<span class="nc bnc" id="L2232" title="All 2 branches missed.">        if (iDesc1 == null) {</span>
<span class="nc" id="L2233">            return null;</span>
        }

<span class="nc" id="L2236">        ThetaDescriptor tDesc1 = features1.extractTheta(</span>
            x1, y1, rotD1);
<span class="nc bnc" id="L2238" title="All 2 branches missed.">        if (tDesc1 == null) {</span>
<span class="nc" id="L2239">            return null;</span>
        }

<span class="nc" id="L2242">        GradientDescriptor gDesc1 = features1.extractGradient(</span>
            x1, y1, rotD1);
<span class="nc bnc" id="L2244" title="All 2 branches missed.">        if (gDesc1 == null) {</span>
<span class="nc" id="L2245">            return null;</span>
        }

<span class="nc" id="L2248">        IntensityDescriptor iDesc2 = features2.extractIntensity(</span>
            x2, y2, rotD2);
<span class="nc bnc" id="L2250" title="All 2 branches missed.">        if (iDesc2 == null) {</span>
<span class="nc" id="L2251">            return null;</span>
        }

<span class="nc" id="L2254">        ThetaDescriptor tDesc2 = features2.extractTheta(</span>
            x2, y2, rotD2);
<span class="nc bnc" id="L2256" title="All 2 branches missed.">        if (tDesc2 == null) {</span>
<span class="nc" id="L2257">            return null;</span>
        }

<span class="nc" id="L2260">        GradientDescriptor gDesc2 = features2.extractGradient(</span>
            x2, y2, rotD2);
<span class="nc bnc" id="L2262" title="All 2 branches missed.">        if (gDesc2 == null) {</span>
<span class="nc" id="L2263">            return null;</span>
        }

<span class="nc" id="L2266">        return Features.calculateStats(iDesc1, gDesc1, tDesc1,</span>
            x1, y1, iDesc2, gDesc2, tDesc2, x2, y2);
    }
    
    public static &lt;T extends CornerRegion&gt; void filterForIntersection(
        TransformationParameters params, float toleranceXY,
        List&lt;List&lt;T&gt;&gt; c1, List&lt;List&lt;T&gt;&gt; c2, 
        List&lt;List&lt;T&gt;&gt; outFilteredTransformedC1,
        List&lt;List&lt;T&gt;&gt; outFilteredC1, 
        List&lt;List&lt;T&gt;&gt; outFilteredC2) {
        
<span class="fc" id="L2277">        float[] minXY2 = MiscMath.findMinXY(c2);</span>
<span class="fc" id="L2278">        float[] maxXY2 = MiscMath.findMaxXY(c2);</span>
        
<span class="fc" id="L2280">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L2282">        float[] minXY1 = new float[]{Float.MAX_VALUE, Float.MAX_VALUE};</span>
<span class="fc" id="L2283">        float[] maxXY1 = new float[]{Float.MIN_VALUE, Float.MIN_VALUE};</span>
   
<span class="fc bfc" id="L2285" title="All 2 branches covered.">        for (int i = 0; i &lt; c1.size(); ++i) {</span>
<span class="fc" id="L2286">            List&lt;T&gt; outList = new ArrayList&lt;T&gt;();</span>
<span class="fc" id="L2287">            List&lt;T&gt; listTr = new ArrayList&lt;T&gt;();</span>
<span class="fc" id="L2288">            List&lt;T&gt; list = c1.get(i);</span>
<span class="fc bfc" id="L2289" title="All 2 branches covered.">            for (int j = 0; j &lt; list.size(); ++j) {</span>
                
<span class="fc" id="L2291">                T ctr = transformer.applyTransformation(params, </span>
<span class="fc" id="L2292">                    list.get(j));</span>
                
<span class="fc" id="L2294">                int x = ctr.getX()[ctr.getKMaxIdx()];</span>
<span class="fc" id="L2295">                int y = ctr.getY()[ctr.getKMaxIdx()];</span>
                
<span class="fc bfc" id="L2297" title="All 4 branches covered.">                if ((x &lt; (minXY2[0] - toleranceXY)) || (x &gt; (maxXY2[0] + toleranceXY))) {</span>
<span class="fc" id="L2298">                    continue;</span>
                }
<span class="pc bpc" id="L2300" title="2 of 4 branches missed.">                if ((y &lt; (minXY2[1] - toleranceXY)) || (y &gt; (maxXY2[1] + toleranceXY))) {</span>
<span class="nc" id="L2301">                    continue;</span>
                }
<span class="fc" id="L2303">                listTr.add(ctr);</span>
<span class="fc" id="L2304">                outList.add(list.get(j));</span>
                
<span class="fc bfc" id="L2306" title="All 2 branches covered.">                if (x &lt; minXY1[0]) {</span>
<span class="fc" id="L2307">                    minXY1[0] = x;</span>
                }
<span class="fc bfc" id="L2309" title="All 2 branches covered.">                if (y &lt; minXY1[1]) {</span>
<span class="fc" id="L2310">                    minXY1[1] = y;</span>
                }
<span class="fc bfc" id="L2312" title="All 2 branches covered.">                if (x &gt; maxXY1[0]) {</span>
<span class="fc" id="L2313">                    maxXY1[0] = x;</span>
                }
<span class="fc bfc" id="L2315" title="All 2 branches covered.">                if (y &gt; maxXY1[1]) {</span>
<span class="fc" id="L2316">                    maxXY1[1] = y;</span>
                }
            }
<span class="fc" id="L2319">            outFilteredTransformedC1.add(listTr);</span>
<span class="fc" id="L2320">            outFilteredC1.add(outList);</span>
        }

<span class="fc bfc" id="L2323" title="All 2 branches covered.">        for (int i = 0; i &lt; c2.size(); ++i) {</span>
<span class="fc" id="L2324">            List&lt;T&gt; outList = new ArrayList&lt;T&gt;();</span>
<span class="fc" id="L2325">            List&lt;T&gt; list = c2.get(i);</span>
<span class="fc bfc" id="L2326" title="All 2 branches covered.">            for (int j = 0; j &lt; list.size(); ++j) {</span>
<span class="fc" id="L2327">                T c = list.get(j);</span>
<span class="fc" id="L2328">                int x = c.getX()[c.getKMaxIdx()];</span>
<span class="fc" id="L2329">                int y = c.getY()[c.getKMaxIdx()];</span>
                
<span class="fc bfc" id="L2331" title="All 4 branches covered.">                if ((x &lt; (minXY1[0] - toleranceXY)) || (x &gt; (maxXY1[0] + toleranceXY))) {</span>
<span class="fc" id="L2332">                    continue;</span>
                }
<span class="fc bfc" id="L2334" title="All 4 branches covered.">                if ((y &lt; (minXY1[1] - toleranceXY)) || (y &gt; (maxXY1[1] + toleranceXY))) {</span>
<span class="fc" id="L2335">                    continue;</span>
                }
<span class="fc" id="L2337">                outList.add(list.get(j));</span>
            }
<span class="fc" id="L2339">            outFilteredC2.add(outList);</span>
        }        
<span class="fc" id="L2341">    }</span>
    
    public static void filterForIntersection2(TransformationParameters params, 
        int transXYTol, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; c1, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; c2, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; outFilteredTransformedC1, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; outFilteredC1, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; outFilteredC2) {
        
<span class="nc" id="L2351">        float[] minXY2 = MiscMath.findMinXY2(c2);</span>
<span class="nc" id="L2352">        float[] maxXY2 = MiscMath.findMaxXY2(c2);</span>
        
<span class="nc" id="L2354">        Transformer transformer = new Transformer();</span>
        
<span class="nc" id="L2356">        float[] minXY1 = new float[]{Float.MAX_VALUE, Float.MAX_VALUE};</span>
<span class="nc" id="L2357">        float[] maxXY1 = new float[]{Float.MIN_VALUE, Float.MIN_VALUE};</span>
        
<span class="nc bnc" id="L2359" title="All 2 branches missed.">        for (int i = 0; i &lt; c1.size(); ++i) {</span>
<span class="nc" id="L2360">            List&lt;CurvatureScaleSpaceContour&gt; outList = new ArrayList&lt;CurvatureScaleSpaceContour&gt;();</span>
<span class="nc" id="L2361">            List&lt;CurvatureScaleSpaceContour&gt; listTr = new ArrayList&lt;CurvatureScaleSpaceContour&gt;();</span>
<span class="nc" id="L2362">            List&lt;CurvatureScaleSpaceContour&gt; list = c1.get(i);</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">            for (int j = 0; j &lt; list.size(); ++j) {</span>
                
<span class="nc" id="L2365">                CurvatureScaleSpaceContour ctr = transformer.applyTransformation(params, </span>
<span class="nc" id="L2366">                    list.get(j));</span>
                
<span class="nc" id="L2368">                int x = ctr.getPeakDetails()[0].getXCoord();</span>
<span class="nc" id="L2369">                int y = ctr.getPeakDetails()[0].getYCoord();</span>
                
<span class="nc bnc" id="L2371" title="All 4 branches missed.">                if ((x &lt; (minXY2[0] - transXYTol)) || (x &gt; (maxXY2[0] + transXYTol))) {</span>
<span class="nc" id="L2372">                    continue;</span>
                }
<span class="nc bnc" id="L2374" title="All 4 branches missed.">                if ((y &lt; (minXY2[1] - transXYTol)) || (y &gt; (maxXY2[1] + transXYTol))) {</span>
<span class="nc" id="L2375">                    continue;</span>
                }
<span class="nc" id="L2377">                listTr.add(ctr);</span>
<span class="nc" id="L2378">                outList.add(list.get(j));</span>
                
<span class="nc bnc" id="L2380" title="All 2 branches missed.">                if (x &lt; minXY1[0]) {</span>
<span class="nc" id="L2381">                    minXY1[0] = x;</span>
                }
<span class="nc bnc" id="L2383" title="All 2 branches missed.">                if (y &lt; minXY1[1]) {</span>
<span class="nc" id="L2384">                    minXY1[1] = y;</span>
                }
<span class="nc bnc" id="L2386" title="All 2 branches missed.">                if (x &gt; maxXY1[0]) {</span>
<span class="nc" id="L2387">                    maxXY1[0] = x;</span>
                }
<span class="nc bnc" id="L2389" title="All 2 branches missed.">                if (y &gt; maxXY1[1]) {</span>
<span class="nc" id="L2390">                    maxXY1[1] = y;</span>
                }
            }
<span class="nc" id="L2393">            outFilteredTransformedC1.add(listTr);</span>
<span class="nc" id="L2394">            outFilteredC1.add(outList);</span>
        }

<span class="nc bnc" id="L2397" title="All 2 branches missed.">        for (int i = 0; i &lt; c2.size(); ++i) {</span>
<span class="nc" id="L2398">            List&lt;CurvatureScaleSpaceContour&gt; outList = new ArrayList&lt;CurvatureScaleSpaceContour&gt;();</span>
<span class="nc" id="L2399">            List&lt;CurvatureScaleSpaceContour&gt; list = c2.get(i);</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">            for (int j = 0; j &lt; list.size(); ++j) {</span>
<span class="nc" id="L2401">                CurvatureScaleSpaceContour c = list.get(j);</span>
<span class="nc" id="L2402">                int x = c.getPeakDetails()[0].getXCoord();</span>
<span class="nc" id="L2403">                int y = c.getPeakDetails()[0].getYCoord();</span>
                
<span class="nc bnc" id="L2405" title="All 4 branches missed.">                if ((x &lt; (minXY1[0] - transXYTol)) || (x &gt; (maxXY1[0] + transXYTol))) {</span>
<span class="nc" id="L2406">                    continue;</span>
                }
<span class="nc bnc" id="L2408" title="All 4 branches missed.">                if ((y &lt; (minXY1[1] - transXYTol)) || (y &gt; (maxXY1[1] + transXYTol))) {</span>
<span class="nc" id="L2409">                    continue;</span>
                }
<span class="nc" id="L2411">                outList.add(list.get(j));</span>
            }
<span class="nc" id="L2413">            outFilteredC2.add(outList);</span>
        }        
<span class="nc" id="L2415">    }</span>

    public static void filterForIntersection3(TransformationParameters params, 
        int transXYTol, CornerRegion[] c1, CornerRegion[] c2, 
        List&lt;CornerRegion&gt; outFilteredTransformedC1, 
        List&lt;CornerRegion&gt; outFilteredC1, 
        List&lt;CornerRegion&gt; outFilteredC2) {
        
<span class="fc" id="L2423">        int[] minXY2 = MiscMath.findMinXY2(c2);</span>
<span class="fc" id="L2424">        int[] maxXY2 = MiscMath.findMaxXY2(c2);</span>
        
<span class="fc" id="L2426">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L2428">        float[] minXY1 = new float[]{Float.MAX_VALUE, Float.MAX_VALUE};</span>
<span class="fc" id="L2429">        float[] maxXY1 = new float[]{Float.MIN_VALUE, Float.MIN_VALUE};</span>
        
<span class="fc bfc" id="L2431" title="All 2 branches covered.">        for (int i = 0; i &lt; c1.length; ++i) {</span>
                
<span class="fc" id="L2433">            CornerRegion ctr = transformer.applyTransformation(params, c1[i]);</span>
                
<span class="fc" id="L2435">            int x = ctr.getX()[ctr.getKMaxIdx()];</span>
<span class="fc" id="L2436">            int y = ctr.getY()[ctr.getKMaxIdx()];</span>

<span class="fc bfc" id="L2438" title="All 4 branches covered.">            if ((x &lt; (minXY2[0] - transXYTol)) || (x &gt; (maxXY2[0] + transXYTol))) {</span>
<span class="fc" id="L2439">                continue;</span>
            }
<span class="pc bpc" id="L2441" title="1 of 4 branches missed.">            if ((y &lt; (minXY2[1] - transXYTol)) || (y &gt; (maxXY2[1] + transXYTol))) {</span>
<span class="fc" id="L2442">                continue;</span>
            }
<span class="fc" id="L2444">            outFilteredTransformedC1.add(ctr);</span>
<span class="fc" id="L2445">            outFilteredC1.add(c1[i]);</span>
                
<span class="fc bfc" id="L2447" title="All 2 branches covered.">            if (x &lt; minXY1[0]) {</span>
<span class="fc" id="L2448">                minXY1[0] = x;</span>
            }
<span class="fc bfc" id="L2450" title="All 2 branches covered.">            if (y &lt; minXY1[1]) {</span>
<span class="fc" id="L2451">                minXY1[1] = y;</span>
            }
<span class="fc bfc" id="L2453" title="All 2 branches covered.">            if (x &gt; maxXY1[0]) {</span>
<span class="fc" id="L2454">                maxXY1[0] = x;</span>
            }
<span class="fc bfc" id="L2456" title="All 2 branches covered.">            if (y &gt; maxXY1[1]) {</span>
<span class="fc" id="L2457">                maxXY1[1] = y;</span>
            }
        }

<span class="fc bfc" id="L2461" title="All 2 branches covered.">        for (int i = 0; i &lt; c2.length; ++i) {</span>
<span class="fc" id="L2462">            CornerRegion c = c2[i];</span>
<span class="fc" id="L2463">            int x = c.getX()[c.getKMaxIdx()];</span>
<span class="fc" id="L2464">            int y = c.getY()[c.getKMaxIdx()];</span>
                
<span class="fc bfc" id="L2466" title="All 4 branches covered.">            if ((x &lt; (minXY1[0] - transXYTol)) || (x &gt; (maxXY1[0] + transXYTol))) {</span>
<span class="fc" id="L2467">                continue;</span>
            }
<span class="fc bfc" id="L2469" title="All 4 branches covered.">            if ((y &lt; (minXY1[1] - transXYTol)) || (y &gt; (maxXY1[1] + transXYTol))) {</span>
<span class="fc" id="L2470">                continue;</span>
            }
<span class="fc" id="L2472">            outFilteredC2.add(c);</span>
        }        
<span class="fc" id="L2474">    }</span>

    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="pc bpc" id="L2479" title="2 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L2480">            return null;</span>
        }
        
<span class="fc" id="L2483">        float[] values = calculateThetaDiff(compStats);</span>
<span class="fc bfc" id="L2484" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc bfc" id="L2485" title="All 2 branches covered.">            if (values[i] &lt; 0) {</span>
<span class="fc" id="L2486">                values[i] += 360;</span>
            }
        }
        
        // 20 degree wide bins
<span class="fc" id="L2491">        HistogramHolder hist = Histogram.createSimpleHistogram(20.f, values, </span>
<span class="fc" id="L2492">            Errors.populateYErrorsBySqrt(values));</span>
        
<span class="fc" id="L2494">        int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="fc bfc" id="L2495" title="All 4 branches covered.">        if ((yMaxIdx &gt; -1) &amp;&amp; (hist.getYHist()[yMaxIdx] == 1)) {</span>
<span class="fc" id="L2496">            hist = Histogram.createSimpleHistogram(40.f, values, </span>
<span class="fc" id="L2497">                Errors.populateYErrorsBySqrt(values));</span>
<span class="fc" id="L2498">            yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
        }
        
        float thetaDiff;
<span class="fc bfc" id="L2502" title="All 2 branches covered.">        if (yMaxIdx == -1) {</span>
<span class="fc" id="L2503">            float[] thetaDiffMeanStDev = MiscMath.getAvgAndStDev(values);</span>
<span class="fc" id="L2504">            thetaDiff = thetaDiffMeanStDev[0];</span>
<span class="fc" id="L2505">        } else {</span>
<span class="fc" id="L2506">            thetaDiff = hist.getXHist()[yMaxIdx];</span>
        }
        
        //TODO: consider a bin larger than 20 degrees... 25
<span class="fc" id="L2510">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L2512" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L2513">            float diffRot = AngleUtil.getAngleDifference(values[i], thetaDiff);</span>
<span class="fc bfc" id="L2514" title="All 2 branches covered.">            if (diffRot &gt; 20) {</span>
<span class="fc" id="L2515">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L2519" title="All 2 branches covered.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="fc" id="L2520">            int idx = remove.get(i);</span>
<span class="fc" id="L2521">            compStats.remove(idx);</span>
        }
        
<span class="fc" id="L2524">        return remove;</span>
    }
    
    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats, float rotationInDegrees) {
        
<span class="pc bpc" id="L2530" title="2 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L2531">            return null;</span>
        }
        
<span class="fc" id="L2534">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc" id="L2536">        float[] values = calculateThetaDiff(compStats);</span>
<span class="fc bfc" id="L2537" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
            
<span class="fc bfc" id="L2539" title="All 2 branches covered.">            if (values[i] &lt; 0) {</span>
<span class="fc" id="L2540">                values[i] += 360;</span>
            }
            
<span class="fc" id="L2543">            int diffRot = Math.round(AngleUtil.getAngleDifference(values[i], </span>
                rotationInDegrees));
<span class="fc bfc" id="L2545" title="All 2 branches covered.">            if (diffRot &gt; 20) {</span>
<span class="fc bfc" id="L2546" title="All 4 branches covered.">                if ((diffRot &lt; 30) &amp;&amp; compStats.get(i).getSumIntensitySqDiff() &lt; 100) {</span>
<span class="fc" id="L2547">                    continue;</span>
                }
<span class="fc" id="L2549">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L2553" title="All 2 branches covered.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="fc" id="L2554">            int idx = remove.get(i);</span>
<span class="fc" id="L2555">            compStats.remove(idx);</span>
        }
        
<span class="fc" id="L2558">        return remove;</span>
    }
    
    public static float[] calcIntensitySSDMeanAndStDev(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc" id="L2563">        int n = compStats.size();</span>
        
<span class="fc" id="L2565">        float[] ssds = new float[n];</span>
        
<span class="fc bfc" id="L2567" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L2569">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L2571">            ssds[i] = stat.getSumIntensitySqDiff();</span>
        }
        
<span class="fc" id="L2574">        float[] meanStDv = MiscMath.getAvgAndStDev(ssds);</span>
        
<span class="fc" id="L2576">        return meanStDv;</span>
    }

    public static void removeIntensityOutliers(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc bfc" id="L2581" title="All 2 branches covered.">        if (compStats.size() &lt; 3) {</span>
<span class="fc" id="L2582">            return;</span>
        }
        
<span class="fc" id="L2585">        int n = compStats.size();</span>
        
<span class="fc" id="L2587">        float[] meanStDv = calcIntensitySSDMeanAndStDev(compStats);</span>
        
<span class="fc" id="L2589">        List&lt;Integer&gt; rm = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L2591" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L2593">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L2595">            float diff = Math.abs(stat.getSumIntensitySqDiff() - meanStDv[0]);</span>
            
<span class="fc bfc" id="L2597" title="All 2 branches covered.">            if (diff &gt; (1.25 * meanStDv[1])) {</span>
<span class="fc" id="L2598">                rm.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L2602" title="All 2 branches covered.">        for (int i = rm.size() - 1; i &gt; -1; --i) {</span>
            
<span class="fc" id="L2604">            int idx = rm.get(i).intValue();</span>
            
<span class="fc" id="L2606">            compStats.remove(idx);</span>
        }
<span class="fc" id="L2608">    }</span>

    private int angleForResultDiff(int rot2, int expectedRotationInDegrees) {
                
<span class="fc" id="L2612">        int r0 = rot2 - expectedRotationInDegrees;</span>
<span class="fc bfc" id="L2613" title="All 2 branches covered.">        if (r0 &lt; 0) {</span>
<span class="fc" id="L2614">            r0 += 360;</span>
        }
        
<span class="fc" id="L2617">        int r = Math.abs(Math.round(AngleUtil.getAngleDifference(r0, rot2)));</span>
        
<span class="pc bpc" id="L2619" title="1 of 2 branches missed.">        if (r != expectedRotationInDegrees) {</span>
<span class="nc" id="L2620">            r0 = expectedRotationInDegrees - rot2;</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">            if (r0 &lt; 0) {</span>
<span class="nc" id="L2622">                r0 += 360;</span>
            }
<span class="nc" id="L2624">            r = Math.abs(Math.round(AngleUtil.getAngleDifference(r0, rot2)));</span>
        }
        
<span class="fc" id="L2627">        return r0;</span>
    }

    private CorrespondenceList useBipartiteMatching(float[][] cost,
        Map&lt;PairInt, FeatureComparisonStat&gt; statMap, 
        TransformationParameters params) {

<span class="pc bpc" id="L2634" title="1 of 2 branches missed.">        if (cost == null) {</span>
<span class="nc" id="L2635">            return null;</span>
        }
        
<span class="fc" id="L2638">        boolean transposed = false;</span>
<span class="pc bpc" id="L2639" title="1 of 2 branches missed.">        if (cost.length &gt; cost[0].length) {</span>
<span class="nc" id="L2640">            cost = MatrixUtil.transpose(cost);</span>
<span class="nc" id="L2641">            transposed = true;</span>
        }

        // one pass thru to count for array sizes
<span class="fc" id="L2645">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="fc" id="L2646">        int[][] match = b.computeAssignments(cost);</span>

<span class="fc bfc" id="L2648" title="All 2 branches covered.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="fc" id="L2649">            int idx1 = match[i][0];</span>
<span class="fc" id="L2650">            int idx2 = match[i][1];</span>
<span class="pc bpc" id="L2651" title="1 of 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="fc" id="L2652">                continue;</span>
            }
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L2655">                int swap = idx1;</span>
<span class="nc" id="L2656">                idx1 = idx2;</span>
<span class="nc" id="L2657">                idx2 = swap;</span>
            }
<span class="fc" id="L2659">            PairInt pI = new PairInt(idx1, idx2);</span>
<span class="fc bfc" id="L2660" title="All 2 branches covered.">            if (!statMap.containsKey(pI)) {</span>
<span class="fc" id="L2661">                continue;</span>
            }
        }

<span class="fc" id="L2665">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L2666">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc" id="L2668">        int nc = 0;</span>

<span class="fc bfc" id="L2670" title="All 2 branches covered.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="fc" id="L2671">            int idx1 = match[i][0];</span>
<span class="fc" id="L2672">            int idx2 = match[i][1];</span>
<span class="pc bpc" id="L2673" title="1 of 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="fc" id="L2674">                continue;</span>
            }
<span class="pc bpc" id="L2676" title="1 of 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L2677">                int swap = idx1;</span>
<span class="nc" id="L2678">                idx1 = idx2;</span>
<span class="nc" id="L2679">                idx2 = swap;</span>
            }

<span class="fc" id="L2682">            PairInt pI = new PairInt(idx1, idx2);</span>
<span class="fc" id="L2683">            FeatureComparisonStat stat = statMap.get(pI);</span>
<span class="fc bfc" id="L2684" title="All 2 branches covered.">            if (stat == null) {</span>
<span class="fc" id="L2685">                continue;</span>
            }
            
<span class="fc" id="L2688">            int x1 = stat.getImg1Point().getX();</span>
<span class="fc" id="L2689">            int y1 = stat.getImg1Point().getY();</span>
<span class="fc" id="L2690">            matched1.add(new PairInt(x1, y1));</span>
<span class="fc" id="L2691">            int x2 = stat.getImg2Point().getX();</span>
<span class="fc" id="L2692">            int y2 = stat.getImg2Point().getY();</span>
<span class="fc" id="L2693">            matched2.add(new PairInt(x2, y2));</span>

<span class="fc" id="L2695">            nc++;</span>
        }

<span class="pc bpc" id="L2698" title="1 of 2 branches missed.">        if (matched1.size() &lt; 7) {</span>
<span class="nc" id="L2699">            return null;</span>
        }
        
<span class="fc" id="L2702">        int rangeRotation = Math.round(params.getStandardDeviations()[1]);</span>
<span class="fc" id="L2703">        int rangeTranslationX = Math.round(params.getStandardDeviations()[2]);</span>
<span class="fc" id="L2704">        int rangeTranslationY = Math.round(params.getStandardDeviations()[3]);</span>

<span class="fc" id="L2706">        CorrespondenceList cl = new CorrespondenceList(params.getScale(),</span>
<span class="fc" id="L2707">            Math.round(params.getRotationInDegrees()),</span>
<span class="fc" id="L2708">            Math.round(params.getTranslationX()), Math.round(params.getTranslationY()),</span>
            rangeRotation, rangeTranslationX, rangeTranslationY,
            matched1, matched2);

<span class="fc" id="L2712">        return cl;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
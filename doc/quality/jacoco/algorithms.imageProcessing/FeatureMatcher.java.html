<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">FeatureMatcher.java</span></div><h1>FeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.AngleUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

public class FeatureMatcher {

<span class="fc" id="L23">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L25">    public FeatureMatcher() {</span>
<span class="fc" id="L26">    }</span>

    /**
     * 
     * @param img1
     * @param gXY1
     * @param theta1
     * @param cornerRegions1
     * @param img2
     * @param gXY2
     * @param theta2
     * @param cornerRegions2
     * @param scale the scale factor between img1 and img2 (can be determined
     * with BlobScaleFinderWrapper before use here).
     * @return 
     */
    public CorrespondenceList findSimilarFeatures(
        GreyscaleImage img1, GreyscaleImage gXY1, GreyscaleImage theta1,
        CornerRegion[] cornerRegions1,
        GreyscaleImage img2, GreyscaleImage gXY2, GreyscaleImage theta2,
        CornerRegion[] cornerRegions2,
        final float scale) {
        
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">        if (img1 == null) {</span>
<span class="nc" id="L50">            throw new IllegalArgumentException(&quot;img1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">        if (img2 == null) {</span>
<span class="nc" id="L53">            throw new IllegalArgumentException(&quot;img2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        if (gXY1 == null) {</span>
<span class="nc" id="L56">            throw new IllegalArgumentException(&quot;gXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        if (gXY2 == null) {</span>
<span class="nc" id="L59">            throw new IllegalArgumentException(&quot;gXY2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (theta1 == null) {</span>
<span class="nc" id="L62">            throw new IllegalArgumentException(&quot;theta1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (theta2 == null) {</span>
<span class="nc" id="L65">            throw new IllegalArgumentException(&quot;theta2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (cornerRegions1 == null) {</span>
<span class="nc" id="L68">            throw new IllegalArgumentException(&quot;cornerRegions1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (cornerRegions2 == null) {</span>
<span class="nc" id="L71">            throw new IllegalArgumentException(&quot;cornerRegions2 cannot be null&quot;);</span>
        }
        
<span class="fc" id="L74">        int blockHalfWidth = 5;</span>
<span class="fc" id="L75">        boolean useNormalizedIntensities = true;</span>
        
        //NOTE: scale was not used in the feature descriptors, but
        // should be in the future.  For large scale factor, would want to
        // scale the grid sizes in the descriptor
        
<span class="fc" id="L81">        Features features1 = new Features(img1, gXY1, theta1, blockHalfWidth, </span>
            useNormalizedIntensities);
        
<span class="fc" id="L84">        Features features2 = new Features(img2, gXY2, theta2, blockHalfWidth, </span>
            useNormalizedIntensities);
        
<span class="fc" id="L87">        Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; matchingMap =</span>
<span class="fc" id="L88">            findMatchingFeatures(features1, features2, cornerRegions1, </span>
                cornerRegions2, blockHalfWidth, useNormalizedIntensities);
        
        // a quick rough look at the most frequent parameters of euclidean
        // transformations.
        
        //TODO: this may need alot of adjustment, espec for histogram bin sizes.
        
<span class="fc" id="L96">        List&lt;PairInt&gt; points1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L97">        List&lt;PairInt&gt; points2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L98">        List&lt;Integer&gt; rotations = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L99">        List&lt;Integer&gt; translationsX = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L100">        List&lt;Integer&gt; translationsY = new ArrayList&lt;Integer&gt;();</span>
        
        for (Entry&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; entry 
<span class="fc bfc" id="L103" title="All 2 branches covered.">            : matchingMap.entrySet()) {</span>
            
<span class="fc" id="L105">            PairInt p1 = entry.getKey();</span>
            
<span class="fc" id="L107">            Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt; p2Map = entry.getValue();</span>
            
<span class="fc bfc" id="L109" title="All 2 branches covered.">            for (Entry&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt; entry2 : p2Map.entrySet()) {</span>
                
<span class="fc" id="L111">                PairInt p2 = entry2.getKey();</span>
                
                //TODO: consider only writing all best solutions if they
                // are different here:
                
<span class="fc bfc" id="L116" title="All 2 branches covered.">                for (FeatureComparisonStat stat : entry2.getValue()) {</span>
                   
<span class="fc" id="L118">                    float rotation = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L119">                        stat.getImg2PointRotInDegrees(), </span>
<span class="fc" id="L120">                        stat.getImg1PointRotInDegrees());</span>
                    
<span class="fc bfc" id="L122" title="All 2 branches covered.">                    if (rotation &lt; 0) {</span>
<span class="fc" id="L123">                        rotation += 360;</span>
                    }
<span class="fc" id="L125">                    double rotationRadians = rotation * Math.PI/180.;</span>
                    
<span class="fc" id="L127">                    double cosine = Math.cos(rotationRadians);</span>
<span class="fc" id="L128">                    double sine = Math.sin(rotationRadians);</span>
                    
                    //given scale and rotation, can calculate implied rotation
<span class="fc" id="L131">                    double xr = (p1.getX() * scale * cosine)</span>
<span class="fc" id="L132">                        + (p1.getY() * scale * sine);</span>

<span class="fc" id="L134">                    double yr = -(p1.getX() * scale * sine)</span>
<span class="fc" id="L135">                        + (p1.getY() * scale * cosine);</span>

<span class="fc" id="L137">                    int xt = Math.round(p2.getX() - (float)xr);</span>
<span class="fc" id="L138">                    int yt = Math.round(p2.getY() - (float)yr);</span>
                    
<span class="fc" id="L140">                    rotations.add(Integer.valueOf(Math.round(rotation)));</span>
<span class="fc" id="L141">                    translationsX.add(Integer.valueOf(xt));</span>
<span class="fc" id="L142">                    translationsY.add(Integer.valueOf(yt));</span>
<span class="fc" id="L143">                    points1.add(p1);</span>
<span class="fc" id="L144">                    points2.add(p2);</span>
<span class="fc" id="L145">                }</span>
<span class="fc" id="L146">            }</span>
<span class="fc" id="L147">        }</span>
        
<span class="fc" id="L149">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L150">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc" id="L152">        HistogramHolder rHist = Histogram.createSimpleHistogram(20, rotations);</span>
<span class="fc" id="L153">        List&lt;Integer&gt; subsetRotation = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L154">        List&lt;Integer&gt; subsetTransX = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L155">        List&lt;Integer&gt; subsetTransY = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L156">        List&lt;PairInt&gt; subsetPoints1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L157">        List&lt;PairInt&gt; subsetPoints2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L158">        int yMaxIdx = MiscMath.findYMaxIndex(rHist.getYHist());</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (yMaxIdx != -1) {</span>
<span class="fc" id="L160">            float rotMax = rHist.getXHist()[yMaxIdx];</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            for (int i = 0; i &lt; rotations.size(); ++i) {</span>
<span class="fc" id="L162">                float rot = rotations.get(i);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                if (Math.abs(rot - rotMax) &lt;= 20) {</span>
<span class="fc" id="L164">                    subsetRotation.add(Math.round(rot));</span>
<span class="fc" id="L165">                    subsetTransX.add(translationsX.get(i));</span>
<span class="fc" id="L166">                    subsetTransY.add(translationsY.get(i));</span>
<span class="fc" id="L167">                    subsetPoints1.add(points1.get(i));</span>
<span class="fc" id="L168">                    subsetPoints2.add(points2.get(i));</span>
                }
            }
            // A general euclidean transformation (possibly varying across
            // image due to projection effects) is needed to determine if
            // points are matched.
            
            // quick look at results to decide if need to use statistics of
            // fit here (as weights) or whether frequency of values is enough.
            
<span class="fc" id="L178">            HistogramHolder txHist = Histogram.createSimpleHistogram(50, subsetTransX);</span>
            try {
<span class="fc" id="L180">                txHist.plotHistogram(&quot;translationX&quot;, MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L181">            } catch (IOException ex) {</span>
<span class="nc" id="L182">                Logger.getLogger(FeatureMatcher.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L183">            }</span>
<span class="fc" id="L184">            int yMaxIdx2 = MiscMath.findYMaxIndex(txHist.getYHist());</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (yMaxIdx2 != -1) {</span>
<span class="fc" id="L186">                float txMax = txHist.getXHist()[yMaxIdx2];</span>
<span class="fc" id="L187">                float txFWHM = Histogram.measureFWHM(txHist, yMaxIdx2);</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (txFWHM &lt; 50) {</span>
<span class="nc" id="L189">                    txFWHM = 50;</span>
                }
<span class="fc" id="L191">                List&lt;Integer&gt; subset2Rotation = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L192">                List&lt;Integer&gt; subset2TransX = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L193">                List&lt;Integer&gt; subset2TransY = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L194">                List&lt;PairInt&gt; subset2Points1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L195">                List&lt;PairInt&gt; subset2Points2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                for (int i = 0; i &lt; subsetTransX.size(); ++i) {</span>
<span class="fc" id="L197">                    int tx = subsetTransX.get(i);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                    if (Math.abs(tx - txMax) &lt;= (txFWHM/2.f)) {</span>
<span class="fc" id="L199">                        subset2Rotation.add(subsetRotation.get(i));</span>
<span class="fc" id="L200">                        subset2TransX.add(tx);</span>
<span class="fc" id="L201">                        subset2TransY.add(subsetTransY.get(i));</span>
<span class="fc" id="L202">                        subset2Points1.add(subsetPoints1.get(i));</span>
<span class="fc" id="L203">                        subset2Points2.add(subsetPoints2.get(i));</span>
                    }
                }
<span class="fc" id="L206">                HistogramHolder tyHist = Histogram.createSimpleHistogram(50, subset2TransY);</span>
                try {
<span class="fc" id="L208">                    tyHist.plotHistogram(&quot;translationY&quot;, MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L209">                } catch (IOException ex) {</span>
<span class="nc" id="L210">                    Logger.getLogger(FeatureMatcher.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L211">                }</span>
<span class="fc" id="L212">                int yMaxIdx3 = MiscMath.findYMaxIndex(tyHist.getYHist());</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                if (yMaxIdx3 != -1) {</span>
<span class="fc" id="L214">                    float tyMax = tyHist.getXHist()[yMaxIdx3];</span>
<span class="fc" id="L215">                    float tyFWHM = Histogram.measureFWHM(tyHist, yMaxIdx3);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                    if (tyFWHM &lt; 50) {</span>
<span class="nc" id="L217">                        tyFWHM = 50;</span>
                    }
                    
<span class="fc" id="L220">                    log.info(&quot;solution rotation=&quot; + rotMax + &quot;+-20 &quot;</span>
                    + &quot; translationX=&quot; + txMax + &quot;+-&quot; + (txFWHM/2.)
                    + &quot; translationY=&quot; + tyMax + &quot;+=&quot; + (tyFWHM/2.));
<span class="fc bfc" id="L223" title="All 2 branches covered.">                    for (int i = 0; i &lt; subset2TransY.size(); ++i) {</span>
<span class="fc" id="L224">                        int ty = subset2TransY.get(i);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                        if (Math.abs(ty - tyMax) &lt;= (tyFWHM/2.f)) {</span>
<span class="fc" id="L226">                            matched1.add(subset2Points1.get(i));</span>
<span class="fc" id="L227">                            matched2.add(subset2Points2.get(i));</span>
                        }
                    } 
                   
<span class="fc" id="L231">                    CorrespondenceList cl = new CorrespondenceList(</span>
                        scale, 
<span class="fc" id="L233">                        Math.round(rotMax), Math.round(txMax), Math.round(tyMax),</span>
<span class="fc" id="L234">                        20, Math.round(txFWHM), Math.round(tyFWHM), </span>
                        matched1, matched2);
                    
<span class="fc" id="L237">                    return cl;</span>
                }
            }
        }
        
<span class="nc" id="L242">        return null;</span>
    }
    
    protected void storeInMap(Map&lt;PairInt, Map&lt;PairInt, 
        Set&lt;FeatureComparisonStat&gt;&gt;&gt; comparisonMap, FeatureComparisonStat stat) {
        
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L249">            return;</span>
        }
        
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (comparisonMap == null) {</span>
<span class="nc" id="L253">            throw new IllegalArgumentException(&quot;comparisonMap cannot be null&quot;);</span>
        }
        
<span class="fc" id="L256">        PairInt p1 = stat.getImg1Point();</span>
<span class="fc" id="L257">        PairInt p2 = stat.getImg2Point();</span>
        
<span class="fc" id="L259">        Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt; p1Map = comparisonMap.get(p1);</span>
        
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (p1Map == null) {</span>
<span class="fc" id="L262">            p1Map = new HashMap&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;();</span>
<span class="fc" id="L263">            comparisonMap.put(p1, p1Map);</span>
        }
        
<span class="fc" id="L266">        Set&lt;FeatureComparisonStat&gt; p2Map = p1Map.get(p2);</span>
        
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (p2Map == null) {</span>
<span class="fc" id="L269">            p2Map = new HashSet&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L270">            p1Map.put(p2, p2Map);</span>
        }
        
<span class="fc" id="L273">        p2Map.add(stat);</span>
<span class="fc" id="L274">    }</span>

    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param cornerRegion1
     * @param cornerRegion2
     * @param dither
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    protected FeatureComparisonStat ditherAndRotateForCorner1Location(
        Features features1, Features features2, CornerRegion cornerRegion1, 
        CornerRegion cornerRegion2, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
                
<span class="fc" id="L293">        int kMaxIdx1 = cornerRegion1.getKMaxIdx();</span>
<span class="fc" id="L294">        final int x1 = cornerRegion1.getX()[kMaxIdx1];</span>
<span class="fc" id="L295">        final int y1 = cornerRegion1.getY()[kMaxIdx1];</span>
<span class="fc" id="L296">        int rot1 = Math.round(</span>
<span class="fc" id="L297">            cornerRegion1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L299">        int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="fc" id="L300">        final int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="fc" id="L301">        final int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="fc" id="L302">        int rot2 = Math.round(</span>
<span class="fc" id="L303">            cornerRegion2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L305">        FeatureComparisonStat best = null;</span>
                
<span class="fc" id="L307">        GradientDescriptor gDesc2 = features2.extractGradient(x2, y2, rot2);</span>
        
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (gDesc2 == null) {</span>
<span class="fc" id="L310">            return null;</span>
        }
        
        // TODO: could decide not to find best rotation here and just discard
        // false matches due to wrong orientation at end of comparisons
<span class="fc" id="L315">        int[] rotations = new int[10];</span>
<span class="fc" id="L316">        int i = 0;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L318">            rotations[i] = rotD1;</span>
<span class="fc" id="L319">            i++;</span>
        }
<span class="fc" id="L321">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L322">        i++;</span>
<span class="fc" id="L323">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L324">        i++;</span>
<span class="fc" id="L325">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L326">        i++;</span>
        
<span class="fc bfc" id="L328" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L330">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L332">                rotD1 += 360;</span>
            }
<span class="fc bfc" id="L334" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L336">                    continue;</span>
                }
<span class="fc bfc" id="L338" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="fc" id="L340">                        continue;</span>
                    }
                    
<span class="fc" id="L343">                    GradientDescriptor gDesc1 = features1.extractGradient(x1d, </span>
                        y1d, rotD1);
                    
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    if (gDesc1 == null) {</span>
<span class="fc" id="L347">                        continue;</span>
                    }
                       
<span class="fc" id="L350">                    FeatureComparisonStat stat = Features.calculateGradientStats(</span>
                        gDesc1, x1d, y1d, gDesc2, x2, y2);
                   
<span class="fc bfc" id="L353" title="All 2 branches covered.">                    if (stat.getSumGradientSqDiff() &lt; stat.getImg2PointGradientErr()) {</span>
                       
<span class="fc bfc" id="L355" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L356">                            best = stat;</span>
<span class="fc" id="L357">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L358">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L360" title="All 2 branches covered.">                            if (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff()) {</span>
<span class="fc" id="L361">                                best = stat;</span>
<span class="fc" id="L362">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L363">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L371">        return best;</span>
    }

    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither) {
     
<span class="nc" id="L389">        final int x1 = region1.getX();</span>
<span class="nc" id="L390">        final int y1 = region1.getY();</span>
<span class="nc" id="L391">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L393">        final int x2 = region2.getX();</span>
<span class="nc" id="L394">        final int y2 = region2.getY();</span>
<span class="nc" id="L395">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L397">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither);
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="fc" id="L406">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="fc" id="L407">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="fc" id="L408">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="fc" id="L409">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="fc" id="L411">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="fc" id="L412">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="fc" id="L413">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="fc" id="L414">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L416">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither);
    }
    
    /**
     * note that a degreeIntervals &gt; 20 is not recommended
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param degreeIntervals
     * @return
     * @throws algorithms.imageProcessing.CornerRegion.CornerRegionDegneracyException 
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither, 
        int degreeIntervals) throws CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L436">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L437">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L438">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L439">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L441">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L442">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L443">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L444">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L446">        int n = 360/degreeIntervals;</span>
<span class="nc" id="L447">        int[] rotations = new int[n];</span>
<span class="nc" id="L448">        int i = 0;</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="nc" id="L450">            rotations[i] = rot1 + rotD1;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (rotations[i] &gt; 359) {</span>
<span class="nc" id="L452">                rotations[i] -= 360;</span>
            }
<span class="nc" id="L454">            i++;</span>
        }
        
<span class="nc" id="L457">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @param degreeIntervals a value &gt; 20 is not recommended
     * @return
     */
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither,
        int degreeIntervals) {
     
<span class="fc" id="L478">        final int x1 = region1.getX();</span>
<span class="fc" id="L479">        final int y1 = region1.getY();</span>
<span class="fc" id="L480">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L482">        final int x2 = region2.getX();</span>
<span class="fc" id="L483">        final int y2 = region2.getY();</span>
<span class="fc" id="L484">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="fc" id="L486">        int n = 360/degreeIntervals;</span>
<span class="fc" id="L487">        int[] rotations = new int[n];</span>
<span class="fc" id="L488">        int i = 0;</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">        for (int rot1 = 0; rot1 &lt; 360; rot1 += degreeIntervals) {</span>
<span class="fc" id="L490">            rotations[i] = rot1 + rotD1;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (rotations[i] &gt; 359) {</span>
<span class="fc" id="L492">                rotations[i] -= 360;</span>
            }
<span class="fc" id="L494">            i++;</span>
        }
        
<span class="fc" id="L497">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotations, x2, y2, rotD2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
        
<span class="fc" id="L522">        int[] rotations = new int[10];</span>
<span class="fc" id="L523">        int i = 0;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="fc" id="L525">            rotations[i] = rotD1;</span>
<span class="fc" id="L526">            i++;</span>
        }
<span class="fc" id="L528">        rotations[i] = rot1 + 90;</span>
<span class="fc" id="L529">        i++;</span>
<span class="fc" id="L530">        rotations[i] = rot1 + 180;</span>
<span class="fc" id="L531">        i++;</span>
<span class="fc" id="L532">        rotations[i] = rot1 + 270;</span>
<span class="fc" id="L533">        i++;</span>
        
<span class="fc" id="L535">        return ditherAndRotateForBestLocation(features1, features2, x1, y1, </span>
            rotations, x2, y2, rot2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rotations
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int[] rotations,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
<span class="fc" id="L559">        FeatureComparisonStat best = null;</span>
        
<span class="fc" id="L561">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (desc2 == null) {</span>
<span class="fc" id="L564">            return null;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (int rotD1 : rotations) {</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">            if (rotD1 &gt; 359) {</span>
<span class="fc" id="L574">                rotD1 = rotD1 - 360;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            } else if (rotD1 &lt; 0) {</span>
<span class="fc" id="L576">                rotD1 += 360;</span>
            }
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L580">                    continue;</span>
                }
<span class="fc bfc" id="L582" title="All 2 branches covered.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="fc" id="L584">                        continue;</span>
                    }
                    
<span class="fc" id="L587">                    IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rotD1);</span>
        
<span class="fc bfc" id="L589" title="All 2 branches covered.">                    if (desc1 == null) {</span>
<span class="fc" id="L590">                        return null;</span>
                    }
                    
<span class="fc" id="L593">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="fc bfc" id="L596" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
                       
<span class="fc bfc" id="L598" title="All 2 branches covered.">                        if (best == null) {</span>
<span class="fc" id="L599">                            best = stat;</span>
<span class="fc" id="L600">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L601">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="fc bfc" id="L603" title="All 2 branches covered.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L604">                                best = stat;</span>
<span class="fc" id="L605">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L606">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L614">        return best;</span>
    }
    
    public FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither,
        final int expectedRotationInDegrees, final int rotationTol) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L623">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L624">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L625">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L626">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L628">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L629">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L630">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L631">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L633">        return ditherAndRotateForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither, expectedRotationInDegrees,
            rotationTol);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation. 
     * @param features1
     * @param x1
     * @param y1
     * @param features2
     * @param rot1
     * @param x2
     * @param dither
     * @param rot2
     * @param y2
     * @param expectedRotationInDegrees
     * @param rotationTol
     * @return
     */
    protected FeatureComparisonStat ditherAndRotateForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither, final int expectedRotationInDegrees, final int rotationTol) {
        
<span class="nc" id="L660">        FeatureComparisonStat best = null;</span>
        
<span class="nc" id="L662">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L665">            return null;</span>
        }
        
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="nc" id="L673">        int[] rotations = new int[10];</span>
<span class="nc" id="L674">        int i = 0;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        for (int rotD1 = (rot1 - 30); rotD1 &lt;= (rot1 + 30); rotD1 += 10) {</span>
<span class="nc" id="L676">            rotations[i] = rotD1;</span>
<span class="nc" id="L677">            i++;</span>
        }
<span class="nc" id="L679">        rotations[i] = rot1 + 90;</span>
<span class="nc" id="L680">        i++;</span>
<span class="nc" id="L681">        rotations[i] = rot1 + 180;</span>
<span class="nc" id="L682">        i++;</span>
<span class="nc" id="L683">        rotations[i] = rot1 + 270;</span>
<span class="nc" id="L684">        i++;</span>
        
<span class="nc bnc" id="L686" title="All 2 branches missed.">        for (int rotD1 : rotations) {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if (rotD1 &gt; 359) {</span>
<span class="nc" id="L688">                rotD1 = rotD1 - 360;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            } else if (rotD1 &lt; 0) {</span>
<span class="nc" id="L690">                rotD1 += 360;</span>
            }
            
            // only try rotations within expected rotation limits
<span class="nc" id="L694">            float rotDescriptors = AngleUtil.getAngleDifference(rotD1, rot2);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (rotDescriptors &lt; 0) {</span>
<span class="nc" id="L696">                rotDescriptors += 360;</span>
            }
<span class="nc" id="L698">            float rotDiff = AngleUtil.getAngleDifference(</span>
                expectedRotationInDegrees, rotDescriptors);
<span class="nc bnc" id="L700" title="All 2 branches missed.">            if (Math.abs(rotDiff) &gt; rotationTol) {</span>
<span class="nc" id="L701">                continue;</span>
            }
            
<span class="nc bnc" id="L704" title="All 2 branches missed.">            for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L706">                    continue;</span>
                }
<span class="nc bnc" id="L708" title="All 2 branches missed.">                for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                    if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L710">                        continue;</span>
                    }
                    
<span class="nc" id="L713">                    IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rotD1);</span>
        
<span class="nc bnc" id="L715" title="All 2 branches missed.">                    if (desc1 == null) {</span>
<span class="nc" id="L716">                        return null;</span>
                    }
                    
<span class="nc" id="L719">                    FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                        desc1, x1d, y1d, desc2, x2, y2);
                   
<span class="nc bnc" id="L722" title="All 2 branches missed.">                    if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">                        if (best == null) {</span>
<span class="nc" id="L724">                            best = stat;</span>
<span class="nc" id="L725">                            best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L726">                            best.setImg2PointRotInDegrees(rot2);</span>
                        } else {
<span class="nc bnc" id="L728" title="All 2 branches missed.">                            if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L729">                                best = stat;</span>
<span class="nc" id="L730">                                best.setImg1PointRotInDegrees(rotD1);</span>
<span class="nc" id="L731">                                best.setImg2PointRotInDegrees(rot2);</span>
                            }
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L739">        return best;</span>
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param region1
     * @param region2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        BlobPerimeterRegion region1, BlobPerimeterRegion region2, int dither) {
        
<span class="nc" id="L757">        final int x1 = region1.getX();</span>
<span class="nc" id="L758">        final int y1 = region1.getY();</span>
<span class="nc" id="L759">        int rot1 = Math.round(region1.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L761">        final int x2 = region2.getX();</span>
<span class="nc" id="L762">        final int y2 = region2.getY();</span>
<span class="nc" id="L763">        int rot2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L765">        return ditherForBestLocation(features1, features2,</span>
            x1, y1, rot1, x2, y2, rot2, dither);
    }
    
    public FeatureComparisonStat ditherForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        CornerRegion region1, CornerRegion region2, int dither) throws 
        CornerRegion.CornerRegionDegneracyException {
        
<span class="nc" id="L774">        int kMaxIdx1 = region1.getKMaxIdx();</span>
<span class="nc" id="L775">        int x1 = region1.getX()[kMaxIdx1];</span>
<span class="nc" id="L776">        int y1 = region1.getY()[kMaxIdx1];</span>
<span class="nc" id="L777">        int rotD1 = Math.round(region1.getRelativeOrientationInDegrees());</span>

<span class="nc" id="L779">        int kMaxIdx2 = region2.getKMaxIdx();</span>
<span class="nc" id="L780">        int x2 = region2.getX()[kMaxIdx2];</span>
<span class="nc" id="L781">        int y2 = region2.getY()[kMaxIdx2];</span>
<span class="nc" id="L782">        int rotD2 = Math.round(region2.getRelativeOrientationInDegrees());</span>
        
<span class="nc" id="L784">        return ditherForBestLocation(features1, features2,</span>
            x1, y1, rotD1, x2, y2, rotD2, dither);
    }
    
    /**
     * comparison of descriptors to tune the center of cornerRegion1 and the
     * orientation.  This doesn't compare the other descriptors to get overall
     * best.
     * @param features1
     * @param features2
     * @param x1
     * @param y1
     * @param rot1
     * @param x2
     * @param y2
     * @param rot2
     * @param dither
     * @return
     */
    public FeatureComparisonStat ditherForBestLocation(
        IntensityFeatures features1, IntensityFeatures features2, 
        final int x1, final int y1, final int rot1,
        final int x2, final int y2, final int rot2,        
        int dither) {
        
<span class="nc" id="L809">        FeatureComparisonStat best = null;</span>
        
<span class="nc" id="L811">        IntensityDescriptor desc2 = features2.extractIntensity(x2, y2, rot2);</span>
        
<span class="nc bnc" id="L813" title="All 2 branches missed.">        if (desc2 == null) {</span>
<span class="nc" id="L814">            return null;</span>
        }
                
        /*
        NOTE: best distinguisher for improved rotation angle is usually 
        the gradient images because these are on edges.
        */
        
<span class="nc bnc" id="L822" title="All 2 branches missed.">        for (int x1d = (x1 - dither); x1d &lt;= (x1 + dither); ++x1d) {</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">            if (!features1.isWithinXBounds(x1d)) {</span>
<span class="nc" id="L824">                continue;</span>
            }
<span class="nc bnc" id="L826" title="All 2 branches missed.">            for (int y1d = (y1 - dither); y1d &lt;= (y1 + dither); ++y1d) {</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                if (!features1.isWithinYBounds(y1d)) {</span>
<span class="nc" id="L828">                    continue;</span>
                }
                    
<span class="nc" id="L831">                IntensityDescriptor desc1 = features1.extractIntensity(x1d, y1d, rot1);</span>

<span class="nc bnc" id="L833" title="All 2 branches missed.">                if (desc1 == null) {</span>
<span class="nc" id="L834">                    return null;</span>
                }

<span class="nc" id="L837">                FeatureComparisonStat stat = IntensityFeatures.calculateStats(</span>
                    desc1, x1d, y1d, desc2, x2, y2);

<span class="nc bnc" id="L840" title="All 2 branches missed.">                if (stat.getSumIntensitySqDiff() &lt; stat.getImg2PointIntensityErr()) {</span>

<span class="nc bnc" id="L842" title="All 2 branches missed.">                    if (best == null) {</span>
<span class="nc" id="L843">                        best = stat;</span>
<span class="nc" id="L844">                        best.setImg1PointRotInDegrees(rot1);</span>
<span class="nc" id="L845">                        best.setImg2PointRotInDegrees(rot2);</span>
                    } else {
<span class="nc bnc" id="L847" title="All 2 branches missed.">                        if (best.getSumIntensitySqDiff() &gt; stat.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L848">                            best = stat;</span>
<span class="nc" id="L849">                            best.setImg1PointRotInDegrees(rot1);</span>
<span class="nc" id="L850">                            best.setImg2PointRotInDegrees(rot2);</span>
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L857">        return best;</span>
    }
    
    protected FeatureComparisonStat[] findBestMatch(Features features1, 
        Features features2, CornerRegion cornerRegion1, 
        CornerRegion[] cornerRegions2, int dither) {
        
<span class="fc" id="L864">        FeatureComparisonStat best = null;</span>
        
        /*
        best3 ranks by intensity ssd only.  sometimes matches areas where
        projection has cause foreground or background changes that appear
        much more strongly in gradient and theta, so intensity alone may
        match, but the other two might not.
        */
<span class="fc" id="L872">        FeatureComparisonStat best3 = null;</span>
        
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (int idx2 = 0; idx2 &lt; cornerRegions2.length; ++idx2) {</span>

<span class="fc" id="L876">            CornerRegion cornerRegion2 = cornerRegions2[idx2];</span>

<span class="pc bpc" id="L878" title="1 of 2 branches missed.">            if (cornerRegion2 == null) {</span>
<span class="nc" id="L879">                continue;</span>
            }

            try {

                /*
                 for the given corner region1,
                 dither and make small rotation changes to find the 
                 best centering and rotation to minimize the differences
                 in gradient descriptors between cornerRegion1 and cornerRegion2.
                 */
<span class="fc" id="L890">                FeatureComparisonStat stat = ditherAndRotateForCorner1Location(</span>
                    features1, features2, cornerRegion1, cornerRegion2,
                    dither);
                
<span class="fc bfc" id="L894" title="All 2 branches covered.">                if (stat != null) {</span>

                    //compare all descriptors to find best
<span class="fc" id="L897">                    int x1 = stat.getImg1Point().getX();</span>
<span class="fc" id="L898">                    int y1 = stat.getImg1Point().getY();</span>
<span class="fc" id="L899">                    int rotD1 = Math.round(stat.getImg1PointRotInDegrees());</span>

<span class="fc" id="L901">                    int kMaxIdx2 = cornerRegion2.getKMaxIdx();</span>
<span class="fc" id="L902">                    int x2 = cornerRegion2.getX()[kMaxIdx2];</span>
<span class="fc" id="L903">                    int y2 = cornerRegion2.getY()[kMaxIdx2];</span>
<span class="fc" id="L904">                    int rotD2 = Math.round(</span>
<span class="fc" id="L905">                        cornerRegion2.getRelativeOrientationInDegrees());</span>

<span class="fc" id="L907">                    IntensityDescriptor iDesc1 = features1.extractIntensity(</span>
                        x1, y1, rotD1);
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">                    if (iDesc1 == null) {</span>
<span class="nc" id="L910">                        continue;</span>
                    }

<span class="fc" id="L913">                    ThetaDescriptor tDesc1 = features1.extractTheta(</span>
                        x1, y1, rotD1);
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">                    if (tDesc1 == null) {</span>
<span class="nc" id="L916">                        continue;</span>
                    }

<span class="fc" id="L919">                    GradientDescriptor gDesc1 = features1.extractGradient(</span>
                        x1, y1, rotD1);
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">                    if (gDesc1 == null) {</span>
<span class="nc" id="L922">                        continue;</span>
                    }

<span class="fc" id="L925">                    IntensityDescriptor iDesc2 = features2.extractIntensity(</span>
                        x2, y2, rotD2);
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">                    if (iDesc2 == null) {</span>
<span class="nc" id="L928">                        continue;</span>
                    }

<span class="fc" id="L931">                    ThetaDescriptor tDesc2 = features2.extractTheta(</span>
                        x2, y2, rotD2);
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">                    if (tDesc2 == null) {</span>
<span class="nc" id="L934">                        continue;</span>
                    }

<span class="fc" id="L937">                    GradientDescriptor gDesc2 = features2.extractGradient(</span>
                        x2, y2, rotD2);
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">                    if (gDesc2 == null) {</span>
<span class="nc" id="L940">                        continue;</span>
                    }

<span class="fc" id="L943">                    stat = Features.calculateStats(iDesc1, gDesc1, tDesc1,</span>
                        x1, y1, iDesc2, gDesc2, tDesc2, x2, y2);

//float diffRot = AngleUtil.getAngleDifference(rotD1, rotD2);
//log.info(&quot;diffRot=&quot; + diffRot + &quot; stat=&quot; + stat.toString());

<span class="fc bfc" id="L949" title="All 2 branches covered.">                    if (fitIsBetter(best, stat)) {</span>
<span class="fc" id="L950">                        best = stat;</span>
<span class="fc" id="L951">                        best.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L952">                        best.setImg2PointRotInDegrees(rotD2);</span>
                    }
                    
<span class="fc bfc" id="L955" title="All 2 branches covered.">                    if (fitIsBetter3(best3, stat)) {</span>
<span class="fc" id="L956">                        best3 = stat;</span>
<span class="fc" id="L957">                        best3.setImg1PointRotInDegrees(rotD1);</span>
<span class="fc" id="L958">                        best3.setImg2PointRotInDegrees(rotD2);</span>
                    }
                }
<span class="fc" id="L961">            } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
                //log.log(Level.SEVERE, null, ex);
<span class="fc" id="L963">            }</span>
        }
        
<span class="fc" id="L966">        int n = 0;</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">        if (best != null) {</span>
<span class="fc" id="L968">            n++;</span>
        }
<span class="fc bfc" id="L970" title="All 2 branches covered.">        if (best3 != null) {</span>
<span class="fc" id="L971">            n++;</span>
        }
<span class="fc" id="L973">        FeatureComparisonStat[] result = new FeatureComparisonStat[n];</span>
<span class="fc" id="L974">        n = 0;</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">        if (best != null) {</span>
<span class="fc" id="L976">            result[n] = best;</span>
<span class="fc" id="L977">            n++;</span>
        }
<span class="fc bfc" id="L979" title="All 2 branches covered.">        if (best3 != null) {</span>
<span class="fc" id="L980">            result[n] = best3;</span>
<span class="fc" id="L981">            n++;</span>
        }

<span class="fc" id="L984">        return result;</span>
    }

    /**
     * compares best to stat and returns true if stat is better.
     * comparison uses all 3 descriptors, that is intensity, gradient, and
     * theta.
     * @param best
     * @param stat
     * @return 
     */
    protected boolean fitIsBetter(FeatureComparisonStat best, 
        FeatureComparisonStat stat) {
        
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L999">            return false;</span>
        }
        
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        if ((stat.getSumIntensitySqDiff() &lt;= stat.getImg2PointIntensityErr()) &amp;&amp;</span>
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">            (stat.getSumGradientSqDiff() &lt;= stat.getImg2PointGradientErr())</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">            &amp;&amp; (stat.getSumThetaSqDiff() &lt;= stat.getImg2PointThetaErr())</span>
            ) {

<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (best == null) {</span>
<span class="fc" id="L1008">                return true;</span>
            } else {
<span class="fc" id="L1010">                if (</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                    (best.getSumIntensitySqDiff() &gt;= stat.getSumIntensitySqDiff())</span>
                    &amp;&amp; 
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                    (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff())</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">                    &amp;&amp; (best.getSumThetaSqDiff() &gt; stat.getSumThetaSqDiff())</span>
                    ) {
<span class="fc" id="L1016">                    return true;</span>
                }
            }
        }
        
<span class="fc" id="L1021">        return false;</span>
    }

    /**
     * compares best to stat and returns true if stat is better.
     * comparison checks that all 3 descriptors are smaller than their errors,
     * then uses intensity, gradient to find best.
     * @param best
     * @param stat
     * @return 
     */
    protected boolean fitIsBetter2(FeatureComparisonStat best, 
        FeatureComparisonStat stat) {
        
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L1036">            return false;</span>
        }
        
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if ((stat.getSumIntensitySqDiff() &lt;= stat.getImg2PointIntensityErr()) &amp;&amp;</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            (stat.getSumGradientSqDiff() &lt;= stat.getImg2PointGradientErr())</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            &amp;&amp; (stat.getSumThetaSqDiff() &lt;= stat.getImg2PointThetaErr())</span>
            ) {

<span class="nc bnc" id="L1044" title="All 2 branches missed.">            if (best == null) {</span>
<span class="nc" id="L1045">                return true;</span>
            } else {
<span class="nc" id="L1047">                if (</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                    (best.getSumIntensitySqDiff() &gt;= stat.getSumIntensitySqDiff())</span>
                    &amp;&amp; 
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                    (best.getSumGradientSqDiff() &gt; stat.getSumGradientSqDiff())</span>
                    ) {
<span class="nc" id="L1052">                    return true;</span>
                }
            }
        }
        
<span class="nc" id="L1057">        return false;</span>
    }
    
    /**
     * compares best to stat and returns true if stat is better.
     * comparison checks that all 3 descriptors are smaller than their errors,
     * then uses intensity, gradient to find best.
     * @param best
     * @param stat
     * @return 
     */
    protected boolean fitIsBetter3(FeatureComparisonStat best, 
        FeatureComparisonStat stat) {
        
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if (stat == null) {</span>
<span class="nc" id="L1072">            return false;</span>
        }
        
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        if ((stat.getSumIntensitySqDiff() &lt;= stat.getImg2PointIntensityErr()) &amp;&amp;</span>
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">            (stat.getSumGradientSqDiff() &lt;= stat.getImg2PointGradientErr())</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">            &amp;&amp; (stat.getSumThetaSqDiff() &lt;= stat.getImg2PointThetaErr())</span>
            ) {

<span class="fc bfc" id="L1080" title="All 2 branches covered.">            if (best == null) {</span>
<span class="fc" id="L1081">                return true;</span>
            } else {
<span class="fc" id="L1083">                if (</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">                    (best.getSumIntensitySqDiff() &gt;= stat.getSumIntensitySqDiff())</span>
                    ) {
<span class="fc" id="L1086">                    return true;</span>
                }
            }
        }
        
<span class="fc" id="L1091">        return false;</span>
    }

    protected Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt; 
        findMatchingFeatures(Features features1, Features features2, 
        CornerRegion[] cornerRegions1, CornerRegion[] cornerRegions2, 
        int blockHalfWidth, boolean useNormalizedIntensities) {
        
        Map&lt;PairInt, Map&lt;PairInt, Set&lt;FeatureComparisonStat&gt;&gt;&gt;
<span class="fc" id="L1100">            comparisonMap = new HashMap&lt;PairInt, Map&lt;PairInt, </span>
            Set&lt;FeatureComparisonStat&gt;&gt;&gt;();
                    
<span class="fc" id="L1103">        final int dither = 1;</span>
                
<span class="fc bfc" id="L1105" title="All 2 branches covered.">        for (int idx1 = 0; idx1 &lt; cornerRegions1.length; ++idx1) {</span>
            
<span class="fc" id="L1107">            CornerRegion cornerRegion1 = cornerRegions1[idx1];</span>
            
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">            if (cornerRegion1 == null) {</span>
<span class="nc" id="L1110">                continue;</span>
            }
            
<span class="fc" id="L1113">            FeatureComparisonStat[] best = findBestMatch(features1, features2,</span>
                cornerRegion1, cornerRegions2, dither);
            
<span class="pc bpc" id="L1116" title="1 of 4 branches missed.">            if ((best != null) &amp;&amp; (best.length &gt; 0)) {</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">                for (FeatureComparisonStat stat : best) {</span>
<span class="fc" id="L1118">                    storeInMap(comparisonMap, stat);</span>
                }
            }
        }
        
<span class="fc" id="L1123">        return comparisonMap;</span>
    }

    public static float[] calculateThetaDiff(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="pc bpc" id="L1128" title="2 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1129">            return null;</span>
        }
        
<span class="fc" id="L1132">        float[] values = new float[compStats.size()];</span>
        
<span class="fc bfc" id="L1134" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
            
<span class="fc" id="L1136">            FeatureComparisonStat stat = compStats.get(i);</span>
            
<span class="fc" id="L1138">            float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L1139">                stat.getImg1PointRotInDegrees(), stat.getImg2PointRotInDegrees());</span>
            
<span class="fc" id="L1141">            values[i] = diff;</span>
        }
        
<span class="fc" id="L1144">        return values;</span>
    }

    public static List&lt;Integer&gt; removeDiscrepantThetaDiff(
        List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="pc bpc" id="L1150" title="2 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1151">            return null;</span>
        }
        
<span class="fc" id="L1154">        float[] values = calculateThetaDiff(compStats);</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            if (values[i] &lt; 0) {</span>
<span class="fc" id="L1157">                values[i] += 360;</span>
            }
        }
        
        // 20 degree wide bins
<span class="fc" id="L1162">        HistogramHolder hist = Histogram.createSimpleHistogram(20.f, values, </span>
<span class="fc" id="L1163">            Errors.populateYErrorsBySqrt(values));</span>
        
<span class="fc" id="L1165">        int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="fc bfc" id="L1166" title="All 4 branches covered.">        if ((yMaxIdx &gt; -1) &amp;&amp; (hist.getYHist()[yMaxIdx] == 1)) {</span>
<span class="fc" id="L1167">            hist = Histogram.createSimpleHistogram(40.f, values, </span>
<span class="fc" id="L1168">                Errors.populateYErrorsBySqrt(values));</span>
<span class="fc" id="L1169">            yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
        }
        
        float thetaDiff;
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if (yMaxIdx == -1) {</span>
<span class="fc" id="L1174">            float[] thetaDiffMeanStDev = MiscMath.getAvgAndStDev(values);</span>
<span class="fc" id="L1175">            thetaDiff = thetaDiffMeanStDev[0];</span>
<span class="fc" id="L1176">        } else {</span>
<span class="fc" id="L1177">            thetaDiff = hist.getXHist()[yMaxIdx];</span>
        }
        
        //TODO: consider a bin larger than 20 degrees... 25
<span class="fc" id="L1181">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1184">            float diffRot = AngleUtil.getAngleDifference(values[i], thetaDiff);</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">            if (diffRot &gt; 20) {</span>
<span class="fc" id="L1186">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L1190" title="All 2 branches covered.">        for (int i = remove.size() - 1; i &gt; -1; --i) {</span>
<span class="fc" id="L1191">            int idx = remove.get(i);</span>
<span class="fc" id="L1192">            compStats.remove(idx);</span>
        }
        
<span class="fc" id="L1195">        return remove;</span>
    }
    
    public static float calculateDiffThetaMean(List&lt;FeatureComparisonStat&gt; 
        comparisonStats) {
        
<span class="nc" id="L1201">        float[] values = calculateThetaDiff(comparisonStats);</span>
        
<span class="nc bnc" id="L1203" title="All 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="nc" id="L1204">            return Float.POSITIVE_INFINITY;</span>
        }
        
<span class="nc" id="L1207">        double sum = 0;</span>
        
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc" id="L1210">            sum += values[i];</span>
        }
        
<span class="nc" id="L1213">        return (float) (sum / ((float) values.length));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RainbowFinder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">RainbowFinder.java</span></div><h1>RainbowFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.QuickSort;
import algorithms.combPerm.SubsetChooser;
import algorithms.compGeometry.MiscellaneousCurveHelper;
import algorithms.compGeometry.ParabolaLeastSquares;
import algorithms.imageProcessing.Sky.SkyObject;
import algorithms.imageProcessing.features.mser.Canonicalizer;
import algorithms.imageProcessing.features.mser.Canonicalizer.RegionGeometry;
import algorithms.imageProcessing.features.mser.MSEREdges;
import algorithms.imageProcessing.features.mser.Region;
import algorithms.misc.MiscMath;
import algorithms.search.NearestNeighbor2D;
import algorithms.util.OneDIntArray;
import algorithms.util.PairInt;
import algorithms.VeryLongBitString;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 * NOT READY FOR USE.
 * rewriting most of it.
 * 
 * class with methods to find a rainbow within an image and to create a hull
 * to encapsulate it for various methods.
 * 
 * @author nichole
 */
public class RainbowFinder {
    
<span class="fc" id="L40">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    static class Hull {
        float[] xHull;
        float[] yHull;
    }
    
<span class="fc" id="L47">    private Hull rainbowHull = null;</span>
    
<span class="fc" id="L49">    public RainbowFinder() {</span>
<span class="fc" id="L50">    }</span>
    
    /**
     * find rainbows in the blob detector results of MSER.
     * NOTE that the method needs more testing.
     * 
     * @param mserEdges
     * @return 
     */
    public List&lt;SkyObject&gt; findRainbows(MSEREdges mserEdges) {
        
        // there may be more than one rainbow in this set.
        // for example, a test image has 1 strong rainbow and 2 fainter ones.
            
<span class="fc" id="L64">        ImageExt img = mserEdges.getClrImg();</span>
        
<span class="fc" id="L66">        List&lt;Region&gt; polarThetaPositive = mserEdges._extractSensitivePT0();</span>
        
        /*
        segments of rainbows in two test images are found as elongated
        thin ellipses in the polar theta positive images,
        and those then have adjacent thin elongated regions in
        the polar theta negative images where the brighter arcs of the
        rainbow are.
        
        NOTE: once a rainbow is found, could look for others fainter in the
        image.
        */
<span class="fc" id="L78">        List&lt;Set&lt;PairInt&gt;&gt; listOfSets0 = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
        
<span class="fc" id="L80">        List&lt;OneDIntArray&gt; hists0 = new ArrayList&lt;OneDIntArray&gt;();</span>
        
<span class="fc" id="L82">        List&lt;RegionGeometry&gt; rgs0 = new ArrayList&lt;RegionGeometry&gt;();</span>

        //mserEdges._debugOrigRegions(2, &quot;_PT_&quot;);
<span class="fc" id="L85">        findPositivePT(img, polarThetaPositive, listOfSets0, hists0, rgs0);</span>
       
<span class="fc" id="L87">        List&lt;Region&gt; polarThetaNegative = mserEdges.getOrigGsPtRegions().get(3);</span>
        
<span class="fc" id="L89">        List&lt;Set&lt;PairInt&gt;&gt; listOfSets1 = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
        
<span class="fc" id="L91">        List&lt;OneDIntArray&gt; hists1 = new ArrayList&lt;OneDIntArray&gt;();</span>
        
<span class="fc" id="L93">        List&lt;RegionGeometry&gt; rgs1 = new ArrayList&lt;RegionGeometry&gt;();</span>

<span class="fc" id="L95">        findNegativePT(img, polarThetaNegative, listOfSets1, hists1, rgs1);</span>
       
<span class="fc" id="L97">        List&lt;VeryLongBitString&gt; listOfSetBits0 = makeBitStrings(listOfSets0, img);</span>
        
<span class="fc" id="L99">        List&lt;SkyObject&gt; output = new ArrayList&lt;SkyObject&gt;();</span>
        
<span class="fc" id="L101">        TIntList arcIdxs = findLargeArc(listOfSetBits0, listOfSets0, hists0, </span>
            rgs0, img);
        
<span class="pc bpc" id="L104" title="3 of 4 branches missed.">        if (arcIdxs == null || arcIdxs.isEmpty()) {</span>
<span class="fc" id="L105">            return null;</span>
        }
            
        // if have found a large arc in the positive image, search for 
        //    adjacent arcs in the negative regions

<span class="nc" id="L111">        Set&lt;PairInt&gt; arcPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (int j = 0; j &lt; arcIdxs.size(); ++j) {</span>
<span class="nc" id="L113">            arcPoints.addAll(listOfSets0.get(arcIdxs.get(j)));</span>
        }

<span class="nc" id="L116">        NearestNeighbor2D nn = new NearestNeighbor2D(arcPoints, </span>
<span class="nc" id="L117">            img.getWidth(), img.getHeight());</span>

<span class="nc" id="L119">        int[] negativeIdxs = findAdjacent(nn, listOfSets1, rgs1);</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (negativeIdxs != null) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            for (int idx1 : negativeIdxs) {</span>
<span class="nc" id="L123">                arcPoints.addAll(listOfSets1.get(idx1));</span>
            }

<span class="nc" id="L126">            Arrays.sort(negativeIdxs);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            for (int j = (negativeIdxs.length - 1); j &gt; -1; --j) {</span>
<span class="nc" id="L128">                int idx = negativeIdxs[j];</span>
<span class="nc" id="L129">                listOfSets1.remove(idx);</span>
<span class="nc" id="L130">                rgs1.remove(idx);</span>
<span class="nc" id="L131">                hists1.remove(idx);</span>
            }                
        }

        /*
        ptImg values for histogram bins:
         0:  red = 0 - 18
         1:  orange = 18 - 40
         2:  yellow = 41 - 60ish
         3:  green = 61 - 106
         4:  blue = 107 - 192
         5:  purple = 193 - 255
        */
<span class="nc" id="L144">        int[] ptCH = ColorHistogram.createPTHistogram(mserEdges.getPtImg(), </span>
            arcPoints);
        
<span class="nc" id="L147">        float[] normalizedHist = new float[ptCH.length];</span>
<span class="nc" id="L148">        int tot = 0;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (int c : ptCH) {</span>
<span class="nc" id="L150">            tot += c;</span>
        }
<span class="nc bnc" id="L152" title="All 2 branches missed.">        for (int j = 0; j &lt; ptCH.length; ++j) {</span>
<span class="nc" id="L153">            normalizedHist[j] = (float)ptCH[j]/(float)tot;</span>
        }
        
<span class="nc" id="L156">        System.out.println(&quot;rainbow? &quot; + Arrays.toString(ptCH) + </span>
<span class="nc" id="L157">            &quot;\n   &quot; + Arrays.toString(normalizedHist));</span>
        
<span class="nc bnc" id="L159" title="All 4 branches missed.">        boolean dark = normalizedHist[0] &gt; 0.1 </span>
            &amp;&amp; normalizedHist[1] &gt; 0.1;
<span class="nc bnc" id="L161" title="All 6 branches missed.">        boolean bright = normalizedHist[1] &gt; 0.01</span>
            &amp;&amp; normalizedHist[3] &gt; 0.01 
            &amp;&amp; normalizedHist[4] &gt; 0.01;
        
<span class="nc bnc" id="L165" title="All 4 branches missed.">        if (!dark &amp;&amp; !bright) {</span>
<span class="nc" id="L166">            return null;</span>
        }
        
<span class="nc" id="L169">        MiscellaneousCurveHelper ch = new MiscellaneousCurveHelper();</span>
<span class="nc" id="L170">        double[] xyCenter = ch.calculateXYCentroids(arcPoints);</span>
<span class="nc" id="L171">        int x = (int)Math.round(xyCenter[0]);</span>
<span class="nc" id="L172">        int y = (int)Math.round(xyCenter[1]);</span>

<span class="nc" id="L174">        SkyObject obj = new SkyObject();</span>
<span class="nc" id="L175">        obj.points = arcPoints;</span>
<span class="nc" id="L176">        obj.xyCenter = new int[]{x, y};</span>
<span class="nc" id="L177">        output.add(obj);</span>

<span class="nc" id="L179">        arcIdxs.sort();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (int j = (arcIdxs.size() - 1); j &gt; -1; --j) {</span>
<span class="nc" id="L181">            int arcIdx = arcIdxs.get(j);</span>
            //System.out.println(&quot;removing &quot; + 
            //    rgs0.get(arcIdx).xC + &quot;, &quot; + rgs0.get(arcIdx).yC);
<span class="nc" id="L184">            listOfSets0.remove(arcIdx);</span>
<span class="nc" id="L185">            listOfSetBits0.remove(arcIdx);</span>
<span class="nc" id="L186">            hists0.remove(arcIdx);</span>
<span class="nc" id="L187">            rgs0.remove(arcIdx);</span>
        }

<span class="nc" id="L190">        return output;</span>
    }
    
    /*
        rainbowCoeff = findRainbowPoints(skyPoints, 
            removedSets.getReflectedSunRemoved(), colorImg, 
            xOffset, yOffset, imageWidth, imageHeight,
            skyIsDarkGrey, allSkyColor, outputRainbowPoints);

        if (outputRainbowPoints.size() &lt; 10) {
            outputRainbowPoints.clear();
            rainbowCoeff = null;
        }
        
        if (rainbowCoeff != null) {
            
            rainbowHull = createRainbowHull(rainbowCoeff, 
                outputRainbowPoints, colorImg, xOffset, yOffset);
            
            if (rainbowHull != null) {
                
                //TODO: may need adjustment for a boundary being an image boundary
                
                int minXHull = (int)MiscMath.findMin(rainbowHull.xHull);
                int maxXHull = (int)Math.ceil(MiscMath.findMax(rainbowHull.xHull));
                int minYHull = (int)MiscMath.findMin(rainbowHull.yHull);
                int maxYHull = (int)Math.ceil(MiscMath.findMax(rainbowHull.yHull));
                PointInPolygon p = new PointInPolygon();
                for (int col = minXHull; col &lt;= maxXHull; col++) {
                    for (int row = minYHull; row &lt;= maxYHull; row++) {
                        boolean in = p.isInSimpleCurve(col, row, 
                            rainbowHull.xHull, rainbowHull.yHull, 
                            rainbowHull.yHull.length);
                        if (in) {
                            excludePointsInRainbowHull.add(new PairInt(col, row));
                        }
                    }
                }
                
                if (!excludePointsInRainbowHull.isEmpty()) {
                    // addRainbow to Hull, but only if there are sky points adjacent to hull
                    addRainbowToPoints(skyPoints, imageWidth - 1, imageHeight - 1);
                }
            }
        }
    }
    
    public void addRainbowToSkyPoints(Set&lt;PairInt&gt; skyPoints, 
        int lastImgCol, int lastImgRow) {
        
        addRainbowToPoints(skyPoints, lastImgCol, lastImgRow);
    }
    
    private void addRainbowToPoints(Set&lt;PairInt&gt; skyPoints, 
        int lastImgCol, int lastImgRow) {
         
        
        int nHull = rainbowHull.xHull.length;
        int nHalf = nHull &gt;&gt; 1;
        for (int c = 0; c &lt; nHalf; c++) {
            
            int count0 = c;
            int count1 = nHull - 2 - c;
            
            double dy0 = rainbowHull.yHull[count0 + 1] - rainbowHull.yHull[count0];
            double dx0 = rainbowHull.xHull[count0 + 1] - rainbowHull.xHull[count0];
            int dist0 = (int)Math.sqrt(dx0*dx0 + dy0*dy0);

            double dy1 = rainbowHull.yHull[count1 - 1] - rainbowHull.yHull[count1];
            double dx1 = rainbowHull.xHull[count1 - 1] - rainbowHull.xHull[count1];
            int dist1 = (int)Math.sqrt(dx1*dx1 + dy1*dy1);

            boolean removeSection = false;
            
            int dist = (dist0 &lt; dist1) ? dist0 : dist1;
            for (int i = 0; i &lt; dist; i++) {
                int x0 = (int)(rainbowHull.xHull[count0] + i*dx0);
                int y0 = (int)(rainbowHull.yHull[count0] + i*dy0);

                int x1 = (int)(rainbowHull.xHull[count1] + i*dx1);
                int y1 = (int)(rainbowHull.yHull[count1] + i*dy1);

                int n0Sky = 0;
                int n0SkyPossible = 0;
                int n1Sky = 0;
                int n1SkyPossible = 0;
                for (int type = 0; type &lt; 2; type++) {
                    int x = (type == 0) ? x0 : x1;
                    int y = (type == 0) ? y0 : y1;
                    int n = 0;
                    int nPossible = 0;
                    for (int col = (x - 1); col &lt;= (x + 1); col++) {
                        if ((col &lt; 0) || (col &gt; lastImgCol)) {
                            continue;
                        }
                        for (int row = (y - 1); row &lt;= (y + 1); row++) {
                            if ((row &lt; 0) || (row &gt; lastImgRow)) {
                                continue;
                            }
                            PairInt p = new PairInt(col, row);
                            if (!excludePointsInRainbowHull.contains(p)) {
                                nPossible++;
                                if (skyPoints.contains(p)) {
                                    n++;
                                }
                            }
                        }
                    }
                    if (type == 0) {
                        n0Sky = n;
                        n0SkyPossible = nPossible;
                    } else {
                        n1Sky = n;
                        n1SkyPossible = nPossible;
                    }
                }
                // evaluate the n's and shorten rainbowHull values for count0 and count1 if needed
                float n0Div = (float)n0Sky/(float)n0SkyPossible;
                float n1Div = (float)n1Sky/(float)n1SkyPossible;
                if ((n0Div &lt; 0.5) || (n1Div &lt; 0.5)) {
                    removeSection = true;
                    break;
                }
            } // end for i
            if (removeSection) {
                
                // remove points from rainbowHull
                float[] xh = new float[]{
                    rainbowHull.xHull[count0], rainbowHull.xHull[count0 + 1],
                    rainbowHull.xHull[count1 - 1], rainbowHull.xHull[count1],
                    rainbowHull.xHull[count0]};
                float[] yh = new float[]{
                    rainbowHull.yHull[count0], rainbowHull.yHull[count0 + 1],
                    rainbowHull.yHull[count1 - 1], rainbowHull.yHull[count1],
                    rainbowHull.yHull[count0]};
                
                int minXHull = (int)MiscMath.findMin(xh);
                int maxXHull = (int)Math.ceil(MiscMath.findMax(xh));
                int minYHull = (int)MiscMath.findMin(yh);
                int maxYHull = (int)Math.ceil(MiscMath.findMax(yh));
                PointInPolygon p = new PointInPolygon();
                for (int col = minXHull; col &lt;= maxXHull; col++) {
                    for (int row = minYHull; row &lt;= maxYHull; row++) {
              
                        boolean in = p.isInSimpleCurve(col, row, xh, yh, 
                            xh.length);
                        if (in) {
                            excludePointsInRainbowHull.remove(new PairInt(col, row));
                        }
                    }
                }
            }
        }
        
        skyPoints.addAll(excludePointsInRainbowHull);
        
    }

     // @return polynomial fit coefficients to 
    // y[i] = c0*1 + c1*x[i] + c2*x[i]*x[i].  this may be null if a fit wasn't
     // possible.
     
    float[] findRainbowPoints(Set&lt;PairInt&gt; skyPoints, 
        Set&lt;PairInt&gt; reflectedSunRemoved,
        ImageExt colorImg, int xOffset, int yOffset, 
        int imageWidth, int imageHeight,
        boolean skyIsDarkGrey, GroupPixelColors allSkyColor,
        Set&lt;PairInt&gt; outputRainbowPoints) {

        Set&lt;PairInt&gt; rainbowPoints = findRainbowColoredPoints(colorImg, 
            reflectedSunRemoved, xOffset, yOffset, skyIsDarkGrey);

        if (rainbowPoints.isEmpty()) {
            return null;
        }
        
        if (rainbowPoints.size() &lt; 12) {
            return null;
        }
        
        if (rainbowPoints.size() &gt; 0.25*(colorImg.getWidth()*colorImg.getHeight())) {
            if ((allSkyColor.getAvgBlue()/allSkyColor.getAvgRed()) &lt; 0.5) {
                return null;
            }
        }
        
        // fit a polynomial to rainbow points.  
        // would prefer a circle, but the optical depth of the dispersers and the
        // orientation of groups of them is not always a slab perpendicular to 
        // the camera

        int[] minMaxXY = MiscMath.findMinMaxXY(rainbowPoints);
        log.fine(&quot;rainbow range in x: &quot; + minMaxXY[0] + &quot; to &quot; + minMaxXY[1]);
        
        //TODO: consider contiguous subsets at this point
        
        PolynomialFitter polyFitter = new PolynomialFitter();
        //y = c0*1 + c1*x[i] + c2*x[i]*x[i]
        float[] coef = polyFitter.solveAfterRandomSampling(rainbowPoints);
             
        if (coef == null) {
            return null;
        }
        
        log.info(&quot;rainbow polynomial coefficients = &quot; + Arrays.toString(coef));
        log.info(&quot;image dimensions are &quot; + colorImg.getWidth() + &quot; X &quot; + 
            colorImg.getHeight() + &quot; pixels^2&quot;);
         
        polyFitter.plotFit(coef, rainbowPoints, colorImg.getWidth(),
            colorImg.getHeight(), 23, &quot;rainbow points&quot;);
        
        double resid = PolyFitter2.calcResiduals(coef, rainbowPoints);

        //TODO: determine this more accurately:
        if (resid &gt; 5) {
            
            Set&lt;PairInt&gt; bestFittingPoints = new HashSet&lt;PairInt&gt;();
            
            coef = polyFitter.solveForBestFittingContiguousSubSets(
                rainbowPoints, bestFittingPoints, colorImg.getWidth(), 
                colorImg.getHeight());
            
        }
    }
   
    private Hull createRainbowHull(float[] rainbowCoeff, 
        Set&lt;PairInt&gt; rainbowPoints, ImageExt originalColorImage, int xOffset, 
        int yOffset) {   
        
        int width = originalColorImage.getWidth() - xOffset;
        int height = originalColorImage.getHeight() - yOffset;
        
        rainbowSkeletonX = new float[10];
        rainbowSkeletonY = new float[10];
        generatePolynomialPoints(rainbowPoints, rainbowCoeff, rainbowSkeletonX, 
            rainbowSkeletonY);
       
        float maxOfPointMinDistances = maxOfPointMinDistances(rainbowPoints,
            rainbowSkeletonX, rainbowSkeletonY);
        
        float high = 2 * maxOfPointMinDistances;
        float low = maxOfPointMinDistances / 2;
        int nMatched = 0;
     
        float[] xPoly = new float[2 * rainbowSkeletonX.length + 1];
        float[] yPoly = new float[xPoly.length];
        int nMaxIter = 5;
        int nIter = 0;
        
        int eps = (int)(0.15f * rainbowPoints.size());
        
        while ((low &lt; high) &amp;&amp; (nIter &lt; nMaxIter)) {
            
            float mid = (high + low)/2.f;
            
            hullHalfWidth = mid;
            
            populatePolygon(rainbowSkeletonX, rainbowSkeletonY, mid, 
                xPoly, yPoly, rainbowCoeff, width, height);
            
            nMatched = nPointsInPolygon(rainbowPoints, xPoly, yPoly);
            
            log.info(&quot;low=&quot; + low + &quot; high=&quot; + high + &quot; mid=&quot; + mid 
                + &quot; nMatched=&quot; + nMatched + &quot; out of &quot; + rainbowPoints.size());

            if (Math.abs(nMatched - rainbowPoints.size()) &lt; eps) {
                if (low &lt; mid) {
                    // decrease high so next mid is lower
                    high = mid;
                } else {
                    break;
                }
            } else {
                // nMatched &lt; rainbowPoints.size()
                // increase low so next mid is higher
                low = mid;
            }
            
            nIter++;
        }
        
        //TODO: once a reasonable hullHalfWidth has been determined,
        // may want to regenerate the hull with higher resolution,
        // that is 5 or 10 times the number of skeleton points on 
        // each side
         
        Hull hull = new Hull();
        hull.xHull = xPoly;
        hull.yHull = yPoly;

        return hull;
    }
    
    protected void generatePolynomialPoints(Set&lt;PairInt&gt; points, 
        float[] polyCoeff, float[] outputX, float[] outputY) {
       
        PolynomialFitter fitter = new PolynomialFitter();
        float[] minXYMaxXY = fitter.determineGoodEndPoints(polyCoeff, points);
        
        // find the furthest points that have the smallest residuals on each side
        int minX = (int)minXYMaxXY[0];
        int yForMinX = (int)minXYMaxXY[1];
        int maxX = (int)minXYMaxXY[2];
        int yForMaxX = (int)minXYMaxXY[3];
        
        log.info(&quot;polyCoeff=&quot; + Arrays.toString(polyCoeff) 
            + &quot; endpoints=(&quot; + minX + &quot;,&quot; + yForMinX + &quot;) (&quot; + maxX + &quot;,&quot; 
            + yForMaxX + &quot;)&quot;);
       
        int n = outputX.length;
        
        // max-min divided by 9 gives 8 more points
        float deltaX = (maxX - minX)/(float)(n - 1);
        
        outputX[0] = minX;
        outputY[0] = yForMinX;
        for (int i = 1; i &lt; (n - 1); i++) {
            outputX[i] = outputX[i - 1] + deltaX;
            outputY[i] = polyCoeff[0] + polyCoeff[1] * outputX[i] 
                + polyCoeff[2] * outputX[i] * outputX[i];
            
        }
        
        outputX[n - 1] = maxX;
        outputY[n - 1] = yForMaxX;
        
    }
    
    protected float maxOfPointMinDistances(Set&lt;PairInt&gt; rainbowPoints, 
        float[] xc, float[] yc) {
        
        double maxDistSq = Double.MIN_VALUE;
        
        for (PairInt p : rainbowPoints) {
            int x = p.getX();
            int y = p.getY();
            double minDistSq = Double.MAX_VALUE;
            int minIdx = -1;
            for (int i = 0; i &lt; xc.length; i++) {
                float diffX = xc[i] - x;
                float diffY = yc[i] - y;
                float dist = (diffX * diffX) + (diffY * diffY);
                if (dist &lt; minDistSq) {
                    minDistSq = dist;
                    minIdx = i;
                }
            }
            if (minDistSq &gt; maxDistSq) {
                maxDistSq = minDistSq;
            } 
        }
        
        return (float)Math.sqrt(maxDistSq);
    }

    protected void populatePolygon(float[] x, float[] y, float dist, 
        float[] outputXPoly, float[] outputYPoly, float[] polynomialCoeff,
        int imgWidth, int imgHeight) {
        
        if (x == null || y == null) {
            throw new IllegalArgumentException(&quot;neither x nor y can be null&quot;);
        }
        if (x.length != y.length) {
            throw new IllegalArgumentException(&quot;x and y must be the same length&quot;);
        }
        if (outputXPoly == null || outputYPoly == null) {
            throw new IllegalArgumentException(
                &quot;neither outputXPoly nor outputYPoly can be null&quot;);
        }
        if (outputXPoly.length != outputYPoly.length) {
            throw new IllegalArgumentException(
                &quot;outputXPoly and outputYPoly must be the same length&quot;);
        }
        if (polynomialCoeff == null) {
            throw new IllegalArgumentException(
                &quot;polynomialCoeff cannot be null&quot;);
        }
        if (polynomialCoeff.length != 3) {
            throw new IllegalArgumentException(
                &quot;polynomialCoeff.length has to be 3&quot;);
        }
        if (outputXPoly.length != (2*x.length + 1)) {
            throw new IllegalArgumentException(&quot;outputXPoly.length must be &quot; +
                &quot; (2 * x.length) + 1&quot;);
        }
        
        //y = c0*1 + c1*x[i] + c2*x[i]*x[i]
        
        //dy/dx = c1 + 2*c2*x[i] = tan theta
        
        int n = outputXPoly.length;
        
       
        int count0 = 0;
        int count1 = n - 2;
        
        for (int i = 0; i &lt; x.length; i++) {
            
            double dydx = polynomialCoeff[1] + (2. * polynomialCoeff[2] * x[i]);
            
            if (dydx == 0) {
                // same x, y's are +- dist
                outputXPoly[count0] = x[i];
                outputYPoly[count0] = y[i] + dist;
                count0++;
                outputXPoly[count1] = x[i];
                outputYPoly[count1] = y[i] - dist;
                count1--;
                continue;
            }
            
            double tangentSlope = -1./dydx;
            double theta = Math.atan(tangentSlope);
            double dy = dist * Math.sin(theta);    
            double dx = dist * Math.cos(theta);
            
            if ((count0 == 0) &amp;&amp; (x[i] == 0)) {
                dy = dist;
                dx = 0;
            } else if (
                ((count0 == ((x.length/2) - 1) || (count0 == (x.length/2))))
                &amp;&amp; (x[i] == (imgWidth - 1))) {
                dy = dist;
                dx = 0;
            }
            
            //System.out.println(&quot;i=&quot; + i + &quot; theta=&quot; + theta
            //    + &quot; x[i]=&quot; + x[i] + &quot; dx=&quot; + dx + &quot; dy=&quot; + dy);
          
            float xHigh = (float)(x[i] + dx);
            float yHigh = (float)(y[i] + dy);
            
            float xLow = (float)(x[i] - dx);
            float yLow = (float)(y[i] - dy);
              
            if (theta &lt; 0) {
                float tx = xHigh;
                float ty = yHigh;
                xHigh = xLow;
                yHigh = yLow;
                xLow = tx;
                yLow = ty;
            }
            
            if (xHigh &lt; 0) {
                xHigh = 0;
            }
            if (yHigh &lt; 0) {
                yHigh = 0;
            }
            if (xLow &lt; 0) {
                xLow = 0;
            }
            if (yLow &lt; 0) {
                yLow = 0;
            }
            if (xLow &gt; (imgWidth - 1)) {
                xLow = (imgWidth - 1);
            }
            if (xHigh &gt; (imgWidth - 1)) {
                xHigh = (imgWidth - 1);
            }
            if (yLow &gt; (imgHeight - 1)) {
                yLow = (imgHeight - 1);
            }
            if (yHigh &gt; (imgHeight - 1)) {
                yHigh = (imgHeight - 1);
            }
            
            outputXPoly[count0] = xHigh;
            outputYPoly[count0] = yHigh;
            count0++;
            outputXPoly[count1] = xLow;
            outputYPoly[count1] = yLow;
            count1--;
        }
       
        outputXPoly[outputXPoly.length - 1] = outputXPoly[0];
        outputYPoly[outputXPoly.length - 1] = outputYPoly[0];
    }
    */
    
    private void extractHues(ImageExt img, Set&lt;PairInt&gt; points, 
        int[] hues, float[] sbAvg) {
        
<span class="fc" id="L675">        float sum0 = 0;</span>
<span class="fc" id="L676">        float sum1 = 0;</span>
        
<span class="fc" id="L678">        float[] hsb = new float[3];</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L680">            int r = img.getR(p);</span>
<span class="fc" id="L681">            int g = img.getG(p);</span>
<span class="fc" id="L682">            int b = img.getB(p);</span>
<span class="fc" id="L683">            Color.RGBtoHSB(r, g, b, hsb);</span>
            
<span class="fc" id="L685">            sum0 += hsb[1];</span>
<span class="fc" id="L686">            sum1 += hsb[2];</span>
            
            // TODO: consider satudation and brightness limits
<span class="fc" id="L689">            int bin = (int)(hsb[0]/0.1f);</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">            if (bin == 10) {</span>
<span class="nc" id="L691">                bin--;</span>
            }
<span class="fc" id="L693">            hues[bin]++;</span>
<span class="fc" id="L694">        }</span>
        
<span class="fc" id="L696">        sum0 /= (float)points.size();</span>
<span class="fc" id="L697">        sum1 /= (float)points.size();</span>
    
<span class="fc" id="L699">        sbAvg[0] = sum0;</span>
<span class="fc" id="L700">        sbAvg[1] = sum1;</span>
<span class="fc" id="L701">    }</span>

    private boolean isWithinBounds(int x, int y, int width, int height) {
    
<span class="nc bnc" id="L705" title="All 8 branches missed.">        if (x &lt; 0 || y &lt; 0 || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L706">            return false;</span>
        }
<span class="nc" id="L708">        return true;</span>
    }
    
    private boolean isEmpty(int[] hues) {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        for (int h : hues) {</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            if (h != 0) {</span>
<span class="fc" id="L714">                return false;</span>
            }
        }
<span class="nc" id="L717">        return true;</span>
    }

    private List&lt;VeryLongBitString&gt; clusterByIntersection(List&lt;OneDIntArray&gt; hists, 
        float minIntersection) {
        
<span class="nc" id="L723">        ColorHistogram ch = new ColorHistogram();</span>
        
<span class="nc" id="L725">        List&lt;VeryLongBitString&gt; out = new ArrayList&lt;VeryLongBitString&gt;();</span>
        
<span class="nc bnc" id="L727" title="All 2 branches missed.">        for (int i = 0; i &lt; hists.size(); ++i) {</span>
            
<span class="nc" id="L729">            OneDIntArray h = hists.get(i);</span>
            
<span class="nc" id="L731">            VeryLongBitString indexes = new VeryLongBitString(hists.size());</span>
<span class="nc" id="L732">            boolean didSet = false;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            for (int j = (i + 1); j &lt; hists.size(); ++j) {</span>
<span class="nc" id="L734">                OneDIntArray h2 = hists.get(j);</span>
<span class="nc" id="L735">                float intersection = ch.intersection(h.a, h2.a);</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">                if (intersection &gt;= minIntersection) {</span>
<span class="nc" id="L737">                    indexes.setBit(j);</span>
<span class="nc" id="L738">                    didSet = true;</span>
                }
            }
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (didSet) {</span>
<span class="nc" id="L742">                indexes.setBit(i);</span>
                // if this bitstring is not a subset of an existing in out, add
<span class="nc" id="L744">                boolean doNotAdd = false;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                for (int j = 0; j &lt; i; ++j) {</span>
<span class="nc" id="L746">                    VeryLongBitString bs = out.get(j);</span>
<span class="nc" id="L747">                    VeryLongBitString intersectionBS = bs.and(indexes);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                    if (intersectionBS.getNSetBits() == indexes.getNSetBits()) {</span>
<span class="nc" id="L749">                        doNotAdd = true;</span>
<span class="nc" id="L750">                        break;</span>
                    }
                }
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (!doNotAdd) {</span>
<span class="nc" id="L754">                    out.add(indexes);</span>
                }
            }
        }
        
        // add entries for the sets by themselves
<span class="nc bnc" id="L760" title="All 2 branches missed.">        for (int i = 0; i &lt; hists.size(); ++i) {            </span>
<span class="nc" id="L761">            OneDIntArray h = hists.get(i);</span>
<span class="nc" id="L762">            VeryLongBitString indexes = new VeryLongBitString(hists.size());</span>
<span class="nc" id="L763">            indexes.setBit(i);</span>
<span class="nc" id="L764">            out.add(indexes);</span>
        }
       
<span class="nc" id="L767">        return out;</span>
    }

    private void findPositivePT(ImageExt img, 
        List&lt;Region&gt; polarThetaPositive, List&lt;Set&lt;PairInt&gt;&gt; listOfSets, 
        List&lt;OneDIntArray&gt; hists, List&lt;RegionGeometry&gt; rgs) {
        
<span class="fc bfc" id="L774" title="All 2 branches covered.">        for (int rIdx = 0; rIdx &lt; polarThetaPositive.size(); ++rIdx) {</span>
            
<span class="fc" id="L776">            Region r = polarThetaPositive.get(rIdx);</span>
           
<span class="fc" id="L778">            Set&lt;PairInt&gt; set1 = null;</span>
                        
<span class="fc bfc" id="L780" title="All 2 branches covered.">            for (int i = 0; i &lt; r.accX.size(); ++i) {</span>
<span class="fc" id="L781">                int x = r.accX.get(i);</span>
<span class="fc" id="L782">                int y = r.accY.get(i);</span>
<span class="fc" id="L783">                PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L784">                int pixIdx = img.getInternalIndex(p);</span>
               
<span class="fc bfc" id="L786" title="All 2 branches covered.">                if (set1 == null) {</span>
<span class="fc" id="L787">                    set1 = new HashSet&lt;PairInt&gt;();</span>
                }
<span class="fc" id="L789">                set1.add(p);</span>
            }
            
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            if (set1 != null) {</span>
                
<span class="fc" id="L794">                RegionGeometry rg = Canonicalizer.calculateEllipseParams(</span>
<span class="fc" id="L795">                    r, img.getWidth(), img.getHeight());</span>
                
                /*System.out.format(
                    &quot;%d : xy=(%d,%d) angle=%.2f &quot;
                        + &quot; ecc=%.3f minor=%.3f major=%.3f n=%d\n&quot;,
                    rIdx, rg.xC, rg.yC,
                    (rg.orientation * 180. / Math.PI),
                    (float) rg.eccentricity, (float) rg.minor, 
                    (float) rg.major, set1.size());
                */
                
<span class="fc bfc" id="L806" title="All 2 branches covered.">                if (rg.eccentricity &gt;= 0.95) {</span>
                    
<span class="fc" id="L808">                    int[] hues = new int[10];</span>
<span class="fc" id="L809">                    float[] sbAvg = new float[2];</span>
<span class="fc" id="L810">                    extractHues(img, set1, hues, sbAvg);</span>
                    
                    //System.out.println(&quot;  &quot; + rIdx + &quot; hues=&quot; + Arrays.toString(hues));
                    
<span class="pc bpc" id="L814" title="2 of 4 branches missed.">                    if (isEmpty(hues) || Float.isNaN(sbAvg[0])) {</span>
<span class="nc" id="L815">                        continue;</span>
                    }
                                        
                    /*
                    bright sky:
                            sAvg=0.23  vAvg=0.75
                        rnbw hues peak is 2nd bin
                    dark sky:
                           sAvg=0.5   bck vAvg=0.43
                        rnbw hues peak is 1st peak
                    */
                    
<span class="fc" id="L827">                    int maxPeakIdx = MiscMath.findYMaxIndex(hues);</span>
<span class="fc" id="L828">                    int hIdx = -1;</span>
                    
                    //NOTE: this may need to be revised
<span class="fc bfc" id="L831" title="All 2 branches covered.">                    if (sbAvg[1] &lt; 0.55) {</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">                        if (maxPeakIdx == 0) {</span>
<span class="fc" id="L833">                            hIdx = hists.size();</span>
<span class="fc" id="L834">                            listOfSets.add(set1);</span>
<span class="fc" id="L835">                            hists.add(new OneDIntArray(hues));</span>
<span class="fc" id="L836">                            rgs.add(rg);</span>
                        }
                    } else {
<span class="fc bfc" id="L839" title="All 2 branches covered.">                        if (maxPeakIdx == 1) {</span>
<span class="fc" id="L840">                            hIdx = hists.size();</span>
<span class="fc" id="L841">                            listOfSets.add(set1);</span>
<span class="fc" id="L842">                            hists.add(new OneDIntArray(hues));</span>
<span class="fc" id="L843">                            rgs.add(rg);</span>
                        }
                    }
                    
                    /*System.out.println(
                        &quot;  &quot; + rIdx + &quot; xy=(&quot; + rg.xC + &quot;,&quot; + rg.yC + &quot;) &quot;
                        + &quot; maxIdx=&quot; + maxPeakIdx
                        + &quot; hists.idx=&quot; + hIdx
                        + &quot; angle=&quot; + (rg.orientation*180./Math.PI)
                        + &quot; ecc=&quot; + rg.eccentricity
                        + &quot;\n  sAvg=&quot; + sbAvg[0] 
                        + &quot;    vAvg=&quot; + sbAvg[1]
                        + &quot; hues hist=&quot; + Arrays.toString(hues)
                    );*/
                }
            }
        }        
<span class="fc" id="L860">    }</span>
    
    private void findNegativePT(ImageExt img, 
        List&lt;Region&gt; polarThetaNegative, List&lt;Set&lt;PairInt&gt;&gt; listOfSets, 
        List&lt;OneDIntArray&gt; hists, List&lt;RegionGeometry&gt; rgs) {
        
<span class="fc bfc" id="L866" title="All 2 branches covered.">        for (int rIdx = 0; rIdx &lt; polarThetaNegative.size(); ++rIdx) {</span>
            
<span class="fc" id="L868">            Region r = polarThetaNegative.get(rIdx);</span>
           
<span class="fc" id="L870">            Set&lt;PairInt&gt; set1 = null;</span>
                        
<span class="fc bfc" id="L872" title="All 2 branches covered.">            for (int i = 0; i &lt; r.accX.size(); ++i) {</span>
<span class="fc" id="L873">                int x = r.accX.get(i);</span>
<span class="fc" id="L874">                int y = r.accY.get(i);</span>
<span class="fc" id="L875">                PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L876">                int pixIdx = img.getInternalIndex(p);</span>
               
<span class="fc bfc" id="L878" title="All 2 branches covered.">                if (set1 == null) {</span>
<span class="fc" id="L879">                    set1 = new HashSet&lt;PairInt&gt;();</span>
                }
<span class="fc" id="L881">                set1.add(p);</span>
            }
            
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">            if (set1 != null) {</span>
                
<span class="fc" id="L886">                RegionGeometry rg = Canonicalizer.calculateEllipseParams(</span>
<span class="fc" id="L887">                    r, img.getWidth(), img.getHeight());</span>

                //System.out.println(&quot;negative xy=&quot; 
                //   + rg.xC + &quot;,&quot; + rg.yC 
                //   + &quot; ecc=&quot; + rg.eccentricity);
                
<span class="fc bfc" id="L893" title="All 2 branches covered.">                if (rg.eccentricity &gt;= 0.95) {</span>
                    
<span class="fc" id="L895">                    int[] hues = new int[10];</span>
<span class="fc" id="L896">                    float[] sbAvg = new float[2];</span>
<span class="fc" id="L897">                    extractHues(img, set1, hues, sbAvg);</span>
                    
<span class="pc bpc" id="L899" title="2 of 4 branches missed.">                    if (isEmpty(hues) || Float.isNaN(sbAvg[0])) {</span>
<span class="nc" id="L900">                        continue;</span>
                    }
                   
                    /*
                    bright sky:
                        sAvg=0.07   vAvg=0.86
                        hues hist=[0, 0, 0, 0, 3, 36, 0, 0, 0, 0]
                        rnbw hues peak is  bin
                    dark sky:
                        sAvg=  vAvg=
                        hues hist=
                        rnbw hues
                    */
                    
<span class="fc" id="L914">                    int maxPeakIdx = MiscMath.findYMaxIndex(hues);</span>
                    
                    //NOTE: this may need to be revised
<span class="fc bfc" id="L917" title="All 2 branches covered.">                    if (maxPeakIdx == 5) {</span>
<span class="fc" id="L918">                        listOfSets.add(set1);</span>
<span class="fc" id="L919">                        hists.add(new OneDIntArray(hues));</span>
<span class="fc" id="L920">                        rgs.add(rg);</span>
                    }
                    
                    /*System.out.println(&quot;negative xy=(&quot; + rg.xC + &quot;,&quot; + rg.yC + &quot;) &quot;
                        + &quot; angle=&quot; + (rg.orientation*180./Math.PI)
                        + &quot; ecc=&quot; + rg.eccentricity
                        + &quot;\n   sAvg=&quot; + sbAvg[0] 
                        + &quot;\n   vAvg=&quot; + sbAvg[1]
                        + &quot;\n   hues hist=&quot; + Arrays.toString(hues)
                    );*/
                   
                }
            }
        }        
<span class="fc" id="L934">    }</span>
    
    private TIntList findLargeArc(List&lt;VeryLongBitString&gt; listOfSetBits, 
        List&lt;Set&lt;PairInt&gt;&gt; listOfSets, 
        List&lt;OneDIntArray&gt; hists0, List&lt;RegionGeometry&gt; rgs0, Image img) {
    
<span class="fc" id="L940">        int n = listOfSetBits.size();</span>
        
<span class="fc" id="L942">        int[] sizes = new int[n];</span>
<span class="fc" id="L943">        int[] indexes = new int[n];</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">        for (int i = 0; i &lt; listOfSetBits.size(); ++i) {</span>
<span class="fc" id="L945">            sizes[i] = (int)listOfSetBits.get(i).getNSetBits();</span>
<span class="fc" id="L946">            indexes[i] = i;</span>
        }
<span class="fc" id="L948">        QuickSort.sortBy1stArg(sizes, indexes);</span>
        
<span class="fc bfc" id="L950" title="All 2 branches covered.">        for (int i = n - 1; i &gt; 0; --i) {</span>
<span class="fc" id="L951">            int idx0 = indexes[i];</span>
<span class="fc" id="L952">            VeryLongBitString bs = listOfSetBits.get(idx0);</span>
<span class="fc" id="L953">            int nbs0 = (int)bs.getNSetBits();</span>
            
<span class="fc" id="L955">            TIntList subsetIdxs = new TIntArrayList();</span>
<span class="fc" id="L956">            int nInSubsets = 0;</span>
            
<span class="fc" id="L958">            ParabolaLeastSquares polyFitter0 = null;</span>
<span class="fc" id="L959">            float[] coeff0 = null;</span>
            
<span class="fc bfc" id="L961" title="All 2 branches covered.">            for (int j = i - 1; j &gt; -1; --j) {</span>
<span class="fc" id="L962">                int idx1 = indexes[j];</span>
<span class="fc" id="L963">                VeryLongBitString bs2 = listOfSetBits.get(idx1);</span>
<span class="fc" id="L964">                int nbs2 = (int)bs2.getNSetBits();</span>
                
<span class="fc" id="L966">                VeryLongBitString inter = bs.and(bs2);</span>
<span class="fc" id="L967">                int nbsi = (int)inter.getNSetBits();</span>
                
<span class="fc bfc" id="L969" title="All 2 branches covered.">                if ((nbs2 - nbsi) &lt; 0.1*(nbs2)) {</span>
<span class="fc" id="L970">                    subsetIdxs.add(idx1);</span>
<span class="fc" id="L971">                    nInSubsets += nbs2;</span>
                }
            }
            
<span class="fc bfc" id="L975" title="All 2 branches covered.">            if (!subsetIdxs.isEmpty()) {</span>
                
                // if not empty, check to see if set idx0 is an arc rather
                //    than a large level set which includes most of the image
<span class="fc" id="L979">                RegionGeometry rg0 = rgs0.get(idx0);</span>
<span class="fc" id="L980">                double area = rg0.major * rg0.minor;</span>
            
<span class="fc" id="L982">                double dens = ((double)listOfSets.get(idx0).size())/area;</span>
                
                /*System.out.println(&quot;dens of x,y=&quot; + rg0.xC + &quot;,&quot; + rg0.yC
                    + &quot; -&gt; &quot; + String.format(&quot;%.3f&quot;, dens)
                    + &quot; nPts=&quot; + nbs0 + &quot; nInSubsets=&quot; + nInSubsets    
                );*/
                
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">                if (dens &gt; 0.1) {</span>
                    
                    // fit a polynomial to rainbow points.  
                    // would prefer a circle, but the optical depth of the dispersers and the
                    // orientation of groups of them is not always a slab perpendicular to 
                    // the camera
                    
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">                    if (polyFitter0 == null) {</span>
<span class="fc" id="L997">                        polyFitter0 = new ParabolaLeastSquares();</span>
<span class="fc" id="L998">                        Set&lt;PairInt&gt; set = listOfSets.get(idx0);</span>
                        
                        //y = c0*1 + c1*x[i] + c2*x[i]*x[i]
<span class="fc" id="L1001">                        polyFitter0.accumulate(set);</span>
<span class="fc" id="L1002">                        coeff0 = polyFitter0.solve();</span>
                        
<span class="fc" id="L1004">                        ParabolaLeastSquares.plotFit(coeff0, set, img.getWidth(),</span>
<span class="fc" id="L1005">                            img.getHeight(), i, </span>
                            &quot;rainbow points&quot;);

<span class="fc" id="L1008">                        double resid = ParabolaLeastSquares.calcResiduals(coeff0, set);</span>
                        
                        /*System.out.println(&quot;rainbow polynomial coefficients = &quot; 
                            + Arrays.toString(coeff0));
                        System.out.println(&quot;image dimensions are &quot; + img.getWidth() + &quot; X &quot;
                            + img.getHeight() + &quot; pixels^2 &quot; 
                            + &quot; resid=&quot; + resid
                            + &quot; rg.coeff=&quot; + Arrays.toString(rg0.m)
                        );*/

<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">                        if (resid &lt; 5) {</span>
                            
<span class="nc" id="L1020">                            TIntSet chk = new TIntHashSet(subsetIdxs);</span>
                            
                            // since we have a polynomial now,
                            // look for other regions that may fit on the arc
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                            for (int j = i - 1; j &gt; -1; --j) {</span>
<span class="nc" id="L1025">                                int idx1 = indexes[j];</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                                if (chk.contains(idx1)) {</span>
<span class="nc" id="L1027">                                    continue;</span>
                                }
                                     
<span class="nc" id="L1030">                                Set&lt;PairInt&gt; chkSet = listOfSets.get(idx1);</span>
                                
<span class="nc" id="L1032">                                ParabolaLeastSquares polyFitter2 = polyFitter0.copy();</span>
<span class="nc" id="L1033">                                polyFitter2.accumulate(chkSet);</span>
                                
<span class="nc" id="L1035">                                float[] coeff2 = polyFitter2.solve();</span>
                                
<span class="nc" id="L1037">                                Set&lt;PairInt&gt; tmp = new HashSet&lt;PairInt&gt;(set);</span>
<span class="nc" id="L1038">                                tmp.addAll(chkSet);</span>
                                
<span class="nc" id="L1040">                                double resid2 = ParabolaLeastSquares.calcResiduals(coeff2, </span>
                                    tmp);
                                
                                //System.out.println(&quot;check &quot; + &quot; x=&quot; + 
                                //    rgs0.get(idx1).xC + &quot; y=&quot; +
                                //    rgs0.get(idx1).yC + &quot; resid=&quot; + resid2);
                                
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                                if (resid2 &gt; 5) {</span>
<span class="nc" id="L1048">                                    continue;</span>
                                }
                        
<span class="nc" id="L1051">                                RegionGeometry chkRg = rgs0.get(idx1);</span>
                                
                                //System.out.println(&quot;check &quot; + &quot; x=&quot; + chkRg.xC + &quot; y=&quot; +
                                //    chkRg.yC + &quot; resid=&quot; + resid2);
                            
<span class="nc" id="L1056">                                subsetIdxs.add(idx1);</span>
                                //set.addAll(chkSet);
                            }
                            
<span class="nc" id="L1060">                            subsetIdxs.add(idx0);</span>
<span class="nc" id="L1061">                            return subsetIdxs;</span>
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L1068">        return null;</span>
    }

    private List&lt;VeryLongBitString&gt; makeBitStrings(List&lt;Set&lt;PairInt&gt;&gt; 
        listOfSets, Image img) {
        
<span class="fc" id="L1074">        List&lt;VeryLongBitString&gt; out = new ArrayList&lt;VeryLongBitString&gt;();</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : listOfSets) {</span>
<span class="fc" id="L1076">            VeryLongBitString bs = new VeryLongBitString(img.getNPixels());</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L1078">                bs.setBit(img.getInternalIndex(p));</span>
<span class="fc" id="L1079">            }</span>
<span class="fc" id="L1080">            out.add(bs);</span>
<span class="fc" id="L1081">        }</span>
        
<span class="fc" id="L1083">        return out;</span>
    }

    private int[] findAdjacent(NearestNeighbor2D nn, 
        List&lt;Set&lt;PairInt&gt;&gt; listOfSets, List&lt;RegionGeometry&gt; rgs) {

<span class="nc" id="L1089">        TIntList idxs2 = new TIntArrayList();</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        for (int i = 0; i &lt; listOfSets.size(); ++i) {</span>
            
<span class="nc" id="L1092">            Set&lt;PairInt&gt; set = listOfSets.get(i);</span>
<span class="nc" id="L1093">            RegionGeometry rg = rgs.get(i);</span>
            
<span class="nc" id="L1095">            int n = set.size();</span>
<span class="nc" id="L1096">            int nAdj = 0;</span>
            
<span class="nc" id="L1098">            int d = 5;</span>
<span class="nc" id="L1099">            int m = 2 * (int)Math.round(rg.minor);</span>
            
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L1102">                Set&lt;PairInt&gt; nearest = nn.findClosest(p.getX(), p.getY(), d);</span>
<span class="nc bnc" id="L1103" title="All 4 branches missed.">                if (nearest != null &amp;&amp; !nearest.isEmpty()) {</span>
<span class="nc" id="L1104">                    nAdj++;</span>
                }
<span class="nc" id="L1106">            }</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">            if (nAdj &gt; 0) {</span>
<span class="nc" id="L1108">                float f = ((float)d)/(float)m;</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                if (f &gt; 1) {</span>
<span class="nc" id="L1110">                    f = 1;</span>
                }
                //System.out.println(&quot;nAdj=&quot; + nAdj 
                //    + &quot; f*n=&quot; + (f*n) + &quot; setx=&quot; + rg.xC + &quot; y=&quot; + rg.yC
                //    + &quot; n=&quot; + n);
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                if (nAdj &gt;= (f*n)) {</span>
<span class="nc" id="L1116">                    idxs2.add(i);</span>
                }
            }
        }
        
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (idxs2.isEmpty()) {</span>
<span class="nc" id="L1122">            return null;</span>
        }
        
<span class="nc" id="L1125">        return idxs2.toArray(new int[idxs2.size()]);</span>
    }
    
    private TIntList findBestCombination(int[] idxs, 
        List&lt;Set&lt;PairInt&gt;&gt; listOfSets, List&lt;RegionGeometry&gt; rgs) {
        
<span class="nc" id="L1131">        TIntList bestIdxs = new TIntArrayList();</span>
        
<span class="nc" id="L1133">        double minResid = Double.MAX_VALUE;</span>
        
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        for (int k = idxs.length; k &gt; 0; k--) {</span>
            
<span class="nc" id="L1137">            int[] selectedIndexes = new int[k];</span>
            
<span class="nc" id="L1139">            SubsetChooser subsetChooser = new SubsetChooser(idxs.length, k);</span>
            
<span class="nc" id="L1141">            int nV = subsetChooser.getNextSubset(selectedIndexes);</span>
            
<span class="nc" id="L1143">            ParabolaLeastSquares polyFitter = new ParabolaLeastSquares();</span>
        
<span class="nc bnc" id="L1145" title="All 2 branches missed.">            while (nV != -1) {</span>
                
<span class="nc" id="L1147">                Set&lt;PairInt&gt; subset = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1149">                StringBuilder sb = new StringBuilder();</span>
                
<span class="nc bnc" id="L1151" title="All 2 branches missed.">                for (int bitIndex : selectedIndexes) {</span>

<span class="nc" id="L1153">                    Set&lt;PairInt&gt; g = listOfSets.get(bitIndex);</span>

<span class="nc" id="L1155">                    subset.addAll(g);</span>
                    
<span class="nc" id="L1157">                    RegionGeometry rg = rgs.get(bitIndex);</span>
                    
<span class="nc" id="L1159">                    sb.append(String.format(&quot; (%d,%d) &quot;, rg.xC, rg.yC));</span>
                }
                
<span class="nc" id="L1162">                polyFitter.accumulate(subset);</span>
                                
<span class="nc" id="L1164">                float[] coeff = polyFitter.solve();</span>
                
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (coeff == null) {</span>
<span class="nc" id="L1167">                    continue;</span>
                }
               
<span class="nc" id="L1170">                double resid = ParabolaLeastSquares.calcResiduals(coeff, subset);</span>
                
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                if (resid &gt; 5) {</span>
<span class="nc" id="L1173">                    nV = subsetChooser.getNextSubset(selectedIndexes);</span>
<span class="nc" id="L1174">                    continue;</span>
                }
                
<span class="nc" id="L1177">                sb.append(String.format(&quot; resid=%.3f\n&quot;, resid));</span>
                
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                if (resid &lt; minResid) {</span>
<span class="nc" id="L1180">                    minResid = resid;</span>
<span class="nc" id="L1181">                    bestIdxs.clear();</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                    for (int bitIndex : selectedIndexes) {</span>
<span class="nc" id="L1183">                        bestIdxs.add(bitIndex);</span>
                    }
                }
                
<span class="nc" id="L1187">                System.out.println(sb.toString());</span>
            
<span class="nc" id="L1189">                nV = subsetChooser.getNextSubset(selectedIndexes);</span>
<span class="nc" id="L1190">            }</span>
        }

<span class="nc" id="L1193">        return bestIdxs;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>
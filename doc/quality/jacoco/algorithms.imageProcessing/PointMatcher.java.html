<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PointMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">PointMatcher.java</span></div><h1>PointMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.MultiArrayMergeSort;
import algorithms.SubsetChooser;
import algorithms.compGeometry.PointPartitioner;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairFloat;
import algorithms.util.PairFloatArray;
import algorithms.util.PairFloatArrayUnmodifiable;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonPlotterPNG;
import algorithms.util.RangeInt;
import algorithms.util.ResourceFinder;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;

/**
 * class to match the points extracted from two images.
 *
 * the transformation parameters of translation, rotation and scale are
 * found given the two sets of points.

 * The resulting transformation returns rotation in a clockwise direction.

 * @author nichole
 */
<span class="fc" id="L47">public final class PointMatcher extends AbstractPointMatcher {</span>

<span class="fc" id="L49">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>

    // when true, there is additional logging and creation of simplex data
    // that can be viewed with resources/plot_3d_simplex_n10.html
<span class="fc" id="L53">    protected boolean debug = false;</span>

<span class="fc" id="L55">    protected boolean usePreSearchAlt1 = true;</span>

<span class="fc" id="L57">    protected static int minTolerance = 5;</span>

    //NOTE: solution is sensitive to this number
<span class="fc" id="L60">    private float generalTolerance = 10;</span>

<span class="fc" id="L62">    public static float toleranceGridFactor = 4.f;</span>

<span class="fc" id="L64">    protected int largeSearchLimit = 20;</span>

<span class="fc" id="L66">    protected float transDeltaPreSearch0 = 4;//10;</span>
<span class="fc" id="L67">    protected float rotDeltaPreSearch0 = 2;</span>

<span class="fc" id="L69">    protected float rotHalfRangeInDegreesPreSearch1Alt2 = 10;</span>
<span class="fc" id="L70">    protected float rotDeltaInDegreesPreSearch1Alt2 = 2;</span>
<span class="fc" id="L71">    protected float transXHalfRangePreSearch1Alt2 = 200;</span>
<span class="fc" id="L72">    protected float transXDeltaPreSearch1Alt2 = 15;</span>

    public void setLargeSearchLimit(int limit) {
<span class="nc" id="L75">        largeSearchLimit = limit;</span>
<span class="nc" id="L76">    }</span>

    /**
     * given the unmatched point sets, and the expectation that the 2 sets
     * have rotation wrt one another less than 30 degrees,
     * calculate the best fitting transformation
     * and then apply the transformation to the first set to return matched
     * points within a tolerance.
     *
     * @param skylineCorners1
     * @param skylineCorners2
     * @param corners1
     * @param corners2
     * @param outputMatchedSet1
     * @param outputMatchedSet2
     * @param useLargestToleranceForOutput use the largest tolerance for
     * applying the transformation to point sets during matching.  the largest
     * tolerance is the class variable generalTolerance.
     * If useLargestToleranceForOutput is false, the transformation's best
     * fit is used during matching (which should provide a smaller but more
     * certain matched output).  If this method is used as a precursor to
     * projection (epipolar) solvers of sets that do have projection components,
     * one might prefer to set this to true to allow more to be matched.
     * @param useGreedyMatching
     * @return best fitting transformation between unmatched points sets
     *
     * @return
     */
    public TransformationPointFit performMatchingForMostlyVerticalTranslation(
        PairIntArray skylineCorners1, PairIntArray skylineCorners2,
        PairIntArray corners1, PairIntArray corners2,
        PairIntArray outputMatchedSet1, PairIntArray outputMatchedSet2,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

<span class="nc" id="L110">        float scale = 1;</span>
<span class="nc" id="L111">        float rotationLowLimitInDegrees = 335;</span>
<span class="nc" id="L112">        float rotationHighLimitInDegrees = 25;</span>

<span class="nc" id="L114">        TransformationPointFit fit = calculateEuclideanTransformation(</span>
            skylineCorners1, skylineCorners2,
            corners1, corners2,
            scale, rotationLowLimitInDegrees, rotationHighLimitInDegrees);

<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (fit == null) {</span>
<span class="nc" id="L120">            return null;</span>
        }

        float translationXTolerance, translationYTolerance;

<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L126">            translationXTolerance = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L127">            translationYTolerance = translationXTolerance;</span>
        } else {
<span class="nc" id="L129">            translationXTolerance = 2 * fit.getTranslationXTolerance();</span>
<span class="nc" id="L130">            translationYTolerance = 2 * fit.getTranslationYTolerance();</span>
        }

<span class="nc" id="L133">        PairIntArray comb1 = skylineCorners1.copy();</span>
<span class="nc" id="L134">        comb1.addAll(corners1);</span>
<span class="nc" id="L135">        PairIntArray comb2 = skylineCorners2.copy();</span>
<span class="nc" id="L136">        comb2.addAll(corners2);</span>

        //TODO: might need tolerance to be as high as 20

<span class="nc" id="L140">        match(fit.getParameters(), comb1, comb2,</span>
            outputMatchedSet1, outputMatchedSet2,
            translationXTolerance, translationYTolerance, useGreedyMatching);

<span class="nc" id="L144">        return fit;</span>
    }

    /**
     * given the unmatched point sets, and the expectation that the 2 sets
     * have rotation wrt one another less than 30 degrees,
     * calculate the best fitting transformation
     * and then apply the transformation to the first set to return matched
     * points within a tolerance.
     *
     * @param set1
     * @param set2
     * @param outputMatchedSet1
     * @param outputMatchedSet2
     * @param useLargestToleranceForOutput use the largest tolerance for
     * applying the transformation to point sets during matching.  the largest
     * tolerance is the class variable generalTolerance.
     * If useLargestToleranceForOutput is false, the transformation's best
     * fit is used during matching (which should provide a smaller but more
     * certain matched output).  If this method is used as a precursor to
     * projection (epipolar) solvers of sets that do have projection components,
     * one might prefer to set this to true to allow more to be matched.
     * @param useGreedyMatching
     * @return best fitting transformation between unmatched points sets
     *
     * @return
     */
    public TransformationPointFit performMatchingForMostlyVerticalTranslation(
        PairIntArray set1, PairIntArray set2,
        PairIntArray outputMatchedSet1, PairIntArray outputMatchedSet2,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

<span class="nc" id="L176">        long nPairPerm = estimateNStepsPairCalculation(set1.getN(),</span>
<span class="nc" id="L177">            set2.getN());</span>

<span class="nc" id="L179">        log.info(&quot;nPairPerm=&quot; + nPairPerm);</span>

<span class="nc" id="L181">        float scale = 1;</span>
<span class="nc" id="L182">        float rotationLowLimitInDegrees = 335;</span>
<span class="nc" id="L183">        float rotationHighLimitInDegrees = 25;</span>

<span class="nc" id="L185">        TransformationPointFit fit = null;</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (nPairPerm &gt; 1e9) {</span>

<span class="nc" id="L189">            log.warning(&quot;assuming scale=1 to solve.&quot; +</span>
            &quot;currently not able to solve for scale too in large sets in reasonable time so &quot; +
            &quot; you can reduce your set sizes or use vert trans methods for better solutions.&quot;);
<span class="nc" id="L192">            fit = preSearch(set1, set2, scale, rotationLowLimitInDegrees,</span>
                rotationHighLimitInDegrees, useGreedyMatching);

        } else {
<span class="nc" id="L196">            fit = calculateEuclideanTransformation(</span>
                set1, set2, scale, rotationLowLimitInDegrees,
                rotationHighLimitInDegrees);
        }

<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (fit == null) {</span>
<span class="nc" id="L202">            return null;</span>
        }

        float translationXTolerance, translationYTolerance;

<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L208">            translationXTolerance = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L209">            translationYTolerance = translationXTolerance;</span>
        } else {
<span class="nc" id="L211">            translationXTolerance = 2 * fit.getTranslationXTolerance();</span>
<span class="nc" id="L212">            translationYTolerance = 2 * fit.getTranslationYTolerance();</span>
        }

<span class="nc" id="L215">        match(fit.getParameters(), set1, set2, outputMatchedSet1, outputMatchedSet2,</span>
            translationXTolerance, translationYTolerance, useGreedyMatching);

<span class="nc" id="L218">        return fit;</span>
    }

    /**
     * given the unmatched point sets, calculates the best fitting transformation
     * and then applies the transformation to the first set to return matched
     * points within a tolerance.
     *
     * @param unmatchedLeftXY
     * @param unmatchedRightXY
     * @param outputMatchedLeftXY
     * @param outputMatchedRightXY
     * @param useLargestToleranceForOutput use the largest tolerance for
     * applying the transformation to point sets during matching.  the largest
     * tolerance is the class variable generalTolerance.
     * If useLargestToleranceForOutput is false, the transformation's best
     * fit is used during matching (which should provide a smaller but more
     * certain matched output).  If this method is used as a precursor to
     * projection (epipolar) solvers of sets that do have projection components,
     * one might prefer to set this to true to allow more to be matched.
     * @return best fitting transformation between unmatched points sets
     *
     * @return
     */
    public TransformationPointFit performMatching(
        PairIntArray unmatchedLeftXY, PairIntArray unmatchedRightXY,
        PairIntArray outputMatchedLeftXY, PairIntArray outputMatchedRightXY,
        boolean useLargestToleranceForOutput) {

<span class="nc" id="L247">        TransformationPointFit transFit =</span>
<span class="nc" id="L248">            calculateEuclideanTransformation(unmatchedLeftXY, unmatchedRightXY);</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (transFit == null) {</span>
<span class="nc" id="L251">            return null;</span>
        }

<span class="nc bnc" id="L254" title="All 2 branches missed.">        int nMaxMatchable = (unmatchedLeftXY.getN() &lt; unmatchedRightXY.getN()) ?</span>
<span class="nc" id="L255">            unmatchedLeftXY.getN() : unmatchedRightXY.getN();</span>

        //transFit.setMaximumNumberMatchable(nMaxMatchable);

<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (nMaxMatchable == 0) {</span>
<span class="nc" id="L260">            return transFit;</span>
        }

        // -- transform filtered1 for matching and evaluation

        float translationXTolerance, translationYTolerance;

<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L268">            translationXTolerance = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L269">            translationYTolerance = translationXTolerance;</span>
        } else {
<span class="nc" id="L271">            translationXTolerance = 2 * transFit.getTranslationXTolerance();</span>
<span class="nc" id="L272">            translationYTolerance = 2 * transFit.getTranslationYTolerance();</span>
        }

<span class="nc" id="L275">        boolean useGreedyMatching = true;</span>

<span class="nc" id="L277">        match(transFit.getParameters(), unmatchedLeftXY, unmatchedRightXY,</span>
            outputMatchedLeftXY, outputMatchedRightXY,
            translationXTolerance, translationYTolerance, useGreedyMatching);

<span class="nc" id="L281">        return transFit;</span>
    }

    /**
     * calculate for Euclidean transformation from set1 to set2 for
     * the points being unmatched.
     *
     * @param set1
     * @param set2
     * @return
     */
    public TransformationPointFit calculateEuclideanTransformation(
        PairIntArray set1, PairIntArray set2) {

<span class="fc" id="L295">        int n1 = set1.getN();</span>
<span class="fc" id="L296">        int n2 = set2.getN();</span>

<span class="fc" id="L298">        long nPairPerm = estimateNStepsPairCalculation(n1, n2);</span>

<span class="fc" id="L300">        log.info(&quot;nPairPerm=&quot; + nPairPerm + &quot; n1=&quot; + n1 + &quot; n2=&quot; + n2);</span>

<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (nPairPerm &gt; 10e9) {</span>
<span class="nc" id="L303">            log.warning(&quot;assuming scale=1 to solve.&quot; +</span>
            &quot;currently not able to solve for scale too in large sets in reasonable time so &quot; +
            &quot; you can reduce your set sizes or use vert trans methods for better solutions.&quot;);
<span class="nc" id="L306">            float scale = 1;</span>
<span class="nc" id="L307">            boolean useGreedyMatching = true;</span>
<span class="nc" id="L308">            return preSearch(set1, set2, scale, useGreedyMatching);</span>
        }

<span class="fc" id="L311">        boolean earlyConvergeReturn = true;</span>

<span class="fc" id="L313">        long t0 = System.currentTimeMillis();</span>

<span class="fc" id="L315">        List&lt;TransformationPointFit&gt; fits = calculateEuclideanTransformationUsingPairs(</span>
            set1, set2, earlyConvergeReturn);

<span class="fc" id="L318">        long t1 = System.currentTimeMillis();</span>

<span class="fc" id="L320">        log.info(&quot;calculateEuclideanTransformationUsingPairs seconds=&quot; +</span>
            ((t1 - t0)*1e-3));

<span class="pc bpc" id="L323" title="2 of 4 branches missed.">        if (fits == null || fits.isEmpty()) {</span>
<span class="nc" id="L324">            return null;</span>
        }

<span class="fc" id="L327">        boolean useGreedyMatching = true;</span>

        // find the best fit to corners1, corners2
<span class="fc" id="L330">        TransformationPointFit bestFit = null;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (int i = 0; i &lt; fits.size(); ++i) {</span>

<span class="fc" id="L333">            TransformationPointFit fit  = fits.get(i);</span>

<span class="fc" id="L335">            TransformationPointFit fitA = evaluateForUnmatched(</span>
<span class="fc" id="L336">                fit.getParameters(), set1, set2,</span>
                generalTolerance, generalTolerance, useGreedyMatching);

<span class="fc" id="L339">            log.info(&quot;test fit w/ corners=&quot; + fitA.toString());</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">            if (fitIsBetter(bestFit, fitA)) {</span>
<span class="fc" id="L342">                bestFit = fitA;</span>
            }
        }

<span class="fc" id="L346">        log.info(&quot;best fitting to all corners from best fits=&quot;</span>
<span class="fc" id="L347">            + bestFit.toString());</span>

<span class="fc" id="L349">        TransformationPointFit fit2 = refineAfterCalculationWithPairs(</span>
<span class="fc" id="L350">            bestFit.getParameters().copy(), set1, set2,</span>
            useGreedyMatching);

<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        if (fitIsBetter(bestFit, fit2)) {</span>
<span class="nc" id="L354">            bestFit = fit2;</span>
        }

<span class="fc" id="L357">        return bestFit;</span>
    }

    /**
     * calculate for Euclidean transformation from set1 to set2 for
     * unmatched points.
     *
     * @param scale
     * @param rotationLowLimitInDegrees
     * @param rotationHighLimitInDegrees
     * @return
     */
    public TransformationPointFit calculateEuclideanTransformation(
        PairIntArray skylineCorners1, PairIntArray skylineCorners2,
        PairIntArray corners1, PairIntArray corners2,
        float scale,
        float rotationLowLimitInDegrees, float rotationHighLimitInDegrees) {

<span class="nc" id="L375">        boolean earlyConvergeReturn = false;</span>
<span class="nc" id="L376">        boolean useLargestToleranceForOutput = true;</span>
<span class="nc" id="L377">        boolean useGreedyMatching = true;</span>

<span class="nc" id="L379">        long t0 = System.currentTimeMillis();</span>

<span class="nc" id="L381">        List&lt;TransformationPointFit&gt; fits = new ArrayList&lt;TransformationPointFit&gt;();</span>
<span class="nc" id="L382">        List&lt;Float&gt; tols = new ArrayList&lt;Float&gt;();</span>

        //TODO: for an image with large projection effects, this may need to be a larger number.
<span class="nc" id="L385">        float[] tolerances = new float[]{10, 15};</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        for (float tol : tolerances) {</span>

<span class="nc" id="L388">            generalTolerance = tol;</span>

<span class="nc" id="L390">            List&lt;TransformationPointFit&gt; fits2 =</span>
<span class="nc" id="L391">                calculateEuclideanTransformationForSmallSets(</span>
                skylineCorners1, skylineCorners2,
                scale, rotationLowLimitInDegrees, rotationHighLimitInDegrees,
                earlyConvergeReturn, useLargestToleranceForOutput, useGreedyMatching);

<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (fits2 != null) {</span>
<span class="nc" id="L397">                fits.addAll(fits2);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                for (int i = 0; i &lt; fits2.size(); ++i) {</span>
<span class="nc" id="L399">                    tols.add(Float.valueOf(tol));</span>
                }
            }
        }

<span class="nc" id="L404">        long t1 = System.currentTimeMillis();</span>

<span class="nc" id="L406">        log.info(&quot;(&quot; + ((t1 - t0)*1e-3) + &quot; seconds for eucl w/ pairs of skyline.&quot;);</span>

<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (fits.isEmpty()) {</span>

<span class="nc" id="L410">            PairIntArray comb1 = skylineCorners1.copy();</span>
<span class="nc" id="L411">            comb1.addAll(corners1);</span>
<span class="nc" id="L412">            PairIntArray comb2 = skylineCorners2.copy();</span>
<span class="nc" id="L413">            comb2.addAll(corners2);</span>

<span class="nc" id="L415">            return calculateEuclideanTransformation(comb1, comb2, scale,</span>
                rotationLowLimitInDegrees, rotationHighLimitInDegrees);
        }

        // find the best fit to corners1, corners2
<span class="nc" id="L420">        TransformationPointFit bestFit = null;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        for (int i = 0; i &lt; fits.size(); ++i) {</span>

<span class="nc" id="L423">            TransformationPointFit fit  = fits.get(i);</span>

<span class="nc" id="L425">                TransformationPointFit fitA = evaluateForUnmatched(</span>
<span class="nc" id="L426">                    fit.getParameters(), corners1, corners2,</span>
                    generalTolerance, generalTolerance, useGreedyMatching);

<span class="nc" id="L429">                log.info(&quot;test skyline params to corners=&quot; + fitA.toString());</span>

<span class="nc bnc" id="L431" title="All 2 branches missed.">                if (fitIsBetter(bestFit, fitA)) {</span>
<span class="nc" id="L432">                    bestFit = fitA;</span>
<span class="nc" id="L433">                    generalTolerance = tols.get(i).floatValue();</span>
                }
        }

<span class="nc" id="L437">        log.info(&quot;best fitting to all corners from best fits=&quot;</span>
<span class="nc" id="L438">            + bestFit.toString());</span>

        // fit the entire datasets using skyline fit

<span class="nc" id="L442">        PairIntArray comb1 = skylineCorners1.copy();</span>
<span class="nc" id="L443">        comb1.addAll(corners1);</span>
<span class="nc" id="L444">        PairIntArray comb2 = skylineCorners2.copy();</span>
<span class="nc" id="L445">        comb2.addAll(corners2);</span>

<span class="nc" id="L447">        TransformationPointFit fit2 = refineAfterCalculationWithPairs(</span>
<span class="nc" id="L448">            bestFit.getParameters().copy(), comb1, comb2, useGreedyMatching);</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (fitIsBetter(bestFit, fit2)) {</span>
<span class="nc" id="L451">            bestFit = fit2;</span>
        }

<span class="nc" id="L454">        return bestFit;</span>
    }

    /**
     * calculate for Euclidean transformation from set1 to set2 for
     * unmatched points.
     *
     * @param set1
     * @param set2
     * @param scale
     * @param rotationLowLimitInDegrees
     * @param rotationHighLimitInDegrees
     * @return
     */
    public TransformationPointFit calculateEuclideanTransformation(
        PairIntArray set1, PairIntArray set2,
        float scale,
        float rotationLowLimitInDegrees, float rotationHighLimitInDegrees) {

<span class="nc" id="L473">        boolean earlyConvergeReturn = true;</span>
<span class="nc" id="L474">        boolean useLargestToleranceForOutput = true;</span>
<span class="nc" id="L475">        boolean useGreedyMatching = true;</span>

        //TODO: consider using multiple tolerances if sets are small enough

<span class="nc" id="L479">        List&lt;TransformationPointFit&gt; fits =</span>
<span class="nc" id="L480">            calculateEuclideanTransformationUsingPairs(set1, set2,</span>
            scale, rotationLowLimitInDegrees, rotationHighLimitInDegrees,
            earlyConvergeReturn, useLargestToleranceForOutput, useGreedyMatching);

<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (fits.isEmpty()) {</span>
<span class="nc" id="L485">            return null;</span>
        }

<span class="nc" id="L488">        TransformationPointFit bestFit = null;</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">        for (int i = 0; i &lt; fits.size(); ++i) {</span>

<span class="nc" id="L492">            TransformationPointFit fit  = fits.get(i);</span>

<span class="nc" id="L494">            log.info(&quot;compare fit=&quot; + fit.toString());</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">            if (fitIsBetter(bestFit, fit)) {</span>
<span class="nc" id="L497">                bestFit = fit;</span>
            }
        }

<span class="nc" id="L501">        log.info(&quot;best fitting to all corners from best fits=&quot;</span>
<span class="nc" id="L502">            + bestFit.toString());</span>

<span class="nc" id="L504">        TransformationPointFit fit2 = refineAfterCalculationWithPairs(</span>
<span class="nc" id="L505">            bestFit.getParameters().copy(), set1, set2,</span>
            useGreedyMatching);

<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (fitIsBetter(bestFit, fit2)) {</span>
<span class="nc" id="L509">            bestFit = fit2;</span>
        }

<span class="nc" id="L512">        return bestFit;</span>
    }

    /**
     * an experimental method that creates corners to make matching points sets.
     * At a later time there will be a more formal stereoscopic matcher in the project
     * to register images and make disparity maps with.
     *
     * @param leftImg
     * @param rightImg
     * @return
     */
    public TransformationPointFit stereoscopicPointMatcher(ImageExt leftImg,
        ImageExt rightImg, PairIntArray outputMatchedLeft,
        PairIntArray outputMatchedRight) throws IOException, NoSuchAlgorithmException {

<span class="nc" id="L528">        ImageExt leftImgOrig = (ImageExt)leftImg.copyImage();</span>
<span class="nc" id="L529">        ImageExt rightImgOrig = (ImageExt)rightImg.copyImage();</span>

        /*
        uses color segmentation, then binary segmentation, then a gap filling
        algorithm, then a binning algorithm to make the image size &lt; 200 x 200,
        then  creates corners, then calculates the euclidean transformation
        from the best pair's solution.
         */

<span class="nc" id="L538">        int binFactor1 = (int) Math.ceil(Math.max((float)leftImg.getWidth()/200.f,</span>
<span class="nc" id="L539">            (float)leftImg.getHeight()/200.));</span>
        //int binFactor2 = (int) Math.round(Math.max((float)rightImg.getWidth()/200.f,
        //    (float)rightImg.getHeight()/200.));

<span class="nc" id="L543">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L544">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
        GreyscaleImage csImg1, csImg2;

<span class="nc" id="L547">        long t0 = System.currentTimeMillis();</span>

        if (false) {
            csImg1 = imageSegmentation.applyUsingCIEXYPolarThetaThenHistEq(leftImg, 3, true);
            imageSegmentation.applyUsingKMPP(csImg1, 2);
            Map&lt;Integer, Integer&gt; freqMap = Histogram.createAFrequencyMap(csImg1);
            int lowValue1 = Integer.MAX_VALUE;
            int highValue1 = Integer.MIN_VALUE;
            for (Integer v : freqMap.keySet()) {
                if (v.intValue() &lt; lowValue1) {
                    lowValue1 = v.intValue();
                }
                if (v.intValue() &gt; highValue1) {
                    highValue1 = v.intValue();
                }
            }
            imageProcessor.fillInPixels(csImg1, lowValue1, 50);
            imageProcessor.fillInPixels(csImg1, highValue1, 50);
            csImg1 = imageProcessor.binImage(csImg1, binFactor1);
            ImageIOHelper.writeOutputImage(ResourceFinder.findDirectory(&quot;bin&quot;)
                + &quot;/color_segmentation1.png&quot;, csImg1);

            csImg2 = imageSegmentation.applyUsingCIEXYPolarThetaThenHistEq(rightImg, 3, true);
            imageSegmentation.applyUsingKMPP(csImg2, 2);
            freqMap = Histogram.createAFrequencyMap(csImg2);
            int lowValue2 = Integer.MAX_VALUE;
            int highValue2 = Integer.MIN_VALUE;
            for (Integer v : freqMap.keySet()) {
                if (v.intValue() &lt; lowValue2) {
                    lowValue2 = v.intValue();
                }
                if (v.intValue() &gt; highValue2) {
                    highValue2 = v.intValue();
                }
            }
            imageProcessor.fillInPixels(csImg2, lowValue2, 50);
            imageProcessor.fillInPixels(csImg2, highValue2, 50);
            csImg2 = imageProcessor.binImage(csImg2, binFactor1);
            ImageIOHelper.writeOutputImage(ResourceFinder.findDirectory(&quot;bin&quot;)
                + &quot;/color_segmentation2.png&quot;, csImg2);
        } else {
<span class="nc" id="L588">            ImageExt leftImgBinned = imageProcessor.binImage(leftImg, binFactor1);</span>

<span class="nc" id="L590">            csImg1 = imageSegmentation.applyUsingCIEXYPolarThetaThenHistEq(leftImgBinned, 3, true);</span>
<span class="nc" id="L591">            imageSegmentation.applyUsingKMPP(csImg1, 2);</span>

<span class="nc" id="L593">            ImageIOHelper.writeOutputImage(ResourceFinder.findDirectory(&quot;bin&quot;)</span>
                + &quot;/color_segmentation1.png&quot;, csImg1);

<span class="nc" id="L596">            ImageExt rightImgBinned = imageProcessor.binImage(rightImg, binFactor1);</span>
<span class="nc" id="L597">            csImg2 = imageSegmentation.applyUsingCIEXYPolarThetaThenHistEq(rightImgBinned, 3, true);</span>
<span class="nc" id="L598">            imageSegmentation.applyUsingKMPP(csImg2, 2);</span>

<span class="nc" id="L600">            ImageIOHelper.writeOutputImage(ResourceFinder.findDirectory(&quot;bin&quot;)</span>
                + &quot;/color_segmentation2.png&quot;, csImg2);
        }
<span class="nc" id="L603">        long t1 = System.currentTimeMillis();</span>
<span class="nc" id="L604">        log.info(&quot;segmentation &quot; + ((t1 - t0)*1e-3) + &quot; seconds&quot;);</span>



<span class="nc" id="L608">        CurvatureScaleSpaceCornerDetector detector = new</span>
            CurvatureScaleSpaceCornerDetector(csImg1);
<span class="nc" id="L610">        detector.doNotPerformHistogramEqualization();</span>
        //detector.findCornersIteratively(nPreferredCorners, nCrit);
<span class="nc" id="L612">        detector.findCorners();</span>
<span class="nc" id="L613">        PairIntArray corners1 = detector.getCornersInOriginalReferenceFrame();</span>

<span class="nc" id="L615">        CurvatureScaleSpaceCornerDetector detector2 = new</span>
            CurvatureScaleSpaceCornerDetector(csImg2);
<span class="nc" id="L617">        detector2.doNotPerformHistogramEqualization();</span>
        //detector2.findCornersIteratively(nPreferredCorners, nCrit);
<span class="nc" id="L619">        detector2.findCorners();</span>
<span class="nc" id="L620">        PairIntArray corners2 = detector2.getCornersInOriginalReferenceFrame();</span>

<span class="nc" id="L622">        writeImage(ImageIOHelper.convertImage(csImg1), corners1,</span>
            &quot;corners1_&quot; + 0 + &quot;_&quot; + 0 + &quot;.png&quot;);
<span class="nc" id="L624">        writeImage(ImageIOHelper.convertImage(csImg2), corners2,</span>
            &quot;corners2_&quot; + 0 + &quot;_&quot; + 0 + &quot;.png&quot;);

<span class="nc" id="L627">        t0 = System.currentTimeMillis();</span>

<span class="nc" id="L629">        boolean useLargestToleranceForOutput = false;//true;</span>
<span class="nc" id="L630">        boolean useGreedyMatching = true;</span>

<span class="nc" id="L632">        log.info(&quot;n1=&quot; + corners1.getN() + &quot; n2=&quot; + corners2.getN());</span>

<span class="nc" id="L634">        TransformationPointFit fit = calculateEuclideanLeftRightTransformation(</span>
            corners1, corners2, useLargestToleranceForOutput, useGreedyMatching);

<span class="nc" id="L637">        t1 = System.currentTimeMillis();</span>

<span class="nc" id="L639">        log.info(&quot;(&quot; + ((t1 - t0)*1e-3) + &quot; seconds) fit=&quot; + fit.toString());</span>

        // make a matching list with small tolerance
<span class="nc" id="L642">        PairIntArray outputMatchedSet1 = new PairIntArray();</span>
<span class="nc" id="L643">        PairIntArray outputMatchedSet2 = new PairIntArray();</span>
<span class="nc" id="L644">        float tolTransX = 3;</span>
<span class="nc" id="L645">        float tolTransY = tolTransX;</span>

<span class="nc" id="L647">        match(fit.getParameters(), corners1, corners2,</span>
            outputMatchedSet1, outputMatchedSet2, tolTransX, tolTransY,
            useGreedyMatching);

<span class="nc" id="L651">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L653">        writeTransformed(fit.getParameters(), ImageIOHelper.convertImage(csImg2),</span>
            corners1, corners2, &quot;transformed_binned.png&quot;);

        // then transform the solution by a scale of binFactor1.
<span class="nc" id="L657">        TransformationParameters paramsOrigScale =</span>
<span class="nc" id="L658">            transformer.applyScaleTransformation(fit.getParameters(), binFactor1);</span>
<span class="nc" id="L659">        paramsOrigScale.setScale(1);</span>

        // ==== this is only the initial solution.
        // need to use it to construct
        // the rest with either stereo matching techniques such as
        // sum of absolute differences of pixel blocks from left and right
        // OR, a round of corners at full resolution of image.

        // temporarily returning the fit with modified parameters
<span class="nc" id="L668">        TransformationPointFit fit2 = new TransformationPointFit(</span>
<span class="nc" id="L669">            paramsOrigScale, fit.getNumberOfMatchedPoints(),</span>
<span class="nc" id="L670">            fit.getMeanDistFromModel(), fit.getStDevFromMean(),</span>
<span class="nc" id="L671">            fit.getTranslationXTolerance(), fit.getTranslationYTolerance());</span>

/*
        writeImage(leftImgOrig, corners1OrigScale,
                    &quot;corners1_&quot; + 1 + &quot;_&quot; + 1 + &quot;.png&quot;);
        writeImage(rightImgOrig, corners2OrigScale,
            &quot;corners2_&quot; + 1 + &quot;_&quot; + 1 + &quot;.png&quot;);

        writeTransformed(paramsOrigScale, rightImgOrig.copyImage(),
            corners1OrigScale, corners2OrigScale, &quot;transformed_&quot; + 0 + &quot;.png&quot;);

        //writeTransformed(fit.getParameters(), rightImg.copyImage(),
        //    outputMatchedScene, outputMatchedModel,
        //    &quot;transformedCorners_&quot; + 0 + &quot;_&quot; + 0 + &quot;.png&quot;);
 */
<span class="nc" id="L686">        return fit2;</span>
    }

private void writeImage(Image image1, PairIntArray points1,
    String outputImageName) {
    try {
<span class="nc" id="L692">        String dirPath = ResourceFinder.findDirectory(&quot;bin&quot;);</span>
<span class="nc" id="L693">        int nExtraForDot = 1;</span>
<span class="nc" id="L694">        ImageIOHelper.addCurveToImage(points1, image1, nExtraForDot,</span>
            255, 0, 0);
<span class="nc" id="L696">        ImageIOHelper.writeOutputImage(dirPath + &quot;/&quot; + outputImageName, image1);</span>
<span class="nc" id="L697">    } catch (Exception e) {</span>
<span class="nc" id="L698">         e.printStackTrace();</span>
<span class="nc" id="L699">        log.severe(&quot;ERROR: &quot; + e.getMessage());</span>
<span class="nc" id="L700">    }</span>
<span class="nc" id="L701">}</span>
private void writeTransformed(TransformationParameters parameters,
    Image image2, PairIntArray points1,
    PairIntArray points2, String outputImageName) {
<span class="nc" id="L705">    Transformer transformer = new Transformer();</span>
    try {
<span class="nc" id="L707">        String dirPath = ResourceFinder.findDirectory(&quot;bin&quot;);</span>
<span class="nc" id="L708">        PairIntArray trPoints1 = transformer.applyTransformation(parameters,</span>
            points1);
<span class="nc" id="L710">        PairIntArray transformedPoints1 = new PairIntArray();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        for (int i = 0; i &lt; trPoints1.getN(); ++i) {</span>
<span class="nc" id="L712">            int x = trPoints1.getX(i);</span>
<span class="nc" id="L713">            int y = trPoints1.getY(i);</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">            if (x &lt; 0 || x &gt; (image2.getWidth() - 1)) {</span>
<span class="nc" id="L715">                continue;</span>
            }
<span class="nc bnc" id="L717" title="All 4 branches missed.">            if (y &lt; 0 || y &gt; (image2.getHeight() - 1)) {</span>
<span class="nc" id="L718">                continue;</span>
            }
<span class="nc" id="L720">            transformedPoints1.add(x, y);</span>
        }

<span class="nc" id="L723">        int nExtraForDot = 1;</span>
<span class="nc" id="L724">        ImageIOHelper.addCurveToImage(transformedPoints1, image2, nExtraForDot,</span>
            255, 0, 0);
<span class="nc" id="L726">        ImageIOHelper.addCurveToImage(points2, image2, nExtraForDot,</span>
            0, 0, 255);
<span class="nc" id="L728">        ImageIOHelper.writeOutputImage(dirPath + &quot;/&quot; + outputImageName, image2);</span>
<span class="nc" id="L729">    } catch (Exception e) {</span>
<span class="nc" id="L730">         e.printStackTrace();</span>
<span class="nc" id="L731">        log.severe(&quot;ERROR: &quot; + e.getMessage());</span>
<span class="nc" id="L732">    }</span>
<span class="nc" id="L733">}</span>

    /**
     * given the scale, rotation and set 1's reference frame centroids,
     * calculate the translation between set1 and set2 assuming that not all
     * points will match.  transXTol and transYTol allow a tolerance when
     * matching the predicted position of a point in set2.
     *
     * It's expected that the invoker of this method is trying to solve for
     * translation for sets of points like corners in images.  This assumption
     * means that the number of point pair combinations is always far less
     * than the pixel combinations of translations over x and y.
     *
     * NOTE: scale has be &gt;= 1, so if one image has a smaller scale, it has to
     * be the first set given in arguments.
     *
     * ALSO NOTE: if you know a better solution exists for translation
     * parameters that matches fewer points, but has a small avg dist from
     * model and smaller standard deviation from the avg dist from model,
     * then transXTol and transYTol should be set to a smaller value and passed
     * to this method.
     * @param params transformation parameters to apply to matched1
     * @param matched1Transformed
     * @param matched2 set of points from image 2 that are matched to points in
     * matched1 with same indexes
     * @return
     */
    public TransformationPointFit evaluateFitForMatchedTransformed(
        TransformationParameters params, PairFloatArray matched1Transformed,
        PairIntArray matched2) {

<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (matched1Transformed == null) {</span>
<span class="nc" id="L765">            throw new IllegalArgumentException(</span>
                &quot;matched1Transformed cannot be null&quot;);
        }
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (matched2 == null) {</span>
<span class="nc" id="L769">            throw new IllegalArgumentException(&quot;matched2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (matched1Transformed.getN() != matched2.getN()) {</span>
<span class="nc" id="L772">            throw new IllegalArgumentException(</span>
                &quot;the 2 point sets must have the same length&quot;);
        }

<span class="nc" id="L776">        double[] diff = new double[matched1Transformed.getN()];</span>

<span class="nc" id="L778">        double avg = 0;</span>

<span class="nc bnc" id="L780" title="All 2 branches missed.">        for (int i = 0; i &lt; matched1Transformed.getN(); i++) {</span>

<span class="nc" id="L782">            float transformedX = matched1Transformed.getX(i);</span>
<span class="nc" id="L783">            float transformedY = matched1Transformed.getY(i);</span>

<span class="nc" id="L785">            int x2 = matched2.getX(i);</span>
<span class="nc" id="L786">            int y2 = matched2.getY(i);</span>

<span class="nc" id="L788">            double dx = x2 - transformedX;</span>
<span class="nc" id="L789">            double dy = y2 - transformedY;</span>

<span class="nc" id="L791">            diff[i] = Math.sqrt(dx*dx + dy*dy);</span>

<span class="nc" id="L793">            avg += diff[i];</span>
        }

<span class="nc" id="L796">        avg /= (double)matched2.getN();</span>

<span class="nc" id="L798">        double stdDev = 0;</span>

<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (int i = 0; i &lt; matched2.getN(); i++) {</span>

<span class="nc" id="L802">            double d = diff[i] - avg;</span>

<span class="nc" id="L804">            stdDev += (d * d);</span>
        }

<span class="nc" id="L807">        stdDev = Math.sqrt(stdDev/((double)matched2.getN() - 1));</span>

<span class="nc" id="L809">        TransformationPointFit fit = new TransformationPointFit(params.copy(),</span>
<span class="nc" id="L810">            matched2.getN(), avg, stdDev, Float.MAX_VALUE, Float.MAX_VALUE);</span>

<span class="nc" id="L812">        return fit;</span>
    }

    protected TransformationPointFit evaluateFitForUnMatchedTransformedGreedy(
        TransformationParameters params, PairFloatArray unmatched1Transformed,
        PairIntArray unmatched2, float tolTransX, float tolTransY) {

<span class="pc bpc" id="L819" title="1 of 2 branches missed.">        if (unmatched1Transformed == null) {</span>
<span class="nc" id="L820">            throw new IllegalArgumentException(</span>
            &quot;unmatched1Transformed cannot be null&quot;);
        }
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if (unmatched2 == null) {</span>
<span class="nc" id="L824">            throw new IllegalArgumentException(</span>
            &quot;unmatched2 cannot be null&quot;);
        }

<span class="fc" id="L828">        PairFloatArray trFiltered1 = new PairFloatArray();</span>
<span class="fc" id="L829">        PairIntArray filtered2 = new PairIntArray();</span>

<span class="fc" id="L831">        reduceToIntersection(unmatched1Transformed, unmatched2, trFiltered1,</span>
            filtered2, tolTransX, tolTransY);

<span class="fc" id="L834">        int n = trFiltered1.getN();</span>

<span class="fc" id="L836">        Set&lt;Integer&gt; chosen = new HashSet&lt;Integer&gt;();</span>

<span class="fc" id="L838">        double[] diffs = new double[n];</span>
<span class="fc" id="L839">        int nMatched = 0;</span>
<span class="fc" id="L840">        double avg = 0;</span>

<span class="fc bfc" id="L842" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

<span class="fc" id="L844">            float transformedX = trFiltered1.getX(i);</span>
<span class="fc" id="L845">            float transformedY = trFiltered1.getY(i);</span>

<span class="fc" id="L847">            double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L848">            int min2Idx = -1;</span>

<span class="fc bfc" id="L850" title="All 2 branches covered.">            for (int j = 0; j &lt; filtered2.getN(); j++) {</span>

<span class="fc bfc" id="L852" title="All 2 branches covered.">                if (chosen.contains(Integer.valueOf(j))) {</span>
<span class="fc" id="L853">                    continue;</span>
                }

<span class="fc" id="L856">                float dx = transformedX - filtered2.getX(j);</span>
<span class="fc" id="L857">                float dy = transformedY - filtered2.getY(j);</span>

<span class="fc bfc" id="L859" title="All 4 branches covered.">                if ((Math.abs(dx) &gt; tolTransX) || (Math.abs(dy) &gt; tolTransY)) {</span>
<span class="fc" id="L860">                    continue;</span>
                }

<span class="fc" id="L863">                float diff = (float)Math.sqrt(dx*dx + dy*dy);</span>

<span class="fc bfc" id="L865" title="All 2 branches covered.">                if (diff &lt; minDiff) {</span>
<span class="fc" id="L866">                    minDiff = diff;</span>
<span class="fc" id="L867">                    min2Idx = j;</span>
                }
            }

<span class="fc bfc" id="L871" title="All 2 branches covered.">            if (minDiff &lt; Double.MAX_VALUE) {</span>
<span class="fc" id="L872">                diffs[nMatched] = minDiff;</span>
<span class="fc" id="L873">                nMatched++;</span>
<span class="fc" id="L874">                chosen.add(Integer.valueOf(min2Idx));</span>
<span class="fc" id="L875">                avg += minDiff;</span>
            }
        }

<span class="fc bfc" id="L879" title="All 2 branches covered.">        avg = (nMatched == 0) ? Double.MAX_VALUE :</span>
            avg / (double)nMatched;

<span class="fc" id="L882">        double stDev = 0;</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (int i = 0; i &lt; nMatched; i++) {</span>
<span class="fc" id="L884">            double d = diffs[i] - avg;</span>
<span class="fc" id="L885">            stDev += (d * d);</span>
        }

<span class="fc bfc" id="L888" title="All 2 branches covered.">        stDev = (nMatched == 0) ? Double.MAX_VALUE :</span>
<span class="fc" id="L889">            Math.sqrt(stDev/((double)nMatched - 1.));</span>

<span class="fc" id="L891">        TransformationPointFit fit = new TransformationPointFit(params.copy(),</span>
            nMatched, avg, stDev, tolTransX, tolTransY);

<span class="fc" id="L894">        int nMaxMatchable = Math.min(trFiltered1.getN(), filtered2.getN());</span>

<span class="fc" id="L896">        fit.setMaximumNumberMatchable(nMaxMatchable);</span>

<span class="fc" id="L898">        return fit;</span>
    }

    protected TransformationPointFit evaluateFitForUnMatchedTransformedOptimal(
        TransformationParameters params, PairFloatArray unmatched1Transformed,
        PairIntArray unmatched2, float tolTransX, float tolTransY) {

<span class="pc bpc" id="L905" title="1 of 2 branches missed.">        if (unmatched1Transformed == null) {</span>
<span class="nc" id="L906">            throw new IllegalArgumentException(</span>
            &quot;unmatched1Transformed cannot be null&quot;);
        }
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">        if (unmatched2 == null) {</span>
<span class="nc" id="L910">            throw new IllegalArgumentException(</span>
            &quot;unmatched2 cannot be null&quot;);
        }

<span class="fc" id="L914">        PairFloatArray trFiltered1 = new PairFloatArray();</span>
<span class="fc" id="L915">        PairIntArray filtered2 = new PairIntArray();</span>

<span class="fc" id="L917">        reduceToIntersection(unmatched1Transformed, unmatched2,</span>
            trFiltered1, filtered2, tolTransX, tolTransY);

<span class="fc" id="L920">        int n = trFiltered1.getN();</span>

<span class="fc" id="L922">        float[][] matchedIndexesAndDiffs = calculateMatchUsingOptimal(</span>
            trFiltered1, filtered2, tolTransX, tolTransY);

<span class="fc" id="L925">        int nMatched = matchedIndexesAndDiffs.length;</span>
<span class="fc" id="L926">        double avg = 0;</span>
<span class="fc" id="L927">        double stDev = 0;</span>

<span class="fc bfc" id="L929" title="All 2 branches covered.">        for (int i = 0; i &lt; nMatched; i++) {</span>
<span class="fc" id="L930">            avg += matchedIndexesAndDiffs[i][2];</span>
        }
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        avg = (nMatched == 0) ? Double.MAX_VALUE : (avg / (double)nMatched);</span>

<span class="fc bfc" id="L934" title="All 2 branches covered.">        for (int i = 0; i &lt; nMatched; i++) {</span>

<span class="fc" id="L936">            double d = matchedIndexesAndDiffs[i][2] - avg;</span>

<span class="fc" id="L938">            stDev += (d * d);</span>
        }
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        stDev = (nMatched == 0) ? Double.MAX_VALUE :</span>
<span class="fc" id="L941">            (Math.sqrt(stDev/((double)nMatched - 1.)));</span>

<span class="fc" id="L943">        TransformationPointFit fit = new TransformationPointFit(params.copy(),</span>
            nMatched,  avg, stDev, tolTransX, tolTransY);

<span class="fc" id="L946">        int nMaxMatchable = Math.min(trFiltered1.getN(),</span>
<span class="fc" id="L947">            filtered2.getN());</span>

<span class="fc" id="L949">        fit.setMaximumNumberMatchable(nMaxMatchable);</span>

<span class="fc" id="L951">        return fit;</span>
    }

    protected TransformationPointFit evaluateFitForUnMatchedOptimal(
        PairFloatArrayUnmodifiable scaledRotatedSet1, float transX, float transY,
        float tolTransX, float tolTransY,
        PairIntArray set2, float scale, float rotationInRadians) {

<span class="nc bnc" id="L959" title="All 2 branches missed.">        if (scaledRotatedSet1 == null) {</span>
<span class="nc" id="L960">            throw new IllegalArgumentException(</span>
            &quot;unmatched1Transformed cannot be null&quot;);
        }
<span class="nc bnc" id="L963" title="All 2 branches missed.">        if (set2 == null) {</span>
<span class="nc" id="L964">            throw new IllegalArgumentException(</span>
            &quot;unmatched2 cannot be null&quot;);
        }

        //TODO: consider filtering for the intersection

<span class="nc" id="L970">        float[][] matchedIndexesAndDiffs = calculateMatchUsingOptimal(</span>
            scaledRotatedSet1, transX, transY, tolTransX, tolTransY,
            set2);

<span class="nc" id="L974">        int nMatched = matchedIndexesAndDiffs.length;</span>
<span class="nc" id="L975">        double avg = 0;</span>
<span class="nc" id="L976">        double stDev = 0;</span>

<span class="nc bnc" id="L978" title="All 2 branches missed.">        for (int i = 0; i &lt; nMatched; i++) {</span>
<span class="nc" id="L979">            avg += matchedIndexesAndDiffs[i][2];</span>
        }
<span class="nc bnc" id="L981" title="All 2 branches missed.">        avg = (nMatched == 0) ? Double.MAX_VALUE : (avg / (double)nMatched);</span>

<span class="nc bnc" id="L983" title="All 2 branches missed.">        for (int i = 0; i &lt; nMatched; i++) {</span>

<span class="nc" id="L985">            double d = matchedIndexesAndDiffs[i][2] - avg;</span>

<span class="nc" id="L987">            stDev += (d * d);</span>
        }
<span class="nc bnc" id="L989" title="All 2 branches missed.">        stDev = (nMatched == 0) ? Double.MAX_VALUE :</span>
<span class="nc" id="L990">            (Math.sqrt(stDev/((double)nMatched - 1.)));</span>

<span class="nc" id="L992">        TransformationParameters params = new TransformationParameters();</span>
<span class="nc" id="L993">        params.setRotationInRadians(rotationInRadians);</span>
<span class="nc" id="L994">        params.setScale(scale);</span>
<span class="nc" id="L995">        params.setTranslationX(transX);</span>
<span class="nc" id="L996">        params.setTranslationY(transY);</span>

<span class="nc" id="L998">        TransformationPointFit fit = new TransformationPointFit(params, nMatched,</span>
            avg, stDev, tolTransX, tolTransY);

<span class="nc" id="L1001">        fit.setMaximumNumberMatchable(Math.max(scaledRotatedSet1.getN(),</span>
<span class="nc" id="L1002">            set2.getN()));</span>

<span class="nc" id="L1004">        return fit;</span>
    }

    /**
     * given the indexes and residuals from optimal matching, populate
     * outputMatched1 and outputMatched2;
     *
     * @param set1
     * @param set2
     * @param transTolXY
     * @param matchedIndexesAndDiffs two dimensional array holding the matched
     * indexes and the distances between the model and the point for that pair.
     * each row holds {idx1, idx2, diff}
     * @param outputMatched1 the container to hold the output matching points
     * for image 1 that are paired with outputMatched2 as a result of running
     * this method.
     * @param outputMatched2 the container to hold the output matching points
     * for image 2 that are paired with outputMatched1 as a result of running
     * this method.
     */
    public void matchPoints(
        PairIntArray set1, PairIntArray set2,
        float transTolXY,
        float[][] matchedIndexesAndDiffs,
        PairIntArray outputMatched1, PairIntArray outputMatched2) {

<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (matchedIndexesAndDiffs == null) {</span>
<span class="nc" id="L1031">            return;</span>
        }

<span class="nc bnc" id="L1034" title="All 2 branches missed.">        for (int i = 0; i &lt; matchedIndexesAndDiffs.length; i++) {</span>

<span class="nc" id="L1036">            int idx1 = (int)matchedIndexesAndDiffs[i][0];</span>
<span class="nc" id="L1037">            int idx2 = (int)matchedIndexesAndDiffs[i][1];</span>
<span class="nc" id="L1038">            float diff = matchedIndexesAndDiffs[i][2];</span>

<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (diff &lt; transTolXY) {</span>
<span class="nc" id="L1041">                outputMatched1.add(set1.getX(idx1), set1.getY(idx1));</span>
<span class="nc" id="L1042">                outputMatched2.add(set2.getX(idx2), set2.getY(idx2));</span>
            }
        }
<span class="nc" id="L1045">    }</span>

    /**
     * given the indexes and residuals from optimal matching, populate
     * outputMatched1 and outputMatched2;
     *
     * @param set1
     * @param set2
     * @param transTolXY
     * @param matchedIndexesAndDiffs two dimensional array holding the matched
     * indexes and the distances between the model and the point for that pair.
     * each row holds {idx1, idx2, diff}
     * @param outputMatched1 the container to hold the output matching points
     * for image 1 that are paired with outputMatched2 as a result of running
     * this method.
     * @param outputMatched2 the container to hold the output matching points
     * for image 2 that are paired with outputMatched1 as a result of running
     * this method.
     */
    public void matchPoints(PairFloatArray set1, PairIntArray set2,
        float transTolXY, float[][] matchedIndexesAndDiffs,
        PairFloatArray outputMatched1, PairIntArray outputMatched2) {

<span class="nc bnc" id="L1068" title="All 2 branches missed.">        for (int i = 0; i &lt; matchedIndexesAndDiffs.length; i++) {</span>

<span class="nc" id="L1070">            int idx1 = (int)matchedIndexesAndDiffs[i][0];</span>
<span class="nc" id="L1071">            int idx2 = (int)matchedIndexesAndDiffs[i][1];</span>
<span class="nc" id="L1072">            float diff = matchedIndexesAndDiffs[i][2];</span>

<span class="nc bnc" id="L1074" title="All 2 branches missed.">            if (diff &lt; transTolXY) {</span>
<span class="nc" id="L1075">                outputMatched1.add(set1.getX(idx1), set1.getY(idx1));</span>
<span class="nc" id="L1076">                outputMatched2.add(set2.getX(idx2), set2.getY(idx2));</span>
            }
        }
<span class="nc" id="L1079">    }</span>

    protected long estimateNStepsPreSearch(PairIntArray set1,
        PairIntArray set2, float rotRange) {

<span class="nc" id="L1084">        int[] xyRange = estimateTranslationXYRange(set1, set2);</span>

<span class="nc" id="L1086">        long nTotal = estimateNStepsPreSearch0(set1.getN(), set2.getN(),</span>
            xyRange[0], xyRange[1], rotRange);

<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (usePreSearchAlt1) {</span>

<span class="nc" id="L1091">            nTotal += estimateNStepsPreSearch1Alt1(set1.getN(), set2.getN());</span>

        } else {

<span class="nc" id="L1095">            nTotal += estimateNStepsPreSearch1Alt2(set1.getN(), set2.getN());</span>
        }

<span class="nc" id="L1098">        return nTotal;</span>
    }

    protected int[] estimateTranslationXYRange(PairIntArray set1,
        PairIntArray set2) {

<span class="nc" id="L1104">        int minX2 = MiscMath.findMin(set2.getX(), set2.getN());</span>
<span class="nc" id="L1105">        int maxX2 = MiscMath.findMax(set2.getX(), set2.getN());</span>
<span class="nc" id="L1106">        int minY2 = MiscMath.findMin(set2.getY(), set2.getN());</span>
<span class="nc" id="L1107">        int maxY2 = MiscMath.findMax(set2.getY(), set2.getN());</span>

<span class="nc" id="L1109">        int minX1 = MiscMath.findMin(set1.getX(), set1.getN());</span>
<span class="nc" id="L1110">        int maxX1 = MiscMath.findMax(set1.getX(), set1.getN());</span>
<span class="nc" id="L1111">        int minY1 = MiscMath.findMin(set1.getX(), set1.getN());</span>
<span class="nc" id="L1112">        int maxY1 = MiscMath.findMax(set1.getX(), set1.getN());</span>

<span class="nc" id="L1114">        int transXStart = minX1 - maxX2;</span>
<span class="nc" id="L1115">        int transXStop = maxX1 - minX2;</span>
<span class="nc" id="L1116">        int transYStart = minY1 - maxY2;</span>
<span class="nc" id="L1117">        int transYStop = maxY1 - minY2;</span>

<span class="nc" id="L1119">        int transXRange = transXStop - transXStart;</span>
<span class="nc" id="L1120">        int transYRange = transYStop - transYStart;</span>

<span class="nc" id="L1122">        return new int[]{transXRange, transYRange};</span>
    }

    protected long estimateNStepsPreSearch0(int n1, int n2, int xRange,
        int yRange) {

<span class="nc" id="L1128">        float rotRange = 360.f;</span>

<span class="nc" id="L1130">        return estimateNStepsPreSearch0(n1, n2, xRange, yRange, rotRange);</span>
    }

    protected long estimateNStepsPreSearch0(int n1, int n2, int xRange,
        int yRange, float rotRange) {

<span class="nc" id="L1136">        int nMaxMatchable = Math.min(n1, n2);</span>

<span class="nc" id="L1138">        int nRot = (int)((rotRange/rotDeltaPreSearch0) + 1);</span>

<span class="nc" id="L1140">        long nPerFitGreedy = n1 * n2;</span>

<span class="nc" id="L1142">        int nX = (int) Math.ceil(2*xRange / transDeltaPreSearch0);</span>

<span class="nc" id="L1144">        int nY = (int) Math.ceil(2*yRange / transDeltaPreSearch0);</span>

<span class="nc" id="L1146">        int nSplit = 1;</span>

<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (nMaxMatchable &gt; largeSearchLimit) {</span>

<span class="nc" id="L1150">            nSplit = (int)Math.ceil((float)n1/(float)largeSearchLimit);</span>

<span class="nc" id="L1152">            nPerFitGreedy = largeSearchLimit * largeSearchLimit;</span>
        }

<span class="nc" id="L1155">        return nSplit * nRot * nX * nY * nPerFitGreedy;</span>
    }

    protected long estimateNStepsPreSearch1Alt1(int n1, int n2) {

<span class="nc" id="L1160">        int nMaxMatchable = Math.min(n1, n2);</span>

<span class="nc" id="L1162">        int nRot = (int)((360/rotDeltaPreSearch0) + 1);</span>

<span class="nc" id="L1164">        long nPerFitGreedy = n1 * n2;</span>

<span class="nc" id="L1166">        int nSplit = 1;</span>

<span class="nc bnc" id="L1168" title="All 2 branches missed.">        if (nMaxMatchable &gt; largeSearchLimit) {</span>

<span class="nc" id="L1170">            nSplit = (int)Math.ceil((float)n1/(float)largeSearchLimit);</span>

<span class="nc" id="L1172">            nPerFitGreedy = largeSearchLimit * largeSearchLimit;</span>
        }

<span class="nc" id="L1175">        return nSplit * nPerFitGreedy * 50;</span>
    }

    protected long estimateNStepsPreSearch1Alt2(int n1, int n2) {

        //preSearch0 gets answer to within +- 10 degrees of rotation and +- 20 ?

<span class="nc" id="L1182">        int nFits = 10;</span>

<span class="nc" id="L1184">        int nMaxMatchable = Math.min(n1, n2);</span>

<span class="nc" id="L1186">        int nRot = (int)((2*rotHalfRangeInDegreesPreSearch1Alt2/</span>
            rotDeltaInDegreesPreSearch1Alt2) + 1);

<span class="nc" id="L1189">        int nX = (int) Math.ceil(2*transXHalfRangePreSearch1Alt2</span>
            / transXDeltaPreSearch1Alt2);
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (nX == 0) {</span>
<span class="nc" id="L1192">            nX = 1;</span>
        }
<span class="nc" id="L1194">        int nY = nX;</span>

<span class="nc" id="L1196">        long nPerFitGreedy = n1 * n2;</span>

<span class="nc" id="L1198">        int nSplit = 1;</span>

<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (nMaxMatchable &gt; largeSearchLimit) {</span>

<span class="nc" id="L1202">            nSplit = (int)Math.ceil((float)n1/(float)largeSearchLimit);</span>

<span class="nc" id="L1204">            nPerFitGreedy = largeSearchLimit * largeSearchLimit;</span>

        }

<span class="nc" id="L1208">        long nTot = nSplit * nFits * nRot * nX * nY * nPerFitGreedy;</span>

<span class="nc" id="L1210">        return nTot;</span>
    }

    /**
     * given unordered unmatched points for a transformed set1 and
     * the model set2 from image1 and image2
     * respectively, find the
     * optimal matching in set2 within tolerance and return the
     * matched information as a two dimensional array of
     * {index from set1, index from set2, diff of point in set2 from
     * model generation by point in set1}
     *
     * @param transformed1
     * @param set2
     * @param toleranceX
     * @param toleranceY
     * @return a two dimensional array holding the matched indexes and
     * the distances between the model and the point for that pair.
     * each row holds float[]{idx1, idx2, diff}
     */
    public float[][] calculateMatchUsingOptimal(
        PairFloatArray transformed1, PairIntArray set2, float toleranceX,
        float toleranceY) {

<span class="fc" id="L1234">        int nPoints1 = transformed1.getN();</span>
<span class="fc" id="L1235">        int nPoints2 = set2.getN();</span>

<span class="fc" id="L1237">        float[][] diffsAsCost = new float[nPoints1][nPoints2];</span>

        // the algorithm modifies diffsAsCost, so make a copy
<span class="fc" id="L1240">        float[][] diffsAsCostCopy = new float[nPoints1][nPoints2];</span>

        // key = indexes i,j; value = diffX, diffY
<span class="fc" id="L1243">        Map&lt;PairInt, PairFloat&gt; diffsXY = new HashMap&lt;PairInt, PairFloat&gt;();</span>

<span class="fc" id="L1245">        int nWithinTol = 0;</span>

<span class="fc bfc" id="L1247" title="All 2 branches covered.">        for (int i = 0; i &lt; transformed1.getN(); i++) {</span>

<span class="fc" id="L1249">            diffsAsCost[i] = new float[nPoints2];</span>
<span class="fc" id="L1250">            diffsAsCostCopy[i] = new float[nPoints2];</span>

<span class="fc" id="L1252">            float x = transformed1.getX(i);</span>
<span class="fc" id="L1253">            float y = transformed1.getY(i);</span>

<span class="fc bfc" id="L1255" title="All 2 branches covered.">            for (int j = 0; j &lt; set2.getN(); j++) {</span>

<span class="fc" id="L1257">                int x2 = set2.getX(j);</span>
<span class="fc" id="L1258">                int y2 = set2.getY(j);</span>

<span class="fc" id="L1260">                float diffX = x - x2;</span>
<span class="fc" id="L1261">                float diffY = y - y2;</span>

<span class="fc bfc" id="L1263" title="All 2 branches covered.">                if ((Math.abs(diffX) &gt; toleranceX) ||</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                    (Math.abs(diffY) &gt; toleranceY)) {</span>

<span class="fc" id="L1266">                    diffsAsCost[i][j] = Float.MAX_VALUE;</span>
<span class="fc" id="L1267">                    diffsAsCostCopy[i][j] = Float.MAX_VALUE;</span>

                } else {

<span class="fc" id="L1271">                    double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc" id="L1273">                    diffsAsCost[i][j] = (float)dist;</span>
<span class="fc" id="L1274">                    diffsAsCostCopy[i][j] = (float)dist;</span>

<span class="fc" id="L1276">                    diffsXY.put(new PairInt(i, j), new PairFloat(diffX, diffY));</span>

<span class="fc" id="L1278">                    nWithinTol++;</span>
                }
            }
        }

<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">        if (nWithinTol == 0) {</span>
<span class="nc" id="L1284">            return new float[0][];</span>
        }

<span class="fc" id="L1287">        boolean transposed = false;</span>
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">        if (nPoints1 &gt; nPoints2) {</span>
<span class="nc" id="L1289">            diffsAsCostCopy = MatrixUtil.transpose(diffsAsCostCopy);</span>
<span class="nc" id="L1290">            transposed = true;</span>
        }

<span class="fc" id="L1293">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="fc" id="L1294">        int[][] match = b.computeAssignments(diffsAsCostCopy);</span>

        // count the number of matches
<span class="fc" id="L1297">        int count = 0;</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="fc" id="L1299">            int idx1 = match[i][0];</span>
<span class="fc" id="L1300">            int idx2 = match[i][1];</span>
<span class="pc bpc" id="L1301" title="2 of 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1302">                continue;</span>
            }
<span class="pc bpc" id="L1304" title="2 of 4 branches missed.">            if (idx1 == Float.MAX_VALUE || idx2 == Float.MAX_VALUE) {</span>
<span class="nc" id="L1305">                continue;</span>
            }
<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1308">                int swap = idx1;</span>
<span class="nc" id="L1309">                idx1 = idx2;</span>
<span class="nc" id="L1310">                idx2 = swap;</span>
            }

<span class="fc" id="L1313">            PairFloat diffXY = diffsXY.get(new PairInt(idx1, idx2));</span>

<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">            if (diffXY == null) {</span>
<span class="nc" id="L1316">                continue;</span>
            }

<span class="pc bpc" id="L1319" title="2 of 4 branches missed.">            if ((diffXY.getX() &gt; toleranceX) || (diffXY.getY() &gt; toleranceY)) {</span>
<span class="nc" id="L1320">                continue;</span>
            }

<span class="fc" id="L1323">            count++;</span>
        }

<span class="fc" id="L1326">        float[][] output = new float[count][];</span>

<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1329">            return output;</span>
        }

<span class="fc" id="L1332">        count = 0;</span>

<span class="fc bfc" id="L1334" title="All 2 branches covered.">        for (int i = 0; i &lt; match.length; i++) {</span>

<span class="fc" id="L1336">            int idx1 = match[i][0];</span>
<span class="fc" id="L1337">            int idx2 = match[i][1];</span>
<span class="pc bpc" id="L1338" title="2 of 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1339">                continue;</span>
            }

<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1343">                int swap = idx1;</span>
<span class="nc" id="L1344">                idx1 = idx2;</span>
<span class="nc" id="L1345">                idx2 = swap;</span>
            }

<span class="fc" id="L1348">            PairFloat diffXY = diffsXY.get(new PairInt(idx1, idx2));</span>

<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">            if (diffXY == null) {</span>
<span class="nc" id="L1351">                continue;</span>
            }

<span class="pc bpc" id="L1354" title="2 of 4 branches missed.">            if ((diffXY.getX() &gt; toleranceX) || (diffXY.getY() &gt; toleranceY)) {</span>
<span class="nc" id="L1355">                continue;</span>
            }

<span class="fc" id="L1358">            output[count] = new float[3];</span>
<span class="fc" id="L1359">            output[count][0] = idx1;</span>
<span class="fc" id="L1360">            output[count][1] = idx2;</span>
<span class="fc" id="L1361">            output[count][2] = diffsAsCost[idx1][idx2];</span>

<span class="fc" id="L1363">            count++;</span>
        }

<span class="fc" id="L1366">        return output;</span>
    }

    /**
     * given unordered unmatched points for a transformed set1 and
     * the model set2 from image1 and image2
     * respectively, find the
     * optimal matching in set2 within tolerance and return the
     * matched information as a two dimensional array of
     * {index from set1, index from set2, diff of point in set2 from
     * model generation by point in set1}
     *
     * @return a two dimensional array holding the matched indexes and
     * the distances between the model and the point for that pair.
     * each row holds float[]{idx1, idx2, diff}
     */
    public float[][] calculateMatchUsingOptimal(
        PairFloatArrayUnmodifiable scaledRotatedSet1,
        float transX, float transY, float toleranceX, float toleranceY,
        PairIntArray set2) {

<span class="nc" id="L1387">        int nPoints1 = scaledRotatedSet1.getN();</span>
<span class="nc" id="L1388">        int nPoints2 = set2.getN();</span>

<span class="nc" id="L1390">        float[][] diffsAsCost = new float[nPoints1][nPoints2];</span>

        // the algorithm modifies diffsAsCost, so make a copy
<span class="nc" id="L1393">        float[][] diffsAsCostCopy = new float[nPoints1][nPoints2];</span>

        // key = indexes i,j; value = diffX, diffY
<span class="nc" id="L1396">        Map&lt;PairInt, PairFloat&gt; diffsXY = new HashMap&lt;PairInt, PairFloat&gt;();</span>

<span class="nc" id="L1398">        int nWithinTol = 0;</span>

<span class="nc bnc" id="L1400" title="All 2 branches missed.">        for (int i = 0; i &lt; scaledRotatedSet1.getN(); i++) {</span>

<span class="nc" id="L1402">            diffsAsCost[i] = new float[nPoints2];</span>
<span class="nc" id="L1403">            diffsAsCostCopy[i] = new float[nPoints2];</span>

<span class="nc" id="L1405">            float x = scaledRotatedSet1.getX(i) + transX;</span>
<span class="nc" id="L1406">            float y = scaledRotatedSet1.getY(i) + transY;</span>

<span class="nc bnc" id="L1408" title="All 2 branches missed.">            for (int j = 0; j &lt; set2.getN(); j++) {</span>

<span class="nc" id="L1410">                int x2 = set2.getX(j);</span>
<span class="nc" id="L1411">                int y2 = set2.getY(j);</span>

<span class="nc" id="L1413">                float diffX = x - x2;</span>
<span class="nc" id="L1414">                float diffY = y - y2;</span>

<span class="nc bnc" id="L1416" title="All 2 branches missed.">                if ((Math.abs(diffX) &gt; toleranceX) ||</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                    (Math.abs(diffY) &gt; toleranceY)) {</span>

<span class="nc" id="L1419">                    diffsAsCost[i][j] = Float.MAX_VALUE;</span>
<span class="nc" id="L1420">                    diffsAsCostCopy[i][j] = Float.MAX_VALUE;</span>

                } else {

<span class="nc" id="L1424">                    double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="nc" id="L1426">                    diffsAsCost[i][j] = (float)dist;</span>
<span class="nc" id="L1427">                    diffsAsCostCopy[i][j] = (float)dist;</span>

<span class="nc" id="L1429">                    diffsXY.put(new PairInt(i, j), new PairFloat(diffX, diffY));</span>

<span class="nc" id="L1431">                    nWithinTol++;</span>
                }
            }
        }

<span class="nc bnc" id="L1436" title="All 2 branches missed.">        if (nWithinTol == 0) {</span>
<span class="nc" id="L1437">            return new float[0][];</span>
        }

<span class="nc" id="L1440">        boolean transposed = false;</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">        if (nPoints1 &gt; nPoints2) {</span>
<span class="nc" id="L1442">            diffsAsCostCopy = MatrixUtil.transpose(diffsAsCostCopy);</span>
<span class="nc" id="L1443">            transposed = true;</span>
        }

<span class="nc" id="L1446">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="nc" id="L1447">        int[][] match = b.computeAssignments(diffsAsCostCopy);</span>

        // count the number of matches
<span class="nc" id="L1450">        int count = 0;</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="nc" id="L1452">            int idx1 = match[i][0];</span>
<span class="nc" id="L1453">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L1454" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1455">                continue;</span>
            }
<span class="nc bnc" id="L1457" title="All 4 branches missed.">            if (idx1 == Float.MAX_VALUE || idx2 == Float.MAX_VALUE) {</span>
<span class="nc" id="L1458">                continue;</span>
            }
<span class="nc bnc" id="L1460" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1461">                int swap = idx1;</span>
<span class="nc" id="L1462">                idx1 = idx2;</span>
<span class="nc" id="L1463">                idx2 = swap;</span>
            }

<span class="nc" id="L1466">            PairFloat diffXY = diffsXY.get(new PairInt(idx1, idx2));</span>

<span class="nc bnc" id="L1468" title="All 2 branches missed.">            if (diffXY == null) {</span>
<span class="nc" id="L1469">                continue;</span>
            }

<span class="nc bnc" id="L1472" title="All 4 branches missed.">            if ((diffXY.getX() &gt; toleranceX) || (diffXY.getY() &gt; toleranceY)) {</span>
<span class="nc" id="L1473">                continue;</span>
            }

<span class="nc" id="L1476">            count++;</span>
        }

<span class="nc" id="L1479">        float[][] output = new float[count][];</span>

<span class="nc bnc" id="L1481" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1482">            return output;</span>
        }

<span class="nc" id="L1485">        count = 0;</span>

<span class="nc bnc" id="L1487" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>

<span class="nc" id="L1489">            int idx1 = match[i][0];</span>
<span class="nc" id="L1490">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L1491" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1492">                continue;</span>
            }

<span class="nc bnc" id="L1495" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1496">                int swap = idx1;</span>
<span class="nc" id="L1497">                idx1 = idx2;</span>
<span class="nc" id="L1498">                idx2 = swap;</span>
            }

<span class="nc" id="L1501">            PairFloat diffXY = diffsXY.get(new PairInt(idx1, idx2));</span>

<span class="nc bnc" id="L1503" title="All 2 branches missed.">            if (diffXY == null) {</span>
<span class="nc" id="L1504">                continue;</span>
            }

<span class="nc bnc" id="L1507" title="All 4 branches missed.">            if ((diffXY.getX() &gt; toleranceX) || (diffXY.getY() &gt; toleranceY)) {</span>
<span class="nc" id="L1508">                continue;</span>
            }

<span class="nc" id="L1511">            output[count] = new float[3];</span>
<span class="nc" id="L1512">            output[count][0] = idx1;</span>
<span class="nc" id="L1513">            output[count][1] = idx2;</span>
<span class="nc" id="L1514">            output[count][2] = diffsAsCost[idx1][idx2];</span>

<span class="nc" id="L1516">            count++;</span>
        }

<span class="nc" id="L1519">        return output;</span>
    }

    protected TransformationPointFit[] evaluateTranslationsOverGrid(
        PairIntArray set1, PairIntArray set2,
        final float rotationInRadians, final float scale,
        RangeInt transXStartStop, int transXDelta,
        RangeInt transYStartStop, int transYDelta,
        float tolTransX, float tolTransY,
        final boolean setsAreMatched,
        final int numberOfBestToReturn) {

        /*   _____
            |     |
            |_____| largest negative or positive translationX of set1 is the width of set2
                  _____
                 |     |
                 |_____|
        */

<span class="nc bnc" id="L1539" title="All 2 branches missed.">        if (transXDelta &lt; 1) {</span>
<span class="nc" id="L1540">            throw new IllegalArgumentException(</span>
            &quot;transXDelta must be greater than 0&quot;);
        }
<span class="nc bnc" id="L1543" title="All 4 branches missed.">        if (rotationInRadians &lt; 0 || rotationInRadians &gt; 359) {</span>
<span class="nc" id="L1544">            throw new IllegalArgumentException(</span>
            &quot;rotation must be between 0 and 359, inclusive&quot;);
        }
<span class="nc bnc" id="L1547" title="All 2 branches missed.">        if (scale &lt; 1) {</span>
            // numerical errors in rounding to integer can give wrong solutions
            //throw new IllegalStateException(&quot;scale cannot be smaller than 1&quot;);

<span class="nc" id="L1551">            log.severe(&quot;scale cannot be smaller than 1&quot;);</span>

<span class="nc" id="L1553">            return null;</span>
        }

<span class="nc bnc" id="L1556" title="All 2 branches missed.">        int nMaxMatchable = (set1.getN() &lt; set2.getN()) ?</span>
<span class="nc" id="L1557">            set1.getN() : set2.getN();</span>

<span class="nc bnc" id="L1559" title="All 2 branches missed.">        if (nMaxMatchable == 0) {</span>
<span class="nc" id="L1560">            return null;</span>
        }

<span class="nc" id="L1563">        int nTranslations =</span>
<span class="nc" id="L1564">            (((transXStartStop.getStop() - transXStartStop.getStart())/transXDelta) + 1) *</span>
<span class="nc" id="L1565">            (((transYStartStop.getStop() - transYStartStop.getStart())/transYDelta) + 1);</span>

<span class="nc bnc" id="L1567" title="All 2 branches missed.">        if (nTranslations == 0) {</span>
<span class="nc" id="L1568">            return null;</span>
        }

<span class="nc" id="L1571">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L1573">        int count = 0;</span>

<span class="nc" id="L1575">        FixedSizeSortedVector&lt;TransformationPointFit&gt; fits =</span>
            new FixedSizeSortedVector&lt;&gt;(numberOfBestToReturn,
                TransformationPointFit.class);

<span class="nc" id="L1579">        for (float transX = transXStartStop.getStart();</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            transX &lt;= transXStartStop.getStop(); transX += transXDelta) {</span>

<span class="nc" id="L1582">            for (float transY = transYStartStop.getStart();</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">                transY &lt;= transYStartStop.getStop(); transY += transYDelta) {</span>

<span class="nc" id="L1585">                float tx0 = transX + (transXDelta/2);</span>
<span class="nc" id="L1586">                float ty0 = transY + (transYDelta/2);</span>

<span class="nc" id="L1588">                TransformationParameters params = new TransformationParameters();</span>
<span class="nc" id="L1589">                params.setRotationInRadians(rotationInRadians);</span>
<span class="nc" id="L1590">                params.setScale(scale);</span>
<span class="nc" id="L1591">                params.setTranslationX(tx0);</span>
<span class="nc" id="L1592">                params.setTranslationY(ty0);</span>

<span class="nc" id="L1594">                PairFloatArray allPoints1Tr = transformer.applyTransformation2(</span>
                    params, set1);

                TransformationPointFit fit;

<span class="nc bnc" id="L1599" title="All 2 branches missed.">                if (setsAreMatched) {</span>

<span class="nc" id="L1601">                    fit = evaluateFitForMatchedTransformed(params,</span>
                        allPoints1Tr, set2);

                } else {

                    // default is to use greedy matching but use optimal for small sets
<span class="nc bnc" id="L1607" title="All 2 branches missed.">                    if (nMaxMatchable &lt; 30) {</span>

<span class="nc" id="L1609">                        fit = evaluateFitForUnMatchedTransformedOptimal(params,</span>
                            allPoints1Tr, set2, tolTransX, tolTransY);

                    } else {

<span class="nc" id="L1614">                        fit = evaluateFitForUnMatchedTransformedGreedy(params,</span>
                        //fit = evaluateFitForUnMatchedTransformedOptimal(params,
                            allPoints1Tr, set2, tolTransX, tolTransY);
                    }
                }

<span class="nc" id="L1620">                fits.add(fit);</span>

<span class="nc" id="L1622">                count++;</span>
            }
        }

<span class="nc" id="L1626">        return fits.getArray();</span>
    }

    /**
     * the maximum number of iterations that the refinement of translation
     * will use in the downhill simplex.  The default value is 50.
     */
<span class="fc" id="L1633">    private int dsNMaxIter = 50;</span>
    protected void setDsNMaxIter(int n) {
<span class="nc" id="L1635">        dsNMaxIter = n;</span>
<span class="nc" id="L1636">    }</span>
    protected int getDsNMaxIter() {
<span class="nc" id="L1638">        return dsNMaxIter;</span>
    }
<span class="fc" id="L1640">    float nEpsFactor = 2.0f;</span>
    protected void setNEpsFactor(float f) {
<span class="nc" id="L1642">        nEpsFactor = f;</span>
<span class="nc" id="L1643">    }</span>
    protected float getNEpsFactor() {
<span class="nc" id="L1645">        return nEpsFactor;</span>
    }
<span class="fc" id="L1647">    protected float cellFactor = 1.25f;</span>
<span class="fc" id="L1648">    protected float tolFactor = 0.67f;</span>
    protected void setCellFactor(float f) {
<span class="nc" id="L1650">        cellFactor = f;</span>
<span class="nc" id="L1651">    }</span>
    protected void setTolFactor(float f) {
<span class="nc" id="L1653">        tolFactor = f;</span>
<span class="nc" id="L1654">    }</span>
    protected float getCellFactor() {
<span class="nc" id="L1656">        return cellFactor;</span>
    }
    protected float getTolFactor() {
<span class="nc" id="L1659">        return tolFactor;</span>
    }

    /**
     * given the scale, rotation and set 1's reference frame centroids,
     * calculate the translation between set1 and set2 assuming that not all
     * points will match.  transXTol and transYTol allow a tolerance when
     * matching the predicted position of a point in set2.
     * Note that the reference point for the rotation is the center of the
     * image 1 width and height.
     *
     * It's expected that the invoker of this method is trying to solve for
     * translation for sets of points like corners in images.  This assumption
     * means that the number of point pair combinations is always far less
     * than the pixel combinations of translations over x and y.
     *
     * NOTE: scale has be &gt;= 1, so if one image has a smaller scale, it has to
     * be the first set given in arguments.
     *
     * ALSO NOTE: if you know a better solution exists for translation
     * parameters that matches fewer points, but has a small avg dist from
     * model and smaller standard deviation from the avg dist from model,
     * then transXTol and transYTol should be set to a smaller value and passed
     * to this method.
     *
     * @param matched1 set of points from image 1 to match to image2.
     * @param matched2 set of points from image 2 to be matched with image 1
     * @param rotationInRadians given in radians with value between 0 and 2*pi, exclusive
     * @param scale
     * @param image1Width
     * @param image1Height
     * @param image2Width
     * @param image2Height
     * @return
     */
    public TransformationParameters calculateTranslationForMatched(
        PairIntArray matched1, PairIntArray matched2,
        float rotationInRadians, float scale,
        int image1Width, int image1Height, int image2Width, int image2Height) {

<span class="nc bnc" id="L1699" title="All 2 branches missed.">        if (scale &lt; 1) {</span>
            // numerical errors in rounding to integer can give wrong solutions
            //throw new IllegalStateException(&quot;scale cannot be smaller than 1&quot;);

<span class="nc" id="L1703">            log.severe(&quot;scale cannot be smaller than 1&quot;);</span>

<span class="nc" id="L1705">            return null;</span>
        }

<span class="nc" id="L1708">        int image1CentroidX = image1Width &gt;&gt; 1;</span>
<span class="nc" id="L1709">        int image1CentroidY = image1Height &gt;&gt; 1;</span>

<span class="nc" id="L1711">        double scaleTimesCosine = scale * Math.cos(rotationInRadians);</span>
<span class="nc" id="L1712">        double scaleTimesSine = scale * Math.sin(rotationInRadians);</span>

<span class="nc" id="L1714">        double avgTransX = 0;</span>
<span class="nc" id="L1715">        double avgTransY = 0;</span>

<span class="nc bnc" id="L1717" title="All 2 branches missed.">        for (int i = 0; i &lt; matched1.getN(); i++) {</span>

<span class="nc" id="L1719">            int x = matched1.getX(i);</span>
<span class="nc" id="L1720">            int y = matched1.getY(i);</span>

<span class="nc" id="L1722">            double xr = image1CentroidX*scale + (</span>
                ((x - image1CentroidX) * scaleTimesCosine) +
                ((y - image1CentroidY) * scaleTimesSine));

<span class="nc" id="L1726">            double yr = image1CentroidY*scale + (</span>
                (-(x - image1CentroidX) * scaleTimesSine) +
                ((y - image1CentroidY) * scaleTimesCosine));

<span class="nc" id="L1730">            int x2 = matched2.getX(i);</span>

<span class="nc" id="L1732">            int y2 = matched2.getY(i);</span>

<span class="nc" id="L1734">            avgTransX += (int)Math.round(x2 - xr);</span>

<span class="nc" id="L1736">            avgTransY += (int)Math.round(y2 - yr);</span>
        }

<span class="nc" id="L1739">        avgTransX /= (float)matched1.getN();</span>

<span class="nc" id="L1741">        avgTransY /= (float)matched1.getN();</span>

<span class="nc" id="L1743">        TransformationParameters params =</span>
            new TransformationParameters();
<span class="nc" id="L1745">        params.setRotationInRadians(rotationInRadians);</span>
<span class="nc" id="L1746">        params.setScale(scale);</span>
<span class="nc" id="L1747">        params.setTranslationX((float)avgTransX);</span>
<span class="nc" id="L1748">        params.setTranslationY((float)avgTransY);</span>

<span class="nc" id="L1750">        return params;</span>
    }

    /**
     * given the transformed x y that have already been scaled and rotated, add the
     * transX and transY, respectively and calculated the average residual
     * between that and set2 and the standard deviation from the average.
     * Note that set2 and (scaledRotatedX, scaledRotatedY) are NOT known to be
     * matched points so the residuals are minimized for each point in
     * the model to find the matching in set2 before computing the
     * average and standard deviation.
     *
     * @param set2
     * @param scaledRotatedSet1 the model xy points scaled and rotated
     * @param transX the x translation to apply to the model points
     * @param transY the y translation to apply to the model points
     * @return
     */
    protected TransformationPointFit evaluateFitForUnMatchedGreedy(
        PairFloatArrayUnmodifiable scaledRotatedSet1,
        float transX, float transY,
        float tolTransX, float tolTransY,
        PairIntArray set2,
        final float scale, final float rotationRadians) {

<span class="nc bnc" id="L1775" title="All 2 branches missed.">        if (set2 == null) {</span>
<span class="nc" id="L1776">            throw new IllegalArgumentException(</span>
            &quot;set2 cannot be null&quot;);
        }
<span class="nc bnc" id="L1779" title="All 2 branches missed.">        if (scaledRotatedSet1 == null) {</span>
<span class="nc" id="L1780">            throw new IllegalArgumentException(</span>
            &quot;scaledRotatedSet1 cannot be null&quot;);
        }

        //TODO: consider filtering for the intersection

<span class="nc bnc" id="L1786" title="All 2 branches missed.">        int nMaxMatchable = (scaledRotatedSet1.getN() &lt; set2.getN()) ?</span>
<span class="nc" id="L1787">            scaledRotatedSet1.getN() : set2.getN();</span>

<span class="nc" id="L1789">        Set&lt;Integer&gt; chosen = new HashSet&lt;Integer&gt;();</span>

<span class="nc" id="L1791">        double[] diffs = new double[scaledRotatedSet1.getN()];</span>
<span class="nc" id="L1792">        int nMatched = 0;</span>
<span class="nc" id="L1793">        double avg = 0;</span>

<span class="nc bnc" id="L1795" title="All 2 branches missed.">        for (int i = 0; i &lt; scaledRotatedSet1.getN(); i++) {</span>

<span class="nc" id="L1797">            float transformedX = scaledRotatedSet1.getX(i) + transX;</span>
<span class="nc" id="L1798">            float transformedY = scaledRotatedSet1.getY(i) + transY;</span>

<span class="nc" id="L1800">            double minDiff = Double.MAX_VALUE;</span>
<span class="nc" id="L1801">            int min2Idx = -1;</span>

<span class="nc bnc" id="L1803" title="All 2 branches missed.">            for (int j = 0; j &lt; set2.getN(); j++) {</span>

<span class="nc bnc" id="L1805" title="All 2 branches missed.">                if (chosen.contains(Integer.valueOf(j))) {</span>
<span class="nc" id="L1806">                    continue;</span>
                }

<span class="nc" id="L1809">                float dx = set2.getX(j) - transformedX;</span>
<span class="nc" id="L1810">                float dy = set2.getY(j) - transformedY;</span>

<span class="nc bnc" id="L1812" title="All 4 branches missed.">                if ((Math.abs(dx) &gt; tolTransX) || (Math.abs(dy) &gt; tolTransY)) {</span>

<span class="nc" id="L1814">                    continue;</span>
                }

<span class="nc" id="L1817">                float diff = (float)Math.sqrt(dx*dx + dy*dy);</span>

<span class="nc bnc" id="L1819" title="All 2 branches missed.">                if (diff &lt; minDiff) {</span>
<span class="nc" id="L1820">                    minDiff = diff;</span>
<span class="nc" id="L1821">                    min2Idx = j;</span>
                }
            }

<span class="nc bnc" id="L1825" title="All 2 branches missed.">            if (minDiff &lt; Double.MAX_VALUE) {</span>
<span class="nc" id="L1826">                diffs[nMatched] = minDiff;</span>
<span class="nc" id="L1827">                nMatched++;</span>
<span class="nc" id="L1828">                chosen.add(Integer.valueOf(min2Idx));</span>
<span class="nc" id="L1829">                avg += minDiff;</span>
            }
        }

<span class="nc bnc" id="L1833" title="All 2 branches missed.">        avg = (nMatched == 0) ? Double.MAX_VALUE :</span>
            avg / (double)nMatched;

<span class="nc" id="L1836">        double stDev = 0;</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">        for (int i = 0; i &lt; nMatched; i++) {</span>
<span class="nc" id="L1838">            double d = diffs[i] - avg;</span>
<span class="nc" id="L1839">            stDev += (d * d);</span>
        }

<span class="nc bnc" id="L1842" title="All 2 branches missed.">        stDev = (nMatched == 0) ? Double.MAX_VALUE :</span>
<span class="nc" id="L1843">            Math.sqrt(stDev/((double)nMatched - 1.));</span>

<span class="nc" id="L1845">        TransformationParameters params = new TransformationParameters();</span>
<span class="nc" id="L1846">        params.setRotationInRadians(rotationRadians);</span>
<span class="nc" id="L1847">        params.setScale(scale);</span>
<span class="nc" id="L1848">        params.setTranslationX(transX);</span>
<span class="nc" id="L1849">        params.setTranslationY(transY);</span>
<span class="nc" id="L1850">        params.setOriginX(0);</span>
<span class="nc" id="L1851">        params.setOriginY(0);</span>

<span class="nc" id="L1853">        TransformationPointFit fit = new TransformationPointFit(params, nMatched,</span>
            avg, stDev, tolTransX, tolTransY);

<span class="nc" id="L1856">        fit.setMaximumNumberMatchable(nMaxMatchable);</span>

<span class="nc" id="L1858">        return fit;</span>
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    TransformationPointFit[] refineTransformationWithDownhillSimplex(
        TransformationPointFit[] fits,
        PairIntArray set1, PairIntArray set2,
        float transX, float transY, float tolTransX, float tolTransY,
        float plusMinusTransX, float plusMinusTransY,
        boolean searchScaleToo,
        boolean useGreedyMatching,
        boolean setsAreMatched, int nMaxIter) {

<span class="pc bpc" id="L1871" title="1 of 2 branches missed.">        int nMaxMatchable = (set1.getN() &lt; set2.getN()) ?</span>
<span class="pc" id="L1872">            set1.getN() : set2.getN();</span>

<span class="pc bpc" id="L1874" title="1 of 2 branches missed.">        if (nMaxMatchable == 0) {</span>
<span class="nc" id="L1875">            return null;</span>
        }

        //TODO: revise this.  consider a sqrt(nMaxMatchable)
<span class="fc" id="L1879">        double eps = Math.log(nMaxMatchable)/Math.log(10);</span>

<span class="fc" id="L1881">        float alpha = 1;   // &gt; 0</span>
<span class="fc" id="L1882">        float gamma = 2;   // &gt; 1</span>
<span class="fc" id="L1883">        float beta = 0.5f;</span>
<span class="fc" id="L1884">        float tau = 0.5f;</span>

        // alternates changes in rotation, translation of X and translation of Y

<span class="fc" id="L1888">        boolean go = true;</span>

<span class="fc" id="L1890">        float txMin = transX - plusMinusTransX;</span>
<span class="fc" id="L1891">        float txMax = transX + plusMinusTransX;</span>
<span class="fc" id="L1892">        float tyMin = transY - plusMinusTransY;</span>
<span class="fc" id="L1893">        float tyMax = transY + plusMinusTransY;</span>

<span class="pc bpc" id="L1895" title="1 of 2 branches missed.">        float rotInRadians = (fits[0] != null) ? fits[0].getRotationInRadians()</span>
            : 0;
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">        float scale = (fits[0] != null) ? fits[0].getScale() : 1;</span>

<span class="fc" id="L1899">        int nIter = 0;</span>
<span class="fc" id="L1900">        int lastAlt = 0;</span>

<span class="fc" id="L1902">        int bestFitIdx = 0;</span>
<span class="fc" id="L1903">        int worstFitIdx = fits.length - 1;</span>

<span class="fc" id="L1905">        TransformationParameters[] lastParams = extractParameters(fits);</span>

<span class="fc bfc" id="L1907" title="All 4 branches covered.">        while (go &amp;&amp; (nIter &lt; nMaxIter)) {</span>

<span class="pc bpc" id="L1909" title="1 of 2 branches missed.">            if (fits.length == 0) {</span>
<span class="nc" id="L1910">                break;</span>
            }

<span class="fc" id="L1913">            sortByDescendingMatches(fits, 0, (fits.length - 1));</span>

<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">            if (fits[bestFitIdx] == null) {</span>
<span class="nc" id="L1916">                break;</span>
            }

<span class="pc bpc" id="L1919" title="1 of 2 branches missed.">            for (int i = (fits.length - 1); i &gt; -1; --i) {</span>
<span class="pc bpc" id="L1920" title="1 of 2 branches missed.">                if (fits[i] != null) {</span>
<span class="fc" id="L1921">                    worstFitIdx = i;</span>
<span class="fc" id="L1922">                    break;</span>
                }
            }

<span class="pc bpc" id="L1926" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc bnc" id="L1927" title="All 4 branches missed.">                if ((nIter == 0) || (nIter % 5 == 0)) {</span>
<span class="nc" id="L1928">                    writeSimplex(fits, false);</span>
                }
            }

<span class="fc bfc" id="L1932" title="All 2 branches covered.">            if (nIter &gt; 0) {</span>

<span class="fc" id="L1934">                TransformationParameters[] currentParams = extractParameters(fits);</span>

<span class="fc" id="L1936">                boolean areTheSame = areEqual(lastParams, currentParams);</span>

<span class="pc bpc" id="L1938" title="1 of 2 branches missed.">                if (areTheSame) {</span>
<span class="nc" id="L1939">                    break;</span>
                }

<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">                if (nIter &gt; 50) {</span>
<span class="nc" id="L1943">                    double[] stdevs = getStandardDeviation(currentParams);</span>
<span class="nc bnc" id="L1944" title="All 4 branches missed.">                    if (stdevs != null &amp;&amp; (stdevs.length &gt; 0)) {</span>
<span class="nc" id="L1945">                        boolean areNearlyZero = true;</span>
<span class="nc bnc" id="L1946" title="All 2 branches missed.">                        for (double stdv : stdevs) {</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">                            if (Math.abs(stdv) &gt; 0.01) {</span>
<span class="nc" id="L1948">                                areNearlyZero = false;</span>
                            }
                        }
<span class="nc bnc" id="L1951" title="All 2 branches missed.">                        if (areNearlyZero) {</span>
<span class="nc" id="L1952">                            break;</span>
                        }
                    }
                }

<span class="fc" id="L1957">                lastParams = currentParams;</span>
            }

            // determine center for all points excepting the worse fit
<span class="fc" id="L1961">            float txSum = 0.0f;</span>
<span class="fc" id="L1962">            float tySum = 0.0f;</span>
<span class="fc" id="L1963">            double rotSum = 0.0f;</span>
<span class="fc" id="L1964">            double scaleSum = 0.0f;</span>
<span class="fc" id="L1965">            int c = 0;</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">            for (int i = 0; i &lt; (fits.length - 1); ++i) {</span>
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">                if (fits[i] != null) {</span>
<span class="fc" id="L1968">                    txSum += fits[i].getTranslationX();</span>
<span class="fc" id="L1969">                    tySum += fits[i].getTranslationY();</span>
<span class="fc" id="L1970">                    rotSum += (fits[i].getRotationInRadians()/(2.*Math.PI));</span>
<span class="fc" id="L1971">                    scaleSum += (fits[i].getScale());</span>
<span class="fc" id="L1972">                    c++;</span>
                }
            }
<span class="fc" id="L1975">            transX = txSum / (float)c;</span>
<span class="fc" id="L1976">            transY = tySum / (float)c;</span>
<span class="fc" id="L1977">            rotInRadians = (float)(rotSum/(float)c)*((float)(2.*Math.PI));</span>
<span class="fc" id="L1978">            scale = (float)(scaleSum / (float)c);</span>

            // &quot;Reflection&quot;

<span class="fc" id="L1982">            float txReflect = 0;</span>
<span class="fc" id="L1983">            float tyReflect = 0;</span>
<span class="fc" id="L1984">            float rotReflect = 0;</span>
<span class="fc" id="L1985">            float scaleReflect = 1;</span>

<span class="fc" id="L1987">            TransformationParameters paramsReflect = new TransformationParameters();</span>
<span class="pc bpc" id="L1988" title="1 of 2 branches missed.">            if (fits[worstFitIdx] != null) {</span>
<span class="fc" id="L1989">                paramsReflect.setScale(fits[worstFitIdx].getScale());</span>
<span class="fc" id="L1990">                paramsReflect.setRotationInRadians(fits[worstFitIdx].getRotationInRadians());</span>
<span class="fc" id="L1991">                paramsReflect.setTranslationX(fits[worstFitIdx].getTranslationX());</span>
<span class="fc" id="L1992">                paramsReflect.setTranslationY(fits[worstFitIdx].getTranslationY());</span>
<span class="fc" id="L1993">                paramsReflect.setOriginX(fits[worstFitIdx].getParameters().getOriginX());</span>
<span class="fc" id="L1994">                paramsReflect.setOriginY(fits[worstFitIdx].getParameters().getOriginY());</span>
            }

<span class="pc bpc" id="L1997" title="1 of 4 branches missed.">            switch(lastAlt) {</span>
                case 0: {
                    // change translation X
<span class="fc" id="L2000">                    txReflect = transX + (alpha</span>
<span class="fc" id="L2001">                        * (transX - fits[worstFitIdx].getTranslationX()));</span>
<span class="fc" id="L2002">                    paramsReflect.setTranslationX(txReflect);</span>
<span class="fc" id="L2003">                    break;</span>
                }
                case 1: {
                    // change translation Y
<span class="fc" id="L2007">                    tyReflect = transY + (alpha</span>
<span class="fc" id="L2008">                        * (transY - fits[worstFitIdx].getTranslationY()));</span>
<span class="fc" id="L2009">                    paramsReflect.setTranslationY(tyReflect);</span>
<span class="fc" id="L2010">                    break;</span>
                }
                case 2: {
<span class="pc bpc" id="L2013" title="1 of 2 branches missed.">                    if (searchScaleToo) {</span>
<span class="nc" id="L2014">                        scaleReflect  = scale + (alpha</span>
<span class="nc" id="L2015">                            * (scale - fits[worstFitIdx].getScale()));</span>
<span class="nc" id="L2016">                        paramsReflect.setScale(scaleReflect);</span>
<span class="nc" id="L2017">                        break;</span>
                    }
                    // else fall through to rotation
                }
                default: {
                    // change rotation
<span class="fc" id="L2023">                    rotReflect = rotInRadians + (alpha</span>
<span class="fc" id="L2024">                        * (rotInRadians - fits[worstFitIdx].getRotationInRadians()));</span>
<span class="fc bfc" id="L2025" title="All 2 branches covered.">                    if (rotReflect &lt; 0) {</span>
<span class="fc" id="L2026">                        rotReflect = rotReflect + (float)(2.*Math.PI);</span>
<span class="pc bpc" id="L2027" title="1 of 2 branches missed.">                    } else if (rotReflect &gt;= (2.*Math.PI)) {</span>
<span class="nc" id="L2028">                        rotReflect = rotReflect - (float)(2.*Math.PI);</span>
                    }
<span class="fc" id="L2030">                    paramsReflect.setRotationInRadians(rotReflect);</span>
                    break;
                }
            }

<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">            TransformationPointFit fitReflected = (fits[worstFitIdx] != null) ?</span>
<span class="pc" id="L2036">                evaluateForUnmatched(paramsReflect, set1, set2,</span>
                tolTransX, tolTransY, useGreedyMatching) : null;

<span class="fc" id="L2039">            int comp0 = compare(fits[bestFitIdx], fitReflected);</span>
<span class="fc" id="L2040">            int compLast = compare(fits[worstFitIdx], fitReflected);</span>

<span class="pc bpc" id="L2042" title="1 of 4 branches missed.">            if ((comp0 &lt; 1) &amp;&amp; (compLast == 1)) {</span>

                // replace last with f_refl
<span class="fc" id="L2045">                fits[worstFitIdx] = fitReflected;</span>

<span class="pc bpc" id="L2047" title="1 of 2 branches missed.">            } else if (comp0 == 1) {</span>

                // reflected is better than best fit, so &quot;expand&quot;
                // &quot;Expansion&quot;

<span class="nc" id="L2052">                TransformationParameters paramsExpansion = new TransformationParameters();</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">                if (fitReflected != null) {</span>
<span class="nc" id="L2054">                    paramsExpansion.setScale(fitReflected.getScale());</span>
<span class="nc" id="L2055">                    paramsExpansion.setRotationInRadians(fitReflected.getRotationInRadians());</span>
<span class="nc" id="L2056">                    paramsExpansion.setTranslationX(fitReflected.getTranslationX());</span>
<span class="nc" id="L2057">                    paramsExpansion.setTranslationY(fitReflected.getTranslationY());</span>
<span class="nc" id="L2058">                    paramsExpansion.setOriginX(fitReflected.getParameters().getOriginX());</span>
<span class="nc" id="L2059">                    paramsExpansion.setOriginY(fitReflected.getParameters().getOriginY());</span>
                }

<span class="nc bnc" id="L2062" title="All 4 branches missed.">                switch (lastAlt) {</span>
                    case 0: {
                        // change translation X
<span class="nc" id="L2065">                        float txExpansion = transX + (gamma * (txReflect - transX));</span>
<span class="nc" id="L2066">                        paramsExpansion.setTranslationX(txExpansion);</span>
<span class="nc" id="L2067">                        break;</span>
                    }
                    case 1: {
                        // change translation Y
<span class="nc" id="L2071">                        float tyExpansion = transY + (gamma * (tyReflect - transY));</span>
<span class="nc" id="L2072">                        paramsExpansion.setTranslationY(tyExpansion);</span>
<span class="nc" id="L2073">                        break;</span>
                    }
                    case 2: {
<span class="nc bnc" id="L2076" title="All 2 branches missed.">                        if (searchScaleToo) {</span>
<span class="nc" id="L2077">                            float scaleExpansion = scale + (gamma * (scaleReflect - scale));</span>
<span class="nc" id="L2078">                            paramsExpansion.setScale(scaleExpansion);</span>
<span class="nc" id="L2079">                            break;</span>
                        }
                        // else fall through to rotation
                    }
                    default: {
                        // change rotation
<span class="nc" id="L2085">                        float rotExpansion = rotInRadians + (gamma * (rotReflect - rotInRadians));</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">                        if (rotExpansion &lt; 0) {</span>
<span class="nc" id="L2087">                            rotExpansion = rotExpansion + (float)(2.*Math.PI);</span>
<span class="nc bnc" id="L2088" title="All 2 branches missed.">                        } else if (rotExpansion &gt;= (2.*Math.PI)) {</span>
<span class="nc" id="L2089">                            rotExpansion = rotExpansion - (float)(2.*Math.PI);</span>
                        }
<span class="nc" id="L2091">                        paramsExpansion.setRotationInRadians(rotExpansion);</span>
<span class="nc" id="L2092">                        break;</span>
                    }
                }

<span class="nc bnc" id="L2096" title="All 2 branches missed.">                TransformationPointFit fitExpansion = (fitReflected != null) ?</span>
<span class="nc" id="L2097">                    evaluateForUnmatched(paramsExpansion, set1, set2,</span>
                    tolTransX, tolTransY, useGreedyMatching) : null;

<span class="nc" id="L2100">                int compR = compare(fitReflected, fitExpansion);</span>

<span class="nc bnc" id="L2102" title="All 2 branches missed.">                if (compR == 1) {</span>

                    // expansion fit is better than reflected fit
<span class="nc" id="L2105">                    fits[worstFitIdx] = fitExpansion;</span>

                } else {

<span class="nc" id="L2109">                    fits[worstFitIdx] = fitReflected;</span>
                }

<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">            } else if (compLast &lt; 1) {</span>

                // reflected fit is worse than the worst (last) fit, so contract
                // &quot;Contraction&quot;

<span class="fc" id="L2117">                TransformationParameters paramsContraction = new TransformationParameters();</span>

<span class="fc" id="L2119">                paramsContraction.setScale(fits[worstFitIdx].getScale());</span>
<span class="fc" id="L2120">                paramsContraction.setRotationInRadians(fits[worstFitIdx].getRotationInRadians());</span>
<span class="fc" id="L2121">                paramsContraction.setTranslationX(fits[worstFitIdx].getTranslationX());</span>
<span class="fc" id="L2122">                paramsContraction.setTranslationY(fits[worstFitIdx].getTranslationY());</span>
<span class="fc" id="L2123">                paramsContraction.setOriginX(fits[worstFitIdx].getParameters().getOriginX());</span>
<span class="fc" id="L2124">                paramsContraction.setOriginY(fits[worstFitIdx].getParameters().getOriginY());</span>

<span class="pc bpc" id="L2126" title="1 of 4 branches missed.">                switch (lastAlt) {</span>
                    case 0: {
                        // change translation X
<span class="fc" id="L2129">                        float txContraction = transX + (beta</span>
<span class="fc" id="L2130">                            * (fits[worstFitIdx].getTranslationX() - transX));</span>
<span class="fc" id="L2131">                        paramsContraction.setTranslationX(txContraction);</span>
<span class="fc" id="L2132">                        break;</span>
                    }
                    case 1: {
                        // change translation Y
<span class="fc" id="L2136">                        float tyContraction = transY + (beta</span>
<span class="fc" id="L2137">                            * (fits[worstFitIdx].getTranslationY() - transY));</span>
<span class="fc" id="L2138">                        paramsContraction.setTranslationY(tyContraction);</span>
<span class="fc" id="L2139">                        break;</span>
                    }
                    case 2: {
<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">                        if (searchScaleToo) {</span>
<span class="nc" id="L2143">                            float scaleContraction = scale + (beta</span>
<span class="nc" id="L2144">                                * (fits[worstFitIdx].getScale() - scale));</span>
<span class="nc" id="L2145">                            paramsContraction.setScale(scaleContraction);</span>
<span class="nc" id="L2146">                            break;</span>
                        }
                        // else fall through to rotation
                    }
                    default: {
                        // change rotation
<span class="fc" id="L2152">                        float rotContraction = rotInRadians + (beta</span>
<span class="fc" id="L2153">                            * (fits[worstFitIdx].getRotationInRadians() - rotInRadians));</span>
<span class="fc bfc" id="L2154" title="All 2 branches covered.">                        if (rotContraction &lt; 0) {</span>
<span class="fc" id="L2155">                            rotContraction = rotContraction + (float)(2.*Math.PI);</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">                        } else if (rotContraction &gt;= (2.*Math.PI)) {</span>
<span class="nc" id="L2157">                            rotContraction = rotContraction - (float)(2.*Math.PI);</span>
                        }
<span class="fc" id="L2159">                        paramsContraction.setRotationInRadians(rotContraction);</span>
<span class="fc" id="L2160">                        break;</span>
                    }
                }

<span class="pc bpc" id="L2164" title="1 of 2 branches missed.">                TransformationPointFit fitContraction = (fits[worstFitIdx] != null) ?</span>
<span class="pc" id="L2165">                    evaluateForUnmatched(paramsContraction, set1, set2,</span>
                    tolTransX, tolTransY, useGreedyMatching) : null;

<span class="fc" id="L2168">                int compC = compare(fits[worstFitIdx], fitContraction);</span>

<span class="fc bfc" id="L2170" title="All 2 branches covered.">                if (compC &gt; -1) {</span>

<span class="fc" id="L2172">                    fits[worstFitIdx] = fitContraction;</span>

                } else {

                    // &quot;Reduction&quot;
<span class="fc bfc" id="L2177" title="All 2 branches covered.">                    for (int i = 1; i &lt; fits.length; ++i) {</span>

<span class="pc bpc" id="L2179" title="2 of 4 branches missed.">                        if (fits[i] == null || fits[bestFitIdx] == null) {</span>
                            /*TODO: consider setting this
                            fits[i] = new TransformationPointFit(
                                new TransformationParameters(),
                                0, Double.MAX_VALUE, Double.MAX_VALUE,
                                Double.MAX_VALUE
                            );
                            */
<span class="nc" id="L2187">                            continue;</span>
                        }

<span class="fc" id="L2190">                        TransformationParameters paramsI = new TransformationParameters();</span>
<span class="fc" id="L2191">                        paramsI.setScale(fits[i].getScale());</span>
<span class="fc" id="L2192">                        paramsI.setRotationInRadians(fits[i].getRotationInRadians());</span>
<span class="fc" id="L2193">                        paramsI.setTranslationX(fits[i].getTranslationX());</span>
<span class="fc" id="L2194">                        paramsI.setTranslationY(fits[i].getTranslationY());</span>
<span class="fc" id="L2195">                        paramsI.setOriginX(fits[i].getParameters().getOriginX());</span>
<span class="fc" id="L2196">                        paramsI.setOriginY(fits[i].getParameters().getOriginY());</span>

<span class="pc bpc" id="L2198" title="1 of 4 branches missed.">                        switch (lastAlt) {</span>
                            case 0: {
                                // change translation X
<span class="fc" id="L2201">                                float txReduction</span>
<span class="fc" id="L2202">                                    = (fits[bestFitIdx].getTranslationX()</span>
<span class="fc" id="L2203">                                    + (tau * (fits[i].getTranslationX()</span>
<span class="fc" id="L2204">                                    - fits[bestFitIdx].getTranslationX())));</span>
<span class="fc" id="L2205">                                paramsI.setTranslationX(txReduction);</span>
<span class="fc" id="L2206">                                break;</span>
                            }
                            case 1: {
                                // change translation Y
<span class="fc" id="L2210">                                float tyReduction</span>
<span class="fc" id="L2211">                                    = (fits[bestFitIdx].getTranslationY()</span>
<span class="fc" id="L2212">                                    + (tau * (fits[i].getTranslationY()</span>
<span class="fc" id="L2213">                                    - fits[bestFitIdx].getTranslationY())));</span>
<span class="fc" id="L2214">                                paramsI.setTranslationY(tyReduction);</span>
<span class="fc" id="L2215">                                break;</span>
                            }
                            case 2: {
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">                                if (searchScaleToo) {</span>
<span class="nc" id="L2219">                                    float scaleReduction</span>
<span class="nc" id="L2220">                                        = (fits[bestFitIdx].getScale()</span>
<span class="nc" id="L2221">                                        + (tau * (fits[i].getScale()</span>
<span class="nc" id="L2222">                                        - fits[bestFitIdx].getScale())));</span>
<span class="nc" id="L2223">                                    paramsI.setScale(scaleReduction);</span>
<span class="nc" id="L2224">                                    break;</span>
                                }
                                // else fall through to rotation
                            }
                            default: {
                                // change rotation
<span class="fc" id="L2230">                                float rotReduction</span>
<span class="fc" id="L2231">                                    = (fits[bestFitIdx].getRotationInRadians()</span>
<span class="fc" id="L2232">                                    + (tau * (fits[i].getRotationInRadians()</span>
<span class="fc" id="L2233">                                    - fits[bestFitIdx].getRotationInRadians())));</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">                                if (rotReduction &lt; 0) {</span>
<span class="fc" id="L2235">                                    rotReduction = rotReduction + (float)(2.*Math.PI);</span>
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">                                } else if (rotReduction &gt;= (2.*Math.PI)) {</span>
<span class="nc" id="L2237">                                    rotReduction = rotReduction - (float)(2.*Math.PI);</span>
                                }
<span class="fc" id="L2239">                                paramsI.setRotationInRadians(rotReduction);</span>
<span class="fc" id="L2240">                                break;</span>
                            }
                        }
<span class="fc" id="L2243">                        fits[i] = evaluateForUnmatched(paramsI, set1, set2,</span>
                            tolTransX, tolTransY, useGreedyMatching);
                    }
                }
            }

<span class="fc" id="L2249">            log.finest(&quot;best fit so far: nMatches=&quot;</span>
<span class="fc" id="L2250">                + fits[bestFitIdx].getNumberOfMatchedPoints()</span>
<span class="fc" id="L2251">                + &quot; diff from model=&quot; + fits[bestFitIdx].getMeanDistFromModel()</span>
            );

<span class="fc" id="L2254">            nIter++;</span>
<span class="fc" id="L2255">            lastAlt++;</span>
<span class="pc bpc" id="L2256" title="1 of 4 branches missed.">            if (searchScaleToo &amp;&amp; (lastAlt &gt; 3)) {</span>
<span class="nc" id="L2257">                lastAlt = 0;</span>
<span class="fc bfc" id="L2258" title="All 4 branches covered.">            } else if (!searchScaleToo &amp;&amp; (lastAlt &gt; 2)) {</span>
<span class="fc" id="L2259">                lastAlt = 0;</span>
            }

<span class="fc bfc" id="L2262" title="All 2 branches covered.">            if ((fits[bestFitIdx].getNumberOfMatchedPoints() == nMaxMatchable)</span>
<span class="pc bpc" id="L2263" title="1 of 2 branches missed.">                &amp;&amp; (fits[bestFitIdx].getMeanDistFromModel() &lt; eps)) {</span>
<span class="fc" id="L2264">                go = false;</span>
<span class="pc bpc" id="L2265" title="2 of 4 branches missed.">            } else if ((transX &gt; txMax) || (transX &lt; txMin)) {</span>
<span class="nc" id="L2266">                go = false;</span>
<span class="pc bpc" id="L2267" title="2 of 4 branches missed.">            } else if ((transY &gt; tyMax) || (transY &lt; tyMin)) {</span>
<span class="nc" id="L2268">                go = false;</span>
            }
<span class="fc" id="L2270">        }</span>

<span class="fc" id="L2272">        log.fine(&quot;nIter=&quot; + Integer.toString(nIter));</span>

        // additional step that's helpful if not enough iterations are used,
        // is to test the summed transX, transY which represent the center
        // of the simplex against the best fit
<span class="pc bpc" id="L2277" title="1 of 2 branches missed.">        if (fits[bestFitIdx] != null) {</span>

<span class="fc" id="L2279">            TransformationParameters p = new TransformationParameters();</span>
<span class="fc" id="L2280">            p.setScale(scale);</span>
<span class="fc" id="L2281">            p.setRotationInRadians(rotInRadians);</span>
<span class="fc" id="L2282">            p.setTranslationX(transX);</span>
<span class="fc" id="L2283">            p.setTranslationY(transY);</span>
<span class="fc" id="L2284">            p.setOriginX(fits[bestFitIdx].getParameters().getOriginX());</span>
<span class="fc" id="L2285">            p.setOriginY(fits[bestFitIdx].getParameters().getOriginY());</span>

<span class="fc" id="L2287">            TransformationPointFit fitAvg = evaluateForUnmatched(p, set1, set2,</span>
                tolTransX, tolTransY, useGreedyMatching);

<span class="fc" id="L2290">            int comp = compare(fits[bestFitIdx], fitAvg);</span>
<span class="fc bfc" id="L2291" title="All 2 branches covered.">            if (comp == 1) {</span>
<span class="fc" id="L2292">                fits[bestFitIdx] = fitAvg;</span>
            }
        }

<span class="pc bpc" id="L2296" title="1 of 2 branches missed.">        if (debug) {</span>
            // the resulting file can be viewed with resources/plot_3d_simplex_n10.html
<span class="nc" id="L2298">            writeSimplex(fits, true);</span>
        }

<span class="fc" id="L2301">        return fits;</span>
    }

    public TransformationPointFit transformAndEvaluateFit(
        PairIntArray set1, PairIntArray set2,
        TransformationParameters params, float tolTransX, float tolTransY,
        boolean useGreedyMatching, boolean setsAreMatched) {

<span class="pc bpc" id="L2309" title="1 of 2 branches missed.">        if (set2 == null) {</span>
<span class="nc" id="L2310">            throw new IllegalArgumentException(</span>
            &quot;set2 cannot be null&quot;);
        }
<span class="pc bpc" id="L2313" title="1 of 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L2314">            throw new IllegalArgumentException(</span>
            &quot;set1 cannot be null&quot;);
        }

<span class="fc" id="L2318">        Transformer transformer = new Transformer();</span>

<span class="fc" id="L2320">        PairFloatArray transformedSet1 = transformer.applyTransformation2(</span>
            params, set1);

<span class="pc bpc" id="L2323" title="1 of 2 branches missed.">        if (setsAreMatched) {</span>

<span class="nc" id="L2325">            return evaluateFitForMatchedTransformed(params, transformedSet1,</span>
                set2);

        } else {

<span class="fc" id="L2330">            return evaluateFitForUnMatchedTransformedGreedy(</span>
                params, transformedSet1, set2, tolTransX, tolTransY);
        }
    }

    private TransformationParameters[] extractParameters(
        TransformationPointFit[] fits) {

<span class="pc bpc" id="L2338" title="1 of 2 branches missed.">        if (fits == null) {</span>
<span class="nc" id="L2339">            return new TransformationParameters[0];</span>
        }

<span class="fc" id="L2342">        TransformationParameters[] params = new TransformationParameters[fits.length];</span>

<span class="fc bfc" id="L2344" title="All 2 branches covered.">        for (int i = 0; i &lt; fits.length; ++i) {</span>
<span class="pc bpc" id="L2345" title="1 of 2 branches missed.">            if (fits[i] != null) {</span>
<span class="fc" id="L2346">                params[i] = fits[i].getParameters();</span>
            }
        }

<span class="fc" id="L2350">        return params;</span>
    }

    private double[] getStandardDeviation(TransformationParameters[] params) {

<span class="nc bnc" id="L2355" title="All 4 branches missed.">        if (params == null || params.length == 0) {</span>
<span class="nc" id="L2356">            return null;</span>
        }

<span class="nc" id="L2359">        double rSum = 0;</span>
<span class="nc" id="L2360">        double sSum = 0;</span>
<span class="nc" id="L2361">        double tXSum = 0;</span>
<span class="nc" id="L2362">        double tYSum = 0;</span>

<span class="nc" id="L2364">        int count = 0;</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">        for (int i = 0; i &lt; params.length; ++i) {</span>

<span class="nc" id="L2367">            TransformationParameters p0 = params[i];</span>

<span class="nc bnc" id="L2369" title="All 2 branches missed.">            if (p0 == null) {</span>
<span class="nc" id="L2370">                continue;</span>
            }

<span class="nc" id="L2373">            rSum += p0.getRotationInRadians();</span>
<span class="nc" id="L2374">            sSum += p0.getScale();</span>
<span class="nc" id="L2375">            tXSum += p0.getTranslationX();</span>
<span class="nc" id="L2376">            tYSum += p0.getTranslationY();</span>
<span class="nc" id="L2377">            count++;</span>
        }
<span class="nc" id="L2379">        rSum /= (double)count;</span>
<span class="nc" id="L2380">        sSum /= (double)count;</span>
<span class="nc" id="L2381">        tXSum /= (double)count;</span>
<span class="nc" id="L2382">        tYSum /= (double)count;</span>

<span class="nc" id="L2384">        double rStdv = 0;</span>
<span class="nc" id="L2385">        double sStdv= 0;</span>
<span class="nc" id="L2386">        double tXStdv = 0;</span>
<span class="nc" id="L2387">        double tYStdv = 0;</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">        for (int i = 0; i &lt; params.length; ++i) {</span>

<span class="nc" id="L2390">            TransformationParameters p0 = params[i];</span>

<span class="nc bnc" id="L2392" title="All 2 branches missed.">            if (p0 == null) {</span>
<span class="nc" id="L2393">                continue;</span>
            }

<span class="nc" id="L2396">            double r = p0.getRotationInRadians() - rSum;</span>
<span class="nc" id="L2397">            double s = p0.getScale() - sSum;</span>
<span class="nc" id="L2398">            double tX = p0.getTranslationX() - tXSum;</span>
<span class="nc" id="L2399">            double tY = p0.getTranslationY() - tYSum;</span>

<span class="nc" id="L2401">            rStdv += (r*r);</span>
<span class="nc" id="L2402">            sStdv += (s*s);</span>
<span class="nc" id="L2403">            tXStdv += (tX*tX);</span>
<span class="nc" id="L2404">            tYStdv += (tY*tY);</span>
        }
<span class="nc" id="L2406">        rStdv = (Math.sqrt(rStdv/(count - 1.0f)));</span>
<span class="nc" id="L2407">        sStdv = (Math.sqrt(sStdv/(count - 1.0f)));</span>
<span class="nc" id="L2408">        tXStdv = (Math.sqrt(tXStdv/(count - 1.0f)));</span>
<span class="nc" id="L2409">        tYStdv = (Math.sqrt(tYStdv/(count - 1.0f)));</span>

<span class="nc" id="L2411">        return new double[]{rStdv, sStdv, tXStdv, tYStdv};</span>
    }

    /**
     * Re-evaluate the fit of the enclosed parameters, but use the new tolerance
     * for translation in x and y.
     *
     * @param fit
     * @param set1
     * @param set2
     * @return
     */
    private TransformationPointFit reevaluateForNewTolerance(
        TransformationPointFit fit, float translationXTolerance,
        float translationYTolerance, PairIntArray set1, PairIntArray set2) {

<span class="nc" id="L2427">        TransformationPointFit fit2 = reevaluateForNewTolerance(</span>
            fit, translationXTolerance, translationYTolerance,
            set1, set2, true);

<span class="nc" id="L2431">        return fit2;</span>
    }

    /**
     * Re-evaluate the fit of the enclosed parameters, but use the new tolerance
     * for translation in x and y.
     *
     * @param fit
     * @param set1
     * @param set2
     * @return
     */
    private TransformationPointFit reevaluateForNewToleranceOptimal(
        TransformationPointFit fit, float translationXTolerance,
        float translationYTolerance, PairIntArray set1, PairIntArray set2) {

<span class="nc" id="L2447">        TransformationPointFit fit2 = reevaluateForNewTolerance(</span>
            fit, translationXTolerance, translationYTolerance,
            set1, set2, false);

<span class="nc" id="L2451">        return fit2;</span>
    }

    /**
     * Re-evaluate the fit of the enclosed parameters, but use the new tolerance
     * for translation in x and y.
     *
     * @param fit
     * @param set1
     * @param set2
     * @return
     */
    private TransformationPointFit reevaluateForNewTolerance(
        TransformationPointFit fit, float translationXTolerance,
        float translationYTolerance, PairIntArray set1, PairIntArray set2,
        boolean useGreedyMatching) {

<span class="nc bnc" id="L2468" title="All 2 branches missed.">        if (fit == null) {</span>
<span class="nc" id="L2469">            return null;</span>
        }

<span class="nc" id="L2472">        float rotationInRadians = fit.getRotationInRadians();</span>

<span class="nc" id="L2474">        float scale = fit.getScale();</span>

<span class="nc" id="L2476">        TransformationParameters params = new TransformationParameters();</span>
<span class="nc" id="L2477">        params.setRotationInRadians(rotationInRadians);</span>
<span class="nc" id="L2478">        params.setScale(scale);</span>
<span class="nc" id="L2479">        params.setTranslationX(fit.getTranslationX());</span>
<span class="nc" id="L2480">        params.setTranslationY(fit.getTranslationY());</span>

<span class="nc" id="L2482">        TransformationPointFit fit2 = evaluateForUnmatched(params,</span>
            set1, set2, translationXTolerance, translationYTolerance,
            useGreedyMatching);

<span class="nc" id="L2486">        return fit2;</span>
    }

    private TransformationPointFit evaluateForUnmatched(
        final TransformationParameters params,
        PairIntArray set1, PairIntArray set2,
        float translationXTolerance, float translationYTolerance,
        boolean useGreedyMatching) {

<span class="pc bpc" id="L2495" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L2496">            return null;</span>
        }

<span class="fc" id="L2499">        boolean setsAreMatched = false;</span>

<span class="fc" id="L2501">        return transformAndEvaluateFit(set1, set2, params,</span>
            translationXTolerance, translationYTolerance,
            useGreedyMatching, setsAreMatched);
    }

    /**
     * find the minima and maxima of translationX and translationY for the given
     * fits.
     * @param fits
     * @return new float[]{minTX, maxTX, minTY, maxTY}
     */
    protected float[] getTranslationMinAndMaxes(TransformationPointFit[] fits) {

<span class="nc bnc" id="L2514" title="All 4 branches missed.">        if (fits == null || fits.length == 0) {</span>
<span class="nc" id="L2515">            return null;</span>
        }
<span class="nc" id="L2517">        float minTX = Float.MAX_VALUE;</span>
<span class="nc" id="L2518">        float maxTX = Float.MIN_VALUE;</span>
<span class="nc" id="L2519">        float minTY = Float.MAX_VALUE;</span>
<span class="nc" id="L2520">        float maxTY = Float.MIN_VALUE;</span>

<span class="nc bnc" id="L2522" title="All 2 branches missed.">        for (TransformationPointFit fit : fits) {</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">            if (fit == null) {</span>
<span class="nc" id="L2524">                continue;</span>
            }
<span class="nc" id="L2526">            float tx = fit.getTranslationX();</span>
<span class="nc" id="L2527">            float ty = fit.getTranslationY();</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">            if (tx &lt; minTX) {</span>
<span class="nc" id="L2529">                minTX = tx;</span>
            }
<span class="nc bnc" id="L2531" title="All 2 branches missed.">            if (ty &lt; minTY) {</span>
<span class="nc" id="L2532">                minTY = ty;</span>
            }
<span class="nc bnc" id="L2534" title="All 2 branches missed.">            if (tx &gt; maxTX) {</span>
<span class="nc" id="L2535">                maxTX = tx;</span>
            }
<span class="nc bnc" id="L2537" title="All 2 branches missed.">            if (ty &gt; maxTY) {</span>
<span class="nc" id="L2538">                maxTY = ty;</span>
            }
        }

<span class="nc" id="L2542">        return new float[]{minTX, maxTX, minTY, maxTY};</span>
    }

    /**
     * re-evaluate bestFit or fit, whichever has the largest translation
     * tolerance, using the smaller tolerance.  Note that there are
     * exception rules, such as when both bestFit and fit have
     * same number of points, but fit has a mean dist from model less than one
     * and bestFit has a much larger mean distance from model.  In that case,
     * even if bestFit has a smaller translation tolerance, fit will not
     * be re-evaluated because such a mean distance from model means the
     * answer has converged.
     *
     *
     * @param bestFit
     * @param fit
     * @param set1
     * @param set2
     * @param reevalFits
     * @param fitIsBetter
     */
    protected void reevaluateFitsForCommonTolerance(
        TransformationPointFit bestFit, TransformationPointFit fit,
        PairIntArray set1, PairIntArray set2,
        final TransformationPointFit[] reevalFits, final boolean[] fitIsBetter) {

<span class="nc bnc" id="L2568" title="All 2 branches missed.">        if (bestFit == null) {</span>
<span class="nc" id="L2569">            reevalFits[0] = bestFit;</span>
<span class="nc" id="L2570">            reevalFits[1] = fit;</span>
<span class="nc" id="L2571">            fitIsBetter[0] = true;</span>
<span class="nc" id="L2572">            return;</span>
<span class="nc bnc" id="L2573" title="All 2 branches missed.">        } else if (fit == null) {</span>
<span class="nc" id="L2574">            reevalFits[0] = bestFit;</span>
<span class="nc" id="L2575">            reevalFits[1] = fit;</span>
<span class="nc" id="L2576">            fitIsBetter[0] = false;</span>
<span class="nc" id="L2577">            return;</span>
        }

<span class="nc bnc" id="L2580" title="All 2 branches missed.">        if ((bestFit.getTranslationXTolerance() == fit.getTranslationXTolerance()) &amp;&amp;</span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">            (bestFit.getTranslationYTolerance() == fit.getTranslationYTolerance())) {</span>
<span class="nc" id="L2582">            fitIsBetter[0] = fitIsBetter(bestFit, fit);</span>
<span class="nc" id="L2583">            reevalFits[0] = bestFit;</span>
<span class="nc" id="L2584">            reevalFits[1] = fit;</span>
<span class="nc" id="L2585">            return;</span>
        }

        /*
        check for whether fit has converged already for equal number of points
        matched.
        */
<span class="nc" id="L2592">        int bestNMatches = bestFit.getNumberOfMatchedPoints();</span>
<span class="nc" id="L2593">        int compNMatches = fit.getNumberOfMatchedPoints();</span>
<span class="nc" id="L2594">        int diffEps = (int)Math.round(2.*Math.ceil(Math.max(bestNMatches,</span>
            compNMatches)/10.));
<span class="nc bnc" id="L2596" title="All 2 branches missed.">        if (diffEps == 0) {</span>
<span class="nc" id="L2597">            diffEps = 1;</span>
        }

<span class="nc" id="L2600">        double compAvg = fit.getMeanDistFromModel();</span>
<span class="nc" id="L2601">        double bestAvg = bestFit.getMeanDistFromModel();</span>

<span class="nc" id="L2603">        double compS = fit.getStDevFromMean();</span>
<span class="nc" id="L2604">        double bestS = bestFit.getStDevFromMean();</span>

<span class="nc" id="L2606">        double aDiv = bestAvg/compAvg;</span>

        // TODO:  this skips the equal tolerance re-eval if solutions are already
        //    alot better and have significant number of points matched
<span class="nc bnc" id="L2610" title="All 4 branches missed.">        if ((compNMatches &gt; 10) &amp;&amp; (bestNMatches &gt; 10)) {</span>
<span class="nc" id="L2611">            float nDiv = (float)bestNMatches/(float)compNMatches;</span>
<span class="nc" id="L2612">            double sDiv = bestS/compS;</span>
<span class="nc" id="L2613">            double nLimit0 = 2;</span>
<span class="nc" id="L2614">            double nLimit1 = 0.5;</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">            if (bestNMatches &gt; 50) {</span>
<span class="nc" id="L2616">                nLimit0 = 1.5;</span>
            }
<span class="nc bnc" id="L2618" title="All 2 branches missed.">            if (compNMatches &gt; 50) {</span>
<span class="nc" id="L2619">                nLimit1 = 1./1.5;</span>
            }
<span class="nc bnc" id="L2621" title="All 6 branches missed.">            if ((nDiv &gt; nLimit0) &amp;&amp; (aDiv &lt; 0.5) &amp;&amp; (sDiv &lt; 0.5)) {</span>
<span class="nc" id="L2622">                fitIsBetter[0] = false;</span>
<span class="nc" id="L2623">                reevalFits[0] = bestFit;</span>
<span class="nc" id="L2624">                reevalFits[1] = fit;</span>
<span class="nc" id="L2625">                return;</span>
<span class="nc bnc" id="L2626" title="All 6 branches missed.">            } else if ((nDiv &lt; nLimit1) &amp;&amp; (aDiv &gt; 2) &amp;&amp; (sDiv &gt; 2)) {</span>
<span class="nc" id="L2627">                fitIsBetter[0] = true;</span>
<span class="nc" id="L2628">                reevalFits[0] = bestFit;</span>
<span class="nc" id="L2629">                reevalFits[1] = fit;</span>
<span class="nc" id="L2630">                return;</span>
            }
        }

        /*
        when tolerances are both already very small, not redoing the fit,
        just comparing as is
        */
<span class="nc" id="L2638">        int limit = 7;</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">        if ((bestFit.getTranslationXTolerance() &lt; limit) &amp;&amp;</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">            (bestFit.getTranslationYTolerance() &lt; limit) &amp;&amp;</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">            (fit.getTranslationXTolerance() &lt; limit) &amp;&amp;</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">            (fit.getTranslationYTolerance() &lt; limit)) {</span>

<span class="nc" id="L2644">            fitIsBetter[0] = fitIsBetter(bestFit, fit);</span>
<span class="nc" id="L2645">            reevalFits[0] = bestFit;</span>
<span class="nc" id="L2646">            reevalFits[1] = fit;</span>
<span class="nc" id="L2647">            return;</span>
        }

        /*
        -1 : both are not null and bestFit tolerances are smaller
         0 : both are not null and tolerances are same.
         1 : both are not null and fit tolerances are smaller
         2 : both are not null and the x and y fits and smaller and larger in a mix
         3 : either bestFit or fit is null
        */
<span class="nc" id="L2657">        int compTol = compareTolerance(bestFit, fit);</span>

<span class="nc" id="L2659">        TransformationPointFit bestFitT = bestFit;</span>
<span class="nc" id="L2660">        TransformationPointFit fitT = fit;</span>

        float tolX, tolY;
<span class="nc bnc" id="L2663" title="All 2 branches missed.">        if (compTol != 3) {</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">            if (compTol == 1) {</span>
<span class="nc" id="L2665">                tolX = fit.getTranslationXTolerance();</span>
<span class="nc" id="L2666">                tolY = fit.getTranslationYTolerance();</span>
<span class="nc bnc" id="L2667" title="All 2 branches missed.">            } else if (compTol == -1) {</span>
<span class="nc" id="L2668">                tolX = bestFit.getTranslationXTolerance();</span>
<span class="nc" id="L2669">                tolY = bestFit.getTranslationYTolerance();</span>
            } else {
<span class="nc" id="L2671">                tolX = bestFit.getTranslationXTolerance();</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">                if (fit.getTranslationXTolerance() &lt; tolX) {</span>
<span class="nc" id="L2673">                    tolX = fit.getTranslationXTolerance();</span>
                }
<span class="nc" id="L2675">                tolY = bestFit.getTranslationYTolerance();</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">                if (fit.getTranslationYTolerance() &lt; tolY) {</span>
<span class="nc" id="L2677">                    tolY = fit.getTranslationYTolerance();</span>
                }
            }
            /*
            for small tolerances, both need to be re-evaluated with optimal
            matching, and then compared
            but the results should not be saved because that would result
            in an inconsistent mix of comparisons with greedy and optimal
            matching outside of this method
            */
<span class="nc" id="L2687">            int limitT = 11;</span>
<span class="nc bnc" id="L2688" title="All 6 branches missed.">            if ((tolX &lt; limitT) &amp;&amp; (tolY &lt; limitT) &amp;&amp; (compTol != 0)) {</span>

<span class="nc" id="L2690">                bestFitT = reevaluateForNewToleranceOptimal(bestFit,</span>
                    tolX, tolY,
                    set1, set2);

<span class="nc" id="L2694">                fitT = reevaluateForNewToleranceOptimal(fit,</span>
                    tolX, tolY,
                    set1, set2);

<span class="nc" id="L2698">                float nBDiv = (float)bestFit.getNumberOfMatchedPoints()/</span>
<span class="nc" id="L2699">                    (float)bestFitT.getNumberOfMatchedPoints();</span>

<span class="nc" id="L2701">                float nFDiv = (float)fit.getNumberOfMatchedPoints()/</span>
<span class="nc" id="L2702">                    (float)fitT.getNumberOfMatchedPoints();</span>

<span class="nc bnc" id="L2704" title="All 2 branches missed.">                if (</span>
<span class="nc bnc" id="L2705" title="All 4 branches missed.">                    (fitT == null) || (fitT.getNumberOfMatchedPoints() &lt; 2) ||</span>
                    (bestFitT == null) ||
<span class="nc bnc" id="L2707" title="All 2 branches missed.">                    (bestFitT.getNumberOfMatchedPoints() &lt; 2)</span>
                    //|| (nBDiv &gt; 4) || (nFDiv &gt; 4)
                ) {
<span class="nc" id="L2710">                    fitIsBetter[0] = fitIsBetter(bestFit, fit);</span>
<span class="nc" id="L2711">                    reevalFits[0] = bestFit;</span>
<span class="nc" id="L2712">                    reevalFits[1] = fit;</span>
                } else {
<span class="nc" id="L2714">                    fitIsBetter[0] = fitIsBetter(bestFitT, fitT);</span>
<span class="nc" id="L2715">                    reevalFits[0] = bestFit;</span>
<span class="nc" id="L2716">                    reevalFits[1] = fit;</span>
                }
<span class="nc" id="L2718">                return;</span>
            }

<span class="nc bnc" id="L2721" title="All 2 branches missed.">            if (compTol == 1) {</span>

<span class="nc" id="L2723">                bestFitT = reevaluateForNewTolerance(bestFit, tolX, tolY, set1,</span>
                    set2);

                //TODO: may need to discard only if smaller tolerances &lt; 10
                // do not use the lower tolerance.  it may be a false fit if null here
<span class="nc bnc" id="L2728" title="All 2 branches missed.">                if (bestFitT == null) {</span>
<span class="nc" id="L2729">                    bestFitT = bestFit;</span>
<span class="nc bnc" id="L2730" title="All 2 branches missed.">                } else if (bestFitT.getNumberOfMatchedPoints() == 0) {</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">                    if (bestFit.getNumberOfMatchedPoints() &gt; 10) {</span>
<span class="nc" id="L2732">                        bestFitT = bestFit;</span>
                    }
                }
<span class="nc bnc" id="L2735" title="All 2 branches missed.">            } else if (compTol == -1) {</span>

<span class="nc" id="L2737">                fitT = reevaluateForNewTolerance(fit, tolX, tolY, set1, set2);</span>

                //TODO: may need to discard only if smaller tolerances &lt; 10
                // do not use the lower tolerance if resulted in null fit
<span class="nc bnc" id="L2741" title="All 2 branches missed.">                if (fitT == null) {</span>
<span class="nc" id="L2742">                    fitT = fit;</span>
<span class="nc bnc" id="L2743" title="All 2 branches missed.">                } else if (fitT.getNumberOfMatchedPoints() == 0) {</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">                    if (fit.getNumberOfMatchedPoints() &gt; 10) {</span>
<span class="nc" id="L2745">                        fitT = fit;</span>
                    }
                } else if (true) {
                    // need to try optimal matching for both.
                    // TODO: may be what the entire method should use for simplicity.
<span class="nc" id="L2750">                    if (</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">                        (fit.getNumberOfMatchedPoints() &gt; 10) &amp;&amp;</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">                        (((float)fit.getNumberOfMatchedPoints()/(float)fitT.getNumberOfMatchedPoints())</span>
                        &gt; 4)) {

<span class="nc" id="L2755">                        bestFitT = reevaluateForNewToleranceOptimal(bestFit,</span>
                            tolX, tolY,
                            set1, set2);

<span class="nc" id="L2759">                        fitT = reevaluateForNewToleranceOptimal(fit,</span>
                            tolX, tolY,
                            set1, set2);

<span class="nc" id="L2763">                        float nBDiv = (float) bestFit.getNumberOfMatchedPoints()</span>
<span class="nc" id="L2764">                            / (float) bestFitT.getNumberOfMatchedPoints();</span>

<span class="nc" id="L2766">                        float nFDiv = (float) fit.getNumberOfMatchedPoints()</span>
<span class="nc" id="L2767">                            / (float) fitT.getNumberOfMatchedPoints();</span>

<span class="nc bnc" id="L2769" title="All 6 branches missed.">                        if ((fitT == null) || (fitT.getNumberOfMatchedPoints() &lt; 2)</span>
                            || (bestFitT == null)
<span class="nc bnc" id="L2771" title="All 2 branches missed.">                            || (bestFitT.getNumberOfMatchedPoints() &lt; 2) //|| (nBDiv &gt; 4) || (nFDiv &gt; 4)</span>
                            ) {
<span class="nc" id="L2773">                            fitIsBetter[0] = fitIsBetter(bestFit, fit);</span>
<span class="nc" id="L2774">                            reevalFits[0] = bestFit;</span>
<span class="nc" id="L2775">                            reevalFits[1] = fit;</span>
                        } else {
<span class="nc" id="L2777">                            fitIsBetter[0] = fitIsBetter(bestFitT, fitT);</span>
<span class="nc" id="L2778">                            reevalFits[0] = bestFit;</span>
<span class="nc" id="L2779">                            reevalFits[1] = fit;</span>
                        }
<span class="nc" id="L2781">                        return;</span>
                    }
                }

<span class="nc bnc" id="L2785" title="All 2 branches missed.">            } else if (compTol == 2) {</span>

                // TODO: may need to revise this
                // reduce both to smallest tolerances
<span class="nc" id="L2789">                bestFitT = reevaluateForNewTolerance(bestFit,</span>
                    tolX, tolY, set1, set2);

<span class="nc" id="L2792">                fitT = reevaluateForNewTolerance(fit,</span>
                    tolX, tolY, set1, set2);
            }
        }

<span class="nc" id="L2797">        fitIsBetter[0] = fitIsBetter(bestFitT, fitT);</span>

<span class="nc" id="L2799">        reevalFits[0] = bestFit;</span>

<span class="nc bnc" id="L2801" title="All 4 branches missed.">        if (fitIsBetter[0] &amp;&amp; (fitT != null)) {</span>
<span class="nc" id="L2802">           reevalFits[1] = fitT;</span>
        }

<span class="nc bnc" id="L2805" title="All 4 branches missed.">if (bestFit != null &amp;&amp; fit != null) {</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">if (compTol == 1) {</span>
<span class="nc" id="L2807">    log.fine(&quot;    rot re-evaluated bestFit at lower tolerance&quot;);</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">} else if (compTol == 2) {</span>
<span class="nc" id="L2809">    log.fine(&quot;    rot re-evaluated bestFit and fit at common tolerance&quot;);</span>
}
}

<span class="nc" id="L2813">    }</span>

<span class="fc" id="L2815">    private PolygonPlotterPNG plotter = null;</span>
    //TODO: put this in an aspect
    private void plotTranslationSimplex(TransformationPointFit[] fits,
        float minX, float maxX, float minY, float maxY, java.awt.Color clr) {

        try {
<span class="nc bnc" id="L2821" title="All 2 branches missed.">            if (plotter == null) {</span>
<span class="nc" id="L2822">                plotter = new PolygonPlotterPNG(minX, maxX, minY, maxY,</span>
                    &quot;translation simplex&quot;, &quot;transX&quot;, &quot;transY&quot;);
            }
<span class="nc" id="L2825">            int count = 0;</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">            for (TransformationPointFit fit : fits) {</span>
<span class="nc bnc" id="L2827" title="All 2 branches missed.">                if (fit == null) {</span>
<span class="nc" id="L2828">                    continue;</span>
                }
<span class="nc" id="L2830">                count++;</span>
            }
<span class="nc" id="L2832">            double[] x = new double[count];</span>
<span class="nc" id="L2833">            double[] y = new double[x.length];</span>
<span class="nc" id="L2834">            count = 0;</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">            for (TransformationPointFit fit : fits) {</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">                if (fit == null) {</span>
<span class="nc" id="L2837">                    continue;</span>
                }
<span class="nc" id="L2839">                x[count] = fit.getTranslationX();</span>
<span class="nc" id="L2840">                y[count] = fit.getTranslationY();</span>
<span class="nc" id="L2841">                count++;</span>
            }

<span class="nc bnc" id="L2844" title="All 2 branches missed.">            if (clr == null) {</span>
<span class="nc" id="L2845">                plotter.addPolygon(x, y);</span>
            } else {
<span class="nc" id="L2847">                plotter.addPolygon(x, y, clr);</span>
            }

<span class="nc" id="L2850">        } catch (IOException e) {</span>
<span class="nc" id="L2851">            log.severe(e.getMessage());</span>
<span class="nc" id="L2852">        }</span>
<span class="nc" id="L2853">    }</span>

<span class="fc" id="L2855">    private FileWriter simplexCSVFileW = null;</span>
<span class="fc" id="L2856">    private BufferedWriter simplexCSVFileWriter = null;</span>
    //TODO: put this in an aspect
    private void writeSimplex(TransformationPointFit[] fits, boolean closeFile) {

        //need a convention for writing for nulls.  will use max of rot, transX,
        //and transY when a fit is null
<span class="nc" id="L2862">        float maxRot = Float.MIN_VALUE;</span>
<span class="nc" id="L2863">        float maxTransX = Float.MIN_VALUE;</span>
<span class="nc" id="L2864">        float maxTransY = Float.MIN_VALUE;</span>
<span class="nc bnc" id="L2865" title="All 2 branches missed.">        for (int i = 0; i &lt; fits.length; ++i) {</span>
<span class="nc" id="L2866">            TransformationPointFit fit = fits[i];</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">            if (fit != null) {</span>
<span class="nc bnc" id="L2868" title="All 2 branches missed.">                if (fit.getParameters().getRotationInDegrees() &gt; maxRot) {</span>
<span class="nc" id="L2869">                    maxRot = fit.getParameters().getRotationInDegrees();</span>
                }
<span class="nc bnc" id="L2871" title="All 2 branches missed.">                if (fit.getParameters().getTranslationX() &gt; maxTransX) {</span>
<span class="nc" id="L2872">                    maxTransX = fit.getParameters().getTranslationX();</span>
                }
<span class="nc bnc" id="L2874" title="All 2 branches missed.">                if (fit.getParameters().getTranslationY() &gt; maxTransY) {</span>
<span class="nc" id="L2875">                    maxTransY = fit.getParameters().getTranslationY();</span>
                }
            }
        }

        try {
<span class="nc bnc" id="L2881" title="All 2 branches missed.">            if (simplexCSVFileWriter == null) {</span>
<span class="nc" id="L2882">                String testDirPath = ResourceFinder.findOutputTestDirectory();</span>
<span class="nc" id="L2883">                String fileName = &quot;simplex_&quot; + MiscDebug.getCurrentTimeFormatted() + &quot;.csv&quot;;</span>
<span class="nc" id="L2884">                String filePath = testDirPath</span>
<span class="nc" id="L2885">                    + System.getProperty(&quot;file.separator&quot;) + fileName;</span>
<span class="nc" id="L2886">                File file = new File(filePath);</span>
<span class="nc" id="L2887">                simplexCSVFileW = new FileWriter(file);</span>
<span class="nc" id="L2888">                simplexCSVFileWriter = new BufferedWriter(simplexCSVFileW);</span>
            }

<span class="nc bnc" id="L2891" title="All 2 branches missed.">            for (TransformationPointFit fit : fits) {</span>

<span class="nc" id="L2893">                StringBuilder sb = new StringBuilder();</span>

                float rot, tx, ty;

<span class="nc bnc" id="L2897" title="All 2 branches missed.">                if (fit == null) {</span>
<span class="nc" id="L2898">                    rot = maxRot;</span>
<span class="nc" id="L2899">                    tx = maxTransX;</span>
<span class="nc" id="L2900">                    ty = maxTransY;</span>
                } else {
<span class="nc" id="L2902">                    rot = fit.getParameters().getRotationInDegrees();</span>
<span class="nc" id="L2903">                    tx = fit.getTranslationX();</span>
<span class="nc" id="L2904">                    ty = fit.getTranslationY();</span>
                }
<span class="nc" id="L2906">                sb.append(Float.toString(rot)).append(&quot;,&quot;)</span>
<span class="nc" id="L2907">                    .append(Float.toString(tx)).append(&quot;,&quot;)</span>
<span class="nc" id="L2908">                    .append(Float.toString(ty)).append(&quot;\n&quot;);</span>

<span class="nc" id="L2910">                String str = sb.toString();</span>

<span class="nc" id="L2912">                simplexCSVFileWriter.write(str, 0, str.length());</span>
            }
<span class="nc" id="L2914">            simplexCSVFileWriter.flush();</span>

<span class="nc bnc" id="L2916" title="All 2 branches missed.">            if (closeFile) {</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">                if (simplexCSVFileW != null) {</span>
<span class="nc" id="L2918">                    simplexCSVFileW.close();</span>
<span class="nc" id="L2919">                    simplexCSVFileW = null;</span>
                }
<span class="nc bnc" id="L2921" title="All 2 branches missed.">                if (simplexCSVFileWriter != null) {</span>
<span class="nc" id="L2922">                    simplexCSVFileWriter.close();</span>
<span class="nc" id="L2923">                    simplexCSVFileWriter = null;</span>
                }
            }

<span class="nc" id="L2927">        } catch (IOException e) {</span>
<span class="nc" id="L2928">            log.severe(e.getMessage());</span>
<span class="nc" id="L2929">        }</span>
<span class="nc" id="L2930">    }</span>

    private void writeTranslationSimplexPlot() {

<span class="nc bnc" id="L2934" title="All 2 branches missed.">        if (plotter == null) {</span>
<span class="nc" id="L2935">            return;</span>
        }

        try {
<span class="nc" id="L2939">            plotter.writeFile(MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L2940">        } catch (IOException e) {</span>
<span class="nc" id="L2941">            log.severe(e.getMessage());</span>
<span class="nc" id="L2942">        }</span>

<span class="nc" id="L2944">    }</span>

    /**
     * method to narrow down all parameter space to 10 fits in which at least
     * one contains a fit within +- 10 degrees of rotation and +- 20 pixels
     * of translation in x and y.  Note, still testing so these numbers
     * may change.
     * The 10 fits should be followed by a downhill simplex to further
     * constrain the transformation, or a detailed grid search of each of
     * the 10 fits with something like a delta rotation of 2 and delta
     * translation of 4 and ranges based on the error stated in the first
     * sentence.
     *
     * @param set1
     * @param set2
     * @param scale
     * @param useGreedyMatching if true, uses an N^2 algorithm to find the
     * best match made for each point in order of points in set1, else uses
     * an ~N^3 optimal bipartite matching algorithm.
     * @return
     */
    protected TransformationPointFit[] preSearch0(
        PairIntArray set1, PairIntArray set2, float scale,
        float startRotationInDegrees, float stopRotationInDegrees,
        boolean useGreedyMatching) {

<span class="nc bnc" id="L2970" title="All 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L2971">            return null;</span>
        }
<span class="nc bnc" id="L2973" title="All 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L2974">            return null;</span>
        }

<span class="nc" id="L2977">        int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>

<span class="nc" id="L2979">        TransformationPointFit[] fits = null;</span>

        // if number of points is very high, need to use alternate method
        if (false &amp;&amp; (nMaxMatchable &gt; largeSearchLimit)) {
            fits = preSearch0Large(set1, set2, scale, startRotationInDegrees,
                stopRotationInDegrees, useGreedyMatching);
        } else {
<span class="nc" id="L2986">            fits = preSearch0Small(set1, set2, scale, startRotationInDegrees,</span>
                stopRotationInDegrees, useGreedyMatching);
        }

<span class="nc" id="L2990">        return fits;</span>
    }

    /**
     * method to narrow down all parameter space to 10 fits in which at least
     * one contains a fit within +- 10 degrees of rotation and +- 20 pixels
     * of translation in x and y.  Note, still testing so these numbers
     * may change.
     * The 10 fits should be followed by a downhill simplex to further
     * constrain the transformation, or a detailed grid search of each of
     * the 10 fits with something like a delta rotation of 2 and delta
     * translation of 4 and ranges based on the error stated in the first
     * sentence.
     *
     * @param set1
     * @param set2
     * @param scale
     * @param useGreedyMatching if true, uses an N^2 algorithm to find the
     * best match made for each point in order of points in set1, else uses
     * an ~N^3 optimal bipartite matching algorithm.
     * @return
     */
    protected TransformationPointFit[] preSearch0Small(
        PairIntArray set1, PairIntArray set2, float scale,
        float rotationStartInDegrees, float rotationStopInDegrees,
        boolean useGreedyMatching) {

<span class="nc bnc" id="L3017" title="All 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L3018">            return null;</span>
        }
<span class="nc bnc" id="L3020" title="All 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L3021">            return null;</span>
        }

<span class="nc" id="L3024">        int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>

        /*
        The best solutions use a fine grid search of rotDelta=2 and transDelta=4
        w/ translation tolerance = transDelta.

        Such a solution takes a long time so a coarser grid is attempted here.

        Trying a fine grid in rotation and a very coarse grid in translation
        to get rotation accurate, then a finer search on translation near
        that found rotation.
        */

        /*
        editing this while testing:

        rotDelta=1 and transDelta of 100 has a smallest delta rot within the
            10 best fits which is accurate within += 20 degrees?

        rotDelta=2 and transDelta of 100 has a smallest delta rot
            within the 10 best fits which is accurate within += 25 degrees... 14, 5
            and within the best fit alone, is accurate within

        */

<span class="nc" id="L3049">        float tolTransX = 0.5f*transDeltaPreSearch0 +</span>
<span class="nc" id="L3050">            (float)(Math.sin(rotDeltaPreSearch0*Math.PI/180.)*transDeltaPreSearch0);</span>
<span class="nc" id="L3051">        float tolTransY = tolTransX;</span>

<span class="nc bnc" id="L3053" title="All 2 branches missed.">        if (tolTransX &lt; minTolerance) {</span>
<span class="nc" id="L3054">            tolTransX = minTolerance;</span>
        }
<span class="nc bnc" id="L3056" title="All 2 branches missed.">        if (tolTransY &lt; minTolerance) {</span>
<span class="nc" id="L3057">            tolTransY = minTolerance;</span>
        }

<span class="nc" id="L3060">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L3062">        float[] rotation = MiscMath.writeDegreeIntervals(rotationStartInDegrees,</span>
            rotationStopInDegrees, rotDeltaPreSearch0);

<span class="nc" id="L3065">        int nKeep = 10;</span>

<span class="nc" id="L3067">        long t0 = System.currentTimeMillis();</span>
<span class="nc" id="L3068">        log.info(&quot;starterPoints.length=&quot; + nKeep);</span>

<span class="nc" id="L3070">        int minX2 = MiscMath.findMin(set2.getX(), set2.getN());</span>
<span class="nc" id="L3071">        int maxX2 = MiscMath.findMax(set2.getX(), set2.getN());</span>
<span class="nc" id="L3072">        int minY2 = MiscMath.findMin(set2.getY(), set2.getN());</span>
<span class="nc" id="L3073">        int maxY2 = MiscMath.findMax(set2.getY(), set2.getN());</span>

<span class="nc" id="L3075">        FixedSizeSortedVector&lt;TransformationPointFit&gt; starterPoints</span>
            = new FixedSizeSortedVector&lt;&gt;(nKeep, TransformationPointFit.class);

<span class="nc" id="L3078">        float[] xsr = new float[set1.getN()];</span>
<span class="nc" id="L3079">        float[] ysr = new float[set1.getN()];</span>

<span class="nc bnc" id="L3081" title="All 2 branches missed.">        for (float rotDeg : rotation) {</span>

<span class="nc" id="L3083">            TransformationParameters rotScaleParams =</span>
                new TransformationParameters();
<span class="nc" id="L3085">            rotScaleParams.setScale(scale);</span>
<span class="nc" id="L3086">            rotScaleParams.setRotationInDegrees(rotDeg);</span>
<span class="nc" id="L3087">            rotScaleParams.setTranslationX(0);</span>
<span class="nc" id="L3088">            rotScaleParams.setTranslationY(0);</span>
<span class="nc" id="L3089">            rotScaleParams.setOriginX(0);</span>
<span class="nc" id="L3090">            rotScaleParams.setOriginY(0);</span>

<span class="nc" id="L3092">            transformer.applyTransformation(rotScaleParams, set1, xsr, ysr);</span>

<span class="nc" id="L3094">            final float minX1 = MiscMath.findMin(xsr);</span>
<span class="nc" id="L3095">            final float maxX1 = MiscMath.findMax(xsr);</span>
<span class="nc" id="L3096">            final float minY1 = MiscMath.findMin(ysr);</span>
<span class="nc" id="L3097">            final float maxY1 = MiscMath.findMax(ysr);</span>

<span class="nc" id="L3099">            float transXStart = minX1 - maxX2;</span>
<span class="nc" id="L3100">            float transXStop = maxX1 - minX2;</span>
<span class="nc" id="L3101">            float transYStart = minY1 - maxY2;</span>
<span class="nc" id="L3102">            float transYStop = maxY1 - minY2;</span>

<span class="nc" id="L3104">            float transXRange = transXStop - transXStart;</span>
<span class="nc" id="L3105">            float transYRange = transYStop - transYStart;</span>

<span class="nc" id="L3107">            int nX = (int) Math.ceil(transXRange / transDeltaPreSearch0);</span>
<span class="nc" id="L3108">            int nY = (int) Math.ceil(transYRange / transDeltaPreSearch0);</span>

<span class="nc" id="L3110">            float[] txS = new float[nX];</span>
<span class="nc" id="L3111">            txS[0] = transXStart;</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">            for (int i = 1; i &lt; nX; ++i) {</span>
<span class="nc" id="L3113">                txS[i] = txS[i - 1] + transDeltaPreSearch0;</span>
            }
<span class="nc" id="L3115">            float[] tyS = new float[nY];</span>
<span class="nc" id="L3116">            tyS[0] = transYStart;</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">            for (int i = 1; i &lt; nY; ++i) {</span>
<span class="nc" id="L3118">                tyS[i] = tyS[i - 1] + transDeltaPreSearch0;</span>
            }

<span class="nc bnc" id="L3121" title="All 2 branches missed.">            for (float tx : txS) {</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">                for (float ty : tyS) {</span>

<span class="nc" id="L3124">                    PairFloatArray allPoints1Tr = new PairFloatArray(set1.getN());</span>

<span class="nc bnc" id="L3126" title="All 2 branches missed.">                    for (int i = 0; i &lt; xsr.length; ++i) {</span>
<span class="nc" id="L3127">                        allPoints1Tr.add(xsr[i] + tx, ysr[i] + ty);</span>
                    }

<span class="nc" id="L3130">                    TransformationParameters params = rotScaleParams.copy();</span>
<span class="nc" id="L3131">                    params.setTranslationX(tx);</span>
<span class="nc" id="L3132">                    params.setTranslationY(ty);</span>

                    TransformationPointFit fit2;
<span class="nc bnc" id="L3135" title="All 2 branches missed.">                    if (useGreedyMatching) {</span>
<span class="nc" id="L3136">                        fit2 = evaluateFitForUnMatchedTransformedGreedy(params,</span>
                            allPoints1Tr, set2, tolTransX, tolTransY);
                    } else {
<span class="nc" id="L3139">                        fit2 = evaluateFitForUnMatchedTransformedOptimal(params,</span>
                            allPoints1Tr, set2, tolTransX, tolTransY);
                    }

<span class="nc" id="L3143">                    starterPoints.add(fit2);</span>
                }
            }
        }

<span class="nc bnc" id="L3148" title="All 2 branches missed.">        if (starterPoints.getArray()[0] == null) {</span>
<span class="nc" id="L3149">            return null;</span>
        }

<span class="nc" id="L3152">        long tm = System.currentTimeMillis() - t0;</span>
<span class="nc" id="L3153">        double ts = tm * 1e-3;</span>
<span class="nc" id="L3154">        log.info(&quot;starterPoints finished for nMaxMatchable=&quot; + nMaxMatchable +</span>
            &quot; seconds=&quot; + ts);

<span class="nc bnc" id="L3157" title="All 2 branches missed.">        if (starterPoints.getNumberOfItems() &gt; 0) {</span>
<span class="nc" id="L3158">            log.info(&quot;best of starter points=&quot; + starterPoints.getArray()[0].toString());</span>
        }

<span class="nc" id="L3161">        return starterPoints.getArray();</span>
    }

    protected TransformationPointFit[]
    refineTransformationWithDownhillSimplexWrapper(TransformationPointFit[] fits,
        PairIntArray set1, PairIntArray set2, boolean searchScaleToo,
        boolean useGreedyMatching) {

<span class="pc bpc" id="L3169" title="1 of 2 branches missed.">        if (fits == null) {</span>
<span class="nc" id="L3170">            throw new IllegalArgumentException(&quot;fits cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L3172" title="2 of 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L3173">            return null;</span>
        }
<span class="pc bpc" id="L3175" title="2 of 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L3176">            return null;</span>
        }

<span class="fc" id="L3179">        float centerTransX = 0;</span>
<span class="fc" id="L3180">        float centerTransY = 0;</span>
<span class="fc" id="L3181">        float minTransX = Float.MAX_VALUE;</span>
<span class="fc" id="L3182">        float minTransY = Float.MAX_VALUE;</span>
<span class="fc" id="L3183">        float maxTransX = Float.MIN_VALUE;</span>
<span class="fc" id="L3184">        float maxTransY = Float.MIN_VALUE;</span>
<span class="fc" id="L3185">        float maxTolTransX = Float.MIN_VALUE;;</span>
<span class="fc" id="L3186">        float maxTolTransY = Float.MIN_VALUE;</span>
<span class="fc" id="L3187">        int count = 0;</span>
<span class="fc bfc" id="L3188" title="All 2 branches covered.">        for (TransformationPointFit fit : fits) {</span>
<span class="pc bpc" id="L3189" title="1 of 2 branches missed.">            if (fit == null) {</span>
<span class="nc" id="L3190">                continue;</span>
            }
<span class="fc" id="L3192">            float tx = fit.getTranslationX();</span>
<span class="fc" id="L3193">            float ty = fit.getTranslationY();</span>
<span class="fc" id="L3194">            float tolX = fit.getTranslationXTolerance();</span>
<span class="fc" id="L3195">            float tolY = fit.getTranslationYTolerance();</span>

<span class="fc" id="L3197">            centerTransX += tx;</span>
<span class="fc" id="L3198">            centerTransY += ty;</span>

<span class="fc bfc" id="L3200" title="All 2 branches covered.">            if (tx &lt; minTransX) {</span>
<span class="fc" id="L3201">                minTransX = tx;</span>
            }
<span class="fc bfc" id="L3203" title="All 2 branches covered.">            if (ty &lt; minTransY) {</span>
<span class="fc" id="L3204">                minTransY = ty;</span>
            }
<span class="fc bfc" id="L3206" title="All 2 branches covered.">            if (tx &gt; maxTransX) {</span>
<span class="fc" id="L3207">                maxTransX = tx;</span>
            }
<span class="fc bfc" id="L3209" title="All 2 branches covered.">            if (ty &gt; maxTransY) {</span>
<span class="fc" id="L3210">                maxTransY = ty;</span>
            }
<span class="fc bfc" id="L3212" title="All 2 branches covered.">            if (tolX &gt; maxTolTransX) {</span>
<span class="fc" id="L3213">                maxTolTransX = tolX;</span>
            }
<span class="fc bfc" id="L3215" title="All 2 branches covered.">            if (tolY &gt; maxTolTransY) {</span>
<span class="fc" id="L3216">                maxTolTransY = tolY;</span>
            }

<span class="fc" id="L3219">            count++;</span>
        }
<span class="fc" id="L3221">        centerTransX /= (float)count;</span>
<span class="fc" id="L3222">        centerTransY /= (float)count;</span>
<span class="fc" id="L3223">        float transXHalfRange = Math.abs(maxTransX - minTransX)/2.f;</span>
<span class="fc" id="L3224">        transXHalfRange += this.transDeltaPreSearch0;</span>
<span class="fc" id="L3225">        float transYHalfRange = Math.abs(maxTransY - minTransY)/2.f;</span>
<span class="fc" id="L3226">        transYHalfRange += this.transDeltaPreSearch0;</span>

<span class="fc" id="L3228">        TransformationPointFit[] fits2 = refineTransformationWithDownhillSimplex(</span>
            fits, set1, set2,
            centerTransX, centerTransY, maxTolTransX, maxTolTransY,
            transXHalfRange, transYHalfRange,
            searchScaleToo, useGreedyMatching, false, 50);

<span class="fc" id="L3234">        return fits2;</span>
    }

    /**
     * method to narrow down all parameter space to a fit that is within
     * +- 20 degrees in rotation and +- 50 pixels in translation in X and Y
     * of the true Euclidean transformation.
     * Note, these numbers are being learned in testing right now so may
     * change.
     *
     * @param set1
     * @param set2
     * @param scale
     * @param useGreedyMatching
     * @return
     */
    protected TransformationPointFit preSearch(PairIntArray set1,
        PairIntArray set2, float scale, boolean useGreedyMatching) {

<span class="nc bnc" id="L3253" title="All 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L3254">            return null;</span>
        }
<span class="nc bnc" id="L3256" title="All 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L3257">            return null;</span>
        }

<span class="nc" id="L3260">        float startRotationInDegrees = 0;</span>
<span class="nc" id="L3261">        float stopRotationInDegrees = 359;</span>

<span class="nc" id="L3263">        return preSearch(set1, set2, scale, startRotationInDegrees,</span>
            stopRotationInDegrees, useGreedyMatching);
    }

    /**
     * method to narrow down all parameter space to a fit that is within
     * +- 20 degrees in rotation and +- 50 pixels in translation in X and Y
     * of the true Euclidean transformation.
     * Note, these numbers are being learned in testing right now so may
     * change.
     *
     * @param set1
     * @param set2
     * @param scale
     * @param startRotationInDegrees
     * @param useGreedyMatching
     * @param stopRotationInDegrees
     * @return
     */
    protected TransformationPointFit preSearch(PairIntArray set1,
        PairIntArray set2, float scale, float startRotationInDegrees,
        float stopRotationInDegrees, boolean useGreedyMatching) {

<span class="nc bnc" id="L3286" title="All 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L3287">            return null;</span>
        }
<span class="nc bnc" id="L3289" title="All 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L3290">            return null;</span>
        }

<span class="nc" id="L3293">        TransformationPointFit[] starterPoints = preSearch0(set1, set2, scale,</span>
            startRotationInDegrees, stopRotationInDegrees,
            useGreedyMatching);

<span class="nc bnc" id="L3297" title="All 2 branches missed.">        if (starterPoints == null) {</span>
<span class="nc" id="L3298">            return null;</span>
        }

<span class="nc" id="L3301">        boolean searchScaleToo = false;</span>

<span class="nc" id="L3303">        TransformationPointFit[] fits2 =</span>
<span class="nc" id="L3304">            refineTransformationWithDownhillSimplexWrapper(starterPoints,</span>
            set1, set2, searchScaleToo, useGreedyMatching);

<span class="nc bnc" id="L3307" title="All 4 branches missed.">        if (fits2 == null || fits2[0] == null) {</span>
<span class="nc" id="L3308">            return null;</span>
        }

<span class="nc" id="L3311">        TransformationPointFit bestFit = fits2[0];</span>
        /*
        TransformationPointFit fit2 = refineAfterCalculationWithPairs(
            bestFit.getParameters().copy(), set1, set2, useGreedyMatching);

        if (fitIsBetter(bestFit, fit2)) {
            bestFit = fit2;
        }
        */
<span class="nc" id="L3320">        return bestFit;</span>
    }

    protected TransformationPointFit[] boundedGridSearch(
        PairIntArray set1, PairIntArray set2,
        final TransformationParameters params,
        float scaleHalfRange, float scaleDelta,
        float rotHalfRangeInDegrees, float rotDeltaInDegrees,
        float transXHalfRange, float transXDelta,
        float transYHalfRange, float transYDelta,
        boolean useGreedyMatching) {

<span class="pc bpc" id="L3332" title="2 of 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L3333">            return null;</span>
        }
<span class="pc bpc" id="L3335" title="2 of 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L3336">            return null;</span>
        }

<span class="fc" id="L3339">        int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>

<span class="fc" id="L3341">        float tolTransX = 0.5f*transXDelta + (float)(Math.sin(rotDeltaInDegrees*Math.PI/180.)*transXDelta);</span>
<span class="fc" id="L3342">        float tolTransY = 0.5f*transYDelta + (float)(Math.sin(rotDeltaInDegrees*Math.PI/180.)*transYDelta);</span>

<span class="fc bfc" id="L3344" title="All 2 branches covered.">        if (tolTransX &lt; minTolerance) {</span>
<span class="fc" id="L3345">            tolTransX = generalTolerance;//minTolerance;</span>
        }
<span class="fc bfc" id="L3347" title="All 2 branches covered.">        if (tolTransY &lt; minTolerance) {</span>
<span class="fc" id="L3348">            tolTransY = generalTolerance;//minTolerance;</span>
        }

<span class="fc" id="L3351">        Transformer transformer = new Transformer();</span>

<span class="fc" id="L3353">        float[] rotation = MiscMath.writeDegreeIntervals(</span>
<span class="fc" id="L3354">            params.getRotationInDegrees() - rotHalfRangeInDegrees,</span>
<span class="fc" id="L3355">            params.getRotationInDegrees() + rotHalfRangeInDegrees,</span>
            rotDeltaInDegrees);

<span class="fc" id="L3358">        log.fine(&quot;searching rotation: &quot; + Arrays.toString(rotation));</span>

<span class="fc" id="L3360">        int nX = (int) Math.ceil(2*transXHalfRange / transXDelta);</span>
<span class="fc" id="L3361">        int nY = (int) Math.ceil(2*transYHalfRange / transYDelta);</span>
<span class="pc bpc" id="L3362" title="1 of 2 branches missed.">        if (nX == 0) {</span>
<span class="nc" id="L3363">            nX = 1;</span>
        }
<span class="pc bpc" id="L3365" title="1 of 2 branches missed.">        if (nY == 0) {</span>
<span class="nc" id="L3366">            nY = 1;</span>
        }

<span class="fc" id="L3369">        float[] txS = new float[nX];</span>
<span class="fc" id="L3370">        txS[0] = params.getTranslationX() - transXHalfRange;</span>
<span class="fc bfc" id="L3371" title="All 2 branches covered.">        for (int i = 1; i &lt; nX; ++i) {</span>
<span class="fc" id="L3372">            txS[i] = txS[i - 1] + transXDelta;</span>
        }
<span class="fc" id="L3374">        float[] tyS = new float[nY];</span>
<span class="fc" id="L3375">        tyS[0] = params.getTranslationY() - transYHalfRange;</span>
<span class="fc bfc" id="L3376" title="All 2 branches covered.">        for (int i = 1; i &lt; nY; ++i) {</span>
<span class="fc" id="L3377">            tyS[i] = tyS[i - 1] + transYDelta;</span>
        }

<span class="fc" id="L3380">        int nS = (int) Math.ceil(2*scaleHalfRange / scaleDelta);</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">        if (nS == 0) {</span>
<span class="fc" id="L3382">            nS = 1;</span>
        }
<span class="fc" id="L3384">        float[] scales = new float[nS];</span>
<span class="fc" id="L3385">        scales[0] = params.getScale() - scaleHalfRange;</span>
<span class="fc bfc" id="L3386" title="All 2 branches covered.">        for (int i = 1; i &lt; nS; ++i) {</span>
<span class="fc" id="L3387">            scales[i] = scales[i - 1] + scaleDelta;</span>
        }

<span class="fc" id="L3390">        int nKeep = 10;</span>

<span class="fc" id="L3392">        long t0 = System.currentTimeMillis();</span>

<span class="fc" id="L3394">        FixedSizeSortedVector&lt;TransformationPointFit&gt; starterPoints</span>
            = new FixedSizeSortedVector&lt;&gt;(nKeep, TransformationPointFit.class);

        // add the given params so best answer is never worse than that
<span class="pc bpc" id="L3398" title="1 of 2 branches missed.">        if (useGreedyMatching) {</span>
<span class="fc" id="L3399">            PairFloatArray allPoints1Tr = transformer.applyTransformation2(</span>
                params, set1);
<span class="fc" id="L3401">            TransformationPointFit fit =</span>
<span class="fc" id="L3402">                evaluateFitForUnMatchedTransformedGreedy(params,</span>
                allPoints1Tr, set2, tolTransX, tolTransY);
<span class="fc" id="L3404">            starterPoints.add(fit);</span>
<span class="fc" id="L3405">        } else {</span>
<span class="nc" id="L3406">            PairFloatArray allPoints1Tr = transformer.applyTransformation2(</span>
                params, set1);
<span class="nc" id="L3408">            TransformationPointFit fit =</span>
<span class="nc" id="L3409">                evaluateFitForUnMatchedTransformedOptimal(params,</span>
                allPoints1Tr, set2, tolTransX, tolTransY);
<span class="nc" id="L3411">            starterPoints.add(fit);</span>
        }

<span class="fc" id="L3414">        float[] xsr = new float[set1.getN()];</span>
<span class="fc" id="L3415">        float[] ysr = new float[set1.getN()];</span>

<span class="fc bfc" id="L3417" title="All 2 branches covered.">        for (float scale : scales) {</span>
<span class="fc bfc" id="L3418" title="All 2 branches covered.">            for (float rotDeg : rotation) {</span>

<span class="fc" id="L3420">                TransformationParameters rotScaleParams =</span>
                    new TransformationParameters();
<span class="fc" id="L3422">                rotScaleParams.setScale(scale);</span>
<span class="fc" id="L3423">                rotScaleParams.setRotationInDegrees(rotDeg);</span>
<span class="fc" id="L3424">                rotScaleParams.setTranslationX(0);</span>
<span class="fc" id="L3425">                rotScaleParams.setTranslationY(0);</span>
<span class="fc" id="L3426">                rotScaleParams.setOriginX(params.getOriginX());</span>
<span class="fc" id="L3427">                rotScaleParams.setOriginY(params.getOriginY());</span>

<span class="fc" id="L3429">                transformer.applyTransformation(rotScaleParams, set1, xsr, ysr);</span>

<span class="fc bfc" id="L3431" title="All 2 branches covered.">                for (float tx : txS) {</span>
<span class="fc bfc" id="L3432" title="All 2 branches covered.">                    for (float ty : tyS) {</span>

<span class="fc" id="L3434">                        PairFloatArray allPoints1Tr = new PairFloatArray(set1.getN());</span>

<span class="fc bfc" id="L3436" title="All 2 branches covered.">                        for (int i = 0; i &lt; xsr.length; ++i) {</span>
<span class="fc" id="L3437">                            allPoints1Tr.add(xsr[i] + tx, ysr[i] + ty);</span>
                        }

<span class="fc" id="L3440">                        TransformationParameters params2 = rotScaleParams.copy();</span>
<span class="fc" id="L3441">                        params2.setTranslationX(tx);</span>
<span class="fc" id="L3442">                        params2.setTranslationY(ty);</span>

                        TransformationPointFit fit2;
<span class="pc bpc" id="L3445" title="1 of 2 branches missed.">                        if (useGreedyMatching) {</span>
<span class="fc" id="L3446">                            fit2 = evaluateFitForUnMatchedTransformedGreedy(params2,</span>
                                allPoints1Tr, set2, tolTransX, tolTransY);
                        } else {
<span class="nc" id="L3449">                            fit2 = evaluateFitForUnMatchedTransformedOptimal(params2,</span>
                                allPoints1Tr, set2, tolTransX, tolTransY);
                        }

<span class="fc" id="L3453">                        starterPoints.add(fit2);</span>
                    }
                }
            }
        }

<span class="pc bpc" id="L3459" title="1 of 2 branches missed.">        if (starterPoints.getArray()[0] == null) {</span>
<span class="nc" id="L3460">            return null;</span>
        }

<span class="fc" id="L3463">        long tm = System.currentTimeMillis() - t0;</span>
<span class="fc" id="L3464">        double ts = tm * 1e-3;</span>
<span class="fc" id="L3465">        log.fine(&quot;bounded grid search finished for nMaxMatchable=&quot; + nMaxMatchable +</span>
            &quot; seconds=&quot; + ts);

<span class="pc bpc" id="L3468" title="1 of 2 branches missed.">        if (starterPoints.getNumberOfItems() &gt; 0) {</span>
<span class="fc" id="L3469">            log.fine(&quot;best=&quot; + starterPoints.getArray()[0].toString());</span>
        }

<span class="fc" id="L3472">        return starterPoints.getArray();</span>
    }

    /**
     * searches around the given params for a better fit using
     * a grid search and then a downhill simplex with the best 10 grid results
     * as starter points.
     *
     * @param set1
     * @param set2
     * @param params
     * @param rotHalfRangeInDegrees half of the range in rotation to search
     * around params.rotationInDegrees.  the value is added and subtracted
     * from params.rotationInDegrees to create the start and end of the
     * range.
     * @param rotDeltaInDegrees the interval size of rotation in degrees
     * for the search.
     * @param transXHalfRange half of the range in translation in X to search
     * around params.translationX.  the value is added and subtracted
     * from params.translationX to create the start and end of the range.
     * @param transYHalfRange half of the range in translation in Y to search
     * around params.translationY.  the value is added and subtracted
     * from params.translationY to create the start and end of the range.
     * @param transYDelta the interval size in translation of X for the search
     * @param transXDelta the interval size in translation of Y for the search
     * @param useGreedyMatching if true, uses an N^2 algorithm to find the
     * best match made for each point in order of points in set1, else uses
     * an ~N^3 optimal bipartite matching algorithm.
     * @return
     */
    public TransformationPointFit refineTheTransformation(
        final TransformationParameters params, PairIntArray set1, PairIntArray set2,
        float rotHalfRangeInDegrees, float rotDeltaInDegrees,
        float transXHalfRange, float transXDelta,
        float transYHalfRange, float transYDelta,
        boolean useGreedyMatching) {

<span class="pc bpc" id="L3509" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L3510">            throw new IllegalArgumentException(&quot;params cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L3512" title="1 of 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L3513">            throw new IllegalArgumentException(&quot;set1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L3515" title="1 of 2 branches missed.">        if (set2 == null) {</span>
<span class="nc" id="L3516">            throw new IllegalArgumentException(&quot;set2 cannot be null&quot;);</span>
        }

<span class="fc" id="L3519">        float scaleHalfRange = 0;</span>
<span class="fc" id="L3520">        float scaleDelta = 1;</span>

<span class="fc" id="L3522">        TransformationPointFit[] fits = boundedGridSearch(</span>
            set1, set2, params,
            scaleHalfRange, scaleDelta,
            rotHalfRangeInDegrees, rotDeltaInDegrees,
            transXHalfRange, transXDelta,
            transYHalfRange, transYDelta, useGreedyMatching);

<span class="pc bpc" id="L3529" title="1 of 2 branches missed.">        if (fits == null) {</span>
<span class="nc" id="L3530">            return null;</span>
        }

<span class="fc" id="L3533">        int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>

<span class="fc bfc" id="L3535" title="All 2 branches covered.">        if (hasConverged(fits[0], nMaxMatchable)) {</span>
<span class="fc" id="L3536">            return fits[0];</span>
        }

        // finest grid so no need for downhill simplex search
<span class="pc bpc" id="L3540" title="5 of 6 branches missed.">        if ((rotDeltaInDegrees == 1) &amp;&amp; (transXDelta == 1) &amp;&amp; (transYDelta == 1)) {</span>
<span class="nc" id="L3541">            return fits[0];</span>
        }

<span class="fc" id="L3544">        boolean searchScaleToo = false;</span>

<span class="fc" id="L3546">        TransformationPointFit[] fits2 =</span>
<span class="fc" id="L3547">            refineTransformationWithDownhillSimplexWrapper(fits, set1, set2,</span>
            searchScaleToo, useGreedyMatching);

<span class="pc bpc" id="L3550" title="2 of 4 branches missed.">        if ((fits2 == null) || (fits2.length == 0)) {</span>
<span class="nc" id="L3551">            return null;</span>
        }

<span class="fc" id="L3554">        TransformationPointFit fit2 = fits2[0];</span>

<span class="pc bpc" id="L3556" title="1 of 2 branches missed.">        if (hasConverged(fit2, nMaxMatchable)) {</span>
<span class="nc" id="L3557">            return fit2;</span>
        }

        // one last refinement
<span class="fc" id="L3561">        scaleHalfRange = 0;</span>
<span class="fc" id="L3562">        scaleDelta = 1;</span>
<span class="fc" id="L3563">        rotHalfRangeInDegrees = 5;</span>
<span class="fc" id="L3564">        rotDeltaInDegrees = 1;</span>
<span class="fc" id="L3565">        transXHalfRange = 20;</span>
<span class="fc" id="L3566">        transYHalfRange = transXHalfRange;</span>
<span class="fc" id="L3567">        transXDelta = 1;</span>
<span class="fc" id="L3568">        transYDelta = transXDelta;</span>

<span class="fc" id="L3570">        TransformationPointFit[] fits3 = boundedGridSearch(</span>
<span class="fc" id="L3571">            set1, set2, fit2.getParameters(),</span>
            scaleHalfRange, scaleDelta,
            rotHalfRangeInDegrees, rotDeltaInDegrees,
            transXHalfRange, transXDelta,
            transYHalfRange, transYDelta, useGreedyMatching);

<span class="pc bpc" id="L3577" title="2 of 4 branches missed.">        if ((fits3 == null) || (fits3.length == 0)) {</span>
<span class="nc" id="L3578">            return null;</span>
        }

<span class="fc" id="L3581">        return fits3[0];</span>
    }

    /**
     * use a downhill simplex algorithm to search for a better fit to the data
     * given the starterPoints.  This method changes
     * scale, rotation, translation in X, and translation in Y.
     *
     * @param set1
     * @param set2
     * @param params
     * @param scaleHalfRange half of the range in scale to search
     * around params.scale.  the value is added and subtracted
     * from params.scale to create the start and end of the
     * range.
     * @param scaleDelta the interval size of scale for the search.
     * @param rotHalfRangeInDegrees half of the range in rotation to search
     * around params.rotationInDegrees.  the value is added and subtracted
     * from params.rotationInDegrees to create the start and end of the
     * range.
     * @param rotDeltaInDegrees the interval size of rotation in degrees
     * for the search.
     * @param transXHalfRange half of the range in translation in X to search
     * around params.translationX.  the value is added and subtracted
     * from params.translationX to create the start and end of the range.
     * @param transYHalfRange half of the range in translation in Y to search
     * around params.translationY.  the value is added and subtracted
     * from params.translationY to create the start and end of the range.
     * @param transYDelta the interval size in translation of X for the search
     * @param transXDelta the interval size in translation of Y for the search
     * @param useGreedyMatching if true, uses an N^2 algorithm to find the
     * best match made for each point in order of points in set1, else uses
     * an ~N^3 optimal bipartite matching algorithm.
     * @return
     */
    public TransformationPointFit refineTheTransformation(
        TransformationParameters params, PairIntArray set1, PairIntArray set2,
        float scaleHalfRange, float scaleDelta,
        float rotHalfRangeInDegrees, float rotDeltaInDegrees,
        float transXHalfRange, float transXDelta,
        float transYHalfRange, float transYDelta,
        boolean useGreedyMatching) {

<span class="pc bpc" id="L3624" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L3625">            throw new IllegalArgumentException(&quot;params cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L3627" title="1 of 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L3628">            throw new IllegalArgumentException(&quot;set1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L3630" title="1 of 2 branches missed.">        if (set2 == null) {</span>
<span class="nc" id="L3631">            throw new IllegalArgumentException(&quot;set2 cannot be null&quot;);</span>
        }

<span class="fc" id="L3634">        TransformationPointFit[] fits = boundedGridSearch(</span>
            set1, set2, params,
            scaleHalfRange, scaleDelta,
            rotHalfRangeInDegrees, rotDeltaInDegrees,
            transXHalfRange, transXDelta,
            transYHalfRange, transYDelta, useGreedyMatching);

<span class="pc bpc" id="L3641" title="1 of 2 branches missed.">        if (fits == null) {</span>
<span class="nc" id="L3642">            return null;</span>
        }

<span class="fc" id="L3645">        int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>

<span class="fc bfc" id="L3647" title="All 2 branches covered.">        if (hasConverged(fits[0], nMaxMatchable)) {</span>
<span class="fc" id="L3648">            return fits[0];</span>
        }

<span class="fc" id="L3651">        boolean searchScaleToo = true;</span>

<span class="fc" id="L3653">        TransformationPointFit[] fits2 =</span>
<span class="fc" id="L3654">            refineTransformationWithDownhillSimplexWrapper(fits, set1, set2,</span>
            searchScaleToo, useGreedyMatching);

<span class="pc bpc" id="L3657" title="1 of 2 branches missed.">        if (fits2 == null) {</span>
<span class="nc" id="L3658">            return null;</span>
        }

<span class="pc bpc" id="L3661" title="1 of 2 branches missed.">        if (hasConverged(fits2[0], nMaxMatchable)) {</span>
<span class="fc" id="L3662">            return fits2[0];</span>
        }

        // TODO: may need a small fine grid search here

<span class="nc" id="L3667">        return fits2[0];</span>

    }

    /**
     * for use when the number of data points is too high for reasonably
     * fast solution using preSearch0.
     * The method randomly reduces set1 to a smaller number of point sets
     * and finds the best solution among those.
     * @param set1
     * @param set2
     * @param scale
     * @param useGreedyMatch
     * @return
     */
    protected TransformationPointFit[] preSearch0Large(PairIntArray set1,
        PairIntArray set2, float scale,
        float startRotationInDegrees, float stopRotationInDegrees,
        boolean useGreedyMatch) {

<span class="nc bnc" id="L3687" title="All 4 branches missed.">        if ((set1 == null) || (set2 == null)) {</span>
<span class="nc" id="L3688">            return null;</span>
        }
<span class="nc bnc" id="L3690" title="All 4 branches missed.">        if ((set1.getN() &lt; 3) || (set2.getN() &lt; 3)) {</span>
<span class="nc" id="L3691">            return null;</span>
        }

<span class="nc" id="L3694">        PointPartitioner partitioner = new PointPartitioner();</span>

<span class="nc" id="L3696">        PairIntArray[] set1Subsets = null;</span>
<span class="nc bnc" id="L3697" title="All 2 branches missed.">        if (set1.getN() &lt; 100) {</span>
<span class="nc" id="L3698">            set1Subsets = new PairIntArray[]{set1};</span>
        } else {
<span class="nc" id="L3700">            set1Subsets = partitioner.reduceByBinSampling(set1, 5, 4);</span>
            //set1Subsets = partitioner.reduceByBinSampling(set1, 10, 2);
            //set1Subsets = partitioner.reduceByBinSampling(set1, 5, 2);

<span class="nc" id="L3704">            set1Subsets = new PairIntArray[]{set1Subsets[0]};</span>
        }

<span class="nc" id="L3707">        boolean useGreedyMatching = true;</span>

<span class="nc bnc" id="L3709" title="All 2 branches missed.">        for (PairIntArray set1Subset : set1Subsets) {</span>

<span class="nc" id="L3711">            TransformationPointFit[] fits = preSearch0Small(set1Subset, set2,</span>
                scale, startRotationInDegrees,
                stopRotationInDegrees, useGreedyMatching);

<span class="nc" id="L3715">            return fits;</span>
        }

<span class="nc" id="L3718">        return null;</span>
    }

    /**
     Calculate the best transformation solution by matching pairs of points
     * in set1 with pairs of points in set2.
     *
     * Note that set1 and set2 should have fewer than __ members each
     * in order to use this method and get results reasonably fast.
     *
     * The number of ways to make pairs in set 1 times the number of ways to make
       pairs in set 2 =
             n_1!            n_2!
         ------------  X  ------------
         2*(n_1 - 2)!     2*(n_2 - 2)!

    After points are matched:
       Estimating scale:
           Take 2 pairs of points in both datasets and compute the distance
           between them and then take the ratio:

           scale = (distance between pair in set 1)
                   / (distance between pair in set 2)

           Note: scale is roughly determined from contour matching too in the
              inflection matcher.

       Estimating rotation:
           Take the same 2 pairs and determine the difference in their angles:
               tan(theta) = delta y / delta x

           rotation = atan((delta y between pair in set 1)
                          /(delta x between pair in set 1))
                      -
                      atan((delta y between pair in set 2)
                          /(delta x between pair in set 2))

       Estimate translation:
           Performed on one point in set 1 with its candidate match in set 2:
           From the full transformation equation, we can rewrite:
               transX = xt0 - xc*scale -
                   (((x0-xc)*scale*math.cos(theta)) + ((y0-yc)*scale*math.sin(theta)))

               transY = yt0 - yc*scale -
                    ((-(x0-xc)*scale*math.sin(theta)) + ((y0-yc)*scale*math.cos(theta)))

               where (xc, yc) is the center of the first image
               *
    * Note that if the solution converges, it will return before trying all
    * subset combinations.
    */
    protected List&lt;TransformationPointFit&gt;
    calculateEuclideanTransformationUsingPairs(
        PairIntArray set1, PairIntArray set2, boolean earlyConvergeReturn) {

<span class="fc" id="L3773">        boolean useLargestToleranceForOutput = true;</span>
<span class="fc" id="L3774">        boolean useGreedyMatching = true;</span>

<span class="fc" id="L3776">        List&lt;TransformationPointFit&gt;  fits = calculateEuclideanTransformationUsingPairs(</span>
            set1, set2, earlyConvergeReturn,
            useLargestToleranceForOutput, useGreedyMatching);

<span class="fc" id="L3780">        return fits;</span>
    }

    protected List&lt;TransformationPointFit&gt;
    calculateEuclideanTransformationForSmallSets(
        PairIntArray set1, PairIntArray set2,
        PairIntArray fullSet1, PairIntArray fullSet2,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

        float toleranceTransX;
        float toleranceTransY;
<span class="nc bnc" id="L3791" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L3792">            toleranceTransX = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L3793">            toleranceTransY = toleranceTransX;</span>
        } else {
<span class="nc" id="L3795">            toleranceTransX = 4;</span>
<span class="nc" id="L3796">            toleranceTransY = 4;</span>
        }

<span class="nc" id="L3799">        long n1P = (set1.getN() * (set1.getN() - 1))/2;</span>

<span class="nc" id="L3801">        return calculateEuclideanTransformationForSmallSets(set1, set2,</span>
            fullSet1, fullSet2, n1P,
            toleranceTransX, toleranceTransY, useGreedyMatching);
    }

    public List&lt;TransformationPointFit&gt;
    calculateEuclideanTransformationForSmallSets(PairIntArray set1,
        PairIntArray set2, PairIntArray fullSet1, PairIntArray fullSet2,
        long n1Iterations,
        float toleranceTransX, float toleranceTransY,
        boolean useGreedyMatching) {

<span class="fc" id="L3813">        int n1 = set1.getN();</span>
<span class="fc" id="L3814">        int n2 = set2.getN();</span>

<span class="fc" id="L3816">        int k = 2;</span>

<span class="fc" id="L3818">        SubsetChooser s1 = new SubsetChooser(n1, k);</span>

<span class="fc" id="L3820">        int[] selected1 = new int[k];</span>
<span class="fc" id="L3821">        int[] selected2 = new int[k];</span>

        /*
        save bestFit for scale near 1,
                   bestFit for scale &gt; 1
                   bestFit for scale &lt; 1
        and normalized for each.
        */
<span class="fc" id="L3829">        TransformationPointFit bestFitScaleGT1 = null;</span>
<span class="fc" id="L3830">        TransformationPointFit bestFitScaleLT1 = null;</span>
<span class="fc" id="L3831">        TransformationPointFit bestFitScale1 = null;</span>
<span class="fc" id="L3832">        TransformationPointFit bestFitNormalizedScaleGT1 = null;</span>
<span class="fc" id="L3833">        TransformationPointFit bestFitNormalizedScaleLT1 = null;</span>
<span class="fc" id="L3834">        TransformationPointFit bestFitNormalizedScale1 = null;</span>

<span class="fc" id="L3836">        int maxNMatchable = Math.min(n1, n2);</span>

<span class="fc" id="L3838">        MatchedPointsTransformationCalculator tc = new</span>
            MatchedPointsTransformationCalculator();

<span class="fc" id="L3841">        TransformationPointFit bestFitNormalized = null;</span>
<span class="fc" id="L3842">        TransformationPointFit bestFit = null;</span>

<span class="fc" id="L3844">        List&lt;TransformationPointFit&gt; similarToBestFitNormalized = new ArrayList&lt;TransformationPointFit&gt;();</span>
<span class="fc" id="L3845">        List&lt;TransformationPointFit&gt; similarToBestFit = new ArrayList&lt;TransformationPointFit&gt;();</span>

<span class="fc" id="L3847">        long n1Count = 0;</span>

<span class="fc bfc" id="L3849" title="All 2 branches covered.">        while (s1.getNextSubset(selected1) != -1) {</span>

<span class="fc bfc" id="L3851" title="All 2 branches covered.">            if (n1Count &gt; n1Iterations) {</span>
<span class="fc" id="L3852">                break;</span>
            }

<span class="fc" id="L3855">            int idx10 = selected1[0];</span>
<span class="fc" id="L3856">            int idx11 = selected1[1];</span>

<span class="fc" id="L3858">            SubsetChooser s2 = new SubsetChooser(n2, k);</span>

            //TODO: could save the calculations for point 1 here

<span class="fc bfc" id="L3862" title="All 2 branches covered.">            while (s2.getNextSubset(selected2) != -1) {</span>

<span class="fc" id="L3864">                int idx20 = selected2[0];</span>
<span class="fc" id="L3865">                int idx21 = selected2[1];</span>

<span class="fc bfc" id="L3867" title="All 2 branches covered.">                for (int order = 0; order &lt; 2; ++order) {</span>

<span class="fc bfc" id="L3869" title="All 2 branches covered.">                    if (order == 1) {</span>
<span class="fc" id="L3870">                        int swap = idx20;</span>
<span class="fc" id="L3871">                        idx20 = idx21;</span>
<span class="fc" id="L3872">                        idx21 = swap;</span>
                    }

<span class="fc" id="L3875">                    TransformationParameters params = tc.calulateEuclidean(</span>
<span class="fc" id="L3876">                        set1.getX(idx10), set1.getY(idx10),</span>
<span class="fc" id="L3877">                        set1.getX(idx11), set1.getY(idx11),</span>
<span class="fc" id="L3878">                        set2.getX(idx20), set2.getY(idx20),</span>
<span class="fc" id="L3879">                        set2.getX(idx21), set2.getY(idx21),</span>
                        0, 0);

<span class="fc" id="L3882">                    TransformationPointFit fit = evaluateForUnmatched(params,</span>
                        fullSet1, fullSet2, toleranceTransX, toleranceTransY,
                        useGreedyMatching);

<span class="pc bpc" id="L3886" title="2 of 4 branches missed.">                    if ((fit == null) || (fit.getNumberOfMatchedPoints() &lt; 2)) {</span>
<span class="nc" id="L3887">                        continue;</span>
                    }

<span class="fc" id="L3890">                    float scale = params.getScale();</span>

<span class="fc bfc" id="L3892" title="All 4 branches covered.">                    if ((scale &gt;= 0.95) &amp;&amp; (scale &lt;= 1.05)) {</span>
<span class="fc bfc" id="L3893" title="All 2 branches covered.">                        if (fitIsBetter(bestFitScale1, fit)) {</span>
<span class="fc" id="L3894">                            bestFitScale1 = fit;</span>
                        }
<span class="fc bfc" id="L3896" title="All 2 branches covered.">                        if (fitIsBetterNormalized(bestFitNormalizedScale1, fit)) {</span>
<span class="fc" id="L3897">                            bestFitNormalizedScale1 = fit;</span>
                        }
<span class="fc bfc" id="L3899" title="All 2 branches covered.">                    } else if (scale &gt; 1.05) {</span>
<span class="fc bfc" id="L3900" title="All 2 branches covered.">                        if (fitIsBetter(bestFitScaleGT1, fit)) {</span>
<span class="fc" id="L3901">                            bestFitScaleGT1 = fit;</span>
                        }
<span class="fc bfc" id="L3903" title="All 2 branches covered.">                        if (fitIsBetterNormalized(bestFitNormalizedScaleGT1, fit)) {</span>
<span class="fc" id="L3904">                            bestFitNormalizedScaleGT1 = fit;</span>
                        }
<span class="pc bpc" id="L3906" title="1 of 2 branches missed.">                    } else if (scale &lt; 0.95) {</span>
<span class="fc bfc" id="L3907" title="All 2 branches covered.">                        if (fitIsBetter(bestFitScaleLT1, fit)) {</span>
<span class="fc" id="L3908">                            bestFitScaleLT1 = fit;</span>
                        }
<span class="fc bfc" id="L3910" title="All 2 branches covered.">                        if (fitIsBetterNormalized(bestFitNormalizedScaleLT1, fit)) {</span>
<span class="fc" id="L3911">                            bestFitNormalizedScaleLT1 = fit;</span>
                        }
                    }

<span class="fc bfc" id="L3915" title="All 2 branches covered.">                    if (fitIsBetterNormalized(bestFitNormalized, fit)) {</span>
<span class="fc bfc" id="L3916" title="All 4 branches covered.">                        if ((bestFitNormalized != null) &amp;&amp; (bestFitNormalized.getMeanDistFromModel() &lt; 1)</span>
<span class="fc bfc" id="L3917" title="All 2 branches covered.">                            &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="fc bfc" id="L3918" title="All 2 branches covered.">                            if (similarToBestFitNormalized.isEmpty()) {</span>
<span class="fc" id="L3919">                                similarToBestFitNormalized.add(bestFitNormalized);</span>
                            }
<span class="fc" id="L3921">                            similarToBestFitNormalized.add(fit);</span>
                        } else {
<span class="fc" id="L3923">                            similarToBestFitNormalized.clear();</span>
                        }
<span class="fc" id="L3925">                        bestFitNormalized = fit;</span>
                    }
<span class="fc bfc" id="L3927" title="All 2 branches covered.">                    if (fitIsBetter(bestFit, fit)) {</span>
<span class="fc bfc" id="L3928" title="All 4 branches covered.">                        if ((bestFit != null) &amp;&amp; (bestFit.getMeanDistFromModel() &lt; 1)</span>
<span class="fc bfc" id="L3929" title="All 2 branches covered.">                            &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="fc bfc" id="L3930" title="All 2 branches covered.">                            if (similarToBestFit.isEmpty()) {</span>
<span class="fc" id="L3931">                                similarToBestFit.add(bestFit);</span>
                            }
<span class="fc" id="L3933">                            similarToBestFit.add(fit);</span>
                        } else {
<span class="fc" id="L3935">                            similarToBestFit.clear();</span>
                        }
<span class="fc" id="L3937">                        bestFit = fit;</span>
                    }
                }
<span class="fc" id="L3940">            }</span>

<span class="fc" id="L3942">            n1Count++;</span>
<span class="fc" id="L3943">        }</span>

<span class="fc" id="L3945">        log.info(&quot;similarToBestFit.size=&quot; + similarToBestFit.size());</span>
<span class="fc bfc" id="L3946" title="All 2 branches covered.">        if (similarToBestFit.size() &gt; 1) {</span>
<span class="fc bfc" id="L3947" title="All 2 branches covered.">            for (TransformationPointFit fit : similarToBestFit) {</span>
<span class="fc" id="L3948">                log.info(&quot;similarFit=&quot; + fit.toString());</span>
<span class="fc" id="L3949">            }</span>
        }
<span class="fc" id="L3951">        log.info(&quot;similarToBestFitNormalized.size=&quot; + similarToBestFitNormalized.size());</span>
<span class="fc bfc" id="L3952" title="All 2 branches covered.">        if (similarToBestFitNormalized.size() &gt; 1) {</span>
<span class="fc bfc" id="L3953" title="All 2 branches covered.">            for (TransformationPointFit fit : similarToBestFitNormalized) {</span>
<span class="fc" id="L3954">                log.info(&quot;similarFit=&quot; + fit.toString());</span>
<span class="fc" id="L3955">            }</span>
<span class="pc bpc" id="L3956" title="2 of 4 branches missed.">        } else if (similarToBestFitNormalized.isEmpty() &amp;&amp; (bestFitNormalized != null)) {</span>
<span class="fc" id="L3957">            log.info(&quot;bestFitNormalized=&quot; + bestFitNormalized.toString());</span>
<span class="fc" id="L3958">            similarToBestFitNormalized.add(bestFitNormalized);</span>
        }
<span class="fc" id="L3960">        log.info(&quot;bestFit(not normalized)=&quot; + bestFit.toString());</span>
<span class="fc" id="L3961">        similarToBestFitNormalized.add(0, bestFit);</span>

<span class="pc bpc" id="L3963" title="1 of 2 branches missed.">        if (bestFitNormalized != null) {</span>
<span class="fc" id="L3964">            log.info(&quot;bestFit(normalized)=&quot; + bestFitNormalized.toString());</span>
        }

<span class="pc bpc" id="L3967" title="1 of 2 branches missed.">        if (bestFitScaleGT1 != null) {</span>
<span class="fc" id="L3968">            log.info(&quot;bestFitScaleGT1=&quot; + bestFitScaleGT1.toString());</span>
<span class="fc" id="L3969">            similarToBestFitNormalized.add(bestFitScaleGT1);</span>
        }

<span class="pc bpc" id="L3972" title="1 of 2 branches missed.">        if (bestFitScaleLT1 != null) {</span>
<span class="fc" id="L3973">            log.info(&quot;bestFitScaleLT1=&quot; + bestFitScaleLT1.toString());</span>
<span class="fc" id="L3974">            similarToBestFitNormalized.add(bestFitScaleLT1);</span>
        }

<span class="pc bpc" id="L3977" title="1 of 2 branches missed.">        if (bestFitScale1 != null) {</span>
<span class="fc" id="L3978">            log.info(&quot;bestFitScale1=&quot; + bestFitScale1.toString());</span>
<span class="fc" id="L3979">            similarToBestFitNormalized.add(bestFitScale1);</span>
        }

<span class="pc bpc" id="L3982" title="1 of 2 branches missed.">        if (bestFitNormalizedScaleGT1 != null) {</span>
<span class="fc" id="L3983">            log.info(&quot;bestFitNormalizedScaleGT1=&quot; + bestFitNormalizedScaleGT1.toString());</span>
<span class="fc" id="L3984">            similarToBestFitNormalized.add(bestFitNormalizedScaleGT1);</span>
        }

<span class="pc bpc" id="L3987" title="1 of 2 branches missed.">        if (bestFitNormalizedScaleLT1 != null) {</span>
<span class="fc" id="L3988">            log.info(&quot;bestFitNormalizedScaleLT1=&quot; + bestFitNormalizedScaleLT1.toString());</span>
<span class="fc" id="L3989">            similarToBestFitNormalized.add(bestFitNormalizedScaleLT1);</span>
        }

<span class="pc bpc" id="L3992" title="1 of 2 branches missed.">        if (bestFitNormalizedScale1 != null) {</span>
<span class="fc" id="L3993">            log.info(&quot;bestFitNormalizedScale1=&quot; + bestFitNormalizedScale1.toString());</span>
<span class="fc" id="L3994">            similarToBestFitNormalized.add(bestFitNormalizedScale1);</span>
        }

<span class="fc" id="L3997">        return similarToBestFitNormalized;</span>
    }

    protected List&lt;TransformationPointFit&gt;
    calculateEuclideanTransformationForSmallSets(
        PairIntArray set1, PairIntArray set2,
        final float scale, final float rotationLowLimitInDegrees,
        final float rotationHighLimitInDegrees,
        boolean earlyConvergeReturn,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

<span class="nc" id="L4008">        int n1 = set1.getN();</span>
<span class="nc" id="L4009">        int n2 = set2.getN();</span>

<span class="nc" id="L4011">        int k = 2;</span>

<span class="nc" id="L4013">        int[] selected1 = new int[k];</span>
<span class="nc" id="L4014">        int[] selected2 = new int[k];</span>

<span class="nc" id="L4016">        int maxNMatchable = Math.min(n1, n2);</span>

<span class="nc" id="L4018">        MatchedPointsTransformationCalculator tc = new</span>
            MatchedPointsTransformationCalculator();
        float toleranceTransX;
        float toleranceTransY;
<span class="nc bnc" id="L4022" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L4023">            toleranceTransX = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L4024">            toleranceTransY = toleranceTransX;</span>
        } else {
<span class="nc" id="L4026">            toleranceTransX = 4;</span>
<span class="nc" id="L4027">            toleranceTransY = 4;</span>
        }

<span class="nc" id="L4030">        float rotRange = AngleUtil.getAngleDifference(rotationLowLimitInDegrees,</span>
            rotationHighLimitInDegrees);

<span class="nc" id="L4033">        TransformationPointFit bestFitNormalized = null;</span>

<span class="nc" id="L4035">        List&lt;TransformationPointFit&gt; similarToBestFitNormalized = new ArrayList&lt;TransformationPointFit&gt;();</span>

<span class="nc" id="L4037">        TransformationPointFit bestFit = null;</span>

<span class="nc" id="L4039">        List&lt;TransformationPointFit&gt; similarToBestFit = new ArrayList&lt;TransformationPointFit&gt;();</span>

<span class="nc" id="L4041">        SubsetChooser s1 = new SubsetChooser(n1, k);</span>

<span class="nc bnc" id="L4043" title="All 2 branches missed.">        while (s1.getNextSubset(selected1) != -1) {</span>

<span class="nc" id="L4045">            int idx10 = selected1[0];</span>
<span class="nc" id="L4046">            int idx11 = selected1[1];</span>

<span class="nc" id="L4048">            SubsetChooser s2 = new SubsetChooser(n2, k);</span>

            //TODO: could save the calculations for point 1 here

<span class="nc bnc" id="L4052" title="All 2 branches missed.">            while (s2.getNextSubset(selected2) != -1) {</span>

<span class="nc" id="L4054">                int idx20 = selected2[0];</span>
<span class="nc" id="L4055">                int idx21 = selected2[1];</span>

<span class="nc bnc" id="L4057" title="All 2 branches missed.">                for (int order = 0; order &lt; 2; ++order) {</span>

<span class="nc bnc" id="L4059" title="All 2 branches missed.">                    if (order == 1) {</span>
<span class="nc" id="L4060">                        int swap = idx20;</span>
<span class="nc" id="L4061">                        idx20 = idx21;</span>
<span class="nc" id="L4062">                        idx21 = swap;</span>
                    }

<span class="nc" id="L4065">                    TransformationParameters params = tc.calulateEuclidean(</span>
<span class="nc" id="L4066">                        set1.getX(idx10), set1.getY(idx10),</span>
<span class="nc" id="L4067">                        set1.getX(idx11), set1.getY(idx11),</span>
<span class="nc" id="L4068">                        set2.getX(idx20), set2.getY(idx20),</span>
<span class="nc" id="L4069">                        set2.getX(idx21), set2.getY(idx21),</span>
                        0, 0);
<span class="nc" id="L4071">                    float rotD = params.getRotationInDegrees();</span>

<span class="nc bnc" id="L4073" title="All 2 branches missed.">                    if (Math.abs(scale - params.getScale()) &gt; 0.05) {</span>
<span class="nc" id="L4074">                        continue;</span>
                    }
<span class="nc bnc" id="L4076" title="All 2 branches missed.">                    if (!</span>
                    (((rotD &gt;= rotationLowLimitInDegrees)
<span class="nc bnc" id="L4078" title="All 4 branches missed.">                      &amp;&amp; (Math.abs(AngleUtil.getAngleDifference(rotD, rotationLowLimitInDegrees)) &lt; rotRange))</span>
                    ||
                    ((rotD &lt;= rotationHighLimitInDegrees)
<span class="nc bnc" id="L4081" title="All 2 branches missed.">                      &amp;&amp; (Math.abs(AngleUtil.getAngleDifference(rotD, rotationHighLimitInDegrees)) &lt; rotRange))</span>
                    )) {
<span class="nc" id="L4083">                        continue;</span>
                    }

<span class="nc" id="L4086">                    TransformationPointFit fit = evaluateForUnmatched(params,</span>
                        set1, set2, toleranceTransX, toleranceTransY,
                        useGreedyMatching);

<span class="nc bnc" id="L4090" title="All 4 branches missed.">                    if ((fit == null) || (fit.getNumberOfMatchedPoints() &lt; 2)) {</span>
<span class="nc" id="L4091">                        continue;</span>
                    }

<span class="nc bnc" id="L4094" title="All 2 branches missed.">                    if (fitIsBetterNormalized(bestFitNormalized, fit)) {</span>
<span class="nc bnc" id="L4095" title="All 4 branches missed.">                        if ((bestFitNormalized != null) &amp;&amp; (bestFitNormalized.getMeanDistFromModel() &lt; 1)</span>
<span class="nc bnc" id="L4096" title="All 2 branches missed.">                            &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="nc bnc" id="L4097" title="All 2 branches missed.">                            if (similarToBestFitNormalized.isEmpty()) {</span>
<span class="nc" id="L4098">                                similarToBestFitNormalized.add(bestFitNormalized);</span>
                            }
<span class="nc" id="L4100">                            similarToBestFitNormalized.add(fit);</span>
                        } else {
<span class="nc" id="L4102">                            similarToBestFitNormalized.clear();</span>
                        }
<span class="nc" id="L4104">                        bestFitNormalized = fit;</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">                        if (earlyConvergeReturn</span>
<span class="nc bnc" id="L4106" title="All 2 branches missed.">                            &amp;&amp; hasConverged(bestFitNormalized, maxNMatchable)) {</span>
<span class="nc bnc" id="L4107" title="All 2 branches missed.">                            if (similarToBestFitNormalized.isEmpty()) {</span>
<span class="nc" id="L4108">                                similarToBestFitNormalized.add(bestFitNormalized);</span>
                            }
<span class="nc" id="L4110">                            return similarToBestFitNormalized;</span>
                        }
                    }
<span class="nc bnc" id="L4113" title="All 2 branches missed.">                    if (fitIsBetter(bestFit, fit)) {</span>
<span class="nc bnc" id="L4114" title="All 4 branches missed.">                        if ((bestFit != null) &amp;&amp; (bestFit.getMeanDistFromModel() &lt; 1)</span>
<span class="nc bnc" id="L4115" title="All 2 branches missed.">                            &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="nc bnc" id="L4116" title="All 2 branches missed.">                            if (similarToBestFit.isEmpty()) {</span>
<span class="nc" id="L4117">                                similarToBestFit.add(bestFit);</span>
                            }
<span class="nc" id="L4119">                            similarToBestFit.add(fit);</span>
                        } else {
<span class="nc" id="L4121">                            similarToBestFit.clear();</span>
                        }
<span class="nc" id="L4123">                        bestFit = fit;</span>
<span class="nc bnc" id="L4124" title="All 2 branches missed.">                        if (earlyConvergeReturn</span>
<span class="nc bnc" id="L4125" title="All 2 branches missed.">                            &amp;&amp; hasConverged(bestFit, maxNMatchable)) {</span>
<span class="nc bnc" id="L4126" title="All 2 branches missed.">                            if (similarToBestFit.isEmpty()) {</span>
<span class="nc" id="L4127">                                similarToBestFit.add(bestFit);</span>
                            }
<span class="nc" id="L4129">                            return similarToBestFit;</span>
                        }
                    }
                }
<span class="nc" id="L4133">            }</span>
<span class="nc" id="L4134">        }</span>

<span class="nc" id="L4136">        log.info(&quot;similarToBestFit.size=&quot; + similarToBestFit.size());</span>
<span class="nc bnc" id="L4137" title="All 2 branches missed.">        if (similarToBestFit.size() &gt; 1) {</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">            for (TransformationPointFit fit : similarToBestFit) {</span>
<span class="nc" id="L4139">                log.info(&quot;similarFit=&quot; + fit.toString());</span>
<span class="nc" id="L4140">            }</span>
        }
<span class="nc" id="L4142">        log.info(&quot;similarToBestFitNormalized.size=&quot; + similarToBestFitNormalized.size());</span>
<span class="nc bnc" id="L4143" title="All 2 branches missed.">        if (similarToBestFitNormalized.size() &gt; 1) {</span>
<span class="nc bnc" id="L4144" title="All 2 branches missed.">            for (TransformationPointFit fit : similarToBestFitNormalized) {</span>
<span class="nc" id="L4145">                log.info(&quot;similarFit=&quot; + fit.toString());</span>
<span class="nc" id="L4146">            }</span>
<span class="nc bnc" id="L4147" title="All 4 branches missed.">        } else if (similarToBestFitNormalized.isEmpty() &amp;&amp; (bestFitNormalized != null)) {</span>
<span class="nc" id="L4148">            log.info(&quot;bestFitNormalized=&quot; + bestFitNormalized.toString());</span>
<span class="nc" id="L4149">            similarToBestFitNormalized.add(bestFitNormalized);</span>
        }
<span class="nc bnc" id="L4151" title="All 2 branches missed.">        if (bestFit != null) {</span>
<span class="nc" id="L4152">            log.info(&quot;bestFit(not normalized)=&quot; + bestFit.toString());</span>
<span class="nc" id="L4153">            similarToBestFitNormalized.add(0, bestFit);</span>
        }

<span class="nc" id="L4156">        return similarToBestFitNormalized;</span>
    }

    /**
     * this one expects a left to right ordering of images and scale near 1
     * and rotation near zero and a y translation near zero.
     *
     * runtime is O(N^2) + O(N)
     *
     * @param set1
     * @param set2
     *
     * @param useLargestToleranceForOutput
     * @param useGreedyMatching
     * @return
     */
    protected TransformationPointFit calculateEuclideanLeftRightTransformation(
        PairIntArray set1, PairIntArray set2,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

        //TODO: consider that the translation in X should always be negative?

<span class="nc" id="L4178">        int n1 = set1.getN();</span>
<span class="nc" id="L4179">        int n2 = set2.getN();</span>

        float toleranceTransX;
        float toleranceTransY;
<span class="nc bnc" id="L4183" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L4184">            toleranceTransX = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L4185">            toleranceTransY = toleranceTransX;</span>
        } else {
<span class="nc" id="L4187">            toleranceTransX = 4;</span>
<span class="nc" id="L4188">            toleranceTransY = 4;</span>
        }

<span class="nc" id="L4191">        List&lt;Integer&gt; diffXs = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L4192">        List&lt;Integer&gt; diffYs = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L4194" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc" id="L4195">            int x1 = set1.getX(i);</span>
<span class="nc" id="L4196">            int y1 = set1.getY(i);</span>
<span class="nc bnc" id="L4197" title="All 2 branches missed.">            for (int j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L4198">                int y2 = set2.getY(j);</span>
<span class="nc" id="L4199">                int diffY = y2 - y1;</span>

<span class="nc bnc" id="L4201" title="All 2 branches missed.">                if (Math.abs(diffY) &gt; toleranceTransY) {</span>
<span class="nc" id="L4202">                    continue;</span>
                }

<span class="nc" id="L4205">                int x2 = set2.getX(j);</span>
<span class="nc" id="L4206">                int diffX = x2 - x1;</span>

<span class="nc" id="L4208">                diffXs.add(Integer.valueOf(diffX));</span>
<span class="nc" id="L4209">                diffYs.add(Integer.valueOf(diffY));</span>
            }
        }

<span class="nc" id="L4213">        float[] values = new float[diffXs.size()];</span>
<span class="nc bnc" id="L4214" title="All 2 branches missed.">        for (int i = 0; i &lt; diffXs.size(); ++i) {</span>
<span class="nc" id="L4215">            values[i] = diffXs.get(i).floatValue();</span>
        }

<span class="nc" id="L4218">        HistogramHolder hist = Histogram.createSimpleHistogram(toleranceTransX,</span>
<span class="nc" id="L4219">            values, Errors.populateYErrorsBySqrt(values));</span>

<span class="nc bnc" id="L4221" title="All 4 branches missed.">        if (hist.getXHist() == null || hist.getXHist().length == 0) {</span>
<span class="nc" id="L4222">            return null;</span>
        }

        // sort and evaluate top 3 answers

<span class="nc" id="L4227">        MultiArrayMergeSort.sortBy1stArgThen2nd(hist.getYHistFloat(), hist.getXHist());</span>

<span class="nc" id="L4229">        TransformationPointFit bestFit = null;</span>
<span class="nc" id="L4230">        TransformationPointFit bestFitNormalized = null;</span>

<span class="nc" id="L4232">        TransformationParameters params = new TransformationParameters();</span>
<span class="nc" id="L4233">        params.setScale(1);</span>
<span class="nc" id="L4234">        params.setRotationInDegrees(0);</span>
<span class="nc" id="L4235">        params.setOriginX(0);</span>
<span class="nc" id="L4236">        params.setOriginY(0);</span>

<span class="nc bnc" id="L4238" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; i++) {</span>

<span class="nc" id="L4240">            int hIdx = hist.getYHistFloat().length - i - 1;</span>

<span class="nc" id="L4242">            float tX = hist.getXHist()[hIdx];</span>

<span class="nc" id="L4244">            double tY = 0;</span>
<span class="nc" id="L4245">            int count = 0;</span>
<span class="nc bnc" id="L4246" title="All 2 branches missed.">            for (int ii = 0; ii &lt; diffXs.size(); ++ii) {</span>
<span class="nc" id="L4247">                int diffX = diffXs.get(ii);</span>
<span class="nc bnc" id="L4248" title="All 2 branches missed.">                if (Math.abs(diffX - tX) &lt;= (toleranceTransX/2.)) {</span>
<span class="nc" id="L4249">                    tY += diffYs.get(ii);</span>
<span class="nc" id="L4250">                    count++;</span>
                }
            }
<span class="nc" id="L4253">            tY /= (double)count;</span>

<span class="nc" id="L4255">            params = params.copy();</span>
<span class="nc" id="L4256">            params.setTranslationX(tX);</span>
<span class="nc" id="L4257">            params.setTranslationY((float)tY);</span>

<span class="nc" id="L4259">            TransformationPointFit fit = evaluateForUnmatched(params,</span>
                set1, set2, toleranceTransX, toleranceTransY,
                useGreedyMatching);

<span class="nc bnc" id="L4263" title="All 2 branches missed.">            if (fitIsBetter(bestFit, fit)) {</span>
<span class="nc" id="L4264">                bestFit = fit;</span>
            }
<span class="nc bnc" id="L4266" title="All 2 branches missed.">            if (fitIsBetterNormalized(bestFitNormalized, fit)) {</span>
<span class="nc" id="L4267">                bestFitNormalized = fit;</span>
            }
        }

<span class="nc" id="L4271">        return bestFit;</span>
    }

    List&lt;TransformationPointFit&gt; calculateEuclideanTransformationUsingPairs(
        PairIntArray set1, PairIntArray set2, boolean earlyConvergeReturn,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

<span class="fc" id="L4278">        int n1 = set1.getN();</span>
<span class="fc" id="L4279">        int n2 = set2.getN();</span>

        float toleranceTransX;
        float toleranceTransY;
<span class="pc bpc" id="L4283" title="1 of 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="fc" id="L4284">            toleranceTransX = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="fc" id="L4285">            toleranceTransY = toleranceTransX;</span>
        } else {
<span class="nc" id="L4287">            toleranceTransX = 4;</span>
<span class="nc" id="L4288">            toleranceTransY = 4;</span>
        }

<span class="fc" id="L4291">        return calculateEuclideanTransformationUsingPairs(</span>
            set1, set2, toleranceTransX, toleranceTransY, earlyConvergeReturn,
            useGreedyMatching);
    }

    List&lt;TransformationPointFit&gt; calculateEuclideanTransformationUsingPairs(
        PairIntArray set1, PairIntArray set2,
        float toleranceTransX, float toleranceTransY,
        boolean earlyConvergeReturn, boolean useGreedyMatching) {

<span class="fc" id="L4301">        int n1 = set1.getN();</span>
<span class="fc" id="L4302">        int n2 = set2.getN();</span>

<span class="fc" id="L4304">        long np = numberOfPairPermutations(n1, n2);</span>

        // if np is very large, need to be able to exit the algorithm
        // earlier than the full try of all permutations.
        // TODO: this may need to be set as an option to allow it to finish
        //     if user really does want all permutations tried.
<span class="pc bpc" id="L4310" title="2 of 6 branches missed.">        if ((np &gt; 1e8) || ((n2 &gt; largeSearchLimit) &amp;&amp; earlyConvergeReturn)){</span>
            /*
            if reduce set2 to a randomly sampled smaller set, the percentage
            of truly matchable points should remain the same.
            we then want a significant number of set1 tried against
            set 2 (but always evaluated with all points) before exiting
            the method instead of trying all , preferably, set1 would be
            randomly sampled.
            The goal would be to keep n1*(n1-1)*n2*(n2-1)*(1./4.)*n1*n2 &lt; 1e9
            reducing n2 to 30 and randomly sampling 30 from n1 results in
            0.17 billion steps.
            */
<span class="fc" id="L4322">            return calculateEuclideanTransformationUsingPairsPartitioned(</span>
                 set1, set2, toleranceTransX, toleranceTransY,
                 useGreedyMatching);
        }

<span class="fc" id="L4327">        long n1P = (set1.getN() * (set1.getN() - 1))/2;</span>

<span class="fc" id="L4329">        return calculateEuclideanTransformationForSmallSets(set1, set2,</span>
            set1, set2, n1P,
            toleranceTransX, toleranceTransY, useGreedyMatching);
    }

    List&lt;TransformationPointFit&gt; calculateEuclideanTransformationUsingPairs(
        PairIntArray set1, PairIntArray set2,
        float scale,
        float rotationLowLimitInDegrees, float rotationHighLimitInDegrees,
        boolean earlyConvergeReturn,
        boolean useLargestToleranceForOutput,
        boolean useGreedyMatching) {

<span class="nc" id="L4342">        int n1 = set1.getN();</span>
<span class="nc" id="L4343">        int n2 = set2.getN();</span>

<span class="nc bnc" id="L4345" title="All 4 branches missed.">        if ((n2 &gt; largeSearchLimit) &amp;&amp; earlyConvergeReturn) {</span>
<span class="nc" id="L4346">            return calculateEuclideanTransformationUsingPairsPartitioned(</span>
                set1, set2,
                scale, rotationLowLimitInDegrees,
                rotationHighLimitInDegrees,
                useLargestToleranceForOutput, useGreedyMatching);
        }

<span class="nc" id="L4353">        return calculateEuclideanTransformationForSmallSets(set1, set2,</span>
            scale, rotationLowLimitInDegrees, rotationHighLimitInDegrees,
            earlyConvergeReturn, useLargestToleranceForOutput, useGreedyMatching);
    }

    /**
     * method to perform pairwise transformation calculations on datasets that
     * are to large to feasibly visit every permutation.
     * The name may change soon to better reflect the internal implementation
     * which is no longer partitions.
     * @param set1
     * @param set2
     * @param toleranceTransX
     * @param toleranceTransY
     * @param useGreedyMatching
     * @return
     */
    protected List&lt;TransformationPointFit&gt;
    calculateEuclideanTransformationUsingPairsPartitioned(
        PairIntArray set1, PairIntArray set2,
        float toleranceTransX, float toleranceTransY,
        boolean useGreedyMatching) {

        /*
        Need to be able to sample only a small part of the dataset and arrive
        at a good answer.

        Will keep all of set2 and shuffle set1 to make sure it isn't ordered.

        Will only visit the first n1Min of set1 and break from the loop.
        n1Min is such that the complexity is kept &lt; 1e9.
            n1Min*(n1Min-1)*n2*(n2-1)*(1./4.)*n1*n2 &lt; 1e9
            n1Min*(n1Min-1) = 1e9/(*n2*(n2-1)*(1./4.)*n1*n2)
            n1Min ~ Math.sqrt(1e9/(n2*(n2-1)*(1./4.)*n1*n2))
        */

<span class="fc" id="L4389">        int n1 = set1.getN();</span>
<span class="fc" id="L4390">        int n2 = set2.getN();</span>
<span class="fc" id="L4391">        PairIntArray shuffledSet1 = null;</span>
        try {
<span class="fc" id="L4393">            shuffledSet1 = MiscMath.shuffle(set1);</span>
<span class="nc" id="L4394">        } catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L4395">            throw new RuntimeException(ex);</span>
<span class="fc" id="L4396">        }</span>

<span class="fc" id="L4398">        long n1Min = Math.round(Math.sqrt(1e9/(n2*(n2-1)*(1./2.)*n1*n2)));</span>
<span class="pc bpc" id="L4399" title="1 of 2 branches missed.">        if (n1Min &lt; 10) {</span>
            //this can still take minutes if n1&gt;150 and n2 &gt; 150
<span class="nc" id="L4401">            n1Min = 10;</span>
        }

<span class="fc" id="L4404">        log.info(&quot;n1Min=&quot; + n1Min);</span>

<span class="fc" id="L4406">        return calculateEuclideanTransformationForSmallSets(shuffledSet1,</span>
            set2, shuffledSet1, set2, n1Min,
            toleranceTransX, toleranceTransY, useGreedyMatching);
    }

    protected List&lt;TransformationPointFit&gt;
    calculateEuclideanTransformationUsingPairsPartitioned(
        PairIntArray set1, PairIntArray set2,
        final float scale,
        final float rotationLowLimitInDegrees,
        final float rotationHighLimitInDegrees,
        boolean useLargestToleranceForOutput, boolean useGreedyMatching) {

<span class="nc" id="L4419">        int n1 = set1.getN();</span>
<span class="nc" id="L4420">        int n2 = set2.getN();</span>

<span class="nc" id="L4422">        PointPartitioner partitioner = new PointPartitioner();</span>

<span class="nc" id="L4424">        List&lt;PairIntArray&gt; set2Subsets = partitioner.randomSubsets(set2,</span>
            largeSearchLimit);

<span class="nc" id="L4427">        int k = 2;</span>

<span class="nc" id="L4429">        int[] selected1 = new int[k];</span>
<span class="nc" id="L4430">        int[] selected2 = new int[k];</span>

<span class="nc" id="L4432">        MatchedPointsTransformationCalculator tc = new</span>
            MatchedPointsTransformationCalculator();
        float toleranceTransX;
        float toleranceTransY;
<span class="nc bnc" id="L4436" title="All 2 branches missed.">        if (useLargestToleranceForOutput) {</span>
<span class="nc" id="L4437">            toleranceTransX = generalTolerance * (float)Math.sqrt(1./2);</span>
<span class="nc" id="L4438">            toleranceTransY = toleranceTransX;</span>
        } else {
<span class="nc" id="L4440">            toleranceTransX = 4;</span>
<span class="nc" id="L4441">            toleranceTransY = 4;</span>
        }
<span class="nc" id="L4443">        double centroidX1 = 0;</span>
<span class="nc" id="L4444">        double centroidY1 = 0;</span>

<span class="nc" id="L4446">        int maxNMatchable = Math.min(n1, n2);</span>

<span class="nc" id="L4448">        float rotRange = AngleUtil.getAngleDifference(rotationLowLimitInDegrees,</span>
            rotationHighLimitInDegrees);

<span class="nc" id="L4451">        SubsetChooser s1 = new SubsetChooser(n1, k);</span>

<span class="nc" id="L4453">        TransformationPointFit bestFitNormalized = null;</span>

<span class="nc" id="L4455">        List&lt;TransformationPointFit&gt; similarToBestFitNormalized = new ArrayList&lt;TransformationPointFit&gt;();</span>

<span class="nc" id="L4457">        TransformationPointFit bestFit = null;</span>

<span class="nc" id="L4459">        List&lt;TransformationPointFit&gt; similarToBestFit = new ArrayList&lt;TransformationPointFit&gt;();</span>

<span class="nc bnc" id="L4461" title="All 2 branches missed.">        while (s1.getNextSubset(selected1) != -1) {</span>

<span class="nc bnc" id="L4463" title="All 2 branches missed.">            for (PairIntArray set2Subset : set2Subsets) {</span>

<span class="nc" id="L4465">                int n2S = set2Subset.getN();</span>

<span class="nc" id="L4467">                SubsetChooser s2 = new SubsetChooser(n2S, k);</span>

<span class="nc bnc" id="L4469" title="All 2 branches missed.">                while (s2.getNextSubset(selected2) != -1) {</span>

<span class="nc" id="L4471">                    TransformationParameters params = tc.calulateEuclidean(</span>
<span class="nc" id="L4472">                        set1.getX(selected1[0]), set1.getY(selected1[0]),</span>
<span class="nc" id="L4473">                        set1.getX(selected1[1]), set1.getY(selected1[1]),</span>
<span class="nc" id="L4474">                        set2Subset.getX(selected2[0]), set2Subset.getY(selected2[0]),</span>
<span class="nc" id="L4475">                        set2Subset.getX(selected2[1]), set2Subset.getY(selected2[1]),</span>
                        centroidX1, centroidY1);

<span class="nc" id="L4478">                    float rotD = params.getRotationInDegrees();</span>

<span class="nc" id="L4480">                    if (</span>
<span class="nc bnc" id="L4481" title="All 4 branches missed.">                        (Math.abs(scale - params.getScale()) &lt; 0.05) &amp;&amp;</span>
                        (((rotD &gt;= rotationLowLimitInDegrees)
<span class="nc bnc" id="L4483" title="All 4 branches missed.">                          &amp;&amp; (Math.abs(AngleUtil.getAngleDifference(rotD, rotationLowLimitInDegrees)) &lt; rotRange))</span>
                        ||
                        ((rotD &lt;= rotationHighLimitInDegrees)
<span class="nc bnc" id="L4486" title="All 2 branches missed.">                          &amp;&amp; (Math.abs(AngleUtil.getAngleDifference(rotD, rotationHighLimitInDegrees)) &lt; rotRange))</span>
                        )) {

<span class="nc" id="L4489">                        TransformationPointFit fit = evaluateForUnmatched(params,</span>
                            set1, set2, toleranceTransX, toleranceTransY,
                            useGreedyMatching);

<span class="nc bnc" id="L4493" title="All 4 branches missed.">                        if ((fit != null) &amp;&amp; (fit.getNumberOfMatchedPoints() &gt; 2)) {</span>
<span class="nc bnc" id="L4494" title="All 2 branches missed.">                            if (fitIsBetterNormalized(bestFitNormalized, fit)) {</span>
<span class="nc bnc" id="L4495" title="All 4 branches missed.">                                if ((bestFitNormalized != null) &amp;&amp; (bestFitNormalized.getMeanDistFromModel() &lt; 1)</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">                                    &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="nc bnc" id="L4497" title="All 2 branches missed.">                                    if (similarToBestFitNormalized.isEmpty()) {</span>
<span class="nc" id="L4498">                                        similarToBestFitNormalized.add(bestFitNormalized);</span>
                                    }
<span class="nc" id="L4500">                                    similarToBestFitNormalized.add(fit);</span>
                                } else {
<span class="nc" id="L4502">                                    similarToBestFitNormalized.clear();</span>
                                }
<span class="nc" id="L4504">                                bestFitNormalized = fit;</span>
                            }
<span class="nc bnc" id="L4506" title="All 2 branches missed.">                            if (fitIsBetter(bestFit, fit)) {</span>
<span class="nc bnc" id="L4507" title="All 4 branches missed.">                                if ((bestFit != null) &amp;&amp; (bestFit.getMeanDistFromModel() &lt; 1)</span>
<span class="nc bnc" id="L4508" title="All 2 branches missed.">                                    &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="nc bnc" id="L4509" title="All 2 branches missed.">                                    if (similarToBestFit.isEmpty()) {</span>
<span class="nc" id="L4510">                                        similarToBestFit.add(bestFit);</span>
                                    }
<span class="nc" id="L4512">                                    similarToBestFit.add(fit);</span>
                                } else {
<span class="nc" id="L4514">                                    similarToBestFit.clear();</span>
                                }
<span class="nc" id="L4516">                                bestFit = fit;</span>
                            }
                        }

<span class="nc" id="L4520">                        params = tc.calulateEuclidean(</span>
<span class="nc" id="L4521">                            set1.getX(selected1[0]), set1.getY(selected1[0]),</span>
<span class="nc" id="L4522">                            set1.getX(selected1[1]), set1.getY(selected1[1]),</span>
<span class="nc" id="L4523">                            set2Subset.getX(selected2[1]), set2Subset.getY(selected2[1]),</span>
<span class="nc" id="L4524">                            set2Subset.getX(selected2[0]), set2Subset.getY(selected2[0]),</span>
                            centroidX1, centroidY1);

<span class="nc" id="L4527">                        rotD = params.getRotationInDegrees();</span>

<span class="nc" id="L4529">                        if (</span>
<span class="nc bnc" id="L4530" title="All 4 branches missed.">                            (Math.abs(scale - params.getScale()) &lt; 0.05) &amp;&amp;</span>
                            (((rotD &gt;= rotationLowLimitInDegrees)
<span class="nc bnc" id="L4532" title="All 4 branches missed.">                              &amp;&amp; (Math.abs(AngleUtil.getAngleDifference(rotD, rotationLowLimitInDegrees)) &lt; rotRange))</span>
                            ||
                            ((rotD &lt;= rotationHighLimitInDegrees)
<span class="nc bnc" id="L4535" title="All 2 branches missed.">                              &amp;&amp; (Math.abs(AngleUtil.getAngleDifference(rotD, rotationHighLimitInDegrees)) &lt; rotRange))</span>
                            )) {

<span class="nc" id="L4538">                            fit = evaluateForUnmatched(params, set1, set2,</span>
                                toleranceTransX, toleranceTransY, useGreedyMatching);

<span class="nc bnc" id="L4541" title="All 4 branches missed.">                            if ((fit != null) &amp;&amp; (fit.getNumberOfMatchedPoints() &gt; 2)) {</span>
<span class="nc bnc" id="L4542" title="All 2 branches missed.">                                if (fitIsBetterNormalized(bestFitNormalized, fit)) {</span>
<span class="nc bnc" id="L4543" title="All 4 branches missed.">                                    if ((bestFitNormalized != null) &amp;&amp; (bestFitNormalized.getMeanDistFromModel() &lt; 1)</span>
<span class="nc bnc" id="L4544" title="All 2 branches missed.">                                        &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="nc bnc" id="L4545" title="All 2 branches missed.">                                        if (similarToBestFitNormalized.isEmpty()) {</span>
<span class="nc" id="L4546">                                            similarToBestFitNormalized.add(bestFitNormalized);</span>
                                        }
<span class="nc" id="L4548">                                        similarToBestFitNormalized.add(fit);</span>
                                    } else {
<span class="nc" id="L4550">                                        similarToBestFitNormalized.clear();</span>
                                    }
<span class="nc" id="L4552">                                    bestFitNormalized = fit;</span>
                                }
<span class="nc bnc" id="L4554" title="All 2 branches missed.">                                if (fitIsBetter(bestFit, fit)) {</span>
<span class="nc bnc" id="L4555" title="All 4 branches missed.">                                    if ((bestFit != null) &amp;&amp; (bestFit.getMeanDistFromModel() &lt; 1)</span>
<span class="nc bnc" id="L4556" title="All 2 branches missed.">                                        &amp;&amp; (fit.getMeanDistFromModel() &lt; 1)) {</span>
<span class="nc bnc" id="L4557" title="All 2 branches missed.">                                        if (similarToBestFit.isEmpty()) {</span>
<span class="nc" id="L4558">                                            similarToBestFit.add(bestFit);</span>
                                        }
<span class="nc" id="L4560">                                        similarToBestFit.add(fit);</span>
                                    } else {
<span class="nc" id="L4562">                                        similarToBestFit.clear();</span>
                                    }
<span class="nc" id="L4564">                                    bestFit = fit;</span>
                                }
                            }
                        }
                    }
<span class="nc" id="L4569">                }</span>
<span class="nc" id="L4570">            }</span>
        }

<span class="nc" id="L4573">        log.info(&quot;similarToBestFit.size=&quot; + similarToBestFit.size());</span>
<span class="nc bnc" id="L4574" title="All 2 branches missed.">        if (similarToBestFit.size() &gt; 1) {</span>
<span class="nc bnc" id="L4575" title="All 2 branches missed.">            for (TransformationPointFit fit : similarToBestFit) {</span>
<span class="nc" id="L4576">                log.info(&quot;similarFit=&quot; + fit.toString());</span>
<span class="nc" id="L4577">            }</span>
        }
<span class="nc" id="L4579">        log.info(&quot;similarToBestFitNormalized.size=&quot; + similarToBestFitNormalized.size());</span>
<span class="nc bnc" id="L4580" title="All 2 branches missed.">        if (similarToBestFitNormalized.size() &gt; 1) {</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">            for (TransformationPointFit fit : similarToBestFitNormalized) {</span>
<span class="nc" id="L4582">                log.info(&quot;similarFit=&quot; + fit.toString());</span>
<span class="nc" id="L4583">            }</span>
<span class="nc bnc" id="L4584" title="All 4 branches missed.">        } else if (similarToBestFitNormalized.isEmpty() &amp;&amp; (bestFitNormalized != null)) {</span>
<span class="nc" id="L4585">            log.info(&quot;bestFitNormalized=&quot; + bestFitNormalized.toString());</span>
<span class="nc" id="L4586">            similarToBestFitNormalized.add(bestFitNormalized);</span>
        }
<span class="nc bnc" id="L4588" title="All 2 branches missed.">        if (bestFit != null) {</span>
<span class="nc" id="L4589">            log.info(&quot;bestFit(not normalized)=&quot; + bestFit.toString());</span>
<span class="nc" id="L4590">            similarToBestFitNormalized.add(0, bestFit);</span>
        }

<span class="nc" id="L4593">        return similarToBestFitNormalized;</span>
    }

    protected long numberOfPairPermutations(int n1, int n2) {

<span class="fc" id="L4598">        long n1p = (MiscMath.computeNDivNMinusK(n1, 2)) &gt;&gt; 1;</span>

<span class="fc" id="L4600">        long n2p = (MiscMath.computeNDivNMinusK(n2, 2)) &gt;&gt; 1;</span>

<span class="fc" id="L4602">        double lg1 = Math.log(n1p)/Math.log(2);</span>
<span class="fc" id="L4603">        double lg2 = Math.log(n2p)/Math.log(2);</span>

<span class="pc bpc" id="L4605" title="1 of 2 branches missed.">        if ((lg1 + lg2) &gt; 63) {</span>
<span class="nc" id="L4606">            return Long.MAX_VALUE;</span>
        }

<span class="fc" id="L4609">        return n1p * n2p;</span>
    }

    protected long estimateNStepsPairCalculation(int n1, int n2) {

<span class="fc" id="L4614">        long np = numberOfPairPermutations(n1, n2);</span>

<span class="pc bpc" id="L4616" title="1 of 2 branches missed.">        if (np == Long.MAX_VALUE) {</span>
<span class="nc" id="L4617">            return np;</span>
        }

<span class="fc" id="L4620">        long nPerFitGreedy = n1 * n2;</span>

<span class="fc" id="L4622">        return np * 2 * nPerFitGreedy;</span>
    }

    protected void reduceToIntersection(
        PairFloatArray set1, PairIntArray set2,
        PairFloatArray outputSet1, PairIntArray outputSet2,
        float tolTransX, float tolTransY) {

        /*
        determine minima and maxima of outputSet2

        filter set1 to place in outputSet1 only the intersection with set2
           +- tolerances

        determine minima and maxima of outputSet1

        filter set2 to place in outputSet1 only the intersection with outputSet1
           +- tolerances
        */

<span class="fc" id="L4642">        int minX2 = MiscMath.findMin(set2.getX(), set2.getN());</span>
<span class="fc" id="L4643">        int maxX2 = MiscMath.findMax(set2.getX(), set2.getN());</span>
<span class="fc" id="L4644">        int minY2 = MiscMath.findMin(set2.getY(), set2.getN());</span>
<span class="fc" id="L4645">        int maxY2 = MiscMath.findMax(set2.getY(), set2.getN());</span>

<span class="fc bfc" id="L4647" title="All 2 branches covered.">        for (int i = 0; i &lt; set1.getN(); ++i) {</span>
<span class="fc" id="L4648">            float x = set1.getX(i);</span>
<span class="fc" id="L4649">            float y = set1.getY(i);</span>
<span class="fc bfc" id="L4650" title="All 4 branches covered.">            if ((x &lt; (minX2 - tolTransX)) || (x &gt; (maxX2 + tolTransX))) {</span>
<span class="fc" id="L4651">                continue;</span>
            }
<span class="fc bfc" id="L4653" title="All 4 branches covered.">            if ((y &lt; (minY2 - tolTransY)) || (y &gt; (maxY2 + tolTransY))) {</span>
<span class="fc" id="L4654">                continue;</span>
            }
<span class="fc" id="L4656">            outputSet1.add(x, y);</span>
        }

<span class="fc" id="L4659">        float minX1 = MiscMath.findMin(outputSet1.getX(), outputSet1.getN());</span>
<span class="fc" id="L4660">        float maxX1 = MiscMath.findMax(outputSet1.getX(), outputSet1.getN());</span>
<span class="fc" id="L4661">        float minY1 = MiscMath.findMin(outputSet1.getY(), outputSet1.getN());</span>
<span class="fc" id="L4662">        float maxY1 = MiscMath.findMax(outputSet1.getY(), outputSet1.getN());</span>

<span class="fc bfc" id="L4664" title="All 2 branches covered.">        for (int i = 0; i &lt; set2.getN(); ++i) {</span>
<span class="fc" id="L4665">            float x = set2.getX(i);</span>
<span class="fc" id="L4666">            float y = set2.getY(i);</span>
<span class="fc bfc" id="L4667" title="All 4 branches covered.">            if ((x &lt; (minX1 - tolTransX)) || (x &gt; (maxX1 + tolTransX))) {</span>
<span class="fc" id="L4668">                continue;</span>
            }
<span class="fc bfc" id="L4670" title="All 4 branches covered.">            if ((y &lt; (minY1 - tolTransY)) || (y &gt; (maxY1 + tolTransY))) {</span>
<span class="fc" id="L4671">                continue;</span>
            }
<span class="fc" id="L4673">            outputSet2.add(Math.round(x), Math.round(y));</span>
        }
<span class="fc" id="L4675">    }</span>

    public void match(TransformationParameters params, PairIntArray set1,
        PairIntArray set2, PairIntArray outputMatchedSet1,
        PairIntArray outputMatchedSet2, float tolTransX, float tolTransY,
        boolean useGreedyMatching) {

<span class="nc" id="L4682">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L4684">        PairFloatArray transformedSet1 = transformer.applyTransformation2(</span>
            params, set1);

<span class="nc bnc" id="L4687" title="All 2 branches missed.">        if (useGreedyMatching) {</span>

<span class="nc" id="L4689">            Set&lt;Integer&gt; chosen = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L4690" title="All 2 branches missed.">            for (int i = 0; i &lt; transformedSet1.getN(); ++i) {</span>
<span class="nc" id="L4691">                float transformedX = transformedSet1.getX(i);</span>
<span class="nc" id="L4692">                float transformedY = transformedSet1.getY(i);</span>
<span class="nc" id="L4693">                double minDiff = Double.MAX_VALUE;</span>
<span class="nc" id="L4694">                int min2Idx = -1;</span>
<span class="nc bnc" id="L4695" title="All 2 branches missed.">                for (int j = 0; j &lt; set2.getN(); ++j) {</span>
<span class="nc bnc" id="L4696" title="All 2 branches missed.">                    if (chosen.contains(Integer.valueOf(j))) {</span>
<span class="nc" id="L4697">                        continue;</span>
                    }
<span class="nc" id="L4699">                    float dx = transformedX - set2.getX(j);</span>
<span class="nc" id="L4700">                    float dy = transformedY - set2.getY(j);</span>
<span class="nc bnc" id="L4701" title="All 4 branches missed.">                    if ((Math.abs(dx) &gt; tolTransX) || (Math.abs(dy) &gt; tolTransY)) {</span>
<span class="nc" id="L4702">                        continue;</span>
                    }
<span class="nc" id="L4704">                    float diff = (float)Math.sqrt(dx*dx + dy*dy);</span>
<span class="nc bnc" id="L4705" title="All 2 branches missed.">                    if (diff &lt; minDiff) {</span>
<span class="nc" id="L4706">                        minDiff = diff;</span>
<span class="nc" id="L4707">                        min2Idx = j;</span>
                    }
                }
<span class="nc bnc" id="L4710" title="All 2 branches missed.">                if (minDiff &lt; Double.MAX_VALUE) {</span>
<span class="nc" id="L4711">                    chosen.add(Integer.valueOf(min2Idx));</span>
<span class="nc" id="L4712">                    outputMatchedSet1.add(set1.getX(i), set1.getY(i));</span>
<span class="nc" id="L4713">                    outputMatchedSet2.add(set2.getX(min2Idx), set2.getY(min2Idx));</span>
                }
            }

<span class="nc" id="L4717">        } else {</span>

<span class="nc" id="L4719">            float[][] matchedIndexesAndDiffs = calculateMatchUsingOptimal(</span>
                transformedSet1, set2, tolTransX, tolTransY);

<span class="nc" id="L4722">            double tolerance = Math.sqrt(tolTransX*tolTransX + tolTransY*tolTransY);</span>

<span class="nc" id="L4724">            matchPoints(set1, set2, (float)tolerance,</span>
                matchedIndexesAndDiffs, outputMatchedSet1, outputMatchedSet2);
        }
<span class="nc" id="L4727">    }</span>

    private TransformationPointFit refineAfterCalculationWithPairs(
        TransformationParameters params, PairIntArray set1, PairIntArray set2,
        boolean useGreedyMatching) {

<span class="fc" id="L4733">        float rotHalfRange = 25;</span>
<span class="fc" id="L4734">        float rotDelta = 5.f;</span>
<span class="fc" id="L4735">        float transHalfRange = 75;</span>
<span class="fc" id="L4736">        float transDelta = 15;</span>

<span class="fc" id="L4738">        int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>

<span class="fc" id="L4740">        long t0 = System.currentTimeMillis();</span>

<span class="fc" id="L4742">        TransformationPointFit fit2 = null;</span>

<span class="fc bfc" id="L4744" title="All 2 branches covered.">        if (params.getScale() &gt;= 1.0) {</span>
<span class="fc" id="L4745">            fit2 = refineTheTransformation(</span>
                params, set1, set2,
                rotHalfRange, rotDelta,
                transHalfRange, transDelta, transHalfRange, transDelta,
                useGreedyMatching);
        } else {
            // scale is &lt; 1 so reverse order of sets and fit
<span class="fc" id="L4752">            MatchedPointsTransformationCalculator tc = new</span>
                MatchedPointsTransformationCalculator();
<span class="fc" id="L4754">            TransformationParameters revParams = tc.swapReferenceFrames(</span>
<span class="fc" id="L4755">                params.copy());</span>

<span class="fc" id="L4757">            TransformationPointFit revFit = refineTheTransformation(</span>
                revParams, set2, set1,
                rotHalfRange, rotDelta,
                transHalfRange, transDelta, transHalfRange, transDelta,
                useGreedyMatching);
            // reverse the parameters.

<span class="fc" id="L4764">            TransformationParameters revRevParams = tc.swapReferenceFrames(</span>
<span class="fc" id="L4765">                revFit.getParameters().copy());</span>
<span class="fc" id="L4766">            fit2 = new TransformationPointFit(revRevParams,</span>
<span class="fc" id="L4767">                revFit.getNumberOfMatchedPoints(),</span>
<span class="fc" id="L4768">                revFit.getMeanDistFromModel(),</span>
<span class="fc" id="L4769">                revFit.getStDevFromMean(),</span>
<span class="fc" id="L4770">                revFit.getTranslationXTolerance(),</span>
<span class="fc" id="L4771">                revFit.getTranslationYTolerance());</span>
<span class="pc bpc" id="L4772" title="1 of 2 branches missed.">            if (fit2 != null) {</span>
<span class="fc" id="L4773">               fit2.setMaximumNumberMatchable(nMaxMatchable);</span>
            }
        }
<span class="fc" id="L4776">        long t1 = System.currentTimeMillis();</span>
<span class="fc" id="L4777">        log.info(&quot;refine seconds=&quot; + ((t1 - t0)*1e-3));</span>

<span class="fc" id="L4779">        return fit2;</span>
    }

    public List&lt;TransformationPointFit&gt; calculateEuclideanTransformationUsingPairs(
        ImageExt img1, ImageExt img2,
        PairIntArray points1, PairIntArray points2,
        float toleranceTransX, float toleranceTransY, double toleranceColor,
        boolean earlyConvergeReturn, boolean useGreedyMatching) {

        // similar to calculateEuclideanTransformationUsingPairs,
        // but additionally uses the region surrounding the
        // points to filter out some calculations

        /*
        before calculate transformation with a pair,
           -- compare the 2 points 20 neighbor summed intensity and discard
              if too different.
        after calculate transformation with a pair:
           -- compare the center pair's spokes at 0, 90, 180, 270 in the
              common reference frame and discard if too different.
              comparison should probably be total intensity.
           -- during evaluation:
                -- for each point within tolerance of greedy match,
                   -- compare the summed intensity
                   -- compare the spokes
                   only consider matched if those comparisons have similar
                   results

        for the spoke intensities, can memoize for the solid angle depending upon
        length of the spoke.
        */

<span class="nc" id="L4811">        int n1 = points1.getN();</span>
<span class="nc" id="L4812">        int n2 = points2.getN();</span>

<span class="nc" id="L4814">        int k = 2;</span>

<span class="nc" id="L4816">        SubsetChooser s1 = new SubsetChooser(n1, k);</span>

<span class="nc" id="L4818">        int[] selected1 = new int[k];</span>
<span class="nc" id="L4819">        int[] selected2 = new int[k];</span>

<span class="nc" id="L4821">        TransformationPointFit bestFitNormalized = null;</span>
<span class="nc" id="L4822">        TransformationPointFit bestFit = null;</span>

<span class="nc" id="L4824">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L4826">        MatchedPointsTransformationCalculator tc = new</span>
            MatchedPointsTransformationCalculator();

<span class="nc bnc" id="L4829" title="All 2 branches missed.">        while (s1.getNextSubset(selected1) != -1) {</span>

<span class="nc" id="L4831">            int idx10 = selected1[0];</span>
<span class="nc" id="L4832">            int idx11 = selected1[1];</span>

<span class="nc bnc" id="L4834" title="All 2 branches missed.">            if (idx11 &lt; idx10) {</span>
<span class="nc" id="L4835">                int swap = idx10;</span>
<span class="nc" id="L4836">                idx10 = idx11;</span>
<span class="nc" id="L4837">                idx11 = swap;</span>
            }

<span class="nc" id="L4840">            int x10 = points1.getX(idx10);</span>
<span class="nc" id="L4841">            int y10 = points1.getY(idx10);</span>

<span class="nc" id="L4843">            int x11 = points1.getX(idx11);</span>
<span class="nc" id="L4844">            int y11 = points1.getY(idx11);</span>

<span class="nc" id="L4846">            SubsetChooser s2 = new SubsetChooser(n2, k);</span>

<span class="nc bnc" id="L4848" title="All 2 branches missed.">            while (s2.getNextSubset(selected2) != -1) {</span>

<span class="nc" id="L4850">                int idx20 = selected2[0];</span>
<span class="nc" id="L4851">                int idx21 = selected2[1];</span>
<span class="nc" id="L4852">                int x20 = points2.getX(idx20);</span>
<span class="nc" id="L4853">                int y20 = points2.getY(idx20);</span>

<span class="nc" id="L4855">                int x21 = points2.getX(idx21);</span>
<span class="nc" id="L4856">                int y21 = points2.getY(idx21);</span>

<span class="nc bnc" id="L4858" title="All 2 branches missed.">                for (int order = 0; order &lt; 2; ++order) {</span>
<span class="nc bnc" id="L4859" title="All 2 branches missed.">                    if (order == 1) {</span>
<span class="nc" id="L4860">                        int swap = x20;</span>
<span class="nc" id="L4861">                        x20 = x21;</span>
<span class="nc" id="L4862">                        x21 = swap;</span>
<span class="nc" id="L4863">                        swap = y20;</span>
<span class="nc" id="L4864">                        y20 = y21;</span>
<span class="nc" id="L4865">                        y21 = swap;</span>
                    }
                    
                    // TODO: might need a small amount of dithering to allow
                    // for finding the better centroid
                    
<span class="nc" id="L4871">                    TransformationParameters params = tc.calulateEuclidean(</span>
                        x10, y10, x11, y11, x20, y20, x21, y21, 0, 0);
                    
                    // TODO: memoize transformed patches and discarded transformations

<span class="nc" id="L4876">                    boolean firstPointIsSimilar = patchesAreSimilar(params, img1, img2,</span>
                        transformer, x10, y10);
                    
<span class="nc bnc" id="L4879" title="All 2 branches missed.">                    if (!firstPointIsSimilar) {</span>
<span class="nc" id="L4880">                        continue;</span>
                    }

<span class="nc" id="L4883">                    boolean secondPointIsSimilar = patchesAreSimilar(params, img1, img2,</span>
                        transformer, x11, y11);

<span class="nc bnc" id="L4886" title="All 2 branches missed.">                    if (!secondPointIsSimilar) {</span>
<span class="nc" id="L4887">                        continue;</span>
                    }

<span class="nc" id="L4890">                    TransformationPointFit fit = evaluateForUnmatchedGreedy(</span>
                        params, points1, points2, img1, img2,
                        toleranceTransX, toleranceTransY);

<span class="nc bnc" id="L4894" title="All 4 branches missed.">                    if ((fit == null) || (fit.getNumberOfMatchedPoints() &lt; 2)) {</span>
<span class="nc" id="L4895">                        continue;</span>
                    }

<span class="nc bnc" id="L4898" title="All 2 branches missed.">                    if (fitIsBetterNormalized(bestFitNormalized, fit)) {</span>
<span class="nc" id="L4899">                        bestFitNormalized = fit;</span>
                    }
<span class="nc bnc" id="L4901" title="All 2 branches missed.">                    if (fitIsBetter(bestFit, fit)) {</span>
<span class="nc" id="L4902">                        bestFit = fit;</span>
                    }
                }
<span class="nc" id="L4905">            }</span>
<span class="nc" id="L4906">        }</span>

<span class="nc" id="L4908">        List&lt;TransformationPointFit&gt; results = new ArrayList&lt;TransformationPointFit&gt;();</span>
<span class="nc bnc" id="L4909" title="All 2 branches missed.">        if (bestFitNormalized != null) {</span>
<span class="nc" id="L4910">            results.add(bestFitNormalized);</span>
        }
<span class="nc bnc" id="L4912" title="All 2 branches missed.">        if (bestFit != null) {</span>
<span class="nc" id="L4913">            results.add(bestFit);</span>
        }

<span class="nc" id="L4916">        return results;</span>
    }

     /**
     *
     * @param points
     * @param img
     * @return two dimensional arrays of the averaged properties of the
     * neighboring pixels to each in points.
     * output first dimension size is size of points array, 2nd dimension
     * size is size of neighbors + 1 (which is54 if use4Neighbors is chosen, else 9).
     * the first entry is for the center pixel which is the pixel in the
     * points array.
     */
    PixelColors[][] avgOfNeighborIntensities(PairIntArray points,
        ImageExt img, boolean use4Neighbors) {

        final int nNeighbors;
        int[] ncXOffsets;
        int[] ncYOffsets;
<span class="nc bnc" id="L4936" title="All 2 branches missed.">        if (use4Neighbors) {</span>
<span class="nc" id="L4937">            nNeighbors = 5;</span>
<span class="nc" id="L4938">            ncXOffsets = new int[]{0, -1, 0,  1, 0};</span>
<span class="nc" id="L4939">            ncYOffsets = new int[]{0,  0, -1, 0, 1};</span>
        } else {
<span class="nc" id="L4941">            nNeighbors = 9;</span>
<span class="nc" id="L4942">            ncXOffsets = new int[]{0, -1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="nc" id="L4943">            ncYOffsets = new int[]{0,  0, -1, -1, -1, 0, 1, 1,  1};</span>
        }

<span class="nc" id="L4946">        PixelColors[][] output = new PixelColors[points.getN()][];</span>

<span class="nc" id="L4948">        PairIntArray neighborOffsets = MiscMath.get20NeighborOffsets();</span>

<span class="nc bnc" id="L4950" title="All 2 branches missed.">        for (int i = 0; i &lt; points.getN(); ++i) {</span>

<span class="nc" id="L4952">            output[i] = new PixelColors[nNeighbors];</span>

<span class="nc" id="L4954">            final int x0 = points.getX(i);</span>
<span class="nc" id="L4955">            final int y0 = points.getY(i);</span>

<span class="nc bnc" id="L4957" title="All 2 branches missed.">            for (int nIdx = 0; nIdx &lt; ncXOffsets.length; ++nIdx) {</span>
<span class="nc" id="L4958">                int x = x0 + ncXOffsets[nIdx];</span>
<span class="nc" id="L4959">                int y = y0 + ncYOffsets[nIdx];</span>

<span class="nc" id="L4961">                PixelColors clr = avgOfNeighborIntensities(x, y, neighborOffsets,</span>
                    img);

<span class="nc" id="L4964">                output[i][nIdx] = clr;</span>
            }
        }

<span class="nc" id="L4968">        return output;</span>
    }

    PixelColors[] avgOfNeighborIntensities(PairIntArray points, ImageExt img) {

<span class="nc" id="L4973">        PixelColors[] output = new PixelColors[points.getN()];</span>

<span class="nc" id="L4975">        PairIntArray neighborOffsets = MiscMath.get20NeighborOffsets();</span>

<span class="nc bnc" id="L4977" title="All 2 branches missed.">        for (int i = 0; i &lt; points.getN(); ++i) {</span>

<span class="nc" id="L4979">            int x = points.getX(i);</span>
<span class="nc" id="L4980">            int y = points.getY(i);</span>

<span class="nc" id="L4982">            PixelColors clr = avgOfNeighborIntensities(x, y, neighborOffsets, img);</span>

<span class="nc" id="L4984">            output[i] = clr;</span>
        }

<span class="nc" id="L4987">        return output;</span>
    }

    PixelColors avgOfNeighborIntensities(int x, int y, PairIntArray neighborOffsets,
        ImageExt img) {

<span class="nc" id="L4993">        img.setRadiusForPopulateOnDemand(0);</span>

<span class="nc" id="L4995">        int colMax = img.getWidth() - 1;</span>
<span class="nc" id="L4996">        int rowMax = img.getHeight()- 1;</span>

<span class="nc" id="L4998">        int sumR = 0;</span>
<span class="nc" id="L4999">        int sumG = 0;</span>
<span class="nc" id="L5000">        int sumB = 0;</span>
<span class="nc" id="L5001">        float sumCIEX = 0;</span>
<span class="nc" id="L5002">        float sumCIEY = 0;</span>
<span class="nc" id="L5003">        int count = 0;</span>
<span class="nc bnc" id="L5004" title="All 2 branches missed.">        for (int j = 0; j &lt; neighborOffsets.getN(); ++j) {</span>
<span class="nc" id="L5005">            int xOff = neighborOffsets.getX(j);</span>
<span class="nc" id="L5006">            int x2 = x + xOff;</span>
<span class="nc bnc" id="L5007" title="All 4 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; colMax)) {</span>
<span class="nc" id="L5008">                continue;</span>
            }

<span class="nc" id="L5011">            int yOff = neighborOffsets.getY(j);</span>
<span class="nc" id="L5012">            int y2 = y + yOff;</span>
<span class="nc bnc" id="L5013" title="All 4 branches missed.">            if ((y2 &lt; 0) || (y2 &gt; rowMax)) {</span>
<span class="nc" id="L5014">                continue;</span>
            }
<span class="nc" id="L5016">            int idx = img.getInternalIndex(x2, y2);</span>
<span class="nc" id="L5017">            sumR += img.getR(idx);</span>
<span class="nc" id="L5018">            sumG += img.getG(idx);</span>
<span class="nc" id="L5019">            sumB += img.getB(idx);</span>
<span class="nc" id="L5020">            sumCIEX += img.getCIEX(idx);</span>
<span class="nc" id="L5021">            sumCIEY += img.getCIEY(idx);</span>

<span class="nc" id="L5023">            count++;</span>
        }

<span class="nc" id="L5026">        sumR = Math.round((float)sumR/(float)count);</span>
<span class="nc" id="L5027">        sumG = Math.round((float)sumG/(float)count);</span>
<span class="nc" id="L5028">        sumB = Math.round((float)sumB/(float)count);</span>
<span class="nc" id="L5029">        sumCIEX = sumCIEX/(float)count;</span>
<span class="nc" id="L5030">        sumCIEY = sumCIEY/(float)count;</span>

<span class="nc" id="L5032">        PixelColors pixClr = new PixelColors(sumR, sumG, sumB, sumCIEX,</span>
            sumCIEY);

<span class="nc" id="L5035">        return pixClr;</span>
    }

    private TransformationPointFit evaluateForUnmatchedGreedy(
        TransformationParameters params,
        PairIntArray points1, PairIntArray points2,
        ImageExt img1, ImageExt img2,
        float toleranceTransX, float toleranceTransY) {

<span class="nc" id="L5044">        Transformer transformer = new Transformer();</span>

<span class="nc" id="L5046">        PairFloatArray transformed1 = transformer.applyTransformation2(</span>
            params, points1);

<span class="nc" id="L5049">        PairFloatArray trFiltered1 = new PairFloatArray();</span>
<span class="nc" id="L5050">        PairIntArray filtered2 = new PairIntArray();</span>

<span class="nc" id="L5052">        reduceToIntersection(transformed1, points2, trFiltered1, filtered2,</span>
            toleranceTransX, toleranceTransY);

<span class="nc" id="L5055">        int n = trFiltered1.getN();</span>

<span class="nc" id="L5057">        Set&lt;Integer&gt; chosen = new HashSet&lt;Integer&gt;();</span>

<span class="nc" id="L5059">        double[] diffs = new double[n];</span>
<span class="nc" id="L5060">        int nMatched = 0;</span>
<span class="nc" id="L5061">        double avg = 0;</span>

<span class="nc bnc" id="L5063" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>

<span class="nc" id="L5065">            float transformedX = trFiltered1.getX(i);</span>
<span class="nc" id="L5066">            float transformedY = trFiltered1.getY(i);</span>

<span class="nc" id="L5068">            double minDiff = Double.MAX_VALUE;</span>
<span class="nc" id="L5069">            int min2Idx = -1;</span>

<span class="nc bnc" id="L5071" title="All 2 branches missed.">            for (int j = 0; j &lt; filtered2.getN(); j++) {</span>

<span class="nc bnc" id="L5073" title="All 2 branches missed.">                if (chosen.contains(Integer.valueOf(j))) {</span>
<span class="nc" id="L5074">                    continue;</span>
                }

<span class="nc" id="L5077">                float dx = transformedX - filtered2.getX(j);</span>
<span class="nc" id="L5078">                float dy = transformedY - filtered2.getY(j);</span>

<span class="nc bnc" id="L5080" title="All 2 branches missed.">                if ((Math.abs(dx) &gt; toleranceTransX) ||</span>
<span class="nc bnc" id="L5081" title="All 2 branches missed.">                    (Math.abs(dy) &gt; toleranceTransY)) {</span>
<span class="nc" id="L5082">                    continue;</span>
                }
                
<span class="nc" id="L5085">                boolean looksSimilar = patchesAreSimilar(params, img1, img2, </span>
<span class="nc" id="L5086">                    transformer, points1.getX(i), points1.getY(i));</span>

<span class="nc bnc" id="L5088" title="All 2 branches missed.">                if (!looksSimilar){</span>
<span class="nc" id="L5089">                    continue;</span>
                }

<span class="nc" id="L5092">                float diff = (float)Math.sqrt(dx*dx + dy*dy);</span>

<span class="nc bnc" id="L5094" title="All 2 branches missed.">                if (diff &lt; minDiff) {</span>
<span class="nc" id="L5095">                    minDiff = diff;</span>
<span class="nc" id="L5096">                    min2Idx = j;</span>
                }
            }

<span class="nc bnc" id="L5100" title="All 2 branches missed.">            if (minDiff &lt; Double.MAX_VALUE) {</span>
<span class="nc" id="L5101">                diffs[nMatched] = minDiff;</span>
<span class="nc" id="L5102">                nMatched++;</span>
<span class="nc" id="L5103">                chosen.add(Integer.valueOf(min2Idx));</span>
<span class="nc" id="L5104">                avg += minDiff;</span>
            }
        }

<span class="nc bnc" id="L5108" title="All 2 branches missed.">        avg = (nMatched == 0) ? Double.MAX_VALUE :</span>
            avg / (double)nMatched;

<span class="nc" id="L5111">        double stDev = 0;</span>
<span class="nc bnc" id="L5112" title="All 2 branches missed.">        for (int i = 0; i &lt; nMatched; i++) {</span>
<span class="nc" id="L5113">            double d = diffs[i] - avg;</span>
<span class="nc" id="L5114">            stDev += (d * d);</span>
        }

<span class="nc bnc" id="L5117" title="All 2 branches missed.">        stDev = (nMatched == 0) ? Double.MAX_VALUE :</span>
<span class="nc" id="L5118">            Math.sqrt(stDev/((double)nMatched - 1.));</span>

<span class="nc" id="L5120">        TransformationPointFit fit = new TransformationPointFit(params.copy(),</span>
            nMatched, avg, stDev, toleranceTransX, toleranceTransY);

<span class="nc" id="L5123">        int nMaxMatchable = Math.min(trFiltered1.getN(), filtered2.getN());</span>

<span class="nc" id="L5125">        fit.setMaximumNumberMatchable(nMaxMatchable);</span>

<span class="nc" id="L5127">        return fit;</span>
    }

    private boolean containsOneSimilarWithinTolerance(PixelColors clr1,
        PixelColors[] clr2, double eps) {

<span class="nc" id="L5133">        boolean oneIsSimlar = false;</span>

<span class="nc" id="L5135">        double cieXEps = 0.012;</span>
<span class="nc" id="L5136">        double cieYEps = 0.009;</span>

<span class="nc bnc" id="L5138" title="All 2 branches missed.">        for (int i = 0; i &lt; clr2.length; ++i) {</span>

<span class="nc" id="L5140">            int diffR = Math.abs(clr1.getRed() - clr2[i].getRed());</span>
<span class="nc" id="L5141">            int diffG = Math.abs(clr1.getGreen() - clr2[i].getGreen());</span>
<span class="nc" id="L5142">            int diffB = Math.abs(clr1.getBlue() - clr2[i].getBlue());</span>
<span class="nc" id="L5143">            float diffCIEX = Math.abs(clr1.getCIEX() - clr2[i].getCIEX());</span>
<span class="nc" id="L5144">            float diffCIEY = Math.abs(clr1.getCIEY() - clr2[i].getCIEY());</span>

<span class="nc bnc" id="L5146" title="All 10 branches missed.">            if ((diffR &gt; eps) || (diffG &gt; eps) || (diffB &gt; eps) ||</span>
                (diffCIEX &gt; cieXEps) || (diffCIEY &gt; cieYEps)) {
<span class="nc" id="L5148">                continue;</span>
            }

<span class="nc" id="L5151">            oneIsSimlar = true;</span>

<span class="nc" id="L5153">            break;</span>
        }

<span class="nc" id="L5156">        return oneIsSimlar;</span>
    }

    boolean patchesAreSimilar(TransformationParameters params,
        ImageExt img1, ImageExt img2, Transformer transformer,
        final int x1, final int y1) {

<span class="fc" id="L5163">        final int d = 2;</span>

        // for each pixel (x1, y1) +-d transform the point to image 2
        // and compare the differences.
        // -- compare by division
        // -- compare by sum of block

<span class="fc" id="L5170">        int count = 0;</span>
        //int sumR = 0;
        //int sumG = 0;
        //int sumB = 0;
        
<span class="fc" id="L5175">        double sumRDiv = 0;</span>
<span class="fc" id="L5176">        double sumGDiv = 0;</span>
<span class="fc" id="L5177">        double sumBDiv = 0;</span>
<span class="fc" id="L5178">        double sumCieXDiv = 0;</span>
<span class="fc" id="L5179">        double sumCieYDiv = 0;</span>

<span class="fc bfc" id="L5181" title="All 2 branches covered.">        for (int x = (x1 - d); x &lt;= (x1 + d); ++x) {</span>
<span class="pc bpc" id="L5182" title="2 of 4 branches missed.">            if ((x &lt; 0) || (x &gt; (img1.getWidth() - 1))) {</span>
<span class="nc" id="L5183">                continue;</span>
            }
<span class="fc bfc" id="L5185" title="All 2 branches covered.">            for (int y = (y1 - d); y &lt;= (y1 + d); ++y) {</span>
<span class="pc bpc" id="L5186" title="2 of 4 branches missed.">                if ((y &lt; 0) || (y &gt; (img1.getHeight() - 1))) {</span>
<span class="nc" id="L5187">                    continue;</span>
                }

<span class="fc" id="L5190">                int idx1 = img1.getInternalIndex(x, y);</span>

<span class="fc" id="L5192">                double[] xyT = transformer.applyTransformation(params, x, y);</span>

                // compare to (x2, y2) given as a check
<span class="fc" id="L5195">                int x2T = (int)Math.round(xyT[0]);</span>
<span class="fc" id="L5196">                int y2T = (int)Math.round(xyT[1]);</span>
                
<span class="pc bpc" id="L5198" title="3 of 6 branches missed.">                if ((x2T &lt; 0) || (x2T &gt; (img2.getWidth() - 1)) ||</span>
<span class="pc bpc" id="L5199" title="1 of 2 branches missed.">                    (y2T &lt; 0) || (y2T &gt; (img2.getHeight() - 1))) {</span>
<span class="nc" id="L5200">                    continue;</span>
                }
                
<span class="pc bpc" id="L5203" title="1 of 2 branches missed.">                if (debug) {</span>
<span class="fc bfc" id="L5204" title="All 4 branches covered.">                    if (y == y1 &amp;&amp; x == x1) {</span>
<span class="fc" id="L5205">                        log.info(String.format(&quot;(%d,%d) transformed to img2 (%d,%d)&quot;,</span>
<span class="fc" id="L5206">                            x1, y1, x2T, y2T));</span>
                    }
                }

<span class="fc" id="L5210">                float cieX1 = img1.getCIEX(idx1);</span>
<span class="fc" id="L5211">                float cieY1 = img1.getCIEY(idx1);</span>
<span class="fc" id="L5212">                int r1 = img1.getR(idx1);</span>
<span class="fc" id="L5213">                int g1 = img1.getG(idx1);</span>
<span class="fc" id="L5214">                int b1 = img1.getB(idx1);</span>
                
<span class="fc" id="L5216">                int idx2 = img2.getInternalIndex(x2T, y2T);</span>
<span class="fc" id="L5217">                float cieX2 = img2.getCIEX(idx2);</span>
<span class="fc" id="L5218">                float cieY2 = img2.getCIEY(idx2);</span>
<span class="fc" id="L5219">                int r2 = img2.getR(idx2);</span>
<span class="fc" id="L5220">                int g2 = img2.getG(idx2);</span>
<span class="fc" id="L5221">                int b2 = img2.getB(idx2);</span>

<span class="fc" id="L5223">                float cieXDiv = cieX1/cieX2;</span>
<span class="fc" id="L5224">                float cieYDiv = cieY1/cieY2;</span>
<span class="fc" id="L5225">                float rDiv = (float)r1/(float)r2;</span>
<span class="fc" id="L5226">                float gDiv = (float)g1/(float)g2;</span>
<span class="fc" id="L5227">                float bDiv = (float)b1/(float)b2;</span>

                /*
                int rDiff = Math.abs(r1 - r2);
                int gDiff = Math.abs(g1 - g2);
                int bDiff = Math.abs(b1 - b2);

                log.info(&quot;cieXDiv=+ &quot; + cieXDiv + &quot; cieYDiv=&quot; + cieYDiv
                    + &quot; rDiv=&quot; + rDiv + &quot; gDiv=&quot; + gDiv + &quot; bDiv=&quot; + bDiv
                    + &quot; rDiff=&quot; + rDiff + &quot; gDiff=&quot; + gDiff + &quot; bDiff=&quot; + bDiff
                );

                sumR += rDiff;
                sumG += gDiff;
                sumB += bDiff;
                */

<span class="fc" id="L5244">                sumRDiv += rDiv;</span>
<span class="fc" id="L5245">                sumGDiv += gDiv;</span>
<span class="fc" id="L5246">                sumBDiv += bDiv;</span>
                
<span class="fc" id="L5248">                sumCieXDiv += cieXDiv;</span>
<span class="fc" id="L5249">                sumCieYDiv += cieYDiv;</span>
                
<span class="fc" id="L5251">                count++;</span>
            }
        }
        
<span class="pc bpc" id="L5255" title="1 of 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L5256">            return false;</span>
        }

        /*float rAvg = (float)sumR/(float)count;
        float gAvg = (float)sumG/(float)count;
        float bAvg = (float)sumB/(float)count;
        */
        
<span class="fc" id="L5264">        double rDivAvg = sumRDiv/(double)count;</span>
<span class="fc" id="L5265">        double gDivAvg = sumGDiv/(double)count;</span>
<span class="fc" id="L5266">        double bDivAvg = sumBDiv/(double)count;</span>
        
<span class="fc" id="L5268">        double cieXDivAvg = sumCieXDiv/(double)count;</span>
<span class="fc" id="L5269">        double cieYDivAvg = sumCieYDiv/(double)count;</span>
        
<span class="pc bpc" id="L5271" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="fc" id="L5272">            log.info(&quot;rDivAvg=+ &quot; + rDivAvg + &quot; gDivAvg=&quot; + gDivAvg + </span>
                &quot; bDivAvg=&quot; + bDivAvg 
                + &quot; cieXDivAvg=&quot; + cieXDivAvg + &quot; cieYDivAvg=&quot; + cieYDivAvg);
        }

<span class="pc bpc" id="L5277" title="1 of 6 branches missed.">        if ((rDivAvg &lt; 0.84) || (gDivAvg &lt; 0.84) || (bDivAvg &lt; 0.84)) {</span>
<span class="fc" id="L5278">            return false;</span>
        }
        
<span class="pc bpc" id="L5281" title="1 of 6 branches missed.">        if ((rDivAvg &gt; 1.19) || (gDivAvg &gt; 1.19) || (bDivAvg &gt; 1.19)) {</span>
<span class="fc" id="L5282">            return false;</span>
        }

<span class="fc" id="L5285">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
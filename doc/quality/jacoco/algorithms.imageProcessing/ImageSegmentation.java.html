<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageSegmentation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageSegmentation.java</span></div><h1>ImageSegmentation.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.CountingSort;
import algorithms.compGeometry.clustering.KMeansPlusPlus;
import algorithms.compGeometry.clustering.KMeansPlusPlusFloat;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonAndPointPlotter;
import algorithms.util.ResourceFinder;
import com.climbwithyourfeet.clustering.DTClusterFinder;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * class holding several different image segmentation methods.  Note that
 * some other techniques involving contrast for example, are elsewhere.
 * 
 * @author nichole
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public class ImageSegmentation {</span>
    
<span class="fc" id="L40">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    /**
     * applies KMeansPlusPlus algorithm to the values in input 
     * (greyscale intensities) to create kBands of clustered pixels 
     * (operates on input).
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */
    public void applyUsingKMPP(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L54">        KMeansPlusPlus instance = new KMeansPlusPlus();</span>
<span class="fc" id="L55">        instance.computeMeans(kBands, input);</span>

<span class="fc" id="L57">        int[] binCenters = instance.getCenters();</span>

<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="fc bfc" id="L61" title="All 2 branches covered.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="fc" id="L63">                int v = input.getValue(col, row);</span>

<span class="pc bpc" id="L65" title="1 of 2 branches missed.">                for (int i = 0; i &lt; binCenters.length; i++) {</span>

<span class="fc" id="L67">                    int vc = binCenters[i];</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">                    int bisectorBelow = ((i - 1) &gt; -1) ?</span>
                        ((binCenters[i - 1] + vc) / 2) : 0;

<span class="fc bfc" id="L72" title="All 2 branches covered.">                    int bisectorAbove = ((i + 1) &gt; (binCenters.length - 1)) ?</span>
                        255 : ((binCenters[i + 1] + vc) / 2);

<span class="pc bpc" id="L75" title="1 of 4 branches missed.">                    if ((v &gt;= bisectorBelow) &amp;&amp; (v &lt;= bisectorAbove)) {</span>

<span class="fc" id="L77">                        input.setValue(col, row, vc);</span>

<span class="fc" id="L79">                        break;</span>
                    }
                }
            }
        }
<span class="fc" id="L84">    }</span>
    
    /**
     * applies a blur of sigma=1 to image,
     * converts each pixel color to the polar angle of CIE XY Lab color space
     * with an origin of (0.35, 0.35) and uses a histogram binning of kColors=8,
     * then maps those bins to 0 to 255,
     * then replaces a pixel if 5,6 or its neighbors have the same color,
     * then applies histogram equalization to stretch the values to range 
     * 0 to 255.
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistEq(ImageExt input) {

<span class="nc" id="L99">        int kColors = 8;</span>

<span class="nc" id="L101">        return applyUsingCIEXYPolarThetaThenHistEq(input, kColors, true);</span>
    }

    /**
     * converts each pixel color to the polar angle of CIE XY Lab color space
     * with an origin of (0.35, 0.35) and uses a histogram binning of kColors,
     * then maps those bins to 0 to 255,
     * then replaces a pixel if 5,6 or its neighbors have the same color,
     * then applies histogram equalization to stretch the values to range 
     * 0 to 255.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur if true, a blur of sigma=1 is applied to the image before
     * processing.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistEq(ImageExt input,
        int kColors, boolean useBlur) {

<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L125">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }
        
<span class="fc" id="L128">        ImageProcessor imageProcessor = new ImageProcessor();</span>

        GreyscaleImage img;

        int minNeighborLimit;

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (useBlur) {</span>

<span class="fc" id="L136">            Image input2 = input.copyImage();</span>

<span class="fc" id="L138">            imageProcessor.blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="fc" id="L140">            img = applyUsingCIEXYPolarThetaThenHistogram(input2, kColors);</span>

<span class="fc" id="L142">            minNeighborLimit = 6;</span>

<span class="fc" id="L144">        } else {</span>

<span class="nc" id="L146">            img = applyUsingCIEXYPolarThetaThenHistogram(input, kColors);</span>

<span class="nc" id="L148">            minNeighborLimit = 5;</span>
        }

<span class="fc" id="L151">        int w = img.getWidth();</span>
<span class="fc" id="L152">        int h = img.getHeight();</span>

        // ----replace pixel, if 5,6 or more neighbors have same color -----
<span class="fc" id="L155">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L156">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="fc" id="L158">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="fc" id="L160">        int nChanged = 1;</span>
<span class="fc" id="L161">        int nIterMax = 100;</span>
<span class="fc" id="L162">        int nIter = 0;</span>

<span class="pc bpc" id="L164" title="5 of 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="nc" id="L166">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="nc" id="L168">            nChanged = 0;</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L173">                    freqMap.clear();</span>

<span class="nc" id="L175">                    Integer maxCountValue = null;</span>
<span class="nc" id="L176">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="nc" id="L179">                        int x = dxs[nIdx] + col;</span>
<span class="nc" id="L180">                        int y = dys[nIdx] + row;</span>

<span class="nc bnc" id="L182" title="All 8 branches missed.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L183">                            break;</span>
                        }

<span class="nc" id="L186">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="nc" id="L188">                        Integer c = freqMap.get(v);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L190">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="nc" id="L192">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="nc" id="L194">                        freqMap.put(v, c);</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="nc" id="L197">                            maxCount = c.intValue();</span>
<span class="nc" id="L198">                            maxCountValue = v;</span>
                        }
                    }

<span class="nc bnc" id="L202" title="All 2 branches missed.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="nc" id="L205">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="nc" id="L206">                        nChanged++;</span>
                    }
                }
            }

<span class="nc" id="L211">            nIter++;</span>
        }

        // rescale the image
<span class="fc" id="L215">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="fc" id="L216">        hEq.applyFilter();</span>

<span class="fc" id="L218">        return img;</span>
    }

    /**
     * applies a blur of sigma=1 to image,
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors=8 bins points then remaps the points to use the
     * range 0 to 255, then replaces a pixel if it has 7 neighbors of same 
     * color, then applies histogram equalization to rescale the range to be
     * between 0 and 255.
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPPThenHistEq(ImageExt
        input) {

<span class="nc" id="L234">        int kColors = 8;</span>

<span class="nc" id="L236">        return applyUsingCIEXYPolarThetaThenKMPPThenHistEq(input, kColors, true);</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors bins points then remaps the points to use the
     * range 0 to 255, then replaces a pixel if it has 5,6 neighbors of same 
     * color, then applies histogram equalization to rescale the range to be
     * between 0 and 255.
     * 
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPPThenHistEq(ImageExt input,
        int kColors, boolean useBlur) {

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L256">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

<span class="fc" id="L262">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
        GreyscaleImage img;

        int minNeighborLimit;

<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (useBlur) {</span>

<span class="fc" id="L270">            Image input2 = input.copyImage();</span>

<span class="fc" id="L272">            imageProcessor.blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="fc" id="L274">            img = applyUsingCIEXYPolarThetaThenKMPP(input2, kColors);</span>

<span class="fc" id="L276">            minNeighborLimit = 6;</span>

<span class="fc" id="L278">        } else {</span>

<span class="fc" id="L280">            img = applyUsingCIEXYPolarThetaThenKMPP(input, kColors);</span>

<span class="fc" id="L282">            minNeighborLimit = 5;</span>
        }

<span class="fc" id="L285">        int w = img.getWidth();</span>
<span class="fc" id="L286">        int h = img.getHeight();</span>

        // ----replace pixel, if 5,6 or more neighbors have same color -----
<span class="fc" id="L289">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L290">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="fc" id="L292">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="fc" id="L294">        int nChanged = 1;</span>
<span class="fc" id="L295">        int nIterMax = 100;</span>
<span class="fc" id="L296">        int nIter = 0;</span>

<span class="pc bpc" id="L298" title="1 of 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="fc" id="L300">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="fc" id="L302">            nChanged = 0;</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="fc" id="L307">                    freqMap.clear();</span>

<span class="fc" id="L309">                    Integer maxCountValue = null;</span>
<span class="fc" id="L310">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="fc" id="L313">                        int x = dxs[nIdx] + col;</span>
<span class="fc" id="L314">                        int y = dys[nIdx] + row;</span>

<span class="fc bfc" id="L316" title="All 8 branches covered.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="fc" id="L317">                            break;</span>
                        }

<span class="fc" id="L320">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="fc" id="L322">                        Integer c = freqMap.get(v);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                        if (c == null) {</span>
<span class="fc" id="L324">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="fc" id="L326">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="fc" id="L328">                        freqMap.put(v, c);</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="fc" id="L331">                            maxCount = c.intValue();</span>
<span class="fc" id="L332">                            maxCountValue = v;</span>
                        }
                    }

<span class="fc bfc" id="L336" title="All 2 branches covered.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="fc" id="L339">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="fc" id="L340">                        nChanged++;</span>
                    }
                }
            }

<span class="fc" id="L345">            nIter++;</span>
        }

        // rescale the image
<span class="fc" id="L349">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="fc" id="L350">        hEq.applyFilter();</span>

<span class="fc" id="L352">        return img;</span>
    }
    
    /**
     * converts each pixel's color into CIE XY polar theta,  
     * then applies histogram mapping of kColors to remap the pixels to
     * values between 0 and 255.
     *
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistogram(Image input) {

<span class="nc" id="L365">        return applyUsingCIEXYPolarThetaThenHistogram(input, 254);</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta,  
     * then applies histogram mapping of kColors to remap the pixels to
     * values between 0 and 255.
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistogram(Image input, 
        int kColors) {

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L382">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L385">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="fc" id="L395">        int w = input.getWidth();</span>
<span class="fc" id="L396">        int h = input.getHeight();</span>

<span class="fc" id="L398">        float[] tmpColorBuffer = new float[2];</span>

<span class="fc" id="L400">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="fc" id="L402">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="fc" id="L404">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L406">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="fc" id="L407">        int thetaCount = 0;</span>

<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="fc" id="L412">                PairInt p = new PairInt(col, row);</span>

<span class="fc" id="L414">                int r = input.getR(col, row);</span>
<span class="fc" id="L415">                int g = input.getG(col, row);</span>
<span class="fc" id="L416">                int b = input.getB(col, row);</span>

<span class="fc bfc" id="L418" title="All 6 branches covered.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="fc" id="L419">                    continue;</span>
<span class="fc bfc" id="L420" title="All 6 branches covered.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="fc" id="L421">                    output.setValue(col, row, 255);</span>
<span class="fc" id="L422">                    continue;</span>
                }

<span class="fc" id="L425">                float[] cieXY = tmpColorBuffer;</span>
<span class="fc" id="L426">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="fc" id="L429">                    output.setValue(col, row, 255);</span>
                } else {

<span class="fc" id="L432">                    double thetaRadians = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="fc" id="L434">                    thetaValues[thetaCount] = (float)thetaRadians;</span>

<span class="fc" id="L436">                    pixThetaMap.put(p, Float.valueOf((float)thetaRadians));</span>

<span class="fc" id="L438">                    thetaCount++;</span>
                }
            }
        }

<span class="fc" id="L443">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="fc" id="L445">        createAndApplyHistMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="fc" id="L447">        return output;</span>
    }
    
    /**
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors bins points then remaps the points to use the
     * range 0 to 255.
     *
     * runtime complexity is O(N) + O(N*lg_2(N))
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPP(Image input, int kColors) {

<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L465">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L468">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="fc" id="L478">        int w = input.getWidth();</span>
<span class="fc" id="L479">        int h = input.getHeight();</span>

<span class="fc" id="L481">        float[] tmpColorBuffer = new float[2];</span>

<span class="fc" id="L483">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="fc" id="L485">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="fc" id="L487">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L489">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="fc" id="L490">        int thetaCount = 0;</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="fc" id="L495">                PairInt p = new PairInt(col, row);</span>

<span class="fc" id="L497">                int r = input.getR(col, row);</span>
<span class="fc" id="L498">                int g = input.getG(col, row);</span>
<span class="fc" id="L499">                int b = input.getB(col, row);</span>

<span class="fc bfc" id="L501" title="All 6 branches covered.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="fc" id="L502">                    continue;</span>
<span class="fc bfc" id="L503" title="All 6 branches covered.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="fc" id="L504">                    output.setValue(col, row, 255);</span>
<span class="fc" id="L505">                    continue;</span>
                }

<span class="fc" id="L508">                float[] cieXY = tmpColorBuffer;</span>
<span class="fc" id="L509">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="fc bfc" id="L511" title="All 2 branches covered.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="fc" id="L512">                    output.setValue(col, row, 255);</span>
                } else {

<span class="fc" id="L515">                    double thetaRadians = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="fc" id="L517">                    thetaValues[thetaCount] = (float)thetaRadians;</span>

<span class="fc" id="L519">                    pixThetaMap.put(p, Float.valueOf((float)thetaRadians));</span>

<span class="fc" id="L521">                    thetaCount++;</span>
                }
            }
        }

<span class="fc" id="L526">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="fc" id="L528">        createAndApplyKMPPMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="fc" id="L530">        return output;</span>
    }
    
    private void createAndApplyKMPPMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

        //TODO: assert kColors.  The invoker is reserving 2 bands for
        // B &amp; W, so nBins should probably be (kColors - 2)...
        // correct this for the invoker when testing
<span class="fc" id="L540">        int nBins = kColors;</span>

<span class="fc" id="L542">        KMeansPlusPlusFloat kmpp = new KMeansPlusPlusFloat();</span>
<span class="fc" id="L543">        kmpp.computeMeans(nBins, thetaValues);</span>

<span class="fc" id="L545">        float minValue = kmpp.getMinValue();</span>
<span class="fc" id="L546">        float maxValue = kmpp.getMaxValue();</span>

<span class="fc" id="L548">        float[] binCenters = kmpp.getCenters();</span>

<span class="fc" id="L550">        Iterator&lt;Map.Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

<span class="fc bfc" id="L552" title="All 2 branches covered.">        while (iter.hasNext()) {</span>

<span class="fc" id="L554">            Map.Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="fc" id="L556">            PairInt p = entry.getKey();</span>

<span class="fc" id="L558">            float theta = entry.getValue().floatValue();</span>

<span class="pc bpc" id="L560" title="1 of 2 branches missed.">            for (int i = 0; i &lt; binCenters.length; i++) {</span>

<span class="fc" id="L562">                float vc = binCenters[i];</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">                float bisectorBelow = ((i - 1) &gt; -1) ?</span>
                    ((binCenters[i - 1] + vc) / 2) : minValue;

<span class="fc bfc" id="L567" title="All 2 branches covered.">                float bisectorAbove = ((i + 1) &gt; (binCenters.length - 1)) ?</span>
                    maxValue : ((binCenters[i + 1] + vc) / 2);

<span class="pc bpc" id="L570" title="1 of 4 branches missed.">                if ((theta &gt;= bisectorBelow) &amp;&amp; (theta &lt;= bisectorAbove)) {</span>

                    //TODO: check this
<span class="fc" id="L573">                    int mappedValue = 255 - nBins + i;</span>

<span class="fc" id="L575">                    output.setValue(p.getX(), p.getY(), mappedValue);</span>

<span class="fc" id="L577">                    break;</span>
                }
            }

            /*
            // if binCenters is ordered, use binary search for faster results
            int idx = Arrays.binarySearch(startBins, theta);

            // if it's negative, (-(insertion point) - 1)
            if (idx &lt; 0) {
                // idx = -*idx2 - 1
                idx = -1*(idx + 1);
            }
            int mappedValue = 255 - startBins.length + idx;

            output.setValue(p.getX(), p.getY(), mappedValue);
            */
<span class="fc" id="L594">        }</span>
<span class="fc" id="L595">    }</span>
    
    private void createAndApplyHistMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

<span class="fc" id="L601">        float minValue = MiscMath.findMin(thetaValues);</span>
<span class="fc" id="L602">        float maxValue = MiscMath.findMax(thetaValues);</span>

<span class="fc" id="L604">        log.fine(&quot;minTheta=&quot; + (minValue * 180./Math.PI) +</span>
            &quot; maxTheta=&quot; + (maxValue * 180./Math.PI));

<span class="fc" id="L607">        int nReserved = 254 - kColors;</span>

<span class="fc" id="L609">        HistogramHolder hist = Histogram.createSimpleHistogram(minValue,</span>
            maxValue, (256 - nReserved - 1), thetaValues,
<span class="fc" id="L611">            Errors.populateYErrorsBySqrt(thetaValues));</span>

        try {
<span class="fc" id="L614">            hist.plotHistogram(&quot;cie XY theta histogram&quot;, &quot;cieXY_hist_&quot;</span>
<span class="fc" id="L615">                + MiscDebug.getCurrentTimeFormatted());</span>
<span class="pc" id="L616">        } catch (Exception e) {}</span>

<span class="fc" id="L618">        int nonZeroCount = 0;</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="fc" id="L620">            int c = hist.getYHist()[i];</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (c &gt; 0) {</span>
<span class="fc" id="L622">                nonZeroCount++;</span>
            }
        }

<span class="fc" id="L626">        float[] startBins = new float[nonZeroCount];</span>

<span class="fc" id="L628">        float halfBinWidth = (hist.getXHist()[1] - hist.getXHist()[0])/2.f;</span>

<span class="fc" id="L630">        nonZeroCount = 0;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="fc" id="L632">            int c = hist.getYHist()[i];</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (c &gt; 0) {</span>
<span class="fc" id="L634">                startBins[nonZeroCount] = hist.getXHist()[i] - halfBinWidth;</span>
<span class="fc" id="L635">                nonZeroCount++;</span>
            }
        }

<span class="fc" id="L639">        Iterator&lt;Map.Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

        // O(N * lg_2(N))
<span class="fc bfc" id="L642" title="All 2 branches covered.">        while (iter.hasNext()) {</span>

<span class="fc" id="L644">            Map.Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="fc" id="L646">            PairInt p = entry.getKey();</span>

<span class="fc" id="L648">            float theta = entry.getValue().floatValue();</span>

<span class="fc" id="L650">            int idx = Arrays.binarySearch(startBins, theta);</span>

            // if it's negative, (-(insertion point) - 1)
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">            if (idx &lt; 0) {</span>
                // idx = -*idx2 - 1
<span class="fc" id="L655">                idx = -1*(idx + 1);</span>
            }

<span class="fc" id="L658">            int mappedValue = 255 - startBins.length + idx;</span>

<span class="fc" id="L660">            output.setValue(p.getX(), p.getY(), mappedValue);</span>
<span class="fc" id="L661">        }</span>
<span class="fc" id="L662">    }</span>
    
    /**
     * NOT READY FOR USE.  STILL EXPERIMENTING.
     * 
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to CIEXY Lab color space, then creates a map of the 
     * CIEX and CIEY points and uses density based clustering  
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters of points in CIE X, CIEY space,
     * then merges pixels in the grey list with adjacent clusters if 
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * 
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * cie xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * 
     * @param input
     * @param useBlur
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingCIEXYAndClustering(ImageExt input,
        boolean useBlur) {

        //TODO: improve the clustering results in two ways:
        // (1) for smaller ciexy clusters, merge with adjacent clusters if
        //     similar color
        // (2) any pixel with 7 neighbors of same color should be that color too
        
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if (useBlur) {</span>
<span class="fc" id="L696">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L697">            imageProcessor.blur(input, 1.0f);</span>
        }

        //TODO: consider making a segmentation method using CIEXY theta
        // for x and the frequency for y, both scaled to numerically
        // resolvable range &lt; max of 5000.
        // this would be good to compare to the method here which
        // uses CIE XY Theta followed by histograms or KMeans++.
        // No need to specify the number of bins before use for suggested
        // version.

        //NOTE: the method needs to have gaps in the data given to it
        //    that is a lack of points for some region between the
        //    min and max of x and y data in integer space

        // max = 6250 unless reduce space complexity
<span class="fc" id="L713">        float factor = 2000;// learn this from numerical resolution</span>

        // then subtract the minima in both cieX and cieY

<span class="fc" id="L717">        int minCIEX = Integer.MAX_VALUE;</span>
<span class="fc" id="L718">        int minCIEY = Integer.MAX_VALUE;</span>
<span class="fc" id="L719">        int maxCIEX = Integer.MIN_VALUE;</span>
<span class="fc" id="L720">        int maxCIEY = Integer.MIN_VALUE;</span>

<span class="fc" id="L722">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L724">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>
        
<span class="fc" id="L726">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L728">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L730">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>
                
        // -------- debug -------
<span class="fc" id="L733">        int nGrey = 0;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L735">            nGrey += entry.getValue().size();</span>
<span class="fc" id="L736">        }</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        assert((points0.size() + blackPixels.size() + nGrey + </span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">            whitePixels.size()) == input.getNPixels());</span>
        // -------- end debug -------

<span class="fc" id="L741">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>
        
        // ------- debug -------
<span class="fc" id="L744">        int nGrey2 = 0;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="fc" id="L746">            nGrey2 += set.size();</span>
<span class="fc" id="L747">        }</span>
<span class="pc bpc" id="L748" title="3 of 4 branches missed.">        assert(nGrey == nGrey2);</span>
        // ------- end debug =====
        
<span class="fc" id="L751">        Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap0 =</span>
            new HashMap&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt;();

<span class="fc bfc" id="L754" title="All 2 branches covered.">        for (PairInt p : points0) {</span>
<span class="fc" id="L755">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="fc" id="L756">            float cx = input.getCIEX(idx);</span>
<span class="fc" id="L757">            float cy = input.getCIEY(idx);               </span>
            
<span class="fc" id="L759">            int cieXInt = Math.round(factor * cx);</span>
<span class="fc" id="L760">            int cieYInt = Math.round(factor * cy);</span>

<span class="fc" id="L762">            PairIntWithIndex p0 = new PairIntWithIndex(cieXInt, cieYInt, idx);</span>
<span class="fc" id="L763">            List&lt;PairIntWithIndex&gt; list = pointsMap0.get(p0);</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L765">                list = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="fc" id="L766">                pointsMap0.put(p0, list);</span>
            }
<span class="fc" id="L768">            list.add(p0);</span>

<span class="fc bfc" id="L770" title="All 2 branches covered.">            if (cieXInt &lt; minCIEX) {</span>
<span class="fc" id="L771">                minCIEX = cieXInt;</span>
            }
<span class="fc bfc" id="L773" title="All 2 branches covered.">            if (cieYInt &lt; minCIEY) {</span>
<span class="fc" id="L774">                minCIEY = cieYInt;</span>
            }
<span class="fc bfc" id="L776" title="All 2 branches covered.">            if (cieXInt &gt; maxCIEX) {</span>
<span class="fc" id="L777">                maxCIEX = cieXInt;</span>
            }
<span class="fc bfc" id="L779" title="All 2 branches covered.">            if (cieYInt &gt; maxCIEY) {</span>
<span class="fc" id="L780">                maxCIEY = cieYInt;</span>
            }
<span class="fc" id="L782">        }</span>

<span class="fc" id="L784">        Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap =</span>
            new HashMap&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt;();

        // subtract minima from the points
<span class="fc bfc" id="L788" title="All 2 branches covered.">        for (PairIntWithIndex p : pointsMap0.keySet()) {</span>

<span class="fc" id="L790">            int x = p.getX() - minCIEX;</span>
<span class="fc" id="L791">            int y = p.getY() - minCIEY;</span>

<span class="fc" id="L793">            PairIntWithIndex p2 = new PairIntWithIndex(x, y, p.pixIdx);</span>
<span class="fc" id="L794">            List&lt;PairIntWithIndex&gt; list2 = pointsMap.get(p2);</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">            if (list2 == null) {</span>
<span class="fc" id="L796">                list2 = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="fc" id="L797">                pointsMap.put(p2, list2);</span>
            }
            // because this is a list, this will eventually be present twice:
            //list2.add(p2);

<span class="fc bfc" id="L802" title="All 2 branches covered.">            for (PairIntWithIndex p0 : pointsMap0.get(p)) {</span>
<span class="fc" id="L803">                PairIntWithIndex p3 = new PairIntWithIndex(</span>
<span class="fc" id="L804">                    p0.getX() - minCIEX, p0.getY() - minCIEY, p0.pixIdx);</span>
<span class="fc" id="L805">                list2.add(p3);</span>
<span class="fc" id="L806">            }</span>
<span class="fc" id="L807">        }</span>
<span class="fc" id="L808">        maxCIEX -= minCIEX;</span>
<span class="fc" id="L809">        maxCIEY -= minCIEY;</span>

        // frequency of colors:
<span class="fc" id="L812">        Map&lt;PairIntWithIndex, Integer&gt; freqMap = new</span>
            HashMap&lt;PairIntWithIndex, Integer&gt;();
        for (Map.Entry&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; entry :
<span class="fc bfc" id="L815" title="All 2 branches covered.">            pointsMap.entrySet()) {</span>
<span class="fc" id="L816">            int c = entry.getValue().size();</span>
<span class="fc" id="L817">            freqMap.put(entry.getKey(), Integer.valueOf(c));</span>
<span class="fc" id="L818">        }</span>

        // ----- debug ---
<span class="fc" id="L821">        int nGreyBW = nGrey + blackPixels.size() + whitePixels.size();</span>
<span class="fc" id="L822">        int nTot = 0;</span>
        //Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap
<span class="fc bfc" id="L824" title="All 2 branches covered.">        for (Entry&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; entry : pointsMap.entrySet()) {</span>
<span class="fc" id="L825">            nTot += entry.getValue().size();</span>
<span class="fc" id="L826">        }</span>
<span class="fc" id="L827">        nTot += nGreyBW;</span>
<span class="fc" id="L828">        log.info(&quot;nTot=&quot; + nTot + &quot; nPixels=&quot; + input.getNPixels());</span>
<span class="pc bpc" id="L829" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        
        // plot the points as an image to see the data first
<span class="fc" id="L832">        GreyscaleImage img = new GreyscaleImage(maxCIEX + 1, maxCIEY + 1);</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">        for (com.climbwithyourfeet.clustering.util.PairInt p : pointsMap.keySet()) {</span>
<span class="fc" id="L834">            img.setValue(p.getX(), p.getY(), 255);</span>
<span class="fc" id="L835">        }</span>
        try {
<span class="fc" id="L837">            ImageIOHelper.writeOutputImage(</span>
<span class="fc" id="L838">                ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt_input.png&quot;, img);</span>
<span class="nc" id="L839">        } catch (IOException ex) {</span>
<span class="nc" id="L840">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="fc" id="L842">        }</span>
        // --- end debug

        //Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap
        
<span class="fc" id="L847">        DTClusterFinder&lt;PairIntWithIndex&gt; clusterFinder </span>
<span class="fc" id="L848">            = new DTClusterFinder&lt;PairIntWithIndex&gt;(pointsMap.keySet(),</span>
            maxCIEX + 1, maxCIEY + 1);

<span class="fc" id="L851">        clusterFinder.setToDebug();</span>

        // to recover every point, set limit to 1
<span class="fc" id="L854">        clusterFinder.setMinimumNumberInCluster(1);</span>

<span class="fc" id="L856">        clusterFinder.calculateCriticalDensity();</span>

<span class="fc" id="L858">        clusterFinder.findClusters();</span>
        
<span class="fc" id="L860">        log.info(&quot;clustering critical density=&quot; + clusterFinder.getCriticalDensity());</span>

<span class="fc" id="L862">        int nGroups = clusterFinder.getNumberOfClusters();</span>

<span class="fc" id="L864">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="fc bfc" id="L866" title="All 2 branches covered.">        for (int k = 0; k &lt; nGroups; ++k) {</span>
            
<span class="fc" id="L868">            Set&lt;PairIntWithIndex&gt; group = clusterFinder.getCluster(k);</span>

<span class="fc" id="L870">            Set&lt;PairInt&gt; coordPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L872" title="All 2 branches covered.">            for (PairIntWithIndex p : group) {</span>

<span class="fc" id="L874">                int idx = p.pixIdx;</span>
<span class="fc" id="L875">                int xCoord = input.getCol(idx);</span>
<span class="fc" id="L876">                int yCoord = input.getRow(idx);</span>

<span class="fc" id="L878">                PairInt pCoord = new PairInt(xCoord, yCoord);</span>
<span class="fc" id="L879">                coordPoints.add(pCoord);</span>

                // include the other points of/ same color
<span class="fc" id="L882">                List&lt;PairIntWithIndex&gt; list = pointsMap.get(p);</span>
<span class="pc bpc" id="L883" title="3 of 4 branches missed.">                assert(list != null);</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                for (PairIntWithIndex p3 : list) {</span>
<span class="fc" id="L885">                    int idx3 = p3.pixIdx;</span>
<span class="fc" id="L886">                    int xCoord3 = input.getCol(idx3);</span>
<span class="fc" id="L887">                    int yCoord3 = input.getRow(idx3);</span>
<span class="fc" id="L888">                    pCoord = new PairInt(xCoord3, yCoord3);</span>
<span class="fc" id="L889">                    coordPoints.add(pCoord);</span>
<span class="fc" id="L890">                }</span>
<span class="fc" id="L891">            }</span>

<span class="fc" id="L893">            groupList.add(coordPoints);</span>
        }
        
        // ------ debug ---------
<span class="fc" id="L897">        nTot = 0;</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : groupList) {</span>
<span class="fc" id="L899">            nTot += set.size();</span>
<span class="fc" id="L900">        }</span>
<span class="fc" id="L901">        nTot += nGreyBW;</span>
<span class="fc" id="L902">        log.info(&quot;nTot=&quot; + nTot + &quot; nPixels=&quot; + input.getNPixels());</span>
<span class="pc bpc" id="L903" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // ------ end debug -----
        
<span class="fc" id="L906">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList, </span>
            blackPixels, whitePixels);
        
        // add back in blackPixels and whitePixels
<span class="fc" id="L910">        groupList.add(blackPixels);</span>
<span class="fc" id="L911">        groupList.add(whitePixels);</span>
        
<span class="fc" id="L913">        int nTot2 = 0;</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; groups : groupList) {</span>
<span class="fc" id="L915">            nTot2 += groups.size();</span>
<span class="fc" id="L916">        }</span>
           
<span class="fc" id="L918">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot2=&quot; + nTot2);</span>
<span class="pc bpc" id="L919" title="3 of 4 branches missed.">        assert(nTot2 == input.getNPixels());</span>

<span class="fc" id="L921">        return groupList;</span>
    }
    
    /**     
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the 
     * polar angles and the number of pixels with those angles (=frequency)
     * and uses density based clustering  
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters in that space (polar CIEXY vs frequency),
     * then merges pixels in the grey list with adjacent clusters if 
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameters are the scaling of the range of polar angles
     * and the range of frequency in order to place the data between values of 0
     * and a number.
     * &lt;code&gt;The scale factors are double xFactor = 2000. and int yFactor = 2000
     * for example.  Smaller scale factors result in faster runtimes,
     * but must be balanced by a large enough factor to have cluster resulution.
     * &lt;/code&gt;
     * Note that the polar angle vs frequency maps are actually partitioned into
     * 4 maps to do density based cluster finding separately.
     * partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f} is the fraction of
     * the maximum frequency defining a partition.
     * 
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * 
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return 
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndClustering(ImageExt input,
        boolean useBlur) {

<span class="pc bpc" id="L960" title="1 of 2 branches missed.">        if (useBlur) {</span>
<span class="fc" id="L961">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L962">            imageProcessor.blur(input, 1.0f);</span>
        }

        //making a segmentation method using CIEXY theta
        // for x and the frequency for y, both scaled to numerically
        // resolvable range &lt; max of 5000.
        // this would be good to compare to the method here which
        // uses CIE XY Theta followed by histograms or KMeans++.
        // No need to specify the number of bins before use for suggested
        // version.

<span class="fc" id="L973">        int w = input.getWidth();</span>
<span class="fc" id="L974">        int h = input.getHeight();</span>
        
<span class="fc" id="L976">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L978">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>
        
<span class="fc" id="L980">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L982">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L984">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>
        
<span class="fc" id="L986">        double[] minMaxTheta0 = findMinMaxTheta(input, points0);</span>
        
<span class="fc" id="L988">        log.info(&quot;for all non-white and non-black, minTheta=&quot; + minMaxTheta0[0]</span>
            + &quot; maxTheta=&quot; + minMaxTheta0[1]);
        
        // -------- debug -------
<span class="fc" id="L992">        int nGrey = 0;</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L994">            nGrey += entry.getValue().size();</span>
<span class="fc" id="L995">        }</span>
<span class="fc" id="L996">        int nGreyBW = + blackPixels.size() + nGrey + whitePixels.size();</span>
<span class="fc" id="L997">        int nTot = (points0.size() + nGreyBW);</span>
<span class="fc" id="L998">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="pc bpc" id="L999" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // -------- end debug -------

<span class="fc" id="L1002">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>
        
<span class="fc" id="L1004">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(greyPixelGroups.size());</span>
        
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">             if (points0.isEmpty()) {</span>
<span class="nc" id="L1008">                 groupList.add(points0);</span>
             }
<span class="nc bnc" id="L1010" title="All 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="nc" id="L1011">                 groupList.add(blackPixels);</span>
             }
<span class="nc bnc" id="L1013" title="All 2 branches missed.">             for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc" id="L1014">                groupList.add(set);</span>
<span class="nc" id="L1015">             }</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L1017">                 groupList.add(whitePixels);</span>
             }
<span class="nc" id="L1019">             return groupList;</span>
        }
        
<span class="fc" id="L1022">        double xFactor = 2000.;</span>
<span class="fc" id="L1023">        int yFactor = 2000;</span>
        
<span class="fc" id="L1025">        double[] minMaxTheta = new double[2];</span>
<span class="fc" id="L1026">        int[] minMaxFreq = new int[2];</span>
<span class="fc" id="L1027">        double thetaFactor0 = xFactor/(minMaxTheta0[1] - minMaxTheta0[0]);</span>
<span class="fc" id="L1028">        Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap = createThetaCIEXYMap(points0,</span>
            input, minMaxTheta0[0], thetaFactor0, minMaxTheta, minMaxFreq);

        // ---- debug ------
<span class="fc" id="L1032">        nTot = nGreyBW;</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="fc" id="L1034">            nTot += entry.getValue().size();</span>
<span class="fc" id="L1035">        }</span>
<span class="fc" id="L1036">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="pc bpc" id="L1037" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // ----- end debug ------
        
        /* ---- create frequency maps partitioned by given fractions ----
        starting w/ partitions at 3 percent (maybe discard below),
            15 percent, and 25 percent resulting in 4 maps
        
        For each map:
            key is pairint w/ x=theta, y=freq,
            value is all pixels having same key
        */
        
<span class="fc" id="L1049">        final float[] partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f};</span>
        
        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="fc" id="L1052">            List&lt;PairIntWithIndex&gt;&gt;&gt; thetaFreqMaps =</span>
<span class="fc" id="L1053">            partitionIntoFrequencyMaps(input, thetaPointMap,</span>
                partitionFreqFracs, minMaxFreq[1]);
        
        //---- debug, assert number of pixels ----
<span class="fc" id="L1057">        nTot = nGreyBW;</span>
        for (Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        List&lt;PairIntWithIndex&gt;&gt; map : thetaFreqMaps) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                List&lt;PairIntWithIndex&gt;&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L1062">                nTot += entry.getValue().size();                </span>
<span class="fc" id="L1063">            }</span>
<span class="fc" id="L1064">        }</span>
<span class="fc" id="L1065">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="pc bpc" id="L1066" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        
        // TODO: handle wrap around values!
        //    if there are points at 0 and 360, and a gap elsewhere, can
        //    shift the values so the gap is at 360 instead.
        
        // ------ TODO: rescale each map by frequencies to span ~1000 pixels -----
<span class="fc" id="L1073">        rescaleKeys(thetaFreqMaps, yFactor);</span>
        
<span class="fc" id="L1075">        int nTot2 = 0;</span>
        
<span class="fc bfc" id="L1077" title="All 2 branches covered.">        for (int i = 1; i &lt; thetaFreqMaps.size(); ++i) {</span>
        
            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="fc" id="L1080">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMapI = thetaFreqMaps.get(i);</span>

<span class="fc" id="L1082">            int[] maxXY = findMaxXY(thetaFreqMapI.keySet());</span>
            
<span class="pc bpc" id="L1084" title="1 of 4 branches missed.">            if (maxXY[0] &lt; 0 || maxXY[1] &lt;= 0) {</span>
<span class="fc" id="L1085">                continue;</span>
            }
            
            // ----- debug ---
            // plot the points as an image to see the data first
<span class="fc" id="L1090">            GreyscaleImage img = new GreyscaleImage(maxXY[0] + 1, maxXY[1] + 1);</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">            for (com.climbwithyourfeet.clustering.util.PairInt p : thetaFreqMapI.keySet()) {</span>
<span class="fc" id="L1092">                img.setValue(p.getX(), p.getY(), 255);</span>
<span class="fc" id="L1093">            }</span>
            try {
<span class="fc" id="L1095">                ImageIOHelper.writeOutputImage(</span>
<span class="fc" id="L1096">                    ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt2_input_&quot; + i </span>
                        + &quot;_.png&quot;, img);
<span class="nc" id="L1098">            } catch (IOException ex) {</span>
<span class="nc" id="L1099">                Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                    null, ex);
<span class="fc" id="L1101">            }</span>
            // --- end debug
            
            // Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            //     List&lt;PairIntWithIndex&gt;&gt; thetaFreqMapI
                
            // map w/ key=(theta, freq) value=collection of coords
            DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; 
<span class="fc" id="L1109">                clusterFinder </span>
                = new DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;(
<span class="fc" id="L1111">                    thetaFreqMapI.keySet(), maxXY[0] + 1, maxXY[1] + 1);</span>

<span class="fc" id="L1113">            clusterFinder.setToDebug();</span>

            // to recover every point, set limit to 1
<span class="fc" id="L1116">            clusterFinder.setMinimumNumberInCluster(1);</span>

<span class="fc" id="L1118">            clusterFinder.calculateCriticalDensity();</span>

<span class="fc" id="L1120">            clusterFinder.findClusters();</span>

<span class="fc" id="L1122">            int nGroups = clusterFinder.getNumberOfClusters();</span>
            
<span class="fc bfc" id="L1124" title="All 2 branches covered.">            for (int k = 0; k &lt; nGroups; ++k) {</span>

<span class="fc" id="L1126">                Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; group</span>
<span class="fc" id="L1127">                    = clusterFinder.getCluster(k);</span>

<span class="fc" id="L1129">                Set&lt;PairInt&gt; coordPoints = new HashSet&lt;PairInt&gt;();</span>
                
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                for (com.climbwithyourfeet.clustering.util.PairInt pThetaFreq : group) {</span>

                    // include the other points of same ciexy theta, freq
<span class="fc" id="L1134">                    List&lt;PairIntWithIndex&gt; list = thetaFreqMapI.get(pThetaFreq);</span>
<span class="pc bpc" id="L1135" title="3 of 4 branches missed.">                    assert (list != null);</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">                    for (PairIntWithIndex p3 : list) {</span>
<span class="fc" id="L1137">                        int idx3 = p3.pixIdx;</span>
<span class="fc" id="L1138">                        int xCoord3 = input.getCol(idx3);</span>
<span class="fc" id="L1139">                        int yCoord3 = input.getRow(idx3);</span>
<span class="fc" id="L1140">                        PairInt pCoord = new PairInt(xCoord3, yCoord3);</span>
<span class="fc" id="L1141">                        coordPoints.add(pCoord);</span>
<span class="fc" id="L1142">                    }</span>
<span class="fc" id="L1143">                }               </span>

<span class="fc" id="L1145">                nTot2 += coordPoints.size();</span>

<span class="fc" id="L1147">                groupList.add(coordPoints);</span>
            }
        }
     
<span class="fc" id="L1151">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList, </span>
            blackPixels, whitePixels);
        
        // add back in blackPixels and whitePixels
<span class="fc" id="L1155">        groupList.add(blackPixels);</span>
<span class="fc" id="L1156">        groupList.add(whitePixels);</span>

        //TODO: assert npixels

<span class="fc" id="L1160">        return groupList;</span>
    }
    
    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the 
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all 
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if 
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.  The list is sorted by size and
     * set to values from 255 to 0.  If there are more than 255 clusters, the
     * remaining (smaller) clusters are pixels with value 0. 
     * 
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return 
     */
    public GreyscaleImage applyUsingPolarCIEXYAndFrequency(ImageExt input,
        boolean useBlur) {
        
<span class="fc" id="L1188">        float fracFreqLimit = 0.03f;</span>
        
<span class="fc" id="L1190">        return applyUsingPolarCIEXYAndFrequency(input, fracFreqLimit, useBlur);</span>
    }
    
    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the 
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all 
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if 
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.  The list is sorted by size and
     * set to values from 255 to 0.  If there are more than 255 clusters, the
     * remaining (smaller) clusters are pixels with value 0. 
     * 
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return 
     */
    public GreyscaleImage applyUsingPolarCIEXYAndFrequency(ImageExt input,
        final float fracFreqLimit, boolean useBlur) {
        
<span class="fc" id="L1218">        List&lt;Set&lt;PairInt&gt;&gt; clusters = calculateUsingPolarCIEXYAndFrequency(</span>
            input, fracFreqLimit, useBlur);
        
<span class="fc" id="L1221">        int n = clusters.size();</span>
        //assert(n &lt; 256);
        
        // sort indexes by set size
<span class="fc" id="L1225">        int maxSize = Integer.MIN_VALUE;</span>
<span class="fc" id="L1226">        int[] indexes = new int[n];</span>
<span class="fc" id="L1227">        int[] sizes = new int[n];</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1229">            indexes[i] = i;</span>
<span class="fc" id="L1230">            sizes[i] = clusters.get(i).size();</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">            if (sizes[i] &gt; maxSize) {</span>
<span class="fc" id="L1232">                maxSize = sizes[i];</span>
            }
        }
<span class="fc" id="L1235">        CountingSort.sort(sizes, indexes, maxSize);</span>
        
<span class="fc" id="L1237">        int delta = 256/clusters.size();</span>
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">        if (delta == 0) {</span>
<span class="nc" id="L1239">            delta = 1;</span>
        }
        
<span class="fc" id="L1242">        GreyscaleImage img2 = new GreyscaleImage(input.getWidth(), input.getHeight());</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">        for (int k = 0; k &lt; n; ++k) {</span>
            
<span class="fc" id="L1245">            int idx = indexes[n - k - 1];</span>
            
<span class="fc" id="L1247">            Set&lt;PairInt&gt; set = clusters.get(idx);</span>
            
<span class="fc" id="L1249">            int v = 255 - delta*k;</span>
<span class="pc bpc" id="L1250" title="1 of 2 branches missed.">            if (v &lt; 1) {</span>
<span class="nc" id="L1251">                continue;</span>
            }
            
<span class="fc bfc" id="L1254" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L1255">                img2.setValue(p.getX(), p.getY(), v);</span>
<span class="fc" id="L1256">            }</span>
        }
        
<span class="fc" id="L1259">        return img2;</span>
    }
    
    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the 
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all 
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if 
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * 
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndFrequency(ImageExt input,
        boolean useBlur) {

<span class="fc" id="L1285">        float fracFreqLimit = 0.03f;</span>
        
<span class="fc" id="L1287">        return calculateUsingPolarCIEXYAndFrequency(input, fracFreqLimit, useBlur);</span>
    }
    
    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the 
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction of max limit then groups all 
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if 
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameter is the fracFreqLimit.  Larger values exclude
     * smaller frequency peaks.
     * 
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * 
     * @param input image to find color clusters within
     * @param fracFreqLimit fraction of the maximum above which peaks will be found
     * @param useBlur if true, performs a gaussian blur of sigma=1 before finding
     * clusters.
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndFrequency(ImageExt input,
        float fracFreqLimit, boolean useBlur) {

<span class="fc bfc" id="L1318" title="All 2 branches covered.">        if (useBlur) {</span>
<span class="fc" id="L1319">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L1320">            imageProcessor.blur(input, 1.0f);</span>
        }

        //making a segmentation method using CIEXY polar theta
        // and the number of points with those colors.
        // choosing the peaks to be the cluster centers, then
        // gathering the pixels by proximity to the theta peaks
        // and when equidistant, chooses the largest peak.

<span class="fc" id="L1329">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1331">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>
        
<span class="fc" id="L1333">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1335">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L1337">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>
        
<span class="fc" id="L1339">        double[] minMaxTheta0 = findMinMaxTheta(input, points0);</span>
        
<span class="fc" id="L1341">        log.info(&quot;for all non-white and non-black, minTheta=&quot; + minMaxTheta0[0]</span>
            + &quot; maxTheta=&quot; + minMaxTheta0[1]);
        
        // -------- debug -------
<span class="fc" id="L1345">        int nGrey = 0;</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L1347">            nGrey += entry.getValue().size();</span>
<span class="fc" id="L1348">        }</span>
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        assert((points0.size() + blackPixels.size() + nGrey + </span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">            whitePixels.size()) == input.getNPixels());</span>
        // -------- end debug -------

<span class="fc" id="L1353">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>
        
<span class="fc" id="L1355">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(greyPixelGroups.size());</span>
        
<span class="fc bfc" id="L1357" title="All 2 branches covered.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">             if (points0.isEmpty()) {</span>
<span class="fc" id="L1359">                 groupList.add(points0);</span>
             }
<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="fc" id="L1362">                 groupList.add(blackPixels);</span>
             }
<span class="fc bfc" id="L1364" title="All 2 branches covered.">             for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="fc" id="L1365">                groupList.add(set);</span>
<span class="fc" id="L1366">             }</span>
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="fc" id="L1368">                 groupList.add(whitePixels);</span>
             }
<span class="fc" id="L1370">             return groupList;</span>
        }
        
        /* ----- create a map of theta and frequency ----
        need to find the peaks in frequency for frequencies larger than about
        3 percent of max frequency
        but don't want to use a spline3 to smooth, so will average every 
        few pixels.
        */

<span class="fc" id="L1380">        int binWidth = 3;</span>
<span class="fc" id="L1381">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap = createThetaCIEXYMap(</span>
            points0, input, binWidth);
       
<span class="fc" id="L1384">        int n = (360/binWidth) + 1;</span>
        
<span class="fc" id="L1386">        int[] orderedThetaKeys = new int[n];</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1388">            orderedThetaKeys[i] = i;</span>
        }
<span class="fc" id="L1390">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="fc" id="L1391">        int nTot = 0;</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="fc" id="L1393">            int count = entry.getValue().size();</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">            if (count &gt; maxFreq) {</span>
<span class="fc" id="L1395">                maxFreq = count;</span>
            }
<span class="fc" id="L1397">            nTot += entry.getValue().size();</span>
<span class="fc" id="L1398">        }</span>
<span class="fc" id="L1399">        nTot += (blackPixels.size() + nGrey + whitePixels.size());</span>
<span class="pc bpc" id="L1400" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        
        /*
        TODO: this is where the DTClusterFinder would be good to use to find
        the peaks.
        */
        
<span class="fc" id="L1407">        PairIntArray peaks = findPeaksInThetaPointMap(orderedThetaKeys, </span>
            thetaPointMap, 
<span class="fc" id="L1409">            Math.round(fracFreqLimit * maxFreq));</span>
        
<span class="fc" id="L1411">        int[] minMaxXY = MiscMath.findMinMaxXY(peaks);</span>
        
        /*
        // ----- debug ---
        // plot the points as an image to see the data first
        int nPoints = 0;
        int maxX = Integer.MIN_VALUE;
        int maxY = Integer.MIN_VALUE;
        for (int i : orderedThetaKeys) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);
            if (list == null) {
                continue;
            }
            int y = list.size();
            nPoints++;
            if (key.intValue() &gt; maxX) {
                maxX = key.intValue();
            }
            if (y &gt; maxY) {
                maxY = y;
            }
        }
        float[] xPoints = new float[nPoints];
        float[] yPoints = new float[nPoints];
        int count = 0;
        for (int i : orderedThetaKeys) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);
            if (list == null) {
                continue;
            }
            int y = list.size();
            xPoints[count] = key.intValue();
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxX, 0, maxY, xPoints, yPoints, xPoints, yPoints, &quot;cieXY theta vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        // --- end debug
        */
        
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">            for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1462">                groupList.add(new HashSet&lt;PairInt&gt;(entry.getValue()));</span>
<span class="nc" id="L1463">            }</span>
<span class="nc" id="L1464">            groupList.add(blackPixels);</span>
<span class="nc" id="L1465">            groupList.add(whitePixels);</span>
<span class="nc" id="L1466">            return groupList;</span>
        }
<span class="fc bfc" id="L1468" title="All 2 branches covered.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="fc" id="L1469">            groupList.add(new HashSet&lt;PairInt&gt;());</span>
        }
        
        /* traverse in ordered manner thetaPointMap to compare to current theta position
           w.r.t. peaks
           then place it in the groupsList.
           points before the first peak are compared with last peak too for wrap around.
        */
<span class="fc" id="L1477">        int currentPeakIdx = -1;</span>
<span class="fc bfc" id="L1478" title="All 2 branches covered.">        for (int i : orderedThetaKeys) {</span>
<span class="fc" id="L1479">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L1480">            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L1482">                continue;</span>
            }
<span class="fc" id="L1484">            int idx = -1;</span>
<span class="fc bfc" id="L1485" title="All 4 branches covered.">            if ((currentPeakIdx == -1) || (currentPeakIdx == (peaks.getN() - 1))) {</span>
                int diffL, diffF;
<span class="fc bfc" id="L1487" title="All 2 branches covered.">                if (currentPeakIdx == -1) {</span>
<span class="fc" id="L1488">                    diffL = key.intValue() + 360 - peaks.getX(peaks.getN() - 1);</span>
<span class="fc" id="L1489">                    diffF = peaks.getX(0) - key.intValue();</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">                    if (diffF == 0) {</span>
<span class="fc" id="L1491">                        currentPeakIdx = 0;</span>
                    }
                } else {
<span class="fc" id="L1494">                    diffL = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L1495">                    diffF = peaks.getX(0) + 360 - key.intValue();</span>
                }
<span class="fc bfc" id="L1497" title="All 2 branches covered.">                if (diffL &lt; diffF) {</span>
<span class="fc" id="L1498">                    idx = peaks.getN() - 1;</span>
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">                } else if (diffL == diffF) {</span>
<span class="nc" id="L1500">                    int freqL = peaks.getY(peaks.getN() - 1);</span>
<span class="nc" id="L1501">                    int freqF = peaks.getY(0);</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">                    if (freqL &lt; freqF) {</span>
<span class="nc" id="L1503">                        idx = peaks.getN() - 1;</span>
                    } else {
<span class="nc" id="L1505">                        idx = 0;</span>
                    }
<span class="nc" id="L1507">                } else {</span>
<span class="fc" id="L1508">                    idx = 0;</span>
                }
<span class="fc" id="L1510">            } else {</span>
                // this has to update currentPeakIdx
<span class="fc" id="L1512">                int diffP = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L1513">                int diffN = peaks.getX(currentPeakIdx + 1) - key.intValue();</span>
<span class="fc bfc" id="L1514" title="All 2 branches covered.">                if (diffN == 0) {</span>
<span class="fc" id="L1515">                    currentPeakIdx++;</span>
<span class="fc" id="L1516">                    idx = currentPeakIdx;</span>
                } else {
<span class="fc bfc" id="L1518" title="All 2 branches covered.">                    if (diffP &lt; diffN) {</span>
<span class="fc" id="L1519">                        idx = currentPeakIdx;</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">                    } else if (diffP == diffN) {</span>
<span class="fc" id="L1521">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="fc" id="L1522">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">                        if (freqP &lt; freqN) {</span>
<span class="fc" id="L1524">                            idx = currentPeakIdx;</span>
                        } else {
<span class="fc" id="L1526">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="fc" id="L1528">                    } else {</span>
<span class="fc" id="L1529">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L1533" title="3 of 4 branches missed.">            assert(idx != -1);</span>
<span class="fc" id="L1534">            groupList.get(idx).addAll(list);</span>
        }
        
<span class="fc" id="L1537">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList, </span>
            blackPixels, whitePixels);
        
        // add back in blackPixels and whitePixels
<span class="fc bfc" id="L1541" title="All 2 branches covered.">        if (!blackPixels.isEmpty()) {</span>
<span class="fc" id="L1542">            groupList.add(blackPixels);</span>
        }
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">        if (!whitePixels.isEmpty()) {</span>
<span class="fc" id="L1545">            groupList.add(whitePixels);</span>
        }
        
<span class="fc" id="L1548">        int nTot2 = 0;</span>
<span class="fc bfc" id="L1549" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; groups : groupList) {</span>
<span class="fc" id="L1550">            nTot2 += groups.size();</span>
<span class="fc" id="L1551">        }</span>
           
<span class="fc" id="L1553">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot2=&quot; + nTot2);</span>
<span class="pc bpc" id="L1554" title="3 of 4 branches missed.">        assert(nTot2 == input.getNPixels());</span>
        
<span class="fc" id="L1556">        return groupList;</span>
    }

    private Map&lt;Integer, List&lt;PairInt&gt;&gt; createThetaCIEXYMap(Set&lt;PairInt&gt;
        points0, ImageExt input, double minTheta, double thetaFactor,
        double[] outputMinMaxTheta, int[] outputMinMaxFreq) {

<span class="fc" id="L1563">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // key = theta, value = pixels having that key
<span class="fc" id="L1566">        Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap = new HashMap&lt;Integer, List&lt;PairInt&gt;&gt;();</span>

<span class="fc" id="L1568">        double minTheta0 = minTheta;</span>
<span class="fc" id="L1569">        outputMinMaxTheta[0] = Double.MIN_VALUE;</span>
<span class="fc" id="L1570">        outputMinMaxTheta[1] = Double.MAX_VALUE;</span>

<span class="fc bfc" id="L1572" title="All 2 branches covered.">        for (PairInt p : points0) {</span>

<span class="fc" id="L1574">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>

<span class="fc" id="L1576">            float cx = input.getCIEX(idx);</span>
<span class="fc" id="L1577">            float cy = input.getCIEY(idx);</span>

<span class="fc" id="L1579">            double theta = thetaFactor * (</span>
<span class="fc" id="L1580">                (cieC.calculateXYTheta(cx, cy)*180./Math.PI) - minTheta0);</span>

<span class="fc" id="L1582">            Integer thetaCIEXY = Integer.valueOf((int)Math.round(theta));</span>

<span class="fc" id="L1584">            List&lt;PairInt&gt; list = thetaPointMap.get(thetaCIEXY);</span>
<span class="fc bfc" id="L1585" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L1586">                list = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L1587">                thetaPointMap.put(thetaCIEXY, list);</span>
            }
<span class="fc" id="L1589">            list.add(p);</span>

<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">            if (theta &lt; outputMinMaxTheta[0]) {</span>
<span class="nc" id="L1592">                outputMinMaxTheta[0] = theta;</span>
            }
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">            if (theta &gt; outputMinMaxTheta[1]) {</span>
<span class="nc" id="L1595">                outputMinMaxTheta[1] = theta;</span>
            }
<span class="fc" id="L1597">        }</span>

<span class="fc" id="L1599">        outputMinMaxFreq[0] = Integer.MAX_VALUE;</span>
<span class="fc" id="L1600">        outputMinMaxFreq[1] = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L1601" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="fc" id="L1602">            int count = entry.getValue().size();</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">            if (count &lt; outputMinMaxFreq[0]) {</span>
<span class="fc" id="L1604">                outputMinMaxFreq[0] = count;</span>
            }
<span class="fc bfc" id="L1606" title="All 2 branches covered.">            if (count &gt; outputMinMaxFreq[1]) {</span>
<span class="fc" id="L1607">                outputMinMaxFreq[1] = count;</span>
            }
<span class="fc" id="L1609">        }</span>

<span class="fc" id="L1611">        return thetaPointMap;</span>
    }

    private List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
    List&lt;PairIntWithIndex&gt;&gt;&gt; partitionIntoFrequencyMaps(
    ImageExt input, Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap, 
    float[] partitionFreqFracs, int maxFreq) {
        
        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
            List&lt;PairIntWithIndex&gt;&gt;&gt; 
<span class="fc" id="L1621">            mapsList = </span>
                new ArrayList&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
                List&lt;PairIntWithIndex&gt;&gt;&gt;();
        
<span class="fc" id="L1625">        int nMaps = partitionFreqFracs.length + 1;</span>
        
<span class="fc bfc" id="L1627" title="All 2 branches covered.">        for (int i = 0; i &lt; nMaps; ++i) {</span>
<span class="fc" id="L1628">            mapsList.add(</span>
                new HashMap&lt;com.climbwithyourfeet.clustering.util.PairInt, 
                List&lt;PairIntWithIndex&gt;&gt;());
        }
        
<span class="fc" id="L1633">        final int[] partitionFreqs = new int[partitionFreqFracs.length];</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">        for (int i = 0; i &lt; partitionFreqs.length; ++i) {</span>
<span class="fc" id="L1635">            partitionFreqs[i] = Math.round(partitionFreqFracs[i]*maxFreq);</span>
        }
        
<span class="fc" id="L1638">        int[] maxXY = new int[2];</span>
<span class="fc" id="L1639">        Arrays.fill(maxXY, Integer.MIN_VALUE);</span>
                
<span class="fc bfc" id="L1641" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>

<span class="fc" id="L1643">            Integer theta = entry.getKey();</span>

<span class="fc" id="L1645">            int count = entry.getValue().size();</span>

<span class="fc" id="L1647">            List&lt;PairIntWithIndex&gt; list = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="fc bfc" id="L1648" title="All 2 branches covered.">            for (PairInt p : entry.getValue()) {</span>
<span class="fc" id="L1649">                int pixIdx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="fc" id="L1650">                PairIntWithIndex p2 = new PairIntWithIndex(theta.intValue(),</span>
                    count, pixIdx);
<span class="fc" id="L1652">                list.add(p2);</span>
<span class="fc" id="L1653">            }</span>
            
<span class="fc" id="L1655">            int n = partitionFreqs.length;</span>
<span class="fc" id="L1656">            int idx = 0;</span>
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L1658" title="All 2 branches covered.">                if (i == 0) {</span>
<span class="fc bfc" id="L1659" title="All 2 branches covered.">                    if (count &lt; partitionFreqs[0]) {</span>
<span class="fc" id="L1660">                        idx = 0;</span>
<span class="fc" id="L1661">                        break;</span>
                    }
<span class="fc bfc" id="L1663" title="All 4 branches covered.">                } else if ((i == (n - 1)) &amp;&amp; count &gt;= partitionFreqs[i]) {</span>
<span class="fc" id="L1664">                    idx = n;// one past partitions is last list bin</span>
<span class="fc" id="L1665">                    break;</span>
                } else {
<span class="pc bpc" id="L1667" title="1 of 4 branches missed.">                    if ((count &gt;= partitionFreqs[i - 1]) &amp;&amp; (count &lt; partitionFreqs[i])) {</span>
<span class="fc" id="L1668">                        idx = i;</span>
<span class="fc" id="L1669">                        break;</span>
                    }
                }
            }
            
            // this is unique to all maps, not stomping on existing key
<span class="fc" id="L1675">            mapsList.get(idx).put(</span>
                new com.climbwithyourfeet.clustering.util.PairInt(
<span class="fc" id="L1677">                    theta.intValue(), count), list);</span>
            
<span class="fc bfc" id="L1679" title="All 2 branches covered.">            if (theta.intValue() &gt; maxXY[0]) {</span>
<span class="fc" id="L1680">                maxXY[0] = theta.intValue();</span>
            }
<span class="fc bfc" id="L1682" title="All 2 branches covered.">            if (count &gt; maxXY[1]) {</span>
<span class="fc" id="L1683">                maxXY[1] = count;</span>
            }
<span class="fc" id="L1685">        }</span>
        
        // ----- temporary print of all pixels -------
        // ----- debug ---
<span class="fc" id="L1689">        GreyscaleImage img = new GreyscaleImage(maxXY[0] + 1, maxXY[1] + 1);</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">        for (int i = 0; i &lt; mapsList.size(); ++i) {            </span>
<span class="fc bfc" id="L1691" title="All 2 branches covered.">            for (com.climbwithyourfeet.clustering.util.PairInt p : mapsList.get(i).keySet()) {</span>
<span class="fc" id="L1692">                img.setValue(p.getX(), p.getY(), 255);</span>
<span class="fc" id="L1693">            }</span>
        }
        try {
<span class="fc" id="L1696">            ImageIOHelper.writeOutputImage(</span>
<span class="fc" id="L1697">                ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt2_input.png&quot;, img);</span>
<span class="nc" id="L1698">        } catch (IOException ex) {</span>
<span class="nc" id="L1699">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="fc" id="L1701">        }</span>
        // --- end debug
        
<span class="fc" id="L1704">        return mapsList;</span>
    }

    private void rescaleKeys(
        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
            List&lt;PairIntWithIndex&gt;&gt;&gt; thetaFreqMaps, int scaleTo) {
        
        // --- can remove the count after debugging ----
<span class="fc" id="L1712">        int nTotBefore = 0;</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt, 
<span class="fc bfc" id="L1715" title="All 2 branches covered.">                List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMaps.get(i).entrySet()) {</span>
<span class="fc" id="L1716">                nTotBefore += entry.getValue().size();</span>
<span class="fc" id="L1717">            }</span>
        }
        
<span class="fc bfc" id="L1720" title="All 2 branches covered.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            
            Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
<span class="fc" id="L1723">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap = thetaFreqMaps.get(i);</span>
            
<span class="fc" id="L1725">            int[] minMax = findMinMaxOfKeyYs(thetaFreqMap.keySet());</span>
                 
            Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
<span class="fc" id="L1728">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap2 = rescaleKeyYs(</span>
                    thetaFreqMap, scaleTo, minMax);
            
<span class="fc" id="L1731">            thetaFreqMaps.set(i, thetaFreqMap2);</span>
        }
        
        // --- can remove the count after debugging ----
<span class="fc" id="L1735">        int nTotAfter = 0;</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt, 
<span class="fc bfc" id="L1738" title="All 2 branches covered.">                List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMaps.get(i).entrySet()) {</span>
<span class="fc" id="L1739">                nTotAfter += entry.getValue().size();</span>
<span class="fc" id="L1740">            }</span>
        }
<span class="pc bpc" id="L1742" title="3 of 4 branches missed.">        assert(nTotBefore == nTotAfter);</span>
<span class="fc" id="L1743">    }</span>

    private int[] findMinMaxOfKeyYs(
        Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; keySet) {
        
<span class="fc" id="L1748">        int min = Integer.MAX_VALUE;</span>
<span class="fc" id="L1749">        int max = Integer.MIN_VALUE;</span>
        
<span class="fc bfc" id="L1751" title="All 2 branches covered.">        for (com.climbwithyourfeet.clustering.util.PairInt p : keySet) {</span>
<span class="fc" id="L1752">            int y = p.getY();</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">            if (y &lt; min) {</span>
<span class="fc" id="L1754">                min = y;</span>
            }
<span class="fc bfc" id="L1756" title="All 2 branches covered.">            if (y &gt; max) {</span>
<span class="fc" id="L1757">                max = y;</span>
            }
<span class="fc" id="L1759">        }</span>
<span class="fc" id="L1760">        return new int[]{min, max};</span>
    }

    private Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
    List&lt;PairIntWithIndex&gt;&gt; rescaleKeyYs(
    Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
    List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap, final int scaleTo, final int[] minMaxY) {
        
        Map&lt;com.climbwithyourfeet.clustering.util.PairInt, 
<span class="fc" id="L1769">            List&lt;PairIntWithIndex&gt;&gt; scaledMap </span>
            = new HashMap&lt;com.climbwithyourfeet.clustering.util.PairInt, 
                List&lt;PairIntWithIndex&gt;&gt;();
        
<span class="pc bpc" id="L1773" title="1 of 2 branches missed.">        if ((minMaxY[1] - minMaxY[0]) == 0) {</span>
<span class="nc" id="L1774">            return thetaFreqMap;</span>
        }
        
<span class="fc" id="L1777">        float factor = scaleTo/(minMaxY[1] - minMaxY[0]);</span>
        
        for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt, 
<span class="fc bfc" id="L1780" title="All 2 branches covered.">            List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMap.entrySet()) {</span>
            
<span class="fc" id="L1782">            com.climbwithyourfeet.clustering.util.PairInt p = entry.getKey();</span>
            
<span class="fc" id="L1784">            int y = Math.round(factor * (p.getY() - minMaxY[0]));</span>
            
<span class="fc" id="L1786">            com.climbwithyourfeet.clustering.util.PairInt p2 = new</span>
<span class="fc" id="L1787">                com.climbwithyourfeet.clustering.util.PairInt(p.getX(), y);</span>
            
<span class="fc" id="L1789">            scaledMap.put(p2, entry.getValue());</span>
<span class="fc" id="L1790">        }</span>
        
<span class="fc" id="L1792">        return scaledMap;</span>
    }

    private int[] findMaxXY(Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; 
        keySet) {
        
<span class="fc" id="L1798">        int maxX = Integer.MIN_VALUE;</span>
<span class="fc" id="L1799">        int maxY = Integer.MIN_VALUE;</span>
        
<span class="fc bfc" id="L1801" title="All 2 branches covered.">        for (com.climbwithyourfeet.clustering.util.PairInt p : keySet) {</span>
<span class="fc" id="L1802">            int x = p.getX();</span>
<span class="fc" id="L1803">            int y = p.getY();</span>
<span class="fc bfc" id="L1804" title="All 2 branches covered.">            if (x &gt; maxX) {</span>
<span class="fc" id="L1805">                maxX = x;</span>
            }
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            if (y &gt; maxY) {</span>
<span class="fc" id="L1808">                maxY = y;</span>
            }
<span class="fc" id="L1810">        }</span>
<span class="fc" id="L1811">        return new int[]{maxX, maxY};</span>
    }

    private Map&lt;Integer, Collection&lt;PairInt&gt;&gt; createThetaCIEXYMap(Set&lt;PairInt&gt; 
        points, ImageExt input, int binWidth) {
        
<span class="fc" id="L1817">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // key = theta, value = pixels having that key
<span class="fc" id="L1820">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>
        
<span class="fc bfc" id="L1822" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L1824">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>

<span class="fc" id="L1826">            float cx = input.getCIEX(idx);</span>
<span class="fc" id="L1827">            float cy = input.getCIEY(idx);</span>

<span class="fc" id="L1829">            double thetaRadians = cieC.calculateXYTheta(cx, cy);</span>
<span class="fc" id="L1830">            double theta = thetaRadians * 180./Math.PI;</span>

<span class="fc" id="L1832">            int thetaCIEXY = (int)Math.round(theta);</span>
            
<span class="fc" id="L1834">            Integer binKey = Integer.valueOf(thetaCIEXY/binWidth);</span>

<span class="fc" id="L1836">            Collection&lt;PairInt&gt; list = thetaPointMap.get(binKey);</span>
<span class="fc bfc" id="L1837" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L1838">                list = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L1839">                thetaPointMap.put(binKey, list);</span>
            }
<span class="fc" id="L1841">            list.add(p);</span>
<span class="fc" id="L1842">        }</span>
        
<span class="fc" id="L1844">        return thetaPointMap;</span>
    }

    /**
     * find peaks in the theta point map above lower limit.
     * @param orderedThetaKeys
     * @param thetaPointMap
     * @param limit
     * @return 
     */
    protected PairIntArray findPeaksInThetaPointMap(final int[] orderedThetaKeys, 
        final Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap, final int limit) {
        
<span class="fc" id="L1857">        int lastKey = -1;</span>
<span class="fc" id="L1858">        int lastValue = -1;</span>
<span class="fc" id="L1859">        boolean isIncr = false;</span>
<span class="fc" id="L1860">        PairIntArray peaks = new PairIntArray();</span>
<span class="fc" id="L1861">        int nInMap = 0;</span>
<span class="fc bfc" id="L1862" title="All 2 branches covered.">        for (int i : orderedThetaKeys) {</span>
<span class="fc" id="L1863">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L1864">            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc bfc" id="L1866" title="All 6 branches covered.">                if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
<span class="fc" id="L1867">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="fc" id="L1869">                lastKey = key.intValue();</span>
<span class="fc" id="L1870">                lastValue = 0;</span>
<span class="fc" id="L1871">                isIncr = false;</span>
<span class="fc" id="L1872">                continue;</span>
            }
<span class="fc" id="L1874">            int count = list.size();</span>
<span class="fc bfc" id="L1875" title="All 2 branches covered.">            if (nInMap == 1) {</span>
<span class="fc bfc" id="L1876" title="All 2 branches covered.">                if (count &gt; lastValue) {</span>
<span class="fc" id="L1877">                    isIncr = true;</span>
                } else {
<span class="pc bpc" id="L1879" title="1 of 2 branches missed.">                    if (lastValue &gt; limit) {</span>
<span class="nc" id="L1880">                        peaks.add(lastKey, lastValue);</span>
                    }
<span class="fc" id="L1882">                    isIncr = false;</span>
                }
<span class="fc bfc" id="L1884" title="All 2 branches covered.">            } else if (nInMap != 0) {</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">                if (isIncr) {</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">                    if (count &lt; lastValue) {</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">                        if (lastValue &gt; limit) {</span>
<span class="fc" id="L1888">                            peaks.add(lastKey, lastValue);</span>
                        }
<span class="fc" id="L1890">                        isIncr = false;</span>
                    }
                } else {
<span class="fc bfc" id="L1893" title="All 2 branches covered.">                    if (count &gt; lastValue) {</span>
<span class="fc" id="L1894">                        isIncr = true;</span>
                    }
                }
            }
<span class="fc" id="L1898">            lastValue = count;</span>
<span class="fc" id="L1899">            lastKey = key.intValue();</span>
<span class="fc" id="L1900">            nInMap++;</span>
        }
<span class="fc bfc" id="L1902" title="All 6 branches covered.">        if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
            //checking value at theta=0 to make sure this is a peak
<span class="fc" id="L1904">            Integer key = orderedThetaKeys[0];</span>
<span class="pc bpc" id="L1905" title="1 of 2 branches missed.">            if (key.intValue() == 0) {</span>
<span class="nc" id="L1906">                Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">                if (list == null) {</span>
<span class="nc" id="L1908">                    peaks.add(lastKey, lastValue);</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">                } else if (list.size() &lt; lastValue) {</span>
<span class="nc" id="L1910">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="nc" id="L1912">            } else {</span>
<span class="fc" id="L1913">                peaks.add(lastKey, lastValue);</span>
            }
        }
        
<span class="fc" id="L1917">        return peaks;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; groupByPeaks(
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {
        
<span class="fc" id="L1923">        int nTot = 0;</span>
<span class="fc" id="L1924">        int minKey = Integer.MAX_VALUE;</span>
<span class="fc" id="L1925">        int maxKey = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L1926" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L1927">            int key = entry.getKey().intValue();</span>
<span class="fc bfc" id="L1928" title="All 2 branches covered.">            if (key &lt; minKey) {</span>
<span class="fc" id="L1929">                minKey = key;</span>
            }
<span class="fc bfc" id="L1931" title="All 2 branches covered.">            if (key &gt; maxKey) {</span>
<span class="fc" id="L1932">                maxKey = key;</span>
            }
<span class="fc" id="L1934">            nTot += entry.getValue().size();</span>
<span class="fc" id="L1935">        }</span>
        
<span class="fc" id="L1937">        int binWidth = 8;</span>
<span class="fc" id="L1938">        greyPixelMap = binByKeys(greyPixelMap, minKey, maxKey, binWidth);</span>
        
<span class="fc" id="L1940">        int nTot2 = 0;</span>
<span class="fc" id="L1941">        minKey = Integer.MAX_VALUE;</span>
<span class="fc" id="L1942">        maxKey = Integer.MIN_VALUE;</span>
<span class="fc" id="L1943">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L1945">            int key = entry.getKey().intValue();</span>
<span class="fc bfc" id="L1946" title="All 2 branches covered.">            if (key &lt; minKey) {</span>
<span class="fc" id="L1947">                minKey = key;</span>
            }
<span class="fc bfc" id="L1949" title="All 2 branches covered.">            if (key &gt; maxKey) {</span>
<span class="fc" id="L1950">                maxKey = key;</span>
            }
<span class="fc" id="L1952">            int y = entry.getValue().size();</span>
<span class="fc bfc" id="L1953" title="All 2 branches covered.">            if (y &gt; maxFreq) {</span>
<span class="fc" id="L1954">                maxFreq = y;</span>
            }

<span class="fc" id="L1957">            nTot2 += y;</span>
<span class="fc" id="L1958">        }</span>
<span class="pc bpc" id="L1959" title="3 of 4 branches missed.">        assert(nTot == nTot2);</span>
        
        // --- debug
<span class="fc" id="L1962">        float[] xPoints = new float[greyPixelMap.size()];</span>
<span class="fc" id="L1963">        float[] yPoints = new float[greyPixelMap.size()];</span>
<span class="fc" id="L1964">        int count = 0;</span>
<span class="fc bfc" id="L1965" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>
<span class="fc" id="L1966">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L1967">            Collection&lt;PairInt&gt; set = greyPixelMap.get(key);</span>
<span class="fc bfc" id="L1968" title="All 2 branches covered.">            if (set == null) {</span>
<span class="fc" id="L1969">                continue;</span>
            }
<span class="fc" id="L1971">            int y = set.size();</span>
<span class="fc" id="L1972">            xPoints[count] = key.intValue();</span>
<span class="fc" id="L1973">            yPoints[count] = y;</span>
<span class="fc" id="L1974">            count++;</span>
        }
        try {
            //maxY=2000;
<span class="fc" id="L1978">            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();</span>
<span class="fc" id="L1979">            plotter.addPlot(0, maxKey, 0, maxFreq, xPoints, yPoints, xPoints, yPoints, &quot;grey avgRGB vs freq&quot;);</span>
<span class="fc" id="L1980">            plotter.writeFile(&quot;_segmentation3_grey_&quot;);</span>
<span class="nc" id="L1981">        } catch (IOException ex) {</span>
<span class="nc" id="L1982">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="fc" id="L1984">        }</span>
        // --- end debug
        
<span class="fc" id="L1987">        final int[] orderedKeys = new int[maxKey - minKey + 1];</span>
<span class="fc" id="L1988">        count = 0;</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>
<span class="fc" id="L1990">            orderedKeys[count] = i;</span>
<span class="fc" id="L1991">            count++;</span>
        }
<span class="fc" id="L1993">        int limit = (int)(0.03 * maxFreq);</span>
<span class="fc" id="L1994">        PairIntArray peaks = findPeaksInThetaPointMap(orderedKeys, greyPixelMap, limit);</span>

        // if there are several peaks within small range of keys, that's noise,
        // so removing them
<span class="fc" id="L1998">        filterPeaksIfNoisey(peaks);</span>
        
        // ---- gather points in greyPixelMap into groups around the peaks ----
<span class="fc" id="L2001">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(orderedKeys.length + 1);</span>
<span class="fc bfc" id="L2002" title="All 2 branches covered.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="fc" id="L2003">            groupList.add(new HashSet&lt;PairInt&gt;());</span>
        }
        
<span class="fc bfc" id="L2006" title="All 2 branches covered.">        if (peaks.getN() == 0) {</span>
<span class="fc" id="L2007">            return groupList;</span>
<span class="fc bfc" id="L2008" title="All 2 branches covered.">        } else if (peaks.getN() == 1) {</span>
<span class="fc bfc" id="L2009" title="All 2 branches covered.">            for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L2010">                Collection&lt;PairInt&gt; set = entry.getValue();</span>
<span class="fc" id="L2011">                groupList.get(0).addAll(set);</span>
<span class="fc" id="L2012">            }</span>
<span class="fc" id="L2013">            return groupList;</span>
        }
        
<span class="fc" id="L2016">        int currentPeakIdx = -1;</span>
<span class="fc bfc" id="L2017" title="All 2 branches covered.">        for (int i : orderedKeys) {</span>
<span class="fc" id="L2018">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L2019">            Collection&lt;PairInt&gt; set = greyPixelMap.get(key);</span>
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">            if (set == null) {</span>
<span class="nc" id="L2021">                continue;</span>
            }
<span class="fc" id="L2023">            int idx = -1;</span>
<span class="fc bfc" id="L2024" title="All 2 branches covered.">            if (currentPeakIdx == -1) {</span>
<span class="fc" id="L2025">                currentPeakIdx = 0;</span>
<span class="fc" id="L2026">                idx = 0;</span>
<span class="fc bfc" id="L2027" title="All 2 branches covered.">            } else if (currentPeakIdx == (peaks.getN() - 1)) {</span>
<span class="fc" id="L2028">                idx = currentPeakIdx;</span>
            } else {
                // this has to update currentPeakIdx
<span class="fc" id="L2031">                int diffP = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L2032">                int diffN = peaks.getX(currentPeakIdx + 1) - key.intValue();</span>
<span class="fc bfc" id="L2033" title="All 2 branches covered.">                if (diffN == 0) {</span>
<span class="fc" id="L2034">                    currentPeakIdx++;</span>
<span class="fc" id="L2035">                    idx = currentPeakIdx;</span>
                } else {
<span class="fc bfc" id="L2037" title="All 2 branches covered.">                    if (diffP &lt; diffN) {</span>
<span class="fc" id="L2038">                        idx = currentPeakIdx;</span>
<span class="fc bfc" id="L2039" title="All 2 branches covered.">                    } else if (diffP == diffN) {</span>
<span class="fc" id="L2040">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="fc" id="L2041">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="fc bfc" id="L2042" title="All 2 branches covered.">                        if (freqP &lt; freqN) {</span>
<span class="fc" id="L2043">                            idx = currentPeakIdx;</span>
                        } else {
<span class="fc" id="L2045">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="fc" id="L2047">                    } else {</span>
<span class="fc" id="L2048">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L2052" title="3 of 4 branches missed.">            assert(idx != -1);</span>
<span class="fc" id="L2053">            groupList.get(idx).addAll(set);</span>
        }
        
        // ----- debug ----
<span class="fc" id="L2057">        int nTot3 = 0;</span>
<span class="fc bfc" id="L2058" title="All 2 branches covered.">        for (Collection&lt;PairInt&gt; set : groupList) {</span>
<span class="fc" id="L2059">            nTot3 += set.size();</span>
<span class="fc" id="L2060">        }</span>
<span class="pc bpc" id="L2061" title="3 of 4 branches missed.">        assert(nTot == nTot3);</span>
        // ----- end debug -----
        
<span class="fc" id="L2064">        return groupList;</span>
    }

    private Map&lt;Integer, Collection&lt;PairInt&gt;&gt; binByKeys(
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap, 
        int minKey, int maxKey, int binWidth) {
        
<span class="fc" id="L2071">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; map2 </span>
            = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();
        
<span class="fc bfc" id="L2074" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>
            
<span class="fc" id="L2076">            Integer key = Integer.valueOf(i);</span>
            
<span class="fc" id="L2078">            Collection&lt;PairInt&gt; c = greyPixelMap.get(key);</span>
            
<span class="fc bfc" id="L2080" title="All 2 branches covered.">            if (c == null) {</span>
<span class="fc" id="L2081">                continue;</span>
            }
            
<span class="fc" id="L2084">            Integer binKey = Integer.valueOf(i/binWidth);</span>
            
<span class="fc" id="L2086">            Collection&lt;PairInt&gt; c2 = map2.get(binKey);</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">            if (c2 == null) {</span>
<span class="fc" id="L2088">                c2 = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2089">                map2.put(binKey, c2);</span>
            }
<span class="fc" id="L2091">            c2.addAll(c);</span>
        }
        
<span class="fc" id="L2094">        return map2;</span>
    }

    private void filterPeaksIfNoisey(PairIntArray peaks) {
        
<span class="fc bfc" id="L2099" title="All 2 branches covered.">        if (peaks.getN() == 0) {</span>
<span class="fc" id="L2100">            return;</span>
        }
        
<span class="fc" id="L2103">        int sumDeltaX = 0;</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        for (int i = (peaks.getN() - 1); i &gt; 0; --i) {</span>
<span class="fc" id="L2105">            sumDeltaX += (peaks.getX(i) - peaks.getX(i - 1));</span>
        }
        //TODO: this may need to be revised:
        // if there are more than 1 peaks per delta x of 5 or so, re-bin by 4 
<span class="fc" id="L2109">        float deltaX = (float)sumDeltaX/((float)peaks.getN() - 1);</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">        if (deltaX &lt; 5) {</span>
            // re-bin by 4
<span class="fc" id="L2112">            PairIntArray peaks2 = new PairIntArray();</span>
<span class="fc bfc" id="L2113" title="All 2 branches covered.">            for (int i = 0; i &lt; peaks.getN(); i += 4) {</span>
<span class="fc" id="L2114">                int sumX = 0;</span>
<span class="fc" id="L2115">                int sumY = 0;</span>
<span class="fc" id="L2116">                int count = 0;</span>
<span class="fc bfc" id="L2117" title="All 2 branches covered.">                for (int j = i; j &lt; (i + 5); ++j) {</span>
<span class="fc" id="L2118">                    sumX += peaks.getX(i);</span>
<span class="fc" id="L2119">                    sumY += peaks.getY(i);</span>
<span class="fc" id="L2120">                    count++;</span>
                }
<span class="fc" id="L2122">                sumX = Math.round((float)sumX/(float)count);</span>
<span class="fc" id="L2123">                sumY = Math.round((float)sumY/(float)count);</span>
<span class="fc" id="L2124">                peaks2.add(sumX, sumY);</span>
            }
            
<span class="fc" id="L2127">            peaks.removeRange(0, peaks.getN() - 1);</span>
<span class="fc" id="L2128">            peaks.addAll(peaks2);</span>
        }
        
<span class="fc" id="L2131">    }</span>

    private void mergeOrAppendGreyWithOthers(ImageExt input, 
        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups, 
        List&lt;Set&lt;PairInt&gt;&gt; groupList, Set&lt;PairInt&gt; blackPixels,
        Set&lt;PairInt&gt; whitePixels) {
                
<span class="fc" id="L2138">        Map&lt;PairInt, Integer&gt; colorPixGroupMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="fc" id="L2140">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="fc" id="L2141">            Integer groupKey = Integer.valueOf(i);</span>
<span class="fc bfc" id="L2142" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L2143">                colorPixGroupMap.put(p, groupKey);</span>
<span class="fc" id="L2144">            }</span>
        }

        // similarity limit for a grey pixel to join adjacent color pixel's cluster
<span class="fc" id="L2148">        int limit = 40;</span>
        
<span class="fc" id="L2150">        int w = input.getWidth();</span>
<span class="fc" id="L2151">        int h = input.getHeight();</span>
        
<span class="fc" id="L2153">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L2154">        int[] dys = Misc.dy8;</span>
<span class="fc bfc" id="L2155" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; greyGroup : greyPixelGroups) {</span>
            
<span class="fc" id="L2157">            Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>
            
<span class="fc bfc" id="L2159" title="All 2 branches covered.">            for (PairInt greyP : greyGroup) {</span>
<span class="fc" id="L2160">                int x = greyP.getX();</span>
<span class="fc" id="L2161">                int y = greyP.getY();</span>
                
<span class="fc" id="L2163">                int idx = input.getInternalIndex(x, y);</span>
<span class="fc" id="L2164">                int r = input.getR(idx);</span>
<span class="fc" id="L2165">                int g = input.getG(idx);</span>
<span class="fc" id="L2166">                int b = input.getB(idx);</span>
                
                // ---- check for color similarity ------
<span class="fc" id="L2169">                int minDiffRGB = Integer.MAX_VALUE;</span>
<span class="fc" id="L2170">                int colorClusterIdx = -1;</span>
<span class="fc" id="L2171">                int minDiffBlack = Integer.MAX_VALUE;</span>
<span class="fc" id="L2172">                int minDiffWhite = Integer.MAX_VALUE;</span>
                
<span class="fc bfc" id="L2174" title="All 2 branches covered.">                for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="fc" id="L2175">                    int x2 = x + dxs[i];</span>
<span class="fc" id="L2176">                    int y2 = y + dys[i];</span>
<span class="fc bfc" id="L2177" title="All 8 branches covered.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="fc" id="L2178">                        continue;</span>
                    }
<span class="fc" id="L2180">                    PairInt p2 = new PairInt(x2, y2);</span>
                    
<span class="fc" id="L2182">                    boolean adjIsBlack = blackPixels.contains(p2);</span>
<span class="fc" id="L2183">                    boolean adjIsWhite = whitePixels.contains(p2);</span>
                    
<span class="fc" id="L2185">                    Integer colorClusterIndex = colorPixGroupMap.get(p2);</span>
<span class="fc bfc" id="L2186" title="All 6 branches covered.">                    if ((colorClusterIndex == null) &amp;&amp; !adjIsBlack &amp;&amp; !adjIsWhite) {</span>
<span class="fc" id="L2187">                        continue;</span>
                    }
                                        
<span class="fc" id="L2190">                    int idx2 = input.getInternalIndex(x2, y2);</span>
<span class="fc" id="L2191">                    int r2 = input.getR(idx2);</span>
<span class="fc" id="L2192">                    int g2 = input.getG(idx2);</span>
<span class="fc" id="L2193">                    int b2 = input.getB(idx2);</span>
                    
<span class="fc" id="L2195">                    int diffR = Math.abs(r2 - r);</span>
<span class="fc" id="L2196">                    int diffG = Math.abs(g2 - g);</span>
<span class="fc" id="L2197">                    int diffB = Math.abs(b2 - b);</span>
                    
<span class="fc" id="L2199">                    int diffRGB = diffR + diffG + diffB;</span>
                    
<span class="fc bfc" id="L2201" title="All 2 branches covered.">                    if (adjIsBlack) {</span>
<span class="fc bfc" id="L2202" title="All 4 branches covered.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="fc" id="L2203">                            minDiffBlack = diffR;</span>
                        }
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                    } else if (adjIsWhite) {</span>
<span class="fc bfc" id="L2206" title="All 4 branches covered.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="fc" id="L2207">                            minDiffWhite = diffR;</span>
                        }
                    } else {
<span class="fc bfc" id="L2210" title="All 4 branches covered.">                        if ((diffRGB &lt; minDiffRGB) &amp;&amp; (diffRGB &lt; limit)) {</span>
<span class="fc" id="L2211">                            minDiffRGB = diffRGB;</span>
<span class="fc" id="L2212">                            colorClusterIdx = colorClusterIndex.intValue();</span>
<span class="fc" id="L2213">                            diffR = Math.abs(r2 - r); </span>
<span class="fc" id="L2214">                            diffG = Math.abs(g2 - g);</span>
<span class="fc" id="L2215">                            diffB = Math.abs(b2 - b);</span>
                        }
                    }
                }
<span class="fc bfc" id="L2219" title="All 2 branches covered.">                if (minDiffBlack &lt; 75) {</span>
<span class="fc" id="L2220">                    blackPixels.add(greyP);</span>
<span class="fc" id="L2221">                    remove.add(greyP);</span>
<span class="fc" id="L2222">                    continue;</span>
<span class="fc bfc" id="L2223" title="All 2 branches covered.">                } else if (minDiffWhite &lt; 75) {</span>
<span class="fc" id="L2224">                    whitePixels.add(greyP);</span>
<span class="fc" id="L2225">                    remove.add(greyP);</span>
<span class="fc" id="L2226">                    continue;</span>
                } else {
<span class="fc bfc" id="L2228" title="All 2 branches covered.">                    if (colorClusterIdx != -1) {</span>
                        //add to color cluster and remove from grey list
<span class="fc" id="L2230">                        groupList.get(colorClusterIdx).add(greyP);</span>
<span class="fc" id="L2231">                        remove.add(greyP);</span>
<span class="fc" id="L2232">                        continue;</span>
                    }
                }
<span class="fc" id="L2235">            }</span>
<span class="fc bfc" id="L2236" title="All 2 branches covered.">            for (PairInt rm : remove) {</span>
<span class="fc" id="L2237">                greyGroup.remove(rm);</span>
<span class="fc" id="L2238">            }</span>
<span class="fc" id="L2239">        }</span>

        // any remaining points in the grey list should be added as sets to
        // the color pixels list now
<span class="fc bfc" id="L2243" title="All 2 branches covered.">        for (int i = 0; i &lt; greyPixelGroups.size(); ++i) {</span>
<span class="fc" id="L2244">            Set&lt;PairInt&gt; greyGroup = greyPixelGroups.get(i);</span>
<span class="fc" id="L2245">            groupList.add(greyGroup);</span>
        }
<span class="fc" id="L2247">        greyPixelGroups.clear();</span>
<span class="fc" id="L2248">    }</span>
    
    protected double[] findMinMaxTheta(ImageExt input, Set&lt;PairInt&gt; points0) {
        
<span class="fc" id="L2252">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="fc" id="L2254">        double[] minMaxTheta = new double[2];</span>
        
<span class="fc bfc" id="L2256" title="All 2 branches covered.">        for (PairInt p : points0) {</span>
<span class="fc" id="L2257">            int x = p.getX();</span>
<span class="fc" id="L2258">            int y = p.getY();</span>
            
<span class="fc" id="L2260">            double thetaRadians = cieC.calculateXYTheta(x, y);</span>
<span class="fc" id="L2261">            double theta = thetaRadians * 180. / Math.PI;</span>

<span class="pc bpc" id="L2263" title="1 of 2 branches missed.">            if (theta &lt; minMaxTheta[0]) {</span>
<span class="nc" id="L2264">                minMaxTheta[0] = theta;</span>
            }
<span class="fc bfc" id="L2266" title="All 2 branches covered.">            if (theta &gt; minMaxTheta[1]) {</span>
<span class="fc" id="L2267">                minMaxTheta[1] = theta;</span>
            }
<span class="fc" id="L2269">        }</span>
        
<span class="fc" id="L2271">        return minMaxTheta;</span>
    }

    private void populatePixelLists(ImageExt input, Set&lt;PairInt&gt; points0, 
        Set&lt;PairInt&gt; blackPixels, Set&lt;PairInt&gt; whitePixels, 
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {
        
<span class="fc" id="L2278">        int w = input.getWidth();</span>
<span class="fc" id="L2279">        int h = input.getHeight();</span>
        
<span class="fc" id="L2281">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="fc bfc" id="L2283" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L2284" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L2286">                int idx = input.getInternalIndex(i, j);</span>

<span class="fc" id="L2288">                int r = input.getR(idx);</span>
<span class="fc" id="L2289">                int g = input.getG(idx);</span>
<span class="fc" id="L2290">                int b = input.getB(idx);</span>

                //dark grey, such as r,g,b=105,105,105?
<span class="fc bfc" id="L2293" title="All 6 branches covered.">                if ((r &lt;= 32) &amp;&amp; (g &lt;= 32) &amp;&amp; (b &lt;= 32)) {</span>
<span class="fc" id="L2294">                    blackPixels.add(new PairInt(i, j));</span>
<span class="fc" id="L2295">                    continue;</span>
                }

<span class="fc" id="L2298">                float cx = input.getCIEX(idx);</span>
<span class="fc" id="L2299">                float cy = input.getCIEY(idx);</span>

<span class="fc bfc" id="L2301" title="All 2 branches covered.">                if (cieC.isWhite2(cx, cy)) {</span>
                    //grey will be binned into clusters by avgRGB and peak frequency
<span class="fc bfc" id="L2303" title="All 6 branches covered.">                    if ((r &lt;= 191) &amp;&amp; (g &lt;= 191) &amp;&amp; (b &lt;= 191)) {</span>
<span class="fc" id="L2304">                        Integer avgRGB = Integer.valueOf(Math.round((r + g + b)/3.f));</span>
<span class="fc" id="L2305">                        Collection&lt;PairInt&gt; set = greyPixelMap.get(avgRGB);</span>
<span class="fc bfc" id="L2306" title="All 2 branches covered.">                        if (set == null) {</span>
<span class="fc" id="L2307">                            set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2308">                            greyPixelMap.put(avgRGB, set);</span>
                        }
<span class="fc" id="L2310">                        set.add(new PairInt(i, j));</span>
<span class="fc" id="L2311">                    } else {</span>
<span class="fc" id="L2312">                        whitePixels.add(new PairInt(i, j));</span>
                    }
<span class="fc" id="L2314">                    continue;</span>
                }

<span class="fc" id="L2317">                points0.add(new PairInt(i, j));                </span>
            }
        }
<span class="fc" id="L2320">    }</span>

    private void mergeNoise(ImageExt input, List&lt;Set&lt;PairInt&gt;&gt; groupList) {
        
<span class="nc" id="L2324">        Map&lt;PairInt, Integer&gt; pixelToGroupMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="nc bnc" id="L2325" title="All 2 branches missed.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="nc" id="L2326">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L2328">                pixelToGroupMap.put(p, Integer.valueOf(i));</span>
<span class="nc" id="L2329">            }</span>
        }
                
<span class="nc" id="L2332">        final int w = input.getWidth();</span>
<span class="nc" id="L2333">        final int h = input.getHeight();</span>
        
<span class="nc" id="L2335">        int[] dxs8 = Misc.dx8;</span>
<span class="nc" id="L2336">        int[] dys8 = Misc.dy8;</span>
        
<span class="nc" id="L2338">        float diffLimit = 0.01f;</span>
        
<span class="nc bnc" id="L2340" title="All 2 branches missed.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="nc" id="L2341">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="nc" id="L2342">            Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L2344">                int x = p.getX();</span>
<span class="nc" id="L2345">                int y = p.getY();</span>
<span class="nc" id="L2346">                int idx = input.getInternalIndex(x, y);</span>
                
<span class="nc" id="L2348">                float cieX = input.getCIEX(idx);</span>
<span class="nc" id="L2349">                float cieY = input.getCIEY(idx);</span>
                
<span class="nc" id="L2351">                Integer groupIndex = pixelToGroupMap.get(p);</span>
                
                // key=groupIndex, value=number of pixels similar
<span class="nc" id="L2354">                Map&lt;Integer, Integer&gt; groupSimilarCount = new HashMap&lt;Integer, Integer&gt;();</span>
                
                // use cieXY, polar theta of cieXY, or rgb?
<span class="nc bnc" id="L2357" title="All 2 branches missed.">                for (int nIdx = 0; nIdx &lt; dxs8.length; ++nIdx) {</span>
<span class="nc" id="L2358">                    int x2 = x + dxs8[nIdx];</span>
<span class="nc" id="L2359">                    int y2 = y + dys8[nIdx];</span>
<span class="nc bnc" id="L2360" title="All 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L2361">                        continue;</span>
                    }
<span class="nc" id="L2363">                    int idx2 = input.getInternalIndex(x2, y2);</span>
                    
<span class="nc" id="L2365">                    Integer groupIndex2 = pixelToGroupMap.get(new PairInt(x2, y2));</span>
                    
<span class="nc bnc" id="L2367" title="All 2 branches missed.">                    if (groupIndex.intValue() == groupIndex2.intValue()) {</span>
<span class="nc" id="L2368">                        continue;</span>
                    }
                    
<span class="nc" id="L2371">                    float cieX2 = input.getCIEX(idx2);</span>
<span class="nc" id="L2372">                    float cieY2 = input.getCIEY(idx2);</span>
                    
<span class="nc" id="L2374">                    float diffCIEX = Math.abs(cieX2 - cieX);</span>
<span class="nc" id="L2375">                    float diffCIEY = Math.abs(cieY2 - cieY);</span>
                    
<span class="nc bnc" id="L2377" title="All 4 branches missed.">                    if ((diffCIEX &gt; diffLimit) || (diffCIEY &gt; diffLimit)) {</span>
<span class="nc" id="L2378">                        continue;</span>
                    }
                    
<span class="nc" id="L2381">                    Integer count = groupSimilarCount.get(groupIndex2);</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">                    if (count == null) {</span>
<span class="nc" id="L2383">                        groupSimilarCount.put(groupIndex2, Integer.valueOf(1));</span>
                    } else {
<span class="nc" id="L2385">                        groupSimilarCount.put(groupIndex2, Integer.valueOf(count.intValue() + 11));</span>
                    }
                   
                }
<span class="nc bnc" id="L2389" title="All 2 branches missed.">                if (groupSimilarCount.isEmpty()) {</span>
<span class="nc" id="L2390">                    continue;</span>
                }
<span class="nc bnc" id="L2392" title="All 2 branches missed.">                for (Entry&lt;Integer, Integer&gt; entry : groupSimilarCount.entrySet()) {</span>
<span class="nc bnc" id="L2393" title="All 2 branches missed.">                    if (entry.getValue() &gt;= 6) {</span>
                        // assign this group to pixel p
<span class="nc" id="L2395">                        pixelToGroupMap.put(p, entry.getKey());</span>
<span class="nc" id="L2396">                        remove.add(p);</span>
<span class="nc" id="L2397">                        groupList.get(entry.getKey().intValue()).add(p);</span>
<span class="nc" id="L2398">                        break;</span>
                    }
<span class="nc" id="L2400">                }</span>
<span class="nc" id="L2401">            }</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">            for (PairInt rm : remove) {</span>
<span class="nc" id="L2403">                set.remove(rm);</span>
<span class="nc" id="L2404">            }</span>
        }
<span class="nc" id="L2406">    }</span>

<span class="fc" id="L2408">    public static class PairIntWithIndex extends com.climbwithyourfeet.clustering.util.PairInt {</span>

        int pixIdx;

        public PairIntWithIndex(int xPoint, int yPoint, int thePixIndex) {
            super(xPoint, yPoint);
            pixIdx = thePixIndex;
        }

        @Override
        public boolean equals(Object obj) {

            if (!(obj instanceof com.climbwithyourfeet.clustering.util.PairInt)) {
                return false;
            }

            com.climbwithyourfeet.clustering.util.PairInt other
                = (com.climbwithyourfeet.clustering.util.PairInt) obj;

            return (x == other.getX()) &amp;&amp; (y == other.getY());
        }

        @Override
        public int hashCode() {

            int hash = fnvHashCode(this.x, this.y);

            return hash;
        }

        @Override
        public com.climbwithyourfeet.clustering.util.PairInt copy() {
             return new PairIntWithIndex(x, y, pixIdx);
        }

        @Override
        public String toString() {

            StringBuilder sb = new StringBuilder(super.toString());
            sb.append(&quot; pixIdx=&quot;).append(Integer.toString(pixIdx));

            return sb.toString();
        }

    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
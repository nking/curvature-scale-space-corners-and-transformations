<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImageSegmentation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageSegmentation.java</span></div><h1>ImageSegmentation.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.QuickSort;
import algorithms.compGeometry.MiscellaneousCurveHelper;
import algorithms.heapsAndPQs.Heap;
import algorithms.heapsAndPQs.HeapNode;
import algorithms.imageProcessing.features.PhaseCongruencyDetector;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import gnu.trove.set.TIntSet;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 * Many methods in here will be removed soon.
 * Meanwhile, see MSEREdges.java for segmentation.
 * 
 * class holding several different image segmentation methods.  Note that
 * some other techniques involving contrast for example, are elsewhere.
 *
 * A few of the methods use a density based clustering algorithm from
       http://nking.github.io/two-point-correlation/
       which has an MIT license
      ---- begin nking copyright ----
      The MIT License (MIT)
      Copyright (c) 2013-* Nichole King
      http://nking.github.io/two-point-correlation/

        Permission is hereby granted, free of charge, to any person obtaining 
        a copy of this software and associated documentation files 
        (the &quot;Software&quot;), to deal in the Software without restriction, 
        including without limitation the rights to use, copy, modify, merge, 
        publish, distribute, sublicense, and/or sell copies of the Software, 
        and to permit persons to whom the Software is furnished to do so, 
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included 
        in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS 
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     ---- end nking copyright ---- 
 * 
 * @author nichole
 */
<span class="fc" id="L59">public class ImageSegmentation {</span>

<span class="fc" id="L61">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * given the list of edges, populate the output arrays with color informaion
     * from the edge points and their 8 neighbor regions.
     * note that any points in more than one output list originally because of
     * being a junction, are corrected and placed in the most similar list.
     *
     * @param img
     * @param edges
     * @param junctions
     * @param outputPoints
     * @param outputDescripors access as [edgeListIndex][(h, s, v, nPix, cenX, cenY)]
     * @param clrSpace color space to fill the descriptors with: 0 is lab, 1 is hsv
     */
    private void populateEdgeLists(ImageExt img,
        List&lt;PairIntArray&gt; edges,
        List&lt;Set&lt;PairInt&gt;&gt; outputPoints, float[][] outputDescripors,
        int clrSpace) {

<span class="fc" id="L81">        int w = img.getWidth();</span>
<span class="fc" id="L82">        int h = img.getHeight();</span>

        // ----- gather edge points and their 8 neighbors into edge point sets ----

<span class="fc" id="L86">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L87">        int[] dys = Misc.dy8;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); ++i) {</span>
<span class="fc" id="L89">            PairIntArray edge = edges.get(i);</span>
<span class="fc" id="L90">            Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="fc" id="L92">                int x = edge.getX(j);</span>
<span class="fc" id="L93">                int y = edge.getY(j);</span>
<span class="fc" id="L94">                set.add(new PairInt(x, y));</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L96">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L97">                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L98" title="4 of 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || </span>
                        (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {
<span class="nc" id="L100">                        continue;</span>
                    }
<span class="fc" id="L102">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L103">                    set.add(p2);</span>
                }
            }
<span class="fc" id="L106">            outputPoints.add(set);</span>
        }

<span class="fc" id="L109">        float n = img.getNPixels();</span>

        // ----- calculate descriptors of the color and location of the edge points -----

<span class="fc" id="L113">        populateDescriptors(img, outputPoints, outputDescripors, clrSpace);</span>

        /*
        the descriptors are
             C_i = {h, s, v, nPix, cenX, cenY}  or labL, labA, labB for colorSpace = 0
        */

        // ======= correct for any points in more than one list ======

        // --- map the list indexes that a point is in --------
<span class="fc" id="L123">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; pointIndexes = new HashMap&lt;PairInt, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (int i = 0; i &lt; outputPoints.size(); ++i) {</span>
<span class="fc" id="L126">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L127">            Set&lt;PairInt&gt; edgePoints = outputPoints.get(i);</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            for (PairInt p : edgePoints) {</span>
<span class="fc" id="L129">                Set&lt;Integer&gt; indexes = pointIndexes.get(p);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if (indexes == null) {</span>
<span class="fc" id="L131">                    indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L132">                    pointIndexes.put(p, indexes);</span>
                }
<span class="fc" id="L134">                indexes.add(key);</span>
<span class="fc" id="L135">            }</span>
        }

<span class="fc" id="L138">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // ---- when a point is in more than one list, choose to keep it in the
        //      list with smallest difference from it in color and remove it from others.

<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="fc" id="L144">            Set&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (indexes.size() == 1) {</span>
<span class="fc" id="L146">                continue;</span>
            }
<span class="fc" id="L148">            PairInt p = entry.getKey();</span>
<span class="fc" id="L149">            int x = p.getX();</span>
<span class="fc" id="L150">            int y = p.getY();</span>
            float c1, c2, c3;
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (clrSpace == 0) {</span>
<span class="fc" id="L153">                float[] lab = img.getCIELAB(x, y);</span>
<span class="fc" id="L154">                c1 = lab[0];</span>
<span class="fc" id="L155">                c2 = lab[1];</span>
<span class="fc" id="L156">                c3 = lab[2];</span>
<span class="fc" id="L157">            } else {</span>
                // hsv
<span class="nc" id="L159">                c1 = img.getHue(x, y);</span>
<span class="nc" id="L160">                c2 = img.getSaturation(x, y);</span>
<span class="nc" id="L161">                c3 = img.getBrightness(x, y);</span>
            }
<span class="fc" id="L163">            double minColorDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L164">            Integer minColorDiffIndex = null;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
                //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L167">                float[] desc = outputDescripors[index.intValue()];</span>
                double diff;
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L170">                    diff = Math.abs(cieC.calcDeltaECIE2000(c1, c2, c3,</span>
                        desc[0], desc[1], desc[2]));
                } else {
<span class="nc" id="L173">                    double diff1 = c1 - desc[0];</span>
<span class="nc" id="L174">                    double diff2 = c2 - desc[1];</span>
<span class="nc" id="L175">                    double diff3 = c3 - desc[2];</span>
<span class="nc" id="L176">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }
<span class="fc bfc" id="L178" title="All 2 branches covered.">                if (diff &lt; minColorDiff) {</span>
<span class="fc" id="L179">                    minColorDiff = diff;</span>
<span class="fc" id="L180">                    minColorDiffIndex = index;</span>
                }
<span class="fc" id="L182">            }</span>
<span class="pc bnc" id="L183" title="All 2 branches missed.">            assert(minColorDiffIndex != null);</span>

            // update the lists to remove point
<span class="fc bfc" id="L186" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (index.equals(minColorDiffIndex)) {</span>
<span class="fc" id="L188">                    continue;</span>
                }

<span class="fc" id="L191">                Set&lt;PairInt&gt; set = outputPoints.get(index.intValue());</span>
<span class="fc" id="L192">                float nBefore = set.size();</span>
<span class="fc" id="L193">                set.remove(p);</span>
<span class="fc" id="L194">                float nAfter = set.size();</span>

                ////C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L197">                float[] desc = outputDescripors[index.intValue()];</span>
<span class="fc" id="L198">                desc[0] = ((desc[0] * nBefore) - c1)/nAfter;</span>
<span class="fc" id="L199">                desc[1] = ((desc[1] * nBefore) - c2)/nAfter;</span>
<span class="fc" id="L200">                desc[2] = ((desc[2] * nBefore) - c3)/nAfter;</span>
<span class="fc" id="L201">                desc[3] = nAfter;</span>
<span class="fc" id="L202">                desc[4] = ((desc[4] * nBefore) - x)/nAfter;</span>
<span class="fc" id="L203">                desc[5] = ((desc[5] * nBefore) - y)/nAfter;</span>
<span class="fc" id="L204">            }</span>
<span class="fc" id="L205">        }</span>
<span class="fc" id="L206">    }</span>

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf
      
     * NOTE: parameters in this algorithm are sensitive to
     * the PSF.
     *
     * NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     *
     * @param input
     * @return
    */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        String debugTag) {
        
        // 0 is CIE LAB, 1 is HSV
<span class="fc" id="L230">        final int clrSpace = 0;</span>

<span class="fc" id="L232">        boolean reduceNoise = false;</span>

        double tColor;
        int tLen;
        double tR;
        double tSmallMerge;
        if (clrSpace == 0) {
            // JND for deltaE is ~2.3, so tColor must be that or larger
<span class="fc" id="L240">            tColor = 2.8;//4.0;//5.5;</span>
<span class="fc" id="L241">            tR = 0.8;//1.0;</span>
<span class="fc" id="L242">            tLen = 1;</span>
<span class="fc" id="L243">            tSmallMerge = 0.02;//0.095;</span>
        } else {
            // what is JND for HSV (a.k.a. HSB) ?  each range of values is 0:1
            tColor =  0.125;//0.125;  between 0.1 and 0.175
            tR = 1.5;
            tLen = 5;
            tSmallMerge = 0.02;
        }

<span class="fc" id="L252">        return createColorEdgeSegmentation(input, clrSpace, tLen, tColor, tR,</span>
            reduceNoise, tSmallMerge, debugTag);
    }

    public List&lt;PairIntArray&gt; extractEdges2(Image img,
        String debugTag) {

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L260">            debugTag = &quot;&quot;;</span>
        }

<span class="fc" id="L263">        CannyEdgeFilterAdaptiveDeltaE2000 canny = </span>
            new CannyEdgeFilterAdaptiveDeltaE2000();
<span class="fc" id="L265">        canny.applyFilter(img.copyToImageExt());</span>

<span class="fc" id="L267">        GreyscaleImage gXY = canny.getFilterProducts().getGradientXY();</span>
        
<span class="fc" id="L269">        int w = gXY.getWidth();</span>
<span class="fc" id="L270">        int h = gXY.getHeight();</span>
        
<span class="pc bnc" id="L272" title="All 2 branches missed.">        assert(img.getWidth() == w);</span>
<span class="pc bnc" id="L273" title="All 2 branches missed.">        assert(img.getHeight() == h);</span>
        
<span class="fc" id="L275">        int[][] thinned = new int[w][];</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L277">            thinned[i] = new int[h];</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L279">                thinned[i][j] = gXY.getValue(i, j);</span>
            }
        }

<span class="fc" id="L283">        EdgeExtractorSimple extractor = new EdgeExtractorSimple(thinned);</span>
<span class="fc" id="L284">        extractor.extractEdges();</span>
<span class="fc" id="L285">        List&lt;PairIntArray&gt; edges = new ArrayList&lt;PairIntArray&gt;();</span>
        // put in framework of images
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (int i = 0; i &lt; extractor.getEdges().size(); ++i) {</span>
<span class="fc" id="L288">            PairIntArray edge = extractor.getEdges().get(i).copy();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="fc" id="L290">                int x = edge.getX(j);</span>
<span class="fc" id="L291">                int y = edge.getY(j);</span>
<span class="fc" id="L292">                edge.set(j, x, y);</span>
            }
<span class="fc" id="L294">            edges.add(edge);</span>
        }

<span class="fc" id="L297">        return edges;</span>
    }

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf

     NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     * 
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        int clrSpace, int tLen, double tColor, double tR, boolean reduceNoise,
        double tSmallMerge, String debugTag) {

<span class="fc" id="L319">        List&lt;PairIntArray&gt; edges = extractEdges2(input, debugTag);</span>

        //List&lt;PairIntArray&gt; edges = extractEdges(input, reduceNoise, debugTag);
        
<span class="fc" id="L323">        return createColorEdgeSegmentation(input, edges,</span>
            clrSpace, tLen, tColor, tR, reduceNoise, tSmallMerge, debugTag);
    }

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf

     NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     * 
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        List&lt;PairIntArray&gt; edges,
        int clrSpace, int tLen, double tColor, double tR, boolean reduceNoise,
        double tSmallMerge, String debugTag) {

<span class="fc" id="L347">        boolean doPlot = false;</span>

<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L350">            debugTag = &quot;&quot;;</span>
        }

<span class="fc" id="L353">        final int w = input.getWidth();</span>
<span class="fc" id="L354">        final int h = input.getHeight();</span>
<span class="fc" id="L355">        final int nPix = input.getNPixels();</span>

<span class="fc" id="L357">        int nEdges = edges.size();</span>
<span class="fc" id="L358">        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (nEdges == 0) {</span>
            // add all picels to one set
<span class="nc" id="L362">             Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L365">                    set.add(new PairInt(i, j));</span>
                }
            }
<span class="nc" id="L368">            clusterPoints.add(set);</span>
<span class="nc" id="L369">            return clusterPoints;</span>
        }

<span class="fc" id="L372">        float[][] clusterDescriptors = new float[nEdges][];</span>

<span class="fc" id="L374">        populateEdgeLists(input, edges, clusterPoints, clusterDescriptors,</span>
            clrSpace);

<span class="pc bnc" id="L377" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L379">        List&lt;Integer&gt; longEdgeIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L380">        List&lt;Integer&gt; shortEdgeIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L381">        populateEdgeLengthLists(clusterDescriptors, tLen, longEdgeIndexes,</span>
            shortEdgeIndexes);

<span class="pc bnc" id="L384" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

        // ----------- merge long edges ----------

        // NOTE that the moved sets modify the data structures :
        //    clusterPoints may contain empty items
        //    clusterDescriptors may contain null items
        //    both clusterPoints and clusterDescriptor non- null and non empty
        //       items are updated for merges

        // the authors consider this algorithm of min-heap merging within a
        // radius of color, a kmeans method as it updates the descriptors upon
        // each merge, but the minimum distance ordering is an improvement over
        // standard kmeans if one can use it as one can here
        // (pairs results in outer loop iteration of approx O(N^2),
        // specifically (N*(N-1)/2)), while kmeans ordering by index uses O(N))
<span class="fc" id="L400">        mergeEdges(clusterPoints, clusterDescriptors, clrSpace, tColor,</span>
            longEdgeIndexes);

        //TODO: consider a number limit to use an alternate here when
        //  n edges is a large number.  determine a fixed k and use kmeans.
        //  can roughly determine a fixed k from
        //  a color histogram with bin size being color tolerance
        //  and counting the number of peaks.

<span class="pc bnc" id="L409" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L413">            List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            for (Integer index : longEdgeIndexes) {</span>
<span class="nc" id="L415">                Set&lt;PairInt&gt; set = clusterPoints.get(index.intValue());</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                if (!set.isEmpty()) {</span>
<span class="nc" id="L417">                    tmp.add(set);</span>
                }
<span class="nc" id="L419">            }</span>
<span class="nc" id="L420">            int nExtraForDot = 1;</span>
<span class="nc" id="L421">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L422">            ImageIOHelper.addAlternatingColorPointSetsToImage(tmp, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L424">            MiscDebug.writeImage(img2, &quot;_longEdges_merged_&quot; +  debugTag + &quot;_&quot;</span>
                + clrSpace);
        }

        // ---- merge short edges (which are usually textures) ------

<span class="fc" id="L430">        mergeShortEdges(clusterPoints, clusterDescriptors, clrSpace, tColor,</span>
            shortEdgeIndexes);

<span class="pc bnc" id="L433" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L437">            List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (Integer index : shortEdgeIndexes) {</span>
<span class="nc" id="L439">                Set&lt;PairInt&gt; set = clusterPoints.get(index.intValue());</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (!set.isEmpty()) {</span>
<span class="nc" id="L441">                    tmp.add(set);</span>
                }
<span class="nc" id="L443">            }</span>
<span class="nc" id="L444">            int nExtraForDot = 1;</span>
<span class="nc" id="L445">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L446">            ImageIOHelper.addAlternatingColorPointSetsToImage(tmp, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L448">            MiscDebug.writeImage(img2, &quot;_shortedges_merged_&quot; +  debugTag +</span>
                &quot;_&quot; + clrSpace);
        }

<span class="pc bnc" id="L452" title="All 2 branches missed.">        assert(assertDescriptorCounts(clusterPoints, clusterDescriptors));</span>

<span class="fc" id="L454">        Map&lt;PairInt, Integer&gt; pointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L456">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L457">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L459">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L460">            }</span>
        }

        // ------ region growing -------
<span class="fc" id="L464">        growEdges(input, clusterPoints, clusterDescriptors, pointIndexMap,</span>
            clrSpace, tColor, shortEdgeIndexes, longEdgeIndexes);

<span class="pc bnc" id="L467" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L469">        longEdgeIndexes = null;</span>
<span class="fc" id="L470">        shortEdgeIndexes = null;</span>

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L474">            int nExtraForDot = 1;</span>
<span class="nc" id="L475">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L476">            ImageIOHelper.addAlternatingColorPointSetsToImage(clusterPoints, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L478">            MiscDebug.writeImage(img2, &quot;_after_rgo_&quot; +  debugTag + &quot;_&quot; + clrSpace);</span>
        }

        // ------ merge by color histograms ------

<span class="fc" id="L483">        clusterDescriptors = condenseAndUpdate(clusterPoints,</span>
            clusterDescriptors, pointIndexMap);

<span class="pc bnc" id="L486" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L488">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap = createAdjacencyMap(</span>
            clusterPoints);

<span class="fc" id="L491">        mergeByColorHistograms(input, clusterPoints, adjacencyMap,</span>
            clrSpace, tR);

<span class="pc bnc" id="L494" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L498">            int nExtraForDot = 1;</span>
<span class="nc" id="L499">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L500">            ImageIOHelper.addAlternatingColorPointSetsToImage(clusterPoints, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L502">            MiscDebug.writeImage(img2, &quot;_FINAL_&quot; +  debugTag + &quot;_&quot; + clrSpace);</span>
        }

        // ----- merge smallest clusters into adjacent larger --------
<span class="fc" id="L506">        int tNumber = (int)Math.round(tSmallMerge * nPix);</span>

<span class="fc" id="L508">        clusterDescriptors = condenseAndUpdate(clusterPoints,</span>
            clusterDescriptors, pointIndexMap);

<span class="pc bnc" id="L511" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L513">        mergeSmallClusters(input, clusterPoints, clusterDescriptors,</span>
            clrSpace, tNumber, debugTag);

<span class="pc bnc" id="L516" title="All 2 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L518">        return clusterPoints;</span>
    }

    private void populateEdgeLengthLists(float[][] clusterDescriptors,
        int tLen, List&lt;Integer&gt; longEdgeIndexes,
        List&lt;Integer&gt; shortEdgeIndexes) {

        //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterDescriptors.length; ++i) {</span>
<span class="fc" id="L527">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L528">            float nPix = clusterDescriptors[i][3];</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            if (nPix &lt; tLen) {</span>
<span class="nc" id="L530">                shortEdgeIndexes.add(key);</span>
            } else {
<span class="fc" id="L532">                longEdgeIndexes.add(key);</span>
            }
        }
<span class="fc" id="L535">    }</span>

    private void populateColorDiffHeap(
        float[][] clusterDescriptors, int clrSpace,
        List&lt;Integer&gt; longEdgeIndexes, Heap longEdgesHeap,
        long heapKeyFactor, Map&lt;PairInt, HeapNode&gt; pairEdgePindexNodes) {

        // for heap nodes:
        //     key is the difference in color times a factor to use long instead of double
        //     data is the PairInt holding the indexes compared

<span class="fc" id="L546">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">        for (int i = 0; i &lt; longEdgeIndexes.size(); ++i) {</span>

<span class="fc" id="L550">            int idx1 = longEdgeIndexes.get(i).intValue();</span>
<span class="fc" id="L551">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; longEdgeIndexes.size(); ++j) {</span>

<span class="fc" id="L555">                int idx2 = longEdgeIndexes.get(j).intValue();</span>
<span class="fc" id="L556">                float[] desc2 = clusterDescriptors[idx2];</span>

                double diff;
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L560">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L564">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L565">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L566">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L567">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

                // note that idx1 is always smaller than idx2
<span class="fc" id="L571">                PairInt p12 = new PairInt(idx1, idx2);</span>

<span class="fc" id="L573">                long heapKey = (long)((double)heapKeyFactor * diff);</span>
<span class="fc" id="L574">                HeapNode node = new HeapNode(heapKey);</span>
<span class="fc" id="L575">                node.setData(p12);</span>

<span class="fc" id="L577">                longEdgesHeap.insert(node);</span>

<span class="fc" id="L579">                pairEdgePindexNodes.put(p12, node);</span>
            }
        }
<span class="fc" id="L582">    }</span>

    private void mergeEdges(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, int clrSpace, double tColor,
        List&lt;Integer&gt; edgeIndexes) {

<span class="fc" id="L588">        log.fine(edgeIndexes.size() + &quot; edges&quot;);</span>

<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if (edgeIndexes.isEmpty()) {</span>
<span class="nc" id="L591">            return;</span>
        }

<span class="fc" id="L594">        final long heapKeyFactor = 1000000l;</span>
<span class="fc" id="L595">        Heap heap = new Heap();</span>
<span class="fc" id="L596">        Map&lt;PairInt, HeapNode&gt; pairEdgePindexNodes = new HashMap&lt;PairInt, HeapNode&gt;();</span>
<span class="fc" id="L597">        populateColorDiffHeap(clusterDescriptors, clrSpace,</span>
            edgeIndexes, heap, heapKeyFactor, pairEdgePindexNodes);

        // ---- make a map to find and update merged data structures ------
<span class="fc" id="L601">        Map&lt;Integer, Set&lt;Integer&gt;&gt; indexToIndexMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">        for (PairInt p : pairEdgePindexNodes.keySet()) {</span>

<span class="fc" id="L604">            Integer index1 = Integer.valueOf(p.getX());</span>
<span class="fc" id="L605">            Integer index2 = Integer.valueOf(p.getY());</span>

<span class="fc" id="L607">            Set&lt;Integer&gt; indexes = indexToIndexMap.get(index1);</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L609">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L610">                indexToIndexMap.put(index1, indexes);</span>
            }
<span class="fc" id="L612">            indexes.add(index2);</span>

<span class="fc" id="L614">            indexes = indexToIndexMap.get(index2);</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L616">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L617">                indexToIndexMap.put(index2, indexes);</span>
            }
<span class="fc" id="L619">            indexes.add(index1);</span>
<span class="fc" id="L620">        }</span>

<span class="fc" id="L622">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        while (!heap.isEmpty()) {</span>

<span class="fc" id="L626">            HeapNode node = heap.extractMin();</span>
<span class="fc" id="L627">            double diff = ((double)node.getKey())/((double)heapKeyFactor);</span>

<span class="fc bfc" id="L629" title="All 2 branches covered.">            if (diff &gt; tColor) {</span>
<span class="fc" id="L630">                break;</span>
            }

<span class="fc" id="L633">            PairInt p12 = (PairInt)node.getData();</span>

<span class="fc" id="L635">            int idx1 = p12.getX();</span>
<span class="fc" id="L636">            int idx2 = p12.getY();</span>

<span class="fc" id="L638">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="fc" id="L639">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>

<span class="pc bpc" id="L641" title="2 of 4 branches missed.">            if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="nc" id="L642">                continue;</span>
            }

<span class="fc bfc" id="L645" title="All 2 branches covered.">            if (set2.size() &gt; set1.size()) {</span>
<span class="fc" id="L646">                idx1 = p12.getY();</span>
<span class="fc" id="L647">                idx2 = p12.getX();</span>
<span class="fc" id="L648">                set1 = set2;</span>
<span class="fc" id="L649">                set2 = clusterPoints.get(idx2);</span>
            }

            // set1 is largest

<span class="fc" id="L654">            Integer index1 = Integer.valueOf(idx1);</span>
<span class="fc" id="L655">            Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L657">            float[] desc1 = clusterDescriptors[idx1];</span>
<span class="fc" id="L658">            float[] desc2 = clusterDescriptors[idx2];</span>
<span class="fc" id="L659">            float n1 = set1.size();</span>
<span class="fc" id="L660">            float n2 = set2.size();</span>
<span class="fc" id="L661">            float nTot = n1 + n2;</span>

<span class="pc bnc" id="L663" title="All 2 branches missed.">            assert(Math.abs(n1 - desc1[3]) &lt; 0.1);</span>
<span class="pc bnc" id="L664" title="All 2 branches missed.">            assert(Math.abs(n2 - desc2[3]) &lt; 0.1);</span>

            //{h, s, v, nPix, cenX, cenY}
            // update desc1 contents for contents in desc2
<span class="fc bfc" id="L668" title="All 2 branches covered.">            for (int k = 0; k &lt; desc1.length; ++k) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (k == 3) {</span>
<span class="fc" id="L670">                    desc1[k] = nTot;</span>
                } else {
<span class="fc" id="L672">                    desc1[k] = ((desc1[k] * n1) + (desc2[k] * n2)) / nTot;</span>
                }
            }
<span class="fc" id="L675">            clusterDescriptors[idx2] = null;</span>
<span class="fc" id="L676">            set1.addAll(set2);</span>
<span class="fc" id="L677">            set2.clear();</span>

<span class="fc" id="L679">            n1 = set1.size();</span>

            // remove the idx1 --&gt; set&lt;integer&gt; pairs from map and heap
            // remove the idx2 --&gt; set&lt;integer&gt; pairs from map and heap

<span class="fc" id="L684">            Set&lt;Integer&gt; indexes3 = indexToIndexMap.get(index1);</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L686">                int idx3 = index3.intValue();</span>
<span class="fc" id="L687">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L688" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L689">                    continue;</span>
                }
                //keys in pairEdgePindexNodes have smaller index in x
                PairInt p13;
<span class="fc bfc" id="L693" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L694">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L696">                    p13 = new PairInt(idx3, idx1);</span>
                }
<span class="fc" id="L698">                HeapNode node3 = pairEdgePindexNodes.get(p13);</span>
<span class="pc bnc" id="L699" title="All 2 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L700">                heap.remove(node3);</span>
<span class="fc" id="L701">                pairEdgePindexNodes.remove(p13);</span>
<span class="fc" id="L702">            }</span>

<span class="fc" id="L704">            indexes3 = indexToIndexMap.get(index2);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L706">                int idx3 = index3.intValue();</span>
<span class="fc" id="L707">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="fc bfc" id="L708" title="All 4 branches covered.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="fc" id="L709">                    continue;</span>
                }
                PairInt p23;
<span class="fc bfc" id="L712" title="All 2 branches covered.">                if (idx2 &lt; idx3) {</span>
<span class="fc" id="L713">                    p23 = new PairInt(idx2, idx3);</span>
                } else {
<span class="fc" id="L715">                    p23 = new PairInt(idx3, idx2);</span>
                }
<span class="fc" id="L717">                HeapNode node3 = pairEdgePindexNodes.get(p23);</span>
<span class="pc bnc" id="L718" title="All 2 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L719">                heap.remove(node3);</span>
<span class="fc" id="L720">                pairEdgePindexNodes.remove(p23);</span>
<span class="fc" id="L721">            }</span>

            // update the indexToIndexMap
<span class="fc" id="L724">            Set&lt;Integer&gt; iim = new HashSet&lt;Integer&gt;(indexToIndexMap.get(index2));</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            for (Integer index3 : iim) {</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                if (!index3.equals(index1)) {</span>
<span class="fc" id="L727">                    Set&lt;Integer&gt; indexes4 = indexToIndexMap.get(index3);</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                    if (indexes4 != null) {</span>
<span class="fc" id="L729">                        indexes4.remove(index2);</span>
<span class="fc" id="L730">                        indexes4.add(index1);</span>
                    }
                }
<span class="fc" id="L733">            }</span>
<span class="fc" id="L734">            indexes3.addAll(iim);</span>
<span class="fc" id="L735">            indexes3.remove(index2);</span>
<span class="fc" id="L736">            indexToIndexMap.remove(index2);</span>

            // add node for updated idx1 ---&gt; set&lt;integer&gt; to map and node
<span class="fc" id="L739">            indexes3 = indexToIndexMap.get(Integer.valueOf(idx1));</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L741">                int idx3 = index3.intValue();</span>
<span class="fc" id="L742">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L743" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L744">                    continue;</span>
                }
                //keys in pairEdgePindexNodes have smaller index in x
                PairInt p13;
<span class="fc bfc" id="L748" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L749">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L751">                    p13 = new PairInt(idx3, idx1);</span>
                }

<span class="fc" id="L754">                float[] desc3 = clusterDescriptors[idx3];</span>

                double diffUpdated;
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L758">                    diffUpdated = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc3[0], desc3[1], desc3[2]));
                } else {
<span class="nc" id="L762">                    double diff1 = desc1[0] - desc3[0];</span>
<span class="nc" id="L763">                    double diff2 = desc1[1] - desc3[1];</span>
<span class="nc" id="L764">                    double diff3 = desc1[2] - desc3[2];</span>
<span class="nc" id="L765">                    diffUpdated = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

<span class="fc" id="L768">                long heapKey = (long)((double)heapKeyFactor * diffUpdated);</span>
<span class="fc" id="L769">                HeapNode node3 = new HeapNode(heapKey);</span>
<span class="fc" id="L770">                node3.setData(p13);</span>
<span class="fc" id="L771">                heap.insert(node3);</span>
<span class="fc" id="L772">                pairEdgePindexNodes.put(p13, node3);</span>
<span class="fc" id="L773">            }</span>

            // pairs having set2 will be skipped because of the empty set at beginning of while loop
<span class="fc" id="L776">        }</span>
<span class="fc" id="L777">    }</span>

    private void growEdges(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors,
        Map&lt;PairInt, Integer&gt; pointIndexMap, int clrSpace, double tColor,
        List&lt;Integer&gt; shortEdgeIndexes, List&lt;Integer&gt; longEdgeIndexes) {

<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (pointIndexMap.isEmpty()) {</span>
<span class="nc" id="L786">            return;</span>
        }

        /*
        traverse all image points to make a map of unassigned pixels and the
            cluster indexes they are adjacent to if any.
            --&gt; O(N)

        initialize an outer queue with the unassigned which have nIndexes &gt; 0
           sorted by descending number of adjacenct indexes
           --&gt; O(N_i * lg2(N_i))

        create an inner queue

        --&gt; O(|V| + |E|)
        visit each outer queue member, adding it to adjacent cluster
           which has most similar color.
           update the cluster's descriptor
           add each of the 8 neighbors which aren't assigned to the inner
              queue.
           add the point to the visited set.
        when all outer queue members have been visited, fill the outer queue
            with the inner queue and empty the inner queue.
            (could sort again here for more precise growing)
        continue in this manner until the inner queue is empty and hence outer
            queue is empty.
            assert that visited.size == unassigned map.size

        The same pattern should be applied elsewhere too
        */

        // for each edge, add neighbors with diff &lt; tColor
        //    if an adjacent pixel is part of a short edge cluster,
        //    then all of that short edge is added to the cluster

        // removing short edge points from pointIndexMap and creating
        // shortPointIndexMap to more easily add them as a whole
<span class="fc" id="L823">        Map&lt;PairInt, Integer&gt; shortPointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">        for (Integer index : shortEdgeIndexes) {</span>
<span class="nc" id="L825">            int idx = index.intValue();</span>
<span class="nc" id="L826">            Set&lt;PairInt&gt; set = clusterPoints.get(idx);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L828">                shortPointIndexMap.put(p, index);</span>
<span class="nc" id="L829">                pointIndexMap.remove(p);</span>
<span class="nc" id="L830">            }</span>
<span class="nc" id="L831">        }</span>

<span class="fc" id="L833">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L835">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L836">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L838">        int width = img.getWidth();</span>
<span class="fc" id="L839">        int height = img.getHeight();</span>

        /*
        on first iteration, the edge regions are grown to include adjacent points
        that are within tColor tolerance and short edges which are ajacent
        regardless of color difference.

        on second iteration, unassigned pixels are added to adjacent indexes
        most similar in color.
        */

<span class="fc" id="L850">        int lastInnerQ = 0;</span>

<span class="fc bfc" id="L852" title="All 2 branches covered.">        for (int nIter = 0; nIter &lt; 2; ++nIter) {</span>

<span class="fc" id="L854">            Map&lt;PairInt, Set&lt;Integer&gt;&gt; unassignedAndIndexes =</span>
<span class="fc" id="L855">                findUnassignedPixelsAndAdjacentIndexes(img, pointIndexMap);</span>

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">            if (unassignedAndIndexes.isEmpty()) {</span>
<span class="nc" id="L858">                return;</span>
            }

<span class="pc" id="L861">            assert(img.getNPixels() == (unassignedAndIndexes.size() +</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">                pointIndexMap.size()));</span>

<span class="fc" id="L864">            int count = 0;</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry : unassignedAndIndexes.entrySet()) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">                if (entry.getValue().size() &gt; 0) {</span>
<span class="fc" id="L867">                    ++count;</span>
                }
<span class="fc" id="L869">            }</span>
<span class="fc" id="L870">            PairInt[] unassigned = new PairInt[count];</span>
<span class="fc" id="L871">            int[] nAdjIndexes = new int[unassigned.length];</span>
<span class="fc" id="L872">            count = 0;</span>
            for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry :
<span class="fc bfc" id="L874" title="All 2 branches covered.">                unassignedAndIndexes.entrySet()) {</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">                if (entry.getValue().size() &gt; 0) {</span>
<span class="fc" id="L876">                    unassigned[count] = entry.getKey();</span>
<span class="fc" id="L877">                    nAdjIndexes[count] = entry.getValue().size();</span>
<span class="fc" id="L878">                    ++count;</span>
                }
<span class="fc" id="L880">            }</span>
<span class="fc" id="L881">            QuickSort.sortBy1stArg(nAdjIndexes, unassigned);</span>
<span class="fc" id="L882">            ArrayDeque&lt;PairInt&gt; outerQueue = new ArrayDeque&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">            for (int i = (unassigned.length - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L884">                outerQueue.add(unassigned[i]);</span>
            }

<span class="fc" id="L887">            ArrayDeque&lt;PairInt&gt; innerQueue = new ArrayDeque&lt;PairInt&gt;();</span>
            while (true) {
<span class="fc bfc" id="L889" title="All 2 branches covered.">                while (!outerQueue.isEmpty()) {</span>
<span class="fc" id="L890">                    PairInt p = outerQueue.poll();</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">                    if (pointIndexMap.containsKey(p)) {</span>
<span class="fc" id="L892">                        continue;</span>
                    }
<span class="fc" id="L894">                    int x = p.getX();</span>
<span class="fc" id="L895">                    int y = p.getY();</span>
<span class="fc" id="L896">                    boolean isAShortEdge = shortPointIndexMap.containsKey(p);</span>
                    float[] clrs1;
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">                    if (isAShortEdge) {</span>
<span class="nc" id="L899">                        clrs1 = clusterDescriptors[shortPointIndexMap.get(p).intValue()];</span>
                    } else {
<span class="fc" id="L901">                        clrs1 = getColors(img, x, y, clrSpace);</span>
                    }

<span class="fc" id="L904">                    double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L905">                    Integer minDiffIndex = null;</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L907">                        int x2 = x + dxs[k];</span>
<span class="fc" id="L908">                        int y2 = y + dys[k];</span>
<span class="fc bfc" id="L909" title="All 8 branches covered.">                        if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (width - 1))</span>
                            || (y2 &gt; (height - 1))) {
<span class="fc" id="L911">                            continue;</span>
                        }
<span class="fc" id="L913">                        PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L914">                        Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">                        if (index2 == null) {</span>
<span class="fc" id="L916">                            continue;</span>
                        } else {
<span class="pc bpc" id="L918" title="3 of 4 branches missed.">                            if (isAShortEdge &amp;&amp; index2.equals(shortPointIndexMap.get(p))) {</span>
<span class="nc" id="L919">                                continue;</span>
                            }
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">                            if (clusterPoints.get(index2.intValue()).isEmpty()) {</span>
<span class="nc" id="L922">                                continue;</span>
                            }
                        }
<span class="fc" id="L925">                        float[] desc2 = clusterDescriptors[index2.intValue()];</span>
                        double diff;
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">                        if (clrSpace == 0) {</span>
<span class="fc" id="L928">                            diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                                clrs1[0], clrs1[1], clrs1[2], desc2[0], desc2[1], desc2[2]));
                        } else {
<span class="nc" id="L931">                            double diff1 = clrs1[0] - desc2[0];</span>
<span class="nc" id="L932">                            double diff2 = clrs1[1] - desc2[1];</span>
<span class="nc" id="L933">                            double diff3 = clrs1[2] - desc2[2];</span>
<span class="nc" id="L934">                            diff = Math.sqrt(diff1 * diff1 + diff2 * diff2 + diff3 * diff3);</span>
                        }
<span class="pc bpc" id="L936" title="1 of 6 branches missed.">                        if ((nIter == 0) &amp;&amp; !isAShortEdge &amp;&amp; (diff &gt; tColor)) {</span>
<span class="fc" id="L937">                            continue;</span>
                        }
<span class="fc bfc" id="L939" title="All 2 branches covered.">                        if (diff &lt; minDiff) {</span>
<span class="fc" id="L940">                            minDiff = diff;</span>
<span class="fc" id="L941">                            minDiffIndex = index2;</span>
                        }
                    }
<span class="fc bfc" id="L944" title="All 2 branches covered.">                    if (minDiffIndex == null) {</span>
<span class="fc" id="L945">                        continue;</span>
                    }
<span class="fc" id="L947">                    int idx2 = minDiffIndex.intValue();</span>
<span class="fc" id="L948">                    Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="fc" id="L949">                    float[] desc2 = clusterDescriptors[idx2];</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">                    if (isAShortEdge) {</span>
<span class="nc" id="L951">                        Integer index1 = shortPointIndexMap.get(p);</span>
<span class="nc" id="L952">                        int idx1 = index1.intValue();</span>
<span class="nc" id="L953">                        Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="nc" id="L954">                        float[] desc1 = clusterDescriptors[idx1];</span>
<span class="nc" id="L955">                        float n1 = set1.size();</span>
<span class="nc" id="L956">                        float n2 = set2.size();</span>
<span class="nc" id="L957">                        float nTot = n1 + n2;</span>
                        //{h, s, v, nPix, cenX, cenY}
<span class="nc bnc" id="L959" title="All 2 branches missed.">                        for (int k = 0; k &lt; 6; ++k) {</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                            if (k == 3) {</span>
<span class="nc" id="L961">                                desc2[k] = nTot;</span>
                            } else {
<span class="nc" id="L963">                                desc2[k] = ((desc2[k] * n2) + desc1[k] * n1)/nTot;</span>
                            }
                        }
                        //add unassigned perimeter of short edge to innerqueue
<span class="nc bnc" id="L967" title="All 2 branches missed.">                        for (PairInt p3 : set1) {</span>
<span class="nc" id="L968">                            shortPointIndexMap.remove(p3);</span>
<span class="nc" id="L969">                            pointIndexMap.put(p3, minDiffIndex);</span>
<span class="nc" id="L970">                            set2.add(p3);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L972">                                int x4 = p3.getX() + dxs[k];</span>
<span class="nc" id="L973">                                int y4 = p3.getY() + dys[k];</span>
<span class="nc bnc" id="L974" title="All 8 branches missed.">                                if (x4 &lt; 0 || y4 &lt; 0 || (x4 &gt; (width - 1))</span>
                                    || (y4 &gt; (height - 1))) {
<span class="nc" id="L976">                                    continue;</span>
                                }
<span class="nc" id="L978">                                PairInt p4 = new PairInt(x4, y4);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">                                if (!shortPointIndexMap.containsKey(p4) &amp;&amp;</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                                    !pointIndexMap.containsKey(p4)) {</span>
<span class="nc" id="L981">                                    innerQueue.offer(p4);</span>
                                }
                            }
<span class="nc" id="L984">                        }</span>
<span class="nc" id="L985">                        clusterDescriptors[idx1] = null;</span>
<span class="nc" id="L986">                        set1.clear();</span>
<span class="nc" id="L987">                    } else {</span>
<span class="fc" id="L988">                        float n2 = set2.size();</span>
<span class="fc" id="L989">                        float nTot = n2 + 1;</span>
                        //{h, s, v, nPix, cenX, cenY}
<span class="fc" id="L991">                        desc2[0] = ((desc2[0] * n2) + clrs1[0])/nTot;</span>
<span class="fc" id="L992">                        desc2[1] = ((desc2[1] * n2) + clrs1[1])/nTot;</span>
<span class="fc" id="L993">                        desc2[2] = ((desc2[2] * n2) + clrs1[2])/nTot;</span>
<span class="fc" id="L994">                        desc2[3] = nTot;</span>
<span class="fc" id="L995">                        desc2[4] = ((desc2[4] * n2) + x)/nTot;</span>
<span class="fc" id="L996">                        desc2[5] = ((desc2[5] * n2) + y)/nTot;</span>

<span class="fc" id="L998">                        pointIndexMap.put(p, minDiffIndex);</span>
<span class="fc" id="L999">                        set2.add(p);</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">                        for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1001">                            int x4 = x + dxs[k];</span>
<span class="fc" id="L1002">                            int y4 = y + dys[k];</span>
<span class="fc bfc" id="L1003" title="All 8 branches covered.">                            if (x4 &lt; 0 || y4 &lt; 0 || (x4 &gt; (width - 1))</span>
                                || (y4 &gt; (height - 1))) {
<span class="fc" id="L1005">                                continue;</span>
                            }
<span class="fc" id="L1007">                            PairInt p4 = new PairInt(x4, y4);</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">                            if (!shortPointIndexMap.containsKey(p4) &amp;&amp;</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">                                !pointIndexMap.containsKey(p4)) {</span>
<span class="fc" id="L1010">                                innerQueue.offer(p4);</span>
                            }
                        }
                    }
<span class="fc" id="L1014">                }</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">                if (innerQueue.isEmpty()) {</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                    if (nIter == 0) {</span>
<span class="fc" id="L1017">                        break;</span>
                    }
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">                    if (!shortPointIndexMap.isEmpty()) {</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                        if (shortPointIndexMap.size() == lastInnerQ) {</span>
<span class="nc" id="L1021">                            return;</span>
                        }
<span class="nc" id="L1023">                        innerQueue.addAll(shortPointIndexMap.keySet());</span>
<span class="nc" id="L1024">                        lastInnerQ = shortPointIndexMap.size();</span>
                    } else {
<span class="fc" id="L1026">                        lastInnerQ = 0;</span>
<span class="fc" id="L1027">                        break;</span>
                    }
                }
<span class="fc" id="L1030">                outerQueue.addAll(innerQueue);</span>
<span class="fc" id="L1031">                innerQueue.clear();</span>
            }
        }

<span class="pc bnc" id="L1035" title="All 2 branches missed.">        assert(assertShortEdgesAreEmpty(shortEdgeIndexes, clusterPoints));</span>

<span class="pc bnc" id="L1037" title="All 2 branches missed.">        assert(pointIndexMap.size() == img.getNPixels());</span>
<span class="fc" id="L1038">    }</span>

    private void mergeShortEdges(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, int clrSpace, double tColor,
        List&lt;Integer&gt; shortEdgeIndexes) {

        /*
        the paper suggests:
            &quot;The pair of lines where the distance of centroids between them is
            nearest is always merged into one if their color difference is not
            exceeding the predefined threshold Tc.&quot;

        this is only merging a single pair at most for every short edge
        */

        //TODO: consider improvements of this for large shortEdgeIndexes.size()

<span class="fc" id="L1055">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">        for (int i = 0; i &lt; shortEdgeIndexes.size(); ++i) {</span>

<span class="nc" id="L1059">            Integer index1 = shortEdgeIndexes.get(i);</span>
<span class="nc" id="L1060">            int idx1 = index1.intValue();</span>
<span class="nc" id="L1061">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">            if (set1.isEmpty()) {</span>
<span class="nc" id="L1063">                continue;</span>
            }

<span class="nc" id="L1066">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="nc bnc" id="L1068" title="All 2 branches missed.">            assert(Math.abs(set1.size() - desc1[3]) &lt; 0.1);</span>

<span class="nc" id="L1070">            double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1071">            int minDistIdx = -1;</span>

<span class="nc bnc" id="L1073" title="All 2 branches missed.">            for (int j = (i + 1); j &lt; shortEdgeIndexes.size(); ++j) {</span>

<span class="nc" id="L1075">                Integer index2 = shortEdgeIndexes.get(j);</span>
<span class="nc" id="L1076">                int idx2 = index2.intValue();</span>
<span class="nc" id="L1077">                Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                if (set2.isEmpty()) {</span>
<span class="nc" id="L1079">                    continue;</span>
                }

                //{h, s, v, nPix, cenX, cenY}
<span class="nc" id="L1083">                float[] desc2 = clusterDescriptors[idx2];</span>

<span class="nc bnc" id="L1085" title="All 2 branches missed.">                assert(Math.abs(set2.size() - desc2[3]) &lt; 0.1);</span>

                double diff;
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="nc" id="L1089">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L1093">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L1094">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L1095">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L1096">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

<span class="nc bnc" id="L1099" title="All 2 branches missed.">                if (diff &gt;= tColor) {</span>
<span class="nc" id="L1100">                    continue;</span>
                }

<span class="nc" id="L1103">                float diffX = desc1[4] - desc2[4];</span>
<span class="nc" id="L1104">                float diffY = desc1[5] - desc2[5];</span>
<span class="nc" id="L1105">                double distSq = diffX * diffX + diffY * diffY;</span>

<span class="nc bnc" id="L1107" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L1108">                    minDistSq = distSq;</span>
<span class="nc" id="L1109">                    minDistIdx = idx2;</span>
                }
            }

<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if (minDistIdx == -1) {</span>
<span class="nc" id="L1114">                continue;</span>
            }

            // merge set2 with set1 and update associated data structures
<span class="nc" id="L1118">            Set&lt;PairInt&gt; set2 = clusterPoints.get(minDistIdx);</span>
<span class="nc" id="L1119">            float[] desc2 = clusterDescriptors[minDistIdx];</span>

<span class="nc" id="L1121">            float n1 = set1.size();</span>
<span class="nc" id="L1122">            float n2 = set2.size();</span>
<span class="nc" id="L1123">            float nTot = n1 + n2;</span>

            //{h, s, v, nPix, cenX, cenY}
            // update desc1 contents for contents in desc2
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            for (int k = 0; k &lt; desc1.length; ++k) {</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">                if (k == 3) {</span>
<span class="nc" id="L1129">                    desc1[k] = nTot;</span>
                } else {
<span class="nc" id="L1131">                    desc1[k] = ((desc1[k] * n1) + (desc2[k] * n2)) / nTot;</span>
                }
            }
<span class="nc" id="L1134">            clusterDescriptors[minDistIdx] = null;</span>
<span class="nc" id="L1135">            set1.addAll(set2);</span>
<span class="nc" id="L1136">            set2.clear();</span>
        }
<span class="fc" id="L1138">    }</span>

    /**
     * get cie lab or hsv colors from img for coordinates (x, y)
     * @param img
     * @param x
     * @param y
     * @param clrSpace
     * @return
     */
    private float[] getColors(ImageExt img, int x, int y, int clrSpace) {

<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">        if (clrSpace == 0) {</span>
<span class="fc" id="L1151">            float[] lab2 = img.getCIELAB(x, y);</span>
<span class="fc" id="L1152">            return lab2;</span>
        } else {
<span class="nc" id="L1154">            float[] hsv = new float[3];</span>
<span class="nc" id="L1155">            hsv[0] = img.getHue(x, y);</span>
<span class="nc" id="L1156">            hsv[1] = img.getSaturation(x, y);</span>
<span class="nc" id="L1157">            hsv[2] = img.getBrightness(x, y);</span>
<span class="nc" id="L1158">            return hsv;</span>
        }
    }

    private boolean assertDescriptorCounts(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors) {

<span class="nc bnc" id="L1165" title="All 2 branches missed.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="nc" id="L1166">            int n = clusterPoints.get(i).size();</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if (n == 0) { continue;}</span>
<span class="nc" id="L1168">            float diff = Math.abs(n - clusterDescriptors[i][3]);</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">            assert(diff &lt; 0.1);</span>
        }

<span class="nc" id="L1172">        return true;</span>
    }

    private void mergeByColorHistograms(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap,
        int clrSpace, double tR) {

<span class="fc" id="L1180">        int[][][] colorHistograms = calculateColorHistograms(input,</span>
            clusterPoints, clrSpace);

        // key is index1, index2 where index1 &lt; index2
<span class="fc" id="L1184">        Map&lt;PairInt, HeapNode&gt; nodesMap = new HashMap&lt;PairInt, HeapNode&gt;();</span>

<span class="fc" id="L1186">        Heap heap = new Heap();</span>

<span class="fc" id="L1188">        ColorHistogram ch = new ColorHistogram();</span>

        // the histogram intersection range of values
        //   is 0 : nColors * 1
        // so for 3 colors, expect that max similarity is 3.0.
        // need to merge by higher similarity, so need to invert
        //   the keys.
        // 3 - similairty bcomes the new key.
        // a tR of 0.7*3.0 = 2.1 becomes 0.9 and any values larger than
        //    that are less similar...smalled values are more similar
<span class="fc" id="L1198">        double tRInv = 3.0 - tR;</span>

<span class="fc" id="L1200">        long heapKeyFactor = input.getNPixels();</span>

<span class="fc bfc" id="L1202" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>

<span class="fc" id="L1204">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L1205">            int idx1 = index1.intValue();</span>

<span class="fc" id="L1207">            int[][] hist1 = colorHistograms[idx1];</span>
<span class="pc bnc" id="L1208" title="All 2 branches missed.">            assert(hist1 != null);</span>

<span class="fc" id="L1210">            Set&lt;Integer&gt; indexes2 = entry.getValue();</span>

<span class="fc bfc" id="L1212" title="All 2 branches covered.">            for (Integer index2 : indexes2) {</span>

<span class="fc" id="L1214">                int idx2 = index2.intValue();</span>

<span class="pc bnc" id="L1216" title="All 2 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p12;
<span class="fc bfc" id="L1218" title="All 2 branches covered.">                if (idx1 &lt; idx2) {</span>
<span class="fc" id="L1219">                    p12 = new PairInt(idx1, idx2);</span>
                } else {
<span class="fc" id="L1221">                    p12 = new PairInt(idx2, idx1);</span>
                }

<span class="fc bfc" id="L1224" title="All 2 branches covered.">                if (nodesMap.containsKey(p12)) {</span>
<span class="fc" id="L1225">                    continue;</span>
                }

<span class="fc" id="L1228">                int[][] hist2 = colorHistograms[index2.intValue()];</span>
<span class="pc bnc" id="L1229" title="All 2 branches missed.">                assert(hist2 != null);</span>

<span class="fc" id="L1231">                float similarity = 3.0f - ch.intersection(hist1, hist2);</span>

<span class="fc" id="L1233">                long key = (long)(similarity * (double)heapKeyFactor);</span>
<span class="fc" id="L1234">                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L1235">                node.setData(p12);</span>
<span class="fc" id="L1236">                heap.insert(node);</span>
<span class="fc" id="L1237">                nodesMap.put(p12, node);</span>

<span class="pc bnc" id="L1239" title="All 2 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L1240">            }</span>
<span class="fc" id="L1241">        }</span>

<span class="fc" id="L1243">        int nMerged = 0;</span>

<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">        while(!heap.isEmpty()) {</span>

<span class="fc" id="L1247">            HeapNode node = heap.extractMin();</span>

<span class="fc" id="L1249">            PairInt p12 = (PairInt)node.getData();</span>

<span class="fc" id="L1251">            nodesMap.remove(p12);</span>

            // this is 3.0 - similarity
<span class="fc" id="L1254">            double diff = ((double)node.getKey())/((double)heapKeyFactor);</span>

<span class="fc bfc" id="L1256" title="All 2 branches covered.">            if (diff &gt; tRInv) {</span>
<span class="fc" id="L1257">                break;</span>
            }

<span class="fc" id="L1260">            int idx1 = p12.getX();</span>
<span class="fc" id="L1261">            int idx2 = p12.getY();</span>

<span class="fc" id="L1263">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="fc" id="L1264">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>

<span class="pc bpc" id="L1266" title="2 of 4 branches missed.">            if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="nc" id="L1267">                continue;</span>
            }

<span class="fc bfc" id="L1270" title="All 2 branches covered.">            if (set2.size() &gt; set1.size()) {</span>
<span class="fc" id="L1271">                idx1 = p12.getY();</span>
<span class="fc" id="L1272">                idx2 = p12.getX();</span>
<span class="fc" id="L1273">                set1 = set2;</span>
<span class="fc" id="L1274">                set2 = clusterPoints.get(idx2);</span>
            }

            // set1 is largest

<span class="fc" id="L1279">            int[][] hist1 = colorHistograms[idx1];</span>
<span class="fc" id="L1280">            ch.add2To1(hist1, colorHistograms[idx2]);</span>
<span class="fc" id="L1281">            colorHistograms[idx2] = null;</span>

<span class="fc" id="L1283">            float n1 = set1.size();</span>
<span class="fc" id="L1284">            float n2 = set2.size();</span>
<span class="fc" id="L1285">            float nTot = n1 + n2;</span>

<span class="fc" id="L1287">            set1.addAll(set2);</span>
<span class="fc" id="L1288">            set2.clear();</span>

<span class="fc" id="L1290">            Integer index1 = Integer.valueOf(idx1);</span>
<span class="fc" id="L1291">            Integer index2 = Integer.valueOf(idx2);</span>

            // remove the idx1 --&gt; set&lt;integer&gt; pairs from map and heap
            // remove the idx2 --&gt; set&lt;integer&gt; pairs from map and heap
            // update the adjacencyMap
            //   add node for updated idx1 ---&gt; set&lt;integer&gt; to map and node

<span class="fc" id="L1298">            Set&lt;Integer&gt; indexes1 = adjacencyMap.get(index1);</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">            for (Integer index3 : indexes1) {</span>
<span class="fc" id="L1300">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1301">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L1302" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L1303">                    continue;</span>
                }
                PairInt p13;
<span class="fc bfc" id="L1306" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L1307">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L1309">                    p13 = new PairInt(idx3, idx1);</span>
                }
<span class="fc" id="L1311">                HeapNode node3 = nodesMap.get(p13);</span>
<span class="pc bnc" id="L1312" title="All 2 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L1313">                heap.remove(node3);</span>
<span class="fc" id="L1314">                nodesMap.remove(p13);</span>
<span class="pc bnc" id="L1315" title="All 2 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L1316">            }</span>
<span class="fc" id="L1317">            Set&lt;Integer&gt; indexes2 = adjacencyMap.get(index2);</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">            for (Integer index3 : indexes2) {</span>
<span class="fc" id="L1319">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1320">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L1321" title="2 of 6 branches missed.">                if (set3.isEmpty() || idx1 == idx3 || idx2 == idx3) {</span>
<span class="nc" id="L1322">                    continue;</span>
                }
                PairInt p23;
<span class="fc bfc" id="L1325" title="All 2 branches covered.">                if (idx2 &lt; idx3) {</span>
<span class="fc" id="L1326">                    p23 = new PairInt(idx2, idx3);</span>
                } else {
<span class="fc" id="L1328">                    p23 = new PairInt(idx3, idx2);</span>
                }
<span class="fc" id="L1330">                HeapNode node3 = nodesMap.get(p23);</span>
<span class="pc bnc" id="L1331" title="All 2 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L1332">                heap.remove(node3);</span>
<span class="fc" id="L1333">                nodesMap.remove(p23);</span>
<span class="pc bnc" id="L1334" title="All 2 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L1335">            }</span>

            //update adjacency map
<span class="fc bfc" id="L1338" title="All 2 branches covered.">            for (Integer index3 : indexes2) {</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">                if (!index3.equals(index1)) {</span>
<span class="fc" id="L1340">                    Set&lt;Integer&gt; indexes4 = adjacencyMap.get(index3);</span>
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">                    if (indexes4 != null) {</span>
<span class="fc" id="L1342">                        indexes4.remove(index2);</span>
<span class="fc" id="L1343">                        indexes4.add(index1);</span>
                    }
                }
<span class="fc" id="L1346">            }</span>
<span class="fc" id="L1347">            indexes1.addAll(indexes2);</span>
<span class="fc" id="L1348">            indexes1.remove(index1);</span>
<span class="fc" id="L1349">            indexes1.remove(index2);</span>
<span class="fc" id="L1350">            adjacencyMap.remove(index2);</span>

            // add nodes back into heap and map for the updated idx1 --&gt; set&lt;integer&gt;
<span class="fc bfc" id="L1353" title="All 2 branches covered.">            for (Integer index3 : indexes1) {</span>
<span class="fc" id="L1354">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1355">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bnc" id="L1356" title="All 2 branches missed.">                assert(idx1 != idx3);</span>
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">                if (set3.isEmpty()) {</span>
<span class="nc" id="L1358">                    continue;</span>
                }
<span class="fc" id="L1360">                int[][] hist3 = colorHistograms[idx3];</span>
<span class="pc bnc" id="L1361" title="All 2 branches missed.">                assert(hist3 != null);</span>

                PairInt p13;
<span class="fc bfc" id="L1364" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L1365">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L1367">                    p13 = new PairInt(idx3, idx1);</span>
                }

<span class="fc" id="L1370">                float similarity3 = 3.0f - ch.intersection(hist1, hist3);</span>

<span class="fc" id="L1372">                long key3 = (long)(similarity3 * (double)heapKeyFactor);</span>
<span class="fc" id="L1373">                HeapNode node3 = new HeapNode(key3);</span>
<span class="fc" id="L1374">                node3.setData(p13);</span>

<span class="fc" id="L1376">                heap.insert(node3);</span>
<span class="fc" id="L1377">                nodesMap.put(p13, node3);</span>
<span class="pc bnc" id="L1378" title="All 2 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L1379">            }</span>

<span class="fc" id="L1381">            nMerged++;</span>
<span class="fc" id="L1382">        }</span>

<span class="fc" id="L1384">        log.fine(&quot;color histogram nMerged=&quot; + nMerged);</span>
<span class="fc" id="L1385">    }</span>

    public int[][][] calculateColorHistograms(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints, int clrSpace) {

        //0 == cie lab,  1 = hsv, 2 = rgb

<span class="fc" id="L1392">        int n = clusterPoints.size();</span>

<span class="fc" id="L1394">        int[][][] hist = new int[n][][];</span>

<span class="fc" id="L1396">        ColorHistogram ch = new ColorHistogram();</span>

<span class="fc bfc" id="L1398" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="fc" id="L1400">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>

<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">            if (set.isEmpty()) {</span>
<span class="nc" id="L1403">                continue;</span>
            }

<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">            if (clrSpace == 0) {</span>
<span class="fc" id="L1407">                hist[i] = ch.histogramCIELAB(input, set);</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">            } else if (clrSpace == 1) {</span>
<span class="nc" id="L1409">                hist[i] = ch.histogramHSV(input, set);</span>
<span class="pc bpc" id="L1410" title="1 of 2 branches missed.">            } if (clrSpace == 2) {</span>
<span class="nc" id="L1411">                hist[i] = ch.histogramRGB(input, set);</span>
            }
        }

<span class="fc" id="L1415">        return hist;</span>
    }

    private Map&lt;Integer, Set&lt;Integer&gt;&gt; createAdjacencyMap(List&lt;Set&lt;PairInt&gt;&gt;
        clusterPoints) {

<span class="fc" id="L1421">        Map&lt;PairInt, Integer&gt; pointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="fc bfc" id="L1423" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L1424">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L1425">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L1426" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L1427">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L1428">            }</span>
        }

<span class="fc" id="L1431">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1432">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1434">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L1436" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>

<span class="fc" id="L1438">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>

<span class="fc" id="L1440">            Set&lt;Integer&gt; indexes2 = new HashSet&lt;Integer&gt;();</span>

<span class="fc bfc" id="L1442" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L1443">                int x = p.getX();</span>
<span class="fc" id="L1444">                int y = p.getY();</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1446">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L1447">                    int y2 = y + dys[k];</span>
<span class="fc" id="L1448">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L1449">                    Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L1450" title="All 4 branches covered.">                    if (index2 == null || index2.intValue() == i) {</span>
<span class="fc" id="L1451">                        continue;</span>
                    }
<span class="fc" id="L1453">                    indexes2.add(index2);</span>
                }
<span class="fc" id="L1455">            }</span>

<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">            if (indexes2.isEmpty()) {</span>
<span class="nc" id="L1458">                continue;</span>
            }

            // add these to all point sets in adjacency map

<span class="fc" id="L1463">            indexes2.add(Integer.valueOf(i));</span>

<span class="fc bfc" id="L1465" title="All 2 branches covered.">            for (Integer key : indexes2) {</span>
<span class="fc" id="L1466">                Set&lt;Integer&gt; v = new HashSet&lt;Integer&gt;(indexes2);</span>
<span class="fc" id="L1467">                v.remove(key);</span>

<span class="fc" id="L1469">                Set&lt;Integer&gt; mapV = adjMap.get(key);</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">                if (mapV == null) {</span>
<span class="fc" id="L1471">                    adjMap.put(key, v);</span>
                } else {
<span class="fc" id="L1473">                    mapV.addAll(v);</span>
                }
<span class="fc" id="L1475">            }</span>
        }

<span class="fc" id="L1478">        return adjMap;</span>
    }

    private Map&lt;PairInt, Set&lt;Integer&gt;&gt; 
    findUnassignedPixelsAndAdjacentIndexes(
        ImageExt img, Map&lt;PairInt, Integer&gt; pointIndexMap) {

<span class="fc" id="L1485">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; unassignedAndIndexes =</span>
            new HashMap&lt;PairInt, Set&lt;Integer&gt;&gt;();

<span class="fc" id="L1488">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1489">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1491">        int w = img.getWidth();</span>
<span class="fc" id="L1492">        int h = img.getHeight();</span>

<span class="fc bfc" id="L1494" title="All 2 branches covered.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="fc bfc" id="L1495" title="All 2 branches covered.">            for (int y = 0; y &lt; h; ++y) {</span>
<span class="fc" id="L1496">                PairInt p = new PairInt(x, y);</span>
<span class="fc bfc" id="L1497" title="All 2 branches covered.">                if (pointIndexMap.containsKey(p)) {</span>
<span class="fc" id="L1498">                    continue;</span>
                }
<span class="fc" id="L1500">                Set&lt;Integer&gt; adjIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1502">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L1503">                    int y2 = y + dys[k];</span>
<span class="fc" id="L1504">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L1505">                    Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">                    if (index2 != null) {</span>
<span class="fc" id="L1507">                        adjIndexes.add(index2);</span>
                    }
                }
<span class="fc" id="L1510">                unassignedAndIndexes.put(p, adjIndexes);</span>
            }
        }

<span class="pc bnc" id="L1514" title="All 2 branches missed.">        assert(pointIndexMap.size() + unassignedAndIndexes.size() == img.getNPixels());</span>

<span class="fc" id="L1516">        return unassignedAndIndexes;</span>
    }

    private void populateDescriptors(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; pointSets,
        float[][] outputDescripors, int clrSpace) {

        /*
        the descriptors are
             C_i = {h, s, v, nPix, cenX, cenY}  or labL, labA, labB for colorSpace = 0
        */
<span class="fc" id="L1527">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc bfc" id="L1529" title="All 2 branches covered.">        for (int i = 0; i &lt; pointSets.size(); ++i) {</span>

<span class="fc" id="L1531">            Set&lt;PairInt&gt; edgePoints = pointSets.get(i);</span>

<span class="fc" id="L1533">            outputDescripors[i] = new float[6];</span>

<span class="fc" id="L1535">            double[] xyCen = curveHelper.calculateXYCentroids(edgePoints);</span>

<span class="fc" id="L1537">            double c1Sum = 0;</span>
<span class="fc" id="L1538">            double c2Sum = 0;</span>
<span class="fc" id="L1539">            double c3Sum = 0;</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">            for (PairInt p : edgePoints) {</span>

<span class="fc" id="L1542">                int x = p.getX();</span>
<span class="fc" id="L1543">                int y = p.getY();</span>

<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L1546">                    float[] lab = img.getCIELAB(x, y);</span>
<span class="fc" id="L1547">                    c1Sum += lab[0];</span>
<span class="fc" id="L1548">                    c2Sum += lab[1];</span>
<span class="fc" id="L1549">                    c3Sum += lab[2];</span>
<span class="fc" id="L1550">                } else {</span>
                    // hsv
<span class="nc" id="L1552">                    c1Sum += img.getHue(x, y);</span>
<span class="nc" id="L1553">                    c2Sum += img.getSaturation(x, y);</span>
<span class="nc" id="L1554">                    c3Sum += img.getBrightness(x, y);</span>
                }
<span class="fc" id="L1556">            }</span>
<span class="fc" id="L1557">            c1Sum /= (float)edgePoints.size();</span>
<span class="fc" id="L1558">            c2Sum /= (float)edgePoints.size();</span>
<span class="fc" id="L1559">            c3Sum /= (float)edgePoints.size();</span>

            //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L1562">            outputDescripors[i][0] = (float)c1Sum;</span>
<span class="fc" id="L1563">            outputDescripors[i][1] = (float)c2Sum;</span>
<span class="fc" id="L1564">            outputDescripors[i][2] = (float)c3Sum;</span>
<span class="fc" id="L1565">            outputDescripors[i][3] = edgePoints.size();</span>
<span class="fc" id="L1566">            outputDescripors[i][4] = (float)xyCen[0];</span>
<span class="fc" id="L1567">            outputDescripors[i][5] = (float)xyCen[1];</span>
        }
<span class="fc" id="L1569">    }</span>

    private float[][] condenseAndUpdate(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, Map&lt;PairInt, Integer&gt; pointIndexMap) {

<span class="fc" id="L1574">        int nNonNull = 0;</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : clusterPoints) {</span>
<span class="fc bfc" id="L1576" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L1577">                nNonNull++;</span>
            }
<span class="fc" id="L1579">        }</span>

<span class="fc" id="L1581">        List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="fc" id="L1583">        float[][] outputDescriptors = new float[nNonNull][];</span>

<span class="fc bfc" id="L1585" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L1586">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L1588">                outputDescriptors[tmp.size()] = clusterDescriptors[i];</span>
<span class="fc" id="L1589">                tmp.add(set);</span>
            }
        }
<span class="fc" id="L1592">        clusterPoints.clear();</span>
<span class="fc" id="L1593">        clusterPoints.addAll(tmp);</span>

<span class="fc" id="L1595">        pointIndexMap.clear();</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L1597">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L1598">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L1600">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L1601">            }</span>
        }

<span class="fc" id="L1604">        return outputDescriptors;</span>
    }

    private void mergeSmallClusters(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints, float[][] clusterDescriptors,
        int clrSpace, int tNumber, String debugTag) {

<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">        if (clusterPoints.isEmpty()) {</span>
<span class="nc" id="L1612">            return;</span>
        }

<span class="fc" id="L1615">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap = createAdjacencyMap(</span>
            clusterPoints);

<span class="fc" id="L1618">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc bfc" id="L1620" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>

<span class="fc" id="L1622">            Integer index1 = entry.getKey();</span>

<span class="fc" id="L1624">            int idx1 = index1.intValue();</span>

<span class="fc" id="L1626">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>

<span class="pc bpc" id="L1628" title="1 of 4 branches missed.">            if ((set1.size() &gt; tNumber) || set1.isEmpty()) {</span>
<span class="nc" id="L1629">                continue;</span>
            }

<span class="fc" id="L1632">            Set&lt;Integer&gt; indexes2 = entry.getValue();</span>

            // merge with closest in color

<span class="fc" id="L1636">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="fc" id="L1638">            double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L1639">            Integer minDiffIndex = null;</span>

<span class="fc bfc" id="L1641" title="All 2 branches covered.">            for (Integer index2 : indexes2) {</span>
<span class="fc" id="L1642">                int idx2 = index2.intValue();</span>
<span class="fc" id="L1643">                Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="fc bfc" id="L1644" title="All 2 branches covered.">                if (set2.isEmpty()) {</span>
<span class="fc" id="L1645">                    continue;</span>
                }
<span class="fc" id="L1647">                float[] desc2 = clusterDescriptors[idx2];</span>
                double diff;
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L1650">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2], desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L1653">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L1654">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L1655">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L1656">                    diff = Math.sqrt(diff1 * diff1 + diff2 * diff2 + diff3 * diff3);</span>
                }
<span class="fc bfc" id="L1658" title="All 2 branches covered.">                if (diff &lt; minDiff) {</span>
<span class="fc" id="L1659">                    minDiff = diff;</span>
<span class="fc" id="L1660">                    minDiffIndex = index2;</span>
                }
<span class="fc" id="L1662">            }</span>

<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">            if (minDiffIndex == null) {</span>
<span class="nc" id="L1665">                continue;</span>
            }
<span class="fc" id="L1667">            int idx2 = minDiffIndex.intValue();</span>
<span class="fc" id="L1668">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="pc bnc" id="L1669" title="All 2 branches missed.">            assert(!set2.isEmpty());</span>
<span class="fc" id="L1670">            float[] desc2 = clusterDescriptors[idx2];</span>
<span class="fc" id="L1671">            int n2 = set2.size();</span>
<span class="fc" id="L1672">            int n1 = set1.size();</span>
<span class="fc" id="L1673">            set2.addAll(set1);</span>
<span class="fc" id="L1674">            int nTot = set2.size();</span>
<span class="fc" id="L1675">            set1.clear();</span>

            //{h, s, v, nPix, cenX, cenY}
<span class="fc bfc" id="L1678" title="All 2 branches covered.">            for (int ii = 0; ii &lt; desc1.length; ++ii) {</span>
<span class="fc" id="L1679">                desc2[ii] = ((desc2[ii] * n2) - desc1[ii] * n1) / nTot;</span>
            }
<span class="fc" id="L1681">            desc2[3] = nTot;</span>

<span class="fc" id="L1683">            clusterDescriptors[idx1] = null;</span>
<span class="fc" id="L1684">        }</span>
<span class="fc" id="L1685">    }</span>

    /**
     *
     * @param img
     * @param gradientMethod
     * 0=CannyEdgeFilterAdaptiveDeltaE2000,
     * 1=CannyEdgeFilterAdaptive,
     * 2=PhaseCongruencyDetector
     * @param ts timestamp used in debugging image name
     * @return
     */
    public EdgeFilterProducts createGradient(Image img,
        int gradientMethod, long ts) {

<span class="fc" id="L1700">        EdgeFilterProducts products = null;</span>

<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">        if (gradientMethod == 0) {</span>

<span class="nc" id="L1704">            ImageExt imgCp = img.copyToImageExt();</span>
            
<span class="nc" id="L1706">            CannyEdgeFilterAdaptiveDeltaE2000 canny =</span>
                new CannyEdgeFilterAdaptiveDeltaE2000();
<span class="nc" id="L1708">            canny.setOtsuScaleFactor(0.3f);</span>
<span class="nc" id="L1709">            canny.setToUseSingleThresholdIn2LayerFilter();</span>
<span class="nc" id="L1710">            canny.applyFilter(imgCp);</span>

<span class="nc" id="L1712">            products = canny.getFilterProducts();</span>

<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">        } else if (gradientMethod == 1) {</span>
            
<span class="nc" id="L1716">            CannyEdgeFilterAdaptive canny2 = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L1717">            canny2.overrideToNotUseLineThinner();</span>
            //canny2.setOtsuScaleFactor(0.3f);
<span class="nc" id="L1719">            canny2.setToUseSingleThresholdIn2LayerFilter();</span>
<span class="nc" id="L1720">            canny2.applyFilter(img.copyToGreyscale2());</span>

<span class="nc" id="L1722">            products = canny2.getFilterProducts();</span>

<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">        } else if (gradientMethod == 2) {</span>
            
<span class="fc" id="L1726">            products = createPhaseCongruencyGradient(</span>
<span class="fc" id="L1727">                img.copyBlueToGreyscale());</span>

        }

<span class="fc" id="L1731">        return products;</span>
    }

    public EdgeFilterProducts packageToEdgeProduct(
        PhaseCongruencyDetector.PhaseCongruencyProducts pr) {
        
<span class="fc" id="L1737">        EdgeFilterProducts eProduct = new EdgeFilterProducts();</span>

<span class="fc" id="L1739">        int nCols = pr.getThinned()[0].length;//img.getWidth();</span>
<span class="fc" id="L1740">        int nRows = pr.getThinned().length;//img.getHeight();</span>

<span class="fc" id="L1742">        GreyscaleImage pcImg = new GreyscaleImage(nCols, nRows);</span>
<span class="fc" id="L1743">        double[][] pc = pr.getPhaseCongruency();</span>
<span class="fc bfc" id="L1744" title="All 2 branches covered.">        for (int i = 0; i &lt; pr.getThinned().length; ++i) {</span>
<span class="fc bfc" id="L1745" title="All 2 branches covered.">            for (int j = 0; j &lt; pr.getThinned()[i].length; ++j) {</span>
<span class="fc bfc" id="L1746" title="All 2 branches covered.">                if (pr.getThinned()[i][j] &gt; 0) {</span>
<span class="fc" id="L1747">                    int v = (int)Math.round(255. * pc[i][j]);</span>
<span class="fc" id="L1748">                    pcImg.setValue(j, i, v);</span>
                }
            }
        }

<span class="fc" id="L1753">        eProduct.setGradientXY(pcImg);</span>

<span class="fc" id="L1755">        GreyscaleImage paImg = new GreyscaleImage(nCols, nRows,</span>
            GreyscaleImage.Type.Bits32FullRangeInt);
        // range -pi to pi
<span class="fc" id="L1758">        double[][] pa = pr.getPhaseAngle();</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">        for (int i = 0; i &lt; pa.length; ++i) {</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">            for (int j = 0; j &lt; pa[i].length; ++j) {</span>
<span class="fc" id="L1761">                double v = pa[i][j];</span>
<span class="fc" id="L1762">                int d = (int)Math.round(v * 180./Math.PI);</span>
<span class="fc" id="L1763">                paImg.setValue(j, i, d);</span>
            }
        }
<span class="fc" id="L1766">        eProduct.setPhaseAngle(paImg);</span>

<span class="fc" id="L1768">        GreyscaleImage orImg = new GreyscaleImage(nCols, nRows);</span>
<span class="fc" id="L1769">        double[][] or = pr.getOrientation();</span>
        // orientation is already in range 0 to 180
<span class="fc bfc" id="L1771" title="All 2 branches covered.">        for (int i = 0; i &lt; or.length; ++i) {</span>
<span class="fc bfc" id="L1772" title="All 2 branches covered.">            for (int j = 0; j &lt; or[i].length; ++j) {</span>
<span class="fc" id="L1773">                double v = or[i][j];</span>
<span class="fc" id="L1774">                orImg.setValue(j, i, (int)Math.round(v));</span>
            }
        }
<span class="fc" id="L1777">        eProduct.setTheta(orImg);</span>
        
<span class="fc" id="L1779">        return eProduct;</span>
    }
    
    public EdgeFilterProducts createPhaseCongruencyGradient(
        GreyscaleImage img) {
        
<span class="fc" id="L1785">        PhaseCongruencyDetector phaseDetector = new PhaseCongruencyDetector();</span>
<span class="fc" id="L1786">        phaseDetector.setK(2);</span>
        
<span class="fc" id="L1788">        PhaseCongruencyDetector.PhaseCongruencyProducts pr =</span>
<span class="fc" id="L1789">            phaseDetector.phaseCongMono(img);</span>

<span class="fc" id="L1791">        EdgeFilterProducts eProduct = packageToEdgeProduct(pr);</span>
        
<span class="fc" id="L1793">        return eProduct;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final GreyscaleImage input,
        PairInt[][] neighborCoords, int col, int row) {
        
<span class="fc" id="L1811">        int w = input.getWidth();</span>
<span class="fc" id="L1812">        int h = input.getHeight();</span>

<span class="pc bpc" id="L1814" title="4 of 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L1818">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="fc bfc" id="L1860" title="All 2 branches covered.">        boolean t6 = (input.getValue(neighborCoords[0][2].getX() + col,</span>
<span class="fc" id="L1861">            neighborCoords[0][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1862" title="All 2 branches covered.">        boolean t7 = (input.getValue(neighborCoords[1][2].getX() + col,</span>
<span class="fc" id="L1863">            neighborCoords[1][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">        boolean t8 = (input.getValue(neighborCoords[2][2].getX() + col,</span>
<span class="fc" id="L1865">            neighborCoords[2][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1866" title="All 2 branches covered.">        boolean t11 = (input.getValue(neighborCoords[0][1].getX() + col,</span>
<span class="fc" id="L1867">            neighborCoords[0][1].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1868" title="All 2 branches covered.">        boolean t12 = (input.getValue(neighborCoords[2][1].getX() + col,</span>
<span class="fc" id="L1869">            neighborCoords[2][1].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1870" title="All 2 branches covered.">        boolean t15 = (input.getValue(neighborCoords[0][0].getX() + col,</span>
<span class="fc" id="L1871">            neighborCoords[0][0].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1872" title="All 2 branches covered.">        boolean t16 = (input.getValue(neighborCoords[1][0].getX() + col,</span>
<span class="fc" id="L1873">            neighborCoords[1][0].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">        boolean t17 = (input.getValue(neighborCoords[2][0].getX() + col,</span>
<span class="fc" id="L1875">            neighborCoords[2][0].getY() + row) &gt; 0);</span>

<span class="pc bpc" id="L1877" title="7 of 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L1878">            return true;</span>
<span class="pc bpc" id="L1879" title="5 of 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L1880">            return true;</span>
<span class="pc bpc" id="L1881" title="7 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L1882">            return true;</span>
<span class="pc bpc" id="L1883" title="1 of 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L1884">            return true;</span>
<span class="pc bpc" id="L1885" title="3 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L1886">            return true;</span>
<span class="pc bpc" id="L1887" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L1888">            return true;</span>
<span class="pc bpc" id="L1889" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L1890">            return true;</span>
<span class="pc bpc" id="L1891" title="1 of 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L1892">            return true;</span>
<span class="pc bpc" id="L1893" title="5 of 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L1894">            return true;</span>
<span class="pc bpc" id="L1895" title="7 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L1896">            return true;</span>
<span class="pc bpc" id="L1897" title="1 of 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L1898">            return true;</span>
<span class="pc bpc" id="L1899" title="3 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L1900">            return true;</span>
<span class="pc bpc" id="L1901" title="1 of 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L1902">            return true;</span>
<span class="pc bpc" id="L1903" title="5 of 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L1904">            return true;</span>
<span class="pc bpc" id="L1905" title="5 of 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L1906">            return true;</span>
<span class="pc bpc" id="L1907" title="7 of 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L1908">            return true;</span>
        }

<span class="fc" id="L1911">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @param w width of image
     * @param h height of image
     * @return
     */
    public static boolean doesDisconnect(final Set&lt;PairInt&gt; input,
        PairInt[][] neighborCoords, int col, int row, int w, int h) {

<span class="pc bpc" id="L1931" title="3 of 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="fc" id="L1935">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="fc" id="L1977">        boolean t6 = input.contains(</span>
<span class="fc" id="L1978">            new PairInt(neighborCoords[0][2].getX() + col,</span>
<span class="fc" id="L1979">            neighborCoords[0][2].getY() + row));</span>
<span class="fc" id="L1980">        boolean t7 = input.contains(</span>
<span class="fc" id="L1981">            new PairInt(neighborCoords[1][2].getX() + col,</span>
<span class="fc" id="L1982">            neighborCoords[1][2].getY() + row));</span>
<span class="fc" id="L1983">        boolean t8 = input.contains(</span>
<span class="fc" id="L1984">            new PairInt(neighborCoords[2][2].getX() + col,</span>
<span class="fc" id="L1985">            neighborCoords[2][2].getY() + row));</span>
<span class="fc" id="L1986">        boolean t11 = input.contains(</span>
<span class="fc" id="L1987">            new PairInt(neighborCoords[0][1].getX() + col,</span>
<span class="fc" id="L1988">            neighborCoords[0][1].getY() + row));</span>
<span class="fc" id="L1989">        boolean t12 = input.contains(</span>
<span class="fc" id="L1990">            new PairInt(neighborCoords[2][1].getX() + col,</span>
<span class="fc" id="L1991">            neighborCoords[2][1].getY() + row));</span>
<span class="fc" id="L1992">        boolean t15 = input.contains(</span>
<span class="fc" id="L1993">            new PairInt(neighborCoords[0][0].getX() + col,</span>
<span class="fc" id="L1994">            neighborCoords[0][0].getY() + row));</span>
<span class="fc" id="L1995">        boolean t16 = input.contains(</span>
<span class="fc" id="L1996">            new PairInt(neighborCoords[1][0].getX() + col,</span>
<span class="fc" id="L1997">            neighborCoords[1][0].getY() + row));</span>
<span class="fc" id="L1998">        boolean t17 = input.contains(</span>
<span class="fc" id="L1999">            new PairInt(neighborCoords[2][0].getX() + col,</span>
<span class="fc" id="L2000">            neighborCoords[2][0].getY() + row));</span>

<span class="pc bpc" id="L2002" title="7 of 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L2003">            return true;</span>
<span class="pc bpc" id="L2004" title="5 of 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L2005">            return true;</span>
<span class="pc bpc" id="L2006" title="7 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L2007">            return true;</span>
<span class="pc bpc" id="L2008" title="1 of 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L2009">            return true;</span>
<span class="pc bpc" id="L2010" title="3 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L2011">            return true;</span>
<span class="pc bpc" id="L2012" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L2013">            return true;</span>
<span class="pc bpc" id="L2014" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L2015">            return true;</span>
<span class="pc bpc" id="L2016" title="1 of 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L2017">            return true;</span>
<span class="pc bpc" id="L2018" title="5 of 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L2019">            return true;</span>
<span class="pc bpc" id="L2020" title="7 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L2021">            return true;</span>
<span class="pc bpc" id="L2022" title="1 of 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L2023">            return true;</span>
<span class="pc bpc" id="L2024" title="3 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L2025">            return true;</span>
<span class="pc bpc" id="L2026" title="1 of 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L2027">            return true;</span>
<span class="pc bpc" id="L2028" title="5 of 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L2029">            return true;</span>
<span class="pc bpc" id="L2030" title="5 of 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L2031">            return true;</span>
<span class="pc bpc" id="L2032" title="7 of 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L2033">            return true;</span>
        }

<span class="fc" id="L2036">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @param w width of image
     * @param h height of image
     * @return
     */
    public static boolean doesDisconnect(final TIntSet input,
        PairInt[][] neighborCoords, int col, int row, int w, int h) {

<span class="pc bpc" id="L2056" title="2 of 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="fc" id="L2060">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="fc" id="L2102">        boolean t6 = input.contains(</span>
<span class="fc" id="L2103">            ((neighborCoords[0][2].getY() + row) * w) +</span>
<span class="fc" id="L2104">            neighborCoords[0][2].getX() + col);</span>
<span class="fc" id="L2105">        boolean t7 = input.contains(</span>
<span class="fc" id="L2106">            ((neighborCoords[1][2].getY() + row) * w) +</span>
<span class="fc" id="L2107">            neighborCoords[1][2].getX() + col);</span>
<span class="fc" id="L2108">        boolean t8 = input.contains(</span>
<span class="fc" id="L2109">            ((neighborCoords[2][2].getY() + row) * w) +</span>
<span class="fc" id="L2110">            neighborCoords[2][2].getX() + col);</span>
<span class="fc" id="L2111">        boolean t11 = input.contains(</span>
<span class="fc" id="L2112">            ((neighborCoords[0][1].getY() + row) * w) +</span>
<span class="fc" id="L2113">            neighborCoords[0][1].getX() + col);</span>
<span class="fc" id="L2114">        boolean t12 = input.contains(</span>
<span class="fc" id="L2115">            ((neighborCoords[2][1].getY() + row) * w) +</span>
<span class="fc" id="L2116">            neighborCoords[2][1].getX() + col);</span>
<span class="fc" id="L2117">        boolean t15 = input.contains(</span>
<span class="fc" id="L2118">            ((neighborCoords[0][0].getY() + row) * w) +</span>
<span class="fc" id="L2119">            neighborCoords[0][0].getX() + col);</span>
<span class="fc" id="L2120">        boolean t16 = input.contains(</span>
<span class="fc" id="L2121">            ((neighborCoords[1][0].getY() + row) * w) +</span>
<span class="fc" id="L2122">            neighborCoords[1][0].getX() + col);</span>
<span class="fc" id="L2123">        boolean t17 = input.contains(</span>
<span class="fc" id="L2124">            ((neighborCoords[2][0].getY() + row) * w) +</span>
<span class="fc" id="L2125">            neighborCoords[2][0].getX() + col);</span>

<span class="pc bpc" id="L2127" title="7 of 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L2128">            return true;</span>
<span class="pc bpc" id="L2129" title="5 of 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L2130">            return true;</span>
<span class="pc bpc" id="L2131" title="7 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L2132">            return true;</span>
<span class="pc bpc" id="L2133" title="1 of 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L2134">            return true;</span>
<span class="pc bpc" id="L2135" title="3 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L2136">            return true;</span>
<span class="pc bpc" id="L2137" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L2138">            return true;</span>
<span class="pc bpc" id="L2139" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L2140">            return true;</span>
<span class="pc bpc" id="L2141" title="1 of 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L2142">            return true;</span>
<span class="pc bpc" id="L2143" title="5 of 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L2144">            return true;</span>
<span class="pc bpc" id="L2145" title="7 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L2146">            return true;</span>
<span class="pc bpc" id="L2147" title="1 of 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L2148">            return true;</span>
<span class="pc bpc" id="L2149" title="3 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L2150">            return true;</span>
<span class="pc bpc" id="L2151" title="1 of 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L2152">            return true;</span>
<span class="pc bpc" id="L2153" title="5 of 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L2154">            return true;</span>
<span class="pc bpc" id="L2155" title="5 of 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L2156">            return true;</span>
<span class="pc bpc" id="L2157" title="7 of 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L2158">            return true;</span>
        }

<span class="fc" id="L2161">        return false;</span>
    }

    private boolean assertShortEdgesAreEmpty(List&lt;Integer&gt; indexes,
        List&lt;Set&lt;PairInt&gt;&gt; clusterSets) {

<span class="nc bnc" id="L2167" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L2168">            Set&lt;PairInt&gt; set = clusterSets.get(index.intValue());</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">            assert(set.isEmpty());</span>
<span class="nc" id="L2170">        }</span>

<span class="nc" id="L2172">        return true;</span>
    }

    public void replaceSinglePixelLabelsCIELAB(int[] labels,
        ImageExt img) {

        // ----- replace single pixels w/ adjacent nearest in color -----
<span class="fc" id="L2179">        int[] dx2 = Misc.dx4;</span>
<span class="fc" id="L2180">        int[] dy2 = Misc.dy4;</span>
        // single pixels should join closest,,,
<span class="fc bfc" id="L2182" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L2183" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L2184">                int pixIdx = img.getInternalIndex(i, j);</span>
<span class="fc" id="L2185">                int v = labels[pixIdx];</span>
<span class="fc" id="L2186">                boolean oneIsSame = false;</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">                for (int z = 0; z &lt; dx2.length; ++z) {</span>
<span class="fc" id="L2188">                    int x2 = i + dx2[z];</span>
<span class="fc" id="L2189">                    int y2 = j + dy2[z];</span>
<span class="fc bfc" id="L2190" title="All 6 branches covered.">                    if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (img.getWidth() - 1))</span>
<span class="fc bfc" id="L2191" title="All 2 branches covered.">                        || (y2 &gt; (img.getHeight() - 1))</span>
                        ) {
<span class="fc" id="L2193">                        continue;</span>
                    }
<span class="fc" id="L2195">                    int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="fc" id="L2196">                    int v2 = labels[pixIdx2];</span>
<span class="fc bfc" id="L2197" title="All 2 branches covered.">                    if (v2 == v) {</span>
<span class="fc" id="L2198">                        oneIsSame = true;</span>
<span class="fc" id="L2199">                        break;</span>
                    }
                }
<span class="fc bfc" id="L2202" title="All 2 branches covered.">                if (!oneIsSame) {</span>
<span class="fc" id="L2203">                    float[] lab = img.getCIELAB(pixIdx);</span>
<span class="fc" id="L2204">                    double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L2205">                    int minIdx = -1;</span>
<span class="fc bfc" id="L2206" title="All 2 branches covered.">                    for (int z = 0; z &lt; dx2.length; ++z) {</span>
<span class="fc" id="L2207">                        int x2 = i + dx2[z];</span>
<span class="fc" id="L2208">                        int y2 = j + dy2[z];</span>
<span class="fc bfc" id="L2209" title="All 6 branches covered.">                        if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (img.getWidth() - 1))</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">                            || (y2 &gt; (img.getHeight() - 1))) {</span>
<span class="fc" id="L2211">                            continue;</span>
                        }
<span class="fc" id="L2213">                        int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="fc" id="L2214">                        float[] lab2 = img.getCIELAB(pixIdx2);</span>
                        
<span class="fc" id="L2216">                        double dClrSq = 0;</span>
<span class="fc bfc" id="L2217" title="All 2 branches covered.">                        for (int i2 = 0; i2 &lt; 3; ++i2) {</span>
<span class="fc" id="L2218">                            float diff = lab[i2] - lab2[i2];</span>
<span class="fc" id="L2219">                            dClrSq += (diff * diff);</span>
                        }
                        
<span class="fc bfc" id="L2222" title="All 2 branches covered.">                        if (dClrSq &lt; minDiff) {</span>
<span class="fc" id="L2223">                            minDiff = dClrSq;</span>
<span class="fc" id="L2224">                            minIdx = pixIdx2;</span>
                        }
                    }
<span class="fc" id="L2227">                    labels[pixIdx] = labels[minIdx];</span>
                }
            }
        }
<span class="fc" id="L2231">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageSegmentation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageSegmentation.java</span></div><h1>ImageSegmentation.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.CountingSort;
import algorithms.compGeometry.NearestPoints1D;
import algorithms.compGeometry.clustering.KMeansPlusPlus;
import algorithms.compGeometry.clustering.KMeansPlusPlusFloat;
import algorithms.imageProcessing.util.PairIntWithIndex;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.ResourceFinder;
import com.climbwithyourfeet.clustering.DTClusterFinder;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * class holding several different image segmentation methods.  Note that
 * some other techniques involving contrast for example, are elsewhere.
 *
 * @author nichole
 */
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">public class ImageSegmentation {</span>

<span class="fc" id="L43">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * applies KMeansPlusPlus algorithm to the values in input
     * (greyscale intensities) to create kBands of clustered pixels
     * (operates on input).
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */
    public void applyUsingKMPP(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {

<span class="fc" id="L57">        KMeansPlusPlus instance = new KMeansPlusPlus();</span>
<span class="fc" id="L58">        instance.computeMeans(kBands, input);</span>

<span class="fc" id="L60">        assignToNearestCluster(input, instance.getCenters());</span>
<span class="fc" id="L61">    }</span>

    /**
     * applies binary algorithm (simple thresholding) to the values in input
     * (greyscale intensities) to create pixels given above or below highest
     * frequency value.  Note that some images may need to be pre-processed
     * in order to use this one (for example, correct for illumination and
     * remove items like sky if main objects are not sky).
     * (operates on input).
     * @param input
     */
    public void applyBinaryUsingFrequency(GreyscaleImage input) {

<span class="nc" id="L74">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(</span>
            input);

<span class="nc bnc" id="L77" title="All 4 branches missed.">        if (valueCounts == null || valueCounts.getN() == 0) {</span>
<span class="nc" id="L78">            return;</span>
        }

        //96, 30
<span class="nc" id="L82">        int divider = valueCounts.getX(0);</span>
<span class="nc" id="L83">        int v0 = 255/4;</span>
<span class="nc" id="L84">        int v1 = 3*v0;</span>

<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">            if (input.getValue(i) &lt; divider) {</span>
<span class="nc" id="L88">                input.setValue(i, v0);</span>
            } else {
<span class="nc" id="L90">                input.setValue(i, v1);</span>
            }
        }

<span class="nc" id="L94">    }</span>

    /**
     * applies DTClustering algorithm to the values in input
     * (greyscale intensities) to create kBands of clustered pixels
     * (operates on input).
     * (This one is competitive with applyUsingPolarCIEXYAndFrequency
     * with lowFreqLimit 0.1f)
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */
    public void applyUsingDTClustering(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {

<span class="nc" id="L110">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(</span>
            input);

        // first, trying clustering by value and frequency,
        // second, compare that to clustering just by giving points as value,value
        //    which is effectivly a 1D clustering
        //Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();
<span class="nc" id="L117">        Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; points =</span>
            new HashSet&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;();

<span class="nc bnc" id="L120" title="All 2 branches missed.">        for (int i = 0; i &lt; valueCounts.getN(); ++i) {</span>
<span class="nc" id="L121">            com.climbwithyourfeet.clustering.util.PairInt p = new</span>
                com.climbwithyourfeet.clustering.util.PairInt(
<span class="nc" id="L123">                    valueCounts.getX(i), valueCounts.getY(i));</span>

<span class="nc" id="L125">            points.add(p);</span>
        }

<span class="nc" id="L128">        DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; cFinder</span>
            = new DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;(
<span class="nc" id="L130">                points, input.getWidth(), input.getHeight());</span>

<span class="nc" id="L132">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L134">        cFinder.findClusters();</span>

<span class="nc" id="L136">        int n = cFinder.getNumberOfClusters();</span>

<span class="nc" id="L138">        int[] centers = new int[n];</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="nc" id="L141">            Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; set = cFinder.getCluster(i);</span>

            // find centeroid for x
<span class="nc" id="L144">            double xc = 0;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">            for (com.climbwithyourfeet.clustering.util.PairInt p : set) {</span>
<span class="nc" id="L146">                double x1 = p.getX();</span>
<span class="nc" id="L147">                xc += x1;</span>
<span class="nc" id="L148">            }</span>

<span class="nc" id="L150">            centers[i] = (int)Math.round(xc/(double)set.size());</span>
        }

<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (n &gt; kBands) {</span>
<span class="nc" id="L154">            n = kBands;</span>
        }

<span class="nc" id="L157">        Arrays.sort(centers);</span>
<span class="nc" id="L158">        int[] kCenters = new int[n];</span>
<span class="nc" id="L159">        int count = 0;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        for (int i = (centers.length - 1); i &gt; (centers.length - 1 - n); --i) {</span>
<span class="nc" id="L161">            kCenters[count] = centers[i];</span>
<span class="nc" id="L162">            count++;</span>
        }

<span class="nc" id="L165">        assignToNearestCluster(input, kCenters);</span>
<span class="nc" id="L166">    }</span>

    /**
     * places points by their proximity to cluster centers
     * @param input
     * @param binCenters
     */
    public void assignToNearestCluster(GreyscaleImage input, int[] binCenters) {

<span class="fc" id="L175">        NearestPoints1D np = new NearestPoints1D(binCenters);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="fc" id="L181">                int v = input.getValue(col, row);</span>

<span class="fc" id="L183">                int vc = np.findClosestValue(v);</span>

<span class="fc" id="L185">                input.setValue(col, row, vc);</span>
            }
        }
<span class="fc" id="L188">    }</span>

    public List&lt;Set&lt;PairInt&gt;&gt; assignToNearestPolarCIECluster(
        Map&lt;PairInt, Integer&gt; polarCIEXYMap, int[] binCenters) {

<span class="nc" id="L193">        Arrays.sort(binCenters);</span>

<span class="nc" id="L195">        int nc = binCenters.length;</span>

<span class="nc" id="L197">        List&lt;Set&lt;PairInt&gt;&gt; groups = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        for (int i = 0; i &lt; nc; ++i) {</span>
<span class="nc" id="L199">            groups.add(new HashSet&lt;PairInt&gt;());</span>
        }

<span class="nc bnc" id="L202" title="All 2 branches missed.">        for (Entry&lt;PairInt, Integer&gt; entry : polarCIEXYMap.entrySet()) {</span>

<span class="nc" id="L204">            int theta = entry.getValue().intValue();</span>

<span class="nc" id="L206">            int idx = Arrays.binarySearch(binCenters, theta);</span>
            // if it's negative, (-(insertion point) - 1)
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (idx &lt; 0) {</span>
                // idx = -*idx2 - 1
<span class="nc" id="L210">                idx = -1*(idx + 1);</span>
            }
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (idx &gt; (nc - 1)) {</span>
<span class="nc" id="L213">                idx = nc - 1;</span>
            }

<span class="nc" id="L216">            int vc = binCenters[idx];</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (idx == 0) {</span>

<span class="nc" id="L220">                int bisectorBelowHalfLength = (360 - binCenters[nc - 1] + vc)/2;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if ((vc - theta) &gt; bisectorBelowHalfLength) {</span>
<span class="nc" id="L222">                    idx = nc - 1;</span>
                }

<span class="nc" id="L225">            } else {</span>

<span class="nc" id="L227">                int bisectorBelow = ((binCenters[idx - 1] + vc) / 2);</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">                if (theta &lt; bisectorBelow) {</span>
<span class="nc" id="L230">                    idx = idx - 1;</span>
                }
            }

<span class="nc" id="L234">            Set&lt;PairInt&gt; set = groups.get(Integer.valueOf(idx));</span>
<span class="nc" id="L235">            set.add(entry.getKey());</span>
<span class="nc" id="L236">        }</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (int i = (groups.size() - 1); i &gt; -1; --i) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (groups.get(i).isEmpty()) {</span>
<span class="nc" id="L240">                groups.remove(i);</span>
            }
        }

<span class="nc" id="L244">        return groups;</span>
    }

    /**
     * applies a blur of sigma=1 to image,
     * converts each pixel color to the polar angle of CIE XY Lab color space
     * with an origin of (0.35, 0.35) and uses a histogram binning of kColors=8,
     * then maps those bins to 0 to 255,
     * then replaces a pixel if 5,6 or its neighbors have the same color,
     * then applies histogram equalization to stretch the values to range
     * 0 to 255.
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistEq(ImageExt input) {

<span class="nc" id="L260">        int kColors = 8;</span>

<span class="nc" id="L262">        return applyUsingCIEXYPolarThetaThenHistEq(input, kColors, true);</span>
    }

    /**
     * converts each pixel color to the polar angle of CIE XY Lab color space
     * with an origin of (0.35, 0.35) and uses a histogram binning of kColors,
     * then maps those bins to 0 to 255,
     * then replaces a pixel if 5,6 or its neighbors have the same color,
     * then applies histogram equalization to stretch the values to range
     * 0 to 255.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur if true, a blur of sigma=1 is applied to the image before
     * processing.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistEq(ImageExt input,
        int kColors, boolean useBlur) {

<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L283">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

<span class="nc" id="L289">        ImageProcessor imageProcessor = new ImageProcessor();</span>

        GreyscaleImage img;

        int minNeighborLimit;

<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (useBlur) {</span>

<span class="nc" id="L297">            Image input2 = input.copyImage();</span>

<span class="nc" id="L299">            imageProcessor.blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="nc" id="L301">            img = applyUsingCIEXYPolarThetaThenHistogram(input2, kColors);</span>

<span class="nc" id="L303">            minNeighborLimit = 6;</span>

<span class="nc" id="L305">        } else {</span>

<span class="nc" id="L307">            img = applyUsingCIEXYPolarThetaThenHistogram(input, kColors);</span>

<span class="nc" id="L309">            minNeighborLimit = 5;</span>
        }

<span class="nc" id="L312">        int w = img.getWidth();</span>
<span class="nc" id="L313">        int h = img.getHeight();</span>

        // ----replace pixel, if 5,6 or more neighbors have same color -----
<span class="nc" id="L316">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="nc" id="L317">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="nc" id="L319">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L321">        int nChanged = 1;</span>
<span class="nc" id="L322">        int nIterMax = 100;</span>
<span class="nc" id="L323">        int nIter = 0;</span>

<span class="nc bnc" id="L325" title="All 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="nc" id="L327">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="nc" id="L329">            nChanged = 0;</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L334">                    freqMap.clear();</span>

<span class="nc" id="L336">                    Integer maxCountValue = null;</span>
<span class="nc" id="L337">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="nc" id="L340">                        int x = dxs[nIdx] + col;</span>
<span class="nc" id="L341">                        int y = dys[nIdx] + row;</span>

<span class="nc bnc" id="L343" title="All 8 branches missed.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L344">                            break;</span>
                        }

<span class="nc" id="L347">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="nc" id="L349">                        Integer c = freqMap.get(v);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L351">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="nc" id="L353">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="nc" id="L355">                        freqMap.put(v, c);</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="nc" id="L358">                            maxCount = c.intValue();</span>
<span class="nc" id="L359">                            maxCountValue = v;</span>
                        }
                    }

<span class="nc bnc" id="L363" title="All 2 branches missed.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="nc" id="L366">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="nc" id="L367">                        nChanged++;</span>
                    }
                }
            }

<span class="nc" id="L372">            nIter++;</span>
        }

        // rescale the image
<span class="nc" id="L376">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L377">        hEq.applyFilter();</span>

<span class="nc" id="L379">        return img;</span>
    }

    /**
     * applies a blur of sigma=1 to image,
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors=8 bins points then remaps the points to use the
     * range 0 to 255, then replaces a pixel if it has 7 neighbors of same
     * color, then applies histogram equalization to rescale the range to be
     * between 0 and 255.
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPPThenHistEq(ImageExt
        input) {

<span class="nc" id="L395">        int kColors = 8;</span>

<span class="nc" id="L397">        return applyUsingCIEXYPolarThetaThenKMPPThenHistEq(input, kColors, true);</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors bins points then remaps the points to use the
     * range 0 to 255, then replaces a pixel if it has 5,6 neighbors of same
     * color, then applies histogram equalization to rescale the range to be
     * between 0 and 255.
     *
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPPThenHistEq(ImageExt input,
        int kColors, boolean useBlur) {

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L417">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L420">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

<span class="fc" id="L423">        ImageProcessor imageProcessor = new ImageProcessor();</span>

        GreyscaleImage img;

        int minNeighborLimit;

<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (useBlur) {</span>

<span class="nc" id="L431">            Image input2 = input.copyImage();</span>

<span class="nc" id="L433">            imageProcessor.blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="nc" id="L435">            img = applyUsingCIEXYPolarThetaThenKMPP(input2, kColors);</span>

<span class="nc" id="L437">            minNeighborLimit = 6;</span>

<span class="nc" id="L439">        } else {</span>

<span class="fc" id="L441">            img = applyUsingCIEXYPolarThetaThenKMPP(input, kColors);</span>

<span class="fc" id="L443">            minNeighborLimit = 5;</span>
        }

<span class="fc" id="L446">        int w = img.getWidth();</span>
<span class="fc" id="L447">        int h = img.getHeight();</span>

        // ----replace pixel, if 5,6 or more neighbors have same color -----
<span class="fc" id="L450">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L451">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="fc" id="L453">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="fc" id="L455">        int nChanged = 1;</span>
<span class="fc" id="L456">        int nIterMax = 100;</span>
<span class="fc" id="L457">        int nIter = 0;</span>

<span class="pc bpc" id="L459" title="2 of 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="fc" id="L461">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="fc" id="L463">            nChanged = 0;</span>

<span class="fc bfc" id="L465" title="All 2 branches covered.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="fc" id="L468">                    freqMap.clear();</span>

<span class="fc" id="L470">                    Integer maxCountValue = null;</span>
<span class="fc" id="L471">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="fc bfc" id="L473" title="All 2 branches covered.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="fc" id="L474">                        int x = dxs[nIdx] + col;</span>
<span class="fc" id="L475">                        int y = dys[nIdx] + row;</span>

<span class="fc bfc" id="L477" title="All 8 branches covered.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="fc" id="L478">                            break;</span>
                        }

<span class="fc" id="L481">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="fc" id="L483">                        Integer c = freqMap.get(v);</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                        if (c == null) {</span>
<span class="fc" id="L485">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="fc" id="L487">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="fc" id="L489">                        freqMap.put(v, c);</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="fc" id="L492">                            maxCount = c.intValue();</span>
<span class="fc" id="L493">                            maxCountValue = v;</span>
                        }
                    }

<span class="fc bfc" id="L497" title="All 2 branches covered.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="fc" id="L500">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="fc" id="L501">                        nChanged++;</span>
                    }
                }
            }

<span class="fc" id="L506">            nIter++;</span>
        }

        // rescale the image
<span class="fc" id="L510">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="fc" id="L511">        hEq.applyFilter();</span>

<span class="fc" id="L513">        return img;</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta,
     * then applies histogram mapping of kColors to remap the pixels to
     * values between 0 and 255.
     *
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistogram(Image input) {

<span class="nc" id="L526">        return applyUsingCIEXYPolarThetaThenHistogram(input, 253);</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta,
     * then applies histogram mapping of kColors to remap the pixels to
     * values between 0 and 255.
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistogram(Image input,
        int kColors) {

<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L543">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L546">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="nc" id="L556">        int w = input.getWidth();</span>
<span class="nc" id="L557">        int h = input.getHeight();</span>

<span class="nc" id="L559">        float[] tmpColorBuffer = new float[2];</span>

<span class="nc" id="L561">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="nc" id="L563">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="nc" id="L565">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L567">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="nc" id="L568">        int thetaCount = 0;</span>

<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L573">                PairInt p = new PairInt(col, row);</span>

<span class="nc" id="L575">                int r = input.getR(col, row);</span>
<span class="nc" id="L576">                int g = input.getG(col, row);</span>
<span class="nc" id="L577">                int b = input.getB(col, row);</span>

<span class="nc bnc" id="L579" title="All 6 branches missed.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="nc" id="L580">                    continue;</span>
<span class="nc bnc" id="L581" title="All 6 branches missed.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="nc" id="L582">                    output.setValue(col, row, 255);</span>
<span class="nc" id="L583">                    continue;</span>
                }

<span class="nc" id="L586">                float[] cieXY = tmpColorBuffer;</span>
<span class="nc" id="L587">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="nc" id="L590">                    output.setValue(col, row, 255);</span>
                } else {

<span class="nc" id="L593">                    double thetaRadians = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="nc" id="L595">                    thetaValues[thetaCount] = (float)thetaRadians;</span>

<span class="nc" id="L597">                    pixThetaMap.put(p, Float.valueOf((float)thetaRadians));</span>

<span class="nc" id="L599">                    thetaCount++;</span>
                }
            }
        }

<span class="nc" id="L604">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="nc" id="L606">        createAndApplyHistMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="nc" id="L608">        return output;</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors bins points then remaps the points to use the
     * range 0 to 255.
     *
     * runtime complexity is O(N) + O(N*lg_2(N))
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPP(Image input, int kColors) {

<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L626">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L629">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="fc" id="L639">        int w = input.getWidth();</span>
<span class="fc" id="L640">        int h = input.getHeight();</span>

<span class="fc" id="L642">        float[] tmpColorBuffer = new float[2];</span>

<span class="fc" id="L644">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="fc" id="L646">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="fc" id="L648">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L650">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="fc" id="L651">        int thetaCount = 0;</span>

<span class="fc bfc" id="L653" title="All 2 branches covered.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="fc" id="L656">                PairInt p = new PairInt(col, row);</span>

<span class="fc" id="L658">                int r = input.getR(col, row);</span>
<span class="fc" id="L659">                int g = input.getG(col, row);</span>
<span class="fc" id="L660">                int b = input.getB(col, row);</span>

<span class="fc bfc" id="L662" title="All 6 branches covered.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="fc" id="L663">                    continue;</span>
<span class="pc bpc" id="L664" title="1 of 6 branches missed.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="nc" id="L665">                    output.setValue(col, row, 255);</span>
<span class="nc" id="L666">                    continue;</span>
                }

<span class="fc" id="L669">                float[] cieXY = tmpColorBuffer;</span>
<span class="fc" id="L670">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="fc" id="L673">                    output.setValue(col, row, 255);</span>
                } else {

<span class="fc" id="L676">                    double thetaRadians = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="fc" id="L678">                    thetaValues[thetaCount] = (float)thetaRadians;</span>

<span class="fc" id="L680">                    pixThetaMap.put(p, Float.valueOf((float)thetaRadians));</span>

<span class="fc" id="L682">                    thetaCount++;</span>
                }
            }
        }

<span class="fc" id="L687">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="fc" id="L689">        createAndApplyKMPPMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="fc" id="L691">        return output;</span>
    }

    private void createAndApplyKMPPMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

        //TODO: assert kColors.  The invoker is reserving 2 bands for
        // B &amp; W, so nBins should probably be (kColors - 2)...
        // correct this for the invoker when testing
<span class="fc" id="L701">        int nBins = kColors;</span>

<span class="fc" id="L703">        KMeansPlusPlusFloat kmpp = new KMeansPlusPlusFloat();</span>
<span class="fc" id="L704">        kmpp.computeMeans(nBins, thetaValues);</span>

<span class="fc" id="L706">        float minValue = kmpp.getMinValue();</span>
<span class="fc" id="L707">        float maxValue = kmpp.getMaxValue();</span>

<span class="fc" id="L709">        float[] binCenters = kmpp.getCenters();</span>

<span class="fc" id="L711">        Iterator&lt;Map.Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

<span class="fc bfc" id="L713" title="All 2 branches covered.">        while (iter.hasNext()) {</span>

<span class="fc" id="L715">            Map.Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="fc" id="L717">            PairInt p = entry.getKey();</span>

<span class="fc" id="L719">            float theta = entry.getValue().floatValue();</span>

<span class="pc bpc" id="L721" title="1 of 2 branches missed.">            for (int i = 0; i &lt; binCenters.length; i++) {</span>

<span class="fc" id="L723">                float vc = binCenters[i];</span>

<span class="fc bfc" id="L725" title="All 2 branches covered.">                float bisectorBelow = ((i - 1) &gt; -1) ?</span>
                    ((binCenters[i - 1] + vc) / 2) : minValue;

<span class="fc bfc" id="L728" title="All 2 branches covered.">                float bisectorAbove = ((i + 1) &gt; (binCenters.length - 1)) ?</span>
                    maxValue : ((binCenters[i + 1] + vc) / 2);

<span class="pc bpc" id="L731" title="1 of 4 branches missed.">                if ((theta &gt;= bisectorBelow) &amp;&amp; (theta &lt;= bisectorAbove)) {</span>

                    //TODO: check this
<span class="fc" id="L734">                    int mappedValue = 255 - nBins + i;</span>

<span class="fc" id="L736">                    output.setValue(p.getX(), p.getY(), mappedValue);</span>

<span class="fc" id="L738">                    break;</span>
                }
            }

            /*
            // if binCenters is ordered, use binary search for faster results
            int idx = Arrays.binarySearch(startBins, theta);

            // if it's negative, (-(insertion point) - 1)
            if (idx &lt; 0) {
                // idx = -*idx2 - 1
                idx = -1*(idx + 1);
            }
            int mappedValue = 255 - startBins.length + idx;

            output.setValue(p.getX(), p.getY(), mappedValue);
            */
<span class="fc" id="L755">        }</span>
<span class="fc" id="L756">    }</span>

    private void createAndApplyHistMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

<span class="nc" id="L762">        float minValue = MiscMath.findMin(thetaValues);</span>
<span class="nc" id="L763">        float maxValue = MiscMath.findMax(thetaValues);</span>

<span class="nc" id="L765">        log.fine(&quot;minTheta=&quot; + (minValue * 180./Math.PI) +</span>
            &quot; maxTheta=&quot; + (maxValue * 180./Math.PI));

<span class="nc" id="L768">        int nReserved = 254 - kColors;</span>

<span class="nc" id="L770">        HistogramHolder hist = Histogram.createSimpleHistogram(minValue,</span>
            maxValue, (256 - nReserved - 1), thetaValues,
<span class="nc" id="L772">            Errors.populateYErrorsBySqrt(thetaValues));</span>

        try {
<span class="nc" id="L775">            hist.plotHistogram(&quot;cie XY theta histogram&quot;, &quot;cieXY_hist_&quot;</span>
<span class="nc" id="L776">                + MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L777">        } catch (Exception e) {}</span>

<span class="nc" id="L779">        int nonZeroCount = 0;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="nc" id="L781">            int c = hist.getYHist()[i];</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L783">                nonZeroCount++;</span>
            }
        }

<span class="nc" id="L787">        float[] startBins = new float[nonZeroCount];</span>

<span class="nc" id="L789">        float halfBinWidth = (hist.getXHist()[1] - hist.getXHist()[0])/2.f;</span>

<span class="nc" id="L791">        nonZeroCount = 0;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="nc" id="L793">            int c = hist.getYHist()[i];</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L795">                startBins[nonZeroCount] = hist.getXHist()[i] - halfBinWidth;</span>
<span class="nc" id="L796">                nonZeroCount++;</span>
            }
        }

<span class="nc" id="L800">        Iterator&lt;Map.Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

        // O(N * lg_2(N))
<span class="nc bnc" id="L803" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L805">            Map.Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="nc" id="L807">            PairInt p = entry.getKey();</span>

<span class="nc" id="L809">            float theta = entry.getValue().floatValue();</span>

<span class="nc" id="L811">            int idx = Arrays.binarySearch(startBins, theta);</span>

            // if it's negative, (-(insertion point) - 1)
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (idx &lt; 0) {</span>
                // idx = -*idx2 - 1
<span class="nc" id="L816">                idx = -1*(idx + 1);</span>
            }

<span class="nc" id="L819">            int mappedValue = 255 - startBins.length + idx;</span>

<span class="nc" id="L821">            output.setValue(p.getX(), p.getY(), mappedValue);</span>
<span class="nc" id="L822">        }</span>
<span class="nc" id="L823">    }</span>

    /**
     * NOT READY FOR USE.  STILL EXPERIMENTING.
     *
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to CIEXY Lab color space, then creates a map of the
     * CIEX and CIEY points and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters of points in CIE X, CIEY space,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * cie xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param useBlur
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingCIEXYAndClustering(ImageExt input,
        boolean useBlur) {

        //TODO: improve the clustering results in two ways:
        // (1) for smaller ciexy clusters, merge with adjacent clusters if
        //     similar color
        // (2) any pixel with 7 neighbors of same color should be that color too

<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (useBlur) {</span>
<span class="nc" id="L857">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L858">            imageProcessor.blur(input, 1.0f);</span>
        }

        //TODO: consider making a segmentation method using CIEXY theta
        // for x and the frequency for y, both scaled to numerically
        // resolvable range &lt; max of 5000.
        // this would be good to compare to the method here which
        // uses CIE XY Theta followed by histograms or KMeans++.
        // No need to specify the number of bins before use for suggested
        // version.

        //NOTE: the method needs to have gaps in the data given to it
        //    that is a lack of points for some region between the
        //    min and max of x and y data in integer space

        // max = 6250 unless reduce space complexity
<span class="nc" id="L874">        float factor = 2000;// learn this from numerical resolution</span>

        // then subtract the minima in both cieX and cieY

<span class="nc" id="L878">        int minCIEX = Integer.MAX_VALUE;</span>
<span class="nc" id="L879">        int minCIEY = Integer.MAX_VALUE;</span>
<span class="nc" id="L880">        int maxCIEX = Integer.MIN_VALUE;</span>
<span class="nc" id="L881">        int maxCIEY = Integer.MIN_VALUE;</span>

<span class="nc" id="L883">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L885">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L887">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L889">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L891">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

        // -------- debug -------
<span class="nc" id="L894">        int nGrey = 0;</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L896">            nGrey += entry.getValue().size();</span>
<span class="nc" id="L897">        }</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        assert((points0.size() + blackPixels.size() + nGrey +</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            whitePixels.size()) == input.getNPixels());</span>
        // -------- end debug -------

<span class="nc" id="L902">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>

        // ------- debug -------
<span class="nc" id="L905">        int nGrey2 = 0;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc" id="L907">            nGrey2 += set.size();</span>
<span class="nc" id="L908">        }</span>
<span class="nc bnc" id="L909" title="All 4 branches missed.">        assert(nGrey == nGrey2);</span>
        // ------- end debug =====

<span class="nc" id="L912">        Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap0 =</span>
            new HashMap&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt;();

<span class="nc bnc" id="L915" title="All 2 branches missed.">        for (PairInt p : points0) {</span>
<span class="nc" id="L916">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="nc" id="L917">            float cx = input.getCIEX(idx);</span>
<span class="nc" id="L918">            float cy = input.getCIEY(idx);</span>

<span class="nc" id="L920">            int cieXInt = Math.round(factor * cx);</span>
<span class="nc" id="L921">            int cieYInt = Math.round(factor * cy);</span>

<span class="nc" id="L923">            PairIntWithIndex p0 = new PairIntWithIndex(cieXInt, cieYInt, idx);</span>
<span class="nc" id="L924">            List&lt;PairIntWithIndex&gt; list = pointsMap0.get(p0);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L926">                list = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="nc" id="L927">                pointsMap0.put(p0, list);</span>
            }
<span class="nc" id="L929">            list.add(p0);</span>

<span class="nc bnc" id="L931" title="All 2 branches missed.">            if (cieXInt &lt; minCIEX) {</span>
<span class="nc" id="L932">                minCIEX = cieXInt;</span>
            }
<span class="nc bnc" id="L934" title="All 2 branches missed.">            if (cieYInt &lt; minCIEY) {</span>
<span class="nc" id="L935">                minCIEY = cieYInt;</span>
            }
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (cieXInt &gt; maxCIEX) {</span>
<span class="nc" id="L938">                maxCIEX = cieXInt;</span>
            }
<span class="nc bnc" id="L940" title="All 2 branches missed.">            if (cieYInt &gt; maxCIEY) {</span>
<span class="nc" id="L941">                maxCIEY = cieYInt;</span>
            }
<span class="nc" id="L943">        }</span>

<span class="nc" id="L945">        Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap =</span>
            new HashMap&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt;();

        // subtract minima from the points
<span class="nc bnc" id="L949" title="All 2 branches missed.">        for (PairIntWithIndex p : pointsMap0.keySet()) {</span>

<span class="nc" id="L951">            int x = p.getX() - minCIEX;</span>
<span class="nc" id="L952">            int y = p.getY() - minCIEY;</span>

<span class="nc" id="L954">            PairIntWithIndex p2 = new PairIntWithIndex(x, y, p.getPixIndex());</span>
<span class="nc" id="L955">            List&lt;PairIntWithIndex&gt; list2 = pointsMap.get(p2);</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (list2 == null) {</span>
<span class="nc" id="L957">                list2 = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="nc" id="L958">                pointsMap.put(p2, list2);</span>
            }
            // because this is a list, this will eventually be present twice:
            //list2.add(p2);

<span class="nc bnc" id="L963" title="All 2 branches missed.">            for (PairIntWithIndex p0 : pointsMap0.get(p)) {</span>
<span class="nc" id="L964">                PairIntWithIndex p3 = new PairIntWithIndex(</span>
<span class="nc" id="L965">                    p0.getX() - minCIEX, p0.getY() - minCIEY, p0.getPixIndex());</span>
<span class="nc" id="L966">                list2.add(p3);</span>
<span class="nc" id="L967">            }</span>
<span class="nc" id="L968">        }</span>
<span class="nc" id="L969">        maxCIEX -= minCIEX;</span>
<span class="nc" id="L970">        maxCIEY -= minCIEY;</span>

        // frequency of colors:
<span class="nc" id="L973">        Map&lt;PairIntWithIndex, Integer&gt; freqMap = new</span>
            HashMap&lt;PairIntWithIndex, Integer&gt;();
        for (Map.Entry&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; entry :
<span class="nc bnc" id="L976" title="All 2 branches missed.">            pointsMap.entrySet()) {</span>
<span class="nc" id="L977">            int c = entry.getValue().size();</span>
<span class="nc" id="L978">            freqMap.put(entry.getKey(), Integer.valueOf(c));</span>
<span class="nc" id="L979">        }</span>

        // ----- debug ---
<span class="nc" id="L982">        int nGreyBW = nGrey + blackPixels.size() + whitePixels.size();</span>
<span class="nc" id="L983">        int nTot = 0;</span>
        //Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap
<span class="nc bnc" id="L985" title="All 2 branches missed.">        for (Entry&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; entry : pointsMap.entrySet()) {</span>
<span class="nc" id="L986">            nTot += entry.getValue().size();</span>
<span class="nc" id="L987">        }</span>
<span class="nc" id="L988">        nTot += nGreyBW;</span>
<span class="nc" id="L989">        log.info(&quot;nTot=&quot; + nTot + &quot; nPixels=&quot; + input.getNPixels());</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>

        // plot the points as an image to see the data first
<span class="nc" id="L993">        GreyscaleImage img = new GreyscaleImage(maxCIEX + 1, maxCIEY + 1);</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">        for (com.climbwithyourfeet.clustering.util.PairInt p : pointsMap.keySet()) {</span>
<span class="nc" id="L995">            img.setValue(p.getX(), p.getY(), 255);</span>
<span class="nc" id="L996">        }</span>
        try {
<span class="nc" id="L998">            ImageIOHelper.writeOutputImage(</span>
<span class="nc" id="L999">                ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt_input.png&quot;, img);</span>
<span class="nc" id="L1000">        } catch (IOException ex) {</span>
<span class="nc" id="L1001">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="nc" id="L1003">        }</span>
        // --- end debug

        //Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap

<span class="nc" id="L1008">        DTClusterFinder&lt;PairIntWithIndex&gt; clusterFinder</span>
<span class="nc" id="L1009">            = new DTClusterFinder&lt;PairIntWithIndex&gt;(pointsMap.keySet(),</span>
            maxCIEX + 1, maxCIEY + 1);

<span class="nc" id="L1012">        clusterFinder.setToDebug();</span>

        // to recover every point, set limit to 1
<span class="nc" id="L1015">        clusterFinder.setMinimumNumberInCluster(1);</span>

<span class="nc" id="L1017">        clusterFinder.calculateCriticalDensity();</span>

<span class="nc" id="L1019">        clusterFinder.findClusters();</span>

<span class="nc" id="L1021">        log.info(&quot;clustering critical density=&quot; + clusterFinder.getCriticalDensity());</span>

<span class="nc" id="L1023">        int nGroups = clusterFinder.getNumberOfClusters();</span>

<span class="nc" id="L1025">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="nc bnc" id="L1027" title="All 2 branches missed.">        for (int k = 0; k &lt; nGroups; ++k) {</span>

<span class="nc" id="L1029">            Set&lt;PairIntWithIndex&gt; group = clusterFinder.getCluster(k);</span>

<span class="nc" id="L1031">            Set&lt;PairInt&gt; coordPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1033" title="All 2 branches missed.">            for (PairIntWithIndex p : group) {</span>

<span class="nc" id="L1035">                int idx = p.getPixIndex();</span>
<span class="nc" id="L1036">                int xCoord = input.getCol(idx);</span>
<span class="nc" id="L1037">                int yCoord = input.getRow(idx);</span>

<span class="nc" id="L1039">                PairInt pCoord = new PairInt(xCoord, yCoord);</span>
<span class="nc" id="L1040">                coordPoints.add(pCoord);</span>

                // include the other points of/ same color
<span class="nc" id="L1043">                List&lt;PairIntWithIndex&gt; list = pointsMap.get(p);</span>
<span class="nc bnc" id="L1044" title="All 4 branches missed.">                assert(list != null);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                for (PairIntWithIndex p3 : list) {</span>
<span class="nc" id="L1046">                    int idx3 = p3.getPixIndex();</span>
<span class="nc" id="L1047">                    int xCoord3 = input.getCol(idx3);</span>
<span class="nc" id="L1048">                    int yCoord3 = input.getRow(idx3);</span>
<span class="nc" id="L1049">                    pCoord = new PairInt(xCoord3, yCoord3);</span>
<span class="nc" id="L1050">                    coordPoints.add(pCoord);</span>
<span class="nc" id="L1051">                }</span>
<span class="nc" id="L1052">            }</span>

<span class="nc" id="L1054">            groupList.add(coordPoints);</span>
        }

        // ------ debug ---------
<span class="nc" id="L1058">        nTot = 0;</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : groupList) {</span>
<span class="nc" id="L1060">            nTot += set.size();</span>
<span class="nc" id="L1061">        }</span>
<span class="nc" id="L1062">        nTot += nGreyBW;</span>
<span class="nc" id="L1063">        log.info(&quot;nTot=&quot; + nTot + &quot; nPixels=&quot; + input.getNPixels());</span>
<span class="nc bnc" id="L1064" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // ------ end debug -----

<span class="nc" id="L1067">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList,</span>
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
<span class="nc" id="L1071">        groupList.add(blackPixels);</span>
<span class="nc" id="L1072">        groupList.add(whitePixels);</span>

<span class="nc" id="L1074">        int nTot2 = 0;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; groups : groupList) {</span>
<span class="nc" id="L1076">            nTot2 += groups.size();</span>
<span class="nc" id="L1077">        }</span>

<span class="nc" id="L1079">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot2=&quot; + nTot2);</span>
<span class="nc bnc" id="L1080" title="All 4 branches missed.">        assert(nTot2 == input.getNPixels());</span>

<span class="nc" id="L1082">        return groupList;</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency)
     * and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters in that space (polar CIEXY vs frequency),
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameters are the scaling of the range of polar angles
     * and the range of frequency in order to place the data between values of 0
     * and a number.
     * &lt;code&gt;The scale factors are double xFactor = 2000. and int yFactor = 2000
     * for example.  Smaller scale factors result in faster runtimes,
     * but must be balanced by a large enough factor to have cluster resulution.
     * &lt;/code&gt;
     * Note that the polar angle vs frequency maps are actually partitioned into
     * 4 maps to do density based cluster finding separately.
     * partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f} is the fraction of
     * the maximum frequency defining a partition.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndClustering(ImageExt input,
        boolean useBlur) {

<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (useBlur) {</span>
<span class="nc" id="L1122">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L1123">            imageProcessor.blur(input, 1.0f);</span>
        }

        //making a segmentation method using CIEXY theta
        // for x and the frequency for y, both scaled to numerically
        // resolvable range &lt; max of 5000.
        // this would be good to compare to the method here which
        // uses CIE XY Theta followed by histograms or KMeans++.
        // No need to specify the number of bins before use for suggested
        // version.

<span class="nc" id="L1134">        int w = input.getWidth();</span>
<span class="nc" id="L1135">        int h = input.getHeight();</span>

<span class="nc" id="L1137">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1139">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L1141">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1143">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1145">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

<span class="nc" id="L1147">        double[] minMaxTheta0 = findMinMaxTheta(input, points0);</span>

<span class="nc" id="L1149">        log.info(&quot;for all non-white and non-black, minTheta=&quot; + minMaxTheta0[0]</span>
            + &quot; maxTheta=&quot; + minMaxTheta0[1]);

        // -------- debug -------
<span class="nc" id="L1153">        int nGrey = 0;</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L1155">            nGrey += entry.getValue().size();</span>
<span class="nc" id="L1156">        }</span>
<span class="nc" id="L1157">        int nGreyBW = + blackPixels.size() + nGrey + whitePixels.size();</span>
<span class="nc" id="L1158">        int nTot = (points0.size() + nGreyBW);</span>
<span class="nc" id="L1159">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="nc bnc" id="L1160" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // -------- end debug -------

<span class="nc" id="L1163">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>

<span class="nc" id="L1165">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(greyPixelGroups.size());</span>

<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">             if (points0.isEmpty()) {</span>
<span class="nc" id="L1169">                 groupList.add(points0);</span>
             }
<span class="nc bnc" id="L1171" title="All 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="nc" id="L1172">                 groupList.add(blackPixels);</span>
             }
<span class="nc bnc" id="L1174" title="All 2 branches missed.">             for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc" id="L1175">                groupList.add(set);</span>
<span class="nc" id="L1176">             }</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L1178">                 groupList.add(whitePixels);</span>
             }
<span class="nc" id="L1180">             return groupList;</span>
        }

<span class="nc" id="L1183">        double xFactor = 2000.;</span>
<span class="nc" id="L1184">        int yFactor = 2000;</span>

<span class="nc" id="L1186">        double[] minMaxTheta = new double[2];</span>
<span class="nc" id="L1187">        int[] minMaxFreq = new int[2];</span>
<span class="nc" id="L1188">        double thetaFactor0 = xFactor/(minMaxTheta0[1] - minMaxTheta0[0]);</span>
<span class="nc" id="L1189">        Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap = createThetaCIEXYMap(points0,</span>
            input, minMaxTheta0[0], thetaFactor0, minMaxTheta, minMaxFreq);

        // ---- debug ------
<span class="nc" id="L1193">        nTot = nGreyBW;</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1195">            nTot += entry.getValue().size();</span>
<span class="nc" id="L1196">        }</span>
<span class="nc" id="L1197">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // ----- end debug ------

        /* ---- create frequency maps partitioned by given fractions ----
        starting w/ partitions at 3 percent (maybe discard below),
            15 percent, and 25 percent resulting in 4 maps

        For each map:
            key is pairint w/ x=theta, y=freq,
            value is all pixels having same key
        */

<span class="nc" id="L1210">        final float[] partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f};</span>

        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1213">            List&lt;PairIntWithIndex&gt;&gt;&gt; thetaFreqMaps =</span>
<span class="nc" id="L1214">            partitionIntoFrequencyMaps(input, thetaPointMap,</span>
                partitionFreqFracs, minMaxFreq[1]);

        //---- debug, assert number of pixels ----
<span class="nc" id="L1218">        nTot = nGreyBW;</span>
        for (Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        List&lt;PairIntWithIndex&gt;&gt; map : thetaFreqMaps) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                List&lt;PairIntWithIndex&gt;&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L1223">                nTot += entry.getValue().size();</span>
<span class="nc" id="L1224">            }</span>
<span class="nc" id="L1225">        }</span>
<span class="nc" id="L1226">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="nc bnc" id="L1227" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>

        // TODO: handle wrap around values!
        //    if there are points at 0 and 360, and a gap elsewhere, can
        //    shift the values so the gap is at 360 instead.

        // ------ TODO: rescale each map by frequencies to span ~1000 pixels -----
<span class="nc" id="L1234">        rescaleKeys(thetaFreqMaps, yFactor);</span>

<span class="nc" id="L1236">        int nTot2 = 0;</span>

<span class="nc bnc" id="L1238" title="All 2 branches missed.">        for (int i = 1; i &lt; thetaFreqMaps.size(); ++i) {</span>

            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1241">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMapI = thetaFreqMaps.get(i);</span>

<span class="nc" id="L1243">            int[] maxXY = findMaxXY(thetaFreqMapI.keySet());</span>

<span class="nc bnc" id="L1245" title="All 4 branches missed.">            if (maxXY[0] &lt; 0 || maxXY[1] &lt;= 0) {</span>
<span class="nc" id="L1246">                continue;</span>
            }

            // ----- debug ---
            // plot the points as an image to see the data first
<span class="nc" id="L1251">            GreyscaleImage img = new GreyscaleImage(maxXY[0] + 1, maxXY[1] + 1);</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            for (com.climbwithyourfeet.clustering.util.PairInt p : thetaFreqMapI.keySet()) {</span>
<span class="nc" id="L1253">                img.setValue(p.getX(), p.getY(), 255);</span>
<span class="nc" id="L1254">            }</span>
            try {
<span class="nc" id="L1256">                ImageIOHelper.writeOutputImage(</span>
<span class="nc" id="L1257">                    ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt2_input_&quot; + i</span>
                        + &quot;_.png&quot;, img);
<span class="nc" id="L1259">            } catch (IOException ex) {</span>
<span class="nc" id="L1260">                Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                    null, ex);
<span class="nc" id="L1262">            }</span>
            // --- end debug

            // Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            //     List&lt;PairIntWithIndex&gt;&gt; thetaFreqMapI

            // map w/ key=(theta, freq) value=collection of coords
            DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;
<span class="nc" id="L1270">                clusterFinder</span>
                = new DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;(
<span class="nc" id="L1272">                    thetaFreqMapI.keySet(), maxXY[0] + 1, maxXY[1] + 1);</span>

<span class="nc" id="L1274">            clusterFinder.setToDebug();</span>

            // to recover every point, set limit to 1
<span class="nc" id="L1277">            clusterFinder.setMinimumNumberInCluster(1);</span>

<span class="nc" id="L1279">            clusterFinder.calculateCriticalDensity();</span>

<span class="nc" id="L1281">            clusterFinder.findClusters();</span>

<span class="nc" id="L1283">            int nGroups = clusterFinder.getNumberOfClusters();</span>

<span class="nc bnc" id="L1285" title="All 2 branches missed.">            for (int k = 0; k &lt; nGroups; ++k) {</span>

<span class="nc" id="L1287">                Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; group</span>
<span class="nc" id="L1288">                    = clusterFinder.getCluster(k);</span>

<span class="nc" id="L1290">                Set&lt;PairInt&gt; coordPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1292" title="All 2 branches missed.">                for (com.climbwithyourfeet.clustering.util.PairInt pThetaFreq : group) {</span>

                    // include the other points of same ciexy theta, freq
<span class="nc" id="L1295">                    List&lt;PairIntWithIndex&gt; list = thetaFreqMapI.get(pThetaFreq);</span>
<span class="nc bnc" id="L1296" title="All 4 branches missed.">                    assert (list != null);</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                    for (PairIntWithIndex p3 : list) {</span>
<span class="nc" id="L1298">                        int idx3 = p3.getPixIndex();</span>
<span class="nc" id="L1299">                        int xCoord3 = input.getCol(idx3);</span>
<span class="nc" id="L1300">                        int yCoord3 = input.getRow(idx3);</span>
<span class="nc" id="L1301">                        PairInt pCoord = new PairInt(xCoord3, yCoord3);</span>
<span class="nc" id="L1302">                        coordPoints.add(pCoord);</span>
<span class="nc" id="L1303">                    }</span>
<span class="nc" id="L1304">                }</span>

<span class="nc" id="L1306">                nTot2 += coordPoints.size();</span>

<span class="nc" id="L1308">                groupList.add(coordPoints);</span>
            }
        }

<span class="nc" id="L1312">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList,</span>
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
<span class="nc" id="L1316">        groupList.add(blackPixels);</span>
<span class="nc" id="L1317">        groupList.add(whitePixels);</span>

        //TODO: assert npixels

<span class="nc" id="L1321">        return groupList;</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.  The list is sorted by size and
     * set to values from 255 to 0.  If there are more than 255 clusters, the
     * remaining (smaller) clusters are pixels with value 0.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public GreyscaleImage applyUsingPolarCIEXYAndFrequency(ImageExt input,
        boolean useBlur) {

<span class="nc" id="L1349">        float fracFreqLimit = 0.03f;</span>

<span class="nc" id="L1351">        return applyUsingPolarCIEXYAndFrequency(input, fracFreqLimit, useBlur);</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.  The list is sorted by size and
     * set to values from 255 to 0.  If there are more than 255 clusters, the
     * remaining (smaller) clusters are pixels with value 0.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param fracFreqLimit
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public GreyscaleImage applyUsingPolarCIEXYAndFrequency(ImageExt input,
        final float fracFreqLimit, boolean useBlur) {

<span class="fc" id="L1380">        int w = input.getWidth();</span>
<span class="fc" id="L1381">        int h = input.getHeight();</span>

<span class="fc" id="L1383">        List&lt;Set&lt;PairInt&gt;&gt; clusters = calculateUsingPolarCIEXYAndFrequency(</span>
            input, fracFreqLimit, useBlur);

<span class="fc" id="L1386">        int n = clusters.size();</span>
        //assert(n &lt; 256);

        // sort indexes by set size
<span class="fc" id="L1390">        int maxSize = Integer.MIN_VALUE;</span>
<span class="fc" id="L1391">        int[] indexes = new int[n];</span>
<span class="fc" id="L1392">        int[] sizes = new int[n];</span>
<span class="fc bfc" id="L1393" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1394">            indexes[i] = i;</span>
<span class="fc" id="L1395">            sizes[i] = clusters.get(i).size();</span>
<span class="fc bfc" id="L1396" title="All 2 branches covered.">            if (sizes[i] &gt; maxSize) {</span>
<span class="fc" id="L1397">                maxSize = sizes[i];</span>
            }
        }
<span class="fc" id="L1400">        CountingSort.sort(sizes, indexes, maxSize);</span>

<span class="fc" id="L1402">        int delta = 256/clusters.size();</span>
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">        if (delta == 0) {</span>
<span class="nc" id="L1404">            delta = 1;</span>
        }

<span class="fc" id="L1407">        GreyscaleImage img2 = new GreyscaleImage(w, h);</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        for (int k = 0; k &lt; n; ++k) {</span>

<span class="fc" id="L1410">            int idx = indexes[n - k - 1];</span>

<span class="fc" id="L1412">            Set&lt;PairInt&gt; set = clusters.get(idx);</span>

<span class="fc" id="L1414">            int v = 255 - delta*k;</span>
<span class="pc bpc" id="L1415" title="1 of 2 branches missed.">            if (v &lt; 1) {</span>
<span class="nc" id="L1416">                continue;</span>
            }

<span class="fc bfc" id="L1419" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L1420">                img2.setValue(p.getX(), p.getY(), v);</span>
<span class="fc" id="L1421">            }</span>
        }

<span class="fc" id="L1424">        return img2;</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndFrequency(ImageExt input,
        boolean useBlur) {

<span class="nc" id="L1450">        float fracFreqLimit = 0.03f;</span>

<span class="nc" id="L1452">        return calculateUsingPolarCIEXYAndFrequency(input, fracFreqLimit, useBlur);</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameter is the fracFreqLimit.  Larger values exclude
     * smaller frequency peaks.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input image to find color clusters within
     * @param fracFreqLimit fraction of the maximum above which peaks will be found
     * @param useBlur if true, performs a gaussian blur of sigma=1 before finding
     * clusters.
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndFrequency(ImageExt input,
        float fracFreqLimit, boolean useBlur) {

<span class="fc bfc" id="L1483" title="All 2 branches covered.">        if (useBlur) {</span>
<span class="fc" id="L1484">            input = input.copyToImageExt();</span>
<span class="fc" id="L1485">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L1486">            imageProcessor.blur(input, 1.0f);</span>
        }

        //making a segmentation method using CIEXY polar theta
        // and the number of points with those colors.
        // choosing the peaks to be the cluster centers, then
        // gathering the pixels by proximity to the theta peaks
        // and when equidistant, chooses the largest peak.

<span class="fc" id="L1495">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1497">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="fc" id="L1499">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1501">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1503">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

<span class="fc" id="L1505">        double[] minMaxTheta0 = findMinMaxTheta(input, points0);</span>

<span class="fc" id="L1507">        log.info(&quot;for all non-white and non-black, minTheta=&quot; + minMaxTheta0[0]</span>
            + &quot; maxTheta=&quot; + minMaxTheta0[1]);

        // -------- debug -------
<span class="fc" id="L1511">        int nGrey = 0;</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L1513">            nGrey += entry.getValue().size();</span>
<span class="fc" id="L1514">        }</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">        assert((points0.size() + blackPixels.size() + nGrey +</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            whitePixels.size()) == input.getNPixels());</span>
        // -------- end debug -------

<span class="fc" id="L1519">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>

<span class="fc" id="L1521">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(greyPixelGroups.size());</span>

<span class="fc bfc" id="L1523" title="All 2 branches covered.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="pc bpc" id="L1524" title="1 of 2 branches missed.">             if (points0.isEmpty()) {</span>
<span class="fc" id="L1525">                 groupList.add(points0);</span>
             }
<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="fc" id="L1528">                 groupList.add(blackPixels);</span>
             }
<span class="fc bfc" id="L1530" title="All 2 branches covered.">             for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="fc" id="L1531">                groupList.add(set);</span>
<span class="fc" id="L1532">             }</span>
<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L1534">                 groupList.add(whitePixels);</span>
             }
<span class="fc" id="L1536">             return groupList;</span>
        }

        /* ----- create a map of theta and frequency ----
        need to find the peaks in frequency for frequencies larger than about
        3 percent of max frequency
        but don't want to use a spline3 to smooth, so will average every
        few pixels.
        */

<span class="fc" id="L1546">        int binWidth = 3;</span>
<span class="fc" id="L1547">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap = createThetaCIEXYMap(</span>
            points0, input, binWidth);

<span class="fc" id="L1550">        int n = (360/binWidth) + 1;</span>

<span class="fc" id="L1552">        int[] orderedThetaKeys = new int[n];</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1554">            orderedThetaKeys[i] = i;</span>
        }
<span class="fc" id="L1556">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="fc" id="L1557">        int nTot = 0;</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="fc" id="L1559">            int count = entry.getValue().size();</span>
<span class="fc bfc" id="L1560" title="All 2 branches covered.">            if (count &gt; maxFreq) {</span>
<span class="fc" id="L1561">                maxFreq = count;</span>
            }
<span class="fc" id="L1563">            nTot += entry.getValue().size();</span>
<span class="fc" id="L1564">        }</span>
<span class="fc" id="L1565">        nTot += (blackPixels.size() + nGrey + whitePixels.size());</span>
<span class="pc bpc" id="L1566" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>

        /*
        TODO: this is where the DTClusterFinder would be good to use to find
        the peaks.
        */

<span class="fc" id="L1573">        PairIntArray peaks = findPeaksInThetaPointMap(orderedThetaKeys,</span>
            thetaPointMap,
<span class="fc" id="L1575">            Math.round(fracFreqLimit * maxFreq));</span>

        /*
        // ----- debug ---
        // plot the points as an image to see the data first
        int[] minMaxXY = MiscMath.findMinMaxXY(peaks);
        int nPoints = 0;
        int maxX = Integer.MIN_VALUE;
        int maxY = Integer.MIN_VALUE;
        for (int i : orderedThetaKeys) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);
            if (list == null) {
                continue;
            }
            int y = list.size();
            nPoints++;
            if (key.intValue() &gt; maxX) {
                maxX = key.intValue();
            }
            if (y &gt; maxY) {
                maxY = y;
            }
        }
        float[] xPoints = new float[nPoints];
        float[] yPoints = new float[nPoints];
        int count = 0;
        for (int i : orderedThetaKeys) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);
            if (list == null) {
                continue;
            }
            int y = list.size();
            xPoints[count] = key.intValue();
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxX, 0, maxY, xPoints, yPoints, xPoints, yPoints, &quot;cieXY theta vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        // --- end debug
        */

<span class="pc bpc" id="L1625" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1627">                groupList.add(new HashSet&lt;PairInt&gt;(entry.getValue()));</span>
<span class="nc" id="L1628">            }</span>
<span class="nc" id="L1629">            groupList.add(blackPixels);</span>
<span class="nc" id="L1630">            groupList.add(whitePixels);</span>
<span class="nc" id="L1631">            return groupList;</span>
        }
<span class="fc bfc" id="L1633" title="All 2 branches covered.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="fc" id="L1634">            groupList.add(new HashSet&lt;PairInt&gt;());</span>
        }

        /* traverse in ordered manner thetaPointMap to compare to current theta position
           w.r.t. peaks
           then place it in the groupsList.
           points before the first peak are compared with last peak too for wrap around.
        */
<span class="fc" id="L1642">        int currentPeakIdx = -1;</span>
<span class="fc bfc" id="L1643" title="All 2 branches covered.">        for (int i : orderedThetaKeys) {</span>
<span class="fc" id="L1644">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L1645">            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="fc bfc" id="L1646" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L1647">                continue;</span>
            }
<span class="fc" id="L1649">            int idx = -1;</span>
<span class="fc bfc" id="L1650" title="All 4 branches covered.">            if ((currentPeakIdx == -1) || (currentPeakIdx == (peaks.getN() - 1))) {</span>
                int diffL, diffF;
<span class="fc bfc" id="L1652" title="All 2 branches covered.">                if (currentPeakIdx == -1) {</span>
<span class="fc" id="L1653">                    diffL = key.intValue() + 360 - peaks.getX(peaks.getN() - 1);</span>
<span class="fc" id="L1654">                    diffF = peaks.getX(0) - key.intValue();</span>
<span class="fc bfc" id="L1655" title="All 2 branches covered.">                    if (diffF == 0) {</span>
<span class="fc" id="L1656">                        currentPeakIdx = 0;</span>
                    }
                } else {
<span class="fc" id="L1659">                    diffL = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L1660">                    diffF = peaks.getX(0) + 360 - key.intValue();</span>
                }
<span class="fc bfc" id="L1662" title="All 2 branches covered.">                if (diffL &lt; diffF) {</span>
<span class="fc" id="L1663">                    idx = peaks.getN() - 1;</span>
<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">                } else if (diffL == diffF) {</span>
<span class="nc" id="L1665">                    int freqL = peaks.getY(peaks.getN() - 1);</span>
<span class="nc" id="L1666">                    int freqF = peaks.getY(0);</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">                    if (freqL &lt; freqF) {</span>
<span class="nc" id="L1668">                        idx = peaks.getN() - 1;</span>
                    } else {
<span class="nc" id="L1670">                        idx = 0;</span>
                    }
<span class="nc" id="L1672">                } else {</span>
<span class="fc" id="L1673">                    idx = 0;</span>
                }
<span class="fc" id="L1675">            } else {</span>
                // this has to update currentPeakIdx
<span class="fc" id="L1677">                int diffP = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L1678">                int diffN = peaks.getX(currentPeakIdx + 1) - key.intValue();</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">                if (diffN == 0) {</span>
<span class="fc" id="L1680">                    currentPeakIdx++;</span>
<span class="fc" id="L1681">                    idx = currentPeakIdx;</span>
                } else {
<span class="fc bfc" id="L1683" title="All 2 branches covered.">                    if (diffP &lt; diffN) {</span>
<span class="fc" id="L1684">                        idx = currentPeakIdx;</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">                    } else if (diffP == diffN) {</span>
<span class="fc" id="L1686">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="fc" id="L1687">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="fc bfc" id="L1688" title="All 2 branches covered.">                        if (freqP &lt; freqN) {</span>
<span class="fc" id="L1689">                            idx = currentPeakIdx;</span>
                        } else {
<span class="fc" id="L1691">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="fc" id="L1693">                    } else {</span>
<span class="fc" id="L1694">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L1698" title="3 of 4 branches missed.">            assert(idx != -1);</span>
<span class="fc" id="L1699">            groupList.get(idx).addAll(list);</span>
        }

<span class="fc" id="L1702">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList,</span>
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
        /*if (!blackPixels.isEmpty()) {
            groupList.add(blackPixels);
        }
        if (!whitePixels.isEmpty()) {
            groupList.add(whitePixels);
        }

        int nTot2 = 0;
        for (Set&lt;PairInt&gt; groups : groupList) {
            nTot2 += groups.size();
        }

        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot2=&quot; + nTot2);
        assert(nTot2 == input.getNPixels());
        */
<span class="fc" id="L1721">        return groupList;</span>
    }

    private Map&lt;Integer, List&lt;PairInt&gt;&gt; createThetaCIEXYMap(Set&lt;PairInt&gt;
        points0, ImageExt input, double minTheta, double thetaFactor,
        double[] outputMinMaxTheta, int[] outputMinMaxFreq) {

<span class="nc" id="L1728">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // key = theta, value = pixels having that key
<span class="nc" id="L1731">        Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap = new HashMap&lt;Integer, List&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L1733">        double minTheta0 = minTheta;</span>
<span class="nc" id="L1734">        outputMinMaxTheta[0] = Double.MIN_VALUE;</span>
<span class="nc" id="L1735">        outputMinMaxTheta[1] = Double.MAX_VALUE;</span>

<span class="nc bnc" id="L1737" title="All 2 branches missed.">        for (PairInt p : points0) {</span>

<span class="nc" id="L1739">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>

<span class="nc" id="L1741">            float cx = input.getCIEX(idx);</span>
<span class="nc" id="L1742">            float cy = input.getCIEY(idx);</span>

<span class="nc" id="L1744">            double theta = thetaFactor * (</span>
<span class="nc" id="L1745">                (cieC.calculateXYTheta(cx, cy)*180./Math.PI) - minTheta0);</span>

<span class="nc" id="L1747">            Integer thetaCIEXY = Integer.valueOf((int)Math.round(theta));</span>

<span class="nc" id="L1749">            List&lt;PairInt&gt; list = thetaPointMap.get(thetaCIEXY);</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L1751">                list = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L1752">                thetaPointMap.put(thetaCIEXY, list);</span>
            }
<span class="nc" id="L1754">            list.add(p);</span>

<span class="nc bnc" id="L1756" title="All 2 branches missed.">            if (theta &lt; outputMinMaxTheta[0]) {</span>
<span class="nc" id="L1757">                outputMinMaxTheta[0] = theta;</span>
            }
<span class="nc bnc" id="L1759" title="All 2 branches missed.">            if (theta &gt; outputMinMaxTheta[1]) {</span>
<span class="nc" id="L1760">                outputMinMaxTheta[1] = theta;</span>
            }
<span class="nc" id="L1762">        }</span>

<span class="nc" id="L1764">        outputMinMaxFreq[0] = Integer.MAX_VALUE;</span>
<span class="nc" id="L1765">        outputMinMaxFreq[1] = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1767">            int count = entry.getValue().size();</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">            if (count &lt; outputMinMaxFreq[0]) {</span>
<span class="nc" id="L1769">                outputMinMaxFreq[0] = count;</span>
            }
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            if (count &gt; outputMinMaxFreq[1]) {</span>
<span class="nc" id="L1772">                outputMinMaxFreq[1] = count;</span>
            }
<span class="nc" id="L1774">        }</span>

<span class="nc" id="L1776">        return thetaPointMap;</span>
    }

    private List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
    List&lt;PairIntWithIndex&gt;&gt;&gt; partitionIntoFrequencyMaps(
    ImageExt input, Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap,
    float[] partitionFreqFracs, int maxFreq) {

        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            List&lt;PairIntWithIndex&gt;&gt;&gt;
<span class="nc" id="L1786">            mapsList =</span>
                new ArrayList&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
                List&lt;PairIntWithIndex&gt;&gt;&gt;();

<span class="nc" id="L1790">        int nMaps = partitionFreqFracs.length + 1;</span>

<span class="nc bnc" id="L1792" title="All 2 branches missed.">        for (int i = 0; i &lt; nMaps; ++i) {</span>
<span class="nc" id="L1793">            mapsList.add(</span>
                new HashMap&lt;com.climbwithyourfeet.clustering.util.PairInt,
                List&lt;PairIntWithIndex&gt;&gt;());
        }

<span class="nc" id="L1798">        final int[] partitionFreqs = new int[partitionFreqFracs.length];</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">        for (int i = 0; i &lt; partitionFreqs.length; ++i) {</span>
<span class="nc" id="L1800">            partitionFreqs[i] = Math.round(partitionFreqFracs[i]*maxFreq);</span>
        }

<span class="nc" id="L1803">        int[] maxXY = new int[2];</span>
<span class="nc" id="L1804">        Arrays.fill(maxXY, Integer.MIN_VALUE);</span>

<span class="nc bnc" id="L1806" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>

<span class="nc" id="L1808">            Integer theta = entry.getKey();</span>

<span class="nc" id="L1810">            int count = entry.getValue().size();</span>

<span class="nc" id="L1812">            List&lt;PairIntWithIndex&gt; list = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">            for (PairInt p : entry.getValue()) {</span>
<span class="nc" id="L1814">                int pixIdx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="nc" id="L1815">                PairIntWithIndex p2 = new PairIntWithIndex(theta.intValue(),</span>
                    count, pixIdx);
<span class="nc" id="L1817">                list.add(p2);</span>
<span class="nc" id="L1818">            }</span>

<span class="nc" id="L1820">            int n = partitionFreqs.length;</span>
<span class="nc" id="L1821">            int idx = 0;</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">                    if (count &lt; partitionFreqs[0]) {</span>
<span class="nc" id="L1825">                        idx = 0;</span>
<span class="nc" id="L1826">                        break;</span>
                    }
<span class="nc bnc" id="L1828" title="All 4 branches missed.">                } else if ((i == (n - 1)) &amp;&amp; count &gt;= partitionFreqs[i]) {</span>
<span class="nc" id="L1829">                    idx = n;// one past partitions is last list bin</span>
<span class="nc" id="L1830">                    break;</span>
                } else {
<span class="nc bnc" id="L1832" title="All 4 branches missed.">                    if ((count &gt;= partitionFreqs[i - 1]) &amp;&amp; (count &lt; partitionFreqs[i])) {</span>
<span class="nc" id="L1833">                        idx = i;</span>
<span class="nc" id="L1834">                        break;</span>
                    }
                }
            }

            // this is unique to all maps, not stomping on existing key
<span class="nc" id="L1840">            mapsList.get(idx).put(</span>
                new com.climbwithyourfeet.clustering.util.PairInt(
<span class="nc" id="L1842">                    theta.intValue(), count), list);</span>

<span class="nc bnc" id="L1844" title="All 2 branches missed.">            if (theta.intValue() &gt; maxXY[0]) {</span>
<span class="nc" id="L1845">                maxXY[0] = theta.intValue();</span>
            }
<span class="nc bnc" id="L1847" title="All 2 branches missed.">            if (count &gt; maxXY[1]) {</span>
<span class="nc" id="L1848">                maxXY[1] = count;</span>
            }
<span class="nc" id="L1850">        }</span>

        // ----- temporary print of all pixels -------
        // ----- debug ---
<span class="nc" id="L1854">        GreyscaleImage img = new GreyscaleImage(maxXY[0] + 1, maxXY[1] + 1);</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">        for (int i = 0; i &lt; mapsList.size(); ++i) {</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">            for (com.climbwithyourfeet.clustering.util.PairInt p : mapsList.get(i).keySet()) {</span>
<span class="nc" id="L1857">                img.setValue(p.getX(), p.getY(), 255);</span>
<span class="nc" id="L1858">            }</span>
        }
        try {
<span class="nc" id="L1861">            ImageIOHelper.writeOutputImage(</span>
<span class="nc" id="L1862">                ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt2_input.png&quot;, img);</span>
<span class="nc" id="L1863">        } catch (IOException ex) {</span>
<span class="nc" id="L1864">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="nc" id="L1866">        }</span>
        // --- end debug

<span class="nc" id="L1869">        return mapsList;</span>
    }

    private void rescaleKeys(
        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            List&lt;PairIntWithIndex&gt;&gt;&gt; thetaFreqMaps, int scaleTo) {

        // --- can remove the count after debugging ----
<span class="nc" id="L1877">        int nTotBefore = 0;</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1880" title="All 2 branches missed.">                List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMaps.get(i).entrySet()) {</span>
<span class="nc" id="L1881">                nTotBefore += entry.getValue().size();</span>
<span class="nc" id="L1882">            }</span>
        }

<span class="nc bnc" id="L1885" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>

            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1888">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap = thetaFreqMaps.get(i);</span>

<span class="nc" id="L1890">            int[] minMax = findMinMaxOfKeyYs(thetaFreqMap.keySet());</span>

            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1893">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap2 = rescaleKeyYs(</span>
                    thetaFreqMap, scaleTo, minMax);

<span class="nc" id="L1896">            thetaFreqMaps.set(i, thetaFreqMap2);</span>
        }

        // --- can remove the count after debugging ----
<span class="nc" id="L1900">        int nTotAfter = 0;</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1903" title="All 2 branches missed.">                List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMaps.get(i).entrySet()) {</span>
<span class="nc" id="L1904">                nTotAfter += entry.getValue().size();</span>
<span class="nc" id="L1905">            }</span>
        }
<span class="nc bnc" id="L1907" title="All 4 branches missed.">        assert(nTotBefore == nTotAfter);</span>
<span class="nc" id="L1908">    }</span>

    private int[] findMinMaxOfKeyYs(
        Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; keySet) {

<span class="nc" id="L1913">        int min = Integer.MAX_VALUE;</span>
<span class="nc" id="L1914">        int max = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L1916" title="All 2 branches missed.">        for (com.climbwithyourfeet.clustering.util.PairInt p : keySet) {</span>
<span class="nc" id="L1917">            int y = p.getY();</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">            if (y &lt; min) {</span>
<span class="nc" id="L1919">                min = y;</span>
            }
<span class="nc bnc" id="L1921" title="All 2 branches missed.">            if (y &gt; max) {</span>
<span class="nc" id="L1922">                max = y;</span>
            }
<span class="nc" id="L1924">        }</span>
<span class="nc" id="L1925">        return new int[]{min, max};</span>
    }

    private Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
    List&lt;PairIntWithIndex&gt;&gt; rescaleKeyYs(
    Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
    List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap, final int scaleTo, final int[] minMaxY) {

        Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1934">            List&lt;PairIntWithIndex&gt;&gt; scaledMap</span>
            = new HashMap&lt;com.climbwithyourfeet.clustering.util.PairInt,
                List&lt;PairIntWithIndex&gt;&gt;();

<span class="nc bnc" id="L1938" title="All 2 branches missed.">        if ((minMaxY[1] - minMaxY[0]) == 0) {</span>
<span class="nc" id="L1939">            return thetaFreqMap;</span>
        }

<span class="nc" id="L1942">        float factor = scaleTo/(minMaxY[1] - minMaxY[0]);</span>

        for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1945" title="All 2 branches missed.">            List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMap.entrySet()) {</span>

<span class="nc" id="L1947">            com.climbwithyourfeet.clustering.util.PairInt p = entry.getKey();</span>

<span class="nc" id="L1949">            int y = Math.round(factor * (p.getY() - minMaxY[0]));</span>

<span class="nc" id="L1951">            com.climbwithyourfeet.clustering.util.PairInt p2 = new</span>
<span class="nc" id="L1952">                com.climbwithyourfeet.clustering.util.PairInt(p.getX(), y);</span>

<span class="nc" id="L1954">            scaledMap.put(p2, entry.getValue());</span>
<span class="nc" id="L1955">        }</span>

<span class="nc" id="L1957">        return scaledMap;</span>
    }

    private int[] findMaxXY(Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;
        keySet) {

<span class="nc" id="L1963">        int maxX = Integer.MIN_VALUE;</span>
<span class="nc" id="L1964">        int maxY = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L1966" title="All 2 branches missed.">        for (com.climbwithyourfeet.clustering.util.PairInt p : keySet) {</span>
<span class="nc" id="L1967">            int x = p.getX();</span>
<span class="nc" id="L1968">            int y = p.getY();</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            if (x &gt; maxX) {</span>
<span class="nc" id="L1970">                maxX = x;</span>
            }
<span class="nc bnc" id="L1972" title="All 2 branches missed.">            if (y &gt; maxY) {</span>
<span class="nc" id="L1973">                maxY = y;</span>
            }
<span class="nc" id="L1975">        }</span>
<span class="nc" id="L1976">        return new int[]{maxX, maxY};</span>
    }

    private Map&lt;Integer, Collection&lt;PairInt&gt;&gt; createThetaCIEXYMap(Set&lt;PairInt&gt;
        points, ImageExt input, int binWidth) {

<span class="fc" id="L1982">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // key = theta, value = pixels having that key
<span class="fc" id="L1985">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="fc bfc" id="L1987" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L1989">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>

<span class="fc" id="L1991">            float cx = input.getCIEX(idx);</span>
<span class="fc" id="L1992">            float cy = input.getCIEY(idx);</span>

<span class="fc" id="L1994">            double thetaRadians = cieC.calculateXYTheta(cx, cy);</span>
<span class="fc" id="L1995">            double theta = thetaRadians * 180./Math.PI;</span>

<span class="fc" id="L1997">            int thetaCIEXY = (int)Math.round(theta);</span>

<span class="fc" id="L1999">            Integer binKey = Integer.valueOf(thetaCIEXY/binWidth);</span>

<span class="fc" id="L2001">            Collection&lt;PairInt&gt; list = thetaPointMap.get(binKey);</span>
<span class="fc bfc" id="L2002" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L2003">                list = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L2004">                thetaPointMap.put(binKey, list);</span>
            }
<span class="fc" id="L2006">            list.add(p);</span>
<span class="fc" id="L2007">        }</span>

<span class="fc" id="L2009">        return thetaPointMap;</span>
    }

    /**
     * find peaks in the theta point map above lower limit.
     * @param orderedThetaKeys
     * @param thetaPointMap
     * @param limit
     * @return
     */
    protected PairIntArray findPeaksInThetaPointMap(final int[] orderedThetaKeys,
        final Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap, final int limit) {

<span class="fc" id="L2022">        int lastKey = -1;</span>
<span class="fc" id="L2023">        int lastValue = -1;</span>
<span class="fc" id="L2024">        boolean isIncr = false;</span>
<span class="fc" id="L2025">        PairIntArray peaks = new PairIntArray();</span>
<span class="fc" id="L2026">        int nInMap = 0;</span>
<span class="fc bfc" id="L2027" title="All 2 branches covered.">        for (int i : orderedThetaKeys) {</span>
<span class="fc" id="L2028">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L2029">            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="fc bfc" id="L2030" title="All 2 branches covered.">            if (list == null) {</span>
<span class="pc bpc" id="L2031" title="1 of 6 branches missed.">                if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
<span class="nc" id="L2032">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="fc" id="L2034">                lastKey = key.intValue();</span>
<span class="fc" id="L2035">                lastValue = 0;</span>
<span class="fc" id="L2036">                isIncr = false;</span>
<span class="fc" id="L2037">                continue;</span>
            }
<span class="fc" id="L2039">            int count = list.size();</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">            if (nInMap == 1) {</span>
<span class="fc bfc" id="L2041" title="All 2 branches covered.">                if (count &gt; lastValue) {</span>
<span class="fc" id="L2042">                    isIncr = true;</span>
                } else {
<span class="fc bfc" id="L2044" title="All 2 branches covered.">                    if (lastValue &gt; limit) {</span>
<span class="fc" id="L2045">                        peaks.add(lastKey, lastValue);</span>
                    }
<span class="fc" id="L2047">                    isIncr = false;</span>
                }
<span class="fc bfc" id="L2049" title="All 2 branches covered.">            } else if (nInMap != 0) {</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">                if (isIncr) {</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">                    if (count &lt; lastValue) {</span>
<span class="fc bfc" id="L2052" title="All 2 branches covered.">                        if (lastValue &gt; limit) {</span>
<span class="fc" id="L2053">                            peaks.add(lastKey, lastValue);</span>
                        }
<span class="fc" id="L2055">                        isIncr = false;</span>
                    }
                } else {
<span class="fc bfc" id="L2058" title="All 2 branches covered.">                    if (count &gt; lastValue) {</span>
<span class="fc" id="L2059">                        isIncr = true;</span>
                    }
                }
            }
<span class="fc" id="L2063">            lastValue = count;</span>
<span class="fc" id="L2064">            lastKey = key.intValue();</span>
<span class="fc" id="L2065">            nInMap++;</span>
        }
<span class="pc bpc" id="L2067" title="2 of 6 branches missed.">        if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
            //checking value at theta=0 to make sure this is a peak
<span class="fc" id="L2069">            Integer key = orderedThetaKeys[0];</span>
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">            if (key.intValue() == 0) {</span>
<span class="nc" id="L2071">                Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">                if (list == null) {</span>
<span class="nc" id="L2073">                    peaks.add(lastKey, lastValue);</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">                } else if (list.size() &lt; lastValue) {</span>
<span class="nc" id="L2075">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="nc" id="L2077">            } else {</span>
<span class="fc" id="L2078">                peaks.add(lastKey, lastValue);</span>
            }
        }

<span class="fc" id="L2082">        return peaks;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; groupByPeaks(
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {

<span class="fc" id="L2088">        int nTot = 0;</span>
<span class="fc" id="L2089">        int minKey = Integer.MAX_VALUE;</span>
<span class="fc" id="L2090">        int maxKey = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L2092">            int key = entry.getKey().intValue();</span>
<span class="fc bfc" id="L2093" title="All 2 branches covered.">            if (key &lt; minKey) {</span>
<span class="fc" id="L2094">                minKey = key;</span>
            }
<span class="fc bfc" id="L2096" title="All 2 branches covered.">            if (key &gt; maxKey) {</span>
<span class="fc" id="L2097">                maxKey = key;</span>
            }
<span class="fc" id="L2099">            nTot += entry.getValue().size();</span>
<span class="fc" id="L2100">        }</span>

<span class="fc" id="L2102">        int binWidth = 8;</span>
<span class="fc" id="L2103">        greyPixelMap = binByKeys(greyPixelMap, minKey, maxKey, binWidth);</span>

<span class="fc" id="L2105">        int nTot2 = 0;</span>
<span class="fc" id="L2106">        minKey = Integer.MAX_VALUE;</span>
<span class="fc" id="L2107">        maxKey = Integer.MIN_VALUE;</span>
<span class="fc" id="L2108">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L2109" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L2110">            int key = entry.getKey().intValue();</span>
<span class="fc bfc" id="L2111" title="All 2 branches covered.">            if (key &lt; minKey) {</span>
<span class="fc" id="L2112">                minKey = key;</span>
            }
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">            if (key &gt; maxKey) {</span>
<span class="fc" id="L2115">                maxKey = key;</span>
            }
<span class="fc" id="L2117">            int y = entry.getValue().size();</span>
<span class="fc bfc" id="L2118" title="All 2 branches covered.">            if (y &gt; maxFreq) {</span>
<span class="fc" id="L2119">                maxFreq = y;</span>
            }

<span class="fc" id="L2122">            nTot2 += y;</span>
<span class="fc" id="L2123">        }</span>
<span class="pc bpc" id="L2124" title="3 of 4 branches missed.">        assert(nTot == nTot2);</span>

<span class="fc" id="L2126">        int count = 0;</span>

        /*
        // --- debug
        float[] xPoints = new float[greyPixelMap.size()];
        float[] yPoints = new float[greyPixelMap.size()];
        for (int i = minKey; i &lt;= maxKey; ++i) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; set = greyPixelMap.get(key);
            if (set == null) {
                continue;
            }
            int y = set.size();
            xPoints[count] = key.intValue();
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxKey, 0, maxFreq, xPoints, yPoints, xPoints, yPoints, &quot;grey avgRGB vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_grey_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        // --- end debug
        */

<span class="fc" id="L2155">        final int[] orderedKeys = new int[maxKey - minKey + 1];</span>
<span class="fc" id="L2156">        count = 0;</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>
<span class="fc" id="L2158">            orderedKeys[count] = i;</span>
<span class="fc" id="L2159">            count++;</span>
        }
<span class="fc" id="L2161">        int limit = (int)(0.03 * maxFreq);</span>
<span class="fc" id="L2162">        PairIntArray peaks = findPeaksInThetaPointMap(orderedKeys, greyPixelMap, limit);</span>

        // if there are several peaks within small range of keys, that's noise,
        // so removing them
<span class="fc" id="L2166">        filterPeaksIfNoisey(peaks);</span>

        // ---- gather points in greyPixelMap into groups around the peaks ----
<span class="fc" id="L2169">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(orderedKeys.length + 1);</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="fc" id="L2171">            groupList.add(new HashSet&lt;PairInt&gt;());</span>
        }

<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc" id="L2175">            return groupList;</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">        } else if (peaks.getN() == 1) {</span>
<span class="fc bfc" id="L2177" title="All 2 branches covered.">            for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L2178">                Collection&lt;PairInt&gt; set = entry.getValue();</span>
<span class="fc" id="L2179">                groupList.get(0).addAll(set);</span>
<span class="fc" id="L2180">            }</span>
<span class="fc" id="L2181">            return groupList;</span>
        }

<span class="fc" id="L2184">        int currentPeakIdx = -1;</span>
<span class="fc bfc" id="L2185" title="All 2 branches covered.">        for (int i : orderedKeys) {</span>
<span class="fc" id="L2186">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L2187">            Collection&lt;PairInt&gt; set = greyPixelMap.get(key);</span>
<span class="pc bpc" id="L2188" title="1 of 2 branches missed.">            if (set == null) {</span>
<span class="nc" id="L2189">                continue;</span>
            }
<span class="fc" id="L2191">            int idx = -1;</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">            if (currentPeakIdx == -1) {</span>
<span class="fc" id="L2193">                currentPeakIdx = 0;</span>
<span class="fc" id="L2194">                idx = 0;</span>
<span class="fc bfc" id="L2195" title="All 2 branches covered.">            } else if (currentPeakIdx == (peaks.getN() - 1)) {</span>
<span class="fc" id="L2196">                idx = currentPeakIdx;</span>
            } else {
                // this has to update currentPeakIdx
<span class="fc" id="L2199">                int diffP = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L2200">                int diffN = peaks.getX(currentPeakIdx + 1) - key.intValue();</span>
<span class="fc bfc" id="L2201" title="All 2 branches covered.">                if (diffN == 0) {</span>
<span class="fc" id="L2202">                    currentPeakIdx++;</span>
<span class="fc" id="L2203">                    idx = currentPeakIdx;</span>
                } else {
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                    if (diffP &lt; diffN) {</span>
<span class="fc" id="L2206">                        idx = currentPeakIdx;</span>
<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">                    } else if (diffP == diffN) {</span>
<span class="nc" id="L2208">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="nc" id="L2209">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">                        if (freqP &lt; freqN) {</span>
<span class="nc" id="L2211">                            idx = currentPeakIdx;</span>
                        } else {
<span class="nc" id="L2213">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="nc" id="L2215">                    } else {</span>
<span class="fc" id="L2216">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L2220" title="3 of 4 branches missed.">            assert(idx != -1);</span>
<span class="fc" id="L2221">            groupList.get(idx).addAll(set);</span>
        }

        // ----- debug ----
<span class="fc" id="L2225">        int nTot3 = 0;</span>
<span class="fc bfc" id="L2226" title="All 2 branches covered.">        for (Collection&lt;PairInt&gt; set : groupList) {</span>
<span class="fc" id="L2227">            nTot3 += set.size();</span>
<span class="fc" id="L2228">        }</span>
<span class="pc bpc" id="L2229" title="3 of 4 branches missed.">        assert(nTot == nTot3);</span>
        // ----- end debug -----

<span class="fc" id="L2232">        return groupList;</span>
    }

    private Map&lt;Integer, Collection&lt;PairInt&gt;&gt; binByKeys(
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap,
        int minKey, int maxKey, int binWidth) {

<span class="fc" id="L2239">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; map2</span>
            = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();

<span class="fc bfc" id="L2242" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>

<span class="fc" id="L2244">            Integer key = Integer.valueOf(i);</span>

<span class="fc" id="L2246">            Collection&lt;PairInt&gt; c = greyPixelMap.get(key);</span>

<span class="fc bfc" id="L2248" title="All 2 branches covered.">            if (c == null) {</span>
<span class="fc" id="L2249">                continue;</span>
            }

<span class="fc" id="L2252">            Integer binKey = Integer.valueOf(i/binWidth);</span>

<span class="fc" id="L2254">            Collection&lt;PairInt&gt; c2 = map2.get(binKey);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">            if (c2 == null) {</span>
<span class="fc" id="L2256">                c2 = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2257">                map2.put(binKey, c2);</span>
            }
<span class="fc" id="L2259">            c2.addAll(c);</span>
        }

<span class="fc" id="L2262">        return map2;</span>
    }

    private void filterPeaksIfNoisey(PairIntArray peaks) {

<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc" id="L2268">            return;</span>
        }

<span class="fc" id="L2271">        int sumDeltaX = 0;</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">        for (int i = (peaks.getN() - 1); i &gt; 0; --i) {</span>
<span class="fc" id="L2273">            sumDeltaX += (peaks.getX(i) - peaks.getX(i - 1));</span>
        }
        //TODO: this may need to be revised:
        // if there are more than 1 peaks per delta x of 5 or so, re-bin by 4
<span class="fc" id="L2277">        float deltaX = (float)sumDeltaX/((float)peaks.getN() - 1);</span>
<span class="fc bfc" id="L2278" title="All 2 branches covered.">        if (deltaX &lt; 5) {</span>
            // re-bin by 4
<span class="fc" id="L2280">            PairIntArray peaks2 = new PairIntArray();</span>
<span class="fc bfc" id="L2281" title="All 2 branches covered.">            for (int i = 0; i &lt; peaks.getN(); i += 4) {</span>
<span class="fc" id="L2282">                int sumX = 0;</span>
<span class="fc" id="L2283">                int sumY = 0;</span>
<span class="fc" id="L2284">                int count = 0;</span>
<span class="fc bfc" id="L2285" title="All 2 branches covered.">                for (int j = i; j &lt; (i + 5); ++j) {</span>
<span class="fc" id="L2286">                    sumX += peaks.getX(i);</span>
<span class="fc" id="L2287">                    sumY += peaks.getY(i);</span>
<span class="fc" id="L2288">                    count++;</span>
                }
<span class="fc" id="L2290">                sumX = Math.round((float)sumX/(float)count);</span>
<span class="fc" id="L2291">                sumY = Math.round((float)sumY/(float)count);</span>
<span class="fc" id="L2292">                peaks2.add(sumX, sumY);</span>
            }

<span class="fc" id="L2295">            peaks.removeRange(0, peaks.getN() - 1);</span>
<span class="fc" id="L2296">            peaks.addAll(peaks2);</span>
        }

<span class="fc" id="L2299">    }</span>

    private void mergeOrAppendGreyWithOthers(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups, List&lt;Set&lt;PairInt&gt;&gt; groupList,
        Set&lt;PairInt&gt; blackPixels, Set&lt;PairInt&gt; whitePixels) {

<span class="fc" id="L2305">        Map&lt;PairInt, Integer&gt; colorPixGroupMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="fc bfc" id="L2306" title="All 2 branches covered.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="fc" id="L2307">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="fc" id="L2308">            Integer groupKey = Integer.valueOf(i);</span>
<span class="fc bfc" id="L2309" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L2310">                colorPixGroupMap.put(p, groupKey);</span>
<span class="fc" id="L2311">            }</span>
        }

        // similarity limit for a grey pixel to join adjacent color pixel's cluster
<span class="fc" id="L2315">        int limit = 40;</span>

<span class="fc" id="L2317">        int w = input.getWidth();</span>
<span class="fc" id="L2318">        int h = input.getHeight();</span>

<span class="fc" id="L2320">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L2321">        int[] dys = Misc.dy8;</span>
<span class="fc bfc" id="L2322" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; greyGroup : greyPixelGroups) {</span>

<span class="fc" id="L2324">            Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2326" title="All 2 branches covered.">            for (PairInt greyP : greyGroup) {</span>
<span class="fc" id="L2327">                int x = greyP.getX();</span>
<span class="fc" id="L2328">                int y = greyP.getY();</span>

<span class="fc" id="L2330">                int idx = input.getInternalIndex(x, y);</span>
<span class="fc" id="L2331">                int r = input.getR(idx);</span>
<span class="fc" id="L2332">                int g = input.getG(idx);</span>
<span class="fc" id="L2333">                int b = input.getB(idx);</span>

                // ---- check for color similarity ------
<span class="fc" id="L2336">                int minDiffRGB = Integer.MAX_VALUE;</span>
<span class="fc" id="L2337">                int colorClusterIdx = -1;</span>
<span class="fc" id="L2338">                int minDiffBlack = Integer.MAX_VALUE;</span>
<span class="fc" id="L2339">                int minDiffWhite = Integer.MAX_VALUE;</span>

<span class="fc bfc" id="L2341" title="All 2 branches covered.">                for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="fc" id="L2342">                    int x2 = x + dxs[i];</span>
<span class="fc" id="L2343">                    int y2 = y + dys[i];</span>
<span class="fc bfc" id="L2344" title="All 8 branches covered.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="fc" id="L2345">                        continue;</span>
                    }
<span class="fc" id="L2347">                    PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc" id="L2349">                    boolean adjIsBlack = blackPixels.contains(p2);</span>
<span class="fc" id="L2350">                    boolean adjIsWhite = whitePixels.contains(p2);</span>

<span class="fc" id="L2352">                    Integer colorClusterIndex = colorPixGroupMap.get(p2);</span>
<span class="fc bfc" id="L2353" title="All 6 branches covered.">                    if ((colorClusterIndex == null) &amp;&amp; !adjIsBlack &amp;&amp; !adjIsWhite) {</span>
<span class="fc" id="L2354">                        continue;</span>
                    }

<span class="fc" id="L2357">                    int idx2 = input.getInternalIndex(x2, y2);</span>
<span class="fc" id="L2358">                    int r2 = input.getR(idx2);</span>
<span class="fc" id="L2359">                    int g2 = input.getG(idx2);</span>
<span class="fc" id="L2360">                    int b2 = input.getB(idx2);</span>

<span class="fc" id="L2362">                    int diffR = Math.abs(r2 - r);</span>
<span class="fc" id="L2363">                    int diffG = Math.abs(g2 - g);</span>
<span class="fc" id="L2364">                    int diffB = Math.abs(b2 - b);</span>

<span class="fc" id="L2366">                    int diffRGB = diffR + diffG + diffB;</span>

<span class="fc bfc" id="L2368" title="All 2 branches covered.">                    if (adjIsBlack) {</span>
<span class="fc bfc" id="L2369" title="All 4 branches covered.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="fc" id="L2370">                            minDiffBlack = diffR;</span>
                        }
<span class="fc bfc" id="L2372" title="All 2 branches covered.">                    } else if (adjIsWhite) {</span>
<span class="fc bfc" id="L2373" title="All 4 branches covered.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="fc" id="L2374">                            minDiffWhite = diffR;</span>
                        }
                    } else {
<span class="fc bfc" id="L2377" title="All 4 branches covered.">                        if ((diffRGB &lt; minDiffRGB) &amp;&amp; (diffRGB &lt; limit)) {</span>
<span class="fc" id="L2378">                            minDiffRGB = diffRGB;</span>
<span class="pc bpc" id="L2379" title="1 of 2 branches missed.">                            colorClusterIdx = (colorClusterIndex == null) ? -1 :</span>
<span class="fc" id="L2380">                                colorClusterIndex.intValue();</span>
                        }
                    }
                }
<span class="fc bfc" id="L2384" title="All 2 branches covered.">                if (minDiffBlack &lt; 75) {</span>
<span class="fc" id="L2385">                    blackPixels.add(greyP);</span>
<span class="fc" id="L2386">                    remove.add(greyP);</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">                } else if (minDiffWhite &lt; 75) {</span>
<span class="fc" id="L2388">                    whitePixels.add(greyP);</span>
<span class="fc" id="L2389">                    remove.add(greyP);</span>
                } else {
<span class="fc bfc" id="L2391" title="All 2 branches covered.">                    if (colorClusterIdx != -1) {</span>
                        //add to color cluster and remove from grey list
<span class="fc" id="L2393">                        groupList.get(colorClusterIdx).add(greyP);</span>
<span class="fc" id="L2394">                        remove.add(greyP);</span>
                    }
                }
<span class="fc" id="L2397">            }</span>
<span class="fc bfc" id="L2398" title="All 2 branches covered.">            for (PairInt rm : remove) {</span>
<span class="fc" id="L2399">                greyGroup.remove(rm);</span>
<span class="fc" id="L2400">            }</span>
<span class="fc" id="L2401">        }</span>

        // any remaining points in the grey list should be added as sets to
        // the color pixels list now
<span class="fc bfc" id="L2405" title="All 2 branches covered.">        for (int i = 0; i &lt; greyPixelGroups.size(); ++i) {</span>
<span class="fc" id="L2406">            Set&lt;PairInt&gt; greyGroup = greyPixelGroups.get(i);</span>
<span class="fc" id="L2407">            groupList.add(greyGroup);</span>
        }
<span class="fc" id="L2409">        greyPixelGroups.clear();</span>
<span class="fc" id="L2410">    }</span>

    protected double[] findMinMaxTheta(ImageExt input, Set&lt;PairInt&gt; points0) {

<span class="fc" id="L2414">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L2416">        double[] minMaxTheta = new double[2];</span>

<span class="fc bfc" id="L2418" title="All 2 branches covered.">        for (PairInt p : points0) {</span>
<span class="fc" id="L2419">            int x = p.getX();</span>
<span class="fc" id="L2420">            int y = p.getY();</span>

<span class="fc" id="L2422">            double thetaRadians = cieC.calculateXYTheta(x, y);</span>
<span class="fc" id="L2423">            double theta = thetaRadians * 180. / Math.PI;</span>

<span class="pc bpc" id="L2425" title="1 of 2 branches missed.">            if (theta &lt; minMaxTheta[0]) {</span>
<span class="nc" id="L2426">                minMaxTheta[0] = theta;</span>
            }
<span class="fc bfc" id="L2428" title="All 2 branches covered.">            if (theta &gt; minMaxTheta[1]) {</span>
<span class="fc" id="L2429">                minMaxTheta[1] = theta;</span>
            }
<span class="fc" id="L2431">        }</span>

<span class="fc" id="L2433">        return minMaxTheta;</span>
    }

    /**
     * Find the 4 categories of point color as black, white, grey, and color.
     * CIE XY color space is used to place a pixel in the category, with the
     * additional determination of black, grey, and white intensity limits
     * using histograms within expected intensity limits.
     *
     * @param input
     * @param points0
     * @param blackPixels
     * @param whitePixels
     * @param greyPixelMap
     */
    private void populatePixelLists(ImageExt input, Set&lt;PairInt&gt; points0,
        Set&lt;PairInt&gt; blackPixels, Set&lt;PairInt&gt; whitePixels,
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {

<span class="fc" id="L2452">        int w = input.getWidth();</span>
<span class="fc" id="L2453">        int h = input.getHeight();</span>

<span class="fc" id="L2455">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // looking for limits in peaks of (r,g,b) &lt;= (45,45,45) and &gt; (191,191,191)
<span class="fc" id="L2458">        int[] whiteBlackLimits = findByHistogramLimitsForBlackAndWhite(input);</span>
        // overriding:
<span class="fc" id="L2460">        int whiteLimit = 245;</span>

<span class="fc bfc" id="L2462" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L2463" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L2465">                int idx = input.getInternalIndex(i, j);</span>

<span class="fc" id="L2467">                int r = input.getR(idx);</span>
<span class="fc" id="L2468">                int g = input.getG(idx);</span>
<span class="fc" id="L2469">                int b = input.getB(idx);</span>

<span class="fc" id="L2471">                int avg = (r + g + b)/3;</span>
<span class="fc bfc" id="L2472" title="All 2 branches covered.">                if (avg &lt;= whiteBlackLimits[0]) {</span>
<span class="fc" id="L2473">                    blackPixels.add(new PairInt(i, j));</span>
<span class="fc" id="L2474">                    continue;</span>
                }

<span class="fc" id="L2477">                float rgbTot = r + g + b;</span>
<span class="fc" id="L2478">                float bDivTot = (float)b/rgbTot;</span>
<span class="fc" id="L2479">                float rDivTot = (float)r/rgbTot;</span>
<span class="fc" id="L2480">                float gDivTot = (float)g/rgbTot;</span>

<span class="fc" id="L2482">                float cx = input.getCIEX(idx);</span>
<span class="fc" id="L2483">                float cy = input.getCIEY(idx);</span>

<span class="fc bfc" id="L2485" title="All 2 branches covered.">                if (cieC.isWhite2(cx, cy) &amp;&amp;</span>
<span class="fc bfc" id="L2486" title="All 2 branches covered.">                    (Math.abs(0.333f - bDivTot) &lt; 0.02f) &amp;&amp;</span>
<span class="fc bfc" id="L2487" title="All 2 branches covered.">                    (Math.abs(0.333f - rDivTot) &lt; 0.02f) &amp;&amp;</span>
<span class="fc bfc" id="L2488" title="All 2 branches covered.">                    (Math.abs(0.333f - gDivTot) &lt; 0.02f)) {</span>

                    //if (avg &gt; whiteBlackLimits[1]) {
<span class="fc bfc" id="L2491" title="All 6 branches covered.">                    if ((r &gt; whiteLimit) &amp;&amp; (g &gt; whiteLimit) &amp;&amp; (b &gt; whiteLimit)) {</span>
<span class="fc" id="L2492">                        whitePixels.add(new PairInt(i, j));</span>
                    } else {
<span class="fc" id="L2494">                        Integer avgRGB = Integer.valueOf(avg);</span>
<span class="fc" id="L2495">                        Collection&lt;PairInt&gt; set = greyPixelMap.get(avgRGB);</span>
<span class="fc bfc" id="L2496" title="All 2 branches covered.">                        if (set == null) {</span>
<span class="fc" id="L2497">                            set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2498">                            greyPixelMap.put(avgRGB, set);</span>
                        }
<span class="fc" id="L2500">                        set.add(new PairInt(i, j));</span>
<span class="fc" id="L2501">                    }</span>
                } else {
<span class="fc" id="L2503">                    points0.add(new PairInt(i, j));</span>
                }
            }
        }
<span class="fc" id="L2507">    }</span>

    private void mergeNoise(ImageExt input, List&lt;Set&lt;PairInt&gt;&gt; groupList) {

<span class="nc" id="L2511">        Map&lt;PairInt, Integer&gt; pixelToGroupMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="nc bnc" id="L2512" title="All 2 branches missed.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="nc" id="L2513">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L2515">                pixelToGroupMap.put(p, Integer.valueOf(i));</span>
<span class="nc" id="L2516">            }</span>
        }

<span class="nc" id="L2519">        final int w = input.getWidth();</span>
<span class="nc" id="L2520">        final int h = input.getHeight();</span>

<span class="nc" id="L2522">        int[] dxs8 = Misc.dx8;</span>
<span class="nc" id="L2523">        int[] dys8 = Misc.dy8;</span>

<span class="nc" id="L2525">        float diffLimit = 0.01f;</span>

<span class="nc bnc" id="L2527" title="All 2 branches missed.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="nc" id="L2528">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="nc" id="L2529">            Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2530" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L2531">                int x = p.getX();</span>
<span class="nc" id="L2532">                int y = p.getY();</span>
<span class="nc" id="L2533">                int idx = input.getInternalIndex(x, y);</span>

<span class="nc" id="L2535">                float cieX = input.getCIEX(idx);</span>
<span class="nc" id="L2536">                float cieY = input.getCIEY(idx);</span>

<span class="nc" id="L2538">                Integer groupIndex = pixelToGroupMap.get(p);</span>

                // key=groupIndex, value=number of pixels similar
<span class="nc" id="L2541">                Map&lt;Integer, Integer&gt; groupSimilarCount = new HashMap&lt;Integer, Integer&gt;();</span>

                // use cieXY, polar theta of cieXY, or rgb?
<span class="nc bnc" id="L2544" title="All 2 branches missed.">                for (int nIdx = 0; nIdx &lt; dxs8.length; ++nIdx) {</span>
<span class="nc" id="L2545">                    int x2 = x + dxs8[nIdx];</span>
<span class="nc" id="L2546">                    int y2 = y + dys8[nIdx];</span>
<span class="nc bnc" id="L2547" title="All 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L2548">                        continue;</span>
                    }
<span class="nc" id="L2550">                    int idx2 = input.getInternalIndex(x2, y2);</span>

<span class="nc" id="L2552">                    Integer groupIndex2 = pixelToGroupMap.get(new PairInt(x2, y2));</span>

<span class="nc bnc" id="L2554" title="All 2 branches missed.">                    if (groupIndex.intValue() == groupIndex2.intValue()) {</span>
<span class="nc" id="L2555">                        continue;</span>
                    }

<span class="nc" id="L2558">                    float cieX2 = input.getCIEX(idx2);</span>
<span class="nc" id="L2559">                    float cieY2 = input.getCIEY(idx2);</span>

<span class="nc" id="L2561">                    float diffCIEX = Math.abs(cieX2 - cieX);</span>
<span class="nc" id="L2562">                    float diffCIEY = Math.abs(cieY2 - cieY);</span>

<span class="nc bnc" id="L2564" title="All 4 branches missed.">                    if ((diffCIEX &gt; diffLimit) || (diffCIEY &gt; diffLimit)) {</span>
<span class="nc" id="L2565">                        continue;</span>
                    }

<span class="nc" id="L2568">                    Integer count = groupSimilarCount.get(groupIndex2);</span>
<span class="nc bnc" id="L2569" title="All 2 branches missed.">                    if (count == null) {</span>
<span class="nc" id="L2570">                        groupSimilarCount.put(groupIndex2, Integer.valueOf(1));</span>
                    } else {
<span class="nc" id="L2572">                        groupSimilarCount.put(groupIndex2, Integer.valueOf(count.intValue() + 11));</span>
                    }

                }
<span class="nc bnc" id="L2576" title="All 2 branches missed.">                if (groupSimilarCount.isEmpty()) {</span>
<span class="nc" id="L2577">                    continue;</span>
                }
<span class="nc bnc" id="L2579" title="All 2 branches missed.">                for (Entry&lt;Integer, Integer&gt; entry : groupSimilarCount.entrySet()) {</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                    if (entry.getValue() &gt;= 6) {</span>
                        // assign this group to pixel p
<span class="nc" id="L2582">                        pixelToGroupMap.put(p, entry.getKey());</span>
<span class="nc" id="L2583">                        remove.add(p);</span>
<span class="nc" id="L2584">                        groupList.get(entry.getKey().intValue()).add(p);</span>
<span class="nc" id="L2585">                        break;</span>
                    }
<span class="nc" id="L2587">                }</span>
<span class="nc" id="L2588">            }</span>
<span class="nc bnc" id="L2589" title="All 2 branches missed.">            for (PairInt rm : remove) {</span>
<span class="nc" id="L2590">                set.remove(rm);</span>
<span class="nc" id="L2591">            }</span>
        }
<span class="nc" id="L2593">    }</span>

    private int[] findByHistogramLimitsForBlackAndWhite(ImageExt input) {

        //looking for limits of (r,g,b) &lt;= (45,45,45) and &gt; (180,180,180)
<span class="fc" id="L2598">        int l0 = 45;</span>
<span class="fc" id="L2599">        int l0B = 70;</span>
<span class="fc" id="L2600">        int h0 = 245;</span>

<span class="fc" id="L2602">        List&lt;Integer&gt; avgL = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L2604">        List&lt;Integer&gt; avgH = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L2606" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="fc" id="L2607">            int r = input.getR(i);</span>
<span class="fc" id="L2608">            int g = input.getG(i);</span>
<span class="fc" id="L2609">            int b = input.getB(i);</span>
<span class="fc bfc" id="L2610" title="All 6 branches covered.">            if ((r &lt;= l0) &amp;&amp; (g &lt;= l0) &amp;&amp; (b &lt;= l0B)) {</span>
<span class="fc" id="L2611">                int avg = (r + g + b)/3;</span>
<span class="fc" id="L2612">                avgL.add(Integer.valueOf(avg));</span>
<span class="fc bfc" id="L2613" title="All 6 branches covered.">            } else if ((r &gt; h0) &amp;&amp; (g &gt; h0) &amp;&amp; (b &gt; h0)) {</span>
<span class="fc" id="L2614">                int avg = (r + g + b)/3;</span>
<span class="fc" id="L2615">                avgH.add(Integer.valueOf(avg));</span>
            }
        }

<span class="fc" id="L2619">        int[] limits = new int[2];</span>

<span class="fc bfc" id="L2621" title="All 2 branches covered.">        if (avgL.size() &gt; 30) {</span>
<span class="fc" id="L2622">            HistogramHolder hist = Histogram.createSimpleHistogram(avgL);</span>
<span class="pc bpc" id="L2623" title="1 of 2 branches missed.">            if (hist == null) {</span>
<span class="nc" id="L2624">                limits[0] = l0 - 1;</span>
            } else {
                /*
                try {
                    hist.plotHistogram(&quot;black pixels&quot;, &quot;black_&quot; + MiscDebug.getCurrentTimeFormatted());
                } catch (IOException ex) {
                    Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
                }
                */
<span class="fc" id="L2633">                int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="fc" id="L2634">                int lastZeroIdx = MiscMath.findLastZeroIndex(hist);</span>
<span class="pc bpc" id="L2635" title="2 of 4 branches missed.">                if ((lastZeroIdx != -1) &amp;&amp; (lastZeroIdx &lt; hist.getXHist().length)) {</span>
<span class="fc" id="L2636">                    limits[0] = Math.round(hist.getXHist()[lastZeroIdx]);</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">                } else if (yMaxIdx == -1) {</span>
<span class="nc" id="L2638">                    limits[0] = l0 - 1;</span>
                } else {
                    //limits[0] = Math.round(hist.getXHist()[indexes.get(0).intValue()]);
<span class="nc" id="L2641">                    limits[0] = Math.round(hist.getXHist()[yMaxIdx]);</span>
                }
            }
<span class="fc" id="L2644">        } else {</span>
<span class="fc" id="L2645">            limits[0] = l0 - 1;</span>
        }

<span class="fc bfc" id="L2648" title="All 2 branches covered.">        if (avgH.size() &gt; 30) {</span>

<span class="fc" id="L2650">            int[] q = ImageStatisticsHelper.getQuartiles(avgH);</span>
            /*
            HistogramHolder hist = Histogram.createSimpleHistogram(avgH);
            if (hist == null) {
                limits[1] = h0;
            } else {
                List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexes(hist, 0.1f);
                try {
                    hist.plotHistogram(&quot;hite pixels&quot;, &quot;white_&quot; + MiscDebug.getCurrentTimeFormatted());
                } catch (IOException ex) {
                    Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
                }
                if (indexes == null || indexes.isEmpty()) {
                    limits[1] = h0;
                } else {
                    limits[1] = Math.round(hist.getXHist()[indexes.get(0).intValue()]);
                }
            }
            */
<span class="fc" id="L2669">            limits[1] = q[3];</span>
<span class="fc" id="L2670">        } else {</span>
<span class="fc" id="L2671">            limits[1] = h0;</span>
        }

<span class="fc" id="L2674">        return limits;</span>
    }

    public Map&lt;PairInt, Integer&gt; calculatePolarCIEXY(ImageExt input, Set&lt;PairInt&gt; points) {

<span class="nc" id="L2679">        Map&lt;PairInt, Integer&gt; map = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc" id="L2681">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc bnc" id="L2683" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L2685">            float cieX = input.getCIEX(p.getX(), p.getY());</span>
<span class="nc" id="L2686">            float cieY = input.getCIEY(p.getX(), p.getY());</span>

<span class="nc" id="L2688">            double thetaRadians = cieC.calculateXYTheta(cieX, cieY);</span>

<span class="nc" id="L2690">            int thetaDegrees = (int)Math.round(thetaRadians * 180./Math.PI);</span>

<span class="nc" id="L2692">            map.put(p, Integer.valueOf(thetaDegrees));</span>
<span class="nc" id="L2693">        }</span>

<span class="nc" id="L2695">        return map;</span>
    }

    public float[] getValues(Map&lt;PairInt, Integer&gt; map) {
<span class="nc" id="L2699">        float[] values = new float[map.size()];</span>
<span class="nc" id="L2700">        int count = 0;</span>
<span class="nc bnc" id="L2701" title="All 2 branches missed.">        for (Entry&lt;PairInt, Integer&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L2702">            values[count] = entry.getValue().floatValue();</span>
<span class="nc" id="L2703">            count++;</span>
<span class="nc" id="L2704">        }</span>
<span class="nc" id="L2705">        return values;</span>
    }

    /**
     * NOT READY FOR USE.  STILL EXPERIMENTING.
     *
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to CIEXY Lab color space, then creates a map of the
     * CIEX and CIEY points and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters of points in CIE X, CIEY space,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * cie xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param useBlur
     */
    public void applyPolarCIEXY(ImageExt input, boolean useBlur) {

        //TODO: improve the clustering results in two ways:
        // (1) for smaller ciexy clusters, merge with adjacent clusters if
        //     similar color
        // (2) any pixel with 7 neighbors of same color should be that color too

<span class="nc bnc" id="L2737" title="All 2 branches missed.">        if (useBlur) {</span>
<span class="nc" id="L2738">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L2739">            imageProcessor.blur(input, 1.0f);</span>
        }

<span class="nc" id="L2742">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L2744">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L2746">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L2748">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L2750">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

<span class="nc" id="L2752">        Map&lt;PairInt, Integer&gt; clrPolarCIEXYMap = calculatePolarCIEXY(input, points0);</span>
<span class="nc" id="L2753">        float[] clrPolarCIEXY = getValues(clrPolarCIEXYMap);</span>
<span class="nc" id="L2754">        float binWidth = 1;</span>
<span class="nc" id="L2755">        HistogramHolder hist = Histogram.createSimpleHistogram(//binWidth,</span>
<span class="nc" id="L2756">            clrPolarCIEXY, Errors.populateYErrorsBySqrt(clrPolarCIEXY));</span>
<span class="nc" id="L2757">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist,</span>
            0.1f);
<span class="nc" id="L2759">        int[] binCenters = createBinCenters360(hist, indexes);</span>

<span class="nc" id="L2761">        List&lt;Set&lt;PairInt&gt;&gt; colorPixelGroups = assignToNearestPolarCIECluster(</span>
            clrPolarCIEXYMap, binCenters);

<span class="nc" id="L2764">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaksForGrey(input, greyPixelMap);</span>

<span class="nc" id="L2766">        ImageExt imgExt = input.copyToImageExt();</span>

<span class="nc bnc" id="L2768" title="All 2 branches missed.">        for (PairInt p : blackPixels) {</span>
<span class="nc" id="L2769">           imgExt.setRGB(p.getX(), p.getY(), 0, 0, 0);</span>
<span class="nc" id="L2770">        }</span>

<span class="nc bnc" id="L2772" title="All 2 branches missed.">        for (PairInt p : whitePixels) {</span>
<span class="nc" id="L2773">           imgExt.setRGB(p.getX(), p.getY(), 255, 255, 255);</span>
<span class="nc" id="L2774">        }</span>

<span class="nc" id="L2776">        int gClr = 255;</span>
<span class="nc" id="L2777">        int s = 127/colorPixelGroups.size();</span>
<span class="nc bnc" id="L2778" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : colorPixelGroups) {</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L2780">               imgExt.setRGB(p.getX(), p.getY(), 0, gClr, 0);</span>
<span class="nc" id="L2781">            }</span>
<span class="nc" id="L2782">            gClr -= s;</span>
<span class="nc" id="L2783">        }</span>

        /*
        int rClr = 255;
        s = 127/greyPixelMap.size();
        for (Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {
            for (PairInt p : entry.getValue()) {
                imgExt.setRGB(p.getX(), p.getY(), rClr, 0, 0);
            }
            rClr -= s;
        }
        */
<span class="nc" id="L2795">        int rClr = 255;</span>
<span class="nc" id="L2796">        s = 127/greyPixelGroups.size();</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L2799">               imgExt.setRGB(p.getX(), p.getY(), rClr, 0, 0);</span>
<span class="nc" id="L2800">            }</span>
<span class="nc" id="L2801">            rClr -= s;</span>
<span class="nc" id="L2802">        }</span>

<span class="nc" id="L2804">        input.resetTo(imgExt);</span>
<span class="nc" id="L2805">    }</span>

    private int[] createBinCenters360(HistogramHolder hist, List&lt;Integer&gt; indexes) {

<span class="nc bnc" id="L2809" title="All 2 branches missed.">        if (indexes.isEmpty()) {</span>
<span class="nc" id="L2810">            return new int[0];</span>
        }

<span class="nc" id="L2813">        int n = indexes.size();</span>

<span class="nc bnc" id="L2815" title="All 2 branches missed.">        if (n == 1) {</span>

<span class="nc" id="L2817">            int[] binCenters = new int[n + 1];</span>

            /*
            examples for n=1
                --  90
            180
                -- 270
            ----------------
                --  90-176=  360-(176-90) = 274
            4
                -- 270-176=  94
            ----------------
                --  90+(330-180)=  240
            330
                -- 270+(330-180)=  270 + 150 - 360 = 60
            */

<span class="nc" id="L2834">            int vc = Math.round(hist.getXHist()[indexes.get(0).intValue()]);</span>

<span class="nc bnc" id="L2836" title="All 2 branches missed.">            if (vc == 180) {</span>
<span class="nc" id="L2837">                binCenters[0] = 90;</span>
<span class="nc" id="L2838">                binCenters[1] = 270;</span>
<span class="nc bnc" id="L2839" title="All 2 branches missed.">            } else if (vc &lt; 180) {</span>
<span class="nc" id="L2840">                int delta = 180 - vc;</span>
<span class="nc" id="L2841">                binCenters[0] = 360 - (delta - 90);</span>
<span class="nc" id="L2842">                binCenters[1] = 270 - delta;</span>
<span class="nc" id="L2843">            } else {</span>
<span class="nc" id="L2844">                int delta = vc - 180;</span>
<span class="nc" id="L2845">                binCenters[0] = 90 + delta;</span>
<span class="nc" id="L2846">                binCenters[1] = 270 + delta - 360;</span>
            }

<span class="nc" id="L2849">            return binCenters;</span>
        }

<span class="nc" id="L2852">        int[] binCenters = new int[n];</span>

<span class="nc bnc" id="L2854" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="nc" id="L2856">            int idx = indexes.get(i);</span>

<span class="nc" id="L2858">            binCenters[i] = Math.round(hist.getXHist()[idx]);</span>
        }

<span class="nc" id="L2861">        return binCenters;</span>
    }

    private int[] createBinCenters255(HistogramHolder hist, List&lt;Integer&gt; indexes) {

<span class="pc bpc" id="L2866" title="1 of 2 branches missed.">        if (indexes.isEmpty()) {</span>
<span class="nc" id="L2867">            return new int[0];</span>
        }

<span class="fc" id="L2870">        int n = indexes.size();</span>

<span class="pc bpc" id="L2872" title="1 of 2 branches missed.">        if (n == 1) {</span>

<span class="nc" id="L2874">            int[] binCenters = new int[n + 1];</span>

<span class="nc" id="L2876">            int vc = Math.round(hist.getXHist()[indexes.get(0).intValue()]);</span>

<span class="nc" id="L2878">            binCenters[0] = vc/2;</span>
<span class="nc" id="L2879">            binCenters[1] = (255 + vc)/2;</span>

<span class="nc" id="L2881">            return binCenters;</span>
        }

<span class="fc" id="L2884">        int[] binCenters = new int[n];</span>

<span class="fc bfc" id="L2886" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="fc" id="L2888">            int idx = indexes.get(i);</span>

<span class="fc" id="L2890">            binCenters[i] = Math.round(hist.getXHist()[idx]);</span>
        }

<span class="fc" id="L2893">        return binCenters;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; groupByPeaksForGrey(ImageExt input,
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {

<span class="nc" id="L2899">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2900" title="All 2 branches missed.">        for (Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L2901">            points.addAll(entry.getValue());</span>
<span class="nc" id="L2902">        }</span>

<span class="nc" id="L2904">        Map&lt;PairInt, Integer&gt; polarCIEXYMap = calculatePolarCIEXY(input, points);</span>
<span class="nc" id="L2905">        float[] polarCIEXY = getValues(polarCIEXYMap);</span>
<span class="nc" id="L2906">        float binWidth = 1;</span>
<span class="nc" id="L2907">        HistogramHolder hist = Histogram.createSimpleHistogram(binWidth,</span>
<span class="nc" id="L2908">            polarCIEXY, Errors.populateYErrorsBySqrt(polarCIEXY));</span>
<span class="nc" id="L2909">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist,</span>
            0.1f);
<span class="nc" id="L2911">        int[] binCenters = createBinCenters360(hist, indexes);</span>

<span class="nc" id="L2913">        List&lt;Set&lt;PairInt&gt;&gt; pixelGroups = assignToNearestPolarCIECluster(</span>
            polarCIEXYMap, binCenters);

<span class="nc" id="L2916">        return pixelGroups;</span>

    }

    /**
     * a greyscale segmentation algorithm similar to the KMPP, but does not use
     * a random number generator to find seeds of intensity bins.
     * @param input
     */
    public void applyGreyscaleHistogram(GreyscaleImage input) {

<span class="nc" id="L2927">        float[] values = new float[input.getNPixels()];</span>
<span class="nc bnc" id="L2928" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="nc" id="L2929">            int v = input.getValue(i);</span>
<span class="nc" id="L2930">            values[i] = v;</span>
        }

<span class="nc" id="L2933">        int[] binCenters = determineGreyscaleBinCenters(values);</span>

<span class="nc" id="L2935">        assignToNearestCluster(input, binCenters);</span>
<span class="nc" id="L2936">    }</span>

    /**
     * a greyscale segmentation algorithm similar to the KMPP, but does not use
     * a random number generator to find seeds of intensity bins.
     *
     * @param values
     * @return
     */
    public int[] determineGreyscaleBinCenters(float[] values) {

<span class="fc" id="L2947">        float binWidth = 3;</span>
<span class="fc" id="L2948">        HistogramHolder hist = Histogram.createSimpleHistogram(0, 255, binWidth,</span>
<span class="fc" id="L2949">            values, Errors.populateYErrorsBySqrt(values));</span>
<span class="fc" id="L2950">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist, 0.05f);</span>

<span class="fc bfc" id="L2952" title="All 2 branches covered.">        if (indexes.size() &lt;= 3) {</span>
<span class="fc" id="L2953">            binWidth = 10;</span>
<span class="fc" id="L2954">            hist = Histogram.createSimpleHistogram(0, 255, binWidth,</span>
<span class="fc" id="L2955">                values, Errors.populateYErrorsBySqrt(values));</span>
<span class="fc" id="L2956">            indexes = MiscMath.findStrongPeakIndexesDescSort(hist, 0.05f);</span>

<span class="fc" id="L2958">            int k = 3;</span>
<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">            int idx = (indexes.size() &lt; k) ? indexes.size() : k;</span>
<span class="fc" id="L2960">            indexes = indexes.subList(0, idx);</span>
        }

        /*
        try {
            hist.plotHistogram(&quot;greyscale&quot;, &quot;1&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
        }*/

<span class="fc" id="L2970">        int[] binCenters = createBinCenters255(hist, indexes);</span>

<span class="fc" id="L2972">        return binCenters;</span>
    }

    /**
     * segmentation algorithm using cieXY and rgb to make pixel categories,
     * and grow lists, then histograms to rescale.
     *
     * @param input
     * @return
     */
    public GreyscaleImage createGreyscale3(ImageExt input) {

<span class="fc" id="L2984">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2986">        Map&lt;PairInt, Float&gt; colorPixelMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="fc" id="L2988">        Set&lt;PairInt&gt; unassignedPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2990">        populatePixelLists2(input, blackPixels, colorPixelMap, unassignedPixels);</span>

<span class="fc" id="L2992">        int nTotC = blackPixels.size() + colorPixelMap.size() + unassignedPixels.size();</span>
<span class="pc bpc" id="L2993" title="3 of 4 branches missed.">        assert(nTotC == input.getNPixels());</span>

        // grow black pixels from unassigned pixels if within a tolerance of rgb
<span class="fc" id="L2996">        growPixelsWithinRGBTolerance(input, blackPixels, unassignedPixels, 10);</span>

        // then grow colorPixelMap from unassignedPixels if within a tolerance of rgb
<span class="fc" id="L2999">        Set&lt;PairInt&gt; addToColor = findPixelsWithinRGBTolerance(input,</span>
<span class="fc" id="L3000">            colorPixelMap.keySet(), unassignedPixels, 10);//5</span>

        // reassign colorPixelMap to averaged color for adjacent thetas within tolerance
        // (1) try just colorPixelMap for this step
        // (2) try adding addToColor to colorPixelMap for this step
        //    Map&lt;PairInt, Float&gt; colorPixelMap2 = createPolarCIEXYMap(input, addToColor);
        //    colorPixelMap.putAll(colorPixelMap2);

<span class="fc" id="L3008">        int toleranceInValue = determineToleranceForIllumCorr(colorPixelMap, nTotC);</span>

<span class="pc bpc" id="L3010" title="2 of 4 branches missed.">        if (toleranceInValue &gt; -1 &amp;&amp; !colorPixelMap.isEmpty()) {</span>
            // use higher &gt; 1 when bp/cp2 &gt;&gt; 1
<span class="fc bfc" id="L3012" title="All 2 branches covered.">            if ((blackPixels.size()/addToColor.size()) &gt; 10) {</span>
<span class="fc" id="L3013">                correctForIllumination(input, 2, colorPixelMap);</span>
            } else {
<span class="fc" id="L3015">                correctForIllumination(input, toleranceInValue, colorPixelMap);</span>
            }
        }
/*
ImageExt tmpInput = input.copyToImageExt();
for (PairInt p : unassignedPixels) {
tmpInput.setRGB(p.getX(), p.getY(), 255, 0, 0);
}
MiscDebug.writeImage(tmpInput, &quot;_after_illumc0_unassigned_pix&quot; + MiscDebug.getCurrentTimeFormatted());
MiscDebug.writeImage(input, &quot;_after_illumc0_&quot; + MiscDebug.getCurrentTimeFormatted());
*/
<span class="fc" id="L3026">        Map&lt;PairInt, Float&gt; colorPixelMap2 = createPolarCIEXYMap(input, addToColor);</span>
<span class="pc bpc" id="L3027" title="2 of 4 branches missed.">        if (toleranceInValue &gt; -1 &amp;&amp; !colorPixelMap2.isEmpty()) {</span>
<span class="fc" id="L3028">            correctForIllumination(input, toleranceInValue, colorPixelMap2);</span>
        }
/*
tmpInput = input.copyToImageExt();
for (PairInt p : colorPixelMap2.keySet()) {
tmpInput.setRGB(p.getX(), p.getY(), 255, 0, 0);
}
MiscDebug.writeImage(tmpInput, &quot;_after2_illumc0_pix&quot; + MiscDebug.getCurrentTimeFormatted());
MiscDebug.writeImage(input, &quot;_after2_illumc0_&quot; + MiscDebug.getCurrentTimeFormatted());
*/
<span class="fc" id="L3038">        Map&lt;PairInt, Float&gt; colorPixelMap3 = createPolarCIEXYMap(input, unassignedPixels);</span>
<span class="fc" id="L3039">        toleranceInValue = determineToleranceForIllumCorr(colorPixelMap3, nTotC);</span>
<span class="pc bpc" id="L3040" title="2 of 4 branches missed.">        if (toleranceInValue &gt; -1 &amp;&amp; !colorPixelMap3.isEmpty()) {</span>
<span class="pc bpc" id="L3041" title="1 of 2 branches missed.">            if ((toleranceInValue == 1) &amp;&amp;</span>
<span class="fc bfc" id="L3042" title="All 2 branches covered.">                ((blackPixels.size()/colorPixelMap2.size()) &gt; 10)) {</span>
<span class="pc bpc" id="L3043" title="1 of 2 branches missed.">                if ((blackPixels.size()/colorPixelMap.size()) &gt; 10) {</span>
<span class="fc" id="L3044">                    toleranceInValue = 10;</span>
                } else {
<span class="nc" id="L3046">                    toleranceInValue = 2;</span>
                }
            }
<span class="fc" id="L3049">            correctForIllumination(input, toleranceInValue, colorPixelMap3);</span>
        }
/*tmpInput = input.copyToImageExt();
for (PairInt p : colorPixelMap3.keySet()) {
tmpInput.setRGB(p.getX(), p.getY(), 255, 0, 0);
}
MiscDebug.writeImage(tmpInput, &quot;_after3_illumc0_pix&quot; + MiscDebug.getCurrentTimeFormatted());
MiscDebug.writeImage(input, &quot;_after3_illumc0_&quot; + MiscDebug.getCurrentTimeFormatted());
*/
<span class="pc bpc" id="L3058" title="1 of 2 branches missed.">        if (nTotC != blackPixels.size()) {</span>
            //TODO: not sure will use this... might consider same method w/ rgb
<span class="fc" id="L3060">            toleranceInValue = 2;</span>
<span class="fc" id="L3061">            correctForIllumination(input, blackPixels, toleranceInValue);</span>
        }

<span class="fc" id="L3064">        GreyscaleImage img = input.copyToGreyscale();</span>

<span class="fc" id="L3066">        MiscDebug.writeImage(img, &quot;_before_greyscale_bins_&quot; + MiscDebug.getCurrentTimeFormatted());</span>

<span class="fc" id="L3068">        float[] cValues = new float[input.getNPixels()];</span>
<span class="fc bfc" id="L3069" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="fc" id="L3070">            int v = img.getValue(i);</span>
<span class="fc" id="L3071">            cValues[i] = v;</span>
        }

<span class="fc" id="L3074">        int[] binCenters = determineGreyscaleBinCenters(cValues);</span>

<span class="fc" id="L3076">        assignToNearestCluster(img, binCenters);</span>
<span class="fc" id="L3077">        MiscDebug.writeImage(img, &quot;_after_greyscale_bins_&quot; + MiscDebug.getCurrentTimeFormatted());</span>

<span class="fc bfc" id="L3079" title="All 2 branches covered.">        for (PairInt p : blackPixels) {</span>
<span class="fc" id="L3080">            img.setValue(p.getX(), p.getY(), 0);</span>
<span class="fc" id="L3081">        }</span>

<span class="fc" id="L3083">MiscDebug.writeImage(img, &quot;_end_seg_&quot; + MiscDebug.getCurrentTimeFormatted());</span>

<span class="fc" id="L3085">        return img;</span>
    }

    /**
     * segmentation algorithm using an a trous wavelet transform.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale5(GreyscaleImage input) {

<span class="fc" id="L3096">        ATrousWaveletTransform wt = new ATrousWaveletTransform();</span>

<span class="fc" id="L3098">        List&lt;GreyscaleImage&gt; transformed = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="fc" id="L3099">        List&lt;GreyscaleImage&gt; coeffs = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="fc" id="L3101">        boolean use1D = false;</span>
<span class="pc bpc" id="L3102" title="1 of 2 branches missed.">        if (use1D) {</span>
<span class="nc" id="L3103">            wt.calculateWithB3SplineScalingFunction(input, transformed, coeffs);</span>
        } else {
<span class="fc" id="L3105">            wt.calculateWithB3SplineScalingFunction2(input, transformed, coeffs);</span>
        }

        /*
            for (int i = 0; i &lt; coeffs.size(); ++i) {
                GreyscaleImage img = coeffs.get(i);
                String str = &quot;coeff_&quot; + Integer.toString(i) + &quot;_&quot; +
                    MiscDebug.getCurrentTimeFormatted();
                MiscDebug.writeImage(img, str);
            }
        */

<span class="fc" id="L3117">        GreyscaleImage coarsestCoeff = coeffs.get(coeffs.size() - 1);</span>
        
<span class="pc bpc" id="L3119" title="1 of 2 branches missed.">        int limit = use1D ? 2 : 1;</span>

<span class="fc bfc" id="L3121" title="All 2 branches covered.">        for (int i = 0; i &lt; coarsestCoeff.getNPixels(); ++i) {</span>
<span class="fc bfc" id="L3122" title="All 2 branches covered.">            if (coarsestCoeff.getValue(i) &gt; limit) {</span>
<span class="fc" id="L3123">                coarsestCoeff.setValue(i, 250);</span>
            } else {
<span class="fc" id="L3125">                coarsestCoeff.setValue(i, 0);</span>
            }
        }

<span class="fc" id="L3129">        return coarsestCoeff;</span>
    }

    /**
     * segmentation algorithm using Canny Edges.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale6(GreyscaleImage input) {

<span class="nc" id="L3140">        CannyEdgeFilter filter = new CannyEdgeFilter();</span>
<span class="nc" id="L3141">        filter.applyFilter(input.copyImage());</span>

<span class="nc" id="L3143">        double thresh = filter.getLowThresholdApplied2Layer() + 2;</span>

<span class="nc" id="L3145">        GreyscaleImage img = filter.getEdgeFilterProducts().getGradientXY();</span>

<span class="nc bnc" id="L3147" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc bnc" id="L3148" title="All 2 branches missed.">            if (img.getValue(i) &gt; thresh) {</span>
<span class="nc" id="L3149">                img.setValue(i, 250);</span>
            } else {
<span class="nc" id="L3151">                img.setValue(i, 0);</span>
            }
        }

<span class="nc" id="L3155">        return img;</span>
    }
    
    /**
     * segmentation algorithm using cieXY and rgb to make segmentation for
     * the colors with CIE X or Y outside of the center region 
     *
     * @param input
     * @return
     */
    public GreyscaleImage createGreyscale7(ImageExt input) {

<span class="nc" id="L3167">        Map&lt;PairInt, Integer&gt; pixelThetaDegreesMap = populatePixelLists3(input);</span>
        
        // -- scale the valus to between 0 and 255 w/ wrap around --
        
<span class="nc" id="L3171">        int count = 0;</span>
<span class="nc" id="L3172">        float[] clrPolarCIEXY =new float[pixelThetaDegreesMap.size()];</span>
<span class="nc bnc" id="L3173" title="All 2 branches missed.">        for (Entry&lt;PairInt, Integer&gt; entry : pixelThetaDegreesMap.entrySet()) {</span>
<span class="nc" id="L3174">            clrPolarCIEXY[count] = entry.getValue();</span>
<span class="nc" id="L3175">            count++;</span>
<span class="nc" id="L3176">        }</span>
        
<span class="nc" id="L3178">        float binWidth = 20;</span>
<span class="nc" id="L3179">        HistogramHolder hist = Histogram.createSimpleHistogram(binWidth,</span>
<span class="nc" id="L3180">            clrPolarCIEXY, Errors.populateYErrorsBySqrt(clrPolarCIEXY));</span>
<span class="nc" id="L3181">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist, 0.1f);</span>
<span class="nc" id="L3182">        int[] binCenters = createBinCenters360(hist, indexes);</span>
        
<span class="nc" id="L3184">        List&lt;Set&lt;PairInt&gt;&gt; colorPixelGroups = assignToNearestPolarCIECluster(</span>
            pixelThetaDegreesMap, binCenters);
        
<span class="nc" id="L3187">        GreyscaleImage img = new GreyscaleImage(input.getWidth(), </span>
<span class="nc" id="L3188">            input.getHeight());</span>
        
<span class="nc" id="L3190">        int gClr = 255;</span>
<span class="nc" id="L3191">        int s = 127/colorPixelGroups.size();</span>
<span class="nc bnc" id="L3192" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : colorPixelGroups) {</span>
<span class="nc bnc" id="L3193" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L3194">               img.setValue(p.getX(), p.getY(), gClr);</span>
<span class="nc" id="L3195">            }</span>
<span class="nc" id="L3196">            gClr -= s;</span>
<span class="nc" id="L3197">        }</span>
        
<span class="nc" id="L3199">MiscDebug.writeImage(img, &quot;_seg_gs7_&quot; + MiscDebug.getCurrentTimeFormatted());</span>

<span class="nc" id="L3201">        return img;</span>
    }

    protected Map&lt;PairInt, Float&gt; createPolarCIEXYMap(ImageExt input,
        Set&lt;PairInt&gt; points) {

<span class="fc" id="L3207">        Map&lt;PairInt, Float&gt; thetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

        //TODO: remove imgCp when finished debugging
        //ImageExt imgCp = input.copyToImageExt();
<span class="fc" id="L3211">        int w = input.getWidth();</span>
<span class="fc" id="L3212">        int h = input.getHeight();</span>

<span class="fc" id="L3214">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L3216">        double thetaFactor = 255./360.;</span>

        // to set the non member colors, need to traverse all pixels.
<span class="fc bfc" id="L3219" title="All 2 branches covered.">        for (int col = 0; col &lt; w; ++col) {</span>
<span class="fc bfc" id="L3220" title="All 2 branches covered.">            for (int row = 0; row &lt; h; row++) {</span>
<span class="fc" id="L3221">                PairInt p = new PairInt(col, row);</span>
<span class="fc bfc" id="L3222" title="All 2 branches covered.">                if (points.contains(p)) {</span>
<span class="fc" id="L3223">                    float cieX = input.getCIEX(col, row);</span>
<span class="fc" id="L3224">                    float cieY = input.getCIEY(col, row);</span>
<span class="fc" id="L3225">                    double thetaDegrees = cieC.calculateXYTheta(cieX, cieY) * 180. / Math.PI;</span>
<span class="fc" id="L3226">                    double theta = thetaFactor * thetaDegrees;</span>
          //          int thetaCIEXY = (int)Math.round(theta);
                    //          imgCp.setRGB(col, row, thetaCIEXY, thetaCIEXY, thetaCIEXY);

<span class="fc" id="L3230">                    thetaMap.put(p, Float.valueOf((float) theta));</span>
                } else {
                    //         imgCp.setRGB(col, row, 0, 255, 0);
                }
            }
        }

        //MiscDebug.writeImage(imgCp, &quot;polarciexy_&quot; + MiscDebug.getCurrentTimeFormatted());

<span class="fc" id="L3239">        return thetaMap;</span>
    }

    private void correctForIllumination(ImageExt input, Set&lt;PairInt&gt; points,
        int toleranceInValue) {

<span class="pc bpc" id="L3245" title="2 of 4 branches missed.">        if (points.isEmpty() || (toleranceInValue == 0)) {</span>
<span class="nc" id="L3246">            return;</span>
        }

<span class="fc" id="L3249">        Map&lt;PairInt, Float&gt; thetaMap = createPolarCIEXYMap(input, points);</span>

<span class="fc" id="L3251">        correctForIllumination(input, toleranceInValue, thetaMap);</span>
<span class="fc" id="L3252">    }</span>

    private void correctForIllumination(ImageExt input,
        int toleranceInValue, Map&lt;PairInt, Float&gt; thetaMap) {

        /*
        in CIE XY color space, reassign colors:

        for points:
        -- convert to polar theta in CIE XY space and plot in image
           as greyscale without changes.

        -- DFS traversal through the theta values of pixels in points
           to make contigous groups of pixels that are within a tolerance of
           theta value of one another.

        -- reassign the average rgb color to those pixels in a group
        */

<span class="fc" id="L3271">        int w = input.getWidth();</span>
<span class="fc" id="L3272">        int h = input.getHeight();</span>

        // find pixels similar in color that are contiguous

<span class="fc" id="L3276">        DFSConnectedGroupsFinder2 groupFinder = new DFSConnectedGroupsFinder2();</span>
<span class="fc" id="L3277">        groupFinder.findConnectedPointGroups(thetaMap, 360, toleranceInValue,</span>
            w, h, false);

<span class="fc" id="L3280">        int nGroups = groupFinder.getNumberOfGroups();</span>

        // calc avg rgb of each contiguous group and reset rgb of all in group
        // to the avg

<span class="fc bfc" id="L3285" title="All 2 branches covered.">        for (int i = 0; i &lt; nGroups; ++i) {</span>

<span class="fc" id="L3287">            Set&lt;PairInt&gt; group = groupFinder.getXY(i);</span>

<span class="fc bfc" id="L3289" title="All 2 branches covered.">            if (group.size() == 1) {</span>
<span class="fc" id="L3290">                continue;</span>
            }

<span class="fc" id="L3293">            float sumR = 0;</span>
<span class="fc" id="L3294">            float sumG = 0;</span>
<span class="fc" id="L3295">            float sumB = 0;</span>
<span class="fc bfc" id="L3296" title="All 2 branches covered.">            for (PairInt p : group) {</span>
<span class="fc" id="L3297">                int pixIdx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="fc" id="L3298">                sumR += input.getR(pixIdx);</span>
<span class="fc" id="L3299">                sumG += input.getG(pixIdx);</span>
<span class="fc" id="L3300">                sumB += input.getB(pixIdx);</span>
<span class="fc" id="L3301">            }</span>
<span class="fc" id="L3302">            int avgR = Math.round(sumR/(float)group.size());</span>
<span class="fc" id="L3303">            int avgG = Math.round(sumG/(float)group.size());</span>
<span class="fc" id="L3304">            int avgB = Math.round(sumB/(float)group.size());</span>

<span class="fc bfc" id="L3306" title="All 2 branches covered.">            for (PairInt p : group) {</span>
<span class="fc" id="L3307">                input.setRGB(p.getX(), p.getY(), avgR, avgG, avgB);</span>
<span class="fc" id="L3308">            }</span>
        }
<span class="fc" id="L3310">    }</span>

    private int determineToleranceForIllumCorr(Map&lt;PairInt, Float&gt; thetaMap,
        int nTotCategoryMembers) {

<span class="pc bpc" id="L3315" title="1 of 2 branches missed.">        if (thetaMap.isEmpty()) {</span>
<span class="nc" id="L3316">            return -1;</span>
        }

        // using a histogram of color in
        // determining whether toleranceInValue should be 1 or 4.
        // 1 is better for low contrast regions like the brown &amp; lowe 2003 mtns
        // but 4 is better for many colors, large contrast, and large dynamic
        // range such as seen in the merton college test images

<span class="fc" id="L3325">        float[] values = new float[thetaMap.size()];</span>
<span class="fc" id="L3326">        int count = 0;</span>
<span class="fc bfc" id="L3327" title="All 2 branches covered.">        for (Entry&lt;PairInt, Float&gt; entry : thetaMap.entrySet()) {</span>
<span class="fc" id="L3328">            values[count] = entry.getValue().floatValue();</span>
<span class="fc" id="L3329">            count++;</span>
<span class="fc" id="L3330">        }</span>

<span class="fc" id="L3332">        int tolerance = 1;</span>

<span class="fc" id="L3334">        HistogramHolder hist = Histogram.createSimpleHistogram(values,</span>
<span class="fc" id="L3335">            Errors.populateYErrorsBySqrt(values));</span>
        try {
<span class="fc" id="L3337">            hist.plotHistogram(&quot;cieTheta&quot;, &quot;_cietheta_&quot;);</span>
<span class="nc" id="L3338">        } catch (IOException ex) {</span>
<span class="nc" id="L3339">            Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L3340">        }</span>

<span class="pc bpc" id="L3342" title="1 of 2 branches missed.">        if (hist != null) {</span>
<span class="fc" id="L3343">            List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexes(hist, 0.05f);</span>

            //TODO: for rare case that image has only one color, and the pixels
            // are all in thetaMap, we want the invoker not to remove illumination
            // because that may be the only contrast in the image.
            // an example of that happening wouldbe a blue sky and blue mountains
            // very similar in color.
<span class="pc bpc" id="L3350" title="1 of 4 branches missed.">            if ((indexes.size() == 1) &amp;&amp; (nTotCategoryMembers == thetaMap.size())) {</span>
<span class="nc" id="L3351">                return -1;</span>
            }

            // from lowest to highest peak, are there continuous values &gt;= 1/4 lowest peak?
<span class="fc bfc" id="L3355" title="All 2 branches covered.">            if (indexes.size() &gt; 1) {</span>

<span class="fc" id="L3357">                Collections.sort(indexes);</span>

<span class="fc" id="L3359">                int minPeak = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L3360" title="All 2 branches covered.">                for (Integer index : indexes) {</span>
<span class="fc" id="L3361">                    int v = hist.getYHist()[index.intValue()];</span>
<span class="fc bfc" id="L3362" title="All 2 branches covered.">                    if (v &lt; minPeak) {</span>
<span class="fc" id="L3363">                        minPeak = v;</span>
                    }
<span class="fc" id="L3365">                }</span>

<span class="fc" id="L3367">                int nBelow = 0;</span>
<span class="fc" id="L3368">                int n = 0;</span>
<span class="fc" id="L3369">                int limit = minPeak/4;</span>
<span class="fc" id="L3370">                for (int i = indexes.get(0).intValue();</span>
<span class="fc bfc" id="L3371" title="All 2 branches covered.">                    i &lt; indexes.get(indexes.size() - 1).intValue(); ++i) {</span>
<span class="fc" id="L3372">                    int v = hist.getYHist()[i];</span>
<span class="fc bfc" id="L3373" title="All 2 branches covered.">                    if (v &lt; limit) {</span>
<span class="fc" id="L3374">                        nBelow++;</span>
                    }
<span class="fc" id="L3376">                    n++;</span>
                }

<span class="pc bpc" id="L3379" title="1 of 2 branches missed.">                if (((float)nBelow/(float)n) &lt; 0.5) {</span>
<span class="nc" id="L3380">                    tolerance = 3;</span>
                }
            }
        }

<span class="fc" id="L3385">        return tolerance;</span>
    }

    private int correctPointsBoundaries(ImageExt input,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; blackPixels,
        Set&lt;PairInt&gt; whitePixels, Set&lt;PairInt&gt; greyPixels) {

         // boundary corrections:
        // iterate over points0 to find boundary points and their neighbors.
        // a boundary point has at least one non-points0 point neighbor.
        // for the boundary points and each of their neigbhors,
        // determine whether should move the point to another group
        // (or add it to its own).
        // the local rgb or ciexy can be computed and kept in a hash to avoid
        // re-calculating.
        // the local color will be the 9 point region members only regions
        //

<span class="nc" id="L3403">        int imageWidth = input.getWidth();</span>
<span class="nc" id="L3404">        int imageHeight = input.getHeight();</span>

<span class="nc" id="L3406">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="nc" id="L3408">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L3409">        int[] dys = Misc.dy8;</span>

<span class="nc" id="L3411">        Set&lt;PairInt&gt; addP = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L3412">        Set&lt;PairInt&gt; rmP = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L3413">        Set&lt;PairInt&gt; moved = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L3415" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L3416">            int x = p.getX();</span>
<span class="nc" id="L3417">            int y = p.getY();</span>

<span class="nc" id="L3419">            int nNonNeighbors = 0;</span>
<span class="nc bnc" id="L3420" title="All 2 branches missed.">            for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="nc" id="L3421">                int x2 = x + dxs[i];</span>
<span class="nc" id="L3422">                int y2 = y + dys[i];</span>
<span class="nc bnc" id="L3423" title="All 8 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                    (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L3425">                    continue;</span>
                }
<span class="nc" id="L3427">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L3428" title="All 2 branches missed.">                if (!points.contains(p2)) {</span>
<span class="nc" id="L3429">                   nNonNeighbors++;</span>
                }
            }

<span class="nc bnc" id="L3433" title="All 2 branches missed.">            if (nNonNeighbors == 0) {</span>
<span class="nc" id="L3434">                continue;</span>
            }

<span class="nc" id="L3437">            Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L3438">            Set&lt;PairInt&gt; nonNB = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L3439">            Set&lt;PairInt&gt; nonNW = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L3440">            Set&lt;PairInt&gt; nonNG = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L3442" title="All 2 branches missed.">            for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="nc" id="L3443">                int x2 = x + dxs[i];</span>
<span class="nc" id="L3444">                int y2 = y + dys[i];</span>
<span class="nc bnc" id="L3445" title="All 8 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                    (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L3447">                    continue;</span>
                }
<span class="nc" id="L3449">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L3450" title="All 2 branches missed.">                if (!moved.contains(p2)) {</span>
<span class="nc bnc" id="L3451" title="All 2 branches missed.">                    if (points.contains(p2)) {</span>
<span class="nc" id="L3452">                        neighbors.add(p2);</span>
<span class="nc bnc" id="L3453" title="All 2 branches missed.">                    } else if (blackPixels.contains(p2)) {</span>
<span class="nc" id="L3454">                        nonNB.add(p2);</span>
<span class="nc bnc" id="L3455" title="All 2 branches missed.">                    } else if (whitePixels.contains(p2)) {</span>
<span class="nc" id="L3456">                        nonNW.add(p2);</span>
<span class="nc bnc" id="L3457" title="All 2 branches missed.">                    } else if (greyPixels.contains(p2)) {</span>
<span class="nc" id="L3458">                        nonNG.add(p2);</span>
                    }
                }
            }

            // calc the avg cieX, cieY of neighbors
            // calc the avg cieX, cieY of non-neighbors
            // if p's cieXY is closer to neighbors, do not move it, but do
            // look at each of the nonNeighbors to see whether to move it...
            //float[] avgCIEXYNeighbors = ImageStatisticsHelper.calculateAvgCIEXY(
            //    input, neighbors);
<span class="nc" id="L3469">            float[] avgRGBNeighbors = ImageStatisticsHelper.calculateAvgRGB(</span>
                input, neighbors);

            //float pCIEX = input.getCIEX(x, y);
            //float pCIEY = input.getCIEY(x, y);
<span class="nc" id="L3474">            int pR = input.getR(x, y);</span>
<span class="nc" id="L3475">            int pG = input.getG(x, y);</span>
<span class="nc" id="L3476">            int pB = input.getB(x, y);</span>

<span class="nc" id="L3478">            double distSq0 = Math.pow((avgRGBNeighbors[0] - pR), 2) +</span>
<span class="nc" id="L3479">                Math.pow((avgRGBNeighbors[1] - pG), 2) +</span>
<span class="nc" id="L3480">                Math.pow((avgRGBNeighbors[2] - pB), 2);</span>

<span class="nc" id="L3482">            double minDistSq = distSq0;</span>

            // 0 = neighbors, 1=blackPixels, 2=whitePixels, 3=greyPixels
<span class="nc" id="L3485">            int minDistGroup = 0;</span>

<span class="nc bnc" id="L3487" title="All 2 branches missed.">            if (!nonNB.isEmpty()) {</span>
<span class="nc" id="L3488">                float[] avgRGB = ImageStatisticsHelper.calculateAvgRGB(</span>
                    input, nonNB);
<span class="nc" id="L3490">                double distSq = Math.pow((avgRGB[0] - pR), 2) +</span>
<span class="nc" id="L3491">                    Math.pow((avgRGB[1] - pG), 2) +</span>
<span class="nc" id="L3492">                    Math.pow((avgRGB[2] - pB), 2);</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L3494">                    minDistSq = distSq;</span>
<span class="nc" id="L3495">                    minDistGroup = 1;</span>
                }
            }
<span class="nc bnc" id="L3498" title="All 2 branches missed.">            if (!nonNW.isEmpty()) {</span>
<span class="nc" id="L3499">                float[] avgRGB = ImageStatisticsHelper.calculateAvgRGB(</span>
                    input, nonNW);
<span class="nc" id="L3501">                double distSq = Math.pow((avgRGB[0] - pR), 2) +</span>
<span class="nc" id="L3502">                    Math.pow((avgRGB[1] - pG), 2) +</span>
<span class="nc" id="L3503">                    Math.pow((avgRGB[2] - pB), 2);</span>
<span class="nc bnc" id="L3504" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L3505">                    minDistSq = distSq;</span>
<span class="nc" id="L3506">                    minDistGroup = 2;</span>
                }
            }
<span class="nc bnc" id="L3509" title="All 2 branches missed.">            if (!nonNG.isEmpty()) {</span>
<span class="nc" id="L3510">                float[] avgRGB = ImageStatisticsHelper.calculateAvgRGB(</span>
                    input, nonNG);
<span class="nc" id="L3512">                double distSq = Math.pow((avgRGB[0] - pR), 2) +</span>
<span class="nc" id="L3513">                    Math.pow((avgRGB[1] - pG), 2) +</span>
<span class="nc" id="L3514">                    Math.pow((avgRGB[2] - pB), 2);</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L3516">                    minDistSq = distSq;</span>
<span class="nc" id="L3517">                    minDistGroup = 3;</span>
                }
            }

            // 0 = neighbors, 1=blackPixels, 2=whitePixels, 3=greyPixels
<span class="nc bnc" id="L3522" title="All 2 branches missed.">            if (minDistGroup &gt; 0) {</span>
<span class="nc bnc" id="L3523" title="All 2 branches missed.">                if (minDistGroup == 1) {</span>
<span class="nc" id="L3524">                    blackPixels.add(p);</span>
<span class="nc bnc" id="L3525" title="All 2 branches missed.">                } else if (minDistGroup == 2) {</span>
<span class="nc" id="L3526">                    whitePixels.add(p);</span>
<span class="nc bnc" id="L3527" title="All 2 branches missed.">                } else if (minDistGroup == 3) {</span>
<span class="nc" id="L3528">                    greyPixels.add(p);</span>
                }
<span class="nc" id="L3530">                rmP.add(p);</span>
<span class="nc" id="L3531">                moved.add(p);</span>
            }

            // determine if the non neighbors should be moved into point group
<span class="nc bnc" id="L3535" title="All 2 branches missed.">            if (!nonNB.isEmpty()) {</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">                for (PairInt p2 : nonNB) {</span>
<span class="nc bnc" id="L3537" title="All 2 branches missed.">                    if (moved.contains(p2)) {</span>
<span class="nc" id="L3538">                        continue;</span>
                    }
<span class="nc" id="L3540">                    int x2 = p2.getX();</span>
<span class="nc" id="L3541">                    int y2 = p2.getY();</span>
<span class="nc" id="L3542">                    int p2R = input.getR(x2, y2);</span>
<span class="nc" id="L3543">                    int p2G = input.getG(x2, y2);</span>
<span class="nc" id="L3544">                    int p2B = input.getB(x2, y2);</span>

<span class="nc" id="L3546">                    Set&lt;PairInt&gt; nbN = curveHelper.findNeighbors(x2, y2, blackPixels);</span>
<span class="nc" id="L3547">                    float[] avgRGB = ImageStatisticsHelper.calculateAvgRGB(input, nbN);</span>

<span class="nc" id="L3549">                    double distSqToNeighbors = Math.pow((avgRGB[0] - p2R), 2) +</span>
<span class="nc" id="L3550">                        Math.pow((avgRGB[1] - p2G), 2) + Math.pow((avgRGB[2] - p2B), 2);</span>

<span class="nc" id="L3552">                    double distSqToP = Math.pow((pR - p2R), 2) +</span>
<span class="nc" id="L3553">                        Math.pow((pG - p2G), 2) + Math.pow((pB - p2B), 2);</span>

<span class="nc bnc" id="L3555" title="All 2 branches missed.">                    if (distSqToP &lt; distSqToNeighbors) {</span>
<span class="nc" id="L3556">                        blackPixels.remove(p2);</span>
<span class="nc" id="L3557">                        addP.add(p2);</span>
<span class="nc" id="L3558">                        moved.add(p2);</span>
                    }
<span class="nc" id="L3560">                }</span>
            }
<span class="nc bnc" id="L3562" title="All 2 branches missed.">            if (!nonNW.isEmpty()) {</span>
<span class="nc bnc" id="L3563" title="All 2 branches missed.">                for (PairInt p2 : nonNW) {</span>
<span class="nc bnc" id="L3564" title="All 2 branches missed.">                    if (moved.contains(p2)) {</span>
<span class="nc" id="L3565">                        continue;</span>
                    }
<span class="nc" id="L3567">                    int x2 = p2.getX();</span>
<span class="nc" id="L3568">                    int y2 = p2.getY();</span>
<span class="nc" id="L3569">                    int p2R = input.getR(x2, y2);</span>
<span class="nc" id="L3570">                    int p2G = input.getG(x2, y2);</span>
<span class="nc" id="L3571">                    int p2B = input.getB(x2, y2);</span>

<span class="nc" id="L3573">                    Set&lt;PairInt&gt; nbN = curveHelper.findNeighbors(x2, y2, whitePixels);</span>
<span class="nc" id="L3574">                    float[] avgRGB = ImageStatisticsHelper.calculateAvgRGB(input, nonNW);</span>

<span class="nc" id="L3576">                    double distSqToNeighbors = Math.pow((avgRGB[0] - p2R), 2) +</span>
<span class="nc" id="L3577">                        Math.pow((avgRGB[1] - p2G), 2) + Math.pow((avgRGB[2] - p2B), 2);</span>

<span class="nc" id="L3579">                    double distSqToP = Math.pow((pR - p2R), 2) +</span>
<span class="nc" id="L3580">                        Math.pow((pG - p2G), 2) + Math.pow((pB - p2B), 2);</span>

<span class="nc bnc" id="L3582" title="All 2 branches missed.">                    if (distSqToP &lt; distSqToNeighbors) {</span>
<span class="nc" id="L3583">                        whitePixels.remove(p2);</span>
<span class="nc" id="L3584">                        addP.add(p2);</span>
<span class="nc" id="L3585">                        moved.add(p2);</span>
                    }
<span class="nc" id="L3587">                }</span>
            }
<span class="nc bnc" id="L3589" title="All 2 branches missed.">            if (!nonNG.isEmpty()) {</span>
<span class="nc bnc" id="L3590" title="All 2 branches missed.">                for (PairInt p2 : nonNG) {</span>
<span class="nc bnc" id="L3591" title="All 2 branches missed.">                    if (moved.contains(p2)) {</span>
<span class="nc" id="L3592">                        continue;</span>
                    }
<span class="nc" id="L3594">                    int x2 = p2.getX();</span>
<span class="nc" id="L3595">                    int y2 = p2.getY();</span>
<span class="nc" id="L3596">                    int p2R = input.getR(x2, y2);</span>
<span class="nc" id="L3597">                    int p2G = input.getG(x2, y2);</span>
<span class="nc" id="L3598">                    int p2B = input.getB(x2, y2);</span>

<span class="nc" id="L3600">                    Set&lt;PairInt&gt; nbN = curveHelper.findNeighbors(x2, y2, greyPixels);</span>
<span class="nc" id="L3601">                    float[] avgRGB = ImageStatisticsHelper.calculateAvgRGB(input, nonNG);</span>

<span class="nc" id="L3603">                    double distSqToNeighbors = Math.pow((avgRGB[0] - p2R), 2) +</span>
<span class="nc" id="L3604">                        Math.pow((avgRGB[1] - p2G), 2) + Math.pow((avgRGB[2] - p2B), 2);</span>

<span class="nc" id="L3606">                    double distSqToP = Math.pow((pR - p2R), 2) +</span>
<span class="nc" id="L3607">                        Math.pow((pG - p2G), 2) + Math.pow((pB - p2B), 2);</span>

<span class="nc bnc" id="L3609" title="All 2 branches missed.">                    if (distSqToP &lt; distSqToNeighbors) {</span>
<span class="nc" id="L3610">                        greyPixels.remove(p2);</span>
<span class="nc" id="L3611">                        addP.add(p2);</span>
<span class="nc" id="L3612">                        moved.add(p2);</span>
                    }
<span class="nc" id="L3614">                }</span>
            }
<span class="nc" id="L3616">        }</span>

<span class="nc bnc" id="L3618" title="All 2 branches missed.">        for (PairInt p : addP) {</span>
<span class="nc" id="L3619">            points.add(p);</span>
<span class="nc" id="L3620">        }</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">        for (PairInt p : rmP) {</span>
<span class="nc" id="L3622">            points.remove(p);</span>
<span class="nc" id="L3623">        }</span>

<span class="nc" id="L3625">        return moved.size();</span>
    }

    /**
     * an algorithm to traverse the image and store black pixels in a list
     * then use cieXY to place pixels in colorPixelMap if they are not in the
     * large white central space, else place them in unassignedPixels.
     * @param input
     * @param blackPixels
     * @param colorPixelMap
     * @param unassignedPixels
     */
    private void populatePixelLists2(ImageExt input, Set&lt;PairInt&gt; blackPixels,
        Map&lt;PairInt, Float&gt; colorPixelMap, Set&lt;PairInt&gt; unassignedPixels) {

<span class="fc" id="L3640">        int w = input.getWidth();</span>
<span class="fc" id="L3641">        int h = input.getHeight();</span>

<span class="fc" id="L3643">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // looking for limits in peaks of (r,g,b) &lt;= (45,45,45) and &gt; (191,191,191)
<span class="fc" id="L3646">        int[] whiteBlackLimits = findByHistogramLimitsForBlackAndWhite(input);</span>
        // overriding:

<span class="fc bfc" id="L3649" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3650" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L3652">                int idx = input.getInternalIndex(i, j);</span>

<span class="fc" id="L3654">                int r = input.getR(idx);</span>
<span class="fc" id="L3655">                int g = input.getG(idx);</span>
<span class="fc" id="L3656">                int b = input.getB(idx);</span>

<span class="fc" id="L3658">                float c = r + g + b;</span>
<span class="fc" id="L3659">                int avg = (int)(c/3);</span>

                /*
                float rd = (float)r/c;
                float gd = (float)g/c;
                float bd = (float)b/c;
                // r and b 20 percent or more below and g 20 percent or more above
                float diff = 0.1f * 0.33333f;
                boolean veryGreen = (rd &lt; (0.333f - diff)) &amp;&amp; (bd &lt; (0.333f - diff)) &amp;&amp; (gd &gt; (0.333f + diff));
                */
                //log.info(String.format(
                //    &quot;rgb=(%3d, %3d, %3d)  rgbdiv=(%.2f, %.2f, %.2f) cie=(%.3f, %.3f) xy=(%3d, %3d)&quot;,
                //    r, g, b, rd, gd, bd, cieX, cieY, i, j));

<span class="fc bfc" id="L3673" title="All 2 branches covered.">                if ((avg &lt;= whiteBlackLimits[0]) /*&amp;&amp; !veryGreen*/) {</span>
<span class="fc" id="L3674">                    blackPixels.add(new PairInt(i, j));</span>
<span class="fc" id="L3675">                    continue;</span>
                }

<span class="fc" id="L3678">                float cieX = input.getCIEX(idx);</span>
<span class="fc" id="L3679">                float cieY = input.getCIEY(idx);</span>

<span class="fc bfc" id="L3681" title="All 2 branches covered.">                if (cieC.isInLargeWhiteCenter(cieX, cieY) /*&amp;&amp; !veryGreen*/) {</span>
<span class="fc" id="L3682">                    unassignedPixels.add(new PairInt(i, j));</span>
<span class="fc" id="L3683">                    continue;</span>
                }

<span class="fc" id="L3686">                double thetaRadians = cieC.calculateXYTheta(cieX, cieY);</span>

<span class="fc" id="L3688">                colorPixelMap.put(new PairInt(i, j),</span>
<span class="fc" id="L3689">                    Float.valueOf((float)thetaRadians));</span>
            }
        }
<span class="fc" id="L3692">    }</span>

    private Map&lt;PairInt, Integer&gt; populatePixelLists3(ImageExt input) {

<span class="nc" id="L3696">        int w = input.getWidth();</span>
<span class="nc" id="L3697">        int h = input.getHeight();</span>

<span class="nc" id="L3699">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L3701">        Map&lt;PairInt, Integer&gt; pixelCIETheta = new HashMap&lt;PairInt, Integer&gt;();</span>
            
<span class="nc bnc" id="L3703" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L3704" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="nc" id="L3706">                int idx = input.getInternalIndex(i, j);</span>

<span class="nc" id="L3708">                float cieX = input.getCIEX(idx);</span>
<span class="nc" id="L3709">                float cieY = input.getCIEY(idx);</span>

<span class="nc bnc" id="L3711" title="All 2 branches missed.">                if (!cieC.isInLargeWhiteCenter(cieX, cieY) /*&amp;&amp; !veryGreen*/) {</span>
                    
<span class="nc" id="L3713">                    double thetaRadians = cieC.calculateXYTheta(cieX, cieY);</span>
                    
<span class="nc" id="L3715">                    double thetaDegrees = thetaRadians * 180./Math.PI;</span>
                    
<span class="nc" id="L3717">                    int thetaDegreesInt = (int)Math.round(thetaDegrees);</span>

<span class="nc" id="L3719">                    pixelCIETheta.put(new PairInt(i, j), thetaDegreesInt);</span>
                }
            }
        }
        
<span class="nc" id="L3724">        return pixelCIETheta;</span>
    }

    private void growPixelsWithinRGBTolerance(Image img,
        Set&lt;PairInt&gt; assignedPixels, Set&lt;PairInt&gt; unassignedPixels, int tolRGB) {

<span class="fc" id="L3730">        Set&lt;PairInt&gt; addTo = findPixelsWithinRGBTolerance(img,</span>
            assignedPixels, unassignedPixels, tolRGB);

<span class="fc" id="L3733">        assignedPixels.addAll(addTo);</span>
<span class="fc" id="L3734">    }</span>

    /**
     * traverses assignedPixels and finds adjacent unassignedPixels that are
     * within tolRGB of r, g, b colors and removes those points from
     * unassignedPixels and returns them as a set.
     * @param input
     * @param assignedPixels
     * @param unassignedPixels
     * @param tolRGB
     * @return
     */
    private Set&lt;PairInt&gt; findPixelsWithinRGBTolerance(Image img,
        Set&lt;PairInt&gt; assignedPixels, Set&lt;PairInt&gt; unassignedPixels, int tolRGB) {

<span class="fc" id="L3749">        Set&lt;PairInt&gt; addToAssigned = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L3751">        int w = img.getWidth();</span>
<span class="fc" id="L3752">        int h = img.getHeight();</span>

<span class="fc" id="L3754">        int[] dxs8 = Misc.dx8;</span>
<span class="fc" id="L3755">        int[] dys8 = Misc.dy8;</span>

<span class="fc" id="L3757">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L3759">        Stack&lt;PairInt&gt; stack = new Stack&lt;PairInt&gt;();</span>
<span class="fc" id="L3760">        stack.addAll(assignedPixels);</span>

<span class="fc bfc" id="L3762" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
<span class="fc" id="L3763">            PairInt uPoint = stack.pop();</span>
<span class="pc bpc" id="L3764" title="1 of 2 branches missed.">            if (visited.contains(uPoint)) {</span>
<span class="nc" id="L3765">                continue;</span>
            }
<span class="fc" id="L3767">            int x = uPoint.getX();</span>
<span class="fc" id="L3768">            int y = uPoint.getY();</span>

<span class="fc" id="L3770">            int r = img.getR(x, y);</span>
<span class="fc" id="L3771">            int g = img.getG(x, y);</span>
<span class="fc" id="L3772">            int b = img.getB(x, y);</span>

<span class="fc bfc" id="L3774" title="All 2 branches covered.">            for (int i = 0; i &lt; dxs8.length; ++i) {</span>
<span class="fc" id="L3775">                int x2 = x + dxs8[i];</span>
<span class="fc" id="L3776">                int y2 = y + dys8[i];</span>
<span class="fc bfc" id="L3777" title="All 8 branches covered.">                if ((x2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &lt; 0) || (y2 &gt; (h - 1))) {</span>
<span class="fc" id="L3778">                    continue;</span>
                }
<span class="fc" id="L3780">                PairInt vPoint = new PairInt(x2, y2);</span>
<span class="fc bfc" id="L3781" title="All 2 branches covered.">                if (!unassignedPixels.contains(vPoint)) {</span>
<span class="fc" id="L3782">                    continue;</span>
                }
<span class="fc" id="L3784">                int r2 = img.getR(x2, y2);</span>
<span class="fc" id="L3785">                int g2 = img.getG(x2, y2);</span>
<span class="fc" id="L3786">                int b2 = img.getB(x2, y2);</span>
<span class="fc" id="L3787">                int diffR = Math.abs(r2 - r);</span>
<span class="fc" id="L3788">                int diffG = Math.abs(g2 - g);</span>
<span class="fc" id="L3789">                int diffB = Math.abs(b2 - b);</span>

<span class="fc bfc" id="L3791" title="All 6 branches covered.">                if ((diffR &lt; tolRGB) &amp;&amp; (diffG &lt; tolRGB) &amp;&amp; (diffB &lt; tolRGB)) {</span>
<span class="fc" id="L3792">                    unassignedPixels.remove(vPoint);</span>
<span class="fc" id="L3793">                    addToAssigned.add(vPoint);</span>
<span class="fc" id="L3794">                    stack.add(vPoint);</span>
                }
            }

<span class="fc" id="L3798">            visited.add(uPoint);</span>
<span class="fc" id="L3799">        }</span>

<span class="fc" id="L3801">        return addToAssigned;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageSegmentation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageSegmentation.java</span></div><h1>ImageSegmentation.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.MultiArrayMergeSort;
import algorithms.QuickSort;
import algorithms.compGeometry.clustering.KMeansPlusPlus;
import algorithms.compGeometry.clustering.KMeansPlusPlusColor;
import algorithms.connected.ConnectedValuesFinder;
import algorithms.imageProcessing.util.GroupAverageColors;
import algorithms.imageProcessing.ImageProcessor.Colors;
import algorithms.imageProcessing.features.PhaseCongruencyDetector;
import algorithms.imageProcessing.segmentation.ColorSpace;
import algorithms.imageProcessing.segmentation.LabelToColorHelper;
import algorithms.imageProcessing.segmentation.NormalizedCuts;
import algorithms.imageProcessing.segmentation.SLICSuperPixels;
import algorithms.misc.MedianSmooth;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.awt.Color;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;

/**
 * Many methods in here will be removed soon.
 * Meanwhile, see MSEREdges.java for segmentation.
 * 
 * class holding several different image segmentation methods.  Note that
 * some other techniques involving contrast for example, are elsewhere.
 *
 * A few of the methods use a density based clustering algorithm from
       http://nking.github.io/two-point-correlation/
       which has an MIT license
      ---- begin nking copyright ----
      The MIT License (MIT)
      Copyright (c) 2013-* Nichole King
      http://nking.github.io/two-point-correlation/

        Permission is hereby granted, free of charge, to any person obtaining 
        a copy of this software and associated documentation files 
        (the &quot;Software&quot;), to deal in the Software without restriction, 
        including without limitation the rights to use, copy, modify, merge, 
        publish, distribute, sublicense, and/or sell copies of the Software, 
        and to permit persons to whom the Software is furnished to do so, 
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included 
        in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS 
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     ---- end nking copyright ---- 
 * 
 * @author nichole
 */
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">public class ImageSegmentation {</span>

<span class="fc" id="L78">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * applies KMeansPlusPlus algorithm to the values in input
     * (greyscale intensities) to create kBands of clustered pixels
     * (operates on input).
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */
    public void applyUsingKMPP(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {

<span class="fc" id="L92">        KMeansPlusPlus kmpp = new KMeansPlusPlus();</span>
<span class="fc" id="L93">        kmpp.computeMeans(kBands, input);</span>

<span class="fc" id="L95">        int[] seeds = kmpp.getCenters();</span>

<span class="fc" id="L97">        int[] imgSeedIndexAssignments = kmpp.getImgPixelSeedIndexes();</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; input.getNPixels(); ++pixIdx) {</span>

<span class="fc" id="L101">            int seedIdx = imgSeedIndexAssignments[pixIdx];</span>

<span class="fc" id="L103">            int seedValue = seeds[seedIdx];</span>

<span class="fc" id="L105">            input.setValue(pixIdx, seedValue);</span>
        }
<span class="fc" id="L107">    }</span>

    public void applyUsingKMPP(Image input, int kBands) throws IOException,
        NoSuchAlgorithmException {

<span class="fc" id="L112">        KMeansPlusPlusColor instance = new KMeansPlusPlusColor();</span>
<span class="fc" id="L113">        instance.computeMeans(kBands, input);</span>

<span class="fc" id="L115">        int[][] seeds = instance.getCenters();</span>

<span class="fc" id="L117">        int[] imgSeedIndexAssignments = instance.getImgPixelSeedIndexes();</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; input.getNPixels(); ++pixIdx) {</span>

<span class="fc" id="L121">            int seedIdx = imgSeedIndexAssignments[pixIdx];</span>

<span class="fc" id="L123">            int r = seeds[0][seedIdx];</span>
<span class="fc" id="L124">            int g = seeds[1][seedIdx];</span>
<span class="fc" id="L125">            int b = seeds[2][seedIdx];</span>

<span class="fc" id="L127">            input.setRGB(pixIdx, r, g, b);</span>
        }
<span class="fc" id="L129">    }</span>
 
    public Map&lt;PairInt, Integer&gt; calculatePolarCIEXY(ImageExt input, Set&lt;PairInt&gt; points) {

<span class="nc" id="L133">        Map&lt;PairInt, Integer&gt; map = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc" id="L135">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L139">            float cieX = input.getCIEX(p.getX(), p.getY());</span>
<span class="nc" id="L140">            float cieY = input.getCIEY(p.getX(), p.getY());</span>

<span class="nc" id="L142">            double thetaRadians = cieC.calculateXYTheta(cieX, cieY);</span>

<span class="nc" id="L144">            int thetaDegrees = (int)Math.round(thetaRadians * 180./Math.PI);</span>

<span class="nc" id="L146">            map.put(p, Integer.valueOf(thetaDegrees));</span>
<span class="nc" id="L147">        }</span>

<span class="nc" id="L149">        return map;</span>
    }

    public GreyscaleImage createCombinedWaveletBased(Image img) {
<span class="nc" id="L153">        return createCombinedWaveletBased(img.copyRedToGreyscale(),</span>
<span class="nc" id="L154">            img.copyGreenToGreyscale(), img.copyBlueToGreyscale());</span>
    }

    public GreyscaleImage createCombinedWaveletBased2(Image img) {
<span class="nc" id="L158">        return createCombinedWaveletBased2(img.copyRedToGreyscale(),</span>
<span class="nc" id="L159">            img.copyGreenToGreyscale(), img.copyBlueToGreyscale());</span>
    }

    public GreyscaleImage createCombinedWaveletBased(
        GreyscaleImage rImg, GreyscaleImage gImg, GreyscaleImage bImg) {

<span class="nc" id="L165">        boolean use1D = true;</span>
<span class="nc" id="L166">        GreyscaleImage rSegImg = createGreyscale5(rImg, use1D);</span>
<span class="nc" id="L167">        GreyscaleImage gSegImg = createGreyscale5(gImg, use1D);</span>
<span class="nc" id="L168">        GreyscaleImage bSegImg = createGreyscale5(bImg, use1D);</span>

<span class="nc" id="L170">        GreyscaleImage combined = rSegImg.copyImage();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        for (int i = 0; i &lt; rSegImg.getWidth(); ++i) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            for (int j = 0; j &lt; rSegImg.getHeight(); ++j) {</span>
<span class="nc" id="L173">                int g = gSegImg.getValue(i, j);</span>
<span class="nc" id="L174">                int b = bSegImg.getValue(i, j);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (g &gt; 0) {</span>
<span class="nc" id="L176">                    combined.setValue(i, j, g);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                } else if (b &gt; 0) {</span>
<span class="nc" id="L178">                    combined.setValue(i, j, b);</span>
                }
            }
        }
<span class="nc" id="L182">        return combined;</span>
    }

    public GreyscaleImage createCombinedWaveletBased2(
        GreyscaleImage rImg, GreyscaleImage gImg, GreyscaleImage bImg) {

<span class="nc" id="L188">        ATrousWaveletTransform wt = new ATrousWaveletTransform();</span>

<span class="nc" id="L190">        GreyscaleImage coarsestCoeffR = null;</span>
<span class="nc" id="L191">        GreyscaleImage coarsestCoeffG = null;</span>
<span class="nc" id="L192">        GreyscaleImage coarsestCoeffB = null;</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
            GreyscaleImage input;
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L197">                input = rImg;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            } else if (i == 1) {</span>
<span class="nc" id="L199">                input = gImg;</span>
            } else {
<span class="nc" id="L201">                input = bImg;</span>
            }
<span class="nc" id="L203">            List&lt;GreyscaleImage&gt; transformed = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L204">            List&lt;GreyscaleImage&gt; coeffs = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L205">            wt.calculateWithB3SplineScalingFunction(input, transformed, coeffs);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L207">                coarsestCoeffR = coeffs.get(coeffs.size() - 1);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            } else if (i == 1) {</span>
<span class="nc" id="L209">                coarsestCoeffG = coeffs.get(coeffs.size() - 1);</span>
            } else {
<span class="nc" id="L211">                coarsestCoeffB = coeffs.get(coeffs.size() - 1);</span>
            }
        }

        //TODO: determine top limit by frequency distr?
<span class="nc" id="L216">        int limit = 3;</span>

<span class="nc" id="L218">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span>

<span class="nc" id="L220">        GreyscaleImage coarsestCombined = coarsestCoeffB.createWithDimensions();</span>

<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (int i = 0; i &lt; coarsestCoeffR.getNPixels(); ++i) {</span>
<span class="nc" id="L223">            int r = coarsestCoeffR.getValue(i);</span>
<span class="nc" id="L224">            int g = coarsestCoeffG.getValue(i);</span>
<span class="nc" id="L225">            int b = coarsestCoeffB.getValue(i);</span>
<span class="nc bnc" id="L226" title="All 6 branches missed.">            if (r &gt; limit || g &gt; limit || b &gt; limit) {</span>
<span class="nc" id="L227">                coarsestCombined.setValue(i, 250);</span>
<span class="nc" id="L228">                stack.add(Integer.valueOf(i));</span>
            }
        }

<span class="nc" id="L232">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L233">        int[] dys = Misc.dy8;</span>
<span class="nc" id="L234">        int w = coarsestCombined.getWidth();</span>
<span class="nc" id="L235">        int h = coarsestCombined.getHeight();</span>

<span class="nc" id="L237">        int lowerLimit = 0;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        while (limit &gt; lowerLimit) {</span>
            // use the canny edge 2-layer approach to pick up neighboring pixels
            // at or above a lower limit

<span class="nc" id="L242">            Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();</span>
<span class="nc" id="L243">            limit--;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            while (!stack.isEmpty()) {</span>
<span class="nc" id="L245">                Integer pixIndex = stack.pop();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                if (visited.contains(pixIndex)) {</span>
<span class="nc" id="L247">                    continue;</span>
                }
<span class="nc" id="L249">                int x = coarsestCombined.getCol(pixIndex.intValue());</span>
<span class="nc" id="L250">                int y = coarsestCombined.getRow(pixIndex.intValue());</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">                for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="nc" id="L252">                    int x2 = x + dxs[i];</span>
<span class="nc" id="L253">                    int y2 = y + dys[i];</span>
<span class="nc bnc" id="L254" title="All 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt; (w - 1) || y2 &gt; (h - 1)) {</span>
<span class="nc" id="L255">                        continue;</span>
                    }
<span class="nc" id="L257">                    int r = coarsestCoeffR.getValue(x2, y2);</span>
<span class="nc" id="L258">                    int g = coarsestCoeffG.getValue(x2, y2);</span>
<span class="nc" id="L259">                    int b = coarsestCoeffB.getValue(x2, y2);</span>
<span class="nc bnc" id="L260" title="All 6 branches missed.">                    if (r &gt; limit || g &gt; limit || b &gt; limit) {</span>
<span class="nc" id="L261">                        coarsestCombined.setValue(i, 250);</span>
<span class="nc" id="L262">                        stack.add(Integer.valueOf(i));</span>
                    }
                }
<span class="nc" id="L265">                visited.add(pixIndex);</span>
<span class="nc" id="L266">            }</span>
<span class="nc" id="L267">        }</span>

<span class="nc" id="L269">        return coarsestCombined;</span>
    }

    /**
     * segmentation algorithm using an a trous wavelet transform.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale5(GreyscaleImage input) {

<span class="fc" id="L280">        boolean use1D = false;</span>
<span class="fc" id="L281">        return createGreyscale5(input, use1D);</span>
    }

    /**
     * segmentation algorithm using an a trous wavelet transform.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale5(GreyscaleImage input, boolean use1D) {

<span class="fc" id="L292">        ATrousWaveletTransform wt = new ATrousWaveletTransform();</span>

<span class="fc" id="L294">        List&lt;GreyscaleImage&gt; transformed = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="fc" id="L295">        List&lt;GreyscaleImage&gt; coeffs = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (use1D) {</span>
<span class="nc" id="L298">            wt.calculateWithB3SplineScalingFunction(input, transformed, coeffs);</span>
        } else {
<span class="fc" id="L300">            wt.calculateWithB3SplineScalingFunction2(input, transformed, coeffs);</span>
        }

        /*
            for (int i = 0; i &lt; coeffs.size(); ++i) {
                GreyscaleImage img = coeffs.get(i);
                String str = &quot;coeff_&quot; + Integer.toString(i) + &quot;_&quot; +
                    MiscDebug.getCurrentTimeFormatted();
                MiscDebug.writeImage(img, str);
            }
        */

<span class="fc" id="L312">        GreyscaleImage coarsestCoeff = coeffs.get(coeffs.size() - 1);</span>

<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        int limit = use1D ? 2 : 1;</span>

<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (int i = 0; i &lt; coarsestCoeff.getNPixels(); ++i) {</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            if (coarsestCoeff.getValue(i) &gt; limit) {</span>
<span class="fc" id="L318">                coarsestCoeff.setValue(i, 250);</span>
            } else {
<span class="fc" id="L320">                coarsestCoeff.setValue(i, 0);</span>
            }
        }

<span class="fc" id="L324">        return coarsestCoeff;</span>
    }

    public GreyscaleImage createAWatershed(ImageExt input, String debugTag,
        int originalImageWidth, int originalImageHeight) {

<span class="nc" id="L330">        int w = input.getWidth();</span>
<span class="nc" id="L331">        int h = input.getHeight();</span>
<span class="nc" id="L332">        GreyscaleImage aImg = new GreyscaleImage(w, h,</span>
            GreyscaleImage.Type.Bits32FullRangeInt);

<span class="nc bnc" id="L335" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>

<span class="nc" id="L337">            float[] lab = input.getCIELAB(i);</span>

<span class="nc" id="L339">            aImg.setValue(i, Math.round(lab[1]));</span>

        }

<span class="nc" id="L343">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="nc" id="L345">        HistogramEqualization hEq = new HistogramEqualization(aImg);</span>
<span class="nc" id="L346">        hEq.applyFilter();</span>

<span class="nc" id="L348">        int minDimension = Math.min(originalImageWidth, originalImageHeight);</span>
        int lowerLimitSize;
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (minDimension &gt; 900) {</span>
<span class="nc" id="L351">            lowerLimitSize = 300;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        } else if (minDimension &lt; 200) {</span>
<span class="nc" id="L353">            lowerLimitSize = 100;</span>
        } else {
<span class="nc" id="L355">            lowerLimitSize = 200;</span>
        }

<span class="nc" id="L358">        imageProcessor.applyAdaptiveMeanThresholding(aImg, 1);</span>

<span class="nc" id="L360">        GreyscaleImage ws = imageProcessor.makeWatershedFromAdaptiveMedian(aImg);</span>

<span class="nc" id="L362">        return ws;</span>
    }

    /**
     * given the list of edges, populate the output arrays with color informaion
     * from the edge points and their 8 neighbor regions.
     * note that any points in more than one output list originally because of
     * being a junction, are corrected and placed in the most similar list.
     *
     * @param img
     * @param edges
     * @param junctions
     * @param outputPoints
     * @param outputDescripors access as [edgeListIndex][(h, s, v, nPix, cenX, cenY)]
     * @param clrSpace color space to fill the descriptors with: 0 is lab, 1 is hsv
     */
    private void populateEdgeLists(ImageExt img,
        List&lt;PairIntArray&gt; edges,
        List&lt;Set&lt;PairInt&gt;&gt; outputPoints, float[][] outputDescripors,
        int clrSpace) {

<span class="fc" id="L383">        int w = img.getWidth();</span>
<span class="fc" id="L384">        int h = img.getHeight();</span>

        // ----- gather edge points and their 8 neighbors into edge point sets ----

<span class="fc" id="L388">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L389">        int[] dys = Misc.dy8;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); ++i) {</span>
<span class="fc" id="L391">            PairIntArray edge = edges.get(i);</span>
<span class="fc" id="L392">            Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="fc" id="L394">                int x = edge.getX(j);</span>
<span class="fc" id="L395">                int y = edge.getY(j);</span>
<span class="fc" id="L396">                set.add(new PairInt(x, y));</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L398">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L399">                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L400" title="4 of 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || </span>
                        (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {
<span class="nc" id="L402">                        continue;</span>
                    }
<span class="fc" id="L404">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L405">                    set.add(p2);</span>
                }
            }
<span class="fc" id="L408">            outputPoints.add(set);</span>
        }

<span class="fc" id="L411">        float n = img.getNPixels();</span>

        // ----- calculate descriptors of the color and location of the edge points -----

<span class="fc" id="L415">        populateDescriptors(img, outputPoints, outputDescripors, clrSpace);</span>

        /*
        the descriptors are
             C_i = {h, s, v, nPix, cenX, cenY}  or labL, labA, labB for colorSpace = 0
        */

        // ======= correct for any points in more than one list ======

        // --- map the list indexes that a point is in --------
<span class="fc" id="L425">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; pointIndexes = new HashMap&lt;PairInt, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">        for (int i = 0; i &lt; outputPoints.size(); ++i) {</span>
<span class="fc" id="L428">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L429">            Set&lt;PairInt&gt; edgePoints = outputPoints.get(i);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">            for (PairInt p : edgePoints) {</span>
<span class="fc" id="L431">                Set&lt;Integer&gt; indexes = pointIndexes.get(p);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                if (indexes == null) {</span>
<span class="fc" id="L433">                    indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L434">                    pointIndexes.put(p, indexes);</span>
                }
<span class="fc" id="L436">                indexes.add(key);</span>
<span class="fc" id="L437">            }</span>
        }

<span class="fc" id="L440">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // ---- when a point is in more than one list, choose to keep it in the
        //      list with smallest difference from it in color and remove it from others.

<span class="fc bfc" id="L445" title="All 2 branches covered.">        for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="fc" id="L446">            Set&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if (indexes.size() == 1) {</span>
<span class="fc" id="L448">                continue;</span>
            }
<span class="fc" id="L450">            PairInt p = entry.getKey();</span>
<span class="fc" id="L451">            int x = p.getX();</span>
<span class="fc" id="L452">            int y = p.getY();</span>
            float c1, c2, c3;
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            if (clrSpace == 0) {</span>
<span class="fc" id="L455">                float[] lab = img.getCIELAB(x, y);</span>
<span class="fc" id="L456">                c1 = lab[0];</span>
<span class="fc" id="L457">                c2 = lab[1];</span>
<span class="fc" id="L458">                c3 = lab[2];</span>
<span class="fc" id="L459">            } else {</span>
                // hsv
<span class="nc" id="L461">                c1 = img.getHue(x, y);</span>
<span class="nc" id="L462">                c2 = img.getSaturation(x, y);</span>
<span class="nc" id="L463">                c3 = img.getBrightness(x, y);</span>
            }
<span class="fc" id="L465">            double minColorDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L466">            Integer minColorDiffIndex = null;</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
                //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L469">                float[] desc = outputDescripors[index.intValue()];</span>
                double diff;
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L472">                    diff = Math.abs(cieC.calcDeltaECIE2000(c1, c2, c3,</span>
                        desc[0], desc[1], desc[2]));
                } else {
<span class="nc" id="L475">                    double diff1 = c1 - desc[0];</span>
<span class="nc" id="L476">                    double diff2 = c2 - desc[1];</span>
<span class="nc" id="L477">                    double diff3 = c3 - desc[2];</span>
<span class="nc" id="L478">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }
<span class="fc bfc" id="L480" title="All 2 branches covered.">                if (diff &lt; minColorDiff) {</span>
<span class="fc" id="L481">                    minColorDiff = diff;</span>
<span class="fc" id="L482">                    minColorDiffIndex = index;</span>
                }
<span class="fc" id="L484">            }</span>
<span class="pc bpc" id="L485" title="3 of 4 branches missed.">            assert(minColorDiffIndex != null);</span>

            // update the lists to remove point
<span class="fc bfc" id="L488" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                if (index.equals(minColorDiffIndex)) {</span>
<span class="fc" id="L490">                    continue;</span>
                }

<span class="fc" id="L493">                Set&lt;PairInt&gt; set = outputPoints.get(index.intValue());</span>
<span class="fc" id="L494">                float nBefore = set.size();</span>
<span class="fc" id="L495">                set.remove(p);</span>
<span class="fc" id="L496">                float nAfter = set.size();</span>

                ////C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L499">                float[] desc = outputDescripors[index.intValue()];</span>
<span class="fc" id="L500">                desc[0] = ((desc[0] * nBefore) - c1)/nAfter;</span>
<span class="fc" id="L501">                desc[1] = ((desc[1] * nBefore) - c2)/nAfter;</span>
<span class="fc" id="L502">                desc[2] = ((desc[2] * nBefore) - c3)/nAfter;</span>
<span class="fc" id="L503">                desc[3] = nAfter;</span>
<span class="fc" id="L504">                desc[4] = ((desc[4] * nBefore) - x)/nAfter;</span>
<span class="fc" id="L505">                desc[5] = ((desc[5] * nBefore) - y)/nAfter;</span>
<span class="fc" id="L506">            }</span>
<span class="fc" id="L507">        }</span>
<span class="fc" id="L508">    }</span>

     /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf
     *
     * NOTE: parameters in this algorithm are sensitive to
     * the PSF.
     *
     * NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     *
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        String debugTag) {
        
        // 0 is CIE LAB, 1 is HSV
<span class="fc" id="L532">        final int clrSpace = 0;</span>

<span class="fc" id="L534">        boolean reduceNoise = false;</span>

        double tColor;
        int tLen;
        double tR;
        double tSmallMerge;
        if (clrSpace == 0) {
            // JND for deltaE is ~2.3, so tColor must be that or larger
<span class="fc" id="L542">            tColor = 2.8;//4.0;//5.5;</span>
<span class="fc" id="L543">            tR = 0.8;//1.0;</span>
<span class="fc" id="L544">            tLen = 1;</span>
<span class="fc" id="L545">            tSmallMerge = 0.02;//0.095;</span>
        } else {
            // what is JND for HSV (a.k.a. HSB) ?  each range of values is 0:1
            tColor =  0.125;//0.125;  between 0.1 and 0.175
            tR = 1.5;
            tLen = 5;
            tSmallMerge = 0.02;
        }

<span class="fc" id="L554">        return createColorEdgeSegmentation(input, clrSpace, tLen, tColor, tR,</span>
            reduceNoise, tSmallMerge, debugTag);
    }

    public List&lt;PairIntArray&gt; extractEdges(Image img,
        boolean reduceNoise, String debugTag) {

<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L562">            debugTag = &quot;&quot;;</span>
        }

<span class="nc" id="L565">        GreyscaleImage gsImg = img.copyBlueToGreyscale();</span>

<span class="nc" id="L567">        PhaseCongruencyDetector phaseDetector = new PhaseCongruencyDetector();</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (reduceNoise) {</span>
<span class="nc" id="L569">            phaseDetector.setK(5);</span>
        } else {
<span class="nc" id="L571">            phaseDetector.setK(2);</span>
        }
<span class="nc" id="L573">        PhaseCongruencyDetector.PhaseCongruencyProducts products =</span>
<span class="nc" id="L574">            phaseDetector.phaseCongMono(gsImg);</span>

        // thinned is in row major format
<span class="nc" id="L577">        int[][] thinned = products.getThinned();</span>
        {
<span class="nc" id="L579">            GreyscaleImage out2 = gsImg.createWithDimensions();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            for (int i = 0; i &lt; thinned.length; ++i) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                for (int j = 0; j &lt; thinned[i].length; ++j) {</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                    if (thinned[i][j] &gt; 0) {</span>
<span class="nc" id="L583">                        out2.setValue(j, i, 255);</span>
                    }
                }
            }
<span class="nc" id="L587">            MiscDebug.writeImage(out2, &quot;_EDGES_grey_&quot; + debugTag);</span>
        }

<span class="nc" id="L590">        EdgeExtractorSimple extractor = new EdgeExtractorSimple(thinned);</span>
<span class="nc" id="L591">        extractor.extractEdges();</span>
<span class="nc" id="L592">        List&lt;PairIntArray&gt; edges = new ArrayList&lt;PairIntArray&gt;();</span>
        // put in framework of images
<span class="nc bnc" id="L594" title="All 2 branches missed.">        for (int i = 0; i &lt; extractor.getEdges().size(); ++i) {</span>
<span class="nc" id="L595">            PairIntArray edge = extractor.getEdges().get(i).copy();</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="nc" id="L597">                int x = edge.getX(j);</span>
<span class="nc" id="L598">                int y = edge.getY(j);</span>
<span class="nc" id="L599">                edge.set(j, y, x);</span>
            }
<span class="nc" id="L601">            edges.add(edge);</span>
        }

<span class="nc" id="L604">        return edges;</span>
    }
    
    public List&lt;PairIntArray&gt; extractEdges2(Image img,
        String debugTag) {

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L611">            debugTag = &quot;&quot;;</span>
        }

<span class="fc" id="L614">        CannyEdgeFilterAdaptiveDeltaE2000 canny = </span>
            new CannyEdgeFilterAdaptiveDeltaE2000();
<span class="fc" id="L616">        canny.applyFilter(img.copyToImageExt());</span>

<span class="fc" id="L618">        GreyscaleImage gXY = canny.getFilterProducts().getGradientXY();</span>
        
<span class="fc" id="L620">        int w = gXY.getWidth();</span>
<span class="fc" id="L621">        int h = gXY.getHeight();</span>
        
<span class="pc bpc" id="L623" title="3 of 4 branches missed.">        assert(img.getWidth() == w);</span>
<span class="pc bpc" id="L624" title="3 of 4 branches missed.">        assert(img.getHeight() == h);</span>
        
<span class="fc" id="L626">        int[][] thinned = new int[w][];</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L628">            thinned[i] = new int[h];</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L630">                thinned[i][j] = gXY.getValue(i, j);</span>
            }
        }

<span class="fc" id="L634">        EdgeExtractorSimple extractor = new EdgeExtractorSimple(thinned);</span>
<span class="fc" id="L635">        extractor.extractEdges();</span>
<span class="fc" id="L636">        List&lt;PairIntArray&gt; edges = new ArrayList&lt;PairIntArray&gt;();</span>
        // put in framework of images
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (int i = 0; i &lt; extractor.getEdges().size(); ++i) {</span>
<span class="fc" id="L639">            PairIntArray edge = extractor.getEdges().get(i).copy();</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="fc" id="L641">                int x = edge.getX(j);</span>
<span class="fc" id="L642">                int y = edge.getY(j);</span>
<span class="fc" id="L643">                edge.set(j, x, y);</span>
            }
<span class="fc" id="L645">            edges.add(edge);</span>
        }

<span class="fc" id="L648">        return edges;</span>
    }

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf

     NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     * 
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        int clrSpace, int tLen, double tColor, double tR, boolean reduceNoise,
        double tSmallMerge, String debugTag) {

<span class="fc" id="L670">        List&lt;PairIntArray&gt; edges = extractEdges2(input, debugTag);</span>

        //List&lt;PairIntArray&gt; edges = extractEdges(input, reduceNoise, debugTag);
        
<span class="fc" id="L674">        return createColorEdgeSegmentation(input, edges,</span>
            clrSpace, tLen, tColor, tR, reduceNoise, tSmallMerge, debugTag);
    }

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf

     NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     * 
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        List&lt;PairIntArray&gt; edges,
        int clrSpace, int tLen, double tColor, double tR, boolean reduceNoise,
        double tSmallMerge, String debugTag) {

<span class="fc" id="L698">        boolean doPlot = false;</span>

<span class="pc bpc" id="L700" title="1 of 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L701">            debugTag = &quot;&quot;;</span>
        }

<span class="fc" id="L704">        final int w = input.getWidth();</span>
<span class="fc" id="L705">        final int h = input.getHeight();</span>
<span class="fc" id="L706">        final int nPix = input.getNPixels();</span>

<span class="fc" id="L708">        int nEdges = edges.size();</span>
<span class="fc" id="L709">        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if (nEdges == 0) {</span>
            // add all picels to one set
<span class="nc" id="L713">             Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L716">                    set.add(new PairInt(i, j));</span>
                }
            }
<span class="nc" id="L719">            clusterPoints.add(set);</span>
<span class="nc" id="L720">            return clusterPoints;</span>
        }

<span class="fc" id="L723">        float[][] clusterDescriptors = new float[nEdges][];</span>

<span class="fc" id="L725">        populateEdgeLists(input, edges, clusterPoints, clusterDescriptors,</span>
            clrSpace);

<span class="pc bpc" id="L728" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L730">        List&lt;Integer&gt; longEdgeIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L731">        List&lt;Integer&gt; shortEdgeIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L732">        populateEdgeLengthLists(clusterDescriptors, tLen, longEdgeIndexes,</span>
            shortEdgeIndexes);

<span class="pc bpc" id="L735" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

        // ----------- merge long edges ----------

        // NOTE that the moved sets modify the data structures :
        //    clusterPoints may contain empty items
        //    clusterDescriptors may contain null items
        //    both clusterPoints and clusterDescriptor non- null and non empty
        //       items are updated for merges

        // the authors consider this algorithm of min-heap merging within a
        // radius of color, a kmeans method as it updates the descriptors upon
        // each merge, but the minimum distance ordering is an improvement over
        // standard kmeans if one can use it as one can here
        // (pairs results in outer loop iteration of approx O(N^2),
        // specifically (N*(N-1)/2)), while kmeans ordering by index uses O(N))
<span class="fc" id="L751">        mergeEdges(clusterPoints, clusterDescriptors, clrSpace, tColor,</span>
            longEdgeIndexes);

        //TODO: consider a number limit to use an alternate here when
        //  n edges is a large number.  determine a fixed k and use kmeans.
        //  can roughly determine a fixed k from
        //  a color histogram with bin size being color tolerance
        //  and counting the number of peaks.

<span class="pc bpc" id="L760" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L764">            List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            for (Integer index : longEdgeIndexes) {</span>
<span class="nc" id="L766">                Set&lt;PairInt&gt; set = clusterPoints.get(index.intValue());</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">                if (!set.isEmpty()) {</span>
<span class="nc" id="L768">                    tmp.add(set);</span>
                }
<span class="nc" id="L770">            }</span>
<span class="nc" id="L771">            int nExtraForDot = 1;</span>
<span class="nc" id="L772">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L773">            ImageIOHelper.addAlternatingColorPointSetsToImage(tmp, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L775">            MiscDebug.writeImage(img2, &quot;_longEdges_merged_&quot; +  debugTag + &quot;_&quot;</span>
                + clrSpace);
        }

        // ---- merge short edges (which are usually textures) ------

<span class="fc" id="L781">        mergeShortEdges(clusterPoints, clusterDescriptors, clrSpace, tColor,</span>
            shortEdgeIndexes);

<span class="pc bpc" id="L784" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L788">            List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            for (Integer index : shortEdgeIndexes) {</span>
<span class="nc" id="L790">                Set&lt;PairInt&gt; set = clusterPoints.get(index.intValue());</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (!set.isEmpty()) {</span>
<span class="nc" id="L792">                    tmp.add(set);</span>
                }
<span class="nc" id="L794">            }</span>
<span class="nc" id="L795">            int nExtraForDot = 1;</span>
<span class="nc" id="L796">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L797">            ImageIOHelper.addAlternatingColorPointSetsToImage(tmp, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L799">            MiscDebug.writeImage(img2, &quot;_shortedges_merged_&quot; +  debugTag +</span>
                &quot;_&quot; + clrSpace);
        }

<span class="pc bpc" id="L803" title="3 of 4 branches missed.">        assert(assertDescriptorCounts(clusterPoints, clusterDescriptors));</span>

<span class="fc" id="L805">        Map&lt;PairInt, Integer&gt; pointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L807">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L808">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L810">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L811">            }</span>
        }

        // ------ region growing -------
<span class="fc" id="L815">        growEdges(input, clusterPoints, clusterDescriptors, pointIndexMap,</span>
            clrSpace, tColor, shortEdgeIndexes, longEdgeIndexes);

<span class="pc bpc" id="L818" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L820">        longEdgeIndexes = null;</span>
<span class="fc" id="L821">        shortEdgeIndexes = null;</span>

<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L825">            int nExtraForDot = 1;</span>
<span class="nc" id="L826">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L827">            ImageIOHelper.addAlternatingColorPointSetsToImage(clusterPoints, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L829">            MiscDebug.writeImage(img2, &quot;_after_rgo_&quot; +  debugTag + &quot;_&quot; + clrSpace);</span>
        }

        // ------ merge by color histograms ------

<span class="fc" id="L834">        clusterDescriptors = condenseAndUpdate(clusterPoints,</span>
            clusterDescriptors, pointIndexMap);

<span class="pc bpc" id="L837" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L839">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap = createAdjacencyMap(</span>
            clusterPoints);

<span class="fc" id="L842">        mergeByColorHistograms(input, clusterPoints, adjacencyMap,</span>
            clrSpace, tR);

<span class="pc bpc" id="L845" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L849">            int nExtraForDot = 1;</span>
<span class="nc" id="L850">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L851">            ImageIOHelper.addAlternatingColorPointSetsToImage(clusterPoints, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L853">            MiscDebug.writeImage(img2, &quot;_FINAL_&quot; +  debugTag + &quot;_&quot; + clrSpace);</span>
        }

        // ----- merge smallest clusters into adjacent larger --------
<span class="fc" id="L857">        int tNumber = (int)Math.round(tSmallMerge * nPix);</span>

<span class="fc" id="L859">        clusterDescriptors = condenseAndUpdate(clusterPoints,</span>
            clusterDescriptors, pointIndexMap);

<span class="pc bpc" id="L862" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L864">        mergeSmallClusters(input, clusterPoints, clusterDescriptors,</span>
            clrSpace, tNumber, debugTag);

<span class="pc bpc" id="L867" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L869">        return clusterPoints;</span>
    }

    private void populateEdgeLengthLists(float[][] clusterDescriptors,
        int tLen, List&lt;Integer&gt; longEdgeIndexes,
        List&lt;Integer&gt; shortEdgeIndexes) {

        //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc bfc" id="L877" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterDescriptors.length; ++i) {</span>
<span class="fc" id="L878">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L879">            float nPix = clusterDescriptors[i][3];</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">            if (nPix &lt; tLen) {</span>
<span class="nc" id="L881">                shortEdgeIndexes.add(key);</span>
            } else {
<span class="fc" id="L883">                longEdgeIndexes.add(key);</span>
            }
        }
<span class="fc" id="L886">    }</span>

    private void populateColorDiffHeap(
        float[][] clusterDescriptors, int clrSpace,
        List&lt;Integer&gt; longEdgeIndexes, Heap longEdgesHeap,
        long heapKeyFactor, Map&lt;PairInt, HeapNode&gt; pairEdgePindexNodes) {

        // for heap nodes:
        //     key is the difference in color times a factor to use long instead of double
        //     data is the PairInt holding the indexes compared

<span class="fc" id="L897">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc bfc" id="L899" title="All 2 branches covered.">        for (int i = 0; i &lt; longEdgeIndexes.size(); ++i) {</span>

<span class="fc" id="L901">            int idx1 = longEdgeIndexes.get(i).intValue();</span>
<span class="fc" id="L902">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="fc bfc" id="L904" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; longEdgeIndexes.size(); ++j) {</span>

<span class="fc" id="L906">                int idx2 = longEdgeIndexes.get(j).intValue();</span>
<span class="fc" id="L907">                float[] desc2 = clusterDescriptors[idx2];</span>

                double diff;
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L911">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L915">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L916">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L917">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L918">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

                // note that idx1 is always smaller than idx2
<span class="fc" id="L922">                PairInt p12 = new PairInt(idx1, idx2);</span>

<span class="fc" id="L924">                long heapKey = (long)((double)heapKeyFactor * diff);</span>
<span class="fc" id="L925">                HeapNode node = new HeapNode(heapKey);</span>
<span class="fc" id="L926">                node.setData(p12);</span>

<span class="fc" id="L928">                longEdgesHeap.insert(node);</span>

<span class="fc" id="L930">                pairEdgePindexNodes.put(p12, node);</span>
            }
        }
<span class="fc" id="L933">    }</span>

    /**
     * expecting binary image input where a pixel of value &quot;1&quot; is significant.
     * if any of the pixels in gapsOf1 are completely surrounded by
     * pixels of value &quot;1&quot; in their 8 pixel neighborhood,
     * those gap pixels are set to &quot;0&quot;.
     * 
     * @param img binary image
     * @param gapsOf1 pixel indexes of filled in gaps (pixels set to &quot;1&quot;)
     * @param value 
     */
    public void restoreGapsOf1WhereSurrounded(GreyscaleImage img,
        TIntSet gapsOf1, int value) {
        
<span class="nc" id="L948">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L949">        int[] dys = Misc.dy8;</span>
<span class="nc" id="L950">        int w = img.getWidth();</span>
<span class="nc" id="L951">        int h = img.getHeight();</span>
<span class="nc" id="L952">        TIntSet reset = new TIntHashSet();</span>
        
<span class="nc" id="L954">        TIntIterator iter = gapsOf1.iterator();</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L956">            int pixIdx = iter.next();</span>
<span class="nc" id="L957">            int y = pixIdx/w;</span>
<span class="nc" id="L958">            int x = pixIdx - (y * w);</span>
<span class="nc" id="L959">            int n1s = 0;</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L961">                int x2 = x + dxs[k];</span>
<span class="nc" id="L962">                int y2 = y + dys[k];</span>
<span class="nc bnc" id="L963" title="All 8 branches missed.">                if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L964">                    continue;</span>
                }
<span class="nc bnc" id="L966" title="All 2 branches missed.">                if (img.getValue(x2, y2) == 1) {</span>
<span class="nc" id="L967">                    n1s++;</span>
                }
            }
<span class="nc bnc" id="L970" title="All 2 branches missed.">            if (n1s == dxs.length) {</span>
<span class="nc" id="L971">                reset.add(pixIdx);</span>
            }
<span class="nc" id="L973">        }</span>
<span class="nc" id="L974">        iter = reset.iterator();</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L976">            int pixIdx = iter.next();</span>
<span class="nc" id="L977">            img.setValue(pixIdx, 0);</span>
<span class="nc" id="L978">        } </span>
        
<span class="nc" id="L980">    }</span>

    /**
     * expecting binary image input where a pixel of value &quot;1&quot; is significant.
     * The algorithm is similar to dilation, in that if any pixel has
     * a gap of size 1 pixel in between itself and another, that gap is
     * set to value 0 and stored in outputAddedGaps.
     * 
     * @param img
     * @param outputAddedGaps
     * @param value
     * @return 
     */
    public GreyscaleImage fillInGapsOf1(GreyscaleImage img,
        TIntSet outputAddedGaps, int value) {

<span class="nc" id="L996">        int w = img.getWidth();</span>
<span class="nc" id="L997">        int h = img.getHeight();</span>

        /*
        0  1  2
        7     3
        6  5  4
        fill in !value if these pairs are filled in:
            0:3, 0:4, 0:5
            1:4, 1:5, 1:6
            2:5, 2:6, 2:7
            3:6, 3:7, 3:0
            4:7
        so a +1 and -1 in x or y and a +1 or -1 in y or x
        */
<span class="nc" id="L1011">        int[] dxs0 = new int[]{-1, -1, -1,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1};</span>
<span class="nc" id="L1012">        int[] dys0 = new int[]{+1, +1, +1,  1,  1,  1,  1,  1,  1,  0,  0,  0, -1};</span>
<span class="nc" id="L1013">        int[] dxs1 = new int[]{1,  +1,  0,  1,  0, -1,  0, -1, -1, -1, -1, -1, -1};</span>
<span class="nc" id="L1014">        int[] dys1 = new int[]{0,  -1, -1, -1, -1, -1, -1, -1,  0, -1,  0,  1,  0};</span>

<span class="nc" id="L1016">        GreyscaleImage tmpImg2 = img.copyImage();</span>

<span class="nc bnc" id="L1018" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="nc" id="L1021">                int v = img.getValue(i, j);</span>

<span class="nc bnc" id="L1023" title="All 2 branches missed.">                if (v == value) {</span>
<span class="nc" id="L1024">                    continue;</span>
                }

<span class="nc bnc" id="L1027" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs0.length; ++k) {</span>
<span class="nc" id="L1028">                    int x1 = i + dxs0[k];</span>
<span class="nc" id="L1029">                    int y1 = j + dys0[k];</span>
<span class="nc bnc" id="L1030" title="All 8 branches missed.">                    if (x1 &lt; 0 || (x1 &gt; (w - 1)) || y1 &lt; 0 || (y1 &gt; (h - 1))) {</span>
<span class="nc" id="L1031">                        continue;</span>
                    }
<span class="nc" id="L1033">                    int v1 = img.getValue(x1, y1);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                    if (v1 != value) {</span>
<span class="nc" id="L1035">                        continue;</span>
                    }
<span class="nc" id="L1037">                    int x2 = i + dxs1[k];</span>
<span class="nc" id="L1038">                    int y2 = j + dys1[k];</span>
<span class="nc bnc" id="L1039" title="All 8 branches missed.">                    if (x2 &lt; 0 || (x2 &gt; (w - 1)) || y2 &lt; 0 || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L1040">                        continue;</span>
                    }
<span class="nc" id="L1042">                    int v2 = img.getValue(x2, y2);</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                    if (v2 != value) {</span>
<span class="nc" id="L1044">                        continue;</span>
                    }
<span class="nc" id="L1046">                    tmpImg2.setValue(i, j, value);</span>
<span class="nc" id="L1047">                    int pixIdx = (j * w) + i;</span>
<span class="nc" id="L1048">                    outputAddedGaps.add(pixIdx);</span>
<span class="nc" id="L1049">                    break;</span>
                }
            }
        }

<span class="nc" id="L1054">        return tmpImg2;</span>
    }

    public GreyscaleImage fillInCompleteGapsOf1(GreyscaleImage img,
        TIntSet outputAddedGaps,int value) {

<span class="nc" id="L1060">        int w = img.getWidth();</span>
<span class="nc" id="L1061">        int h = img.getHeight();</span>

<span class="nc" id="L1063">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L1064">        int[] dys = Misc.dy8;</span>

<span class="nc" id="L1066">        GreyscaleImage tmpImg2 = img.copyImage();</span>

<span class="nc" id="L1068">        int nIter = 0;</span>
<span class="nc" id="L1069">        int nChanged = 0;</span>
<span class="nc" id="L1070">        int nMaxIter = 5;</span>
<span class="nc bnc" id="L1071" title="All 6 branches missed.">        while ((nIter == 0) || ((nChanged &gt; 0) &amp;&amp; (nIter &lt; nMaxIter))) {</span>
<span class="nc" id="L1072">            nChanged = 0;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">            for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L1075">                    int v = img.getValue(i, j);</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                    if (v == value) {</span>
<span class="nc" id="L1077">                        continue;</span>
                    }
<span class="nc" id="L1079">                    int count = 0;</span>
<span class="nc" id="L1080">                    int neighborCount = 0;</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L1082">                        int x2 = i + dxs[k];</span>
<span class="nc" id="L1083">                        int y2 = j + dys[k];</span>
<span class="nc bnc" id="L1084" title="All 8 branches missed.">                        if (x2 &lt; 0 || (x2 &gt; (w - 1)) || y2 &lt; 0 || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L1085">                            continue;</span>
                        }
<span class="nc" id="L1087">                        count++;</span>
<span class="nc" id="L1088">                        int v1 = img.getValue(x2, y2);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                        if (v1 != value) {</span>
<span class="nc" id="L1090">                            continue;</span>
                        }
<span class="nc" id="L1092">                        neighborCount++;</span>
                    }
<span class="nc bnc" id="L1094" title="All 2 branches missed.">                    if (count == neighborCount) {</span>
<span class="nc" id="L1095">                        tmpImg2.setValue(i, j, value);</span>
<span class="nc" id="L1096">                        int pixIdx = (j * w) + i;</span>
<span class="nc" id="L1097">                        outputAddedGaps.add(pixIdx);</span>
<span class="nc" id="L1098">                        nChanged++;</span>
                    }
                }
            }
<span class="nc" id="L1102">            nIter++;</span>
        }

<span class="nc" id="L1105">        return tmpImg2;</span>
    }

    GreyscaleImage shrinkBy1(GreyscaleImage img, int edgeValue, int nonEdgeValue) {

<span class="nc" id="L1110">        int w = img.getWidth();</span>
<span class="nc" id="L1111">        int h = img.getHeight();</span>

        /*
         any pixel with neighbors that are not edgeValue can be removed
         */
<span class="nc" id="L1116">        PairInt[][] neighborCoordOffsets</span>
<span class="nc" id="L1117">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
                0, 0);

<span class="nc" id="L1120">        GreyscaleImage tmpImg2 = img.copyImage();</span>
<span class="nc" id="L1121">        int[] dxs0 = Misc.dx8;</span>
<span class="nc" id="L1122">        int[] dys0 = Misc.dy8;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L1125">                int v = img.getValue(i, j);</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                if (v != edgeValue) {</span>
<span class="nc" id="L1127">                    continue;</span>
                }
<span class="nc" id="L1129">                int nEmptyNeigbhors = 0;</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs0.length; ++k) {</span>
<span class="nc" id="L1131">                    int x1 = i + dxs0[k];</span>
<span class="nc" id="L1132">                    int y1 = j + dys0[k];</span>
<span class="nc bnc" id="L1133" title="All 8 branches missed.">                    if (x1 &lt; 0 || (x1 &gt; (w - 1)) || y1 &lt; 0 || (y1 &gt; (h - 1))) {</span>
<span class="nc" id="L1134">                        continue;</span>
                    }
<span class="nc" id="L1136">                    int v2 = img.getValue(x1, y1);</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">                    if (v2 != edgeValue) {</span>
<span class="nc" id="L1138">                        nEmptyNeigbhors++;</span>
                    }
                }

<span class="nc bnc" id="L1142" title="All 2 branches missed.">                if (nEmptyNeigbhors &gt; 0</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">                    &amp;&amp; !doesDisconnect(tmpImg2, neighborCoordOffsets, i, j, edgeValue)) {</span>
<span class="nc" id="L1144">                    tmpImg2.setValue(i, j, nonEdgeValue);</span>
                }
            }
        }

<span class="nc" id="L1149">        return tmpImg2;</span>
    }

    private void invertImage(GreyscaleImage img) {
<span class="nc bnc" id="L1153" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L1154">            int v = img.getValue(i);</span>
<span class="nc" id="L1155">            img.setValue(i, 255 - v);</span>
        }
<span class="nc" id="L1157">    }</span>
    private void setAllNonZeroTo255(GreyscaleImage img) {
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L1160">            int v = img.getValue(i);</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (v &gt; 0) {</span>
<span class="nc" id="L1162">                img.setValue(i, 255);</span>
            }
        }
<span class="nc" id="L1165">    }</span>

    private void removeIsolatedPixels(GreyscaleImage img, int pixValue,
        int pixNullValue, boolean use8Neighbors) {

        int[] dxs, dys;
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        if (use8Neighbors) {</span>
<span class="nc" id="L1172">            dxs = Misc.dx8;</span>
<span class="nc" id="L1173">            dys = Misc.dy8;</span>
        } else {
<span class="nc" id="L1175">            dxs = Misc.dx4;</span>
<span class="nc" id="L1176">            dys = Misc.dy4;</span>
        }

<span class="nc" id="L1179">        int w = img.getWidth();</span>
<span class="nc" id="L1180">        int h = img.getHeight();</span>

<span class="nc bnc" id="L1182" title="All 2 branches missed.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">            for (int y = 0; y &lt; h; ++y) {</span>
<span class="nc" id="L1184">                int v = img.getValue(x, y);</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">                if (v != pixValue) {</span>
<span class="nc" id="L1186">                    continue;</span>
                }
<span class="nc" id="L1188">                int count = 0;</span>
<span class="nc" id="L1189">                int nSame = 0;</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L1191">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L1192">                    int y2 = y + dys[k];</span>
<span class="nc bnc" id="L1193" title="All 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) ||</span>
                        (y2 &gt; (h - 1))) {
<span class="nc" id="L1195">                        continue;</span>
                    }
<span class="nc" id="L1197">                    count++;</span>
<span class="nc" id="L1198">                    int v2 = img.getValue(x2, y2);</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">                    if (v2 == pixValue) {</span>
<span class="nc" id="L1200">                        nSame++;</span>
<span class="nc" id="L1201">                        break;</span>
                    }
                }
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                if (nSame == 0) {</span>
<span class="nc" id="L1205">                    img.setValue(x, y, pixNullValue);</span>
                }
            }
        }
<span class="nc" id="L1209">    }</span>

    /**
     * check whether a neighbor belongs to another edge (NOTE that the bounds
     * have to have been checked before this)
     * @param x
     * @param y
     * @param edgeIndexMap
     * @param hN
     * @return
     */
    private boolean foundAdjacentEdge(int x, int y, Map&lt;PairInt, Integer&gt;
        edgeIndexMap, Integer index, int hN) {

<span class="nc bnc" id="L1223" title="All 2 branches missed.">        for (int dy = -hN; dy &lt;= hN; ++dy) {</span>
<span class="nc" id="L1224">            int y2 = y + dy;</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">            for (int dx = -hN; dx &lt;= hN; ++dx) {</span>
<span class="nc" id="L1226">                int x2 = x + dx;</span>
<span class="nc" id="L1227">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc" id="L1228">                Integer index2 = edgeIndexMap.get(p2);</span>
<span class="nc bnc" id="L1229" title="All 4 branches missed.">                if ((index2 != null) &amp;&amp; !index2.equals(index)) {</span>
<span class="nc" id="L1230">                    return true;</span>
                }
            }
        }
<span class="nc" id="L1234">        return false;</span>
    }

    private boolean aMemberIsOutOfBounds(int x, int y, int hN, int w, int h) {

<span class="nc bnc" id="L1239" title="All 2 branches missed.">        for (int dy = -hN; dy &lt;= hN; ++dy) {</span>
<span class="nc" id="L1240">            int y2 = y + dy;</span>
<span class="nc bnc" id="L1241" title="All 4 branches missed.">            if ((y2 &lt; 0) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L1242">                return true;</span>
            }
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            for (int dx = -hN; dx &lt;= hN; ++dx) {</span>
<span class="nc" id="L1245">                int x2 = x + dx;</span>
<span class="nc bnc" id="L1246" title="All 4 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (w - 1))) {</span>
<span class="nc" id="L1247">                    return true;</span>
                }
            }
        }

<span class="nc" id="L1252">        return false;</span>
    }

    private int countNeighbors(Map&lt;PairInt, Integer&gt; pointMap, int x, int y) {

<span class="nc" id="L1257">        int count = 0;</span>
<span class="nc" id="L1258">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L1259">        int[] dys = Misc.dy8;</span>

<span class="nc bnc" id="L1261" title="All 2 branches missed.">        for (int jj = 0; jj &lt; dxs.length; ++jj) {</span>
<span class="nc" id="L1262">            PairInt p3 = new PairInt(x + dxs[jj], y + dys[jj]);</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">            if (pointMap.containsKey(p3)) {</span>
<span class="nc" id="L1264">                count++;</span>
            }
        }

<span class="nc" id="L1268">        return count;</span>
    }

    private void mergeEdges(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, int clrSpace, double tColor,
        List&lt;Integer&gt; edgeIndexes) {

<span class="fc" id="L1275">        log.fine(edgeIndexes.size() + &quot; edges&quot;);</span>

<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">        if (edgeIndexes.isEmpty()) {</span>
<span class="nc" id="L1278">            return;</span>
        }

<span class="fc" id="L1281">        final long heapKeyFactor = 1000000l;</span>
<span class="fc" id="L1282">        Heap heap = new Heap();</span>
<span class="fc" id="L1283">        Map&lt;PairInt, HeapNode&gt; pairEdgePindexNodes = new HashMap&lt;PairInt, HeapNode&gt;();</span>
<span class="fc" id="L1284">        populateColorDiffHeap(clusterDescriptors, clrSpace,</span>
            edgeIndexes, heap, heapKeyFactor, pairEdgePindexNodes);

        // ---- make a map to find and update merged data structures ------
<span class="fc" id="L1288">        Map&lt;Integer, Set&lt;Integer&gt;&gt; indexToIndexMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        for (PairInt p : pairEdgePindexNodes.keySet()) {</span>

<span class="fc" id="L1291">            Integer index1 = Integer.valueOf(p.getX());</span>
<span class="fc" id="L1292">            Integer index2 = Integer.valueOf(p.getY());</span>

<span class="fc" id="L1294">            Set&lt;Integer&gt; indexes = indexToIndexMap.get(index1);</span>
<span class="fc bfc" id="L1295" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L1296">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1297">                indexToIndexMap.put(index1, indexes);</span>
            }
<span class="fc" id="L1299">            indexes.add(index2);</span>

<span class="fc" id="L1301">            indexes = indexToIndexMap.get(index2);</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L1303">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1304">                indexToIndexMap.put(index2, indexes);</span>
            }
<span class="fc" id="L1306">            indexes.add(index1);</span>
<span class="fc" id="L1307">        }</span>

<span class="fc" id="L1309">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="pc bpc" id="L1311" title="1 of 2 branches missed.">        while (!heap.isEmpty()) {</span>

<span class="fc" id="L1313">            HeapNode node = heap.extractMin();</span>
<span class="fc" id="L1314">            double diff = ((double)node.getKey())/((double)heapKeyFactor);</span>

<span class="fc bfc" id="L1316" title="All 2 branches covered.">            if (diff &gt; tColor) {</span>
<span class="fc" id="L1317">                break;</span>
            }

<span class="fc" id="L1320">            PairInt p12 = (PairInt)node.getData();</span>

<span class="fc" id="L1322">            int idx1 = p12.getX();</span>
<span class="fc" id="L1323">            int idx2 = p12.getY();</span>

<span class="fc" id="L1325">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="fc" id="L1326">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>

<span class="pc bpc" id="L1328" title="2 of 4 branches missed.">            if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="nc" id="L1329">                continue;</span>
            }

<span class="fc bfc" id="L1332" title="All 2 branches covered.">            if (set2.size() &gt; set1.size()) {</span>
<span class="fc" id="L1333">                idx1 = p12.getY();</span>
<span class="fc" id="L1334">                idx2 = p12.getX();</span>
<span class="fc" id="L1335">                set1 = set2;</span>
<span class="fc" id="L1336">                set2 = clusterPoints.get(idx2);</span>
            }

            // set1 is largest

<span class="fc" id="L1341">            Integer index1 = Integer.valueOf(idx1);</span>
<span class="fc" id="L1342">            Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L1344">            float[] desc1 = clusterDescriptors[idx1];</span>
<span class="fc" id="L1345">            float[] desc2 = clusterDescriptors[idx2];</span>
<span class="fc" id="L1346">            float n1 = set1.size();</span>
<span class="fc" id="L1347">            float n2 = set2.size();</span>
<span class="fc" id="L1348">            float nTot = n1 + n2;</span>

<span class="pc bpc" id="L1350" title="3 of 4 branches missed.">            assert(Math.abs(n1 - desc1[3]) &lt; 0.1);</span>
<span class="pc bpc" id="L1351" title="3 of 4 branches missed.">            assert(Math.abs(n2 - desc2[3]) &lt; 0.1);</span>

            //{h, s, v, nPix, cenX, cenY}
            // update desc1 contents for contents in desc2
<span class="fc bfc" id="L1355" title="All 2 branches covered.">            for (int k = 0; k &lt; desc1.length; ++k) {</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">                if (k == 3) {</span>
<span class="fc" id="L1357">                    desc1[k] = nTot;</span>
                } else {
<span class="fc" id="L1359">                    desc1[k] = ((desc1[k] * n1) + (desc2[k] * n2)) / nTot;</span>
                }
            }
<span class="fc" id="L1362">            clusterDescriptors[idx2] = null;</span>
<span class="fc" id="L1363">            set1.addAll(set2);</span>
<span class="fc" id="L1364">            set2.clear();</span>

<span class="fc" id="L1366">            n1 = set1.size();</span>

            // remove the idx1 --&gt; set&lt;integer&gt; pairs from map and heap
            // remove the idx2 --&gt; set&lt;integer&gt; pairs from map and heap

<span class="fc" id="L1371">            Set&lt;Integer&gt; indexes3 = indexToIndexMap.get(index1);</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L1373">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1374">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L1375" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L1376">                    continue;</span>
                }
                //keys in pairEdgePindexNodes have smaller index in x
                PairInt p13;
<span class="fc bfc" id="L1380" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L1381">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L1383">                    p13 = new PairInt(idx3, idx1);</span>
                }
<span class="fc" id="L1385">                HeapNode node3 = pairEdgePindexNodes.get(p13);</span>
<span class="pc bpc" id="L1386" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L1387">                heap.remove(node3);</span>
<span class="fc" id="L1388">                pairEdgePindexNodes.remove(p13);</span>
<span class="fc" id="L1389">            }</span>

<span class="fc" id="L1391">            indexes3 = indexToIndexMap.get(index2);</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L1393">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1394">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="fc bfc" id="L1395" title="All 4 branches covered.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="fc" id="L1396">                    continue;</span>
                }
                PairInt p23;
<span class="fc bfc" id="L1399" title="All 2 branches covered.">                if (idx2 &lt; idx3) {</span>
<span class="fc" id="L1400">                    p23 = new PairInt(idx2, idx3);</span>
                } else {
<span class="fc" id="L1402">                    p23 = new PairInt(idx3, idx2);</span>
                }
<span class="fc" id="L1404">                HeapNode node3 = pairEdgePindexNodes.get(p23);</span>
<span class="pc bpc" id="L1405" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L1406">                heap.remove(node3);</span>
<span class="fc" id="L1407">                pairEdgePindexNodes.remove(p23);</span>
<span class="fc" id="L1408">            }</span>

            // update the indexToIndexMap
<span class="fc" id="L1411">            Set&lt;Integer&gt; iim = new HashSet&lt;Integer&gt;(indexToIndexMap.get(index2));</span>
<span class="fc bfc" id="L1412" title="All 2 branches covered.">            for (Integer index3 : iim) {</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">                if (!index3.equals(index1)) {</span>
<span class="fc" id="L1414">                    Set&lt;Integer&gt; indexes4 = indexToIndexMap.get(index3);</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">                    if (indexes4 != null) {</span>
<span class="fc" id="L1416">                        indexes4.remove(index2);</span>
<span class="fc" id="L1417">                        indexes4.add(index1);</span>
                    }
                }
<span class="fc" id="L1420">            }</span>
<span class="fc" id="L1421">            indexes3.addAll(iim);</span>
<span class="fc" id="L1422">            indexes3.remove(index2);</span>
<span class="fc" id="L1423">            indexToIndexMap.remove(index2);</span>

            // add node for updated idx1 ---&gt; set&lt;integer&gt; to map and node
<span class="fc" id="L1426">            indexes3 = indexToIndexMap.get(Integer.valueOf(idx1));</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L1428">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1429">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L1430" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L1431">                    continue;</span>
                }
                //keys in pairEdgePindexNodes have smaller index in x
                PairInt p13;
<span class="fc bfc" id="L1435" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L1436">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L1438">                    p13 = new PairInt(idx3, idx1);</span>
                }

<span class="fc" id="L1441">                float[] desc3 = clusterDescriptors[idx3];</span>

                double diffUpdated;
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L1445">                    diffUpdated = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc3[0], desc3[1], desc3[2]));
                } else {
<span class="nc" id="L1449">                    double diff1 = desc1[0] - desc3[0];</span>
<span class="nc" id="L1450">                    double diff2 = desc1[1] - desc3[1];</span>
<span class="nc" id="L1451">                    double diff3 = desc1[2] - desc3[2];</span>
<span class="nc" id="L1452">                    diffUpdated = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

<span class="fc" id="L1455">                long heapKey = (long)((double)heapKeyFactor * diffUpdated);</span>
<span class="fc" id="L1456">                HeapNode node3 = new HeapNode(heapKey);</span>
<span class="fc" id="L1457">                node3.setData(p13);</span>
<span class="fc" id="L1458">                heap.insert(node3);</span>
<span class="fc" id="L1459">                pairEdgePindexNodes.put(p13, node3);</span>
<span class="fc" id="L1460">            }</span>

            // pairs having set2 will be skipped because of the empty set at beginning of while loop
<span class="fc" id="L1463">        }</span>
<span class="fc" id="L1464">    }</span>

    private void growEdges(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors,
        Map&lt;PairInt, Integer&gt; pointIndexMap, int clrSpace, double tColor,
        List&lt;Integer&gt; shortEdgeIndexes, List&lt;Integer&gt; longEdgeIndexes) {

<span class="pc bpc" id="L1472" title="1 of 2 branches missed.">        if (pointIndexMap.isEmpty()) {</span>
<span class="nc" id="L1473">            return;</span>
        }

        /*
        traverse all image points to make a map of unassigned pixels and the
            cluster indexes they are adjacent to if any.
            --&gt; O(N)

        initialize an outer queue with the unassigned which have nIndexes &gt; 0
           sorted by descending number of adjacenct indexes
           --&gt; O(N_i * lg2(N_i))

        create an inner queue

        --&gt; O(|V| + |E|)
        visit each outer queue member, adding it to adjacent cluster
           which has most similar color.
           update the cluster's descriptor
           add each of the 8 neighbors which aren't assigned to the inner
              queue.
           add the point to the visited set.
        when all outer queue members have been visited, fill the outer queue
            with the inner queue and empty the inner queue.
            (could sort again here for more precise growing)
        continue in this manner until the inner queue is empty and hence outer
            queue is empty.
            assert that visited.size == unassigned map.size

        The same pattern should be applied elsewhere too
        */

        // for each edge, add neighbors with diff &lt; tColor
        //    if an adjacent pixel is part of a short edge cluster,
        //    then all of that short edge is added to the cluster

        // removing short edge points from pointIndexMap and creating
        // shortPointIndexMap to more easily add them as a whole
<span class="fc" id="L1510">        Map&lt;PairInt, Integer&gt; shortPointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">        for (Integer index : shortEdgeIndexes) {</span>
<span class="nc" id="L1512">            int idx = index.intValue();</span>
<span class="nc" id="L1513">            Set&lt;PairInt&gt; set = clusterPoints.get(idx);</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L1515">                shortPointIndexMap.put(p, index);</span>
<span class="nc" id="L1516">                pointIndexMap.remove(p);</span>
<span class="nc" id="L1517">            }</span>
<span class="nc" id="L1518">        }</span>

<span class="fc" id="L1520">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L1522">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1523">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1525">        int width = img.getWidth();</span>
<span class="fc" id="L1526">        int height = img.getHeight();</span>

        /*
        on first iteration, the edge regions are grown to include adjacent points
        that are within tColor tolerance and short edges which are ajacent
        regardless of color difference.

        on second iteration, unassigned pixels are added to adjacent indexes
        most similar in color.
        */

<span class="fc" id="L1537">        int lastInnerQ = 0;</span>

<span class="fc bfc" id="L1539" title="All 2 branches covered.">        for (int nIter = 0; nIter &lt; 2; ++nIter) {</span>

<span class="fc" id="L1541">            Map&lt;PairInt, Set&lt;Integer&gt;&gt; unassignedAndIndexes =</span>
<span class="fc" id="L1542">                findUnassignedPixelsAndAdjacentIndexes(img, pointIndexMap);</span>

<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">            if (unassignedAndIndexes.isEmpty()) {</span>
<span class="nc" id="L1545">                return;</span>
            }

<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">            assert(img.getNPixels() == (unassignedAndIndexes.size() +</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">                pointIndexMap.size()));</span>

<span class="fc" id="L1551">            int count = 0;</span>
<span class="fc bfc" id="L1552" title="All 2 branches covered.">            for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry : unassignedAndIndexes.entrySet()) {</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">                if (entry.getValue().size() &gt; 0) {</span>
<span class="fc" id="L1554">                    ++count;</span>
                }
<span class="fc" id="L1556">            }</span>
<span class="fc" id="L1557">            PairInt[] unassigned = new PairInt[count];</span>
<span class="fc" id="L1558">            int[] nAdjIndexes = new int[unassigned.length];</span>
<span class="fc" id="L1559">            count = 0;</span>
            for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry :
<span class="fc bfc" id="L1561" title="All 2 branches covered.">                unassignedAndIndexes.entrySet()) {</span>
<span class="fc bfc" id="L1562" title="All 2 branches covered.">                if (entry.getValue().size() &gt; 0) {</span>
<span class="fc" id="L1563">                    unassigned[count] = entry.getKey();</span>
<span class="fc" id="L1564">                    nAdjIndexes[count] = entry.getValue().size();</span>
<span class="fc" id="L1565">                    ++count;</span>
                }
<span class="fc" id="L1567">            }</span>
<span class="fc" id="L1568">            QuickSort.sortBy1stArg(nAdjIndexes, unassigned);</span>
<span class="fc" id="L1569">            ArrayDeque&lt;PairInt&gt; outerQueue = new ArrayDeque&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1570" title="All 2 branches covered.">            for (int i = (unassigned.length - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1571">                outerQueue.add(unassigned[i]);</span>
            }

<span class="fc" id="L1574">            ArrayDeque&lt;PairInt&gt; innerQueue = new ArrayDeque&lt;PairInt&gt;();</span>
            while (true) {
<span class="fc bfc" id="L1576" title="All 2 branches covered.">                while (!outerQueue.isEmpty()) {</span>
<span class="fc" id="L1577">                    PairInt p = outerQueue.poll();</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">                    if (pointIndexMap.containsKey(p)) {</span>
<span class="fc" id="L1579">                        continue;</span>
                    }
<span class="fc" id="L1581">                    int x = p.getX();</span>
<span class="fc" id="L1582">                    int y = p.getY();</span>
<span class="fc" id="L1583">                    boolean isAShortEdge = shortPointIndexMap.containsKey(p);</span>
                    float[] clrs1;
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">                    if (isAShortEdge) {</span>
<span class="nc" id="L1586">                        clrs1 = clusterDescriptors[shortPointIndexMap.get(p).intValue()];</span>
                    } else {
<span class="fc" id="L1588">                        clrs1 = getColors(img, x, y, clrSpace);</span>
                    }

<span class="fc" id="L1591">                    double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L1592">                    Integer minDiffIndex = null;</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1594">                        int x2 = x + dxs[k];</span>
<span class="fc" id="L1595">                        int y2 = y + dys[k];</span>
<span class="fc bfc" id="L1596" title="All 8 branches covered.">                        if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (width - 1))</span>
                            || (y2 &gt; (height - 1))) {
<span class="fc" id="L1598">                            continue;</span>
                        }
<span class="fc" id="L1600">                        PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L1601">                        Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L1602" title="All 2 branches covered.">                        if (index2 == null) {</span>
<span class="fc" id="L1603">                            continue;</span>
                        } else {
<span class="pc bpc" id="L1605" title="3 of 4 branches missed.">                            if (isAShortEdge &amp;&amp; index2.equals(shortPointIndexMap.get(p))) {</span>
<span class="nc" id="L1606">                                continue;</span>
                            }
<span class="pc bpc" id="L1608" title="1 of 2 branches missed.">                            if (clusterPoints.get(index2.intValue()).isEmpty()) {</span>
<span class="nc" id="L1609">                                continue;</span>
                            }
                        }
<span class="fc" id="L1612">                        float[] desc2 = clusterDescriptors[index2.intValue()];</span>
                        double diff;
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">                        if (clrSpace == 0) {</span>
<span class="fc" id="L1615">                            diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                                clrs1[0], clrs1[1], clrs1[2], desc2[0], desc2[1], desc2[2]));
                        } else {
<span class="nc" id="L1618">                            double diff1 = clrs1[0] - desc2[0];</span>
<span class="nc" id="L1619">                            double diff2 = clrs1[1] - desc2[1];</span>
<span class="nc" id="L1620">                            double diff3 = clrs1[2] - desc2[2];</span>
<span class="nc" id="L1621">                            diff = Math.sqrt(diff1 * diff1 + diff2 * diff2 + diff3 * diff3);</span>
                        }
<span class="pc bpc" id="L1623" title="1 of 6 branches missed.">                        if ((nIter == 0) &amp;&amp; !isAShortEdge &amp;&amp; (diff &gt; tColor)) {</span>
<span class="fc" id="L1624">                            continue;</span>
                        }
<span class="fc bfc" id="L1626" title="All 2 branches covered.">                        if (diff &lt; minDiff) {</span>
<span class="fc" id="L1627">                            minDiff = diff;</span>
<span class="fc" id="L1628">                            minDiffIndex = index2;</span>
                        }
                    }
<span class="fc bfc" id="L1631" title="All 2 branches covered.">                    if (minDiffIndex == null) {</span>
<span class="fc" id="L1632">                        continue;</span>
                    }
<span class="fc" id="L1634">                    int idx2 = minDiffIndex.intValue();</span>
<span class="fc" id="L1635">                    Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="fc" id="L1636">                    float[] desc2 = clusterDescriptors[idx2];</span>
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">                    if (isAShortEdge) {</span>
<span class="nc" id="L1638">                        Integer index1 = shortPointIndexMap.get(p);</span>
<span class="nc" id="L1639">                        int idx1 = index1.intValue();</span>
<span class="nc" id="L1640">                        Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="nc" id="L1641">                        float[] desc1 = clusterDescriptors[idx1];</span>
<span class="nc" id="L1642">                        float n1 = set1.size();</span>
<span class="nc" id="L1643">                        float n2 = set2.size();</span>
<span class="nc" id="L1644">                        float nTot = n1 + n2;</span>
                        //{h, s, v, nPix, cenX, cenY}
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                        for (int k = 0; k &lt; 6; ++k) {</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                            if (k == 3) {</span>
<span class="nc" id="L1648">                                desc2[k] = nTot;</span>
                            } else {
<span class="nc" id="L1650">                                desc2[k] = ((desc2[k] * n2) + desc1[k] * n1)/nTot;</span>
                            }
                        }
                        //add unassigned perimeter of short edge to innerqueue
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                        for (PairInt p3 : set1) {</span>
<span class="nc" id="L1655">                            shortPointIndexMap.remove(p3);</span>
<span class="nc" id="L1656">                            pointIndexMap.put(p3, minDiffIndex);</span>
<span class="nc" id="L1657">                            set2.add(p3);</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">                            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L1659">                                int x4 = p3.getX() + dxs[k];</span>
<span class="nc" id="L1660">                                int y4 = p3.getY() + dys[k];</span>
<span class="nc bnc" id="L1661" title="All 8 branches missed.">                                if (x4 &lt; 0 || y4 &lt; 0 || (x4 &gt; (width - 1))</span>
                                    || (y4 &gt; (height - 1))) {
<span class="nc" id="L1663">                                    continue;</span>
                                }
<span class="nc" id="L1665">                                PairInt p4 = new PairInt(x4, y4);</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                                if (!shortPointIndexMap.containsKey(p4) &amp;&amp;</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">                                    !pointIndexMap.containsKey(p4)) {</span>
<span class="nc" id="L1668">                                    innerQueue.offer(p4);</span>
                                }
                            }
<span class="nc" id="L1671">                        }</span>
<span class="nc" id="L1672">                        clusterDescriptors[idx1] = null;</span>
<span class="nc" id="L1673">                        set1.clear();</span>
<span class="nc" id="L1674">                    } else {</span>
<span class="fc" id="L1675">                        float n2 = set2.size();</span>
<span class="fc" id="L1676">                        float nTot = n2 + 1;</span>
                        //{h, s, v, nPix, cenX, cenY}
<span class="fc" id="L1678">                        desc2[0] = ((desc2[0] * n2) + clrs1[0])/nTot;</span>
<span class="fc" id="L1679">                        desc2[1] = ((desc2[1] * n2) + clrs1[1])/nTot;</span>
<span class="fc" id="L1680">                        desc2[2] = ((desc2[2] * n2) + clrs1[2])/nTot;</span>
<span class="fc" id="L1681">                        desc2[3] = nTot;</span>
<span class="fc" id="L1682">                        desc2[4] = ((desc2[4] * n2) + x)/nTot;</span>
<span class="fc" id="L1683">                        desc2[5] = ((desc2[5] * n2) + y)/nTot;</span>

<span class="fc" id="L1685">                        pointIndexMap.put(p, minDiffIndex);</span>
<span class="fc" id="L1686">                        set2.add(p);</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">                        for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1688">                            int x4 = x + dxs[k];</span>
<span class="fc" id="L1689">                            int y4 = y + dys[k];</span>
<span class="fc bfc" id="L1690" title="All 8 branches covered.">                            if (x4 &lt; 0 || y4 &lt; 0 || (x4 &gt; (width - 1))</span>
                                || (y4 &gt; (height - 1))) {
<span class="fc" id="L1692">                                continue;</span>
                            }
<span class="fc" id="L1694">                            PairInt p4 = new PairInt(x4, y4);</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">                            if (!shortPointIndexMap.containsKey(p4) &amp;&amp;</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">                                !pointIndexMap.containsKey(p4)) {</span>
<span class="fc" id="L1697">                                innerQueue.offer(p4);</span>
                            }
                        }
                    }
<span class="fc" id="L1701">                }</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">                if (innerQueue.isEmpty()) {</span>
<span class="fc bfc" id="L1703" title="All 2 branches covered.">                    if (nIter == 0) {</span>
<span class="fc" id="L1704">                        break;</span>
                    }
<span class="pc bpc" id="L1706" title="1 of 2 branches missed.">                    if (!shortPointIndexMap.isEmpty()) {</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">                        if (shortPointIndexMap.size() == lastInnerQ) {</span>
<span class="nc" id="L1708">                            return;</span>
                        }
<span class="nc" id="L1710">                        innerQueue.addAll(shortPointIndexMap.keySet());</span>
<span class="nc" id="L1711">                        lastInnerQ = shortPointIndexMap.size();</span>
                    } else {
<span class="fc" id="L1713">                        lastInnerQ = 0;</span>
<span class="fc" id="L1714">                        break;</span>
                    }
                }
<span class="fc" id="L1717">                outerQueue.addAll(innerQueue);</span>
<span class="fc" id="L1718">                innerQueue.clear();</span>
            }
        }

<span class="pc bpc" id="L1722" title="3 of 4 branches missed.">        assert(assertShortEdgesAreEmpty(shortEdgeIndexes, clusterPoints));</span>

<span class="pc bpc" id="L1724" title="3 of 4 branches missed.">        assert(pointIndexMap.size() == img.getNPixels());</span>
<span class="fc" id="L1725">    }</span>

    private void mergeShortEdges(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, int clrSpace, double tColor,
        List&lt;Integer&gt; shortEdgeIndexes) {

        /*
        the paper suggests:
            &quot;The pair of lines where the distance of centroids between them is
            nearest is always merged into one if their color difference is not
            exceeding the predefined threshold Tc.&quot;

        this is only merging a single pair at most for every short edge
        */

        //TODO: consider improvements of this for large shortEdgeIndexes.size()

<span class="fc" id="L1742">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">        for (int i = 0; i &lt; shortEdgeIndexes.size(); ++i) {</span>

<span class="nc" id="L1746">            Integer index1 = shortEdgeIndexes.get(i);</span>
<span class="nc" id="L1747">            int idx1 = index1.intValue();</span>
<span class="nc" id="L1748">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">            if (set1.isEmpty()) {</span>
<span class="nc" id="L1750">                continue;</span>
            }

<span class="nc" id="L1753">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="nc bnc" id="L1755" title="All 4 branches missed.">            assert(Math.abs(set1.size() - desc1[3]) &lt; 0.1);</span>

<span class="nc" id="L1757">            double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1758">            int minDistIdx = -1;</span>

<span class="nc bnc" id="L1760" title="All 2 branches missed.">            for (int j = (i + 1); j &lt; shortEdgeIndexes.size(); ++j) {</span>

<span class="nc" id="L1762">                Integer index2 = shortEdgeIndexes.get(j);</span>
<span class="nc" id="L1763">                int idx2 = index2.intValue();</span>
<span class="nc" id="L1764">                Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">                if (set2.isEmpty()) {</span>
<span class="nc" id="L1766">                    continue;</span>
                }

                //{h, s, v, nPix, cenX, cenY}
<span class="nc" id="L1770">                float[] desc2 = clusterDescriptors[idx2];</span>

<span class="nc bnc" id="L1772" title="All 4 branches missed.">                assert(Math.abs(set2.size() - desc2[3]) &lt; 0.1);</span>

                double diff;
<span class="nc bnc" id="L1775" title="All 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="nc" id="L1776">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L1780">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L1781">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L1782">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L1783">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

<span class="nc bnc" id="L1786" title="All 2 branches missed.">                if (diff &gt;= tColor) {</span>
<span class="nc" id="L1787">                    continue;</span>
                }

<span class="nc" id="L1790">                float diffX = desc1[4] - desc2[4];</span>
<span class="nc" id="L1791">                float diffY = desc1[5] - desc2[5];</span>
<span class="nc" id="L1792">                double distSq = diffX * diffX + diffY * diffY;</span>

<span class="nc bnc" id="L1794" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L1795">                    minDistSq = distSq;</span>
<span class="nc" id="L1796">                    minDistIdx = idx2;</span>
                }
            }

<span class="nc bnc" id="L1800" title="All 2 branches missed.">            if (minDistIdx == -1) {</span>
<span class="nc" id="L1801">                continue;</span>
            }

            // merge set2 with set1 and update associated data structures
<span class="nc" id="L1805">            Set&lt;PairInt&gt; set2 = clusterPoints.get(minDistIdx);</span>
<span class="nc" id="L1806">            float[] desc2 = clusterDescriptors[minDistIdx];</span>

<span class="nc" id="L1808">            float n1 = set1.size();</span>
<span class="nc" id="L1809">            float n2 = set2.size();</span>
<span class="nc" id="L1810">            float nTot = n1 + n2;</span>

            //{h, s, v, nPix, cenX, cenY}
            // update desc1 contents for contents in desc2
<span class="nc bnc" id="L1814" title="All 2 branches missed.">            for (int k = 0; k &lt; desc1.length; ++k) {</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">                if (k == 3) {</span>
<span class="nc" id="L1816">                    desc1[k] = nTot;</span>
                } else {
<span class="nc" id="L1818">                    desc1[k] = ((desc1[k] * n1) + (desc2[k] * n2)) / nTot;</span>
                }
            }
<span class="nc" id="L1821">            clusterDescriptors[minDistIdx] = null;</span>
<span class="nc" id="L1822">            set1.addAll(set2);</span>
<span class="nc" id="L1823">            set2.clear();</span>
        }
<span class="fc" id="L1825">    }</span>

    /**
     * get cie lab or hsv colors from img for coordinates (x, y)
     * @param img
     * @param x
     * @param y
     * @param clrSpace
     * @return
     */
    private float[] getColors(ImageExt img, int x, int y, int clrSpace) {

<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        if (clrSpace == 0) {</span>
<span class="fc" id="L1838">            float[] lab2 = img.getCIELAB(x, y);</span>
<span class="fc" id="L1839">            return lab2;</span>
        } else {
<span class="nc" id="L1841">            float[] hsv = new float[3];</span>
<span class="nc" id="L1842">            hsv[0] = img.getHue(x, y);</span>
<span class="nc" id="L1843">            hsv[1] = img.getSaturation(x, y);</span>
<span class="nc" id="L1844">            hsv[2] = img.getBrightness(x, y);</span>
<span class="nc" id="L1845">            return hsv;</span>
        }
    }

    private boolean assertDescriptorCounts(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors) {

<span class="nc bnc" id="L1852" title="All 2 branches missed.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="nc" id="L1853">            int n = clusterPoints.get(i).size();</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">            if (n == 0) { continue;}</span>
<span class="nc" id="L1855">            float diff = Math.abs(n - clusterDescriptors[i][3]);</span>
<span class="nc bnc" id="L1856" title="All 4 branches missed.">            assert(diff &lt; 0.1);</span>
        }

<span class="nc" id="L1859">        return true;</span>
    }

    private void mergeByColorHistograms(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap,
        int clrSpace, double tR) {

<span class="fc" id="L1867">        int[][][] colorHistograms = calculateColorHistograms(input,</span>
            clusterPoints, clrSpace);

        // key is index1, index2 where index1 &lt; index2
<span class="fc" id="L1871">        Map&lt;PairInt, HeapNode&gt; nodesMap = new HashMap&lt;PairInt, HeapNode&gt;();</span>

<span class="fc" id="L1873">        Heap heap = new Heap();</span>

<span class="fc" id="L1875">        ColorHistogram ch = new ColorHistogram();</span>

        // the histogram intersection range of values
        //   is 0 : nColors * 1
        // so for 3 colors, expect that max similarity is 3.0.
        // need to merge by higher similarity, so need to invert
        //   the keys.
        // 3 - similairty bcomes the new key.
        // a tR of 0.7*3.0 = 2.1 becomes 0.9 and any values larger than
        //    that are less similar...smalled values are more similar
<span class="fc" id="L1885">        double tRInv = 3.0 - tR;</span>

<span class="fc" id="L1887">        long heapKeyFactor = input.getNPixels();</span>

<span class="fc bfc" id="L1889" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>

<span class="fc" id="L1891">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L1892">            int idx1 = index1.intValue();</span>

<span class="fc" id="L1894">            int[][] hist1 = colorHistograms[idx1];</span>
<span class="pc bpc" id="L1895" title="3 of 4 branches missed.">            assert(hist1 != null);</span>

<span class="fc" id="L1897">            Set&lt;Integer&gt; indexes2 = entry.getValue();</span>

<span class="fc bfc" id="L1899" title="All 2 branches covered.">            for (Integer index2 : indexes2) {</span>

<span class="fc" id="L1901">                int idx2 = index2.intValue();</span>

<span class="pc bpc" id="L1903" title="3 of 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p12;
<span class="fc bfc" id="L1905" title="All 2 branches covered.">                if (idx1 &lt; idx2) {</span>
<span class="fc" id="L1906">                    p12 = new PairInt(idx1, idx2);</span>
                } else {
<span class="fc" id="L1908">                    p12 = new PairInt(idx2, idx1);</span>
                }

<span class="fc bfc" id="L1911" title="All 2 branches covered.">                if (nodesMap.containsKey(p12)) {</span>
<span class="fc" id="L1912">                    continue;</span>
                }

<span class="fc" id="L1915">                int[][] hist2 = colorHistograms[index2.intValue()];</span>
<span class="pc bpc" id="L1916" title="3 of 4 branches missed.">                assert(hist2 != null);</span>

<span class="fc" id="L1918">                float similarity = 3.0f - ch.intersection(hist1, hist2);</span>

<span class="fc" id="L1920">                long key = (long)(similarity * (double)heapKeyFactor);</span>
<span class="fc" id="L1921">                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L1922">                node.setData(p12);</span>
<span class="fc" id="L1923">                heap.insert(node);</span>
<span class="fc" id="L1924">                nodesMap.put(p12, node);</span>

<span class="pc bpc" id="L1926" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L1927">            }</span>
<span class="fc" id="L1928">        }</span>

<span class="fc" id="L1930">        int nMerged = 0;</span>

<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">        while(!heap.isEmpty()) {</span>

<span class="fc" id="L1934">            HeapNode node = heap.extractMin();</span>

<span class="fc" id="L1936">            PairInt p12 = (PairInt)node.getData();</span>

<span class="fc" id="L1938">            nodesMap.remove(p12);</span>

            // this is 3.0 - similarity
<span class="fc" id="L1941">            double diff = ((double)node.getKey())/((double)heapKeyFactor);</span>

<span class="fc bfc" id="L1943" title="All 2 branches covered.">            if (diff &gt; tRInv) {</span>
<span class="fc" id="L1944">                break;</span>
            }

<span class="fc" id="L1947">            int idx1 = p12.getX();</span>
<span class="fc" id="L1948">            int idx2 = p12.getY();</span>

<span class="fc" id="L1950">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="fc" id="L1951">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>

<span class="pc bpc" id="L1953" title="2 of 4 branches missed.">            if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="nc" id="L1954">                continue;</span>
            }

<span class="fc bfc" id="L1957" title="All 2 branches covered.">            if (set2.size() &gt; set1.size()) {</span>
<span class="fc" id="L1958">                idx1 = p12.getY();</span>
<span class="fc" id="L1959">                idx2 = p12.getX();</span>
<span class="fc" id="L1960">                set1 = set2;</span>
<span class="fc" id="L1961">                set2 = clusterPoints.get(idx2);</span>
            }

            // set1 is largest

<span class="fc" id="L1966">            int[][] hist1 = colorHistograms[idx1];</span>
<span class="fc" id="L1967">            ch.add2To1(hist1, colorHistograms[idx2]);</span>
<span class="fc" id="L1968">            colorHistograms[idx2] = null;</span>

<span class="fc" id="L1970">            float n1 = set1.size();</span>
<span class="fc" id="L1971">            float n2 = set2.size();</span>
<span class="fc" id="L1972">            float nTot = n1 + n2;</span>

<span class="fc" id="L1974">            set1.addAll(set2);</span>
<span class="fc" id="L1975">            set2.clear();</span>

<span class="fc" id="L1977">            Integer index1 = Integer.valueOf(idx1);</span>
<span class="fc" id="L1978">            Integer index2 = Integer.valueOf(idx2);</span>

            // remove the idx1 --&gt; set&lt;integer&gt; pairs from map and heap
            // remove the idx2 --&gt; set&lt;integer&gt; pairs from map and heap
            // update the adjacencyMap
            //   add node for updated idx1 ---&gt; set&lt;integer&gt; to map and node

<span class="fc" id="L1985">            Set&lt;Integer&gt; indexes1 = adjacencyMap.get(index1);</span>
<span class="fc bfc" id="L1986" title="All 2 branches covered.">            for (Integer index3 : indexes1) {</span>
<span class="fc" id="L1987">                int idx3 = index3.intValue();</span>
<span class="fc" id="L1988">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L1989" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L1990">                    continue;</span>
                }
                PairInt p13;
<span class="fc bfc" id="L1993" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L1994">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L1996">                    p13 = new PairInt(idx3, idx1);</span>
                }
<span class="fc" id="L1998">                HeapNode node3 = nodesMap.get(p13);</span>
<span class="pc bpc" id="L1999" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L2000">                heap.remove(node3);</span>
<span class="fc" id="L2001">                nodesMap.remove(p13);</span>
<span class="pc bpc" id="L2002" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L2003">            }</span>
<span class="fc" id="L2004">            Set&lt;Integer&gt; indexes2 = adjacencyMap.get(index2);</span>
<span class="fc bfc" id="L2005" title="All 2 branches covered.">            for (Integer index3 : indexes2) {</span>
<span class="fc" id="L2006">                int idx3 = index3.intValue();</span>
<span class="fc" id="L2007">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L2008" title="2 of 6 branches missed.">                if (set3.isEmpty() || idx1 == idx3 || idx2 == idx3) {</span>
<span class="nc" id="L2009">                    continue;</span>
                }
                PairInt p23;
<span class="fc bfc" id="L2012" title="All 2 branches covered.">                if (idx2 &lt; idx3) {</span>
<span class="fc" id="L2013">                    p23 = new PairInt(idx2, idx3);</span>
                } else {
<span class="fc" id="L2015">                    p23 = new PairInt(idx3, idx2);</span>
                }
<span class="fc" id="L2017">                HeapNode node3 = nodesMap.get(p23);</span>
<span class="pc bpc" id="L2018" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L2019">                heap.remove(node3);</span>
<span class="fc" id="L2020">                nodesMap.remove(p23);</span>
<span class="pc bpc" id="L2021" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L2022">            }</span>

            //update adjacency map
<span class="fc bfc" id="L2025" title="All 2 branches covered.">            for (Integer index3 : indexes2) {</span>
<span class="fc bfc" id="L2026" title="All 2 branches covered.">                if (!index3.equals(index1)) {</span>
<span class="fc" id="L2027">                    Set&lt;Integer&gt; indexes4 = adjacencyMap.get(index3);</span>
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">                    if (indexes4 != null) {</span>
<span class="fc" id="L2029">                        indexes4.remove(index2);</span>
<span class="fc" id="L2030">                        indexes4.add(index1);</span>
                    }
                }
<span class="fc" id="L2033">            }</span>
<span class="fc" id="L2034">            indexes1.addAll(indexes2);</span>
<span class="fc" id="L2035">            indexes1.remove(index1);</span>
<span class="fc" id="L2036">            indexes1.remove(index2);</span>
<span class="fc" id="L2037">            adjacencyMap.remove(index2);</span>

            // add nodes back into heap and map for the updated idx1 --&gt; set&lt;integer&gt;
<span class="fc bfc" id="L2040" title="All 2 branches covered.">            for (Integer index3 : indexes1) {</span>
<span class="fc" id="L2041">                int idx3 = index3.intValue();</span>
<span class="fc" id="L2042">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L2043" title="3 of 4 branches missed.">                assert(idx1 != idx3);</span>
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">                if (set3.isEmpty()) {</span>
<span class="nc" id="L2045">                    continue;</span>
                }
<span class="fc" id="L2047">                int[][] hist3 = colorHistograms[idx3];</span>
<span class="pc bpc" id="L2048" title="3 of 4 branches missed.">                assert(hist3 != null);</span>

                PairInt p13;
<span class="fc bfc" id="L2051" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L2052">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L2054">                    p13 = new PairInt(idx3, idx1);</span>
                }

<span class="fc" id="L2057">                float similarity3 = 3.0f - ch.intersection(hist1, hist3);</span>

<span class="fc" id="L2059">                long key3 = (long)(similarity3 * (double)heapKeyFactor);</span>
<span class="fc" id="L2060">                HeapNode node3 = new HeapNode(key3);</span>
<span class="fc" id="L2061">                node3.setData(p13);</span>

<span class="fc" id="L2063">                heap.insert(node3);</span>
<span class="fc" id="L2064">                nodesMap.put(p13, node3);</span>
<span class="pc bpc" id="L2065" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L2066">            }</span>

<span class="fc" id="L2068">            nMerged++;</span>
<span class="fc" id="L2069">        }</span>

<span class="fc" id="L2071">        log.fine(&quot;color histogram nMerged=&quot; + nMerged);</span>
<span class="fc" id="L2072">    }</span>

    public int[][][] calculateColorHistograms(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints, int clrSpace) {

        //0 == cie lab,  1 = hsv, 2 = rgb

<span class="fc" id="L2079">        int n = clusterPoints.size();</span>

<span class="fc" id="L2081">        int[][][] hist = new int[n][][];</span>

<span class="fc" id="L2083">        ColorHistogram ch = new ColorHistogram();</span>

<span class="fc bfc" id="L2085" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="fc" id="L2087">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>

<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">            if (set.isEmpty()) {</span>
<span class="nc" id="L2090">                continue;</span>
            }

<span class="pc bpc" id="L2093" title="1 of 2 branches missed.">            if (clrSpace == 0) {</span>
<span class="fc" id="L2094">                hist[i] = ch.histogramCIELAB(input, set);</span>
<span class="nc bnc" id="L2095" title="All 2 branches missed.">            } else if (clrSpace == 1) {</span>
<span class="nc" id="L2096">                hist[i] = ch.histogramHSV(input, set);</span>
<span class="pc bpc" id="L2097" title="1 of 2 branches missed.">            } if (clrSpace == 2) {</span>
<span class="nc" id="L2098">                hist[i] = ch.histogramRGB(input, set);</span>
            }
        }

<span class="fc" id="L2102">        return hist;</span>
    }

    private Map&lt;Integer, Set&lt;Integer&gt;&gt; createAdjacencyMap(List&lt;Set&lt;PairInt&gt;&gt;
        clusterPoints) {

<span class="fc" id="L2108">        Map&lt;PairInt, Integer&gt; pointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="fc bfc" id="L2110" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L2111">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L2112">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L2113" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L2114">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L2115">            }</span>
        }

<span class="fc" id="L2118">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L2119">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L2121">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L2123" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>

<span class="fc" id="L2125">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>

<span class="fc" id="L2127">            Set&lt;Integer&gt; indexes2 = new HashSet&lt;Integer&gt;();</span>

<span class="fc bfc" id="L2129" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L2130">                int x = p.getX();</span>
<span class="fc" id="L2131">                int y = p.getY();</span>
<span class="fc bfc" id="L2132" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L2133">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L2134">                    int y2 = y + dys[k];</span>
<span class="fc" id="L2135">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L2136">                    Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L2137" title="All 4 branches covered.">                    if (index2 == null || index2.intValue() == i) {</span>
<span class="fc" id="L2138">                        continue;</span>
                    }
<span class="fc" id="L2140">                    indexes2.add(index2);</span>
                }
<span class="fc" id="L2142">            }</span>

<span class="pc bpc" id="L2144" title="1 of 2 branches missed.">            if (indexes2.isEmpty()) {</span>
<span class="nc" id="L2145">                continue;</span>
            }

            // add these to all point sets in adjacency map

<span class="fc" id="L2150">            indexes2.add(Integer.valueOf(i));</span>

<span class="fc bfc" id="L2152" title="All 2 branches covered.">            for (Integer key : indexes2) {</span>
<span class="fc" id="L2153">                Set&lt;Integer&gt; v = new HashSet&lt;Integer&gt;(indexes2);</span>
<span class="fc" id="L2154">                v.remove(key);</span>

<span class="fc" id="L2156">                Set&lt;Integer&gt; mapV = adjMap.get(key);</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">                if (mapV == null) {</span>
<span class="fc" id="L2158">                    adjMap.put(key, v);</span>
                } else {
<span class="fc" id="L2160">                    mapV.addAll(v);</span>
                }
<span class="fc" id="L2162">            }</span>
        }

<span class="fc" id="L2165">        return adjMap;</span>
    }

    private Map&lt;PairInt, Set&lt;Integer&gt;&gt; findUnassignedPixelsAndAdjacentIndexes(
        ImageExt img, Map&lt;PairInt, Integer&gt; pointIndexMap) {

<span class="fc" id="L2171">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; unassignedAndIndexes =</span>
            new HashMap&lt;PairInt, Set&lt;Integer&gt;&gt;();

<span class="fc" id="L2174">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L2175">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L2177">        int w = img.getWidth();</span>
<span class="fc" id="L2178">        int h = img.getHeight();</span>

<span class="fc bfc" id="L2180" title="All 2 branches covered.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">            for (int y = 0; y &lt; h; ++y) {</span>
<span class="fc" id="L2182">                PairInt p = new PairInt(x, y);</span>
<span class="fc bfc" id="L2183" title="All 2 branches covered.">                if (pointIndexMap.containsKey(p)) {</span>
<span class="fc" id="L2184">                    continue;</span>
                }
<span class="fc" id="L2186">                Set&lt;Integer&gt; adjIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L2188">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L2189">                    int y2 = y + dys[k];</span>
<span class="fc" id="L2190">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L2191">                    Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">                    if (index2 != null) {</span>
<span class="fc" id="L2193">                        adjIndexes.add(index2);</span>
                    }
                }
<span class="fc" id="L2196">                unassignedAndIndexes.put(p, adjIndexes);</span>
            }
        }

<span class="pc bpc" id="L2200" title="3 of 4 branches missed.">        assert(pointIndexMap.size() + unassignedAndIndexes.size() == img.getNPixels());</span>

<span class="fc" id="L2202">        return unassignedAndIndexes;</span>
    }

    private void populateDescriptors(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; pointSets,
        float[][] outputDescripors, int clrSpace) {

        /*
        the descriptors are
             C_i = {h, s, v, nPix, cenX, cenY}  or labL, labA, labB for colorSpace = 0
        */
<span class="fc" id="L2213">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc bfc" id="L2215" title="All 2 branches covered.">        for (int i = 0; i &lt; pointSets.size(); ++i) {</span>

<span class="fc" id="L2217">            Set&lt;PairInt&gt; edgePoints = pointSets.get(i);</span>

<span class="fc" id="L2219">            outputDescripors[i] = new float[6];</span>

<span class="fc" id="L2221">            double[] xyCen = curveHelper.calculateXYCentroids(edgePoints);</span>

<span class="fc" id="L2223">            double c1Sum = 0;</span>
<span class="fc" id="L2224">            double c2Sum = 0;</span>
<span class="fc" id="L2225">            double c3Sum = 0;</span>
<span class="fc bfc" id="L2226" title="All 2 branches covered.">            for (PairInt p : edgePoints) {</span>

<span class="fc" id="L2228">                int x = p.getX();</span>
<span class="fc" id="L2229">                int y = p.getY();</span>

<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L2232">                    float[] lab = img.getCIELAB(x, y);</span>
<span class="fc" id="L2233">                    c1Sum += lab[0];</span>
<span class="fc" id="L2234">                    c2Sum += lab[1];</span>
<span class="fc" id="L2235">                    c3Sum += lab[2];</span>
<span class="fc" id="L2236">                } else {</span>
                    // hsv
<span class="nc" id="L2238">                    c1Sum += img.getHue(x, y);</span>
<span class="nc" id="L2239">                    c2Sum += img.getSaturation(x, y);</span>
<span class="nc" id="L2240">                    c3Sum += img.getBrightness(x, y);</span>
                }
<span class="fc" id="L2242">            }</span>
<span class="fc" id="L2243">            c1Sum /= (float)edgePoints.size();</span>
<span class="fc" id="L2244">            c2Sum /= (float)edgePoints.size();</span>
<span class="fc" id="L2245">            c3Sum /= (float)edgePoints.size();</span>

            //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L2248">            outputDescripors[i][0] = (float)c1Sum;</span>
<span class="fc" id="L2249">            outputDescripors[i][1] = (float)c2Sum;</span>
<span class="fc" id="L2250">            outputDescripors[i][2] = (float)c3Sum;</span>
<span class="fc" id="L2251">            outputDescripors[i][3] = edgePoints.size();</span>
<span class="fc" id="L2252">            outputDescripors[i][4] = (float)xyCen[0];</span>
<span class="fc" id="L2253">            outputDescripors[i][5] = (float)xyCen[1];</span>
        }
<span class="fc" id="L2255">    }</span>

    private float[][] condenseAndUpdate(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, Map&lt;PairInt, Integer&gt; pointIndexMap) {

<span class="fc" id="L2260">        int nNonNull = 0;</span>
<span class="fc bfc" id="L2261" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : clusterPoints) {</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L2263">                nNonNull++;</span>
            }
<span class="fc" id="L2265">        }</span>

<span class="fc" id="L2267">        List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="fc" id="L2269">        float[][] outputDescriptors = new float[nNonNull][];</span>

<span class="fc bfc" id="L2271" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L2272">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc bfc" id="L2273" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L2274">                outputDescriptors[tmp.size()] = clusterDescriptors[i];</span>
<span class="fc" id="L2275">                tmp.add(set);</span>
            }
        }
<span class="fc" id="L2278">        clusterPoints.clear();</span>
<span class="fc" id="L2279">        clusterPoints.addAll(tmp);</span>

<span class="fc" id="L2281">        pointIndexMap.clear();</span>
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L2283">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L2284">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L2285" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L2286">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L2287">            }</span>
        }

<span class="fc" id="L2290">        return outputDescriptors;</span>
    }

    private void mergeSmallClusters(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints, float[][] clusterDescriptors,
        int clrSpace, int tNumber, String debugTag) {

<span class="pc bpc" id="L2297" title="1 of 2 branches missed.">        if (clusterPoints.isEmpty()) {</span>
<span class="nc" id="L2298">            return;</span>
        }

<span class="fc" id="L2301">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap = createAdjacencyMap(</span>
            clusterPoints);

<span class="fc" id="L2304">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc bfc" id="L2306" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>

<span class="fc" id="L2308">            Integer index1 = entry.getKey();</span>

<span class="fc" id="L2310">            int idx1 = index1.intValue();</span>

<span class="fc" id="L2312">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>

<span class="pc bpc" id="L2314" title="1 of 4 branches missed.">            if ((set1.size() &gt; tNumber) || set1.isEmpty()) {</span>
<span class="nc" id="L2315">                continue;</span>
            }

<span class="fc" id="L2318">            Set&lt;Integer&gt; indexes2 = entry.getValue();</span>

            // merge with closest in color

<span class="fc" id="L2322">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="fc" id="L2324">            double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L2325">            Integer minDiffIndex = null;</span>

<span class="fc bfc" id="L2327" title="All 2 branches covered.">            for (Integer index2 : indexes2) {</span>
<span class="fc" id="L2328">                int idx2 = index2.intValue();</span>
<span class="fc" id="L2329">                Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">                if (set2.isEmpty()) {</span>
<span class="fc" id="L2331">                    continue;</span>
                }
<span class="fc" id="L2333">                float[] desc2 = clusterDescriptors[idx2];</span>
                double diff;
<span class="pc bpc" id="L2335" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L2336">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2], desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L2339">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L2340">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L2341">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L2342">                    diff = Math.sqrt(diff1 * diff1 + diff2 * diff2 + diff3 * diff3);</span>
                }
<span class="fc bfc" id="L2344" title="All 2 branches covered.">                if (diff &lt; minDiff) {</span>
<span class="fc" id="L2345">                    minDiff = diff;</span>
<span class="fc" id="L2346">                    minDiffIndex = index2;</span>
                }
<span class="fc" id="L2348">            }</span>

<span class="fc bfc" id="L2350" title="All 2 branches covered.">            if (minDiffIndex == null) {</span>
<span class="fc" id="L2351">                continue;</span>
            }
<span class="fc" id="L2353">            int idx2 = minDiffIndex.intValue();</span>
<span class="fc" id="L2354">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="pc bpc" id="L2355" title="3 of 4 branches missed.">            assert(!set2.isEmpty());</span>
<span class="fc" id="L2356">            float[] desc2 = clusterDescriptors[idx2];</span>
<span class="fc" id="L2357">            int n2 = set2.size();</span>
<span class="fc" id="L2358">            int n1 = set1.size();</span>
<span class="fc" id="L2359">            set2.addAll(set1);</span>
<span class="fc" id="L2360">            int nTot = set2.size();</span>
<span class="fc" id="L2361">            set1.clear();</span>

            //{h, s, v, nPix, cenX, cenY}
<span class="fc bfc" id="L2364" title="All 2 branches covered.">            for (int ii = 0; ii &lt; desc1.length; ++ii) {</span>
<span class="fc" id="L2365">                desc2[ii] = ((desc2[ii] * n2) - desc1[ii] * n1) / nTot;</span>
            }
<span class="fc" id="L2367">            desc2[3] = nTot;</span>

<span class="fc" id="L2369">            clusterDescriptors[idx1] = null;</span>
<span class="fc" id="L2370">        }</span>
<span class="fc" id="L2371">    }</span>

    /**
     * order the indexes by decreasing number of neighbors
     * within pixIndexes.
     * runtime complexity is max(O(N*log_2(N)), O(N*9)).
     * @param pixIndexes
     * @param imgWidth
     * @param imgHeight
     * @return
     */
    private ArrayDeque&lt;Integer&gt; populateByNumberOfNeighbors(
        TIntSet pixIndexes, int imgWidth, int imgHeight) {

<span class="nc" id="L2385">        int n = pixIndexes.size();</span>

<span class="nc" id="L2387">        ArrayDeque&lt;Integer&gt; output = new ArrayDeque&lt;Integer&gt;(n);</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L2389">            return output;</span>
        }

<span class="nc" id="L2392">        int[] idxs = new int[n];</span>
<span class="nc" id="L2393">        int[] nn = new int[n];</span>

<span class="nc" id="L2395">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L2396">        int[] dys = Misc.dy8;</span>

<span class="nc" id="L2398">        int count = 0;</span>
<span class="nc" id="L2399">        TIntIterator iter = pixIndexes.iterator();</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L2401">            int idx = iter.next();</span>
<span class="nc" id="L2402">            int y = idx/imgWidth;</span>
<span class="nc" id="L2403">            int x = idx - (y * imgWidth);</span>
<span class="nc" id="L2404">            int nc = 0;</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L2406">                int x2 = x + dxs[k];</span>
<span class="nc" id="L2407">                int y2 = y + dys[k];</span>
<span class="nc bnc" id="L2408" title="All 4 branches missed.">                if (x2 &lt; 0 || x2 &gt; (imgWidth - 1)) {</span>
<span class="nc" id="L2409">                    continue;</span>
                }
<span class="nc bnc" id="L2411" title="All 4 branches missed.">                if (y2 &lt; 0 || y2 &gt; (imgHeight - 1)) {</span>
<span class="nc" id="L2412">                    continue;</span>
                }
<span class="nc" id="L2414">                int pixIdx2 = (y2 * imgWidth) + x2;</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">                if (pixIndexes.contains(pixIdx2)) {</span>
<span class="nc" id="L2416">                    nc++;</span>
                }
            }
<span class="nc" id="L2419">            idxs[count] = idx;</span>
<span class="nc" id="L2420">            nn[count] = nc;</span>
<span class="nc" id="L2421">            count++;</span>
<span class="nc" id="L2422">        }</span>

<span class="nc" id="L2424">        MultiArrayMergeSort.sortByDecr(nn, idxs);</span>

<span class="nc bnc" id="L2426" title="All 2 branches missed.">        for (int i = 0; i &lt; nn.length; ++i) {</span>
<span class="nc" id="L2427">            output.add(Integer.valueOf(idxs[i]));</span>
        }

<span class="nc" id="L2430">        return output;</span>
    }

    private List&lt;GroupPixelRGB&gt; calculateRGB(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; sets) {

<span class="nc" id="L2436">        List&lt;GroupPixelRGB&gt; out = new ArrayList&lt;GroupPixelRGB&gt;();</span>

<span class="nc bnc" id="L2438" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : sets) {</span>
<span class="nc" id="L2439">            GroupPixelRGB gp = new GroupPixelRGB(set, input, 0, 0);</span>
<span class="nc" id="L2440">            out.add(gp);</span>
<span class="nc" id="L2441">        }</span>

<span class="nc" id="L2443">        return out;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; copy(
        List&lt;Set&lt;PairInt&gt;&gt; contiguousSets) {

<span class="nc" id="L2449">        List&lt;Set&lt;PairInt&gt;&gt; c = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">        for (int i = 0; i &lt; contiguousSets.size(); ++i) {</span>
<span class="nc" id="L2451">            Set&lt;PairInt&gt; set = contiguousSets.get(i);</span>
<span class="nc" id="L2452">            Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;(set);</span>
<span class="nc" id="L2453">            c.add(set2);</span>
        }

<span class="nc" id="L2456">        return c;</span>
    }

    public void mergeSmallSegments(ImageExt img,
        int[] labels, int sizeLimit, ColorSpace clrSpace) {

<span class="nc" id="L2462">        CIEChromaticity cieC = null;</span>
<span class="nc bnc" id="L2463" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2464">            cieC = new CIEChromaticity();</span>
        }

        //key = label, value = label indexes
<span class="nc" id="L2468">        TIntObjectMap&lt;TIntSet&gt; labelToIndexMap =</span>
<span class="nc" id="L2469">            LabelToColorHelper.createLabelIndexMap(labels);</span>

        // key = label, value = adjacent label indexes
<span class="nc" id="L2472">        TIntObjectMap&lt;TIntSet&gt; adjacencyMap =</span>
<span class="nc" id="L2473">            LabelToColorHelper.createAdjacencyLabelMap(</span>
                img, labels, false);

        //key = label, value = average color in clrSpace
<span class="nc" id="L2477">        TIntObjectMap&lt;Colors&gt; labelColorMap =</span>
            new TIntObjectHashMap&lt;Colors&gt;();

<span class="nc" id="L2480">        TIntObjectMap&lt;Colors&gt; labelRGBMap = new</span>
            TIntObjectHashMap&lt;Colors&gt;();

<span class="nc" id="L2483">        TIntSet merged = new TIntHashSet();</span>

        //labels
<span class="nc" id="L2486">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span>
<span class="nc" id="L2487">        TIntSet labelSet = labelToIndexMap.keySet();</span>
<span class="nc" id="L2488">        TIntIterator iter = labelSet.iterator();</span>
<span class="nc bnc" id="L2489" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L2490">            stack.add(Integer.valueOf(iter.next()));</span>
        }

<span class="nc" id="L2493">        int nSmall = 0;</span>
<span class="nc bnc" id="L2494" title="All 2 branches missed.">        while (!stack.isEmpty()) {</span>
<span class="nc" id="L2495">            int label1 = stack.pop().intValue();</span>
<span class="nc bnc" id="L2496" title="All 2 branches missed.">            if (merged.contains(label1)) {</span>
<span class="nc" id="L2497">                continue;</span>
            }

<span class="nc" id="L2500">            TIntSet set = labelToIndexMap.get(label1);</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">            if (set.size() &lt; sizeLimit) {</span>
<span class="nc" id="L2502">                nSmall++;</span>
                // merge w/ closest adjacent above sizeLimit
<span class="nc" id="L2504">                Colors clrs = labelColorMap.get(label1);</span>
<span class="nc" id="L2505">                Colors rgbClrs = labelRGBMap.get(label1);</span>
<span class="nc" id="L2506">                int minLabel = -1;</span>
<span class="nc" id="L2507">                double minDiff = Double.MAX_VALUE;</span>
<span class="nc" id="L2508">                Colors minDiffClrs = null;</span>
<span class="nc" id="L2509">                Colors minDiffRGBClrs = null;</span>

<span class="nc" id="L2511">                TIntSet adj = adjacencyMap.get(label1);</span>
<span class="nc bnc" id="L2512" title="All 2 branches missed.">                if (adj != null) {</span>
<span class="nc" id="L2513">                    TIntIterator iter2 = adj.iterator();</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">                    while (iter2.hasNext()) {</span>
<span class="nc" id="L2515">                        int label3 = iter2.next();</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">                        if (merged.contains(label3) ||</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">                            labelToIndexMap.get(label3).size() &lt; sizeLimit) {</span>
<span class="nc" id="L2518">                            continue;</span>
                        }
<span class="nc bnc" id="L2520" title="All 2 branches missed.">                        if (rgbClrs == null) {</span>
<span class="nc" id="L2521">                            rgbClrs = calculateSetColor(set, img,</span>
                                ColorSpace.RGB);
<span class="nc" id="L2523">                            clrs = calculateSetColor(rgbClrs, clrSpace);</span>
                        }
<span class="nc" id="L2525">                        Colors rgbClrs3 = labelRGBMap.get(label3);</span>
<span class="nc" id="L2526">                        Colors clrs3 = labelColorMap.get(label3);</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">                        if (rgbClrs3 == null) {</span>
<span class="nc" id="L2528">                            TIntSet set3 = labelToIndexMap.get(label3);</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">                            if (set3.size() &lt; sizeLimit) {</span>
<span class="nc" id="L2530">                                continue;</span>
                            }
<span class="nc" id="L2532">                            rgbClrs3 = calculateSetColor(set3, img,</span>
                                ColorSpace.RGB);
<span class="nc" id="L2534">                            labelRGBMap.put(label3, rgbClrs3);</span>
<span class="nc" id="L2535">                            clrs3 = calculateSetColor(rgbClrs3, clrSpace);</span>
<span class="nc" id="L2536">                            labelColorMap.put(label3, clrs3);</span>
                        }

<span class="nc" id="L2539">                        double diff = colorDiff(clrs, clrs3, clrSpace);</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">                        if (diff &lt; 0) {</span>
<span class="nc" id="L2541">                            diff *= -1;</span>
                        }
<span class="nc bnc" id="L2543" title="All 2 branches missed.">                        if (diff &lt; minDiff) {</span>
<span class="nc" id="L2544">                            minDiff = diff;</span>
<span class="nc" id="L2545">                            minLabel = label3;</span>
<span class="nc" id="L2546">                            minDiffClrs = clrs3;</span>
<span class="nc" id="L2547">                            minDiffRGBClrs = rgbClrs3;</span>
                        }
<span class="nc" id="L2549">                    }</span>
                }

<span class="nc bnc" id="L2552" title="All 2 branches missed.">                if (minLabel &gt; -1) {</span>

                    // merge this label's data into minLabel's data

                    //update adjacency maps
<span class="nc" id="L2557">                    TIntSet adjLabels1 = adjacencyMap.get(label1);</span>
<span class="nc" id="L2558">                    TIntIterator iter1 = adjLabels1.iterator();</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">                    while (iter1.hasNext()) {</span>
                        // change to adjacent to minLabel instead of label1
<span class="nc" id="L2561">                        int label3 = iter1.next();</span>
<span class="nc bnc" id="L2562" title="All 4 branches missed.">                        if (label3 == minLabel || label3 == label1) {</span>
<span class="nc" id="L2563">                            continue;</span>
                        }
<span class="nc" id="L2565">                        TIntSet adjLabels3 = adjacencyMap.get(label3);</span>
<span class="nc" id="L2566">                        adjLabels3.remove(label1);</span>
<span class="nc" id="L2567">                        adjLabels3.add(minLabel);</span>
<span class="nc" id="L2568">                    }</span>
<span class="nc" id="L2569">                    adjacencyMap.get(minLabel).addAll(adjLabels1);</span>
<span class="nc" id="L2570">                    adjacencyMap.get(minLabel).remove(label1);</span>

                    // reassign label1 indexes to minLabel
<span class="nc" id="L2573">                    TIntSet set1 = labelToIndexMap.get(label1);</span>
<span class="nc" id="L2574">                    float n1 = set.size();</span>
<span class="nc" id="L2575">                    float n2 = set1.size();</span>
<span class="nc" id="L2576">                    float nTot = n1 + n2;</span>
<span class="nc" id="L2577">                    iter1 = set1.iterator();</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">                    while (iter1.hasNext()) {</span>
<span class="nc" id="L2579">                        int lIdx = iter1.next();</span>
<span class="nc" id="L2580">                        labels[lIdx] = minLabel;</span>
<span class="nc" id="L2581">                    }</span>

                    // update color maps
<span class="nc" id="L2584">                    int r = Math.round((rgbClrs.getColors()[0]*n1 +</span>
<span class="nc" id="L2585">                        minDiffRGBClrs.getColors()[0]*n2)/nTot);</span>
<span class="nc" id="L2586">                    int g = Math.round((rgbClrs.getColors()[1]*n1 +</span>
<span class="nc" id="L2587">                        minDiffRGBClrs.getColors()[1]*n2)/nTot);</span>
<span class="nc" id="L2588">                    int b = Math.round((rgbClrs.getColors()[2]*n1 +</span>
<span class="nc" id="L2589">                        minDiffRGBClrs.getColors()[2]*n2)/nTot);</span>
<span class="nc" id="L2590">                    minDiffRGBClrs.getColors()[0] = r;</span>
<span class="nc" id="L2591">                    minDiffRGBClrs.getColors()[1] = g;</span>
<span class="nc" id="L2592">                    minDiffRGBClrs.getColors()[2] = b;</span>
<span class="nc bnc" id="L2593" title="All 2 branches missed.">                    if (ColorSpace.RGB.equals(clrSpace)) {</span>
<span class="nc" id="L2594">                        minDiffClrs.getColors()[0] = r;</span>
<span class="nc" id="L2595">                        minDiffClrs.getColors()[1] = g;</span>
<span class="nc" id="L2596">                        minDiffClrs.getColors()[2] = b;</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">                    } else if (ColorSpace.HSV.equals(clrSpace)) {</span>
<span class="nc" id="L2598">                        Color.RGBtoHSB(r, g, b, minDiffClrs.getColors());</span>
<span class="nc bnc" id="L2599" title="All 2 branches missed.">                    } else if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2600">                        float[] lab = cieC.rgbToCIELAB(r, g, b);</span>
<span class="nc" id="L2601">                        System.arraycopy(lab, 0, minDiffClrs.getColors(),</span>
                            0, lab.length);
                    }

<span class="nc" id="L2605">                    TIntSet set0 = labelToIndexMap.get(minLabel);</span>
<span class="nc" id="L2606">                    set0.addAll(set);</span>
<span class="nc" id="L2607">                    set.clear();</span>
<span class="nc" id="L2608">                    set0.remove(label1);</span>
<span class="nc" id="L2609">                    set0.remove(minLabel);</span>

<span class="nc" id="L2611">                    merged.add(label1);</span>
<span class="nc" id="L2612">                    stack.add(minLabel);</span>
                }
            }
<span class="nc" id="L2615">        }</span>
<span class="nc" id="L2616">        log.fine(&quot;number of small merges=&quot; + merged.size()</span>
<span class="nc" id="L2617">           + &quot; nSmall=&quot; + nSmall + &quot; nSets=&quot; + labelToIndexMap.size());</span>
<span class="nc" id="L2618">    }</span>

    private Colors calculateSetColor(Colors rgbClrs,
        ColorSpace clrSpace) {

<span class="nc" id="L2623">        CIEChromaticity cieC = null;</span>
<span class="nc bnc" id="L2624" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2625">            cieC = new CIEChromaticity();</span>
        }

<span class="nc" id="L2628">        float r = rgbClrs.getColors()[0];</span>
<span class="nc" id="L2629">        float g = rgbClrs.getColors()[1];</span>
<span class="nc" id="L2630">        float b = rgbClrs.getColors()[2];</span>

<span class="nc bnc" id="L2632" title="All 2 branches missed.">        if (ColorSpace.RGB.equals(clrSpace)) {</span>
<span class="nc" id="L2633">            return new Colors(new float[]{r, g, b});</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">        } else if (ColorSpace.HSV.equals(clrSpace)) {</span>
<span class="nc" id="L2635">            float[] hsb = new float[3];</span>
<span class="nc" id="L2636">            Color.RGBtoHSB(Math.round(r), Math.round(g),</span>
<span class="nc" id="L2637">                Math.round(b), hsb);</span>
<span class="nc" id="L2638">            return new Colors(hsb);</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">        } else if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2640">            float[] lab = cieC.rgbToCIELAB(</span>
<span class="nc" id="L2641">                Math.round(r), Math.round(g), Math.round(b));</span>
<span class="nc" id="L2642">            return new Colors(lab);</span>
        }

<span class="nc" id="L2645">        throw new IllegalArgumentException(&quot;ColorSpace &quot; +</span>
            clrSpace + &quot; calc is not implemented.&quot;);
    }

    private double colorDiff(Colors clrs1, Colors clrs2,
        ColorSpace clrSpace) {

<span class="nc bnc" id="L2652" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2653">            CIEChromaticity cieC = new CIEChromaticity();</span>
<span class="nc" id="L2654">            double d = cieC.calcDeltaECIE2000(clrs1.getColors(),</span>
<span class="nc" id="L2655">                clrs2.getColors());</span>
<span class="nc" id="L2656">            return d;</span>
<span class="nc bnc" id="L2657" title="All 2 branches missed.">        } else if (ColorSpace.HSV.equals(clrSpace) ||</span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">            ColorSpace.RGB.equals(clrSpace)) {</span>

<span class="nc" id="L2660">            double diff = 0;</span>
<span class="nc bnc" id="L2661" title="All 2 branches missed.">            for (int i = 0; i &lt; clrs1.getColors().length; ++i) {</span>
<span class="nc" id="L2662">                float d = clrs1.getColors()[i] -</span>
<span class="nc" id="L2663">                    clrs2.getColors()[i];</span>
<span class="nc" id="L2664">                diff = (d * d);</span>
            }

<span class="nc" id="L2667">            return Math.sqrt(diff);</span>
        }

<span class="nc" id="L2670">        throw new IllegalArgumentException(&quot;ColorSpace &quot; +</span>
            clrSpace + &quot; calc is not implemented.&quot;);
    }

    private Colors calculateSetColor(
        TIntSet indexesSet, ImageExt img,
        ColorSpace clrSpace) {

<span class="nc" id="L2678">        CIEChromaticity cieC = null;</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2680">            cieC = new CIEChromaticity();</span>
        }

<span class="nc" id="L2683">        GroupPixelRGB0 gpb = new GroupPixelRGB0();</span>
<span class="nc" id="L2684">        gpb.calculateColors(indexesSet, img, 0, 0);</span>

<span class="nc" id="L2686">        int r = Math.round(gpb.getAvgRed());</span>
<span class="nc" id="L2687">        int g = Math.round(gpb.getAvgGreen());</span>
<span class="nc" id="L2688">        int b = Math.round(gpb.getAvgBlue());</span>
<span class="nc bnc" id="L2689" title="All 2 branches missed.">        if (ColorSpace.RGB.equals(clrSpace)) {</span>
<span class="nc" id="L2690">            return new Colors(new float[]{r, g, b});</span>
<span class="nc bnc" id="L2691" title="All 2 branches missed.">        } else if (ColorSpace.HSV.equals(clrSpace)) {</span>
<span class="nc" id="L2692">            float[] hsb = new float[3];</span>
<span class="nc" id="L2693">            Color.RGBtoHSB(r, g, b, hsb);</span>
<span class="nc" id="L2694">            return new Colors(hsb);</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">        } else if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L2696">            float[] lab = cieC.rgbToCIELAB(r, g, b);</span>
<span class="nc" id="L2697">            return new Colors(lab);</span>
        }

<span class="nc" id="L2700">        throw new IllegalArgumentException(&quot;ColorSpace &quot; +</span>
            clrSpace + &quot; calc is not implemented.&quot;);
    }

    public float[][] createSobelGradient(GreyscaleImage img) {

<span class="nc" id="L2706">        int nPix = img.getNPixels();</span>
<span class="nc" id="L2707">        int width = img.getWidth();</span>
<span class="nc" id="L2708">        int height = img.getHeight();</span>

<span class="nc" id="L2710">        float[][] gradient = new float[width][];</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="nc" id="L2712">            gradient[i] = new float[height];</span>
        }

<span class="nc" id="L2715">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

<span class="nc" id="L2717">        int h = (kernel.length - 1) &gt;&gt; 1;</span>

<span class="nc bnc" id="L2719" title="All 2 branches missed.">        for (int i = 0; i &lt; nPix; ++i) {</span>
<span class="nc" id="L2720">            final int x1 = img.getCol(i);</span>
<span class="nc" id="L2721">            final int y1 = img.getRow(i);</span>

<span class="nc" id="L2723">            float xSum = 0;</span>
<span class="nc" id="L2724">            float ySum = 0;</span>

<span class="nc bnc" id="L2726" title="All 2 branches missed.">            for (int g = 0; g &lt; kernel.length; ++g) {</span>
<span class="nc" id="L2727">                float gg = kernel[g];</span>
<span class="nc bnc" id="L2728" title="All 2 branches missed.">                if (gg == 0) {</span>
<span class="nc" id="L2729">                    continue;</span>
                }

                int x2, y2;
                // calc for X gradient first
<span class="nc" id="L2734">                int delta = g - h;</span>
<span class="nc" id="L2735">                x2 = x1 + delta;</span>
<span class="nc" id="L2736">                y2 = y1;</span>
                // edge corrections.  use replication
<span class="nc bnc" id="L2738" title="All 2 branches missed.">                if (x2 &lt; 0) {</span>
<span class="nc" id="L2739">                    x2 = -1 * x2 - 1;</span>
<span class="nc bnc" id="L2740" title="All 2 branches missed.">                } else if (x2 &gt;= width) {</span>
<span class="nc" id="L2741">                    int diff = x2 - width;</span>
<span class="nc" id="L2742">                    x2 = width - diff - 1;</span>
                }
<span class="nc" id="L2744">                xSum += gg * img.getValue(x2, y2);</span>

                // calc for y
<span class="nc" id="L2747">                y2 = y1 + delta;</span>
<span class="nc" id="L2748">                x2 = x1;</span>
                // edge corrections.  use replication
<span class="nc bnc" id="L2750" title="All 2 branches missed.">                if (y2 &lt; 0) {</span>
<span class="nc" id="L2751">                    y2 = -1 * y2 - 1;</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">                } else if (y2 &gt;= height) {</span>
<span class="nc" id="L2753">                    int diff = y2 - height;</span>
<span class="nc" id="L2754">                    y2 = height - diff - 1;</span>
                }
<span class="nc" id="L2756">                ySum += gg * img.getValue(x2, y2);</span>
            }

<span class="nc" id="L2759">            double c = Math.sqrt(xSum * xSum + ySum * ySum);</span>

<span class="nc" id="L2761">            gradient[x1][y1] = (float) c;</span>
        }

<span class="nc" id="L2764">        return gradient;</span>
    }

    /**
     *
     * @param img
     * @param gradientMethod
     * 0=CannyEdgeFilterAdaptiveDeltaE2000,
     * 1=CannyEdgeFilterAdaptive,
     * 2=PhaseCongruencyDetector
     * @param ts timestamp used in debugging image name
     * @return
     */
    public EdgeFilterProducts createGradient(Image img,
        int gradientMethod, long ts) {

<span class="fc" id="L2780">        EdgeFilterProducts products = null;</span>

<span class="pc bpc" id="L2782" title="1 of 2 branches missed.">        if (gradientMethod == 0) {</span>

<span class="nc" id="L2784">            ImageExt imgCp = img.copyToImageExt();</span>
            
<span class="nc" id="L2786">            CannyEdgeFilterAdaptiveDeltaE2000 canny =</span>
                new CannyEdgeFilterAdaptiveDeltaE2000();
<span class="nc" id="L2788">            canny.setOtsuScaleFactor(0.3f);</span>
<span class="nc" id="L2789">            canny.setToUseSingleThresholdIn2LayerFilter();</span>
<span class="nc" id="L2790">            canny.applyFilter(imgCp);</span>

<span class="nc" id="L2792">            products = canny.getFilterProducts();</span>

<span class="pc bpc" id="L2794" title="1 of 2 branches missed.">        } else if (gradientMethod == 1) {</span>
            
<span class="nc" id="L2796">            CannyEdgeFilterAdaptive canny2 = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L2797">            canny2.overrideToNotUseLineThinner();</span>
            //canny2.setOtsuScaleFactor(0.3f);
<span class="nc" id="L2799">            canny2.setToUseSingleThresholdIn2LayerFilter();</span>
<span class="nc" id="L2800">            canny2.applyFilter(img.copyToGreyscale2());</span>

<span class="nc" id="L2802">            products = canny2.getFilterProducts();</span>

<span class="pc bpc" id="L2804" title="1 of 2 branches missed.">        } else if (gradientMethod == 2) {</span>
            
<span class="fc" id="L2806">            products = createPhaseCongruencyGradient(</span>
<span class="fc" id="L2807">                img.copyBlueToGreyscale());</span>

        }

<span class="fc" id="L2811">        return products;</span>
    }

    private int[] calcStdDev(List&lt;GroupAverageColors&gt; listOfColors,
        List&lt;Integer&gt; indexes) {

<span class="nc" id="L2817">        float avgR = 0;</span>
<span class="nc" id="L2818">        float avgG = 0;</span>
<span class="nc" id="L2819">        float avgB = 0;</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L2821">            GroupAverageColors clrs = listOfColors.get(index.intValue());</span>
<span class="nc" id="L2822">            avgR += clrs.getR();</span>
<span class="nc" id="L2823">            avgG += clrs.getG();</span>
<span class="nc" id="L2824">            avgB += clrs.getB();</span>
<span class="nc" id="L2825">        }</span>
<span class="nc" id="L2826">        float length = (float)indexes.size();</span>
<span class="nc" id="L2827">        avgR /= length;</span>
<span class="nc" id="L2828">        avgG /= length;</span>
<span class="nc" id="L2829">        avgB /= length;</span>

<span class="nc" id="L2831">        float stdvR = 0;</span>
<span class="nc" id="L2832">        float stdvG = 0;</span>
<span class="nc" id="L2833">        float stdvB = 0;</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L2835">            GroupAverageColors clrs = listOfColors.get(index.intValue());</span>
<span class="nc" id="L2836">            float diffR = clrs.getR() - avgR;</span>
<span class="nc" id="L2837">            float diffG = clrs.getG() - avgG;</span>
<span class="nc" id="L2838">            float diffB = clrs.getB() - avgB;</span>
<span class="nc" id="L2839">            stdvR += (diffR * diffR);</span>
<span class="nc" id="L2840">            stdvG += (diffG * diffG);</span>
<span class="nc" id="L2841">            stdvB += (diffB * diffB);</span>
<span class="nc" id="L2842">        }</span>
<span class="nc" id="L2843">        int stdDevR = (int)Math.round(Math.sqrt(stdvR/(length - 1.0f)));</span>
<span class="nc" id="L2844">        int stdDevG = (int)Math.round(Math.sqrt(stdvG/(length - 1.0f)));</span>
<span class="nc" id="L2845">        int stdDevB = (int)Math.round(Math.sqrt(stdvB/(length - 1.0f)));</span>

<span class="nc" id="L2847">        return new int[]{stdDevR, stdDevG, stdDevB};</span>
    }

    public EdgeFilterProducts packageToEdgeProduct(
        PhaseCongruencyDetector.PhaseCongruencyProducts pr) {
        
<span class="fc" id="L2853">        EdgeFilterProducts eProduct = new EdgeFilterProducts();</span>

<span class="fc" id="L2855">        int nCols = pr.getThinned()[0].length;//img.getWidth();</span>
<span class="fc" id="L2856">        int nRows = pr.getThinned().length;//img.getHeight();</span>

<span class="fc" id="L2858">        GreyscaleImage pcImg = new GreyscaleImage(nCols, nRows);</span>
<span class="fc" id="L2859">        double[][] pc = pr.getPhaseCongruency();</span>
<span class="fc bfc" id="L2860" title="All 2 branches covered.">        for (int i = 0; i &lt; pr.getThinned().length; ++i) {</span>
<span class="fc bfc" id="L2861" title="All 2 branches covered.">            for (int j = 0; j &lt; pr.getThinned()[i].length; ++j) {</span>
<span class="fc bfc" id="L2862" title="All 2 branches covered.">                if (pr.getThinned()[i][j] &gt; 0) {</span>
<span class="fc" id="L2863">                    int v = (int)Math.round(255. * pc[i][j]);</span>
<span class="fc" id="L2864">                    pcImg.setValue(j, i, v);</span>
                }
            }
        }

<span class="fc" id="L2869">        eProduct.setGradientXY(pcImg);</span>

<span class="fc" id="L2871">        GreyscaleImage paImg = new GreyscaleImage(nCols, nRows,</span>
            GreyscaleImage.Type.Bits32FullRangeInt);
        // range -pi to pi
<span class="fc" id="L2874">        double[][] pa = pr.getPhaseAngle();</span>
<span class="fc bfc" id="L2875" title="All 2 branches covered.">        for (int i = 0; i &lt; pa.length; ++i) {</span>
<span class="fc bfc" id="L2876" title="All 2 branches covered.">            for (int j = 0; j &lt; pa[i].length; ++j) {</span>
<span class="fc" id="L2877">                double v = pa[i][j];</span>
<span class="fc" id="L2878">                int d = (int)Math.round(v * 180./Math.PI);</span>
<span class="fc" id="L2879">                paImg.setValue(j, i, d);</span>
            }
        }
<span class="fc" id="L2882">        eProduct.setPhaseAngle(paImg);</span>

<span class="fc" id="L2884">        GreyscaleImage orImg = new GreyscaleImage(nCols, nRows);</span>
<span class="fc" id="L2885">        double[][] or = pr.getOrientation();</span>
        // orientation is already in range 0 to 180
<span class="fc bfc" id="L2887" title="All 2 branches covered.">        for (int i = 0; i &lt; or.length; ++i) {</span>
<span class="fc bfc" id="L2888" title="All 2 branches covered.">            for (int j = 0; j &lt; or[i].length; ++j) {</span>
<span class="fc" id="L2889">                double v = or[i][j];</span>
<span class="fc" id="L2890">                orImg.setValue(j, i, (int)Math.round(v));</span>
            }
        }
<span class="fc" id="L2893">        eProduct.setTheta(orImg);</span>
        
<span class="fc" id="L2895">        return eProduct;</span>
    }
    
    public EdgeFilterProducts createPhaseCongruencyGradient(
        GreyscaleImage img) {
        
<span class="fc" id="L2901">        PhaseCongruencyDetector phaseDetector = new PhaseCongruencyDetector();</span>
<span class="fc" id="L2902">        phaseDetector.setK(2);</span>
        
<span class="fc" id="L2904">        PhaseCongruencyDetector.PhaseCongruencyProducts pr =</span>
<span class="fc" id="L2905">            phaseDetector.phaseCongMono(img);</span>

<span class="fc" id="L2907">        EdgeFilterProducts eProduct = packageToEdgeProduct(pr);</span>
        
<span class="fc" id="L2909">        return eProduct;</span>
    }

    /**
     * for the full 8 neighbor region, determine whether nulling the pixel
     * at (col, row) would disconnect the remaining line.  Note that the
     * boolean logic is embedded in the comments.  One should be able to
     * combine the rules for multiple pixel tests to reduce the redundant
     * comparisons for the regions in common.
     *
     * Note, that row and col are expected to be at least 1 pixel distant
     * from the image borders.
     *
     * @param input
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final GreyscaleImage input,
        PairInt[][] neighborCoords, int col, int row, int edgeValue) {

<span class="nc" id="L2930">        int w = input.getWidth();</span>
<span class="nc" id="L2931">        int h = input.getHeight();</span>

<span class="nc bnc" id="L2933" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L2937">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc bnc" id="L2979" title="All 2 branches missed.">        boolean t6 = (input.getValue(neighborCoords[0][2].getX() + col,</span>
<span class="nc" id="L2980">            neighborCoords[0][2].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">        boolean t7 = (input.getValue(neighborCoords[1][2].getX() + col,</span>
<span class="nc" id="L2982">            neighborCoords[1][2].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">        boolean t8 = (input.getValue(neighborCoords[2][2].getX() + col,</span>
<span class="nc" id="L2984">            neighborCoords[2][2].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2985" title="All 2 branches missed.">        boolean t11 = (input.getValue(neighborCoords[0][1].getX() + col,</span>
<span class="nc" id="L2986">            neighborCoords[0][1].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2987" title="All 2 branches missed.">        boolean t12 = (input.getValue(neighborCoords[2][1].getX() + col,</span>
<span class="nc" id="L2988">            neighborCoords[2][1].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">        boolean t15 = (input.getValue(neighborCoords[0][0].getX() + col,</span>
<span class="nc" id="L2990">            neighborCoords[0][0].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">        boolean t16 = (input.getValue(neighborCoords[1][0].getX() + col,</span>
<span class="nc" id="L2992">            neighborCoords[1][0].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">        boolean t17 = (input.getValue(neighborCoords[2][0].getX() + col,</span>
<span class="nc" id="L2994">            neighborCoords[2][0].getY() + row) == edgeValue);</span>

<span class="nc bnc" id="L2996" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L2997">            return true;</span>
<span class="nc bnc" id="L2998" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L2999">            return true;</span>
<span class="nc bnc" id="L3000" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L3001">            return true;</span>
<span class="nc bnc" id="L3002" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L3003">            return true;</span>
<span class="nc bnc" id="L3004" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L3005">            return true;</span>
<span class="nc bnc" id="L3006" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3007">            return true;</span>
<span class="nc bnc" id="L3008" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3009">            return true;</span>
<span class="nc bnc" id="L3010" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3011">            return true;</span>
<span class="nc bnc" id="L3012" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3013">            return true;</span>
<span class="nc bnc" id="L3014" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L3015">            return true;</span>
<span class="nc bnc" id="L3016" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3017">            return true;</span>
<span class="nc bnc" id="L3018" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L3019">            return true;</span>
<span class="nc bnc" id="L3020" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L3021">            return true;</span>
<span class="nc bnc" id="L3022" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L3023">            return true;</span>
<span class="nc bnc" id="L3024" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L3025">            return true;</span>
<span class="nc bnc" id="L3026" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L3027">            return true;</span>
        }

<span class="nc" id="L3030">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final GreyscaleImage input,
        PairInt[][] neighborCoords, int col, int row) {
        
<span class="fc" id="L3048">        int w = input.getWidth();</span>
<span class="fc" id="L3049">        int h = input.getHeight();</span>

<span class="pc bpc" id="L3051" title="4 of 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L3055">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="fc bfc" id="L3097" title="All 2 branches covered.">        boolean t6 = (input.getValue(neighborCoords[0][2].getX() + col,</span>
<span class="fc" id="L3098">            neighborCoords[0][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3099" title="All 2 branches covered.">        boolean t7 = (input.getValue(neighborCoords[1][2].getX() + col,</span>
<span class="fc" id="L3100">            neighborCoords[1][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3101" title="All 2 branches covered.">        boolean t8 = (input.getValue(neighborCoords[2][2].getX() + col,</span>
<span class="fc" id="L3102">            neighborCoords[2][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3103" title="All 2 branches covered.">        boolean t11 = (input.getValue(neighborCoords[0][1].getX() + col,</span>
<span class="fc" id="L3104">            neighborCoords[0][1].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3105" title="All 2 branches covered.">        boolean t12 = (input.getValue(neighborCoords[2][1].getX() + col,</span>
<span class="fc" id="L3106">            neighborCoords[2][1].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3107" title="All 2 branches covered.">        boolean t15 = (input.getValue(neighborCoords[0][0].getX() + col,</span>
<span class="fc" id="L3108">            neighborCoords[0][0].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3109" title="All 2 branches covered.">        boolean t16 = (input.getValue(neighborCoords[1][0].getX() + col,</span>
<span class="fc" id="L3110">            neighborCoords[1][0].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L3111" title="All 2 branches covered.">        boolean t17 = (input.getValue(neighborCoords[2][0].getX() + col,</span>
<span class="fc" id="L3112">            neighborCoords[2][0].getY() + row) &gt; 0);</span>

<span class="pc bpc" id="L3114" title="3 of 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="fc" id="L3115">            return true;</span>
<span class="pc bpc" id="L3116" title="1 of 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="fc" id="L3117">            return true;</span>
<span class="pc bpc" id="L3118" title="5 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="fc" id="L3119">            return true;</span>
<span class="pc bpc" id="L3120" title="1 of 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L3121">            return true;</span>
<span class="pc bpc" id="L3122" title="3 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L3123">            return true;</span>
<span class="pc bpc" id="L3124" title="3 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="fc" id="L3125">            return true;</span>
<span class="pc bpc" id="L3126" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3127">            return true;</span>
<span class="fc bfc" id="L3128" title="All 8 branches covered.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="fc" id="L3129">            return true;</span>
<span class="pc bpc" id="L3130" title="2 of 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="fc" id="L3131">            return true;</span>
<span class="pc bpc" id="L3132" title="7 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L3133">            return true;</span>
<span class="pc bpc" id="L3134" title="1 of 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3135">            return true;</span>
<span class="pc bpc" id="L3136" title="3 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L3137">            return true;</span>
<span class="fc bfc" id="L3138" title="All 8 branches covered.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="fc" id="L3139">            return true;</span>
<span class="pc bpc" id="L3140" title="5 of 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L3141">            return true;</span>
<span class="pc bpc" id="L3142" title="5 of 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L3143">            return true;</span>
<span class="pc bpc" id="L3144" title="7 of 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L3145">            return true;</span>
        }

<span class="fc" id="L3148">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @param w width of image
     * @param h height of image
     * @return
     */
    public static boolean doesDisconnect(final Set&lt;PairInt&gt; input,
        PairInt[][] neighborCoords, int col, int row, int w, int h) {

<span class="nc bnc" id="L3168" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L3172">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc" id="L3214">        boolean t6 = input.contains(</span>
<span class="nc" id="L3215">            new PairInt(neighborCoords[0][2].getX() + col,</span>
<span class="nc" id="L3216">            neighborCoords[0][2].getY() + row));</span>
<span class="nc" id="L3217">        boolean t7 = input.contains(</span>
<span class="nc" id="L3218">            new PairInt(neighborCoords[1][2].getX() + col,</span>
<span class="nc" id="L3219">            neighborCoords[1][2].getY() + row));</span>
<span class="nc" id="L3220">        boolean t8 = input.contains(</span>
<span class="nc" id="L3221">            new PairInt(neighborCoords[2][2].getX() + col,</span>
<span class="nc" id="L3222">            neighborCoords[2][2].getY() + row));</span>
<span class="nc" id="L3223">        boolean t11 = input.contains(</span>
<span class="nc" id="L3224">            new PairInt(neighborCoords[0][1].getX() + col,</span>
<span class="nc" id="L3225">            neighborCoords[0][1].getY() + row));</span>
<span class="nc" id="L3226">        boolean t12 = input.contains(</span>
<span class="nc" id="L3227">            new PairInt(neighborCoords[2][1].getX() + col,</span>
<span class="nc" id="L3228">            neighborCoords[2][1].getY() + row));</span>
<span class="nc" id="L3229">        boolean t15 = input.contains(</span>
<span class="nc" id="L3230">            new PairInt(neighborCoords[0][0].getX() + col,</span>
<span class="nc" id="L3231">            neighborCoords[0][0].getY() + row));</span>
<span class="nc" id="L3232">        boolean t16 = input.contains(</span>
<span class="nc" id="L3233">            new PairInt(neighborCoords[1][0].getX() + col,</span>
<span class="nc" id="L3234">            neighborCoords[1][0].getY() + row));</span>
<span class="nc" id="L3235">        boolean t17 = input.contains(</span>
<span class="nc" id="L3236">            new PairInt(neighborCoords[2][0].getX() + col,</span>
<span class="nc" id="L3237">            neighborCoords[2][0].getY() + row));</span>

<span class="nc bnc" id="L3239" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L3240">            return true;</span>
<span class="nc bnc" id="L3241" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3242">            return true;</span>
<span class="nc bnc" id="L3243" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L3244">            return true;</span>
<span class="nc bnc" id="L3245" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L3246">            return true;</span>
<span class="nc bnc" id="L3247" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L3248">            return true;</span>
<span class="nc bnc" id="L3249" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3250">            return true;</span>
<span class="nc bnc" id="L3251" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3252">            return true;</span>
<span class="nc bnc" id="L3253" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3254">            return true;</span>
<span class="nc bnc" id="L3255" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3256">            return true;</span>
<span class="nc bnc" id="L3257" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L3258">            return true;</span>
<span class="nc bnc" id="L3259" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3260">            return true;</span>
<span class="nc bnc" id="L3261" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L3262">            return true;</span>
<span class="nc bnc" id="L3263" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L3264">            return true;</span>
<span class="nc bnc" id="L3265" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L3266">            return true;</span>
<span class="nc bnc" id="L3267" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L3268">            return true;</span>
<span class="nc bnc" id="L3269" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L3270">            return true;</span>
        }

<span class="nc" id="L3273">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @param w width of image
     * @param h height of image
     * @return
     */
    public static boolean doesDisconnect(final TIntSet input,
        PairInt[][] neighborCoords, int col, int row, int w, int h) {

<span class="nc bnc" id="L3293" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L3297">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc" id="L3339">        boolean t6 = input.contains(</span>
<span class="nc" id="L3340">            ((neighborCoords[0][2].getY() + row) * w) +</span>
<span class="nc" id="L3341">            neighborCoords[0][2].getX() + col);</span>
<span class="nc" id="L3342">        boolean t7 = input.contains(</span>
<span class="nc" id="L3343">            ((neighborCoords[1][2].getY() + row) * w) +</span>
<span class="nc" id="L3344">            neighborCoords[1][2].getX() + col);</span>
<span class="nc" id="L3345">        boolean t8 = input.contains(</span>
<span class="nc" id="L3346">            ((neighborCoords[2][2].getY() + row) * w) +</span>
<span class="nc" id="L3347">            neighborCoords[2][2].getX() + col);</span>
<span class="nc" id="L3348">        boolean t11 = input.contains(</span>
<span class="nc" id="L3349">            ((neighborCoords[0][1].getY() + row) * w) +</span>
<span class="nc" id="L3350">            neighborCoords[0][1].getX() + col);</span>
<span class="nc" id="L3351">        boolean t12 = input.contains(</span>
<span class="nc" id="L3352">            ((neighborCoords[2][1].getY() + row) * w) +</span>
<span class="nc" id="L3353">            neighborCoords[2][1].getX() + col);</span>
<span class="nc" id="L3354">        boolean t15 = input.contains(</span>
<span class="nc" id="L3355">            ((neighborCoords[0][0].getY() + row) * w) +</span>
<span class="nc" id="L3356">            neighborCoords[0][0].getX() + col);</span>
<span class="nc" id="L3357">        boolean t16 = input.contains(</span>
<span class="nc" id="L3358">            ((neighborCoords[1][0].getY() + row) * w) +</span>
<span class="nc" id="L3359">            neighborCoords[1][0].getX() + col);</span>
<span class="nc" id="L3360">        boolean t17 = input.contains(</span>
<span class="nc" id="L3361">            ((neighborCoords[2][0].getY() + row) * w) +</span>
<span class="nc" id="L3362">            neighborCoords[2][0].getX() + col);</span>

<span class="nc bnc" id="L3364" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L3365">            return true;</span>
<span class="nc bnc" id="L3366" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3367">            return true;</span>
<span class="nc bnc" id="L3368" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L3369">            return true;</span>
<span class="nc bnc" id="L3370" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L3371">            return true;</span>
<span class="nc bnc" id="L3372" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L3373">            return true;</span>
<span class="nc bnc" id="L3374" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3375">            return true;</span>
<span class="nc bnc" id="L3376" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3377">            return true;</span>
<span class="nc bnc" id="L3378" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3379">            return true;</span>
<span class="nc bnc" id="L3380" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3381">            return true;</span>
<span class="nc bnc" id="L3382" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L3383">            return true;</span>
<span class="nc bnc" id="L3384" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3385">            return true;</span>
<span class="nc bnc" id="L3386" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L3387">            return true;</span>
<span class="nc bnc" id="L3388" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L3389">            return true;</span>
<span class="nc bnc" id="L3390" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L3391">            return true;</span>
<span class="nc bnc" id="L3392" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L3393">            return true;</span>
<span class="nc bnc" id="L3394" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L3395">            return true;</span>
        }

<span class="nc" id="L3398">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final double[][] input,
        PairInt[][] neighborCoords, int col, int row) {

<span class="nc" id="L3416">        int w = input.length;</span>
<span class="nc" id="L3417">        int h = input[0].length;</span>

<span class="nc bnc" id="L3419" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L3423">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc" id="L3465">        boolean t6 = (input[neighborCoords[0][2].getX() + col][</span>
<span class="nc bnc" id="L3466" title="All 2 branches missed.">            neighborCoords[0][2].getY() + row] &gt; 0);</span>
<span class="nc" id="L3467">        boolean t7 = (input[neighborCoords[1][2].getX() + col][</span>
<span class="nc bnc" id="L3468" title="All 2 branches missed.">            neighborCoords[1][2].getY() + row] &gt; 0);</span>
<span class="nc" id="L3469">        boolean t8 = (input[neighborCoords[2][2].getX() + col][</span>
<span class="nc bnc" id="L3470" title="All 2 branches missed.">            neighborCoords[2][2].getY() + row] &gt; 0);</span>
<span class="nc" id="L3471">        boolean t11 = (input[neighborCoords[0][1].getX() + col][</span>
<span class="nc bnc" id="L3472" title="All 2 branches missed.">            neighborCoords[0][1].getY() + row] &gt; 0);</span>
<span class="nc" id="L3473">        boolean t12 = (input[neighborCoords[2][1].getX() + col][</span>
<span class="nc bnc" id="L3474" title="All 2 branches missed.">            neighborCoords[2][1].getY() + row] &gt; 0);</span>
<span class="nc" id="L3475">        boolean t15 = (input[neighborCoords[0][0].getX() + col][</span>
<span class="nc bnc" id="L3476" title="All 2 branches missed.">            neighborCoords[0][0].getY() + row] &gt; 0);</span>
<span class="nc" id="L3477">        boolean t16 = (input[neighborCoords[1][0].getX() + col][</span>
<span class="nc bnc" id="L3478" title="All 2 branches missed.">            neighborCoords[1][0].getY() + row] &gt; 0);</span>
<span class="nc" id="L3479">        boolean t17 = (input[neighborCoords[2][0].getX() + col][</span>
<span class="nc bnc" id="L3480" title="All 2 branches missed.">            neighborCoords[2][0].getY() + row] &gt; 0);</span>

<span class="nc bnc" id="L3482" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L3483">            return true;</span>
<span class="nc bnc" id="L3484" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3485">            return true;</span>
<span class="nc bnc" id="L3486" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L3487">            return true;</span>
<span class="nc bnc" id="L3488" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L3489">            return true;</span>
<span class="nc bnc" id="L3490" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L3491">            return true;</span>
<span class="nc bnc" id="L3492" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3493">            return true;</span>
<span class="nc bnc" id="L3494" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L3495">            return true;</span>
<span class="nc bnc" id="L3496" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3497">            return true;</span>
<span class="nc bnc" id="L3498" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L3499">            return true;</span>
<span class="nc bnc" id="L3500" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L3501">            return true;</span>
<span class="nc bnc" id="L3502" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L3503">            return true;</span>
<span class="nc bnc" id="L3504" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L3505">            return true;</span>
<span class="nc bnc" id="L3506" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L3507">            return true;</span>
<span class="nc bnc" id="L3508" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L3509">            return true;</span>
<span class="nc bnc" id="L3510" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L3511">            return true;</span>
<span class="nc bnc" id="L3512" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L3513">            return true;</span>
        }

<span class="nc" id="L3516">        return false;</span>
    }

    /**
     * given a greyscale image, makes edges (0's are edges and the background
     * is 255).
     * @param img
     * @param debugTag
     */
    public void createEdges02(GreyscaleImage img, String debugTag) {

<span class="nc" id="L3527">        GreyscaleImage greyGradient2 = img.copyImage();</span>

<span class="nc" id="L3529">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L3530">        imageProcessor.blur(greyGradient2, SIGMA.ONE);</span>

//TODO: an adaptive gradient might help here

<span class="nc" id="L3534">        CannyEdgeFilterAdaptive fl = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L3535">        fl.applyFilter(greyGradient2);</span>
<span class="nc" id="L3536">        removeIsolatedPixels(greyGradient2, 0, 255, true);</span>
<span class="nc" id="L3537">        removeIsolatedPixels(greyGradient2, 255, 0, true);</span>
<span class="nc" id="L3538">        MedianSmooth s = new MedianSmooth();</span>
<span class="nc" id="L3539">        GreyscaleImage tmp2 = s.calculate(greyGradient2, 2, 2);</span>
<span class="nc" id="L3540">        greyGradient2 = tmp2;</span>
<span class="nc bnc" id="L3541" title="All 2 branches missed.">        for (int i = 0; i &lt; greyGradient2.getNPixels(); ++i) {</span>
<span class="nc" id="L3542">            int v = greyGradient2.getValue(i);</span>
<span class="nc bnc" id="L3543" title="All 2 branches missed.">            if (v &gt; 1) {</span>
<span class="nc" id="L3544">                img.setValue(i, 0);</span>
            } else {
<span class="nc" id="L3546">                img.setValue(i, 255);</span>
            }
        }
<span class="nc" id="L3549">        removeEdgesSmallerThanLimit(img, 0, 255, 2);</span>
        //removeIsolatedPixels(img, 0, 255, true);
<span class="nc" id="L3551">    }</span>

    public void createEdges03(GreyscaleImage img, String debugTag) {
<span class="nc" id="L3554">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L3555">        hEq.applyFilter();</span>
<span class="nc" id="L3556">        createEdges02(img, debugTag);</span>
<span class="nc" id="L3557">    }</span>

    public void createEdges01(GreyscaleImage img, String debugTag) {

<span class="nc" id="L3561">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L3562">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L3563">        hEq.applyFilter();</span>
<span class="nc" id="L3564">        CannyEdgeFilterAdaptive cannyFilter = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L3565">        cannyFilter.applyFilter(img);</span>

        //MiscDebug.writeImage(img, &quot;_canny_&quot; + debugTag);

<span class="nc" id="L3569">        setAllNonZeroTo255(img);</span>
<span class="nc" id="L3570">        removeIsolatedPixels(img, 0, 255, false);</span>
<span class="nc" id="L3571">        removeIsolatedPixels(img, 255, 0, true);</span>

<span class="nc" id="L3573">        MedianSmooth s = new MedianSmooth();</span>
<span class="nc" id="L3574">        GreyscaleImage tmp2 = s.calculate(img, 3, 3);</span>

        //MiscDebug.writeImage(tmp2, &quot;tmp_edges01_2_&quot; + debugTag);

<span class="nc" id="L3578">        removeIsolatedPixels(tmp2, 255, 0, true);</span>
<span class="nc" id="L3579">        removeIsolatedPixels(tmp2, 0, 255, true);</span>
<span class="nc" id="L3580">        invertImage(tmp2);</span>
<span class="nc" id="L3581">        imageProcessor.applyAdaptiveMeanThresholding(tmp2, 1);</span>
<span class="nc" id="L3582">        img.resetTo(tmp2);</span>

        //MiscDebug.writeImage(img, &quot;tmp_edges01_3_&quot; + debugTag);
<span class="nc" id="L3585">    }</span>

     /**
     *
     * @param img
     * @param edgeValue
     * @param nonEdgeValue
     * @param limit edges less than or equal to this size will be removed
     */
    public void removeEdgesSmallerThanLimit(GreyscaleImage img, int edgeValue,
        int nonEdgeValue, int limit) {

<span class="nc" id="L3597">        ConnectedValuesFinder finder = new ConnectedValuesFinder(img);</span>
<span class="nc" id="L3598">        finder.setMinimumNumberInCluster(1);</span>
<span class="nc" id="L3599">        finder.setToUse8Neighbors();</span>
<span class="nc" id="L3600">        finder.findGroups(edgeValue);</span>

<span class="nc bnc" id="L3602" title="All 2 branches missed.">        for (int i = 0; i &lt; finder.getNumberOfGroups(); ++i) {</span>
<span class="nc" id="L3603">            TIntSet edge = finder.getXY(i);</span>
<span class="nc bnc" id="L3604" title="All 2 branches missed.">            if (edge.size() &gt; limit) {</span>
<span class="nc" id="L3605">                continue;</span>
            }
<span class="nc" id="L3607">            TIntIterator iter = edge.iterator();</span>
<span class="nc bnc" id="L3608" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L3609">                int pixIdx = iter.next();</span>
<span class="nc" id="L3610">                int y = pixIdx/img.getWidth();</span>
<span class="nc" id="L3611">                int x = pixIdx - (y * img.getWidth());</span>
            
<span class="nc" id="L3613">                img.setValue(x, y, nonEdgeValue);</span>
<span class="nc" id="L3614">            }</span>
        }
<span class="nc" id="L3616">    }</span>

    private int[][] copy(int[][] a) {

<span class="nc" id="L3620">        int[][] b = new int[a.length][];</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">        for (int i = 0; i &lt; b.length; ++i) {</span>
<span class="nc" id="L3622">            b[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="nc" id="L3625">        return b;</span>
    }

    private boolean assertShortEdgesAreEmpty(List&lt;Integer&gt; indexes,
        List&lt;Set&lt;PairInt&gt;&gt; clusterSets) {

<span class="nc bnc" id="L3631" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L3632">            Set&lt;PairInt&gt; set = clusterSets.get(index.intValue());</span>
<span class="nc bnc" id="L3633" title="All 4 branches missed.">            assert(set.isEmpty());</span>
<span class="nc" id="L3634">        }</span>

<span class="nc" id="L3636">        return true;</span>
    }

    /**
     * apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
     * (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public void applySuperPixelsAndNormalizedCuts(ImageExt img) {

<span class="fc" id="L3657">        int[] labels = calcSuperPixelsAndNormalizedCutsLabels(img);</span>

<span class="fc" id="L3659">        LabelToColorHelper.applyLabels(img, labels);</span>
<span class="fc" id="L3660">    }</span>

    /**
     * apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
     * (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public void applySuperPixelsAndNormalizedCuts(ImageExt img, int nIter) {

<span class="nc" id="L3680">        int[] labels = calcSuperPixelsAndNormalizedCutsLabels(img, nIter);</span>

<span class="nc" id="L3682">        LabelToColorHelper.applyLabels(img, labels);</span>
<span class="nc" id="L3683">    }</span>

    /**
     * Apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
       (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public int[] calcSuperPixelsAndNormalizedCutsLabels(ImageExt img) {
        int kCell;

<span class="fc" id="L3704">        int avgDimension = (img.getWidth() + img.getHeight()) / 2;</span>

<span class="pc bpc" id="L3706" title="1 of 2 branches missed.">        if (avgDimension &lt; 25) {</span>
<span class="nc" id="L3707">            kCell = 2 * avgDimension;</span>
<span class="fc bfc" id="L3708" title="All 2 branches covered.">        } else if (avgDimension &lt; 100) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 10);
<span class="fc" id="L3710">            kCell = 200;</span>
<span class="pc bpc" id="L3711" title="1 of 2 branches missed.">        } else if (avgDimension &lt; 200) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 10);
<span class="fc" id="L3713">            kCell = 200;</span>
<span class="nc bnc" id="L3714" title="All 2 branches missed.">        } else if (avgDimension &lt; 301) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 100);
<span class="nc" id="L3716">            kCell = 1050;</span>
<span class="nc bnc" id="L3717" title="All 2 branches missed.">        } else if (avgDimension &lt; 400) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 350);
<span class="nc" id="L3719">            kCell = 750;</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">        } else if (avgDimension &lt; 500) {</span>
<span class="nc" id="L3721">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
<span class="nc" id="L3722">            kCell *= 2;  // creates a more segmented defined labelling</span>
        } else {
            // this section has not been tested well yet
<span class="nc" id="L3725">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
<span class="nc bnc" id="L3726" title="All 2 branches missed.">            if (kCell &gt; 2000) {</span>
<span class="nc" id="L3727">                kCell = 2000;</span>
            }
        }

<span class="fc" id="L3731">        System.out.println(&quot;kCell=&quot; + kCell + &quot; avgDim=&quot; + avgDimension);</span>

<span class="fc" id="L3733">        kCell = 200;</span>
<span class="fc" id="L3734">        int clNorm = 1;</span>

<span class="fc" id="L3736">        SLICSuperPixels slic</span>
            = new SLICSuperPixels(img, kCell, clNorm);
<span class="fc" id="L3738">        slic.calculate();</span>
<span class="fc" id="L3739">        int[] labels = slic.getLabels();</span>

        //ImageExt img2 = img.copyToImageExt();
        //ImageIOHelper.addAlternatingColorLabelsToRegion(img2, labels);
        //MiscDebug.writeImage(img2, &quot;_slic_&quot; + trainingData[i].imgFileName);

<span class="fc" id="L3745">        NormalizedCuts normCuts = new NormalizedCuts();</span>
<span class="fc" id="L3746">        int[] labels2 = normCuts.normalizedCut(img, labels);</span>

<span class="fc" id="L3748">        return labels2;</span>
    }

    /**
     * Apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
       (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public int[] calcSuperPixelsAndNormalizedCutsLabels(ImageExt img, int nIter) {

        int kCell;

<span class="nc" id="L3771">        int avgDimension = (img.getWidth() + img.getHeight()) / 2;</span>

<span class="nc bnc" id="L3773" title="All 2 branches missed.">        if (avgDimension &lt; 25) {</span>
<span class="nc" id="L3774">            kCell = 2 * avgDimension;</span>
<span class="nc bnc" id="L3775" title="All 2 branches missed.">        } else if (avgDimension &lt; 100) {</span>
<span class="nc" id="L3776">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 100);</span>
<span class="nc bnc" id="L3777" title="All 2 branches missed.">        } else if (avgDimension &lt; 500) {</span>
<span class="nc" id="L3778">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
            //kCell *= 2;  // creates a more segmented defined labelling
        } else {
            // this section has not been tested well yet
<span class="nc" id="L3782">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
<span class="nc bnc" id="L3783" title="All 2 branches missed.">            if (kCell &gt; 2000) {</span>
<span class="nc" id="L3784">                kCell = 2000;</span>
            }
        }

<span class="nc" id="L3788">        System.out.println(&quot;kCell=&quot; + kCell);</span>

<span class="nc" id="L3790">        SLICSuperPixels slic = new SLICSuperPixels(img, kCell);</span>
<span class="nc" id="L3791">        slic.calculate();</span>
<span class="nc" id="L3792">        int[] labels = slic.getLabels();</span>

        //ImageExt img2 = img.copyToImageExt();
        //ImageIOHelper.addAlternatingColorLabelsToRegion(img2, labels);
        //MiscDebug.writeImage(img2, &quot;_slic_&quot; + trainingData[i].imgFileName);

<span class="nc bnc" id="L3798" title="All 2 branches missed.">        for (int i = 0; i &lt; nIter; ++i) {</span>

<span class="nc" id="L3800">            NormalizedCuts normCuts = new NormalizedCuts();</span>
<span class="nc" id="L3801">            labels = normCuts.normalizedCut(img, labels);</span>

        }

<span class="nc" id="L3805">        return labels;</span>
    }

    public static class DecimatedData {
        // decimated comparison size is the closest to 128
        // for that have labels, decimated image, perimeter.
        // for decimated sizes 256 and 512, have
        //    decimated images and labels also.
        // that allows for a range of scale up to 4 in
        // feature comparisons
        public TIntObjectMap&lt;TIntSet&gt; fullLabels;

        // note that a small image may have nulls for
        // dimensions larger than it's image.
        // the 128, 256, and 512 decimated images
        public ImageExt[] dImages = new ImageExt[3];
        public int[] dBinFactors = new int[3];

        // first list indexes are for 128, 256, or 512
        // then map indexes are the labels of the segments
        //  and the values of the maps are the characteristics
        //  of those segments
        public List&lt;TIntObjectMap&lt;TIntSet&gt;&gt; dLabeledIndexes
            = new ArrayList&lt;TIntObjectMap&lt;TIntSet&gt;&gt;();
        public List&lt;TIntObjectMap&lt;PairInt&gt;&gt; dLabelCentroids
            = new ArrayList&lt;TIntObjectMap&lt;PairInt&gt;&gt;();
    }

    public void replaceSinglePixelLabelsCIELAB(int[] labels,
        ImageExt img) {

        // ----- replace single pixels w/ adjacent nearest in color -----
<span class="fc" id="L3837">        int[] dx2 = Misc.dx4;</span>
<span class="fc" id="L3838">        int[] dy2 = Misc.dy4;</span>
        // single pixels should join closest,,,
<span class="fc bfc" id="L3840" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L3841" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L3842">                int pixIdx = img.getInternalIndex(i, j);</span>
<span class="fc" id="L3843">                int v = labels[pixIdx];</span>
<span class="fc" id="L3844">                boolean oneIsSame = false;</span>
<span class="fc bfc" id="L3845" title="All 2 branches covered.">                for (int z = 0; z &lt; dx2.length; ++z) {</span>
<span class="fc" id="L3846">                    int x2 = i + dx2[z];</span>
<span class="fc" id="L3847">                    int y2 = j + dy2[z];</span>
<span class="fc bfc" id="L3848" title="All 6 branches covered.">                    if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (img.getWidth() - 1))</span>
<span class="fc bfc" id="L3849" title="All 2 branches covered.">                        || (y2 &gt; (img.getHeight() - 1))</span>
                        ) {
<span class="fc" id="L3851">                        continue;</span>
                    }
<span class="fc" id="L3853">                    int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="fc" id="L3854">                    int v2 = labels[pixIdx2];</span>
<span class="fc bfc" id="L3855" title="All 2 branches covered.">                    if (v2 == v) {</span>
<span class="fc" id="L3856">                        oneIsSame = true;</span>
<span class="fc" id="L3857">                        break;</span>
                    }
                }
<span class="fc bfc" id="L3860" title="All 2 branches covered.">                if (!oneIsSame) {</span>
<span class="fc" id="L3861">                    float[] lab = img.getCIELAB(pixIdx);</span>
<span class="fc" id="L3862">                    double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L3863">                    int minIdx = -1;</span>
<span class="fc bfc" id="L3864" title="All 2 branches covered.">                    for (int z = 0; z &lt; dx2.length; ++z) {</span>
<span class="fc" id="L3865">                        int x2 = i + dx2[z];</span>
<span class="fc" id="L3866">                        int y2 = j + dy2[z];</span>
<span class="fc bfc" id="L3867" title="All 6 branches covered.">                        if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (img.getWidth() - 1))</span>
<span class="fc bfc" id="L3868" title="All 2 branches covered.">                            || (y2 &gt; (img.getHeight() - 1))) {</span>
<span class="fc" id="L3869">                            continue;</span>
                        }
<span class="fc" id="L3871">                        int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="fc" id="L3872">                        float[] lab2 = img.getCIELAB(pixIdx2);</span>
                        
<span class="fc" id="L3874">                        double dClrSq = 0;</span>
<span class="fc bfc" id="L3875" title="All 2 branches covered.">                        for (int i2 = 0; i2 &lt; 3; ++i2) {</span>
<span class="fc" id="L3876">                            float diff = lab[i2] - lab2[i2];</span>
<span class="fc" id="L3877">                            dClrSq += (diff * diff);</span>
                        }
                        
<span class="fc bfc" id="L3880" title="All 2 branches covered.">                        if (dClrSq &lt; minDiff) {</span>
<span class="fc" id="L3881">                            minDiff = dClrSq;</span>
<span class="fc" id="L3882">                            minIdx = pixIdx2;</span>
                        }
                    }
<span class="fc" id="L3885">                    labels[pixIdx] = labels[minIdx];</span>
                }
            }
        }
<span class="fc" id="L3889">    }</span>

    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageSegmentation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageSegmentation.java</span></div><h1>ImageSegmentation.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.CountingSort;
import algorithms.MultiArrayMergeSort;
import algorithms.QuickSort;
import algorithms.compGeometry.PerimeterFinder2;
import algorithms.compGeometry.clustering.KMeansPlusPlus;
import algorithms.compGeometry.clustering.KMeansPlusPlusColor;
import algorithms.connected.ConnectedValuesFinder;
import algorithms.imageProcessing.util.GroupAverageColors;
import algorithms.imageProcessing.ImageProcessor.Colors;
import algorithms.imageProcessing.features.PhaseCongruencyDetector;
import algorithms.imageProcessing.features.UnsupervisedTextureFinder;
import algorithms.imageProcessing.features.UnsupervisedTextureFinder.TexturePatchesAndResponse;
import algorithms.imageProcessing.segmentation.ColorSpace;
import algorithms.imageProcessing.segmentation.LabelToColorHelper;
import algorithms.imageProcessing.segmentation.NormalizedCuts;
import algorithms.imageProcessing.segmentation.SLICSuperPixels;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.PairIntWithIndex;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MedianSmooth;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.search.NearestNeighbor1D;
import algorithms.search.NearestNeighbor2D;
import algorithms.util.Errors;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.PairIntArrayWithColor;
import algorithms.util.ResourceFinder;
import algorithms.util.TwoDIntArray;
import com.climbwithyourfeet.clustering.DTClusterFinder;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.awt.Color;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import thirdparty.edu.princeton.cs.algs4.Interval;
import thirdparty.edu.princeton.cs.algs4.Interval2D;
import thirdparty.edu.princeton.cs.algs4.QuadTree;
import thirdparty.ods.Integerizer;
import thirdparty.ods.XFastTrie;
import thirdparty.ods.XFastTrieNode;

/**
 * Many methods in here will be removed soon.
 * Meanwhile, see MSEREdges.java for segmentation.
 * 
 * class holding several different image segmentation methods.  Note that
 * some other techniques involving contrast for example, are elsewhere.
 *
 * A few of the methods use a density based clustering algorithm from
       http://nking.github.io/two-point-correlation/
       which has an MIT license
      ---- begin nking copyright ----
      The MIT License (MIT)
      Copyright (c) 2013-* Nichole King
      http://nking.github.io/two-point-correlation/

        Permission is hereby granted, free of charge, to any person obtaining 
        a copy of this software and associated documentation files 
        (the &quot;Software&quot;), to deal in the Software without restriction, 
        including without limitation the rights to use, copy, modify, merge, 
        publish, distribute, sublicense, and/or sell copies of the Software, 
        and to permit persons to whom the Software is furnished to do so, 
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included 
        in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS 
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     ---- end nking copyright ---- 
 * 
 * @author nichole
 */
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">public class ImageSegmentation {</span>

<span class="fc" id="L108">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * applies KMeansPlusPlus algorithm to the values in input
     * (greyscale intensities) to create kBands of clustered pixels
     * (operates on input).
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */
    public void applyUsingKMPP(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {

<span class="fc" id="L122">        KMeansPlusPlus kmpp = new KMeansPlusPlus();</span>
<span class="fc" id="L123">        kmpp.computeMeans(kBands, input);</span>

<span class="fc" id="L125">        int[] seeds = kmpp.getCenters();</span>

<span class="fc" id="L127">        int[] imgSeedIndexAssignments = kmpp.getImgPixelSeedIndexes();</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; input.getNPixels(); ++pixIdx) {</span>

<span class="fc" id="L131">            int seedIdx = imgSeedIndexAssignments[pixIdx];</span>

<span class="fc" id="L133">            int seedValue = seeds[seedIdx];</span>

<span class="fc" id="L135">            input.setValue(pixIdx, seedValue);</span>
        }
<span class="fc" id="L137">    }</span>

    public void applyUsingKMPP(Image input, int kBands) throws IOException,
        NoSuchAlgorithmException {

<span class="fc" id="L142">        KMeansPlusPlusColor instance = new KMeansPlusPlusColor();</span>
<span class="fc" id="L143">        instance.computeMeans(kBands, input);</span>

<span class="fc" id="L145">        int[][] seeds = instance.getCenters();</span>

<span class="fc" id="L147">        int[] imgSeedIndexAssignments = instance.getImgPixelSeedIndexes();</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; input.getNPixels(); ++pixIdx) {</span>

<span class="fc" id="L151">            int seedIdx = imgSeedIndexAssignments[pixIdx];</span>

<span class="fc" id="L153">            int r = seeds[0][seedIdx];</span>
<span class="fc" id="L154">            int g = seeds[1][seedIdx];</span>
<span class="fc" id="L155">            int b = seeds[2][seedIdx];</span>

<span class="fc" id="L157">            input.setRGB(pixIdx, r, g, b);</span>
        }
<span class="fc" id="L159">    }</span>

    /**
     * applies binary algorithm (simple thresholding) to the values in input
     * (greyscale intensities) to create pixels given above or below highest
     * frequency value.  Note that some images may need to be pre-processed
     * in order to use this one (for example, correct for illumination and
     * remove items like sky if main objects are not sky).
     * (operates on input).
     * @param input
     */
    public void applyBinaryUsingFrequency(GreyscaleImage input) {

<span class="nc" id="L172">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(</span>
            input);

<span class="nc bnc" id="L175" title="All 4 branches missed.">        if (valueCounts == null || valueCounts.getN() == 0) {</span>
<span class="nc" id="L176">            return;</span>
        }

        //96, 30
<span class="nc" id="L180">        int divider = valueCounts.getX(0);</span>
<span class="nc" id="L181">        int v0 = 255/4;</span>
<span class="nc" id="L182">        int v1 = 3*v0;</span>

<span class="nc bnc" id="L184" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (input.getValue(i) &lt; divider) {</span>
<span class="nc" id="L186">                input.setValue(i, v0);</span>
            } else {
<span class="nc" id="L188">                input.setValue(i, v1);</span>
            }
        }

<span class="nc" id="L192">    }</span>

    /**
     * applies DTClustering algorithm to the values in input
     * (greyscale intensities) to create kBands of clustered pixels
     * (operates on input).
     * (This one is competitive with applyUsingPolarCIEXYAndFrequency
     * with lowFreqLimit 0.1f)
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */
    public void applyUsingDTClustering(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {

<span class="nc" id="L208">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(</span>
            input);

        // first, trying clustering by value and frequency,
        // second, compare that to clustering just by giving points as value,value
        //    which is effectivly a 1D clustering
        //Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();
<span class="nc" id="L215">        Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; points =</span>
            new HashSet&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;();

<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (int i = 0; i &lt; valueCounts.getN(); ++i) {</span>
<span class="nc" id="L219">            com.climbwithyourfeet.clustering.util.PairInt p = new</span>
                com.climbwithyourfeet.clustering.util.PairInt(
<span class="nc" id="L221">                    valueCounts.getX(i), valueCounts.getY(i));</span>

<span class="nc" id="L223">            points.add(p);</span>
        }

<span class="nc" id="L226">        DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; cFinder</span>
            = new DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;(
<span class="nc" id="L228">                points, input.getWidth(), input.getHeight());</span>

<span class="nc" id="L230">        cFinder.calculateCriticalDensity();</span>

<span class="nc" id="L232">        cFinder.findClusters();</span>

<span class="nc" id="L234">        int n = cFinder.getNumberOfClusters();</span>

<span class="nc" id="L236">        int[] centers = new int[n];</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="nc" id="L239">            Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; set = cFinder.getCluster(i);</span>

            // find centeroid for x
<span class="nc" id="L242">            double xc = 0;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (com.climbwithyourfeet.clustering.util.PairInt p : set) {</span>
<span class="nc" id="L244">                double x1 = p.getX();</span>
<span class="nc" id="L245">                xc += x1;</span>
<span class="nc" id="L246">            }</span>

<span class="nc" id="L248">            centers[i] = (int)Math.round(xc/(double)set.size());</span>
        }

<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (n &gt; kBands) {</span>
<span class="nc" id="L252">            n = kBands;</span>
        }

<span class="nc" id="L255">        Arrays.sort(centers);</span>
<span class="nc" id="L256">        int[] kCenters = new int[n];</span>
<span class="nc" id="L257">        int count = 0;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (int i = (centers.length - 1); i &gt; (centers.length - 1 - n); --i) {</span>
<span class="nc" id="L259">            kCenters[count] = centers[i];</span>
<span class="nc" id="L260">            count++;</span>
        }

<span class="nc" id="L263">        assignToNearestCluster(input, kCenters);</span>
<span class="nc" id="L264">    }</span>

    /**
     * places points by their proximity to cluster centers
     * @param input
     * @param binCenters
     */
    public void assignToNearestCluster(GreyscaleImage input,
        int[] binCenters) {

<span class="nc" id="L274">        int maxC = input.getMax();</span>

<span class="nc" id="L276">        Integerizer&lt;Integer&gt; it = new Integerizer&lt;Integer&gt;() {</span>
            @Override
            public int intValue(Integer x) {return x;}
        };

<span class="nc" id="L281">        XFastTrieNode&lt;Integer&gt; node = new XFastTrieNode&lt;Integer&gt;();</span>

<span class="nc" id="L283">        int w = 1 + (int)Math.ceil(Math.log(maxC)/Math.log(2));</span>

<span class="nc" id="L285">        XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt; xft</span>
            = new XFastTrie&lt;XFastTrieNode&lt;Integer&gt;, Integer&gt;(node, it, w);

<span class="nc bnc" id="L288" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="nc" id="L292">                int v = input.getValue(col, row);</span>

<span class="nc" id="L294">                Integer key = Integer.valueOf(v);</span>

<span class="nc" id="L296">                Integer vc = xft.find(key);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (vc == null) {</span>
<span class="nc" id="L298">                    Integer vP = xft.predecessor(key);</span>
<span class="nc" id="L299">                    Integer vS = xft.successor(key);</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">                    if (vP != null &amp;&amp; vS != null) {</span>
<span class="nc" id="L301">                        int diffP = Math.abs(vP.intValue() - v);</span>
<span class="nc" id="L302">                        int diffS = Math.abs(vS.intValue() - v);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                        if (diffP &lt; diffS) {</span>
<span class="nc" id="L304">                            vc = vP;</span>
                        } else {
<span class="nc" id="L306">                            vc = vS;</span>
                        }
<span class="nc bnc" id="L308" title="All 2 branches missed.">                    } else if (vP != null) {</span>
<span class="nc" id="L309">                        vc = vP;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                    } else if (vS != null) {</span>
<span class="nc" id="L311">                        vc = vS;</span>
                    } else {
<span class="nc" id="L313">                        throw new IllegalArgumentException(</span>
                            &quot;closest not found&quot;);
                    }
                }

<span class="nc" id="L318">                input.setValue(col, row, vc);</span>
            }
        }
<span class="nc" id="L321">    }</span>

    public List&lt;Set&lt;PairInt&gt;&gt; assignToNearestPolarCIECluster(
        Map&lt;PairInt, Integer&gt; polarCIEXYMap, int[] binCenters) {

<span class="nc" id="L326">        Arrays.sort(binCenters);</span>

<span class="nc" id="L328">        int nc = binCenters.length;</span>

<span class="nc" id="L330">        List&lt;Set&lt;PairInt&gt;&gt; groups = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        for (int i = 0; i &lt; nc; ++i) {</span>
<span class="nc" id="L332">            groups.add(new HashSet&lt;PairInt&gt;());</span>
        }

<span class="nc bnc" id="L335" title="All 2 branches missed.">        for (Entry&lt;PairInt, Integer&gt; entry : polarCIEXYMap.entrySet()) {</span>

<span class="nc" id="L337">            int theta = entry.getValue().intValue();</span>

<span class="nc" id="L339">            int idx = Arrays.binarySearch(binCenters, theta);</span>
            // if it's negative, (-(insertion point) - 1)
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (idx &lt; 0) {</span>
                // idx = -*idx2 - 1
<span class="nc" id="L343">                idx = -1*(idx + 1);</span>
            }
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (idx &gt; (nc - 1)) {</span>
<span class="nc" id="L346">                idx = nc - 1;</span>
            }

<span class="nc" id="L349">            int vc = binCenters[idx];</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (idx == 0) {</span>

<span class="nc" id="L353">                int bisectorBelowHalfLength = (360 - binCenters[nc - 1] + vc)/2;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if ((vc - theta) &gt; bisectorBelowHalfLength) {</span>
<span class="nc" id="L355">                    idx = nc - 1;</span>
                }

<span class="nc" id="L358">            } else {</span>

<span class="nc" id="L360">                int bisectorBelow = ((binCenters[idx - 1] + vc) / 2);</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">                if (theta &lt; bisectorBelow) {</span>
<span class="nc" id="L363">                    idx = idx - 1;</span>
                }
            }

<span class="nc" id="L367">            Set&lt;PairInt&gt; set = groups.get(Integer.valueOf(idx));</span>
<span class="nc" id="L368">            set.add(entry.getKey());</span>
<span class="nc" id="L369">        }</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">        for (int i = (groups.size() - 1); i &gt; -1; --i) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (groups.get(i).isEmpty()) {</span>
<span class="nc" id="L373">                groups.remove(i);</span>
            }
        }

<span class="nc" id="L377">        return groups;</span>
    }

    /**
     * applies a blur of sigma=1 to image,
     * converts each pixel color to the polar angle of CIE XY Lab color space
     * with an origin of (0.35, 0.35) and uses a histogram binning of kColors=8,
     * then maps those bins to 0 to 255,
     * then replaces a pixel if 5,6 or its neighbors have the same color,
     * then applies histogram equalization to stretch the values to range
     * 0 to 255.
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistEq(ImageExt input) {

<span class="nc" id="L393">        int kColors = 8;</span>

<span class="nc" id="L395">        return applyUsingCIEXYPolarThetaThenHistEq(input, kColors, true);</span>
    }

    /**
     * converts each pixel color to the polar angle of CIE XY Lab color space
     * with an origin of (0.35, 0.35) and uses a histogram binning of kColors,
     * then maps those bins to 0 to 255,
     * then replaces a pixel if 5,6 or its neighbors have the same color,
     * then applies histogram equalization to stretch the values to range
     * 0 to 255.
     * runtime complexity is about O(N) + O(N * lg_2(N)) though the later
     * term has small constant multiples of it.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur if true, a blur of sigma=1 is applied to the image before
     * processing.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistEq(ImageExt input,
        int kColors, boolean useBlur) {

<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L418">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L421">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

<span class="nc" id="L424">        ImageProcessor imageProcessor = new ImageProcessor();</span>

        GreyscaleImage img;

        int minNeighborLimit;

<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (useBlur) {</span>

<span class="nc" id="L432">            Image input2 = input.copyImage();</span>

            //O(N) + O(N * lg_2(N)) where N=n_pixels and k=kernel.length
<span class="nc" id="L435">            imageProcessor.blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

            //O(N) + O(N * lg_2(N))
<span class="nc" id="L438">            img = applyUsingCIEXYPolarThetaThenHistogram(input2, kColors);</span>

<span class="nc" id="L440">            minNeighborLimit = 6;</span>

<span class="nc" id="L442">        } else {</span>

            //O(N) + O(N * lg_2(N))
<span class="nc" id="L445">            img = applyUsingCIEXYPolarThetaThenHistogram(input, kColors);</span>

<span class="nc" id="L447">            minNeighborLimit = 5;</span>
        }

<span class="nc" id="L450">        int w = img.getWidth();</span>
<span class="nc" id="L451">        int h = img.getHeight();</span>

        // ----replace pixel, if 5,6 or more neighbors have same color -----
<span class="nc" id="L454">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="nc" id="L455">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="nc" id="L457">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L459">        int nChanged = 1;</span>
<span class="nc" id="L460">        int nIterMax = 100;</span>
<span class="nc" id="L461">        int nIter = 0;</span>

        // change value of pixels largely surrounded by another value

        // runtime complexity is nIterations * O(N*8)
        // number of iterations appears to be small multiple of minNeighborLimit
<span class="nc bnc" id="L467" title="All 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="nc" id="L469">            log.fine(&quot;***nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged +</span>
                &quot; minNeighbotLimit=&quot; + minNeighborLimit);

<span class="nc" id="L472">            nChanged = 0;</span>

            //O(N*8)
<span class="nc bnc" id="L475" title="All 2 branches missed.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L478">                    freqMap.clear();</span>

<span class="nc" id="L480">                    Integer maxCountValue = null;</span>
<span class="nc" id="L481">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="nc" id="L484">                        int x = dxs[nIdx] + col;</span>
<span class="nc" id="L485">                        int y = dys[nIdx] + row;</span>

<span class="nc bnc" id="L487" title="All 8 branches missed.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L488">                            break;</span>
                        }

<span class="nc" id="L491">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="nc" id="L493">                        Integer c = freqMap.get(v);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L495">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="nc" id="L497">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="nc" id="L499">                        freqMap.put(v, c);</span>

<span class="nc bnc" id="L501" title="All 2 branches missed.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="nc" id="L502">                            maxCount = c.intValue();</span>
<span class="nc" id="L503">                            maxCountValue = v;</span>
                        }
                    }

<span class="nc bnc" id="L507" title="All 2 branches missed.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="nc" id="L510">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="nc" id="L511">                        nChanged++;</span>
                    }
                }
            }

<span class="nc" id="L516">            nIter++;</span>
        }

        // rescale the image
<span class="nc" id="L520">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L521">        hEq.applyFilter();</span>

<span class="nc" id="L523">        return img;</span>
    }

    /**
     * applies a blur of sigma=1 to image,
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors=8 bins points then remaps the points to use the
     * range 0 to 255, then replaces a pixel if it has 7 neighbors of same
     * color, then applies histogram equalization to rescale the range to be
     * between 0 and 255.
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPPThenHistEq(ImageExt
        input) throws IOException, NoSuchAlgorithmException {

<span class="nc" id="L539">        int kColors = 8;</span>

<span class="nc" id="L541">        return applyUsingCIEXYPolarThetaThenKMPPThenHistEq(input, kColors, true);</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors bins points then remaps the points to use the
     * range 0 to 255, then replaces a pixel if it has 5,6 neighbors of same
     * color, then applies histogram equalization to rescale the range to be
     * between 0 and 255.
     *
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPPThenHistEq(
        ImageExt input,
        int kColors, boolean useBlur)
        throws IOException, NoSuchAlgorithmException {

<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L563">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L566">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

<span class="nc" id="L569">        ImageProcessor imageProcessor = new ImageProcessor();</span>

        GreyscaleImage img;

        int minNeighborLimit;

<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (useBlur) {</span>

<span class="nc" id="L577">            Image input2 = input.copyImage();</span>

<span class="nc" id="L579">            imageProcessor.blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="nc" id="L581">            img = applyUsingCIEXYPolarThetaThenKMPP(input2, kColors);</span>

<span class="nc" id="L583">            minNeighborLimit = 6;</span>

<span class="nc" id="L585">        } else {</span>

<span class="nc" id="L587">            img = applyUsingCIEXYPolarThetaThenKMPP(input, kColors);</span>

<span class="nc" id="L589">            minNeighborLimit = 5;</span>
        }

<span class="nc" id="L592">        int w = img.getWidth();</span>
<span class="nc" id="L593">        int h = img.getHeight();</span>

        // ----replace pixel, if 5,6 or more neighbors have same color -----
<span class="nc" id="L596">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="nc" id="L597">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="nc" id="L599">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L601">        int nChanged = 1;</span>
<span class="nc" id="L602">        int nIterMax = 100;</span>
<span class="nc" id="L603">        int nIter = 0;</span>

<span class="nc bnc" id="L605" title="All 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="nc" id="L607">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="nc" id="L609">            nChanged = 0;</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L614">                    freqMap.clear();</span>

<span class="nc" id="L616">                    Integer maxCountValue = null;</span>
<span class="nc" id="L617">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="nc" id="L620">                        int x = dxs[nIdx] + col;</span>
<span class="nc" id="L621">                        int y = dys[nIdx] + row;</span>

<span class="nc bnc" id="L623" title="All 8 branches missed.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L624">                            break;</span>
                        }

<span class="nc" id="L627">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="nc" id="L629">                        Integer c = freqMap.get(v);</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L631">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="nc" id="L633">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="nc" id="L635">                        freqMap.put(v, c);</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="nc" id="L638">                            maxCount = c.intValue();</span>
<span class="nc" id="L639">                            maxCountValue = v;</span>
                        }
                    }

<span class="nc bnc" id="L643" title="All 2 branches missed.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="nc" id="L646">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="nc" id="L647">                        nChanged++;</span>
                    }
                }
            }

<span class="nc" id="L652">            nIter++;</span>
        }

        // rescale the image
<span class="nc" id="L656">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L657">        hEq.applyFilter();</span>

<span class="nc" id="L659">        return img;</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta,
     * then applies histogram mapping of kColors to remap the pixels to
     * values between 0 and 255.
     *
     * @param input
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistogram(Image input) {

<span class="nc" id="L672">        return applyUsingCIEXYPolarThetaThenHistogram(input, 253);</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta,
     * then applies histogram mapping of kColors to remap the pixels to
     * values between 0 and 255.
     * runtime complexity is O(N) + O(N * lg_2(N)).
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenHistogram(Image input,
        int kColors) {

<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L689">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L692">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="nc" id="L702">        int w = input.getWidth();</span>
<span class="nc" id="L703">        int h = input.getHeight();</span>

<span class="nc" id="L705">        float[] tmpColorBuffer = new float[2];</span>

<span class="nc" id="L707">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="nc" id="L709">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="nc" id="L711">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L713">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="nc" id="L714">        int thetaCount = 0;</span>

<span class="nc bnc" id="L716" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L719">                PairInt p = new PairInt(col, row);</span>

<span class="nc" id="L721">                int r = input.getR(col, row);</span>
<span class="nc" id="L722">                int g = input.getG(col, row);</span>
<span class="nc" id="L723">                int b = input.getB(col, row);</span>

<span class="nc bnc" id="L725" title="All 6 branches missed.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="nc" id="L726">                    continue;</span>
<span class="nc bnc" id="L727" title="All 6 branches missed.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="nc" id="L728">                    output.setValue(col, row, 255);</span>
<span class="nc" id="L729">                    continue;</span>
                }

<span class="nc" id="L732">                float[] cieXY = tmpColorBuffer;</span>
<span class="nc" id="L733">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="nc bnc" id="L735" title="All 2 branches missed.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="nc" id="L736">                    output.setValue(col, row, 255);</span>
                } else {

<span class="nc" id="L739">                    double thetaRadians = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="nc" id="L741">                    thetaValues[thetaCount] = (float)thetaRadians;</span>

<span class="nc" id="L743">                    pixThetaMap.put(p, Float.valueOf((float)thetaRadians));</span>

<span class="nc" id="L745">                    thetaCount++;</span>
                }
            }
        }

<span class="nc" id="L750">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

        // O(N * lg_2(N))
<span class="nc" id="L753">        createAndApplyHistMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="nc" id="L755">        return output;</span>
    }

    /**
     * converts each pixel's color into CIE XY polar theta, then uses KMeansPlusPlus
     * to create kColors bins points then remaps the points to use the
     * range 0 to 255.
     *
     * runtime complexity is O(N) + O(N*lg_2(N))
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage applyUsingCIEXYPolarThetaThenKMPP(Image input,
        int kColors) throws IOException, NoSuchAlgorithmException {

<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L774">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L776" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L777">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="nc" id="L787">        int w = input.getWidth();</span>
<span class="nc" id="L788">        int h = input.getHeight();</span>

<span class="nc" id="L790">        float[] tmpColorBuffer = new float[2];</span>

<span class="nc" id="L792">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="nc" id="L794">        Map&lt;PairInt, Integer&gt; pixThetaMap = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc" id="L796">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L798">        int[] thetaValues = new int[input.getNPixels()];</span>
<span class="nc" id="L799">        int thetaCount = 0;</span>

<span class="nc bnc" id="L801" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L804">                PairInt p = new PairInt(col, row);</span>

<span class="nc" id="L806">                int r = input.getR(col, row);</span>
<span class="nc" id="L807">                int g = input.getG(col, row);</span>
<span class="nc" id="L808">                int b = input.getB(col, row);</span>

<span class="nc bnc" id="L810" title="All 6 branches missed.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="nc" id="L811">                    continue;</span>
<span class="nc bnc" id="L812" title="All 6 branches missed.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="nc" id="L813">                    output.setValue(col, row, 255);</span>
<span class="nc" id="L814">                    continue;</span>
                }

<span class="nc" id="L817">                float[] cieXY = tmpColorBuffer;</span>
<span class="nc" id="L818">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="nc bnc" id="L820" title="All 2 branches missed.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="nc" id="L821">                    output.setValue(col, row, 255);</span>
                } else {

<span class="nc" id="L824">                    double thetaRadians = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="nc" id="L826">                    int thetaDegrees = Math.round(</span>
                        (float)(thetaRadians * 180./Math.PI));
<span class="nc" id="L828">                    thetaValues[thetaCount] = thetaDegrees;</span>

<span class="nc" id="L830">                    pixThetaMap.put(p, Integer.valueOf(thetaDegrees));</span>

<span class="nc" id="L832">                    thetaCount++;</span>
                }
            }
        }

<span class="nc" id="L837">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="nc" id="L839">        createAndApplyKMPPMapping(output, pixThetaMap, thetaValues,</span>
            kColors);

<span class="nc" id="L842">        return output;</span>
    }

    private void createAndApplyKMPPMapping(GreyscaleImage output,
        Map&lt;PairInt, Integer&gt; pixThetaMap, int[] thetaValues,
        final int kColors) throws IOException, NoSuchAlgorithmException {

        //TODO: assert kColors.  The invoker is reserving 2 bands for
        // B &amp; W, so nBins should probably be (kColors - 2)...
        // correct this for the invoker when testing
<span class="nc" id="L852">        int nBins = kColors;</span>

<span class="nc" id="L854">        KMeansPlusPlus kmpp = new KMeansPlusPlus();</span>
<span class="nc" id="L855">        kmpp.computeMeans(nBins, thetaValues);</span>

<span class="nc" id="L857">        int[] imgPixelAssignmentIndexes =</span>
<span class="nc" id="L858">            kmpp.getImgPixelSeedIndexes();</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">        for (int i = 0; i &lt; imgPixelAssignmentIndexes.length; ++i) {</span>

<span class="nc" id="L862">            int assigned = imgPixelAssignmentIndexes[i];</span>

<span class="nc" id="L864">            int mappedValue = 255 - nBins + assigned;</span>

<span class="nc" id="L866">            output.setValue(i, mappedValue);</span>
        }
<span class="nc" id="L868">    }</span>

    /**
     * for the given thetaValues, create a histogram of kColors bins and then
     * apply the bins to points with those values in the output image.
     * The values in the output image are populated from high value of
     * roughly 254 down to kColors in lower pixel value.
     * The range is approximate because some histograms have gaps for a color
     * bin, so those are not mapped to the final image.
     *
     * runtime complexity is O(N * lg_2(N)).
     * @param output
     * @param pixThetaMap
     * @param thetaValues
     * @param kColors
     */
    private void createAndApplyHistMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

<span class="nc" id="L888">        float minValue = MiscMath.findMin(thetaValues);</span>
<span class="nc" id="L889">        float maxValue = MiscMath.findMax(thetaValues);</span>

<span class="nc" id="L891">        log.fine(&quot;minTheta=&quot; + (minValue * 180./Math.PI) +</span>
            &quot; maxTheta=&quot; + (maxValue * 180./Math.PI));

<span class="nc" id="L894">        int nReserved = 254 - kColors;</span>

<span class="nc" id="L896">        HistogramHolder hist = Histogram.createSimpleHistogram(minValue,</span>
            maxValue, (256 - nReserved - 1), thetaValues,
<span class="nc" id="L898">            Errors.populateYErrorsBySqrt(thetaValues));</span>

        /*
        try {
            hist.plotHistogram(&quot;cie XY theta histogram&quot;, &quot;cieXY_hist_&quot;
                + MiscDebug.getCurrentTimeFormatted());
        } catch (Exception e) {}
        */

<span class="nc" id="L907">        int nonZeroCount = 0;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="nc" id="L909">            int c = hist.getYHist()[i];</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L911">                nonZeroCount++;</span>
            }
        }

<span class="nc" id="L915">        float[] startBins = new float[nonZeroCount];</span>

<span class="nc" id="L917">        float halfBinWidth = (hist.getXHist()[1] - hist.getXHist()[0])/2.f;</span>

<span class="nc" id="L919">        nonZeroCount = 0;</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="nc" id="L921">            int c = hist.getYHist()[i];</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L923">                startBins[nonZeroCount] = hist.getXHist()[i] - halfBinWidth;</span>
<span class="nc" id="L924">                nonZeroCount++;</span>
            }
        }

<span class="nc" id="L928">        Iterator&lt;Map.Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

        // O(N * lg_2(N))
<span class="nc bnc" id="L931" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L933">            Map.Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="nc" id="L935">            PairInt p = entry.getKey();</span>

<span class="nc" id="L937">            float theta = entry.getValue().floatValue();</span>

<span class="nc" id="L939">            int idx = Arrays.binarySearch(startBins, theta);</span>

            // if it's negative, (-(insertion point) - 1)
<span class="nc bnc" id="L942" title="All 2 branches missed.">            if (idx &lt; 0) {</span>
                // idx = -*idx2 - 1
<span class="nc" id="L944">                idx = -1*(idx + 1);</span>
            }

<span class="nc" id="L947">            int mappedValue = 255 - startBins.length + idx;</span>

<span class="nc" id="L949">            output.setValue(p.getX(), p.getY(), mappedValue);</span>
<span class="nc" id="L950">        }</span>
<span class="nc" id="L951">    }</span>

    /**
     * NOT READY FOR USE.  STILL EXPERIMENTING.
     *
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to CIEXY Lab color space, then creates a map of the
     * CIEX and CIEY points and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters of points in CIE X, CIEY space,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * cie xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param useBlur
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingCIEXYAndClustering(ImageExt input,
        boolean useBlur) {

        //TODO: improve the clustering results in two ways:
        // (1) for smaller ciexy clusters, merge with adjacent clusters if
        //     similar color
        // (2) any pixel with 7 neighbors of same color should be that color too

<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (useBlur) {</span>
<span class="nc" id="L985">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L986">            imageProcessor.blur(input, 1.0f);</span>
        }

        //TODO: consider making a segmentation method using CIEXY theta
        // for x and the frequency for y, both scaled to numerically
        // resolvable range &lt; max of 5000.
        // this would be good to compare to the method here which
        // uses CIE XY Theta followed by histograms or KMeans++.
        // No need to specify the number of bins before use for suggested
        // version.

        //NOTE: the method needs to have gaps in the data given to it
        //    that is a lack of points for some region between the
        //    min and max of x and y data in integer space

        // max = 6250 unless reduce space complexity
<span class="nc" id="L1002">        float factor = 2000;// learn this from numerical resolution</span>

        // then subtract the minima in both cieX and cieY

<span class="nc" id="L1006">        int minCIEX = Integer.MAX_VALUE;</span>
<span class="nc" id="L1007">        int minCIEY = Integer.MAX_VALUE;</span>
<span class="nc" id="L1008">        int maxCIEX = Integer.MIN_VALUE;</span>
<span class="nc" id="L1009">        int maxCIEY = Integer.MIN_VALUE;</span>

<span class="nc" id="L1011">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1013">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L1015">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1017">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1019">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

        // -------- debug -------
<span class="nc" id="L1022">        int nGrey = 0;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L1024">            nGrey += entry.getValue().size();</span>
<span class="nc" id="L1025">        }</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        assert((points0.size() + blackPixels.size() + nGrey +</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            whitePixels.size()) == input.getNPixels());</span>
        // -------- end debug -------

<span class="nc" id="L1030">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>

        // ------- debug -------
<span class="nc" id="L1033">        int nGrey2 = 0;</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc" id="L1035">            nGrey2 += set.size();</span>
<span class="nc" id="L1036">        }</span>
<span class="nc bnc" id="L1037" title="All 4 branches missed.">        assert(nGrey == nGrey2);</span>
        // ------- end debug =====

<span class="nc" id="L1040">        Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap0 =</span>
            new HashMap&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt;();

<span class="nc bnc" id="L1043" title="All 2 branches missed.">        for (PairInt p : points0) {</span>
<span class="nc" id="L1044">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="nc" id="L1045">            float cx = input.getCIEX(idx);</span>
<span class="nc" id="L1046">            float cy = input.getCIEY(idx);</span>

<span class="nc" id="L1048">            int cieXInt = Math.round(factor * cx);</span>
<span class="nc" id="L1049">            int cieYInt = Math.round(factor * cy);</span>

<span class="nc" id="L1051">            PairIntWithIndex p0 = new PairIntWithIndex(cieXInt, cieYInt, idx);</span>
<span class="nc" id="L1052">            List&lt;PairIntWithIndex&gt; list = pointsMap0.get(p0);</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L1054">                list = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="nc" id="L1055">                pointsMap0.put(p0, list);</span>
            }
<span class="nc" id="L1057">            list.add(p0);</span>

<span class="nc bnc" id="L1059" title="All 2 branches missed.">            if (cieXInt &lt; minCIEX) {</span>
<span class="nc" id="L1060">                minCIEX = cieXInt;</span>
            }
<span class="nc bnc" id="L1062" title="All 2 branches missed.">            if (cieYInt &lt; minCIEY) {</span>
<span class="nc" id="L1063">                minCIEY = cieYInt;</span>
            }
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            if (cieXInt &gt; maxCIEX) {</span>
<span class="nc" id="L1066">                maxCIEX = cieXInt;</span>
            }
<span class="nc bnc" id="L1068" title="All 2 branches missed.">            if (cieYInt &gt; maxCIEY) {</span>
<span class="nc" id="L1069">                maxCIEY = cieYInt;</span>
            }
<span class="nc" id="L1071">        }</span>

<span class="nc" id="L1073">        Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap =</span>
            new HashMap&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt;();

        // subtract minima from the points
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        for (PairIntWithIndex p : pointsMap0.keySet()) {</span>

<span class="nc" id="L1079">            int x = p.getX() - minCIEX;</span>
<span class="nc" id="L1080">            int y = p.getY() - minCIEY;</span>

<span class="nc" id="L1082">            PairIntWithIndex p2 = new PairIntWithIndex(x, y, p.getPixIndex());</span>
<span class="nc" id="L1083">            List&lt;PairIntWithIndex&gt; list2 = pointsMap.get(p2);</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if (list2 == null) {</span>
<span class="nc" id="L1085">                list2 = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="nc" id="L1086">                pointsMap.put(p2, list2);</span>
            }
            // because this is a list, this will eventually be present twice:
            //list2.add(p2);

<span class="nc bnc" id="L1091" title="All 2 branches missed.">            for (PairIntWithIndex p0 : pointsMap0.get(p)) {</span>
<span class="nc" id="L1092">                PairIntWithIndex p3 = new PairIntWithIndex(</span>
<span class="nc" id="L1093">                    p0.getX() - minCIEX, p0.getY() - minCIEY, p0.getPixIndex());</span>
<span class="nc" id="L1094">                list2.add(p3);</span>
<span class="nc" id="L1095">            }</span>
<span class="nc" id="L1096">        }</span>
<span class="nc" id="L1097">        maxCIEX -= minCIEX;</span>
<span class="nc" id="L1098">        maxCIEY -= minCIEY;</span>

        // frequency of colors:
<span class="nc" id="L1101">        Map&lt;PairIntWithIndex, Integer&gt; freqMap = new</span>
            HashMap&lt;PairIntWithIndex, Integer&gt;();
        for (Map.Entry&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; entry :
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            pointsMap.entrySet()) {</span>
<span class="nc" id="L1105">            int c = entry.getValue().size();</span>
<span class="nc" id="L1106">            freqMap.put(entry.getKey(), Integer.valueOf(c));</span>
<span class="nc" id="L1107">        }</span>

        // ----- debug ---
<span class="nc" id="L1110">        int nGreyBW = nGrey + blackPixels.size() + whitePixels.size();</span>
<span class="nc" id="L1111">        int nTot = 0;</span>
        //Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        for (Entry&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; entry : pointsMap.entrySet()) {</span>
<span class="nc" id="L1114">            nTot += entry.getValue().size();</span>
<span class="nc" id="L1115">        }</span>
<span class="nc" id="L1116">        nTot += nGreyBW;</span>
<span class="nc" id="L1117">        log.info(&quot;nTot=&quot; + nTot + &quot; nPixels=&quot; + input.getNPixels());</span>
<span class="nc bnc" id="L1118" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>

        // plot the points as an image to see the data first
<span class="nc" id="L1121">        GreyscaleImage img = new GreyscaleImage(maxCIEX + 1, maxCIEY + 1);</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        for (com.climbwithyourfeet.clustering.util.PairInt p : pointsMap.keySet()) {</span>
<span class="nc" id="L1123">            img.setValue(p.getX(), p.getY(), 255);</span>
<span class="nc" id="L1124">        }</span>
        try {
<span class="nc" id="L1126">            ImageIOHelper.writeOutputImage(</span>
<span class="nc" id="L1127">                ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt_input.png&quot;, img);</span>
<span class="nc" id="L1128">        } catch (IOException ex) {</span>
<span class="nc" id="L1129">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="nc" id="L1131">        }</span>
        // --- end debug

        //Map&lt;PairIntWithIndex, List&lt;PairIntWithIndex&gt;&gt; pointsMap

<span class="nc" id="L1136">        DTClusterFinder&lt;PairIntWithIndex&gt; clusterFinder</span>
<span class="nc" id="L1137">            = new DTClusterFinder&lt;PairIntWithIndex&gt;(pointsMap.keySet(),</span>
            maxCIEX + 1, maxCIEY + 1);

<span class="nc" id="L1140">        clusterFinder.setToDebug();</span>

        // to recover every point, set limit to 1
<span class="nc" id="L1143">        clusterFinder.setMinimumNumberInCluster(1);</span>

<span class="nc" id="L1145">        clusterFinder.calculateCriticalDensity();</span>

<span class="nc" id="L1147">        clusterFinder.findClusters();</span>

<span class="nc" id="L1149">        log.info(&quot;clustering critical density=&quot; + clusterFinder.getCriticalDensity());</span>

<span class="nc" id="L1151">        int nGroups = clusterFinder.getNumberOfClusters();</span>

<span class="nc" id="L1153">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="nc bnc" id="L1155" title="All 2 branches missed.">        for (int k = 0; k &lt; nGroups; ++k) {</span>

<span class="nc" id="L1157">            Set&lt;PairIntWithIndex&gt; group = clusterFinder.getCluster(k);</span>

<span class="nc" id="L1159">            Set&lt;PairInt&gt; coordPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1161" title="All 2 branches missed.">            for (PairIntWithIndex p : group) {</span>

<span class="nc" id="L1163">                int idx = p.getPixIndex();</span>
<span class="nc" id="L1164">                int xCoord = input.getCol(idx);</span>
<span class="nc" id="L1165">                int yCoord = input.getRow(idx);</span>

<span class="nc" id="L1167">                PairInt pCoord = new PairInt(xCoord, yCoord);</span>
<span class="nc" id="L1168">                coordPoints.add(pCoord);</span>

                // include the other points of/ same color
<span class="nc" id="L1171">                List&lt;PairIntWithIndex&gt; list = pointsMap.get(p);</span>
<span class="nc bnc" id="L1172" title="All 4 branches missed.">                assert(list != null);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                for (PairIntWithIndex p3 : list) {</span>
<span class="nc" id="L1174">                    int idx3 = p3.getPixIndex();</span>
<span class="nc" id="L1175">                    int xCoord3 = input.getCol(idx3);</span>
<span class="nc" id="L1176">                    int yCoord3 = input.getRow(idx3);</span>
<span class="nc" id="L1177">                    pCoord = new PairInt(xCoord3, yCoord3);</span>
<span class="nc" id="L1178">                    coordPoints.add(pCoord);</span>
<span class="nc" id="L1179">                }</span>
<span class="nc" id="L1180">            }</span>

<span class="nc" id="L1182">            groupList.add(coordPoints);</span>
        }

        // ------ debug ---------
<span class="nc" id="L1186">        nTot = 0;</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : groupList) {</span>
<span class="nc" id="L1188">            nTot += set.size();</span>
<span class="nc" id="L1189">        }</span>
<span class="nc" id="L1190">        nTot += nGreyBW;</span>
<span class="nc" id="L1191">        log.info(&quot;nTot=&quot; + nTot + &quot; nPixels=&quot; + input.getNPixels());</span>
<span class="nc bnc" id="L1192" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // ------ end debug -----

<span class="nc" id="L1195">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList,</span>
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
<span class="nc" id="L1199">        groupList.add(blackPixels);</span>
<span class="nc" id="L1200">        groupList.add(whitePixels);</span>

<span class="nc" id="L1202">        int nTot2 = 0;</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; groups : groupList) {</span>
<span class="nc" id="L1204">            nTot2 += groups.size();</span>
<span class="nc" id="L1205">        }</span>

<span class="nc" id="L1207">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot2=&quot; + nTot2);</span>
<span class="nc bnc" id="L1208" title="All 4 branches missed.">        assert(nTot2 == input.getNPixels());</span>

<span class="nc" id="L1210">        return groupList;</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency)
     * and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters in that space (polar CIEXY vs frequency),
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameters are the scaling of the range of polar angles
     * and the range of frequency in order to place the data between values of 0
     * and a number.
     * &lt;code&gt;The scale factors are double xFactor = 2000. and int yFactor = 2000
     * for example.  Smaller scale factors result in faster runtimes,
     * but must be balanced by a large enough factor to have cluster resulution.
     * &lt;/code&gt;
     * Note that the polar angle vs frequency maps are actually partitioned into
     * 4 maps to do density based cluster finding separately.
     * partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f} is the fraction of
     * the maximum frequency defining a partition.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndClustering(ImageExt input,
        boolean useBlur) {

<span class="nc" id="L1249">        return calculateUsingPolarCIEXYAndClustering(input, 2000., 2000, useBlur);</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency)
     * and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters in that space (polar CIEXY vs frequency),
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameters are the scaling of the range of polar angles
     * and the range of frequency in order to place the data between values of 0
     * and a number.
     * &lt;code&gt;The scale factors are double xFactor = 2000. and int yFactor = 2000
     * for example.  Smaller scale factors result in faster runtimes,
     * but must be balanced by a large enough factor to have cluster resulution.
     * &lt;/code&gt;
     * Note that the polar angle vs frequency maps are actually partitioned into
     * 4 maps to do density based cluster finding separately.
     * partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f} is the fraction of
     * the maximum frequency defining a partition.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param thetaRange range to scale the values of cie xy polar theta values
     * to (the range affects the speed because dynamic programming is used).
     * @param thetaFrequencyRange range to scale the values of frequencies of polar
     * theta values to (the range affects the speed because dynamic programming is used).
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndClustering(ImageExt input,
        double thetaRange, int thetaFrequencyRange, boolean useBlur) {

<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (useBlur) {</span>
<span class="nc" id="L1293">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L1294">            imageProcessor.blur(input, 1.0f);</span>
        }

        //making a segmentation method using CIEXY theta
        // for x and the frequency for y, both scaled to numerically
        // resolvable range &lt; max of 5000.
        // this would be good to compare to the method here which
        // uses CIE XY Theta followed by histograms or KMeans++.
        // No need to specify the number of bins before use for suggested
        // version.

<span class="nc" id="L1305">        int w = input.getWidth();</span>
<span class="nc" id="L1306">        int h = input.getHeight();</span>

<span class="nc" id="L1308">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1310">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L1312">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1314">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L1316">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

<span class="nc" id="L1318">        double[] minMaxTheta0 = findMinMaxTheta(input, points0);</span>

<span class="nc" id="L1320">        log.info(&quot;for all non-white and non-black, minTheta=&quot; + minMaxTheta0[0]</span>
            + &quot; maxTheta=&quot; + minMaxTheta0[1]);

        // -------- debug -------
<span class="nc" id="L1324">        int nGrey = 0;</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L1326">            nGrey += entry.getValue().size();</span>
<span class="nc" id="L1327">        }</span>
<span class="nc" id="L1328">        int nGreyBW = + blackPixels.size() + nGrey + whitePixels.size();</span>
<span class="nc" id="L1329">        int nTot = (points0.size() + nGreyBW);</span>
<span class="nc" id="L1330">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="nc bnc" id="L1331" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // -------- end debug -------

<span class="nc" id="L1334">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>

<span class="nc" id="L1336">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(greyPixelGroups.size());</span>

<span class="nc bnc" id="L1338" title="All 2 branches missed.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">             if (points0.isEmpty()) {</span>
<span class="nc" id="L1340">                 groupList.add(points0);</span>
             }
<span class="nc bnc" id="L1342" title="All 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="nc" id="L1343">                 groupList.add(blackPixels);</span>
             }
<span class="nc bnc" id="L1345" title="All 2 branches missed.">             for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc" id="L1346">                groupList.add(set);</span>
<span class="nc" id="L1347">             }</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L1349">                 groupList.add(whitePixels);</span>
             }
<span class="nc" id="L1351">             return groupList;</span>
        }

<span class="nc" id="L1354">        double[] minMaxTheta = new double[2];</span>
<span class="nc" id="L1355">        int[] minMaxFreq = new int[2];</span>
<span class="nc" id="L1356">        double thetaFactor0 = thetaRange/(minMaxTheta0[1] - minMaxTheta0[0]);</span>
<span class="nc" id="L1357">        Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap = createThetaCIEXYMap(points0,</span>
            input, minMaxTheta0[0], thetaFactor0, minMaxTheta, minMaxFreq);

        // ---- debug ------
<span class="nc" id="L1361">        nTot = nGreyBW;</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1363">            nTot += entry.getValue().size();</span>
<span class="nc" id="L1364">        }</span>
<span class="nc" id="L1365">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>
        // ----- end debug ------

        /* ---- create frequency maps partitioned by given fractions ----
        starting w/ partitions at 3 percent (maybe discard below),
            15 percent, and 25 percent resulting in 4 maps

        For each map:
            key is pairint w/ x=theta, y=freq,
            value is all pixels having same key
        */

<span class="nc" id="L1378">        final float[] partitionFreqFracs = new float[]{0.03f, 0.15f, 0.25f};</span>

        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1381">            List&lt;PairIntWithIndex&gt;&gt;&gt; thetaFreqMaps =</span>
<span class="nc" id="L1382">            partitionIntoFrequencyMaps(input, thetaPointMap,</span>
                partitionFreqFracs, minMaxFreq[1]);

        //---- debug, assert number of pixels ----
<span class="nc" id="L1386">        nTot = nGreyBW;</span>
        for (Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        List&lt;PairIntWithIndex&gt;&gt; map : thetaFreqMaps) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                List&lt;PairIntWithIndex&gt;&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L1391">                nTot += entry.getValue().size();</span>
<span class="nc" id="L1392">            }</span>
<span class="nc" id="L1393">        }</span>
<span class="nc" id="L1394">        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot=&quot; + nTot);</span>
<span class="nc bnc" id="L1395" title="All 4 branches missed.">        assert(nTot == input.getNPixels());</span>

        // TODO: handle wrap around values!
        //    if there are points at 0 and 360, and a gap elsewhere, can
        //    shift the values so the gap is at 360 instead.

        // ------ TODO: rescale each map by frequencies to span ~1000 pixels -----
<span class="nc" id="L1402">        rescaleKeys(thetaFreqMaps, thetaFrequencyRange);</span>

<span class="nc" id="L1404">        int nTot2 = 0;</span>

<span class="nc bnc" id="L1406" title="All 2 branches missed.">        for (int i = 1; i &lt; thetaFreqMaps.size(); ++i) {</span>

            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L1409">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMapI = thetaFreqMaps.get(i);</span>

<span class="nc" id="L1411">            int[] maxXY = findMaxXY(thetaFreqMapI.keySet());</span>

<span class="nc bnc" id="L1413" title="All 4 branches missed.">            if (maxXY[0] &lt; 0 || maxXY[1] &lt;= 0) {</span>
<span class="nc" id="L1414">                continue;</span>
            }

            // ----- debug ---
            // plot the points as an image to see the data first
<span class="nc" id="L1419">            GreyscaleImage img = new GreyscaleImage(maxXY[0] + 1, maxXY[1] + 1);</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">            for (com.climbwithyourfeet.clustering.util.PairInt p : thetaFreqMapI.keySet()) {</span>
<span class="nc" id="L1421">                img.setValue(p.getX(), p.getY(), 255);</span>
<span class="nc" id="L1422">            }</span>
            try {
<span class="nc" id="L1424">                ImageIOHelper.writeOutputImage(</span>
<span class="nc" id="L1425">                    ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt2_input_&quot; + i</span>
                        + &quot;_.png&quot;, img);
<span class="nc" id="L1427">            } catch (IOException ex) {</span>
<span class="nc" id="L1428">                Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                    null, ex);
<span class="nc" id="L1430">            }</span>
            // --- end debug

            // Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            //     List&lt;PairIntWithIndex&gt;&gt; thetaFreqMapI

            // map w/ key=(theta, freq) value=collection of coords
            DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;
<span class="nc" id="L1438">                clusterFinder</span>
                = new DTClusterFinder&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;(
<span class="nc" id="L1440">                    thetaFreqMapI.keySet(), maxXY[0] + 1, maxXY[1] + 1);</span>

<span class="nc" id="L1442">            clusterFinder.setToDebug();</span>

            // to recover every point, set limit to 1
<span class="nc" id="L1445">            clusterFinder.setMinimumNumberInCluster(1);</span>

<span class="nc" id="L1447">            clusterFinder.calculateCriticalDensity();</span>

<span class="nc" id="L1449">            clusterFinder.findClusters();</span>

<span class="nc" id="L1451">            int nGroups = clusterFinder.getNumberOfClusters();</span>

<span class="nc bnc" id="L1453" title="All 2 branches missed.">            for (int k = 0; k &lt; nGroups; ++k) {</span>

<span class="nc" id="L1455">                Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; group</span>
<span class="nc" id="L1456">                    = clusterFinder.getCluster(k);</span>

<span class="nc" id="L1458">                Set&lt;PairInt&gt; coordPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1460" title="All 2 branches missed.">                for (com.climbwithyourfeet.clustering.util.PairInt pThetaFreq : group) {</span>

                    // include the other points of same ciexy theta, freq
<span class="nc" id="L1463">                    List&lt;PairIntWithIndex&gt; list = thetaFreqMapI.get(pThetaFreq);</span>
<span class="nc bnc" id="L1464" title="All 4 branches missed.">                    assert (list != null);</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">                    for (PairIntWithIndex p3 : list) {</span>
<span class="nc" id="L1466">                        int idx3 = p3.getPixIndex();</span>
<span class="nc" id="L1467">                        int xCoord3 = input.getCol(idx3);</span>
<span class="nc" id="L1468">                        int yCoord3 = input.getRow(idx3);</span>
<span class="nc" id="L1469">                        PairInt pCoord = new PairInt(xCoord3, yCoord3);</span>
<span class="nc" id="L1470">                        coordPoints.add(pCoord);</span>
<span class="nc" id="L1471">                    }</span>
<span class="nc" id="L1472">                }</span>

<span class="nc" id="L1474">                nTot2 += coordPoints.size();</span>

<span class="nc" id="L1476">                groupList.add(coordPoints);</span>
            }
        }

<span class="nc" id="L1480">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList,</span>
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
<span class="nc" id="L1484">        groupList.add(blackPixels);</span>
<span class="nc" id="L1485">        groupList.add(whitePixels);</span>

        //TODO: assert npixels

<span class="nc" id="L1489">        return groupList;</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.  The list is sorted by size and
     * set to values from 255 to 0.  If there are more than 255 clusters, the
     * remaining (smaller) clusters are pixels with value 0.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public GreyscaleImage applyUsingPolarCIEXYAndFrequency(ImageExt input,
        boolean useBlur) {

<span class="nc" id="L1517">        float fracFreqLimit = 0.03f;</span>

<span class="nc" id="L1519">        return applyUsingPolarCIEXYAndFrequency(input, fracFreqLimit, useBlur);</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.  The list is sorted by size and
     * set to values from 255 to 0.  If there are more than 255 clusters, the
     * remaining (smaller) clusters are pixels with value 0.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param fracFreqLimit
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public GreyscaleImage applyUsingPolarCIEXYAndFrequency(ImageExt input,
        final float fracFreqLimit, boolean useBlur) {

<span class="nc" id="L1548">        int w = input.getWidth();</span>
<span class="nc" id="L1549">        int h = input.getHeight();</span>

<span class="nc" id="L1551">        List&lt;Set&lt;PairInt&gt;&gt; clusters = calculateUsingPolarCIEXYAndFrequency(</span>
            input, fracFreqLimit, useBlur);

<span class="nc" id="L1554">        int n = clusters.size();</span>
        //assert(n &lt; 256);

        // sort indexes by set size
<span class="nc" id="L1558">        int maxSize = Integer.MIN_VALUE;</span>
<span class="nc" id="L1559">        int[] indexes = new int[n];</span>
<span class="nc" id="L1560">        int[] sizes = new int[n];</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L1562">            indexes[i] = i;</span>
<span class="nc" id="L1563">            sizes[i] = clusters.get(i).size();</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">            if (sizes[i] &gt; maxSize) {</span>
<span class="nc" id="L1565">                maxSize = sizes[i];</span>
            }
        }
<span class="nc" id="L1568">        CountingSort.sort(sizes, indexes, maxSize);</span>

<span class="nc" id="L1570">        int delta = 256/clusters.size();</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        if (delta == 0) {</span>
<span class="nc" id="L1572">            delta = 1;</span>
        }

<span class="nc" id="L1575">        GreyscaleImage img2 = new GreyscaleImage(w, h);</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">        for (int k = 0; k &lt; n; ++k) {</span>

<span class="nc" id="L1578">            int idx = indexes[n - k - 1];</span>

<span class="nc" id="L1580">            Set&lt;PairInt&gt; set = clusters.get(idx);</span>

<span class="nc" id="L1582">            int v = 255 - delta*k;</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            if (v &lt; 1) {</span>
<span class="nc" id="L1584">                continue;</span>
            }

<span class="nc bnc" id="L1587" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L1588">                img2.setValue(p.getX(), p.getY(), v);</span>
<span class="nc" id="L1589">            }</span>
        }

<span class="nc" id="L1592">        return img2;</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction =0.03 of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     * @param input
     * @param useBlur apply a gaussian blur of sigma=1 before the method logic
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndFrequency(ImageExt input,
        boolean useBlur) {

<span class="nc" id="L1618">        float fracFreqLimit = 0.03f;</span>

<span class="nc" id="L1620">        return calculateUsingPolarCIEXYAndFrequency(input, fracFreqLimit, useBlur);</span>
    }

    /**
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to the polar angle of CIEXY Lab color space, then creates a map of the
     * polar angles and the number of pixels with those angles (=frequency),
     * then finds peaks in theta above a fraction of max limit then groups all
     * pixels in the map by proximity to the peak,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     * The changeable parameter is the fracFreqLimit.  Larger values exclude
     * smaller frequency peaks.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * CIE xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input image to find color clusters within
     * @param fracFreqLimit fraction of the maximum above which peaks will be found
     * @param useBlur if true, performs a gaussian blur of sigma=1 before finding
     * clusters.
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; calculateUsingPolarCIEXYAndFrequency(ImageExt input,
        float fracFreqLimit, boolean useBlur) {

<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">        if (useBlur) {</span>
<span class="fc" id="L1652">            input = input.copyToImageExt();</span>
<span class="fc" id="L1653">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L1654">            imageProcessor.blur(input, 1.0f);</span>
        }

        //making a segmentation method using CIEXY polar theta
        // and the number of points with those colors.
        // choosing the peaks to be the cluster centers, then
        // gathering the pixels by proximity to the theta peaks
        // and when equidistant, chooses the largest peak.

<span class="fc" id="L1663">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1665">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="fc" id="L1667">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1669">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1671">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

<span class="fc" id="L1673">        double[] minMaxTheta0 = findMinMaxTheta(input, points0);</span>

<span class="fc" id="L1675">        log.info(&quot;for all non-white and non-black, minTheta=&quot; + minMaxTheta0[0]</span>
            + &quot; maxTheta=&quot; + minMaxTheta0[1]);

        // -------- debug -------
<span class="fc" id="L1679">        int nGrey = 0;</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L1681">            nGrey += entry.getValue().size();</span>
<span class="fc" id="L1682">        }</span>
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">        assert((points0.size() + blackPixels.size() + nGrey +</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            whitePixels.size()) == input.getNPixels());</span>
        // -------- end debug -------

<span class="fc" id="L1687">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaks(greyPixelMap);</span>

<span class="fc" id="L1689">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(greyPixelGroups.size());</span>

<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">             if (!points0.isEmpty()) {</span>
<span class="nc" id="L1693">                 groupList.add(points0);</span>
             }
<span class="nc bnc" id="L1695" title="All 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="nc" id="L1696">                 groupList.add(blackPixels);</span>
             }
<span class="nc bnc" id="L1698" title="All 2 branches missed.">             for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc" id="L1699">                groupList.add(set);</span>
<span class="nc" id="L1700">             }</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L1702">                 groupList.add(whitePixels);</span>
             }
<span class="nc" id="L1704">             return groupList;</span>
        }

        /* ----- create a map of theta and frequency ----
        need to find the peaks in frequency for frequencies larger than about
        3 percent of max frequency
        but don't want to use a spline3 to smooth, so will average every
        few pixels.
        */

<span class="fc" id="L1714">        int binWidth = 3;</span>
<span class="fc" id="L1715">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap = createThetaCIEXYMap(</span>
            points0, input, binWidth);

<span class="fc" id="L1718">        int n = (360/binWidth) + 1;</span>

<span class="fc" id="L1720">        int[] orderedThetaKeys = new int[n];</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1722">            orderedThetaKeys[i] = i;</span>
        }
<span class="fc" id="L1724">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="fc" id="L1725">        int nTot = 0;</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="fc" id="L1727">            int count = entry.getValue().size();</span>
<span class="fc bfc" id="L1728" title="All 2 branches covered.">            if (count &gt; maxFreq) {</span>
<span class="fc" id="L1729">                maxFreq = count;</span>
            }
<span class="fc" id="L1731">            nTot += entry.getValue().size();</span>
<span class="fc" id="L1732">        }</span>
<span class="fc" id="L1733">        nTot += (blackPixels.size() + nGrey + whitePixels.size());</span>
<span class="pc bpc" id="L1734" title="3 of 4 branches missed.">        assert(nTot == input.getNPixels());</span>

        /*
        TODO: this is where the DTClusterFinder would be good to use to find
        the peaks.
        */

<span class="fc" id="L1741">        PairIntArray peaks = findPeaksInThetaPointMap(orderedThetaKeys,</span>
            thetaPointMap,
<span class="fc" id="L1743">            Math.round(fracFreqLimit * maxFreq));</span>

        /*
        // ----- debug ---
        // plot the points as an image to see the data first
        int[] minMaxXY = MiscMath.findMinMaxXY(peaks);
        int nPoints = 0;
        int maxX = Integer.MIN_VALUE;
        int maxY = Integer.MIN_VALUE;
        for (int i : orderedThetaKeys) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);
            if (list == null) {
                continue;
            }
            int y = list.size();
            nPoints++;
            if (key.intValue() &gt; maxX) {
                maxX = key.intValue();
            }
            if (y &gt; maxY) {
                maxY = y;
            }
        }
        float[] xPoints = new float[nPoints];
        float[] yPoints = new float[nPoints];
        int count = 0;
        for (int i : orderedThetaKeys) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);
            if (list == null) {
                continue;
            }
            int y = list.size();
            xPoints[count] = key.intValue();
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxX, 0, maxY, xPoints, yPoints, xPoints, yPoints, &quot;cieXY theta vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        // --- end debug
        */

<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">            for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1795">                groupList.add(new HashSet&lt;PairInt&gt;(entry.getValue()));</span>
<span class="nc" id="L1796">            }</span>
<span class="nc" id="L1797">            groupList.add(blackPixels);</span>
<span class="nc" id="L1798">            groupList.add(whitePixels);</span>
<span class="nc" id="L1799">            return groupList;</span>
        }
<span class="fc bfc" id="L1801" title="All 2 branches covered.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="fc" id="L1802">            groupList.add(new HashSet&lt;PairInt&gt;());</span>
        }

        /* traverse in ordered manner thetaPointMap to compare to current theta position
           w.r.t. peaks
           then place it in the groupsList.
           points before the first peak are compared with last peak too for wrap around.
        */
<span class="fc" id="L1810">        int currentPeakIdx = -1;</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">        for (int i : orderedThetaKeys) {</span>
<span class="fc" id="L1812">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L1813">            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L1815">                continue;</span>
            }
<span class="fc" id="L1817">            int idx = -1;</span>
<span class="fc bfc" id="L1818" title="All 4 branches covered.">            if ((currentPeakIdx == -1) || (currentPeakIdx == (peaks.getN() - 1))) {</span>
                int diffL, diffF;
<span class="fc bfc" id="L1820" title="All 2 branches covered.">                if (currentPeakIdx == -1) {</span>
<span class="fc" id="L1821">                    diffL = key.intValue() + 360 - peaks.getX(peaks.getN() - 1);</span>
<span class="fc" id="L1822">                    diffF = peaks.getX(0) - key.intValue();</span>
<span class="fc bfc" id="L1823" title="All 2 branches covered.">                    if (diffF == 0) {</span>
<span class="fc" id="L1824">                        currentPeakIdx = 0;</span>
                    }
                } else {
<span class="fc" id="L1827">                    diffL = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L1828">                    diffF = peaks.getX(0) + 360 - key.intValue();</span>
                }
<span class="fc bfc" id="L1830" title="All 2 branches covered.">                if (diffL &lt; diffF) {</span>
<span class="fc" id="L1831">                    idx = peaks.getN() - 1;</span>
<span class="pc bpc" id="L1832" title="1 of 2 branches missed.">                } else if (diffL == diffF) {</span>
<span class="nc" id="L1833">                    int freqL = peaks.getY(peaks.getN() - 1);</span>
<span class="nc" id="L1834">                    int freqF = peaks.getY(0);</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">                    if (freqL &lt; freqF) {</span>
<span class="nc" id="L1836">                        idx = peaks.getN() - 1;</span>
                    } else {
<span class="nc" id="L1838">                        idx = 0;</span>
                    }
<span class="nc" id="L1840">                } else {</span>
<span class="fc" id="L1841">                    idx = 0;</span>
                }
<span class="fc" id="L1843">            } else {</span>
                // this has to update currentPeakIdx
<span class="fc" id="L1845">                int diffP = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L1846">                int diffN = peaks.getX(currentPeakIdx + 1) - key.intValue();</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">                if (diffN == 0) {</span>
<span class="fc" id="L1848">                    currentPeakIdx++;</span>
<span class="fc" id="L1849">                    idx = currentPeakIdx;</span>
                } else {
<span class="fc bfc" id="L1851" title="All 2 branches covered.">                    if (diffP &lt; diffN) {</span>
<span class="fc" id="L1852">                        idx = currentPeakIdx;</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">                    } else if (diffP == diffN) {</span>
<span class="fc" id="L1854">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="fc" id="L1855">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="pc bpc" id="L1856" title="1 of 2 branches missed.">                        if (freqP &lt; freqN) {</span>
<span class="fc" id="L1857">                            idx = currentPeakIdx;</span>
                        } else {
<span class="nc" id="L1859">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="fc" id="L1861">                    } else {</span>
<span class="fc" id="L1862">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L1866" title="3 of 4 branches missed.">            assert(idx != -1);</span>
<span class="fc" id="L1867">            groupList.get(idx).addAll(list);</span>
        }

<span class="fc" id="L1870">        mergeOrAppendGreyWithOthers(input, greyPixelGroups, groupList,</span>
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
        /*if (!blackPixels.isEmpty()) {
            groupList.add(blackPixels);
        }
        if (!whitePixels.isEmpty()) {
            groupList.add(whitePixels);
        }

        int nTot2 = 0;
        for (Set&lt;PairInt&gt; groups : groupList) {
            nTot2 += groups.size();
        }

        log.info(&quot;img nPix=&quot; + input.getNPixels() + &quot; nTot2=&quot; + nTot2);
        assert(nTot2 == input.getNPixels());
        */
<span class="fc" id="L1889">        return groupList;</span>
    }

    private Map&lt;Integer, List&lt;PairInt&gt;&gt; createThetaCIEXYMap(Set&lt;PairInt&gt;
        points0, ImageExt input, double minTheta, double thetaFactor,
        double[] outputMinMaxTheta, int[] outputMinMaxFreq) {

<span class="nc" id="L1896">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // key = theta, value = pixels having that key
<span class="nc" id="L1899">        Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap = new HashMap&lt;Integer, List&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L1901">        double minTheta0 = minTheta;</span>
<span class="nc" id="L1902">        outputMinMaxTheta[0] = Double.MIN_VALUE;</span>
<span class="nc" id="L1903">        outputMinMaxTheta[1] = Double.MAX_VALUE;</span>

<span class="nc bnc" id="L1905" title="All 2 branches missed.">        for (PairInt p : points0) {</span>

<span class="nc" id="L1907">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>

<span class="nc" id="L1909">            float cx = input.getCIEX(idx);</span>
<span class="nc" id="L1910">            float cy = input.getCIEY(idx);</span>

<span class="nc" id="L1912">            double theta = thetaFactor * (</span>
<span class="nc" id="L1913">                (cieC.calculateXYTheta(cx, cy)*180./Math.PI) - minTheta0);</span>

<span class="nc" id="L1915">            Integer thetaCIEXY = Integer.valueOf((int)Math.round(theta));</span>

<span class="nc" id="L1917">            List&lt;PairInt&gt; list = thetaPointMap.get(thetaCIEXY);</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L1919">                list = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L1920">                thetaPointMap.put(thetaCIEXY, list);</span>
            }
<span class="nc" id="L1922">            list.add(p);</span>

<span class="nc bnc" id="L1924" title="All 2 branches missed.">            if (theta &lt; outputMinMaxTheta[0]) {</span>
<span class="nc" id="L1925">                outputMinMaxTheta[0] = theta;</span>
            }
<span class="nc bnc" id="L1927" title="All 2 branches missed.">            if (theta &gt; outputMinMaxTheta[1]) {</span>
<span class="nc" id="L1928">                outputMinMaxTheta[1] = theta;</span>
            }
<span class="nc" id="L1930">        }</span>

<span class="nc" id="L1932">        outputMinMaxFreq[0] = Integer.MAX_VALUE;</span>
<span class="nc" id="L1933">        outputMinMaxFreq[1] = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1934" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>
<span class="nc" id="L1935">            int count = entry.getValue().size();</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">            if (count &lt; outputMinMaxFreq[0]) {</span>
<span class="nc" id="L1937">                outputMinMaxFreq[0] = count;</span>
            }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">            if (count &gt; outputMinMaxFreq[1]) {</span>
<span class="nc" id="L1940">                outputMinMaxFreq[1] = count;</span>
            }
<span class="nc" id="L1942">        }</span>

<span class="nc" id="L1944">        return thetaPointMap;</span>
    }

    private List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
    List&lt;PairIntWithIndex&gt;&gt;&gt; partitionIntoFrequencyMaps(
    ImageExt input, Map&lt;Integer, List&lt;PairInt&gt;&gt; thetaPointMap,
    float[] partitionFreqFracs, int maxFreq) {

        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            List&lt;PairIntWithIndex&gt;&gt;&gt;
<span class="nc" id="L1954">            mapsList =</span>
                new ArrayList&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
                List&lt;PairIntWithIndex&gt;&gt;&gt;();

<span class="nc" id="L1958">        int nMaps = partitionFreqFracs.length + 1;</span>

<span class="nc bnc" id="L1960" title="All 2 branches missed.">        for (int i = 0; i &lt; nMaps; ++i) {</span>
<span class="nc" id="L1961">            mapsList.add(</span>
                new HashMap&lt;com.climbwithyourfeet.clustering.util.PairInt,
                List&lt;PairIntWithIndex&gt;&gt;());
        }

<span class="nc" id="L1966">        final int[] partitionFreqs = new int[partitionFreqFracs.length];</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">        for (int i = 0; i &lt; partitionFreqs.length; ++i) {</span>
<span class="nc" id="L1968">            partitionFreqs[i] = Math.round(partitionFreqFracs[i]*maxFreq);</span>
        }

<span class="nc" id="L1971">        int[] maxXY = new int[2];</span>
<span class="nc" id="L1972">        Arrays.fill(maxXY, Integer.MIN_VALUE);</span>

<span class="nc bnc" id="L1974" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;PairInt&gt;&gt; entry : thetaPointMap.entrySet()) {</span>

<span class="nc" id="L1976">            Integer theta = entry.getKey();</span>

<span class="nc" id="L1978">            int count = entry.getValue().size();</span>

<span class="nc" id="L1980">            List&lt;PairIntWithIndex&gt; list = new ArrayList&lt;PairIntWithIndex&gt;();</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">            for (PairInt p : entry.getValue()) {</span>
<span class="nc" id="L1982">                int pixIdx = input.getInternalIndex(p.getX(), p.getY());</span>
<span class="nc" id="L1983">                PairIntWithIndex p2 = new PairIntWithIndex(theta.intValue(),</span>
                    count, pixIdx);
<span class="nc" id="L1985">                list.add(p2);</span>
<span class="nc" id="L1986">            }</span>

<span class="nc" id="L1988">            int n = partitionFreqs.length;</span>
<span class="nc" id="L1989">            int idx = 0;</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L1991" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc bnc" id="L1992" title="All 2 branches missed.">                    if (count &lt; partitionFreqs[0]) {</span>
<span class="nc" id="L1993">                        idx = 0;</span>
<span class="nc" id="L1994">                        break;</span>
                    }
<span class="nc bnc" id="L1996" title="All 4 branches missed.">                } else if ((i == (n - 1)) &amp;&amp; count &gt;= partitionFreqs[i]) {</span>
<span class="nc" id="L1997">                    idx = n;// one past partitions is last list bin</span>
<span class="nc" id="L1998">                    break;</span>
                } else {
<span class="nc bnc" id="L2000" title="All 4 branches missed.">                    if ((count &gt;= partitionFreqs[i - 1]) &amp;&amp; (count &lt; partitionFreqs[i])) {</span>
<span class="nc" id="L2001">                        idx = i;</span>
<span class="nc" id="L2002">                        break;</span>
                    }
                }
            }

            // this is unique to all maps, not stomping on existing key
<span class="nc" id="L2008">            mapsList.get(idx).put(</span>
                new com.climbwithyourfeet.clustering.util.PairInt(
<span class="nc" id="L2010">                    theta.intValue(), count), list);</span>

<span class="nc bnc" id="L2012" title="All 2 branches missed.">            if (theta.intValue() &gt; maxXY[0]) {</span>
<span class="nc" id="L2013">                maxXY[0] = theta.intValue();</span>
            }
<span class="nc bnc" id="L2015" title="All 2 branches missed.">            if (count &gt; maxXY[1]) {</span>
<span class="nc" id="L2016">                maxXY[1] = count;</span>
            }
<span class="nc" id="L2018">        }</span>

        // ----- temporary print of all pixels -------
        // ----- debug ---
<span class="nc" id="L2022">        GreyscaleImage img = new GreyscaleImage(maxXY[0] + 1, maxXY[1] + 1);</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">        for (int i = 0; i &lt; mapsList.size(); ++i) {</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">            for (com.climbwithyourfeet.clustering.util.PairInt p : mapsList.get(i).keySet()) {</span>
<span class="nc" id="L2025">                img.setValue(p.getX(), p.getY(), 255);</span>
<span class="nc" id="L2026">            }</span>
        }
        try {
<span class="nc" id="L2029">            ImageIOHelper.writeOutputImage(</span>
<span class="nc" id="L2030">                ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/dt2_input.png&quot;, img);</span>
<span class="nc" id="L2031">        } catch (IOException ex) {</span>
<span class="nc" id="L2032">            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,</span>
                null, ex);
<span class="nc" id="L2034">        }</span>
        // --- end debug

<span class="nc" id="L2037">        return mapsList;</span>
    }

    private void rescaleKeys(
        List&lt;Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
            List&lt;PairIntWithIndex&gt;&gt;&gt; thetaFreqMaps, int scaleTo) {

        // --- can remove the count after debugging ----
<span class="nc" id="L2045">        int nTotBefore = 0;</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L2048" title="All 2 branches missed.">                List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMaps.get(i).entrySet()) {</span>
<span class="nc" id="L2049">                nTotBefore += entry.getValue().size();</span>
<span class="nc" id="L2050">            }</span>
        }

<span class="nc bnc" id="L2053" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>

            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L2056">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap = thetaFreqMaps.get(i);</span>

<span class="nc" id="L2058">            int[] minMax = findMinMaxOfKeyYs(thetaFreqMap.keySet());</span>

            Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L2061">                List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap2 = rescaleKeyYs(</span>
                    thetaFreqMap, scaleTo, minMax);

<span class="nc" id="L2064">            thetaFreqMaps.set(i, thetaFreqMap2);</span>
        }

        // --- can remove the count after debugging ----
<span class="nc" id="L2068">        int nTotAfter = 0;</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaFreqMaps.size(); ++i) {</span>
            for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L2071" title="All 2 branches missed.">                List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMaps.get(i).entrySet()) {</span>
<span class="nc" id="L2072">                nTotAfter += entry.getValue().size();</span>
<span class="nc" id="L2073">            }</span>
        }
<span class="nc bnc" id="L2075" title="All 4 branches missed.">        assert(nTotBefore == nTotAfter);</span>
<span class="nc" id="L2076">    }</span>

    private int[] findMinMaxOfKeyYs(
        Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt; keySet) {

<span class="nc" id="L2081">        int min = Integer.MAX_VALUE;</span>
<span class="nc" id="L2082">        int max = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L2084" title="All 2 branches missed.">        for (com.climbwithyourfeet.clustering.util.PairInt p : keySet) {</span>
<span class="nc" id="L2085">            int y = p.getY();</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">            if (y &lt; min) {</span>
<span class="nc" id="L2087">                min = y;</span>
            }
<span class="nc bnc" id="L2089" title="All 2 branches missed.">            if (y &gt; max) {</span>
<span class="nc" id="L2090">                max = y;</span>
            }
<span class="nc" id="L2092">        }</span>
<span class="nc" id="L2093">        return new int[]{min, max};</span>
    }

    private Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
    List&lt;PairIntWithIndex&gt;&gt; rescaleKeyYs(
    Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
    List&lt;PairIntWithIndex&gt;&gt; thetaFreqMap, final int scaleTo, final int[] minMaxY) {

        Map&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc" id="L2102">            List&lt;PairIntWithIndex&gt;&gt; scaledMap</span>
            = new HashMap&lt;com.climbwithyourfeet.clustering.util.PairInt,
                List&lt;PairIntWithIndex&gt;&gt;();

<span class="nc bnc" id="L2106" title="All 2 branches missed.">        if ((minMaxY[1] - minMaxY[0]) == 0) {</span>
<span class="nc" id="L2107">            return thetaFreqMap;</span>
        }

<span class="nc" id="L2110">        float factor = scaleTo/(minMaxY[1] - minMaxY[0]);</span>

        for (Map.Entry&lt;com.climbwithyourfeet.clustering.util.PairInt,
<span class="nc bnc" id="L2113" title="All 2 branches missed.">            List&lt;PairIntWithIndex&gt;&gt; entry : thetaFreqMap.entrySet()) {</span>

<span class="nc" id="L2115">            com.climbwithyourfeet.clustering.util.PairInt p = entry.getKey();</span>

<span class="nc" id="L2117">            int y = Math.round(factor * (p.getY() - minMaxY[0]));</span>

<span class="nc" id="L2119">            com.climbwithyourfeet.clustering.util.PairInt p2 = new</span>
<span class="nc" id="L2120">                com.climbwithyourfeet.clustering.util.PairInt(p.getX(), y);</span>

<span class="nc" id="L2122">            scaledMap.put(p2, entry.getValue());</span>
<span class="nc" id="L2123">        }</span>

<span class="nc" id="L2125">        return scaledMap;</span>
    }

    private int[] findMaxXY(Set&lt;com.climbwithyourfeet.clustering.util.PairInt&gt;
        keySet) {

<span class="nc" id="L2131">        int maxX = Integer.MIN_VALUE;</span>
<span class="nc" id="L2132">        int maxY = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L2134" title="All 2 branches missed.">        for (com.climbwithyourfeet.clustering.util.PairInt p : keySet) {</span>
<span class="nc" id="L2135">            int x = p.getX();</span>
<span class="nc" id="L2136">            int y = p.getY();</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">            if (x &gt; maxX) {</span>
<span class="nc" id="L2138">                maxX = x;</span>
            }
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            if (y &gt; maxY) {</span>
<span class="nc" id="L2141">                maxY = y;</span>
            }
<span class="nc" id="L2143">        }</span>
<span class="nc" id="L2144">        return new int[]{maxX, maxY};</span>
    }

    private Map&lt;Integer, Collection&lt;PairInt&gt;&gt; createThetaCIEXYMap(Set&lt;PairInt&gt;
        points, ImageExt input, int binWidth) {

<span class="fc" id="L2150">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // key = theta, value = pixels having that key
<span class="fc" id="L2153">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="fc bfc" id="L2155" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L2157">            int idx = input.getInternalIndex(p.getX(), p.getY());</span>

<span class="fc" id="L2159">            float cx = input.getCIEX(idx);</span>
<span class="fc" id="L2160">            float cy = input.getCIEY(idx);</span>

<span class="fc" id="L2162">            double thetaRadians = cieC.calculateXYTheta(cx, cy);</span>
<span class="fc" id="L2163">            double theta = thetaRadians * 180./Math.PI;</span>

<span class="fc" id="L2165">            int thetaCIEXY = (int)Math.round(theta);</span>

<span class="fc" id="L2167">            Integer binKey = Integer.valueOf(thetaCIEXY/binWidth);</span>

<span class="fc" id="L2169">            Collection&lt;PairInt&gt; list = thetaPointMap.get(binKey);</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L2171">                list = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L2172">                thetaPointMap.put(binKey, list);</span>
            }
<span class="fc" id="L2174">            list.add(p);</span>
<span class="fc" id="L2175">        }</span>

<span class="fc" id="L2177">        return thetaPointMap;</span>
    }

    private TIntObjectMap&lt;TIntSet&gt; createThetaCIEXYMap(
        TIntList indexes, TIntList thetaValues, int binWidth) {

<span class="nc bnc" id="L2183" title="All 4 branches missed.">        assert(indexes.size() == thetaValues.size());</span>

        // key = theta, value = pixels having that key
<span class="nc" id="L2186">        TIntObjectMap&lt;TIntSet&gt; thetaPointMap =</span>
            new TIntObjectHashMap&lt;TIntSet&gt;();

<span class="nc bnc" id="L2189" title="All 2 branches missed.">        for (int i = 0; i &lt; indexes.size(); ++i) {</span>
<span class="nc" id="L2190">            int lIdx = indexes.get(i);</span>
<span class="nc" id="L2191">            int thetaDeg = thetaValues.get(i);</span>

<span class="nc" id="L2193">            int binKey = thetaDeg/binWidth;</span>

<span class="nc" id="L2195">            TIntSet set = thetaPointMap.get(binKey);</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            if (set == null) {</span>
<span class="nc" id="L2197">                set = new TIntHashSet();</span>
<span class="nc" id="L2198">                thetaPointMap.put(binKey, set);</span>
            }
<span class="nc" id="L2200">            set.add(lIdx);</span>
        }

<span class="nc" id="L2203">        return thetaPointMap;</span>
    }

    /**
     * find peaks in the theta point map above lower limit.
     * @param orderedThetaKeys
     * @param thetaPointMap
     * @param limit
     * @return
     */
    protected PairIntArray findPeaksInThetaPointMap(final int[] orderedThetaKeys,
        final Map&lt;Integer, Collection&lt;PairInt&gt;&gt; thetaPointMap, final int limit) {

<span class="fc" id="L2216">        int lastKey = -1;</span>
<span class="fc" id="L2217">        int lastValue = -1;</span>
<span class="fc" id="L2218">        boolean isIncr = false;</span>
<span class="fc" id="L2219">        PairIntArray peaks = new PairIntArray();</span>
<span class="fc" id="L2220">        int nInMap = 0;</span>
<span class="fc bfc" id="L2221" title="All 2 branches covered.">        for (int i : orderedThetaKeys) {</span>
<span class="fc" id="L2222">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L2223">            Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">            if (list == null) {</span>
<span class="nc bnc" id="L2225" title="All 6 branches missed.">                if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
<span class="nc" id="L2226">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="nc" id="L2228">                lastKey = key.intValue();</span>
<span class="nc" id="L2229">                lastValue = 0;</span>
<span class="nc" id="L2230">                isIncr = false;</span>
<span class="nc" id="L2231">                continue;</span>
            }
<span class="fc" id="L2233">            int count = list.size();</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">            if (nInMap == 1) {</span>
<span class="pc bpc" id="L2235" title="1 of 2 branches missed.">                if (count &gt; lastValue) {</span>
<span class="fc" id="L2236">                    isIncr = true;</span>
                } else {
<span class="nc bnc" id="L2238" title="All 2 branches missed.">                    if (lastValue &gt; limit) {</span>
<span class="nc" id="L2239">                        peaks.add(lastKey, lastValue);</span>
                    }
<span class="nc" id="L2241">                    isIncr = false;</span>
                }
<span class="fc bfc" id="L2243" title="All 2 branches covered.">            } else if (nInMap != 0) {</span>
<span class="fc bfc" id="L2244" title="All 2 branches covered.">                if (isIncr) {</span>
<span class="fc bfc" id="L2245" title="All 2 branches covered.">                    if (count &lt; lastValue) {</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">                        if (lastValue &gt; limit) {</span>
<span class="fc" id="L2247">                            peaks.add(lastKey, lastValue);</span>
                        }
<span class="fc" id="L2249">                        isIncr = false;</span>
                    }
                } else {
<span class="fc bfc" id="L2252" title="All 2 branches covered.">                    if (count &gt; lastValue) {</span>
<span class="fc" id="L2253">                        isIncr = true;</span>
                    }
                }
            }
<span class="fc" id="L2257">            lastValue = count;</span>
<span class="fc" id="L2258">            lastKey = key.intValue();</span>
<span class="fc" id="L2259">            nInMap++;</span>
        }
<span class="pc bpc" id="L2261" title="4 of 6 branches missed.">        if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
            //checking value at theta=0 to make sure this is a peak
<span class="nc" id="L2263">            Integer key = orderedThetaKeys[0];</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">            if (key.intValue() == 0) {</span>
<span class="nc" id="L2265">                Collection&lt;PairInt&gt; list = thetaPointMap.get(key);</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">                if (list == null) {</span>
<span class="nc" id="L2267">                    peaks.add(lastKey, lastValue);</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">                } else if (list.size() &lt; lastValue) {</span>
<span class="nc" id="L2269">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="nc" id="L2271">            } else {</span>
<span class="nc" id="L2272">                peaks.add(lastKey, lastValue);</span>
            }
        }

<span class="fc" id="L2276">        return peaks;</span>
    }

    /**
     * find peaks in the theta point map above lower limit.
     * @param orderedThetaKeys
     * @param thetaPointMap
     * @param limit
     * @return
     */
    protected PairIntArray findPeaksInThetaPointMap(final int[] orderedThetaKeys,
        final TIntObjectMap&lt;TIntSet&gt; thetaPointMap, final int limit) {

<span class="nc" id="L2289">        int lastKey = -1;</span>
<span class="nc" id="L2290">        int lastValue = -1;</span>
<span class="nc" id="L2291">        boolean isIncr = false;</span>
<span class="nc" id="L2292">        PairIntArray peaks = new PairIntArray();</span>
<span class="nc" id="L2293">        int nInMap = 0;</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">        for (int i : orderedThetaKeys) {</span>
<span class="nc" id="L2295">            TIntSet set = thetaPointMap.get(i);</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">            if (set == null) {</span>
<span class="nc bnc" id="L2297" title="All 6 branches missed.">                if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
<span class="nc" id="L2298">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="nc" id="L2300">                lastKey = i;</span>
<span class="nc" id="L2301">                lastValue = 0;</span>
<span class="nc" id="L2302">                isIncr = false;</span>
<span class="nc" id="L2303">                continue;</span>
            }
<span class="nc" id="L2305">            int count = set.size();</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            if (nInMap == 1) {</span>
<span class="nc bnc" id="L2307" title="All 2 branches missed.">                if (count &gt; lastValue) {</span>
<span class="nc" id="L2308">                    isIncr = true;</span>
                } else {
<span class="nc bnc" id="L2310" title="All 2 branches missed.">                    if (lastValue &gt; limit) {</span>
<span class="nc" id="L2311">                        peaks.add(lastKey, lastValue);</span>
                    }
<span class="nc" id="L2313">                    isIncr = false;</span>
                }
<span class="nc bnc" id="L2315" title="All 2 branches missed.">            } else if (nInMap != 0) {</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">                if (isIncr) {</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">                    if (count &lt; lastValue) {</span>
<span class="nc bnc" id="L2318" title="All 2 branches missed.">                        if (lastValue &gt; limit) {</span>
<span class="nc" id="L2319">                            peaks.add(lastKey, lastValue);</span>
                        }
<span class="nc" id="L2321">                        isIncr = false;</span>
                    }
                } else {
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                    if (count &gt; lastValue) {</span>
<span class="nc" id="L2325">                        isIncr = true;</span>
                    }
                }
            }
<span class="nc" id="L2329">            lastValue = count;</span>
<span class="nc" id="L2330">            lastKey = i;</span>
<span class="nc" id="L2331">            nInMap++;</span>
        }
<span class="nc bnc" id="L2333" title="All 6 branches missed.">        if ((nInMap &gt; 0) &amp;&amp; isIncr &amp;&amp; (lastValue &gt; limit)) {</span>
            //checking value at theta=0 to make sure this is a peak
<span class="nc" id="L2335">            int key = orderedThetaKeys[0];</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">            if (key == 0) {</span>
<span class="nc" id="L2337">                TIntSet set = thetaPointMap.get(key);</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">                if (set == null) {</span>
<span class="nc" id="L2339">                    peaks.add(lastKey, lastValue);</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">                } else if (set.size() &lt; lastValue) {</span>
<span class="nc" id="L2341">                    peaks.add(lastKey, lastValue);</span>
                }
<span class="nc" id="L2343">            } else {</span>
<span class="nc" id="L2344">                peaks.add(lastKey, lastValue);</span>
            }
        }

<span class="nc" id="L2348">        return peaks;</span>
    }

    private List&lt;TIntSet&gt; groupByPeaks(TIntObjectMap&lt;TIntSet&gt;
        greyIndexMap) {

<span class="nc" id="L2354">        int nTot = 0;</span>
<span class="nc" id="L2355">        int minKey = Integer.MAX_VALUE;</span>
<span class="nc" id="L2356">        int maxKey = Integer.MIN_VALUE;</span>

<span class="nc" id="L2358">        TIntObjectIterator&lt;TIntSet&gt; iter = greyIndexMap.iterator();</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">        for (int i = 0; i &lt; greyIndexMap.size(); ++i) {</span>
<span class="nc" id="L2360">            iter.advance();</span>
<span class="nc" id="L2361">            int avgRGB = iter.key();</span>
<span class="nc" id="L2362">            TIntSet listIndexes = iter.value();</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">            if (avgRGB &lt; minKey) {</span>
<span class="nc" id="L2364">                minKey = avgRGB;</span>
            }
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            if (avgRGB &gt; maxKey) {</span>
<span class="nc" id="L2367">                maxKey = avgRGB;</span>
            }
<span class="nc" id="L2369">            nTot += listIndexes.size();</span>
        }

<span class="nc" id="L2372">        int binWidth = 8;</span>
<span class="nc" id="L2373">        greyIndexMap = binByKeys(greyIndexMap, minKey, maxKey, binWidth);</span>

<span class="nc" id="L2375">        int nTot2 = 0;</span>
<span class="nc" id="L2376">        minKey = Integer.MAX_VALUE;</span>
<span class="nc" id="L2377">        maxKey = Integer.MIN_VALUE;</span>
<span class="nc" id="L2378">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="nc" id="L2379">        iter = greyIndexMap.iterator();</span>
<span class="nc bnc" id="L2380" title="All 2 branches missed.">        for (int i = 0; i &lt; greyIndexMap.size(); ++i) {</span>
<span class="nc" id="L2381">            iter.advance();</span>
<span class="nc" id="L2382">            int avgRGB = iter.key();</span>
<span class="nc" id="L2383">            TIntSet listIndexes = iter.value();</span>
<span class="nc bnc" id="L2384" title="All 2 branches missed.">            if (avgRGB &lt; minKey) {</span>
<span class="nc" id="L2385">                minKey = avgRGB;</span>
            }
<span class="nc bnc" id="L2387" title="All 2 branches missed.">            if (avgRGB &gt; maxKey) {</span>
<span class="nc" id="L2388">                maxKey = avgRGB;</span>
            }
<span class="nc" id="L2390">            int y = listIndexes.size();</span>
<span class="nc bnc" id="L2391" title="All 2 branches missed.">            if (y &gt; maxFreq) {</span>
<span class="nc" id="L2392">                maxFreq = y;</span>
            }
<span class="nc" id="L2394">            nTot2 += y;</span>
        }
<span class="nc bnc" id="L2396" title="All 4 branches missed.">        assert(nTot == nTot2);</span>

<span class="nc" id="L2398">        int count = 0;</span>

        /*
        // --- debug
        float[] xPoints = new float[greyPixelMap.size()];
        float[] yPoints = new float[greyPixelMap.size()];
        for (int i = minKey; i &lt;= maxKey; ++i) {
            TIntSet set = greyIndexMap.get(i);
            if (set == null) {
                continue;
            }
            int y = set.size();
            xPoints[count] = i;
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxKey, 0, maxFreq, xPoints, yPoints, xPoints, yPoints, &quot;grey avgRGB vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_grey_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        // --- end debug
        */

<span class="nc" id="L2426">        final int[] orderedKeys = new int[maxKey - minKey + 1];</span>
<span class="nc" id="L2427">        count = 0;</span>
<span class="nc bnc" id="L2428" title="All 2 branches missed.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>
<span class="nc" id="L2429">            orderedKeys[count] = i;</span>
<span class="nc" id="L2430">            count++;</span>
        }
<span class="nc" id="L2432">        int limit = (int)(0.03 * maxFreq);</span>
<span class="nc" id="L2433">        PairIntArray peaks = findPeaksInThetaPointMap(orderedKeys,</span>
            greyIndexMap, limit);

        // if there are several peaks within small range of keys, that's noise,
        // so removing them
<span class="nc" id="L2438">        filterPeaksIfNoisey(peaks);</span>

        // ---- gather points in greyPixelMap into groups around the peaks ----
<span class="nc" id="L2441">        List&lt;TIntSet&gt; groupList = new ArrayList&lt;TIntSet&gt;(orderedKeys.length + 1);</span>
<span class="nc bnc" id="L2442" title="All 2 branches missed.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="nc" id="L2443">            groupList.add(new TIntHashSet());</span>
        }

<span class="nc bnc" id="L2446" title="All 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc" id="L2447">            return groupList;</span>
<span class="nc bnc" id="L2448" title="All 2 branches missed.">        } else if (peaks.getN() == 1) {</span>
<span class="nc" id="L2449">            iter = greyIndexMap.iterator();</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">            for (int i = 0; i &lt; greyIndexMap.size(); ++i) {</span>
<span class="nc" id="L2451">                iter.advance();</span>
<span class="nc" id="L2452">                int avgRGB = iter.key();</span>
<span class="nc" id="L2453">                TIntSet listIndexes = iter.value();</span>
<span class="nc" id="L2454">                groupList.get(0).addAll(listIndexes);</span>
            }
<span class="nc" id="L2456">            return groupList;</span>
        }

<span class="nc" id="L2459">        int currentPeakIdx = -1;</span>
<span class="nc bnc" id="L2460" title="All 2 branches missed.">        for (int i : orderedKeys) {</span>
<span class="nc" id="L2461">            TIntSet set = greyIndexMap.get(i);</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">            if (set == null) {</span>
<span class="nc" id="L2463">                continue;</span>
            }
<span class="nc" id="L2465">            int idx = -1;</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">            if (currentPeakIdx == -1) {</span>
<span class="nc" id="L2467">                currentPeakIdx = 0;</span>
<span class="nc" id="L2468">                idx = 0;</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            } else if (currentPeakIdx == (peaks.getN() - 1)) {</span>
<span class="nc" id="L2470">                idx = currentPeakIdx;</span>
            } else {
                // this has to update currentPeakIdx
<span class="nc" id="L2473">                int diffP = i - peaks.getX(currentPeakIdx);</span>
<span class="nc" id="L2474">                int diffN = peaks.getX(currentPeakIdx + 1) - i;</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                if (diffN == 0) {</span>
<span class="nc" id="L2476">                    currentPeakIdx++;</span>
<span class="nc" id="L2477">                    idx = currentPeakIdx;</span>
                } else {
<span class="nc bnc" id="L2479" title="All 2 branches missed.">                    if (diffP &lt; diffN) {</span>
<span class="nc" id="L2480">                        idx = currentPeakIdx;</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">                    } else if (diffP == diffN) {</span>
<span class="nc" id="L2482">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="nc" id="L2483">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="nc bnc" id="L2484" title="All 2 branches missed.">                        if (freqP &lt; freqN) {</span>
<span class="nc" id="L2485">                            idx = currentPeakIdx;</span>
                        } else {
<span class="nc" id="L2487">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="nc" id="L2489">                    } else {</span>
<span class="nc" id="L2490">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="nc bnc" id="L2494" title="All 4 branches missed.">            assert(idx != -1);</span>
<span class="nc" id="L2495">            groupList.get(idx).addAll(set);</span>
        }

<span class="nc" id="L2498">        return groupList;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; groupByPeaks(
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {

<span class="fc" id="L2504">        int nTot = 0;</span>
<span class="fc" id="L2505">        int minKey = Integer.MAX_VALUE;</span>
<span class="fc" id="L2506">        int maxKey = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L2507" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L2508">            int key = entry.getKey().intValue();</span>
<span class="fc bfc" id="L2509" title="All 2 branches covered.">            if (key &lt; minKey) {</span>
<span class="fc" id="L2510">                minKey = key;</span>
            }
<span class="pc bpc" id="L2512" title="1 of 2 branches missed.">            if (key &gt; maxKey) {</span>
<span class="fc" id="L2513">                maxKey = key;</span>
            }
<span class="fc" id="L2515">            nTot += entry.getValue().size();</span>
<span class="fc" id="L2516">        }</span>

<span class="fc" id="L2518">        int binWidth = 8;</span>
<span class="fc" id="L2519">        greyPixelMap = binByKeys(greyPixelMap, minKey, maxKey, binWidth);</span>

<span class="fc" id="L2521">        int nTot2 = 0;</span>
<span class="fc" id="L2522">        minKey = Integer.MAX_VALUE;</span>
<span class="fc" id="L2523">        maxKey = Integer.MIN_VALUE;</span>
<span class="fc" id="L2524">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L2525" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="fc" id="L2526">            int key = entry.getKey().intValue();</span>
<span class="fc bfc" id="L2527" title="All 2 branches covered.">            if (key &lt; minKey) {</span>
<span class="fc" id="L2528">                minKey = key;</span>
            }
<span class="pc bpc" id="L2530" title="1 of 2 branches missed.">            if (key &gt; maxKey) {</span>
<span class="fc" id="L2531">                maxKey = key;</span>
            }
<span class="fc" id="L2533">            int y = entry.getValue().size();</span>
<span class="fc bfc" id="L2534" title="All 2 branches covered.">            if (y &gt; maxFreq) {</span>
<span class="fc" id="L2535">                maxFreq = y;</span>
            }

<span class="fc" id="L2538">            nTot2 += y;</span>
<span class="fc" id="L2539">        }</span>
<span class="pc bpc" id="L2540" title="3 of 4 branches missed.">        assert(nTot == nTot2);</span>

<span class="fc" id="L2542">        int count = 0;</span>

        /*
        // --- debug
        float[] xPoints = new float[greyPixelMap.size()];
        float[] yPoints = new float[greyPixelMap.size()];
        for (int i = minKey; i &lt;= maxKey; ++i) {
            Integer key = Integer.valueOf(i);
            Collection&lt;PairInt&gt; set = greyPixelMap.get(key);
            if (set == null) {
                continue;
            }
            int y = set.size();
            xPoints[count] = key.intValue();
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxKey, 0, maxFreq, xPoints, yPoints, xPoints, yPoints, &quot;grey avgRGB vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_grey_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        // --- end debug
        */

<span class="fc" id="L2571">        final int[] orderedKeys = new int[maxKey - minKey + 1];</span>
<span class="fc" id="L2572">        count = 0;</span>
<span class="fc bfc" id="L2573" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>
<span class="fc" id="L2574">            orderedKeys[count] = i;</span>
<span class="fc" id="L2575">            count++;</span>
        }
<span class="fc" id="L2577">        int limit = (int)(0.03 * maxFreq);</span>
<span class="fc" id="L2578">        PairIntArray peaks = findPeaksInThetaPointMap(orderedKeys, greyPixelMap, limit);</span>

        // if there are several peaks within small range of keys, that's noise,
        // so removing them
<span class="fc" id="L2582">        filterPeaksIfNoisey(peaks);</span>

        // ---- gather points in greyPixelMap into groups around the peaks ----
<span class="fc" id="L2585">        List&lt;Set&lt;PairInt&gt;&gt; groupList = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(orderedKeys.length + 1);</span>
<span class="fc bfc" id="L2586" title="All 2 branches covered.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="fc" id="L2587">            groupList.add(new HashSet&lt;PairInt&gt;());</span>
        }

<span class="pc bpc" id="L2590" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc" id="L2591">            return groupList;</span>
<span class="pc bpc" id="L2592" title="1 of 2 branches missed.">        } else if (peaks.getN() == 1) {</span>
<span class="nc bnc" id="L2593" title="All 2 branches missed.">            for (Map.Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L2594">                Collection&lt;PairInt&gt; set = entry.getValue();</span>
<span class="nc" id="L2595">                groupList.get(0).addAll(set);</span>
<span class="nc" id="L2596">            }</span>
<span class="nc" id="L2597">            return groupList;</span>
        }

<span class="fc" id="L2600">        int currentPeakIdx = -1;</span>
<span class="fc bfc" id="L2601" title="All 2 branches covered.">        for (int i : orderedKeys) {</span>
<span class="fc" id="L2602">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L2603">            Collection&lt;PairInt&gt; set = greyPixelMap.get(key);</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">            if (set == null) {</span>
<span class="nc" id="L2605">                continue;</span>
            }
<span class="fc" id="L2607">            int idx = -1;</span>
<span class="fc bfc" id="L2608" title="All 2 branches covered.">            if (currentPeakIdx == -1) {</span>
<span class="fc" id="L2609">                currentPeakIdx = 0;</span>
<span class="fc" id="L2610">                idx = 0;</span>
<span class="fc bfc" id="L2611" title="All 2 branches covered.">            } else if (currentPeakIdx == (peaks.getN() - 1)) {</span>
<span class="fc" id="L2612">                idx = currentPeakIdx;</span>
            } else {
                // this has to update currentPeakIdx
<span class="fc" id="L2615">                int diffP = key.intValue() - peaks.getX(currentPeakIdx);</span>
<span class="fc" id="L2616">                int diffN = peaks.getX(currentPeakIdx + 1) - key.intValue();</span>
<span class="fc bfc" id="L2617" title="All 2 branches covered.">                if (diffN == 0) {</span>
<span class="fc" id="L2618">                    currentPeakIdx++;</span>
<span class="fc" id="L2619">                    idx = currentPeakIdx;</span>
                } else {
<span class="fc bfc" id="L2621" title="All 2 branches covered.">                    if (diffP &lt; diffN) {</span>
<span class="fc" id="L2622">                        idx = currentPeakIdx;</span>
<span class="fc bfc" id="L2623" title="All 2 branches covered.">                    } else if (diffP == diffN) {</span>
<span class="fc" id="L2624">                        int freqP = peaks.getY(currentPeakIdx);</span>
<span class="fc" id="L2625">                        int freqN = peaks.getY(currentPeakIdx + 1);</span>
<span class="fc bfc" id="L2626" title="All 2 branches covered.">                        if (freqP &lt; freqN) {</span>
<span class="fc" id="L2627">                            idx = currentPeakIdx;</span>
                        } else {
<span class="fc" id="L2629">                            idx = currentPeakIdx + 1;</span>
                        }
<span class="fc" id="L2631">                    } else {</span>
<span class="fc" id="L2632">                        idx = currentPeakIdx + 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L2636" title="3 of 4 branches missed.">            assert(idx != -1);</span>
<span class="fc" id="L2637">            groupList.get(idx).addAll(set);</span>
        }

        // ----- debug ----
<span class="fc" id="L2641">        int nTot3 = 0;</span>
<span class="fc bfc" id="L2642" title="All 2 branches covered.">        for (Collection&lt;PairInt&gt; set : groupList) {</span>
<span class="fc" id="L2643">            nTot3 += set.size();</span>
<span class="fc" id="L2644">        }</span>
<span class="pc bpc" id="L2645" title="3 of 4 branches missed.">        assert(nTot == nTot3);</span>
        // ----- end debug -----

<span class="fc" id="L2648">        return groupList;</span>
    }

    private Map&lt;Integer, Collection&lt;PairInt&gt;&gt; binByKeys(
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap,
        int minKey, int maxKey, int binWidth) {

<span class="fc" id="L2655">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; map2</span>
            = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();

<span class="fc bfc" id="L2658" title="All 2 branches covered.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>

<span class="fc" id="L2660">            Integer key = Integer.valueOf(i);</span>

<span class="fc" id="L2662">            Collection&lt;PairInt&gt; c = greyPixelMap.get(key);</span>

<span class="pc bpc" id="L2664" title="1 of 2 branches missed.">            if (c == null) {</span>
<span class="nc" id="L2665">                continue;</span>
            }

<span class="fc" id="L2668">            Integer binKey = Integer.valueOf(i/binWidth);</span>

<span class="fc" id="L2670">            Collection&lt;PairInt&gt; c2 = map2.get(binKey);</span>
<span class="fc bfc" id="L2671" title="All 2 branches covered.">            if (c2 == null) {</span>
<span class="fc" id="L2672">                c2 = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2673">                map2.put(binKey, c2);</span>
            }
<span class="fc" id="L2675">            c2.addAll(c);</span>
        }

<span class="fc" id="L2678">        return map2;</span>
    }

    private TIntObjectMap&lt;TIntSet&gt; binByKeys(
        TIntObjectMap&lt;TIntSet&gt; greyPixelMap, int minKey,
        int maxKey, int binWidth) {

<span class="nc" id="L2685">        TIntObjectMap&lt;TIntSet&gt; map2 =</span>
            new TIntObjectHashMap&lt;TIntSet&gt;();

<span class="nc bnc" id="L2688" title="All 2 branches missed.">        for (int i = minKey; i &lt;= maxKey; ++i) {</span>

<span class="nc" id="L2690">            TIntSet c = greyPixelMap.get(i);</span>

<span class="nc bnc" id="L2692" title="All 2 branches missed.">            if (c == null) {</span>
<span class="nc" id="L2693">                continue;</span>
            }

<span class="nc" id="L2696">            int binKey = i/binWidth;</span>

<span class="nc" id="L2698">            TIntSet c2 = map2.get(binKey);</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">            if (c2 == null) {</span>
<span class="nc" id="L2700">                c2 = new TIntHashSet();</span>
<span class="nc" id="L2701">                map2.put(binKey, c2);</span>
            }
<span class="nc" id="L2703">            c2.addAll(c);</span>
        }

<span class="nc" id="L2706">        return map2;</span>
    }

    private void filterPeaksIfNoisey(PairIntArray peaks) {

<span class="pc bpc" id="L2711" title="1 of 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc" id="L2712">            return;</span>
        }

<span class="fc" id="L2715">        int sumDeltaX = 0;</span>
<span class="fc bfc" id="L2716" title="All 2 branches covered.">        for (int i = (peaks.getN() - 1); i &gt; 0; --i) {</span>
<span class="fc" id="L2717">            sumDeltaX += (peaks.getX(i) - peaks.getX(i - 1));</span>
        }
        //TODO: this may need to be revised:
        // if there are more than 1 peaks per delta x of 5 or so, re-bin by 4
<span class="fc" id="L2721">        float deltaX = (float)sumDeltaX/((float)peaks.getN() - 1);</span>
<span class="pc bpc" id="L2722" title="1 of 2 branches missed.">        if (deltaX &lt; 5) {</span>
            // re-bin by 4
<span class="nc" id="L2724">            PairIntArray peaks2 = new PairIntArray();</span>
<span class="nc bnc" id="L2725" title="All 2 branches missed.">            for (int i = 0; i &lt; peaks.getN(); i += 4) {</span>
<span class="nc" id="L2726">                int sumX = 0;</span>
<span class="nc" id="L2727">                int sumY = 0;</span>
<span class="nc" id="L2728">                int count = 0;</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">                for (int j = i; j &lt; (i + 5); ++j) {</span>
<span class="nc" id="L2730">                    sumX += peaks.getX(i);</span>
<span class="nc" id="L2731">                    sumY += peaks.getY(i);</span>
<span class="nc" id="L2732">                    count++;</span>
                }
<span class="nc" id="L2734">                sumX = Math.round((float)sumX/(float)count);</span>
<span class="nc" id="L2735">                sumY = Math.round((float)sumY/(float)count);</span>
<span class="nc" id="L2736">                peaks2.add(sumX, sumY);</span>
            }

<span class="nc" id="L2739">            peaks.removeRange(0, peaks.getN() - 1);</span>
<span class="nc" id="L2740">            peaks.addAll(peaks2);</span>
        }

<span class="fc" id="L2743">    }</span>

    private void mergeOrAppendGreyWithOthers(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups, List&lt;Set&lt;PairInt&gt;&gt; groupList,
        Set&lt;PairInt&gt; blackPixels, Set&lt;PairInt&gt; whitePixels) {

<span class="fc" id="L2749">        Map&lt;PairInt, Integer&gt; colorPixGroupMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="fc bfc" id="L2750" title="All 2 branches covered.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="fc" id="L2751">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="fc" id="L2752">            Integer groupKey = Integer.valueOf(i);</span>
<span class="fc bfc" id="L2753" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L2754">                colorPixGroupMap.put(p, groupKey);</span>
<span class="fc" id="L2755">            }</span>
        }

        // similarity limit for a grey pixel to join adjacent color pixel's cluster
<span class="fc" id="L2759">        int limit = 40;</span>

<span class="fc" id="L2761">        int w = input.getWidth();</span>
<span class="fc" id="L2762">        int h = input.getHeight();</span>

<span class="fc" id="L2764">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L2765">        int[] dys = Misc.dy8;</span>
<span class="fc bfc" id="L2766" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; greyGroup : greyPixelGroups) {</span>

<span class="fc" id="L2768">            Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2770" title="All 2 branches covered.">            for (PairInt greyP : greyGroup) {</span>
<span class="fc" id="L2771">                int x = greyP.getX();</span>
<span class="fc" id="L2772">                int y = greyP.getY();</span>

<span class="fc" id="L2774">                int idx = input.getInternalIndex(x, y);</span>
<span class="fc" id="L2775">                int r = input.getR(idx);</span>
<span class="fc" id="L2776">                int g = input.getG(idx);</span>
<span class="fc" id="L2777">                int b = input.getB(idx);</span>

                // ---- check for color similarity ------
<span class="fc" id="L2780">                int minDiffRGB = Integer.MAX_VALUE;</span>
<span class="fc" id="L2781">                int colorClusterIdx = -1;</span>
<span class="fc" id="L2782">                int minDiffBlack = Integer.MAX_VALUE;</span>
<span class="fc" id="L2783">                int minDiffWhite = Integer.MAX_VALUE;</span>

<span class="fc bfc" id="L2785" title="All 2 branches covered.">                for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="fc" id="L2786">                    int x2 = x + dxs[i];</span>
<span class="fc" id="L2787">                    int y2 = y + dys[i];</span>
<span class="pc bpc" id="L2788" title="1 of 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L2789">                        continue;</span>
                    }
<span class="fc" id="L2791">                    PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc" id="L2793">                    boolean adjIsBlack = blackPixels.contains(p2);</span>
<span class="fc" id="L2794">                    boolean adjIsWhite = whitePixels.contains(p2);</span>

<span class="fc" id="L2796">                    Integer colorClusterIndex = colorPixGroupMap.get(p2);</span>
<span class="fc bfc" id="L2797" title="All 6 branches covered.">                    if ((colorClusterIndex == null) &amp;&amp; !adjIsBlack &amp;&amp; !adjIsWhite) {</span>
<span class="fc" id="L2798">                        continue;</span>
                    }

<span class="fc" id="L2801">                    int idx2 = input.getInternalIndex(x2, y2);</span>
<span class="fc" id="L2802">                    int r2 = input.getR(idx2);</span>
<span class="fc" id="L2803">                    int g2 = input.getG(idx2);</span>
<span class="fc" id="L2804">                    int b2 = input.getB(idx2);</span>

<span class="fc" id="L2806">                    int diffR = Math.abs(r2 - r);</span>
<span class="fc" id="L2807">                    int diffG = Math.abs(g2 - g);</span>
<span class="fc" id="L2808">                    int diffB = Math.abs(b2 - b);</span>

<span class="fc" id="L2810">                    int diffRGB = diffR + diffG + diffB;</span>

<span class="fc bfc" id="L2812" title="All 2 branches covered.">                    if (adjIsBlack) {</span>
<span class="fc bfc" id="L2813" title="All 4 branches covered.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="fc" id="L2814">                            minDiffBlack = diffR;</span>
                        }
<span class="fc bfc" id="L2816" title="All 2 branches covered.">                    } else if (adjIsWhite) {</span>
<span class="fc bfc" id="L2817" title="All 4 branches covered.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="fc" id="L2818">                            minDiffWhite = diffR;</span>
                        }
                    } else {
<span class="fc bfc" id="L2821" title="All 4 branches covered.">                        if ((diffRGB &lt; minDiffRGB) &amp;&amp; (diffRGB &lt; limit)) {</span>
<span class="fc" id="L2822">                            minDiffRGB = diffRGB;</span>
<span class="pc bpc" id="L2823" title="1 of 2 branches missed.">                            colorClusterIdx = (colorClusterIndex == null) ? -1 :</span>
<span class="fc" id="L2824">                                colorClusterIndex.intValue();</span>
                        }
                    }
                }
<span class="fc bfc" id="L2828" title="All 2 branches covered.">                if (minDiffBlack &lt; 75) {</span>
<span class="fc" id="L2829">                    blackPixels.add(greyP);</span>
<span class="fc" id="L2830">                    remove.add(greyP);</span>
<span class="fc bfc" id="L2831" title="All 2 branches covered.">                } else if (minDiffWhite &lt; 75) {</span>
<span class="fc" id="L2832">                    whitePixels.add(greyP);</span>
<span class="fc" id="L2833">                    remove.add(greyP);</span>
                } else {
<span class="fc bfc" id="L2835" title="All 2 branches covered.">                    if (colorClusterIdx != -1) {</span>
                        //add to color cluster and remove from grey list
<span class="fc" id="L2837">                        groupList.get(colorClusterIdx).add(greyP);</span>
<span class="fc" id="L2838">                        remove.add(greyP);</span>
                    }
                }
<span class="fc" id="L2841">            }</span>
<span class="fc bfc" id="L2842" title="All 2 branches covered.">            for (PairInt rm : remove) {</span>
<span class="fc" id="L2843">                greyGroup.remove(rm);</span>
<span class="fc" id="L2844">            }</span>
<span class="fc" id="L2845">        }</span>

        // any remaining points in the grey list should be added as sets to
        // the color pixels list now
<span class="fc bfc" id="L2849" title="All 2 branches covered.">        for (int i = 0; i &lt; greyPixelGroups.size(); ++i) {</span>
<span class="fc" id="L2850">            Set&lt;PairInt&gt; greyGroup = greyPixelGroups.get(i);</span>
<span class="fc" id="L2851">            groupList.add(greyGroup);</span>
        }
<span class="fc" id="L2853">        greyPixelGroups.clear();</span>
<span class="fc" id="L2854">    }</span>

    private void mergeOrAppendGreyWithOthers(
        TIntObjectMap&lt;TIntSet&gt; adjacencyMap,
        List&lt;GroupPixelRGB&gt; rgbList,
        List&lt;TIntSet&gt; greyPixelsGroups,
        List&lt;TIntList&gt; groupedIndexesList,
        TIntList blackPixels, TIntList whitePixels) {

        // similarity limit for a grey pixel to join adjacent color pixel's cluster
<span class="nc" id="L2864">        int limit = 40;</span>

        // map w/ key = list index, value = groupedIndexesList index
<span class="nc" id="L2867">        TIntIntMap groupedRevIndexMap = new TIntIntHashMap();</span>
<span class="nc bnc" id="L2868" title="All 2 branches missed.">        for (int i = 0; i &lt; groupedIndexesList.size(); ++i) {</span>
<span class="nc" id="L2869">            TIntList listIndexes = groupedIndexesList.get(i);</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">            for (int j = 0; j &lt; listIndexes.size(); ++j) {</span>
<span class="nc" id="L2871">                int lIdx = listIndexes.get(j);</span>
<span class="nc" id="L2872">                groupedRevIndexMap.put(lIdx, i);</span>
            }
        }

<span class="nc bnc" id="L2876" title="All 2 branches missed.">        for (int i = 0; i &lt; greyPixelsGroups.size(); ++i) {</span>
            // remove from greyPixelGroups
<span class="nc" id="L2878">            TIntList remove = new TIntArrayList();</span>

<span class="nc" id="L2880">            TIntSet setListIndexes = greyPixelsGroups.get(i);</span>
<span class="nc" id="L2881">            TIntIterator iter = setListIndexes.iterator();</span>
<span class="nc bnc" id="L2882" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L2883">                int lIdx = iter.next();</span>

                // if an adjacent cell is near in color, merge grey
<span class="nc" id="L2886">                TIntSet adjIndexes = adjacencyMap.get(lIdx);</span>
<span class="nc bnc" id="L2887" title="All 4 branches missed.">                if (adjIndexes == null || adjIndexes.isEmpty()) {</span>
<span class="nc" id="L2888">                    continue;</span>
                }

<span class="nc" id="L2891">                GroupPixelRGB rgb1 = rgbList.get(lIdx);</span>
<span class="nc" id="L2892">                int r = Math.round(rgb1.getAvgRed());</span>
<span class="nc" id="L2893">                int g = Math.round(rgb1.getAvgGreen());</span>
<span class="nc" id="L2894">                int b = Math.round(rgb1.getAvgBlue());</span>

                // ---- check for color similarity ------
<span class="nc" id="L2897">                int minDiffRGB = Integer.MAX_VALUE;</span>
<span class="nc" id="L2898">                int colorClusterIdx = -1;</span>
<span class="nc" id="L2899">                int minDiffBlack = Integer.MAX_VALUE;</span>
<span class="nc" id="L2900">                int minDiffWhite = Integer.MAX_VALUE;</span>

<span class="nc" id="L2902">                TIntIterator iter2 = adjIndexes.iterator();</span>
<span class="nc bnc" id="L2903" title="All 2 branches missed.">                while (iter2.hasNext()) {</span>
<span class="nc" id="L2904">                    int lIdx2 = iter2.next();</span>
<span class="nc" id="L2905">                    GroupPixelRGB rgb2 = rgbList.get(lIdx2);</span>

<span class="nc" id="L2907">                    boolean adjIsBlack = blackPixels.contains(lIdx2);</span>
<span class="nc" id="L2908">                    boolean adjIsWhite = whitePixels.contains(lIdx2);</span>

<span class="nc bnc" id="L2910" title="All 6 branches missed.">                    if (!groupedRevIndexMap.containsKey(lIdx)</span>
                        &amp;&amp; !adjIsBlack &amp;&amp; !adjIsWhite) {
<span class="nc" id="L2912">                        continue;</span>
                    }
<span class="nc" id="L2914">                    int r2 = Math.round(rgb2.getAvgRed());</span>
<span class="nc" id="L2915">                    int g2 = Math.round(rgb2.getAvgGreen());</span>
<span class="nc" id="L2916">                    int b2 = Math.round(rgb2.getAvgBlue());</span>

<span class="nc" id="L2918">                    int diffR = Math.abs(r2 - r);</span>
<span class="nc" id="L2919">                    int diffG = Math.abs(g2 - g);</span>
<span class="nc" id="L2920">                    int diffB = Math.abs(b2 - b);</span>

<span class="nc" id="L2922">                    int diffRGB = diffR + diffG + diffB;</span>

<span class="nc bnc" id="L2924" title="All 2 branches missed.">                    if (adjIsBlack) {</span>
<span class="nc bnc" id="L2925" title="All 4 branches missed.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="nc" id="L2926">                            minDiffBlack = diffR;</span>
                        }
<span class="nc bnc" id="L2928" title="All 2 branches missed.">                    } else if (adjIsWhite) {</span>
<span class="nc bnc" id="L2929" title="All 4 branches missed.">                        if (diffR == diffG &amp;&amp; diffR == diffB) {</span>
<span class="nc" id="L2930">                            minDiffWhite = diffR;</span>
                        }
                    } else {
<span class="nc bnc" id="L2933" title="All 4 branches missed.">                        if ((diffRGB &lt; minDiffRGB) &amp;&amp; (diffRGB &lt; limit)) {</span>
<span class="nc" id="L2934">                            minDiffRGB = diffRGB;</span>
<span class="nc" id="L2935">                            colorClusterIdx =</span>
<span class="nc bnc" id="L2936" title="All 2 branches missed.">                                (groupedRevIndexMap.containsKey(lIdx)) ?</span>
<span class="nc" id="L2937">                                groupedRevIndexMap.get(lIdx) : -1;</span>
                        }
                    }
<span class="nc" id="L2940">                }</span>
<span class="nc bnc" id="L2941" title="All 2 branches missed.">                if (minDiffBlack &lt; 75) {</span>
<span class="nc" id="L2942">                    blackPixels.add(lIdx);</span>
<span class="nc" id="L2943">                    remove.add(lIdx);</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">                } else if (minDiffWhite &lt; 75) {</span>
<span class="nc" id="L2945">                    whitePixels.add(lIdx);</span>
<span class="nc" id="L2946">                    remove.add(lIdx);</span>
                } else {
                    //TODO: revisit this
<span class="nc bnc" id="L2949" title="All 2 branches missed.">                    if (colorClusterIdx != -1) {</span>
                        //add to color cluster and remove from grey list
<span class="nc" id="L2951">                        groupedIndexesList.get(colorClusterIdx)</span>
<span class="nc" id="L2952">                            .add(lIdx);</span>
<span class="nc" id="L2953">                        remove.add(lIdx);</span>
                    }
                }
<span class="nc" id="L2956">            }</span>
<span class="nc" id="L2957">            setListIndexes.removeAll(remove);</span>
        }

        // any remaining points in the grey list should be added as sets to
        // the color pixels list now
<span class="nc bnc" id="L2962" title="All 2 branches missed.">        for (int i = 0; i &lt; greyPixelsGroups.size(); ++i) {</span>
<span class="nc" id="L2963">            TIntSet setListIndexes = greyPixelsGroups.get(i);</span>
<span class="nc" id="L2964">            groupedIndexesList.add(</span>
                new TIntArrayList(setListIndexes));
        }

<span class="nc" id="L2968">        greyPixelsGroups.clear();</span>
<span class="nc" id="L2969">    }</span>

    protected double[] findMinMaxTheta(ImageExt input, Set&lt;PairInt&gt; points0) {

        //TODO: fix this and see if can find when hacked

<span class="fc" id="L2975">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L2977">        double[] minMaxTheta = new double[2];</span>

<span class="fc bfc" id="L2979" title="All 2 branches covered.">        for (PairInt p : points0) {</span>
<span class="fc" id="L2980">            int x = p.getX();</span>
<span class="fc" id="L2981">            int y = p.getY();</span>

<span class="fc" id="L2983">            double thetaRadians = cieC.calculateXYTheta(x, y);</span>
<span class="fc" id="L2984">            double theta = thetaRadians * 180. / Math.PI;</span>

<span class="pc bpc" id="L2986" title="1 of 2 branches missed.">            if (theta &lt; minMaxTheta[0]) {</span>
<span class="nc" id="L2987">                minMaxTheta[0] = theta;</span>
            }
<span class="fc bfc" id="L2989" title="All 2 branches covered.">            if (theta &gt; minMaxTheta[1]) {</span>
<span class="fc" id="L2990">                minMaxTheta[1] = theta;</span>
            }
<span class="fc" id="L2992">        }</span>

<span class="fc" id="L2994">        return minMaxTheta;</span>
    }

    /**
     * Find the 4 categories of point color as black, white, grey, and color.
     * CIE XY color space is used to place a pixel in the category, with the
     * additional determination of black, grey, and white intensity limits
     * using histograms within expected intensity limits.
     *
     * @param input
     * @param points0
     * @param blackPixels
     * @param whitePixels
     * @param greyPixelMap
     */
    private void populatePixelLists(ImageExt input,
        Set&lt;PairInt&gt; points0,
        Set&lt;PairInt&gt; blackPixels, Set&lt;PairInt&gt; whitePixels,
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {

<span class="fc" id="L3014">        int w = input.getWidth();</span>
<span class="fc" id="L3015">        int h = input.getHeight();</span>

<span class="fc" id="L3017">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // looking for limits in peaks of (r,g,b) &lt;= (45,45,45) and &gt; (191,191,191)
<span class="fc" id="L3020">        int[] whiteBlackLimits = findByHistogramLimitsForBlackAndWhite(input);</span>
        // overriding:
<span class="fc" id="L3022">        int whiteLimit = 245;</span>

<span class="fc bfc" id="L3024" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3025" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L3027">                int idx = input.getInternalIndex(i, j);</span>

<span class="fc" id="L3029">                int r = input.getR(idx);</span>
<span class="fc" id="L3030">                int g = input.getG(idx);</span>
<span class="fc" id="L3031">                int b = input.getB(idx);</span>

<span class="fc" id="L3033">                int avg = (r + g + b)/3;</span>
<span class="fc bfc" id="L3034" title="All 2 branches covered.">                if (avg &lt;= whiteBlackLimits[0]) {</span>
<span class="fc" id="L3035">                    blackPixels.add(new PairInt(i, j));</span>
<span class="fc" id="L3036">                    continue;</span>
                }

<span class="fc" id="L3039">                float rgbTot = r + g + b;</span>
<span class="fc" id="L3040">                float bDivTot = (float)b/rgbTot;</span>
<span class="fc" id="L3041">                float rDivTot = (float)r/rgbTot;</span>
<span class="fc" id="L3042">                float gDivTot = (float)g/rgbTot;</span>

<span class="fc" id="L3044">                float cx = input.getCIEX(idx);</span>
<span class="fc" id="L3045">                float cy = input.getCIEY(idx);</span>

<span class="fc bfc" id="L3047" title="All 2 branches covered.">                if (cieC.isWhite2(cx, cy) &amp;&amp;</span>
<span class="fc bfc" id="L3048" title="All 2 branches covered.">                    (Math.abs(0.333f - bDivTot) &lt; 0.02f) &amp;&amp;</span>
<span class="fc bfc" id="L3049" title="All 2 branches covered.">                    (Math.abs(0.333f - rDivTot) &lt; 0.02f) &amp;&amp;</span>
<span class="fc bfc" id="L3050" title="All 2 branches covered.">                    (Math.abs(0.333f - gDivTot) &lt; 0.02f)) {</span>

                    //if (avg &gt; whiteBlackLimits[1]) {
<span class="fc bfc" id="L3053" title="All 6 branches covered.">                    if ((r &gt; whiteLimit) &amp;&amp; (g &gt; whiteLimit) &amp;&amp; (b &gt; whiteLimit)) {</span>
<span class="fc" id="L3054">                        whitePixels.add(new PairInt(i, j));</span>
                    } else {
<span class="fc" id="L3056">                        Integer avgRGB = Integer.valueOf(avg);</span>
<span class="fc" id="L3057">                        Collection&lt;PairInt&gt; set = greyPixelMap.get(avgRGB);</span>
<span class="fc bfc" id="L3058" title="All 2 branches covered.">                        if (set == null) {</span>
<span class="fc" id="L3059">                            set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L3060">                            greyPixelMap.put(avgRGB, set);</span>
                        }
<span class="fc" id="L3062">                        set.add(new PairInt(i, j));</span>
<span class="fc" id="L3063">                    }</span>
                } else {
<span class="fc" id="L3065">                    points0.add(new PairInt(i, j));</span>
                }
            }
        }
<span class="fc" id="L3069">    }</span>

    /**
     * Find the 4 categories of point color as black, white, grey, and color.
     * CIE XY color space is used to place a pixel in the category, with the
     * additional determination of black, grey, and white intensity limits
     * using histograms within expected intensity limits.
     *
     * @param input
     * @param points0 output
     * @param blackPixels output
     * @param whitePixels output
     * @param greyPixelMap output key=avgRGB, value=input indexes
     */
    private void populatePixelLists(
        List&lt;GroupPixelRGB&gt; input,
        TIntList points0,
        TIntList blackPixels,
        TIntList whitePixels,
        TIntObjectMap&lt;TIntSet&gt; greyPixelMap,
        TIntList thetaForPoints0) {

<span class="nc" id="L3091">        float greyDiff = 0.02f;</span>

<span class="nc" id="L3093">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // looking for limits in peaks of (r,g,b) &lt;= (45,45,45) and &gt; (191,191,191)
<span class="nc" id="L3096">        int[] whiteBlackLimits =</span>
<span class="nc" id="L3097">            findByHistogramLimitsForBlackAndWhite(input);</span>
        // overriding:
<span class="nc" id="L3099">        int whiteLimit = 229;//245;</span>

<span class="nc bnc" id="L3101" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; input.size(); ++lIdx) {</span>
<span class="nc" id="L3102">            GroupPixelRGB group = input.get(lIdx);</span>
<span class="nc" id="L3103">            int avg = group.getAvgRGB();</span>
<span class="nc bnc" id="L3104" title="All 2 branches missed.">            if (avg &lt;= whiteBlackLimits[0]) {</span>
<span class="nc" id="L3105">                blackPixels.add(lIdx);</span>
<span class="nc" id="L3106">                continue;</span>
            }
<span class="nc" id="L3108">            float r = group.getAvgRed();</span>
<span class="nc" id="L3109">            float g = group.getAvgGreen();</span>
<span class="nc" id="L3110">            float b = group.getAvgBlue();</span>
<span class="nc" id="L3111">            float rgbTot = r + g + b;</span>
<span class="nc" id="L3112">            float bDivTot = b/rgbTot;</span>
<span class="nc" id="L3113">            float rDivTot = r/rgbTot;</span>
<span class="nc" id="L3114">            float gDivTot = g/rgbTot;</span>

<span class="nc" id="L3116">            float[] cieXY = cieC._rgbToXYChromaticity(</span>
                r, g, b);

<span class="nc bnc" id="L3119" title="All 2 branches missed.">            if (cieC.isWhite2(cieXY[0], cieXY[1]) &amp;&amp;</span>
<span class="nc bnc" id="L3120" title="All 2 branches missed.">                (Math.abs(0.333f - bDivTot) &lt; greyDiff) &amp;&amp;</span>
<span class="nc bnc" id="L3121" title="All 2 branches missed.">                (Math.abs(0.333f - rDivTot) &lt; greyDiff) &amp;&amp;</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">                (Math.abs(0.333f - gDivTot) &lt; greyDiff)) {</span>

                //if (avg &gt; whiteBlackLimits[1]) {
<span class="nc bnc" id="L3125" title="All 6 branches missed.">                if ((r &gt; whiteLimit) &amp;&amp; (g &gt; whiteLimit) &amp;&amp; (b &gt; whiteLimit)) {</span>
<span class="nc" id="L3126">                    whitePixels.add(lIdx);</span>
                } else {
<span class="nc" id="L3128">                    TIntSet set = greyPixelMap.get(avg);</span>
<span class="nc bnc" id="L3129" title="All 2 branches missed.">                    if (set == null) {</span>
<span class="nc" id="L3130">                        set = new TIntHashSet();</span>
<span class="nc" id="L3131">                        greyPixelMap.put(avg, set);</span>
                    }
<span class="nc" id="L3133">                    set.add(lIdx);</span>
<span class="nc" id="L3134">                }</span>
            } else {
<span class="nc" id="L3136">                points0.add(lIdx);</span>

<span class="nc" id="L3138">                double thetaRadians = cieC.calculateXYTheta(</span>
                    cieXY[0], cieXY[1]);
<span class="nc" id="L3140">                double theta = thetaRadians * 180. / Math.PI;</span>
<span class="nc" id="L3141">                thetaForPoints0.add((int)Math.round(theta));</span>
            }
        }
<span class="nc" id="L3144">    }</span>

    private void mergeNoise(ImageExt input, List&lt;Set&lt;PairInt&gt;&gt; groupList) {

<span class="nc" id="L3148">        Map&lt;PairInt, Integer&gt; pixelToGroupMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="nc bnc" id="L3149" title="All 2 branches missed.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="nc" id="L3150">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="nc bnc" id="L3151" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L3152">                pixelToGroupMap.put(p, Integer.valueOf(i));</span>
<span class="nc" id="L3153">            }</span>
        }

<span class="nc" id="L3156">        final int w = input.getWidth();</span>
<span class="nc" id="L3157">        final int h = input.getHeight();</span>

<span class="nc" id="L3159">        int[] dxs8 = Misc.dx8;</span>
<span class="nc" id="L3160">        int[] dys8 = Misc.dy8;</span>

<span class="nc" id="L3162">        float diffLimit = 0.01f;</span>

<span class="nc bnc" id="L3164" title="All 2 branches missed.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="nc" id="L3165">            Set&lt;PairInt&gt; set = groupList.get(i);</span>
<span class="nc" id="L3166">            Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3167" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L3168">                int x = p.getX();</span>
<span class="nc" id="L3169">                int y = p.getY();</span>
<span class="nc" id="L3170">                int idx = input.getInternalIndex(x, y);</span>

<span class="nc" id="L3172">                float cieX = input.getCIEX(idx);</span>
<span class="nc" id="L3173">                float cieY = input.getCIEY(idx);</span>

<span class="nc" id="L3175">                Integer groupIndex = pixelToGroupMap.get(p);</span>

                // key=groupIndex, value=number of pixels similar
<span class="nc" id="L3178">                Map&lt;Integer, Integer&gt; groupSimilarCount = new HashMap&lt;Integer, Integer&gt;();</span>

                // use cieXY, polar theta of cieXY, or rgb?
<span class="nc bnc" id="L3181" title="All 2 branches missed.">                for (int nIdx = 0; nIdx &lt; dxs8.length; ++nIdx) {</span>
<span class="nc" id="L3182">                    int x2 = x + dxs8[nIdx];</span>
<span class="nc" id="L3183">                    int y2 = y + dys8[nIdx];</span>
<span class="nc bnc" id="L3184" title="All 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L3185">                        continue;</span>
                    }
<span class="nc" id="L3187">                    int idx2 = input.getInternalIndex(x2, y2);</span>

<span class="nc" id="L3189">                    Integer groupIndex2 = pixelToGroupMap.get(new PairInt(x2, y2));</span>

<span class="nc bnc" id="L3191" title="All 2 branches missed.">                    if (groupIndex.intValue() == groupIndex2.intValue()) {</span>
<span class="nc" id="L3192">                        continue;</span>
                    }

<span class="nc" id="L3195">                    float cieX2 = input.getCIEX(idx2);</span>
<span class="nc" id="L3196">                    float cieY2 = input.getCIEY(idx2);</span>

<span class="nc" id="L3198">                    float diffCIEX = Math.abs(cieX2 - cieX);</span>
<span class="nc" id="L3199">                    float diffCIEY = Math.abs(cieY2 - cieY);</span>

<span class="nc bnc" id="L3201" title="All 4 branches missed.">                    if ((diffCIEX &gt; diffLimit) || (diffCIEY &gt; diffLimit)) {</span>
<span class="nc" id="L3202">                        continue;</span>
                    }

<span class="nc" id="L3205">                    Integer count = groupSimilarCount.get(groupIndex2);</span>
<span class="nc bnc" id="L3206" title="All 2 branches missed.">                    if (count == null) {</span>
<span class="nc" id="L3207">                        groupSimilarCount.put(groupIndex2, Integer.valueOf(1));</span>
                    } else {
<span class="nc" id="L3209">                        groupSimilarCount.put(groupIndex2, Integer.valueOf(count.intValue() + 11));</span>
                    }

                }
<span class="nc bnc" id="L3213" title="All 2 branches missed.">                if (groupSimilarCount.isEmpty()) {</span>
<span class="nc" id="L3214">                    continue;</span>
                }
<span class="nc bnc" id="L3216" title="All 2 branches missed.">                for (Entry&lt;Integer, Integer&gt; entry : groupSimilarCount.entrySet()) {</span>
<span class="nc bnc" id="L3217" title="All 2 branches missed.">                    if (entry.getValue() &gt;= 6) {</span>
                        // assign this group to pixel p
<span class="nc" id="L3219">                        pixelToGroupMap.put(p, entry.getKey());</span>
<span class="nc" id="L3220">                        remove.add(p);</span>
<span class="nc" id="L3221">                        groupList.get(entry.getKey().intValue()).add(p);</span>
<span class="nc" id="L3222">                        break;</span>
                    }
<span class="nc" id="L3224">                }</span>
<span class="nc" id="L3225">            }</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">            for (PairInt rm : remove) {</span>
<span class="nc" id="L3227">                set.remove(rm);</span>
<span class="nc" id="L3228">            }</span>
        }
<span class="nc" id="L3230">    }</span>

    private int[] findByHistogramLimitsForBlackAndWhite(ImageExt input) {

        //looking for limits of (r,g,b) &lt;= (45,45,45) and &gt; (180,180,180)
<span class="fc" id="L3235">        int l0 = 45;</span>
<span class="fc" id="L3236">        int l0B = 70;</span>
<span class="fc" id="L3237">        int h0 = 245;</span>

<span class="fc" id="L3239">        List&lt;Integer&gt; avgL = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L3241">        List&lt;Integer&gt; avgH = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L3243" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="fc" id="L3244">            int r = input.getR(i);</span>
<span class="fc" id="L3245">            int g = input.getG(i);</span>
<span class="fc" id="L3246">            int b = input.getB(i);</span>
<span class="fc bfc" id="L3247" title="All 6 branches covered.">            if ((r &lt;= l0) &amp;&amp; (g &lt;= l0) &amp;&amp; (b &lt;= l0B)) {</span>
<span class="fc" id="L3248">                int avg = (r + g + b)/3;</span>
<span class="fc" id="L3249">                avgL.add(Integer.valueOf(avg));</span>
<span class="fc bfc" id="L3250" title="All 6 branches covered.">            } else if ((r &gt; h0) &amp;&amp; (g &gt; h0) &amp;&amp; (b &gt; h0)) {</span>
<span class="fc" id="L3251">                int avg = (r + g + b)/3;</span>
<span class="fc" id="L3252">                avgH.add(Integer.valueOf(avg));</span>
            }
        }

<span class="fc" id="L3256">        int[] limits = new int[2];</span>

<span class="pc bpc" id="L3258" title="1 of 2 branches missed.">        if (avgL.size() &gt; 30) {</span>
<span class="fc" id="L3259">            HistogramHolder hist = Histogram.createSimpleHistogram(avgL);</span>
<span class="pc bpc" id="L3260" title="1 of 2 branches missed.">            if (hist == null) {</span>
<span class="nc" id="L3261">                limits[0] = l0 - 1;</span>
            } else {
                /*
                try {
                    hist.plotHistogram(&quot;black pixels&quot;, &quot;black_&quot; + MiscDebug.getCurrentTimeFormatted());
                } catch (IOException ex) {
                    Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
                }
                */
<span class="fc" id="L3270">                int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="fc" id="L3271">                int lastZeroIdx = MiscMath.findLastZeroIndex(hist);</span>
<span class="pc bpc" id="L3272" title="2 of 4 branches missed.">                if ((lastZeroIdx != -1) &amp;&amp; (lastZeroIdx &lt; hist.getXHist().length)) {</span>
<span class="fc" id="L3273">                    limits[0] = Math.round(hist.getXHist()[lastZeroIdx]);</span>
<span class="nc bnc" id="L3274" title="All 2 branches missed.">                } else if (yMaxIdx == -1) {</span>
<span class="nc" id="L3275">                    limits[0] = l0 - 1;</span>
                } else {
                    //limits[0] = Math.round(hist.getXHist()[indexes.get(0).intValue()]);
<span class="nc" id="L3278">                    limits[0] = Math.round(hist.getXHist()[yMaxIdx]);</span>
                }
            }
<span class="fc" id="L3281">        } else {</span>
<span class="nc" id="L3282">            limits[0] = l0 - 1;</span>
        }

<span class="pc bpc" id="L3285" title="1 of 2 branches missed.">        if (avgH.size() &gt; 30) {</span>

<span class="fc" id="L3287">            int[] q = ImageStatisticsHelper.getQuartiles(avgH);</span>
            /*
            HistogramHolder hist = Histogram.createSimpleHistogram(avgH);
            if (hist == null) {
                limits[1] = h0;
            } else {
                List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexes(hist, 0.1f);
                try {
                    hist.plotHistogram(&quot;hite pixels&quot;, &quot;white_&quot; + MiscDebug.getCurrentTimeFormatted());
                } catch (IOException ex) {
                    Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
                }
                if (indexes == null || indexes.isEmpty()) {
                    limits[1] = h0;
                } else {
                    limits[1] = Math.round(hist.getXHist()[indexes.get(0).intValue()]);
                }
            }
            */
<span class="fc" id="L3306">            limits[1] = q[3];</span>
<span class="fc" id="L3307">        } else {</span>
<span class="nc" id="L3308">            limits[1] = h0;</span>
        }

<span class="fc" id="L3311">        return limits;</span>
    }

    private int[] findByHistogramLimitsForBlackAndWhite(
        List&lt;GroupPixelRGB&gt; input) {

        //looking for limits of (r,g,b) &lt;= (45,45,45) and &gt; (180,180,180)
<span class="nc" id="L3318">        int l0 = 45;</span>
<span class="nc" id="L3319">        int l0B = 70;</span>
<span class="nc" id="L3320">        int h0 = 229;//245;</span>

<span class="nc" id="L3322">        List&lt;Integer&gt; avgL = new ArrayList&lt;Integer&gt;();</span>

<span class="nc" id="L3324">        List&lt;Integer&gt; avgH = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L3326" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; input.size(); ++lIdx) {</span>
<span class="nc" id="L3327">            GroupPixelRGB gp = input.get(lIdx);</span>
<span class="nc" id="L3328">            float r = gp.getAvgRed();</span>
<span class="nc" id="L3329">            float g = gp.getAvgGreen();</span>
<span class="nc" id="L3330">            float b = gp.getAvgBlue();</span>
<span class="nc" id="L3331">            int avg = Math.round(gp.getAvgRGB());</span>

<span class="nc bnc" id="L3333" title="All 6 branches missed.">            if ((r &lt;= l0) &amp;&amp; (g &lt;= l0) &amp;&amp; (b &lt;= l0B)) {</span>
<span class="nc" id="L3334">                avgL.add(Integer.valueOf(avg));</span>
<span class="nc bnc" id="L3335" title="All 6 branches missed.">            } else if ((r &gt; h0) &amp;&amp; (g &gt; h0) &amp;&amp; (b &gt; h0)) {</span>
<span class="nc" id="L3336">                avgH.add(Integer.valueOf(avg));</span>
            }
        }

<span class="nc" id="L3340">        int[] limits = new int[2];</span>

<span class="nc bnc" id="L3342" title="All 2 branches missed.">        if (avgL.size() &gt; 30) {</span>
<span class="nc" id="L3343">            HistogramHolder hist = Histogram.createSimpleHistogram(avgL);</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">            if (hist == null) {</span>
<span class="nc" id="L3345">                limits[0] = l0 - 1;</span>
            } else {
                /*
                try {
                    hist.plotHistogram(&quot;black pixels&quot;, &quot;black_&quot; + MiscDebug.getCurrentTimeFormatted());
                } catch (IOException ex) {
                    Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
                }
                */
<span class="nc" id="L3354">                int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
<span class="nc" id="L3355">                int lastZeroIdx = MiscMath.findLastZeroIndex(hist);</span>
<span class="nc bnc" id="L3356" title="All 4 branches missed.">                if ((lastZeroIdx != -1) &amp;&amp; (lastZeroIdx &lt; hist.getXHist().length)) {</span>
<span class="nc" id="L3357">                    limits[0] = Math.round(hist.getXHist()[lastZeroIdx]);</span>
<span class="nc bnc" id="L3358" title="All 2 branches missed.">                } else if (yMaxIdx == -1) {</span>
<span class="nc" id="L3359">                    limits[0] = l0 - 1;</span>
                } else {
                    //limits[0] = Math.round(hist.getXHist()[indexes.get(0).intValue()]);
<span class="nc" id="L3362">                    limits[0] = Math.round(hist.getXHist()[yMaxIdx]);</span>
                }
            }
<span class="nc" id="L3365">        } else {</span>
<span class="nc" id="L3366">            limits[0] = l0 - 1;</span>
        }

<span class="nc bnc" id="L3369" title="All 2 branches missed.">        if (avgH.size() &gt; 30) {</span>

<span class="nc" id="L3371">            int[] q = ImageStatisticsHelper.getQuartiles(avgH);</span>
            /*
            HistogramHolder hist = Histogram.createSimpleHistogram(avgH);
            if (hist == null) {
                limits[1] = h0;
            } else {
                List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexes(hist, 0.1f);
                try {
                    hist.plotHistogram(&quot;hite pixels&quot;, &quot;white_&quot; + MiscDebug.getCurrentTimeFormatted());
                } catch (IOException ex) {
                    Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
                }
                if (indexes == null || indexes.isEmpty()) {
                    limits[1] = h0;
                } else {
                    limits[1] = Math.round(hist.getXHist()[indexes.get(0).intValue()]);
                }
            }
            */
<span class="nc" id="L3390">            limits[1] = q[3];</span>
<span class="nc" id="L3391">        } else {</span>
<span class="nc" id="L3392">            limits[1] = h0;</span>
        }

<span class="nc" id="L3395">        return limits;</span>
    }

    public Map&lt;PairInt, Integer&gt; calculatePolarCIEXY(ImageExt input, Set&lt;PairInt&gt; points) {

<span class="nc" id="L3400">        Map&lt;PairInt, Integer&gt; map = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc" id="L3402">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc bnc" id="L3404" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L3406">            float cieX = input.getCIEX(p.getX(), p.getY());</span>
<span class="nc" id="L3407">            float cieY = input.getCIEY(p.getX(), p.getY());</span>

<span class="nc" id="L3409">            double thetaRadians = cieC.calculateXYTheta(cieX, cieY);</span>

<span class="nc" id="L3411">            int thetaDegrees = (int)Math.round(thetaRadians * 180./Math.PI);</span>

<span class="nc" id="L3413">            map.put(p, Integer.valueOf(thetaDegrees));</span>
<span class="nc" id="L3414">        }</span>

<span class="nc" id="L3416">        return map;</span>
    }

    public float[] getValues(Map&lt;PairInt, Integer&gt; map) {
<span class="nc" id="L3420">        float[] values = new float[map.size()];</span>
<span class="nc" id="L3421">        int count = 0;</span>
<span class="nc bnc" id="L3422" title="All 2 branches missed.">        for (Entry&lt;PairInt, Integer&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L3423">            values[count] = entry.getValue().floatValue();</span>
<span class="nc" id="L3424">            count++;</span>
<span class="nc" id="L3425">        }</span>
<span class="nc" id="L3426">        return values;</span>
    }

    /**
     * NOT READY FOR USE.  STILL EXPERIMENTING.
     *
     * Calculates lists of black pixels, white pixels, grey pixels, and assigns
     * the remaining to CIEXY Lab color space, then creates a map of the
     * CIEX and CIEY points and uses density based clustering
     * (http://nking.github.io/two-point-correlation/)
     * to find clusters of points in CIE X, CIEY space,
     * then merges pixels in the grey list with adjacent clusters if
     * similar, and the final result is a list of pixel clusters, including the
     * black and white and remaining grey.
     *
     * Note that the color black is not defined in CIE XY color space and that
     * the color white is at the center of the space as a large circle so they
     * are not included in the density based clustering.
     * Note also that the remaining grey pixels which did not merge with the
     * cie xy pixel clusters, may be in separate groups already due to a
     * frequency based grouping for them.
     *
     * @param input
     * @param useBlur
     */
    public void applyPolarCIEXY(ImageExt input, boolean useBlur) {

        //TODO: improve the clustering results in two ways:
        // (1) for smaller ciexy clusters, merge with adjacent clusters if
        //     similar color
        // (2) any pixel with 7 neighbors of same color should be that color too

<span class="nc bnc" id="L3458" title="All 2 branches missed.">        if (useBlur) {</span>
<span class="nc" id="L3459">            ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L3460">            imageProcessor.blur(input, 1.0f);</span>
        }

<span class="nc" id="L3463">        Set&lt;PairInt&gt; blackPixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L3465">        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap = new HashMap&lt;Integer, Collection&lt;PairInt&gt;&gt;();</span>

<span class="nc" id="L3467">        Set&lt;PairInt&gt; whitePixels = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L3469">        Set&lt;PairInt&gt; points0 = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L3471">        populatePixelLists(input, points0, blackPixels, whitePixels, greyPixelMap);</span>

<span class="nc" id="L3473">        Map&lt;PairInt, Integer&gt; clrPolarCIEXYMap = calculatePolarCIEXY(input, points0);</span>
<span class="nc" id="L3474">        float[] clrPolarCIEXY = getValues(clrPolarCIEXYMap);</span>
<span class="nc" id="L3475">        float binWidth = 1;</span>
<span class="nc" id="L3476">        HistogramHolder hist = Histogram.createSimpleHistogram(//binWidth,</span>
<span class="nc" id="L3477">            clrPolarCIEXY, Errors.populateYErrorsBySqrt(clrPolarCIEXY));</span>
<span class="nc" id="L3478">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist,</span>
            0.1f);
<span class="nc" id="L3480">        int[] binCenters = createBinCenters360(hist, indexes);</span>

<span class="nc" id="L3482">        List&lt;Set&lt;PairInt&gt;&gt; colorPixelGroups = assignToNearestPolarCIECluster(</span>
            clrPolarCIEXYMap, binCenters);

<span class="nc" id="L3485">        List&lt;Set&lt;PairInt&gt;&gt; greyPixelGroups = groupByPeaksForGrey(input, greyPixelMap);</span>

<span class="nc" id="L3487">        ImageExt imgExt = input.copyToImageExt();</span>

<span class="nc bnc" id="L3489" title="All 2 branches missed.">        for (PairInt p : blackPixels) {</span>
<span class="nc" id="L3490">           imgExt.setRGB(p.getX(), p.getY(), 0, 0, 0);</span>
<span class="nc" id="L3491">        }</span>

<span class="nc bnc" id="L3493" title="All 2 branches missed.">        for (PairInt p : whitePixels) {</span>
<span class="nc" id="L3494">           imgExt.setRGB(p.getX(), p.getY(), 255, 255, 255);</span>
<span class="nc" id="L3495">        }</span>

<span class="nc" id="L3497">        int gClr = 255;</span>
<span class="nc" id="L3498">        int s = 127/colorPixelGroups.size();</span>
<span class="nc bnc" id="L3499" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : colorPixelGroups) {</span>
<span class="nc bnc" id="L3500" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L3501">               imgExt.setRGB(p.getX(), p.getY(), 0, gClr, 0);</span>
<span class="nc" id="L3502">            }</span>
<span class="nc" id="L3503">            gClr -= s;</span>
<span class="nc" id="L3504">        }</span>

        /*
        int rClr = 255;
        s = 127/greyPixelMap.size();
        for (Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {
            for (PairInt p : entry.getValue()) {
                imgExt.setRGB(p.getX(), p.getY(), rClr, 0, 0);
            }
            rClr -= s;
        }
        */
<span class="nc" id="L3516">        int rClr = 255;</span>
<span class="nc" id="L3517">        s = 127/greyPixelGroups.size();</span>
<span class="nc bnc" id="L3518" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : greyPixelGroups) {</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L3520">               imgExt.setRGB(p.getX(), p.getY(), rClr, 0, 0);</span>
<span class="nc" id="L3521">            }</span>
<span class="nc" id="L3522">            rClr -= s;</span>
<span class="nc" id="L3523">        }</span>

<span class="nc" id="L3525">        input.resetTo(imgExt);</span>
<span class="nc" id="L3526">    }</span>

    private int[] createBinCenters360(HistogramHolder hist, List&lt;Integer&gt; indexes) {

<span class="nc bnc" id="L3530" title="All 2 branches missed.">        if (indexes.isEmpty()) {</span>
<span class="nc" id="L3531">            return new int[0];</span>
        }

<span class="nc" id="L3534">        int n = indexes.size();</span>

<span class="nc bnc" id="L3536" title="All 2 branches missed.">        if (n == 1) {</span>

<span class="nc" id="L3538">            int[] binCenters = new int[n + 1];</span>

            /*
            examples for n=1
                --  90
            180
                -- 270
            ----------------
                --  90-176=  360-(176-90) = 274
            4
                -- 270-176=  94
            ----------------
                --  90+(330-180)=  240
            330
                -- 270+(330-180)=  270 + 150 - 360 = 60
            */

<span class="nc" id="L3555">            int vc = Math.round(hist.getXHist()[indexes.get(0).intValue()]);</span>

<span class="nc bnc" id="L3557" title="All 2 branches missed.">            if (vc == 180) {</span>
<span class="nc" id="L3558">                binCenters[0] = 90;</span>
<span class="nc" id="L3559">                binCenters[1] = 270;</span>
<span class="nc bnc" id="L3560" title="All 2 branches missed.">            } else if (vc &lt; 180) {</span>
<span class="nc" id="L3561">                int delta = 180 - vc;</span>
<span class="nc" id="L3562">                binCenters[0] = 360 - (delta - 90);</span>
<span class="nc" id="L3563">                binCenters[1] = 270 - delta;</span>
<span class="nc" id="L3564">            } else {</span>
<span class="nc" id="L3565">                int delta = vc - 180;</span>
<span class="nc" id="L3566">                binCenters[0] = 90 + delta;</span>
<span class="nc" id="L3567">                binCenters[1] = 270 + delta - 360;</span>
            }

<span class="nc" id="L3570">            return binCenters;</span>
        }

<span class="nc" id="L3573">        int[] binCenters = new int[n];</span>

<span class="nc bnc" id="L3575" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="nc" id="L3577">            int idx = indexes.get(i);</span>

<span class="nc" id="L3579">            binCenters[i] = Math.round(hist.getXHist()[idx]);</span>
        }

<span class="nc" id="L3582">        return binCenters;</span>
    }

    private int[] createBinCenters255(HistogramHolder hist, List&lt;Integer&gt; indexes) {

<span class="nc bnc" id="L3587" title="All 2 branches missed.">        if (indexes.isEmpty()) {</span>
<span class="nc" id="L3588">            return new int[0];</span>
        }

<span class="nc" id="L3591">        int n = indexes.size();</span>

<span class="nc bnc" id="L3593" title="All 2 branches missed.">        if (n == 1) {</span>

<span class="nc" id="L3595">            int[] binCenters = new int[n + 1];</span>

<span class="nc" id="L3597">            int vc = Math.round(hist.getXHist()[indexes.get(0).intValue()]);</span>

<span class="nc" id="L3599">            binCenters[0] = vc/2;</span>
<span class="nc" id="L3600">            binCenters[1] = (255 + vc)/2;</span>

<span class="nc" id="L3602">            return binCenters;</span>
        }

<span class="nc" id="L3605">        int[] binCenters = new int[n];</span>

<span class="nc bnc" id="L3607" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="nc" id="L3609">            int idx = indexes.get(i);</span>

<span class="nc" id="L3611">            binCenters[i] = Math.round(hist.getXHist()[idx]);</span>
        }

<span class="nc" id="L3614">        return binCenters;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; groupByPeaksForGrey(ImageExt input,
        Map&lt;Integer, Collection&lt;PairInt&gt;&gt; greyPixelMap) {

<span class="nc" id="L3620">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">        for (Entry&lt;Integer, Collection&lt;PairInt&gt;&gt; entry : greyPixelMap.entrySet()) {</span>
<span class="nc" id="L3622">            points.addAll(entry.getValue());</span>
<span class="nc" id="L3623">        }</span>

<span class="nc" id="L3625">        Map&lt;PairInt, Integer&gt; polarCIEXYMap = calculatePolarCIEXY(input, points);</span>
<span class="nc" id="L3626">        float[] polarCIEXY = getValues(polarCIEXYMap);</span>
<span class="nc" id="L3627">        float binWidth = 1;</span>
<span class="nc" id="L3628">        HistogramHolder hist = Histogram.createSimpleHistogram(binWidth,</span>
<span class="nc" id="L3629">            polarCIEXY, Errors.populateYErrorsBySqrt(polarCIEXY));</span>
<span class="nc" id="L3630">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist,</span>
            0.1f);
<span class="nc" id="L3632">        int[] binCenters = createBinCenters360(hist, indexes);</span>

<span class="nc" id="L3634">        List&lt;Set&lt;PairInt&gt;&gt; pixelGroups = assignToNearestPolarCIECluster(</span>
            polarCIEXYMap, binCenters);

<span class="nc" id="L3637">        return pixelGroups;</span>

    }

    /**
     * a greyscale segmentation algorithm similar to the KMPP, but does not use
     * a random number generator to find seeds of intensity bins.
     * @param input
     */
    public void applyGreyscaleHistogram(GreyscaleImage input) {

<span class="nc" id="L3648">        float[] values = new float[input.getNPixels()];</span>
<span class="nc bnc" id="L3649" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="nc" id="L3650">            int v = input.getValue(i);</span>
<span class="nc" id="L3651">            values[i] = v;</span>
        }

<span class="nc" id="L3654">        int[] binCenters = determineGreyscaleBinCenters(values);</span>

<span class="nc" id="L3656">        assignToNearestCluster(input, binCenters);</span>
<span class="nc" id="L3657">    }</span>

    /**
     * a greyscale segmentation algorithm similar to the KMPP, but does not use
     * a random number generator to find seeds of intensity bins.
     *
     * @param values
     * @return
     */
    public int[] determineGreyscaleBinCenters(float[] values) {

<span class="nc" id="L3668">        float binWidth = 3;</span>
<span class="nc" id="L3669">        HistogramHolder hist = Histogram.createSimpleHistogram(0, 255, binWidth,</span>
<span class="nc" id="L3670">            values, Errors.populateYErrorsBySqrt(values));</span>
<span class="nc" id="L3671">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist, 0.05f);</span>

<span class="nc bnc" id="L3673" title="All 2 branches missed.">        if (indexes.size() &lt;= 3) {</span>
<span class="nc" id="L3674">            binWidth = 10;</span>
<span class="nc" id="L3675">            hist = Histogram.createSimpleHistogram(0, 255, binWidth,</span>
<span class="nc" id="L3676">                values, Errors.populateYErrorsBySqrt(values));</span>
<span class="nc" id="L3677">            indexes = MiscMath.findStrongPeakIndexesDescSort(hist, 0.05f);</span>

<span class="nc" id="L3679">            int k = 3;</span>
<span class="nc bnc" id="L3680" title="All 2 branches missed.">            int idx = (indexes.size() &lt; k) ? indexes.size() : k;</span>
<span class="nc" id="L3681">            indexes = indexes.subList(0, idx);</span>
        }

        /*
        try {
            hist.plotHistogram(&quot;greyscale&quot;, &quot;1&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageSegmentation.class.getName()).log(Level.SEVERE, null, ex);
        }*/

<span class="nc" id="L3691">        int[] binCenters = createBinCenters255(hist, indexes);</span>

<span class="nc" id="L3693">        return binCenters;</span>
    }
    
    public GreyscaleImage createCombinedWaveletBased(Image img) {
<span class="nc" id="L3697">        return createCombinedWaveletBased(img.copyRedToGreyscale(),</span>
<span class="nc" id="L3698">            img.copyGreenToGreyscale(), img.copyBlueToGreyscale());</span>
    }

    public GreyscaleImage createCombinedWaveletBased2(Image img) {
<span class="nc" id="L3702">        return createCombinedWaveletBased2(img.copyRedToGreyscale(),</span>
<span class="nc" id="L3703">            img.copyGreenToGreyscale(), img.copyBlueToGreyscale());</span>
    }

    public GreyscaleImage createCombinedWaveletBased(
        GreyscaleImage rImg, GreyscaleImage gImg, GreyscaleImage bImg) {

<span class="nc" id="L3709">        boolean use1D = true;</span>
<span class="nc" id="L3710">        GreyscaleImage rSegImg = createGreyscale5(rImg, use1D);</span>
<span class="nc" id="L3711">        GreyscaleImage gSegImg = createGreyscale5(gImg, use1D);</span>
<span class="nc" id="L3712">        GreyscaleImage bSegImg = createGreyscale5(bImg, use1D);</span>

<span class="nc" id="L3714">        GreyscaleImage combined = rSegImg.copyImage();</span>
<span class="nc bnc" id="L3715" title="All 2 branches missed.">        for (int i = 0; i &lt; rSegImg.getWidth(); ++i) {</span>
<span class="nc bnc" id="L3716" title="All 2 branches missed.">            for (int j = 0; j &lt; rSegImg.getHeight(); ++j) {</span>
<span class="nc" id="L3717">                int g = gSegImg.getValue(i, j);</span>
<span class="nc" id="L3718">                int b = bSegImg.getValue(i, j);</span>
<span class="nc bnc" id="L3719" title="All 2 branches missed.">                if (g &gt; 0) {</span>
<span class="nc" id="L3720">                    combined.setValue(i, j, g);</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">                } else if (b &gt; 0) {</span>
<span class="nc" id="L3722">                    combined.setValue(i, j, b);</span>
                }
            }
        }
<span class="nc" id="L3726">        return combined;</span>
    }

    public GreyscaleImage createCombinedWaveletBased2(
        GreyscaleImage rImg, GreyscaleImage gImg, GreyscaleImage bImg) {

<span class="nc" id="L3732">        ATrousWaveletTransform wt = new ATrousWaveletTransform();</span>

<span class="nc" id="L3734">        GreyscaleImage coarsestCoeffR = null;</span>
<span class="nc" id="L3735">        GreyscaleImage coarsestCoeffG = null;</span>
<span class="nc" id="L3736">        GreyscaleImage coarsestCoeffB = null;</span>

<span class="nc bnc" id="L3738" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
            GreyscaleImage input;
<span class="nc bnc" id="L3740" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L3741">                input = rImg;</span>
<span class="nc bnc" id="L3742" title="All 2 branches missed.">            } else if (i == 1) {</span>
<span class="nc" id="L3743">                input = gImg;</span>
            } else {
<span class="nc" id="L3745">                input = bImg;</span>
            }
<span class="nc" id="L3747">            List&lt;GreyscaleImage&gt; transformed = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L3748">            List&lt;GreyscaleImage&gt; coeffs = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L3749">            wt.calculateWithB3SplineScalingFunction(input, transformed, coeffs);</span>
<span class="nc bnc" id="L3750" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L3751">                coarsestCoeffR = coeffs.get(coeffs.size() - 1);</span>
<span class="nc bnc" id="L3752" title="All 2 branches missed.">            } else if (i == 1) {</span>
<span class="nc" id="L3753">                coarsestCoeffG = coeffs.get(coeffs.size() - 1);</span>
            } else {
<span class="nc" id="L3755">                coarsestCoeffB = coeffs.get(coeffs.size() - 1);</span>
            }
        }

        //TODO: determine top limit by frequency distr?
<span class="nc" id="L3760">        int limit = 3;</span>

<span class="nc" id="L3762">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span>

<span class="nc" id="L3764">        GreyscaleImage coarsestCombined = coarsestCoeffB.createWithDimensions();</span>

<span class="nc bnc" id="L3766" title="All 2 branches missed.">        for (int i = 0; i &lt; coarsestCoeffR.getNPixels(); ++i) {</span>
<span class="nc" id="L3767">            int r = coarsestCoeffR.getValue(i);</span>
<span class="nc" id="L3768">            int g = coarsestCoeffG.getValue(i);</span>
<span class="nc" id="L3769">            int b = coarsestCoeffB.getValue(i);</span>
<span class="nc bnc" id="L3770" title="All 6 branches missed.">            if (r &gt; limit || g &gt; limit || b &gt; limit) {</span>
<span class="nc" id="L3771">                coarsestCombined.setValue(i, 250);</span>
<span class="nc" id="L3772">                stack.add(Integer.valueOf(i));</span>
            }
        }

<span class="nc" id="L3776">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L3777">        int[] dys = Misc.dy8;</span>
<span class="nc" id="L3778">        int w = coarsestCombined.getWidth();</span>
<span class="nc" id="L3779">        int h = coarsestCombined.getHeight();</span>

<span class="nc" id="L3781">        int lowerLimit = 0;</span>
<span class="nc bnc" id="L3782" title="All 2 branches missed.">        while (limit &gt; lowerLimit) {</span>
            // use the canny edge 2-layer approach to pick up neighboring pixels
            // at or above a lower limit

<span class="nc" id="L3786">            Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();</span>
<span class="nc" id="L3787">            limit--;</span>
<span class="nc bnc" id="L3788" title="All 2 branches missed.">            while (!stack.isEmpty()) {</span>
<span class="nc" id="L3789">                Integer pixIndex = stack.pop();</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">                if (visited.contains(pixIndex)) {</span>
<span class="nc" id="L3791">                    continue;</span>
                }
<span class="nc" id="L3793">                int x = coarsestCombined.getCol(pixIndex.intValue());</span>
<span class="nc" id="L3794">                int y = coarsestCombined.getRow(pixIndex.intValue());</span>
<span class="nc bnc" id="L3795" title="All 2 branches missed.">                for (int i = 0; i &lt; dxs.length; ++i) {</span>
<span class="nc" id="L3796">                    int x2 = x + dxs[i];</span>
<span class="nc" id="L3797">                    int y2 = y + dys[i];</span>
<span class="nc bnc" id="L3798" title="All 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt; (w - 1) || y2 &gt; (h - 1)) {</span>
<span class="nc" id="L3799">                        continue;</span>
                    }
<span class="nc" id="L3801">                    int r = coarsestCoeffR.getValue(x2, y2);</span>
<span class="nc" id="L3802">                    int g = coarsestCoeffG.getValue(x2, y2);</span>
<span class="nc" id="L3803">                    int b = coarsestCoeffB.getValue(x2, y2);</span>
<span class="nc bnc" id="L3804" title="All 6 branches missed.">                    if (r &gt; limit || g &gt; limit || b &gt; limit) {</span>
<span class="nc" id="L3805">                        coarsestCombined.setValue(i, 250);</span>
<span class="nc" id="L3806">                        stack.add(Integer.valueOf(i));</span>
                    }
                }
<span class="nc" id="L3809">                visited.add(pixIndex);</span>
<span class="nc" id="L3810">            }</span>
<span class="nc" id="L3811">        }</span>

<span class="nc" id="L3813">        return coarsestCombined;</span>
    }

    /**
     * segmentation algorithm using an a trous wavelet transform.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale5(GreyscaleImage input) {

<span class="fc" id="L3824">        boolean use1D = false;</span>
<span class="fc" id="L3825">        return createGreyscale5(input, use1D);</span>
    }

    /**
     * segmentation algorithm using an a trous wavelet transform.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale5(GreyscaleImage input, boolean use1D) {

<span class="fc" id="L3836">        ATrousWaveletTransform wt = new ATrousWaveletTransform();</span>

<span class="fc" id="L3838">        List&lt;GreyscaleImage&gt; transformed = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="fc" id="L3839">        List&lt;GreyscaleImage&gt; coeffs = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="pc bpc" id="L3841" title="1 of 2 branches missed.">        if (use1D) {</span>
<span class="nc" id="L3842">            wt.calculateWithB3SplineScalingFunction(input, transformed, coeffs);</span>
        } else {
<span class="fc" id="L3844">            wt.calculateWithB3SplineScalingFunction2(input, transformed, coeffs);</span>
        }

        /*
            for (int i = 0; i &lt; coeffs.size(); ++i) {
                GreyscaleImage img = coeffs.get(i);
                String str = &quot;coeff_&quot; + Integer.toString(i) + &quot;_&quot; +
                    MiscDebug.getCurrentTimeFormatted();
                MiscDebug.writeImage(img, str);
            }
        */

<span class="fc" id="L3856">        GreyscaleImage coarsestCoeff = coeffs.get(coeffs.size() - 1);</span>

<span class="pc bpc" id="L3858" title="1 of 2 branches missed.">        int limit = use1D ? 2 : 1;</span>

<span class="fc bfc" id="L3860" title="All 2 branches covered.">        for (int i = 0; i &lt; coarsestCoeff.getNPixels(); ++i) {</span>
<span class="fc bfc" id="L3861" title="All 2 branches covered.">            if (coarsestCoeff.getValue(i) &gt; limit) {</span>
<span class="fc" id="L3862">                coarsestCoeff.setValue(i, 250);</span>
            } else {
<span class="fc" id="L3864">                coarsestCoeff.setValue(i, 0);</span>
            }
        }

<span class="fc" id="L3868">        return coarsestCoeff;</span>
    }

    /**
     * segmentation algorithm using Canny Edges.
     *
     * @param input
     * @return the segmented image holding values 0 or 250.
     */
    public GreyscaleImage createGreyscale6(GreyscaleImage input) {

<span class="nc" id="L3879">        CannyEdgeFilterAdaptive filter = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L3880">        filter.applyFilter(input.copyImage());</span>

<span class="nc" id="L3882">        OtsuThresholding ot = new OtsuThresholding();</span>
<span class="nc" id="L3883">        float otsuScaleFactor = 0.65f;//0.4f;</span>
<span class="nc" id="L3884">        double tHigh = otsuScaleFactor * ot.calculateBinaryThreshold256(</span>
<span class="nc" id="L3885">            filter.getFilterProducts().getGradientXY());</span>

<span class="nc" id="L3887">        double thresh = tHigh;</span>

<span class="nc" id="L3889">        GreyscaleImage img = filter.getFilterProducts().getGradientXY();</span>

<span class="nc bnc" id="L3891" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc bnc" id="L3892" title="All 2 branches missed.">            if (img.getValue(i) &gt; thresh) {</span>
<span class="nc" id="L3893">                img.setValue(i, 250);</span>
            } else {
<span class="nc" id="L3895">                img.setValue(i, 0);</span>
            }
        }

<span class="nc" id="L3899">        return img;</span>
    }

    /**
     * segmentation algorithm using cieXY and rgb to make segmentation for
     * the colors with CIE X or Y outside of the center region
     *
     * @param input
     * @return
     */
    public GreyscaleImage createGreyscale7(ImageExt input) {

<span class="nc" id="L3911">        Map&lt;PairInt, Integer&gt; pixelThetaDegreesMap = populatePixelLists3(input);</span>

        // -- scale the valus to between 0 and 255 w/ wrap around --

<span class="nc" id="L3915">        int count = 0;</span>
<span class="nc" id="L3916">        float[] clrPolarCIEXY =new float[pixelThetaDegreesMap.size()];</span>
<span class="nc bnc" id="L3917" title="All 2 branches missed.">        for (Entry&lt;PairInt, Integer&gt; entry : pixelThetaDegreesMap.entrySet()) {</span>
<span class="nc" id="L3918">            clrPolarCIEXY[count] = entry.getValue();</span>
<span class="nc" id="L3919">            count++;</span>
<span class="nc" id="L3920">        }</span>

<span class="nc" id="L3922">        float binWidth = 20;</span>
<span class="nc" id="L3923">        HistogramHolder hist = Histogram.createSimpleHistogram(binWidth,</span>
<span class="nc" id="L3924">            clrPolarCIEXY, Errors.populateYErrorsBySqrt(clrPolarCIEXY));</span>
<span class="nc" id="L3925">        List&lt;Integer&gt; indexes = MiscMath.findStrongPeakIndexesDescSort(hist, 0.1f);</span>
<span class="nc" id="L3926">        int[] binCenters = createBinCenters360(hist, indexes);</span>

<span class="nc" id="L3928">        List&lt;Set&lt;PairInt&gt;&gt; colorPixelGroups = assignToNearestPolarCIECluster(</span>
            pixelThetaDegreesMap, binCenters);

<span class="nc" id="L3931">        GreyscaleImage img = new GreyscaleImage(input.getWidth(),</span>
<span class="nc" id="L3932">            input.getHeight());</span>

<span class="nc" id="L3934">        int gClr = 255;</span>
<span class="nc" id="L3935">        int s = 127/colorPixelGroups.size();</span>
<span class="nc bnc" id="L3936" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : colorPixelGroups) {</span>
<span class="nc bnc" id="L3937" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L3938">               img.setValue(p.getX(), p.getY(), gClr);</span>
<span class="nc" id="L3939">            }</span>
<span class="nc" id="L3940">            gClr -= s;</span>
<span class="nc" id="L3941">        }</span>

<span class="nc" id="L3943">MiscDebug.writeImage(img, &quot;_seg_gs7_&quot; + MiscDebug.getCurrentTimeFormatted());</span>

<span class="nc" id="L3945">        return img;</span>
    }

    public GreyscaleImage createAWatershed(ImageExt input, String debugTag,
        int originalImageWidth, int originalImageHeight) {

<span class="nc" id="L3951">        int w = input.getWidth();</span>
<span class="nc" id="L3952">        int h = input.getHeight();</span>
<span class="nc" id="L3953">        GreyscaleImage aImg = new GreyscaleImage(w, h,</span>
            GreyscaleImage.Type.Bits32FullRangeInt);

<span class="nc bnc" id="L3956" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>

<span class="nc" id="L3958">            float[] lab = input.getCIELAB(i);</span>

<span class="nc" id="L3960">            aImg.setValue(i, Math.round(lab[1]));</span>

        }

<span class="nc" id="L3964">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="nc" id="L3966">        HistogramEqualization hEq = new HistogramEqualization(aImg);</span>
<span class="nc" id="L3967">        hEq.applyFilter();</span>

<span class="nc" id="L3969">        int minDimension = Math.min(originalImageWidth, originalImageHeight);</span>
        int lowerLimitSize;
<span class="nc bnc" id="L3971" title="All 2 branches missed.">        if (minDimension &gt; 900) {</span>
<span class="nc" id="L3972">            lowerLimitSize = 300;</span>
<span class="nc bnc" id="L3973" title="All 2 branches missed.">        } else if (minDimension &lt; 200) {</span>
<span class="nc" id="L3974">            lowerLimitSize = 100;</span>
        } else {
<span class="nc" id="L3976">            lowerLimitSize = 200;</span>
        }

<span class="nc" id="L3979">        imageProcessor.applyAdaptiveMeanThresholding(aImg, 1);</span>

<span class="nc" id="L3981">        GreyscaleImage ws = imageProcessor.makeWatershedFromAdaptiveMedian(aImg);</span>

<span class="nc" id="L3983">        return ws;</span>
    }

    /**
     * given the list of edges, populate the output arrays with color informaion
     * from the edge points and their 8 neighbor regions.
     * note that any points in more than one output list originally because of
     * being a junction, are corrected and placed in the most similar list.
     *
     * @param img
     * @param edges
     * @param junctions
     * @param outputPoints
     * @param outputDescripors access as [edgeListIndex][(h, s, v, nPix, cenX, cenY)]
     * @param clrSpace color space to fill the descriptors with: 0 is lab, 1 is hsv
     */
    private void populateEdgeLists(ImageExt img,
        List&lt;PairIntArray&gt; edges,
        List&lt;Set&lt;PairInt&gt;&gt; outputPoints, float[][] outputDescripors,
        int clrSpace) {

<span class="fc" id="L4004">        int w = img.getWidth();</span>
<span class="fc" id="L4005">        int h = img.getHeight();</span>

        // ----- gather edge points and their 8 neighbors into edge point sets ----

<span class="fc" id="L4009">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L4010">        int[] dys = Misc.dy8;</span>
<span class="fc bfc" id="L4011" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); ++i) {</span>
<span class="fc" id="L4012">            PairIntArray edge = edges.get(i);</span>
<span class="fc" id="L4013">            Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L4014" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="fc" id="L4015">                int x = edge.getX(j);</span>
<span class="fc" id="L4016">                int y = edge.getY(j);</span>
<span class="fc" id="L4017">                set.add(new PairInt(x, y));</span>
<span class="fc bfc" id="L4018" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L4019">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L4020">                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L4021" title="4 of 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || </span>
                        (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {
<span class="nc" id="L4023">                        continue;</span>
                    }
<span class="fc" id="L4025">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L4026">                    set.add(p2);</span>
                }
            }
<span class="fc" id="L4029">            outputPoints.add(set);</span>
        }

<span class="fc" id="L4032">        float n = img.getNPixels();</span>

        // ----- calculate descriptors of the color and location of the edge points -----

<span class="fc" id="L4036">        populateDescriptors(img, outputPoints, outputDescripors, clrSpace);</span>

        /*
        the descriptors are
             C_i = {h, s, v, nPix, cenX, cenY}  or labL, labA, labB for colorSpace = 0
        */

        // ======= correct for any points in more than one list ======

        // --- map the list indexes that a point is in --------
<span class="fc" id="L4046">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; pointIndexes = new HashMap&lt;PairInt, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L4048" title="All 2 branches covered.">        for (int i = 0; i &lt; outputPoints.size(); ++i) {</span>
<span class="fc" id="L4049">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L4050">            Set&lt;PairInt&gt; edgePoints = outputPoints.get(i);</span>
<span class="fc bfc" id="L4051" title="All 2 branches covered.">            for (PairInt p : edgePoints) {</span>
<span class="fc" id="L4052">                Set&lt;Integer&gt; indexes = pointIndexes.get(p);</span>
<span class="fc bfc" id="L4053" title="All 2 branches covered.">                if (indexes == null) {</span>
<span class="fc" id="L4054">                    indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L4055">                    pointIndexes.put(p, indexes);</span>
                }
<span class="fc" id="L4057">                indexes.add(key);</span>
<span class="fc" id="L4058">            }</span>
        }

<span class="fc" id="L4061">        CIEChromaticity cieC = new CIEChromaticity();</span>

        // ---- when a point is in more than one list, choose to keep it in the
        //      list with smallest difference from it in color and remove it from others.

<span class="fc bfc" id="L4066" title="All 2 branches covered.">        for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
<span class="fc" id="L4067">            Set&lt;Integer&gt; indexes = entry.getValue();</span>
<span class="fc bfc" id="L4068" title="All 2 branches covered.">            if (indexes.size() == 1) {</span>
<span class="fc" id="L4069">                continue;</span>
            }
<span class="fc" id="L4071">            PairInt p = entry.getKey();</span>
<span class="fc" id="L4072">            int x = p.getX();</span>
<span class="fc" id="L4073">            int y = p.getY();</span>
            float c1, c2, c3;
<span class="pc bpc" id="L4075" title="1 of 2 branches missed.">            if (clrSpace == 0) {</span>
<span class="fc" id="L4076">                float[] lab = img.getCIELAB(x, y);</span>
<span class="fc" id="L4077">                c1 = lab[0];</span>
<span class="fc" id="L4078">                c2 = lab[1];</span>
<span class="fc" id="L4079">                c3 = lab[2];</span>
<span class="fc" id="L4080">            } else {</span>
                // hsv
<span class="nc" id="L4082">                c1 = img.getHue(x, y);</span>
<span class="nc" id="L4083">                c2 = img.getSaturation(x, y);</span>
<span class="nc" id="L4084">                c3 = img.getBrightness(x, y);</span>
            }
<span class="fc" id="L4086">            double minColorDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L4087">            Integer minColorDiffIndex = null;</span>
<span class="fc bfc" id="L4088" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
                //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L4090">                float[] desc = outputDescripors[index.intValue()];</span>
                double diff;
<span class="pc bpc" id="L4092" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L4093">                    diff = Math.abs(cieC.calcDeltaECIE2000(c1, c2, c3,</span>
                        desc[0], desc[1], desc[2]));
                } else {
<span class="nc" id="L4096">                    double diff1 = c1 - desc[0];</span>
<span class="nc" id="L4097">                    double diff2 = c2 - desc[1];</span>
<span class="nc" id="L4098">                    double diff3 = c3 - desc[2];</span>
<span class="nc" id="L4099">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }
<span class="fc bfc" id="L4101" title="All 2 branches covered.">                if (diff &lt; minColorDiff) {</span>
<span class="fc" id="L4102">                    minColorDiff = diff;</span>
<span class="fc" id="L4103">                    minColorDiffIndex = index;</span>
                }
<span class="fc" id="L4105">            }</span>
<span class="pc bpc" id="L4106" title="3 of 4 branches missed.">            assert(minColorDiffIndex != null);</span>

            // update the lists to remove point
<span class="fc bfc" id="L4109" title="All 2 branches covered.">            for (Integer index : indexes) {</span>
<span class="fc bfc" id="L4110" title="All 2 branches covered.">                if (index.equals(minColorDiffIndex)) {</span>
<span class="fc" id="L4111">                    continue;</span>
                }

<span class="fc" id="L4114">                Set&lt;PairInt&gt; set = outputPoints.get(index.intValue());</span>
<span class="fc" id="L4115">                float nBefore = set.size();</span>
<span class="fc" id="L4116">                set.remove(p);</span>
<span class="fc" id="L4117">                float nAfter = set.size();</span>

                ////C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L4120">                float[] desc = outputDescripors[index.intValue()];</span>
<span class="fc" id="L4121">                desc[0] = ((desc[0] * nBefore) - c1)/nAfter;</span>
<span class="fc" id="L4122">                desc[1] = ((desc[1] * nBefore) - c2)/nAfter;</span>
<span class="fc" id="L4123">                desc[2] = ((desc[2] * nBefore) - c3)/nAfter;</span>
<span class="fc" id="L4124">                desc[3] = nAfter;</span>
<span class="fc" id="L4125">                desc[4] = ((desc[4] * nBefore) - x)/nAfter;</span>
<span class="fc" id="L4126">                desc[5] = ((desc[5] * nBefore) - y)/nAfter;</span>
<span class="fc" id="L4127">            }</span>
<span class="fc" id="L4128">        }</span>
<span class="fc" id="L4129">    }</span>

     /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf
     *
     * NOTE: parameters in this algorithm are sensitive to
     * the PSF.
     *
     * NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     *
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        String debugTag) {
        
        // 0 is CIE LAB, 1 is HSV
<span class="fc" id="L4153">        final int clrSpace = 0;</span>

<span class="fc" id="L4155">        boolean reduceNoise = false;</span>

        double tColor;
        int tLen;
        double tR;
        double tSmallMerge;
        if (clrSpace == 0) {
            // JND for deltaE is ~2.3, so tColor must be that or larger
<span class="fc" id="L4163">            tColor = 2.8;//4.0;//5.5;</span>
<span class="fc" id="L4164">            tR = 0.8;//1.0;</span>
<span class="fc" id="L4165">            tLen = 1;</span>
<span class="fc" id="L4166">            tSmallMerge = 0.02;//0.095;</span>
        } else {
            // what is JND for HSV (a.k.a. HSB) ?  each range of values is 0:1
            tColor =  0.125;//0.125;  between 0.1 and 0.175
            tR = 1.5;
            tLen = 5;
            tSmallMerge = 0.02;
        }

<span class="fc" id="L4175">        return createColorEdgeSegmentation(input, clrSpace, tLen, tColor, tR,</span>
            reduceNoise, tSmallMerge, debugTag);
    }

    public List&lt;PairIntArray&gt; extractEdges(Image img,
        boolean reduceNoise, String debugTag) {

<span class="nc bnc" id="L4182" title="All 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L4183">            debugTag = &quot;&quot;;</span>
        }

<span class="nc" id="L4186">        GreyscaleImage gsImg = img.copyBlueToGreyscale();</span>

<span class="nc" id="L4188">        PhaseCongruencyDetector phaseDetector = new PhaseCongruencyDetector();</span>
<span class="nc bnc" id="L4189" title="All 2 branches missed.">        if (reduceNoise) {</span>
<span class="nc" id="L4190">            phaseDetector.setK(5);</span>
        } else {
<span class="nc" id="L4192">            phaseDetector.setK(2);</span>
        }
<span class="nc" id="L4194">        PhaseCongruencyDetector.PhaseCongruencyProducts products =</span>
<span class="nc" id="L4195">            phaseDetector.phaseCongMono(gsImg);</span>

        // thinned is in row major format
<span class="nc" id="L4198">        int[][] thinned = products.getThinned();</span>
        {
<span class="nc" id="L4200">            GreyscaleImage out2 = gsImg.createWithDimensions();</span>
<span class="nc bnc" id="L4201" title="All 2 branches missed.">            for (int i = 0; i &lt; thinned.length; ++i) {</span>
<span class="nc bnc" id="L4202" title="All 2 branches missed.">                for (int j = 0; j &lt; thinned[i].length; ++j) {</span>
<span class="nc bnc" id="L4203" title="All 2 branches missed.">                    if (thinned[i][j] &gt; 0) {</span>
<span class="nc" id="L4204">                        out2.setValue(j, i, 255);</span>
                    }
                }
            }
<span class="nc" id="L4208">            MiscDebug.writeImage(out2, &quot;_EDGES_grey_&quot; + debugTag);</span>
        }

<span class="nc" id="L4211">        EdgeExtractorSimple extractor = new EdgeExtractorSimple(thinned);</span>
<span class="nc" id="L4212">        extractor.extractEdges();</span>
<span class="nc" id="L4213">        List&lt;PairIntArray&gt; edges = new ArrayList&lt;PairIntArray&gt;();</span>
        // put in framework of images
<span class="nc bnc" id="L4215" title="All 2 branches missed.">        for (int i = 0; i &lt; extractor.getEdges().size(); ++i) {</span>
<span class="nc" id="L4216">            PairIntArray edge = extractor.getEdges().get(i).copy();</span>
<span class="nc bnc" id="L4217" title="All 2 branches missed.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="nc" id="L4218">                int x = edge.getX(j);</span>
<span class="nc" id="L4219">                int y = edge.getY(j);</span>
<span class="nc" id="L4220">                edge.set(j, y, x);</span>
            }
<span class="nc" id="L4222">            edges.add(edge);</span>
        }

<span class="nc" id="L4225">        return edges;</span>
    }
    
    public List&lt;PairIntArray&gt; extractEdges2(Image img,
        String debugTag) {

<span class="pc bpc" id="L4231" title="1 of 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L4232">            debugTag = &quot;&quot;;</span>
        }

<span class="fc" id="L4235">        CannyEdgeFilterAdaptiveDeltaE2000 canny = </span>
            new CannyEdgeFilterAdaptiveDeltaE2000();
<span class="fc" id="L4237">        canny.applyFilter(img.copyToImageExt());</span>

<span class="fc" id="L4239">        GreyscaleImage gXY = canny.getFilterProducts().getGradientXY();</span>
        
<span class="fc" id="L4241">        int w = gXY.getWidth();</span>
<span class="fc" id="L4242">        int h = gXY.getHeight();</span>
        
<span class="pc bpc" id="L4244" title="3 of 4 branches missed.">        assert(img.getWidth() == w);</span>
<span class="pc bpc" id="L4245" title="3 of 4 branches missed.">        assert(img.getHeight() == h);</span>
        
<span class="fc" id="L4247">        int[][] thinned = new int[w][];</span>
<span class="fc bfc" id="L4248" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L4249">            thinned[i] = new int[h];</span>
<span class="fc bfc" id="L4250" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L4251">                thinned[i][j] = gXY.getValue(i, j);</span>
            }
        }

<span class="fc" id="L4255">        EdgeExtractorSimple extractor = new EdgeExtractorSimple(thinned);</span>
<span class="fc" id="L4256">        extractor.extractEdges();</span>
<span class="fc" id="L4257">        List&lt;PairIntArray&gt; edges = new ArrayList&lt;PairIntArray&gt;();</span>
        // put in framework of images
<span class="fc bfc" id="L4259" title="All 2 branches covered.">        for (int i = 0; i &lt; extractor.getEdges().size(); ++i) {</span>
<span class="fc" id="L4260">            PairIntArray edge = extractor.getEdges().get(i).copy();</span>
<span class="fc bfc" id="L4261" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="fc" id="L4262">                int x = edge.getX(j);</span>
<span class="fc" id="L4263">                int y = edge.getY(j);</span>
<span class="fc" id="L4264">                edge.set(j, x, y);</span>
            }
<span class="fc" id="L4266">            edges.add(edge);</span>
        }

<span class="fc" id="L4269">        return edges;</span>
    }

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf

     NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     * 
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        int clrSpace, int tLen, double tColor, double tR, boolean reduceNoise,
        double tSmallMerge, String debugTag) {

<span class="fc" id="L4291">        List&lt;PairIntArray&gt; edges = extractEdges2(input, debugTag);</span>

        //List&lt;PairIntArray&gt; edges = extractEdges(input, reduceNoise, debugTag);
        
<span class="fc" id="L4295">        return createColorEdgeSegmentation(input, edges,</span>
            clrSpace, tLen, tColor, tR, reduceNoise, tSmallMerge, debugTag);
    }

    /**
     * create segmented image by creating edges with phase congruence,
     * then using the edge color properties to form clusters and seeds
     * of regions to grow, then using color histograms to further merge
     * regions.
     * The algorithm follows the general outline given by
     * Jie and Peng-fei 2003, &quot;Natural Color Image Segmentation&quot;,
       http://www-labs.iro.umontreal.ca/~mignotte/IFT6150/Articles/TRASH/ARTICLES_2010/cr1231.pdf

     NOTE: this implementation doesn't reproduce their results as
     * precisely so needs some improvements.
     * 
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; createColorEdgeSegmentation(ImageExt input,
        List&lt;PairIntArray&gt; edges,
        int clrSpace, int tLen, double tColor, double tR, boolean reduceNoise,
        double tSmallMerge, String debugTag) {

<span class="fc" id="L4319">        boolean doPlot = false;</span>

<span class="pc bpc" id="L4321" title="1 of 2 branches missed.">        if (debugTag == null) {</span>
<span class="nc" id="L4322">            debugTag = &quot;&quot;;</span>
        }

<span class="fc" id="L4325">        final int w = input.getWidth();</span>
<span class="fc" id="L4326">        final int h = input.getHeight();</span>
<span class="fc" id="L4327">        final int nPix = input.getNPixels();</span>

<span class="fc" id="L4329">        int nEdges = edges.size();</span>
<span class="fc" id="L4330">        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="pc bpc" id="L4332" title="1 of 2 branches missed.">        if (nEdges == 0) {</span>
            // add all picels to one set
<span class="nc" id="L4334">             Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L4335" title="All 2 branches missed.">            for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L4336" title="All 2 branches missed.">                for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L4337">                    set.add(new PairInt(i, j));</span>
                }
            }
<span class="nc" id="L4340">            clusterPoints.add(set);</span>
<span class="nc" id="L4341">            return clusterPoints;</span>
        }

<span class="fc" id="L4344">        float[][] clusterDescriptors = new float[nEdges][];</span>

<span class="fc" id="L4346">        populateEdgeLists(input, edges, clusterPoints, clusterDescriptors,</span>
            clrSpace);

<span class="pc bpc" id="L4349" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L4351">        List&lt;Integer&gt; longEdgeIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L4352">        List&lt;Integer&gt; shortEdgeIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L4353">        populateEdgeLengthLists(clusterDescriptors, tLen, longEdgeIndexes,</span>
            shortEdgeIndexes);

<span class="pc bpc" id="L4356" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

        // ----------- merge long edges ----------

        // NOTE that the moved sets modify the data structures :
        //    clusterPoints may contain empty items
        //    clusterDescriptors may contain null items
        //    both clusterPoints and clusterDescriptor non- null and non empty
        //       items are updated for merges

        // the authors consider this algorithm of min-heap merging within a
        // radius of color, a kmeans method as it updates the descriptors upon
        // each merge, but the minimum distance ordering is an improvement over
        // standard kmeans if one can use it as one can here
        // (pairs results in outer loop iteration of approx O(N^2),
        // specifically (N*(N-1)/2)), while kmeans ordering by index uses O(N))
<span class="fc" id="L4372">        mergeEdges(clusterPoints, clusterDescriptors, clrSpace, tColor,</span>
            longEdgeIndexes);

        //TODO: consider a number limit to use an alternate here when
        //  n edges is a large number.  determine a fixed k and use kmeans.
        //  can roughly determine a fixed k from
        //  a color histogram with bin size being color tolerance
        //  and counting the number of peaks.

<span class="pc bpc" id="L4381" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L4383" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L4385">            List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L4386" title="All 2 branches missed.">            for (Integer index : longEdgeIndexes) {</span>
<span class="nc" id="L4387">                Set&lt;PairInt&gt; set = clusterPoints.get(index.intValue());</span>
<span class="nc bnc" id="L4388" title="All 2 branches missed.">                if (!set.isEmpty()) {</span>
<span class="nc" id="L4389">                    tmp.add(set);</span>
                }
<span class="nc" id="L4391">            }</span>
<span class="nc" id="L4392">            int nExtraForDot = 1;</span>
<span class="nc" id="L4393">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L4394">            ImageIOHelper.addAlternatingColorPointSetsToImage(tmp, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L4396">            MiscDebug.writeImage(img2, &quot;_longEdges_merged_&quot; +  debugTag + &quot;_&quot;</span>
                + clrSpace);
        }

        // ---- merge short edges (which are usually textures) ------

<span class="fc" id="L4402">        mergeShortEdges(clusterPoints, clusterDescriptors, clrSpace, tColor,</span>
            shortEdgeIndexes);

<span class="pc bpc" id="L4405" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L4407" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L4409">            List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L4410" title="All 2 branches missed.">            for (Integer index : shortEdgeIndexes) {</span>
<span class="nc" id="L4411">                Set&lt;PairInt&gt; set = clusterPoints.get(index.intValue());</span>
<span class="nc bnc" id="L4412" title="All 2 branches missed.">                if (!set.isEmpty()) {</span>
<span class="nc" id="L4413">                    tmp.add(set);</span>
                }
<span class="nc" id="L4415">            }</span>
<span class="nc" id="L4416">            int nExtraForDot = 1;</span>
<span class="nc" id="L4417">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L4418">            ImageIOHelper.addAlternatingColorPointSetsToImage(tmp, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L4420">            MiscDebug.writeImage(img2, &quot;_shortedges_merged_&quot; +  debugTag +</span>
                &quot;_&quot; + clrSpace);
        }

<span class="pc bpc" id="L4424" title="3 of 4 branches missed.">        assert(assertDescriptorCounts(clusterPoints, clusterDescriptors));</span>

<span class="fc" id="L4426">        Map&lt;PairInt, Integer&gt; pointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="fc bfc" id="L4427" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L4428">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L4429">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L4430" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L4431">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L4432">            }</span>
        }

        // ------ region growing -------
<span class="fc" id="L4436">        growEdges(input, clusterPoints, clusterDescriptors, pointIndexMap,</span>
            clrSpace, tColor, shortEdgeIndexes, longEdgeIndexes);

<span class="pc bpc" id="L4439" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L4441">        longEdgeIndexes = null;</span>
<span class="fc" id="L4442">        shortEdgeIndexes = null;</span>

<span class="pc bpc" id="L4444" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L4446">            int nExtraForDot = 1;</span>
<span class="nc" id="L4447">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L4448">            ImageIOHelper.addAlternatingColorPointSetsToImage(clusterPoints, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L4450">            MiscDebug.writeImage(img2, &quot;_after_rgo_&quot; +  debugTag + &quot;_&quot; + clrSpace);</span>
        }

        // ------ merge by color histograms ------

<span class="fc" id="L4455">        clusterDescriptors = condenseAndUpdate(clusterPoints,</span>
            clusterDescriptors, pointIndexMap);

<span class="pc bpc" id="L4458" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L4460">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap = createAdjacencyMap(</span>
            clusterPoints);

<span class="fc" id="L4463">        mergeByColorHistograms(input, clusterPoints, adjacencyMap,</span>
            clrSpace, tR);

<span class="pc bpc" id="L4466" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="pc bpc" id="L4468" title="1 of 2 branches missed.">        if (doPlot) {</span>
            // DEBUG
<span class="nc" id="L4470">            int nExtraForDot = 1;</span>
<span class="nc" id="L4471">            Image img2 = input.copyImage().copyToGreyscale().copyToColorGreyscale();</span>
<span class="nc" id="L4472">            ImageIOHelper.addAlternatingColorPointSetsToImage(clusterPoints, 0, 0,</span>
                nExtraForDot, img2);
<span class="nc" id="L4474">            MiscDebug.writeImage(img2, &quot;_FINAL_&quot; +  debugTag + &quot;_&quot; + clrSpace);</span>
        }

        // ----- merge smallest clusters into adjacent larger --------
<span class="fc" id="L4478">        int tNumber = (int)Math.round(tSmallMerge * nPix);</span>

<span class="fc" id="L4480">        clusterDescriptors = condenseAndUpdate(clusterPoints,</span>
            clusterDescriptors, pointIndexMap);

<span class="pc bpc" id="L4483" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L4485">        mergeSmallClusters(input, clusterPoints, clusterDescriptors,</span>
            clrSpace, tNumber, debugTag);

<span class="pc bpc" id="L4488" title="3 of 4 branches missed.">        assert(clusterPoints.size() == clusterDescriptors.length);</span>

<span class="fc" id="L4490">        return clusterPoints;</span>
    }

    private void populateEdgeLengthLists(float[][] clusterDescriptors,
        int tLen, List&lt;Integer&gt; longEdgeIndexes,
        List&lt;Integer&gt; shortEdgeIndexes) {

        //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc bfc" id="L4498" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterDescriptors.length; ++i) {</span>
<span class="fc" id="L4499">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L4500">            float nPix = clusterDescriptors[i][3];</span>
<span class="pc bpc" id="L4501" title="1 of 2 branches missed.">            if (nPix &lt; tLen) {</span>
<span class="nc" id="L4502">                shortEdgeIndexes.add(key);</span>
            } else {
<span class="fc" id="L4504">                longEdgeIndexes.add(key);</span>
            }
        }
<span class="fc" id="L4507">    }</span>

    private void populateColorDiffHeap(
        float[][] clusterDescriptors, int clrSpace,
        List&lt;Integer&gt; longEdgeIndexes, Heap longEdgesHeap,
        long heapKeyFactor, Map&lt;PairInt, HeapNode&gt; pairEdgePindexNodes) {

        // for heap nodes:
        //     key is the difference in color times a factor to use long instead of double
        //     data is the PairInt holding the indexes compared

<span class="fc" id="L4518">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc bfc" id="L4520" title="All 2 branches covered.">        for (int i = 0; i &lt; longEdgeIndexes.size(); ++i) {</span>

<span class="fc" id="L4522">            int idx1 = longEdgeIndexes.get(i).intValue();</span>
<span class="fc" id="L4523">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="fc bfc" id="L4525" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; longEdgeIndexes.size(); ++j) {</span>

<span class="fc" id="L4527">                int idx2 = longEdgeIndexes.get(j).intValue();</span>
<span class="fc" id="L4528">                float[] desc2 = clusterDescriptors[idx2];</span>

                double diff;
<span class="pc bpc" id="L4531" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L4532">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L4536">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L4537">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L4538">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L4539">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

                // note that idx1 is always smaller than idx2
<span class="fc" id="L4543">                PairInt p12 = new PairInt(idx1, idx2);</span>

<span class="fc" id="L4545">                long heapKey = (long)((double)heapKeyFactor * diff);</span>
<span class="fc" id="L4546">                HeapNode node = new HeapNode(heapKey);</span>
<span class="fc" id="L4547">                node.setData(p12);</span>

<span class="fc" id="L4549">                longEdgesHeap.insert(node);</span>

<span class="fc" id="L4551">                pairEdgePindexNodes.put(p12, node);</span>
            }
        }
<span class="fc" id="L4554">    }</span>

    /**
     *
     * @param input
     * @param debugLabel if null, no debug output is made, else output uses debugLabel
     * as suffix in file names
     */
    public void extractObjectEdges(ImageExt input, String debugLabel,
        int originalImageWidth, int originalImageHeight) {

<span class="nc" id="L4565">        int w = input.getWidth();</span>
<span class="nc" id="L4566">        int h = input.getHeight();</span>

<span class="nc" id="L4568">        GreyscaleImage o1 = new GreyscaleImage(w, h,</span>
            GreyscaleImage.Type.Bits32FullRangeInt);
<span class="nc" id="L4570">        GreyscaleImage o2 = o1.createFullRangeIntWithDimensions();</span>
<span class="nc" id="L4571">        GreyscaleImage o3 = o1.createFullRangeIntWithDimensions();</span>
<span class="nc" id="L4572">        GreyscaleImage aImg = o1.createFullRangeIntWithDimensions();</span>
<span class="nc" id="L4573">        GreyscaleImage bImg = o1.createFullRangeIntWithDimensions();</span>
<span class="nc" id="L4574">        GreyscaleImage hueAngleImg = o1.createFullRangeIntWithDimensions();</span>
<span class="nc" id="L4575">        GreyscaleImage cieXYAngleImg = o1.createFullRangeIntWithDimensions();</span>

<span class="nc bnc" id="L4577" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getNPixels(); ++i) {</span>
<span class="nc" id="L4578">            int r = input.getR(i);</span>
<span class="nc" id="L4579">            int g = input.getG(i);</span>
<span class="nc" id="L4580">            int b = input.getB(i);</span>
<span class="nc" id="L4581">            float[] lab = input.getCIELAB(i);</span>
<span class="nc" id="L4582">            o1.setValue(i, (int)Math.round((double)(r - g)/Math.sqrt(2)));</span>
<span class="nc" id="L4583">            o2.setValue(i, (int)Math.round((double)(r + g - 2*b)/Math.sqrt(6)));</span>
<span class="nc" id="L4584">            o3.setValue(i, (int)Math.round((double)(r + g + b)/Math.sqrt(2)));</span>
<span class="nc" id="L4585">            aImg.setValue(i, Math.round(lab[1]));</span>
<span class="nc" id="L4586">            bImg.setValue(i, Math.round(lab[2]));</span>

            float ha;
<span class="nc bnc" id="L4589" title="All 2 branches missed.">            if (lab[1] == 0) {</span>
<span class="nc" id="L4590">                ha = 0;</span>
            } else {
<span class="nc" id="L4592">                ha = (float)(Math.atan2(lab[2], lab[1]) * 180. / Math.PI);</span>
<span class="nc bnc" id="L4593" title="All 2 branches missed.">                if (ha &lt; 0) {</span>
<span class="nc" id="L4594">                    ha += 360.;</span>
                }
            }

<span class="nc" id="L4598">            hueAngleImg.setValue(i, Math.round(ha));</span>

            //TODO: replace w/ cached method
<span class="nc" id="L4601">            float[] cieXY = input.getCIEXY_(i);</span>

<span class="nc" id="L4603">            float cieXYAngle = (float)(Math.atan2(cieXY[1], cieXY[0]) * 180. / Math.PI);</span>
<span class="nc bnc" id="L4604" title="All 2 branches missed.">            if (cieXYAngle &lt; 0) {</span>
<span class="nc" id="L4605">                cieXYAngle += 360.;</span>
            }
<span class="nc" id="L4607">            cieXYAngleImg.setValue(i, Math.round(cieXYAngle));</span>
        }

<span class="nc" id="L4610">        HistogramEqualization hEq = new HistogramEqualization(aImg);</span>
<span class="nc" id="L4611">        hEq.applyFilter();</span>
<span class="nc" id="L4612">        hEq = new HistogramEqualization(bImg);</span>
<span class="nc" id="L4613">        hEq.applyFilter();</span>
<span class="nc" id="L4614">        hEq = new HistogramEqualization(hueAngleImg);</span>
<span class="nc" id="L4615">        hEq.applyFilter();</span>
<span class="nc" id="L4616">        hEq = new HistogramEqualization(cieXYAngleImg);</span>
<span class="nc" id="L4617">        hEq.applyFilter();</span>
<span class="nc" id="L4618">        hEq = new HistogramEqualization(o1);</span>
<span class="nc" id="L4619">        hEq.applyFilter();</span>
<span class="nc" id="L4620">        hEq = new HistogramEqualization(o1);</span>
<span class="nc" id="L4621">        hEq.applyFilter();</span>
<span class="nc" id="L4622">        hEq = new HistogramEqualization(o3);</span>
<span class="nc" id="L4623">        hEq.applyFilter();</span>
<span class="nc bnc" id="L4624" title="All 4 branches missed.">        if (debugLabel != null &amp;&amp; !debugLabel.equals(&quot;&quot;)) {</span>
<span class="nc" id="L4625">            MiscDebug.writeImage(o1, &quot;_o1_&quot; + debugLabel);</span>
<span class="nc" id="L4626">            MiscDebug.writeImage(o2, &quot;_o2_&quot; + debugLabel);</span>
<span class="nc" id="L4627">            MiscDebug.writeImage(o3, &quot;_o3_&quot; + debugLabel);</span>
<span class="nc" id="L4628">            MiscDebug.writeImage(aImg, &quot;_a_&quot; + debugLabel);</span>
<span class="nc" id="L4629">            MiscDebug.writeImage(bImg, &quot;_b_&quot; + debugLabel);</span>
<span class="nc" id="L4630">            MiscDebug.writeImage(hueAngleImg, &quot;_ha_&quot; + debugLabel);</span>
<span class="nc" id="L4631">            MiscDebug.writeImage(cieXYAngleImg, &quot;_ciexya_&quot; + debugLabel);</span>
        }

<span class="nc" id="L4634">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="nc" id="L4636">        imageProcessor.applyAdaptiveMeanThresholding(o1, 1);</span>
<span class="nc" id="L4637">        imageProcessor.applyAdaptiveMeanThresholding(o2, 1);</span>
<span class="nc" id="L4638">        imageProcessor.applyAdaptiveMeanThresholding(o3, 1);</span>

<span class="nc bnc" id="L4640" title="All 4 branches missed.">        if (debugLabel != null &amp;&amp; !debugLabel.equals(&quot;&quot;)) {</span>
<span class="nc" id="L4641">            MiscDebug.writeImage(o1, &quot;_o1_adaptive_median_&quot; + debugLabel);</span>
<span class="nc" id="L4642">            MiscDebug.writeImage(o2, &quot;_o2_adaptive_median_&quot; + debugLabel);</span>
<span class="nc" id="L4643">            MiscDebug.writeImage(o3, &quot;_o3_adaptive_median_&quot; + debugLabel);</span>
        }

        /*
        imageProcessor.applyAdaptiveMeanThresholding(aImg, 1);
        if (debugLabel != null &amp;&amp; !debugLabel.equals(&quot;&quot;)) {
            MiscDebug.writeImage(aImg, &quot;_a_adaptive_median_&quot; + debugLabel);
        }*/

        //TODO: revise for minimum size of contiguous pixels.
        // it should be dependent upon image resolution, that is PSF and the focal distance of objects
        // (the number of beams, that is psf diameters, across the object),
        // but the number of pixels as image size is all the information available.
<span class="nc" id="L4656">        int minDimension = Math.min(originalImageWidth, originalImageHeight);</span>
        int lowerLimitSize;
<span class="nc bnc" id="L4658" title="All 2 branches missed.">        if (minDimension &gt; 900) {</span>
<span class="nc" id="L4659">            lowerLimitSize = 300;</span>
<span class="nc bnc" id="L4660" title="All 2 branches missed.">        } else if (minDimension &lt; 200) {</span>
<span class="nc" id="L4661">            lowerLimitSize = 100;</span>
        } else {
<span class="nc" id="L4663">            lowerLimitSize = 200;</span>
        }

        //List&lt;Set&lt;PairInt&gt;&gt; maskList = imageProcessor.extractConnectedComponents(
        //    labelled, lowerLimitSize);

<span class="nc" id="L4669">        imageProcessor.applyAdaptiveMeanThresholding(aImg, 1);</span>

<span class="nc" id="L4671">        GreyscaleImage aWSImg = imageProcessor.makeWatershedFromAdaptiveMedian(</span>
            aImg);

<span class="nc" id="L4674">        CannyEdgeFilterAdaptive filter = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L4675">        filter.applyFilter(input.copyToGreyscale());</span>
<span class="nc" id="L4676">        EdgeFilterProducts ep = filter.getFilterProducts();</span>
<span class="nc" id="L4677">        MiscDebug.writeImage(ep.getGradientXY(), &quot;_edges_&quot; + debugLabel);</span>
<span class="nc" id="L4678">    }</span>

    protected Map&lt;PairInt, Float&gt; createPolarCIEXYMap(ImageExt input,
        Set&lt;PairInt&gt; points) {

<span class="nc" id="L4683">        Map&lt;PairInt, Float&gt; thetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

        //TODO: remove imgCp when finished debugging
        //ImageExt imgCp = input.copyToImageExt();
<span class="nc" id="L4687">        int w = input.getWidth();</span>
<span class="nc" id="L4688">        int h = input.getHeight();</span>

<span class="nc" id="L4690">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L4692">        double thetaFactor = 255./360.;</span>

        // to set the non member colors, need to traverse all pixels.
<span class="nc bnc" id="L4695" title="All 2 branches missed.">        for (int col = 0; col &lt; w; ++col) {</span>
<span class="nc bnc" id="L4696" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>
<span class="nc" id="L4697">                PairInt p = new PairInt(col, row);</span>
<span class="nc bnc" id="L4698" title="All 2 branches missed.">                if (points.contains(p)) {</span>
<span class="nc" id="L4699">                    float cieX = input.getCIEX(col, row);</span>
<span class="nc" id="L4700">                    float cieY = input.getCIEY(col, row);</span>
<span class="nc" id="L4701">                    double thetaDegrees = cieC.calculateXYTheta(cieX, cieY) * 180. / Math.PI;</span>
<span class="nc" id="L4702">                    double theta = thetaFactor * thetaDegrees;</span>
          //          int thetaCIEXY = (int)Math.round(theta);
                    //          imgCp.setRGB(col, row, thetaCIEXY, thetaCIEXY, thetaCIEXY);

<span class="nc" id="L4706">                    thetaMap.put(p, Float.valueOf((float) theta));</span>
                } else {
                    //         imgCp.setRGB(col, row, 0, 255, 0);
                }
            }
        }

        //MiscDebug.writeImage(imgCp, &quot;polarciexy_&quot; + MiscDebug.getCurrentTimeFormatted());

<span class="nc" id="L4715">        return thetaMap;</span>
    }

    private Map&lt;PairInt, Integer&gt; populatePixelLists3(ImageExt input) {

<span class="nc" id="L4720">        int w = input.getWidth();</span>
<span class="nc" id="L4721">        int h = input.getHeight();</span>

<span class="nc" id="L4723">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L4725">        Map&lt;PairInt, Integer&gt; pixelCIETheta = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc bnc" id="L4727" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L4728" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="nc" id="L4730">                int idx = input.getInternalIndex(i, j);</span>

<span class="nc" id="L4732">                float cieX = input.getCIEX(idx);</span>
<span class="nc" id="L4733">                float cieY = input.getCIEY(idx);</span>

<span class="nc bnc" id="L4735" title="All 2 branches missed.">                if (!cieC.isInLargeWhiteCenter(cieX, cieY) /*&amp;&amp; !veryGreen*/) {</span>

<span class="nc" id="L4737">                    double thetaRadians = cieC.calculateXYTheta(cieX, cieY);</span>

<span class="nc" id="L4739">                    double thetaDegrees = thetaRadians * 180./Math.PI;</span>

<span class="nc" id="L4741">                    int thetaDegreesInt = (int)Math.round(thetaDegrees);</span>

<span class="nc" id="L4743">                    pixelCIETheta.put(new PairInt(i, j), thetaDegreesInt);</span>
                }
            }
        }

<span class="nc" id="L4748">        return pixelCIETheta;</span>
    }

    public void createContrastImages(ImageExt input) {

<span class="nc" id="L4753">        int n = input.getNPixels();</span>
<span class="nc" id="L4754">        double[] luma = new double[n];</span>
<span class="nc bnc" id="L4755" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L4756">            int r = input.getR(i);</span>
<span class="nc" id="L4757">            int g = input.getG(i);</span>
<span class="nc" id="L4758">            int b = input.getB(i);</span>
<span class="nc" id="L4759">            double lumaI = (0.256*r) - (-0.148*g) + (0.439*b);</span>
<span class="nc" id="L4760">            luma[i] = lumaI;</span>
        }

        // create contrast as (avgLuma - luma[i])/luma[i]
<span class="nc" id="L4764">        GreyscaleImage lumaAvg = new GreyscaleImage(input.getWidth(), input.getHeight());</span>
<span class="nc bnc" id="L4765" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L4766">            lumaAvg.setValue(i, (int)Math.round(luma[i]));</span>
        }

        // range of luma is 0 to 215.  adding 1 to avoid divide by zero
<span class="nc" id="L4770">        double[] contrast = new double[n];</span>
<span class="nc" id="L4771">        MedianSmooth medSmooth = new MedianSmooth();</span>
<span class="nc" id="L4772">        lumaAvg = medSmooth.calculate(lumaAvg, 2, 2);</span>
        //ImageProcessor imageProcessor = new ImageProcessor();
        //imageProcessor.applyAdaptiveMeanThresholding(lumaAvg, 1);
        //medSmooth.calculate(lumaAvg, 1, 1);
        //medSmooth.calculate(lumaAvg, 1, 1);
<span class="nc bnc" id="L4777" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L4778">            int vAvg = lumaAvg.getValue(i);</span>
<span class="nc" id="L4779">            double vI = luma[i] + 1;</span>
<span class="nc" id="L4780">            contrast[i] = ((double)vAvg - vI)/vI;</span>
        }
<span class="nc" id="L4782">        int[] contrastInt = MiscMath.rescale(contrast, 0, 255);</span>

<span class="nc" id="L4784">        double[] blueDivContrast = new double[n];</span>
<span class="nc" id="L4785">        double[] redDivContrast = new double[n];</span>

<span class="nc bnc" id="L4787" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L4788">            int r = input.getR(i);</span>
            //int g = input.getG(i);
<span class="nc" id="L4790">            int b = input.getB(i);</span>
<span class="nc" id="L4791">            double c = contrastInt[i] + 1; // plus 1 to void divide by zero</span>
<span class="nc" id="L4792">            blueDivContrast[i] = (double)b/c;</span>
<span class="nc" id="L4793">            redDivContrast[i] = (double)r/c;</span>
        }

        // rescale to be between 0 and 255

<span class="nc" id="L4798">        int[] blueDivContrastInt = MiscMath.rescale(blueDivContrast, 0, 255);</span>
<span class="nc" id="L4799">        int[] redDivContrastInt = MiscMath.rescale(redDivContrast, 0, 255);</span>

<span class="nc" id="L4801">        GreyscaleImage contrastImg = new GreyscaleImage(input.getWidth(), input.getHeight());</span>
<span class="nc" id="L4802">        GreyscaleImage blueDivContrastImg = new GreyscaleImage(input.getWidth(), input.getHeight());</span>
<span class="nc" id="L4803">        GreyscaleImage redDivContrastImg = new GreyscaleImage(input.getWidth(), input.getHeight());</span>

<span class="nc bnc" id="L4805" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L4806">            contrastImg.setValue(i, contrastInt[i]);</span>
<span class="nc" id="L4807">            blueDivContrastImg.setValue(i, blueDivContrastInt[i]);</span>
<span class="nc" id="L4808">            redDivContrastImg.setValue(i, redDivContrastInt[i]);</span>
        }

<span class="nc" id="L4811">        long ts = MiscDebug.getCurrentTimeFormatted();</span>

<span class="nc" id="L4813">        MiscDebug.writeImage(contrastImg, &quot;_contrast_&quot; + ts);</span>
<span class="nc" id="L4814">        MiscDebug.writeImage(blueDivContrastImg, &quot;_blue_div_contrast_&quot; + ts);</span>
<span class="nc" id="L4815">        MiscDebug.writeImage(redDivContrastImg, &quot;_red_div_contrast_&quot; + ts);</span>
<span class="nc" id="L4816">    }</span>

    /**
     * expecting binary image input where a pixel of value &quot;1&quot; is significant.
     * if any of the pixels in gapsOf1 are completely surrounded by
     * pixels of value &quot;1&quot; in their 8 pixel neighborhood,
     * those gap pixels are set to &quot;0&quot;.
     * 
     * @param img binary image
     * @param gapsOf1 pixel indexes of filled in gaps (pixels set to &quot;1&quot;)
     * @param value 
     */
    public void restoreGapsOf1WhereSurrounded(GreyscaleImage img,
        TIntSet gapsOf1, int value) {
        
<span class="nc" id="L4831">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L4832">        int[] dys = Misc.dy8;</span>
<span class="nc" id="L4833">        int w = img.getWidth();</span>
<span class="nc" id="L4834">        int h = img.getHeight();</span>
<span class="nc" id="L4835">        TIntSet reset = new TIntHashSet();</span>
        
<span class="nc" id="L4837">        TIntIterator iter = gapsOf1.iterator();</span>
<span class="nc bnc" id="L4838" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L4839">            int pixIdx = iter.next();</span>
<span class="nc" id="L4840">            int y = pixIdx/w;</span>
<span class="nc" id="L4841">            int x = pixIdx - (y * w);</span>
<span class="nc" id="L4842">            int n1s = 0;</span>
<span class="nc bnc" id="L4843" title="All 2 branches missed.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L4844">                int x2 = x + dxs[k];</span>
<span class="nc" id="L4845">                int y2 = y + dys[k];</span>
<span class="nc bnc" id="L4846" title="All 8 branches missed.">                if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L4847">                    continue;</span>
                }
<span class="nc bnc" id="L4849" title="All 2 branches missed.">                if (img.getValue(x2, y2) == 1) {</span>
<span class="nc" id="L4850">                    n1s++;</span>
                }
            }
<span class="nc bnc" id="L4853" title="All 2 branches missed.">            if (n1s == dxs.length) {</span>
<span class="nc" id="L4854">                reset.add(pixIdx);</span>
            }
<span class="nc" id="L4856">        }</span>
<span class="nc" id="L4857">        iter = reset.iterator();</span>
<span class="nc bnc" id="L4858" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L4859">            int pixIdx = iter.next();</span>
<span class="nc" id="L4860">            img.setValue(pixIdx, 0);</span>
<span class="nc" id="L4861">        } </span>
        
<span class="nc" id="L4863">    }</span>

    /**
     * expecting binary image input where a pixel of value &quot;1&quot; is significant.
     * The algorithm is similar to dilation, in that if any pixel has
     * a gap of size 1 pixel in between itself and another, that gap is
     * set to value 0 and stored in outputAddedGaps.
     * 
     * @param img
     * @param outputAddedGaps
     * @param value
     * @return 
     */
    public GreyscaleImage fillInGapsOf1(GreyscaleImage img,
        TIntSet outputAddedGaps, int value) {

<span class="nc" id="L4879">        int w = img.getWidth();</span>
<span class="nc" id="L4880">        int h = img.getHeight();</span>

        /*
        0  1  2
        7     3
        6  5  4
        fill in !value if these pairs are filled in:
            0:3, 0:4, 0:5
            1:4, 1:5, 1:6
            2:5, 2:6, 2:7
            3:6, 3:7, 3:0
            4:7
        so a +1 and -1 in x or y and a +1 or -1 in y or x
        */
<span class="nc" id="L4894">        int[] dxs0 = new int[]{-1, -1, -1,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1};</span>
<span class="nc" id="L4895">        int[] dys0 = new int[]{+1, +1, +1,  1,  1,  1,  1,  1,  1,  0,  0,  0, -1};</span>
<span class="nc" id="L4896">        int[] dxs1 = new int[]{1,  +1,  0,  1,  0, -1,  0, -1, -1, -1, -1, -1, -1};</span>
<span class="nc" id="L4897">        int[] dys1 = new int[]{0,  -1, -1, -1, -1, -1, -1, -1,  0, -1,  0,  1,  0};</span>

<span class="nc" id="L4899">        GreyscaleImage tmpImg2 = img.copyImage();</span>

<span class="nc bnc" id="L4901" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L4902" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="nc" id="L4904">                int v = img.getValue(i, j);</span>

<span class="nc bnc" id="L4906" title="All 2 branches missed.">                if (v == value) {</span>
<span class="nc" id="L4907">                    continue;</span>
                }

<span class="nc bnc" id="L4910" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs0.length; ++k) {</span>
<span class="nc" id="L4911">                    int x1 = i + dxs0[k];</span>
<span class="nc" id="L4912">                    int y1 = j + dys0[k];</span>
<span class="nc bnc" id="L4913" title="All 8 branches missed.">                    if (x1 &lt; 0 || (x1 &gt; (w - 1)) || y1 &lt; 0 || (y1 &gt; (h - 1))) {</span>
<span class="nc" id="L4914">                        continue;</span>
                    }
<span class="nc" id="L4916">                    int v1 = img.getValue(x1, y1);</span>
<span class="nc bnc" id="L4917" title="All 2 branches missed.">                    if (v1 != value) {</span>
<span class="nc" id="L4918">                        continue;</span>
                    }
<span class="nc" id="L4920">                    int x2 = i + dxs1[k];</span>
<span class="nc" id="L4921">                    int y2 = j + dys1[k];</span>
<span class="nc bnc" id="L4922" title="All 8 branches missed.">                    if (x2 &lt; 0 || (x2 &gt; (w - 1)) || y2 &lt; 0 || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L4923">                        continue;</span>
                    }
<span class="nc" id="L4925">                    int v2 = img.getValue(x2, y2);</span>
<span class="nc bnc" id="L4926" title="All 2 branches missed.">                    if (v2 != value) {</span>
<span class="nc" id="L4927">                        continue;</span>
                    }
<span class="nc" id="L4929">                    tmpImg2.setValue(i, j, value);</span>
<span class="nc" id="L4930">                    int pixIdx = (j * w) + i;</span>
<span class="nc" id="L4931">                    outputAddedGaps.add(pixIdx);</span>
<span class="nc" id="L4932">                    break;</span>
                }
            }
        }

<span class="nc" id="L4937">        return tmpImg2;</span>
    }

    public GreyscaleImage fillInCompleteGapsOf1(GreyscaleImage img,
        TIntSet outputAddedGaps,int value) {

<span class="nc" id="L4943">        int w = img.getWidth();</span>
<span class="nc" id="L4944">        int h = img.getHeight();</span>

<span class="nc" id="L4946">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L4947">        int[] dys = Misc.dy8;</span>

<span class="nc" id="L4949">        GreyscaleImage tmpImg2 = img.copyImage();</span>

<span class="nc" id="L4951">        int nIter = 0;</span>
<span class="nc" id="L4952">        int nChanged = 0;</span>
<span class="nc" id="L4953">        int nMaxIter = 5;</span>
<span class="nc bnc" id="L4954" title="All 6 branches missed.">        while ((nIter == 0) || ((nChanged &gt; 0) &amp;&amp; (nIter &lt; nMaxIter))) {</span>
<span class="nc" id="L4955">            nChanged = 0;</span>
<span class="nc bnc" id="L4956" title="All 2 branches missed.">            for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L4957" title="All 2 branches missed.">                for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L4958">                    int v = img.getValue(i, j);</span>
<span class="nc bnc" id="L4959" title="All 2 branches missed.">                    if (v == value) {</span>
<span class="nc" id="L4960">                        continue;</span>
                    }
<span class="nc" id="L4962">                    int count = 0;</span>
<span class="nc" id="L4963">                    int neighborCount = 0;</span>
<span class="nc bnc" id="L4964" title="All 2 branches missed.">                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L4965">                        int x2 = i + dxs[k];</span>
<span class="nc" id="L4966">                        int y2 = j + dys[k];</span>
<span class="nc bnc" id="L4967" title="All 8 branches missed.">                        if (x2 &lt; 0 || (x2 &gt; (w - 1)) || y2 &lt; 0 || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L4968">                            continue;</span>
                        }
<span class="nc" id="L4970">                        count++;</span>
<span class="nc" id="L4971">                        int v1 = img.getValue(x2, y2);</span>
<span class="nc bnc" id="L4972" title="All 2 branches missed.">                        if (v1 != value) {</span>
<span class="nc" id="L4973">                            continue;</span>
                        }
<span class="nc" id="L4975">                        neighborCount++;</span>
                    }
<span class="nc bnc" id="L4977" title="All 2 branches missed.">                    if (count == neighborCount) {</span>
<span class="nc" id="L4978">                        tmpImg2.setValue(i, j, value);</span>
<span class="nc" id="L4979">                        int pixIdx = (j * w) + i;</span>
<span class="nc" id="L4980">                        outputAddedGaps.add(pixIdx);</span>
<span class="nc" id="L4981">                        nChanged++;</span>
                    }
                }
            }
<span class="nc" id="L4985">            nIter++;</span>
        }

<span class="nc" id="L4988">        return tmpImg2;</span>
    }

    GreyscaleImage shrinkBy1(GreyscaleImage img, int edgeValue, int nonEdgeValue) {

<span class="nc" id="L4993">        int w = img.getWidth();</span>
<span class="nc" id="L4994">        int h = img.getHeight();</span>

        /*
         any pixel with neighbors that are not edgeValue can be removed
         */
<span class="nc" id="L4999">        PairInt[][] neighborCoordOffsets</span>
<span class="nc" id="L5000">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
                0, 0);

<span class="nc" id="L5003">        GreyscaleImage tmpImg2 = img.copyImage();</span>
<span class="nc" id="L5004">        int[] dxs0 = Misc.dx8;</span>
<span class="nc" id="L5005">        int[] dys0 = Misc.dy8;</span>
<span class="nc bnc" id="L5006" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L5007" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L5008">                int v = img.getValue(i, j);</span>
<span class="nc bnc" id="L5009" title="All 2 branches missed.">                if (v != edgeValue) {</span>
<span class="nc" id="L5010">                    continue;</span>
                }
<span class="nc" id="L5012">                int nEmptyNeigbhors = 0;</span>
<span class="nc bnc" id="L5013" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs0.length; ++k) {</span>
<span class="nc" id="L5014">                    int x1 = i + dxs0[k];</span>
<span class="nc" id="L5015">                    int y1 = j + dys0[k];</span>
<span class="nc bnc" id="L5016" title="All 8 branches missed.">                    if (x1 &lt; 0 || (x1 &gt; (w - 1)) || y1 &lt; 0 || (y1 &gt; (h - 1))) {</span>
<span class="nc" id="L5017">                        continue;</span>
                    }
<span class="nc" id="L5019">                    int v2 = img.getValue(x1, y1);</span>
<span class="nc bnc" id="L5020" title="All 2 branches missed.">                    if (v2 != edgeValue) {</span>
<span class="nc" id="L5021">                        nEmptyNeigbhors++;</span>
                    }
                }

<span class="nc bnc" id="L5025" title="All 2 branches missed.">                if (nEmptyNeigbhors &gt; 0</span>
<span class="nc bnc" id="L5026" title="All 2 branches missed.">                    &amp;&amp; !doesDisconnect(tmpImg2, neighborCoordOffsets, i, j, edgeValue)) {</span>
<span class="nc" id="L5027">                    tmpImg2.setValue(i, j, nonEdgeValue);</span>
                }
            }
        }

<span class="nc" id="L5032">        return tmpImg2;</span>
    }

    private void invertImage(GreyscaleImage img) {
<span class="nc bnc" id="L5036" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L5037">            int v = img.getValue(i);</span>
<span class="nc" id="L5038">            img.setValue(i, 255 - v);</span>
        }
<span class="nc" id="L5040">    }</span>
    private void setAllNonZeroTo255(GreyscaleImage img) {
<span class="nc bnc" id="L5042" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L5043">            int v = img.getValue(i);</span>
<span class="nc bnc" id="L5044" title="All 2 branches missed.">            if (v &gt; 0) {</span>
<span class="nc" id="L5045">                img.setValue(i, 255);</span>
            }
        }
<span class="nc" id="L5048">    }</span>

    private void removeIsolatedPixels(GreyscaleImage img, int pixValue,
        int pixNullValue, boolean use8Neighbors) {

        int[] dxs, dys;
<span class="nc bnc" id="L5054" title="All 2 branches missed.">        if (use8Neighbors) {</span>
<span class="nc" id="L5055">            dxs = Misc.dx8;</span>
<span class="nc" id="L5056">            dys = Misc.dy8;</span>
        } else {
<span class="nc" id="L5058">            dxs = Misc.dx4;</span>
<span class="nc" id="L5059">            dys = Misc.dy4;</span>
        }

<span class="nc" id="L5062">        int w = img.getWidth();</span>
<span class="nc" id="L5063">        int h = img.getHeight();</span>

<span class="nc bnc" id="L5065" title="All 2 branches missed.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="nc bnc" id="L5066" title="All 2 branches missed.">            for (int y = 0; y &lt; h; ++y) {</span>
<span class="nc" id="L5067">                int v = img.getValue(x, y);</span>
<span class="nc bnc" id="L5068" title="All 2 branches missed.">                if (v != pixValue) {</span>
<span class="nc" id="L5069">                    continue;</span>
                }
<span class="nc" id="L5071">                int count = 0;</span>
<span class="nc" id="L5072">                int nSame = 0;</span>
<span class="nc bnc" id="L5073" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L5074">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L5075">                    int y2 = y + dys[k];</span>
<span class="nc bnc" id="L5076" title="All 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) ||</span>
                        (y2 &gt; (h - 1))) {
<span class="nc" id="L5078">                        continue;</span>
                    }
<span class="nc" id="L5080">                    count++;</span>
<span class="nc" id="L5081">                    int v2 = img.getValue(x2, y2);</span>
<span class="nc bnc" id="L5082" title="All 2 branches missed.">                    if (v2 == pixValue) {</span>
<span class="nc" id="L5083">                        nSame++;</span>
<span class="nc" id="L5084">                        break;</span>
                    }
                }
<span class="nc bnc" id="L5087" title="All 2 branches missed.">                if (nSame == 0) {</span>
<span class="nc" id="L5088">                    img.setValue(x, y, pixNullValue);</span>
                }
            }
        }
<span class="nc" id="L5092">    }</span>

    private void populateAdjacentCellPoints(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; segmentedCellList,
        Map&lt;PairInt, Integer&gt; pointIndexMap,
        List&lt;Double&gt; deltaE, List&lt;Integer&gt; hueAngle1, List&lt;Integer&gt; hueAngle2) {

<span class="nc" id="L5099">        int w = input.getWidth();</span>
<span class="nc" id="L5100">        int h = input.getHeight();</span>

<span class="nc" id="L5102">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L5103">        int[] dys = Misc.dy8;</span>

<span class="nc" id="L5105">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc bnc" id="L5107" title="All 2 branches missed.">        for (int i = 0; i &lt; segmentedCellList.size(); ++i) {</span>

<span class="nc" id="L5109">            Integer index = Integer.valueOf(i);</span>

<span class="nc" id="L5111">            Set&lt;PairInt&gt; set = segmentedCellList.get(index.intValue());</span>

            // collecting bordering points
            // storing all then averaging and comparing to deltaELimit
<span class="nc" id="L5115">            Map&lt;Integer, List&lt;Double&gt;&gt; listIndexDeltaEMap = new HashMap&lt;Integer, List&lt;Double&gt;&gt;();</span>
<span class="nc" id="L5116">            Map&lt;Integer, List&lt;Integer&gt;&gt; listIndexHA1Map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span>
<span class="nc" id="L5117">            Map&lt;Integer, List&lt;Integer&gt;&gt; listIndexHA2Map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span>

<span class="nc bnc" id="L5119" title="All 2 branches missed.">            for (PairInt p : set) {</span>

<span class="nc" id="L5121">                int x = p.getX();</span>
<span class="nc" id="L5122">                int y = p.getY();</span>
<span class="nc" id="L5123">                Integer listIndex = pointIndexMap.get(p);</span>
<span class="nc bnc" id="L5124" title="All 4 branches missed.">                assert(listIndex.intValue() == index.intValue());</span>

<span class="nc" id="L5126">                float[] lab = input.getCIELAB(x, y);</span>

<span class="nc bnc" id="L5128" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>

<span class="nc" id="L5130">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L5131">                    int y2 = y + dys[k];</span>

<span class="nc" id="L5133">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L5134" title="All 8 branches missed.">                    if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L5135">                        continue;</span>
                    }

<span class="nc" id="L5138">                    Integer listIndex2 = pointIndexMap.get(p2);</span>
<span class="nc bnc" id="L5139" title="All 4 branches missed.">                    if (listIndex2 == null || listIndex.equals(listIndex2)) {</span>
<span class="nc" id="L5140">                        continue;</span>
                    }

<span class="nc" id="L5143">                    float[] lab2 = input.getCIELAB(x2, y2);</span>

<span class="nc" id="L5145">                    double dE = Math.abs(cieC.calcDeltaECIE2000(lab, lab2));</span>

<span class="nc" id="L5147">                    List&lt;Double&gt; dEs = listIndexDeltaEMap.get(listIndex2);</span>
<span class="nc bnc" id="L5148" title="All 2 branches missed.">                    if (dEs == null) {</span>
<span class="nc" id="L5149">                        dEs = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L5150">                        listIndexDeltaEMap.put(listIndex2, dEs);</span>
                    }
<span class="nc" id="L5152">                    dEs.add(Double.valueOf(dE));</span>

                    float ha1;
<span class="nc bnc" id="L5155" title="All 2 branches missed.">                    if (lab[1] == 0) {</span>
<span class="nc" id="L5156">                        ha1 = 0;</span>
                    } else {
<span class="nc" id="L5158">                        ha1 = (float) (Math.atan2(lab[2], lab[1]) * 180. / Math.PI);</span>
<span class="nc bnc" id="L5159" title="All 2 branches missed.">                        if (ha1 &lt; 0) {</span>
<span class="nc" id="L5160">                            ha1 += 360.;</span>
                        }
                    }

<span class="nc" id="L5164">                    List&lt;Integer&gt; ha1s = listIndexHA1Map.get(listIndex2);</span>
<span class="nc bnc" id="L5165" title="All 2 branches missed.">                    if (ha1s == null) {</span>
<span class="nc" id="L5166">                        ha1s = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L5167">                        listIndexHA1Map.put(listIndex2, ha1s);</span>
                    }
<span class="nc" id="L5169">                    ha1s.add(Integer.valueOf(Math.round(ha1)));</span>

                    float ha2;
<span class="nc bnc" id="L5172" title="All 2 branches missed.">                    if (lab2[1] == 0) {</span>
<span class="nc" id="L5173">                        ha2 = 0;</span>
                    } else {
<span class="nc" id="L5175">                        ha2 = (float) (Math.atan2(lab2[2], lab2[1]) * 180. / Math.PI);</span>
<span class="nc bnc" id="L5176" title="All 2 branches missed.">                        if (ha2 &lt; 0) {</span>
<span class="nc" id="L5177">                            ha2 += 360.;</span>
                        }
                    }

<span class="nc" id="L5181">                    List&lt;Integer&gt; ha2s = listIndexHA2Map.get(listIndex2);</span>
<span class="nc bnc" id="L5182" title="All 2 branches missed.">                    if (ha2s == null) {</span>
<span class="nc" id="L5183">                        ha2s = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L5184">                        listIndexHA2Map.put(listIndex2, ha2s);</span>
                    }
<span class="nc" id="L5186">                    ha2s.add(Integer.valueOf(Math.round(ha2)));</span>
                }
<span class="nc" id="L5188">            }</span>

<span class="nc bnc" id="L5190" title="All 2 branches missed.">            for (Entry&lt;Integer, List&lt;Double&gt;&gt; entry : listIndexDeltaEMap.entrySet()) {</span>

<span class="nc" id="L5192">                Integer listIndex2 = entry.getKey();</span>

<span class="nc" id="L5194">                List&lt;Double&gt; deltaEs = entry.getValue();</span>

<span class="nc" id="L5196">                double sumDeltaE = 0;</span>
<span class="nc bnc" id="L5197" title="All 2 branches missed.">                for (int ii = 0; ii &lt; deltaEs.size(); ++ii) {</span>
<span class="nc" id="L5198">                    sumDeltaE += deltaEs.get(ii).doubleValue();</span>
                }
<span class="nc" id="L5200">                sumDeltaE /= (double)deltaEs.size();</span>

<span class="nc" id="L5202">                List&lt;Integer&gt; ha1s = listIndexHA1Map.get(listIndex2.intValue());</span>
<span class="nc" id="L5203">                int[] hueAngles1 = new int[ha1s.size()];</span>
<span class="nc" id="L5204">                List&lt;Integer&gt; ha2s = listIndexHA2Map.get(listIndex2.intValue());</span>
<span class="nc" id="L5205">                int[] hueAngles2 = new int[ha2s.size()];</span>
<span class="nc bnc" id="L5206" title="All 2 branches missed.">                for (int ii = 0; ii &lt; ha1s.size(); ++ii) {</span>
<span class="nc" id="L5207">                    hueAngles1[ii] = ha1s.get(ii).intValue();</span>
<span class="nc" id="L5208">                    hueAngles2[ii] = ha2s.get(ii).intValue();</span>
                }

<span class="nc" id="L5211">                float avgHA1 = AngleUtil.calculateAverageWithQuadrantCorrections(</span>
                    hueAngles1, hueAngles1.length - 1);

<span class="nc" id="L5214">                float avgHA2 = AngleUtil.calculateAverageWithQuadrantCorrections(</span>
                    hueAngles2, hueAngles2.length - 1);

<span class="nc bnc" id="L5217" title="All 2 branches missed.">                if (avgHA1 &lt; 0) {</span>
<span class="nc" id="L5218">                    avgHA1 += 360;</span>
<span class="nc bnc" id="L5219" title="All 2 branches missed.">                } else if (avgHA1 &gt; 359) {</span>
<span class="nc" id="L5220">                    avgHA1 -= 360;</span>
                }
<span class="nc bnc" id="L5222" title="All 2 branches missed.">                if (avgHA2 &lt; 0) {</span>
<span class="nc" id="L5223">                    avgHA2 += 360;</span>
<span class="nc bnc" id="L5224" title="All 2 branches missed.">                } else if (avgHA2 &gt; 359) {</span>
<span class="nc" id="L5225">                    avgHA2 -= 360;</span>
                }

<span class="nc" id="L5228">                deltaE.add(Double.valueOf(sumDeltaE));</span>
<span class="nc" id="L5229">                hueAngle1.add(Integer.valueOf(Math.round(avgHA1)));</span>
<span class="nc" id="L5230">                hueAngle2.add(Integer.valueOf(Math.round(avgHA2)));</span>
<span class="nc" id="L5231">            }</span>
        }

<span class="nc" id="L5234">    }</span>
    
    /**
     * check whether a neighbor belongs to another edge (NOTE that the bounds
     * have to have been checked before this)
     * @param x
     * @param y
     * @param edgeIndexMap
     * @param hN
     * @return
     */
    private boolean foundAdjacentEdge(int x, int y, Map&lt;PairInt, Integer&gt;
        edgeIndexMap, Integer index, int hN) {

<span class="nc bnc" id="L5248" title="All 2 branches missed.">        for (int dy = -hN; dy &lt;= hN; ++dy) {</span>
<span class="nc" id="L5249">            int y2 = y + dy;</span>
<span class="nc bnc" id="L5250" title="All 2 branches missed.">            for (int dx = -hN; dx &lt;= hN; ++dx) {</span>
<span class="nc" id="L5251">                int x2 = x + dx;</span>
<span class="nc" id="L5252">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc" id="L5253">                Integer index2 = edgeIndexMap.get(p2);</span>
<span class="nc bnc" id="L5254" title="All 4 branches missed.">                if ((index2 != null) &amp;&amp; !index2.equals(index)) {</span>
<span class="nc" id="L5255">                    return true;</span>
                }
            }
        }
<span class="nc" id="L5259">        return false;</span>
    }

    private boolean aMemberIsOutOfBounds(int x, int y, int hN, int w, int h) {

<span class="nc bnc" id="L5264" title="All 2 branches missed.">        for (int dy = -hN; dy &lt;= hN; ++dy) {</span>
<span class="nc" id="L5265">            int y2 = y + dy;</span>
<span class="nc bnc" id="L5266" title="All 4 branches missed.">            if ((y2 &lt; 0) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L5267">                return true;</span>
            }
<span class="nc bnc" id="L5269" title="All 2 branches missed.">            for (int dx = -hN; dx &lt;= hN; ++dx) {</span>
<span class="nc" id="L5270">                int x2 = x + dx;</span>
<span class="nc bnc" id="L5271" title="All 4 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (w - 1))) {</span>
<span class="nc" id="L5272">                    return true;</span>
                }
            }
        }

<span class="nc" id="L5277">        return false;</span>
    }

    private int countNeighbors(Map&lt;PairInt, Integer&gt; pointMap, int x, int y) {

<span class="nc" id="L5282">        int count = 0;</span>
<span class="nc" id="L5283">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L5284">        int[] dys = Misc.dy8;</span>

<span class="nc bnc" id="L5286" title="All 2 branches missed.">        for (int jj = 0; jj &lt; dxs.length; ++jj) {</span>
<span class="nc" id="L5287">            PairInt p3 = new PairInt(x + dxs[jj], y + dys[jj]);</span>
<span class="nc bnc" id="L5288" title="All 2 branches missed.">            if (pointMap.containsKey(p3)) {</span>
<span class="nc" id="L5289">                count++;</span>
            }
        }

<span class="nc" id="L5293">        return count;</span>
    }

    private void mergeEdges(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, int clrSpace, double tColor,
        List&lt;Integer&gt; edgeIndexes) {

<span class="fc" id="L5300">        log.fine(edgeIndexes.size() + &quot; edges&quot;);</span>

<span class="pc bpc" id="L5302" title="1 of 2 branches missed.">        if (edgeIndexes.isEmpty()) {</span>
<span class="nc" id="L5303">            return;</span>
        }

<span class="fc" id="L5306">        final long heapKeyFactor = 1000000l;</span>
<span class="fc" id="L5307">        Heap heap = new Heap();</span>
<span class="fc" id="L5308">        Map&lt;PairInt, HeapNode&gt; pairEdgePindexNodes = new HashMap&lt;PairInt, HeapNode&gt;();</span>
<span class="fc" id="L5309">        populateColorDiffHeap(clusterDescriptors, clrSpace,</span>
            edgeIndexes, heap, heapKeyFactor, pairEdgePindexNodes);

        // ---- make a map to find and update merged data structures ------
<span class="fc" id="L5313">        Map&lt;Integer, Set&lt;Integer&gt;&gt; indexToIndexMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
<span class="fc bfc" id="L5314" title="All 2 branches covered.">        for (PairInt p : pairEdgePindexNodes.keySet()) {</span>

<span class="fc" id="L5316">            Integer index1 = Integer.valueOf(p.getX());</span>
<span class="fc" id="L5317">            Integer index2 = Integer.valueOf(p.getY());</span>

<span class="fc" id="L5319">            Set&lt;Integer&gt; indexes = indexToIndexMap.get(index1);</span>
<span class="fc bfc" id="L5320" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L5321">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L5322">                indexToIndexMap.put(index1, indexes);</span>
            }
<span class="fc" id="L5324">            indexes.add(index2);</span>

<span class="fc" id="L5326">            indexes = indexToIndexMap.get(index2);</span>
<span class="fc bfc" id="L5327" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L5328">                indexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L5329">                indexToIndexMap.put(index2, indexes);</span>
            }
<span class="fc" id="L5331">            indexes.add(index1);</span>
<span class="fc" id="L5332">        }</span>

<span class="fc" id="L5334">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="pc bpc" id="L5336" title="1 of 2 branches missed.">        while (!heap.isEmpty()) {</span>

<span class="fc" id="L5338">            HeapNode node = heap.extractMin();</span>
<span class="fc" id="L5339">            double diff = ((double)node.getKey())/((double)heapKeyFactor);</span>

<span class="fc bfc" id="L5341" title="All 2 branches covered.">            if (diff &gt; tColor) {</span>
<span class="fc" id="L5342">                break;</span>
            }

<span class="fc" id="L5345">            PairInt p12 = (PairInt)node.getData();</span>

<span class="fc" id="L5347">            int idx1 = p12.getX();</span>
<span class="fc" id="L5348">            int idx2 = p12.getY();</span>

<span class="fc" id="L5350">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="fc" id="L5351">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>

<span class="pc bpc" id="L5353" title="2 of 4 branches missed.">            if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="nc" id="L5354">                continue;</span>
            }

<span class="fc bfc" id="L5357" title="All 2 branches covered.">            if (set2.size() &gt; set1.size()) {</span>
<span class="fc" id="L5358">                idx1 = p12.getY();</span>
<span class="fc" id="L5359">                idx2 = p12.getX();</span>
<span class="fc" id="L5360">                set1 = set2;</span>
<span class="fc" id="L5361">                set2 = clusterPoints.get(idx2);</span>
            }

            // set1 is largest

<span class="fc" id="L5366">            Integer index1 = Integer.valueOf(idx1);</span>
<span class="fc" id="L5367">            Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L5369">            float[] desc1 = clusterDescriptors[idx1];</span>
<span class="fc" id="L5370">            float[] desc2 = clusterDescriptors[idx2];</span>
<span class="fc" id="L5371">            float n1 = set1.size();</span>
<span class="fc" id="L5372">            float n2 = set2.size();</span>
<span class="fc" id="L5373">            float nTot = n1 + n2;</span>

<span class="pc bpc" id="L5375" title="3 of 4 branches missed.">            assert(Math.abs(n1 - desc1[3]) &lt; 0.1);</span>
<span class="pc bpc" id="L5376" title="3 of 4 branches missed.">            assert(Math.abs(n2 - desc2[3]) &lt; 0.1);</span>

            //{h, s, v, nPix, cenX, cenY}
            // update desc1 contents for contents in desc2
<span class="fc bfc" id="L5380" title="All 2 branches covered.">            for (int k = 0; k &lt; desc1.length; ++k) {</span>
<span class="fc bfc" id="L5381" title="All 2 branches covered.">                if (k == 3) {</span>
<span class="fc" id="L5382">                    desc1[k] = nTot;</span>
                } else {
<span class="fc" id="L5384">                    desc1[k] = ((desc1[k] * n1) + (desc2[k] * n2)) / nTot;</span>
                }
            }
<span class="fc" id="L5387">            clusterDescriptors[idx2] = null;</span>
<span class="fc" id="L5388">            set1.addAll(set2);</span>
<span class="fc" id="L5389">            set2.clear();</span>

<span class="fc" id="L5391">            n1 = set1.size();</span>

            // remove the idx1 --&gt; set&lt;integer&gt; pairs from map and heap
            // remove the idx2 --&gt; set&lt;integer&gt; pairs from map and heap

<span class="fc" id="L5396">            Set&lt;Integer&gt; indexes3 = indexToIndexMap.get(index1);</span>
<span class="fc bfc" id="L5397" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L5398">                int idx3 = index3.intValue();</span>
<span class="fc" id="L5399">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L5400" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L5401">                    continue;</span>
                }
                //keys in pairEdgePindexNodes have smaller index in x
                PairInt p13;
<span class="fc bfc" id="L5405" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L5406">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L5408">                    p13 = new PairInt(idx3, idx1);</span>
                }
<span class="fc" id="L5410">                HeapNode node3 = pairEdgePindexNodes.get(p13);</span>
<span class="pc bpc" id="L5411" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L5412">                heap.remove(node3);</span>
<span class="fc" id="L5413">                pairEdgePindexNodes.remove(p13);</span>
<span class="fc" id="L5414">            }</span>

<span class="fc" id="L5416">            indexes3 = indexToIndexMap.get(index2);</span>
<span class="fc bfc" id="L5417" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L5418">                int idx3 = index3.intValue();</span>
<span class="fc" id="L5419">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="fc bfc" id="L5420" title="All 4 branches covered.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="fc" id="L5421">                    continue;</span>
                }
                PairInt p23;
<span class="fc bfc" id="L5424" title="All 2 branches covered.">                if (idx2 &lt; idx3) {</span>
<span class="fc" id="L5425">                    p23 = new PairInt(idx2, idx3);</span>
                } else {
<span class="fc" id="L5427">                    p23 = new PairInt(idx3, idx2);</span>
                }
<span class="fc" id="L5429">                HeapNode node3 = pairEdgePindexNodes.get(p23);</span>
<span class="pc bpc" id="L5430" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L5431">                heap.remove(node3);</span>
<span class="fc" id="L5432">                pairEdgePindexNodes.remove(p23);</span>
<span class="fc" id="L5433">            }</span>

            // update the indexToIndexMap
<span class="fc" id="L5436">            Set&lt;Integer&gt; iim = new HashSet&lt;Integer&gt;(indexToIndexMap.get(index2));</span>
<span class="fc bfc" id="L5437" title="All 2 branches covered.">            for (Integer index3 : iim) {</span>
<span class="fc bfc" id="L5438" title="All 2 branches covered.">                if (!index3.equals(index1)) {</span>
<span class="fc" id="L5439">                    Set&lt;Integer&gt; indexes4 = indexToIndexMap.get(index3);</span>
<span class="fc bfc" id="L5440" title="All 2 branches covered.">                    if (indexes4 != null) {</span>
<span class="fc" id="L5441">                        indexes4.remove(index2);</span>
<span class="fc" id="L5442">                        indexes4.add(index1);</span>
                    }
                }
<span class="fc" id="L5445">            }</span>
<span class="fc" id="L5446">            indexes3.addAll(iim);</span>
<span class="fc" id="L5447">            indexes3.remove(index2);</span>
<span class="fc" id="L5448">            indexToIndexMap.remove(index2);</span>

            // add node for updated idx1 ---&gt; set&lt;integer&gt; to map and node
<span class="fc" id="L5451">            indexes3 = indexToIndexMap.get(Integer.valueOf(idx1));</span>
<span class="fc bfc" id="L5452" title="All 2 branches covered.">            for (Integer index3 : indexes3) {</span>
<span class="fc" id="L5453">                int idx3 = index3.intValue();</span>
<span class="fc" id="L5454">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L5455" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L5456">                    continue;</span>
                }
                //keys in pairEdgePindexNodes have smaller index in x
                PairInt p13;
<span class="fc bfc" id="L5460" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L5461">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L5463">                    p13 = new PairInt(idx3, idx1);</span>
                }

<span class="fc" id="L5466">                float[] desc3 = clusterDescriptors[idx3];</span>

                double diffUpdated;
<span class="pc bpc" id="L5469" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L5470">                    diffUpdated = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc3[0], desc3[1], desc3[2]));
                } else {
<span class="nc" id="L5474">                    double diff1 = desc1[0] - desc3[0];</span>
<span class="nc" id="L5475">                    double diff2 = desc1[1] - desc3[1];</span>
<span class="nc" id="L5476">                    double diff3 = desc1[2] - desc3[2];</span>
<span class="nc" id="L5477">                    diffUpdated = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

<span class="fc" id="L5480">                long heapKey = (long)((double)heapKeyFactor * diffUpdated);</span>
<span class="fc" id="L5481">                HeapNode node3 = new HeapNode(heapKey);</span>
<span class="fc" id="L5482">                node3.setData(p13);</span>
<span class="fc" id="L5483">                heap.insert(node3);</span>
<span class="fc" id="L5484">                pairEdgePindexNodes.put(p13, node3);</span>
<span class="fc" id="L5485">            }</span>

            // pairs having set2 will be skipped because of the empty set at beginning of while loop
<span class="fc" id="L5488">        }</span>
<span class="fc" id="L5489">    }</span>

    private void growEdges(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors,
        Map&lt;PairInt, Integer&gt; pointIndexMap, int clrSpace, double tColor,
        List&lt;Integer&gt; shortEdgeIndexes, List&lt;Integer&gt; longEdgeIndexes) {

<span class="pc bpc" id="L5497" title="1 of 2 branches missed.">        if (pointIndexMap.isEmpty()) {</span>
<span class="nc" id="L5498">            return;</span>
        }

        /*
        traverse all image points to make a map of unassigned pixels and the
            cluster indexes they are adjacent to if any.
            --&gt; O(N)

        initialize an outer queue with the unassigned which have nIndexes &gt; 0
           sorted by descending number of adjacenct indexes
           --&gt; O(N_i * lg2(N_i))

        create an inner queue

        --&gt; O(|V| + |E|)
        visit each outer queue member, adding it to adjacent cluster
           which has most similar color.
           update the cluster's descriptor
           add each of the 8 neighbors which aren't assigned to the inner
              queue.
           add the point to the visited set.
        when all outer queue members have been visited, fill the outer queue
            with the inner queue and empty the inner queue.
            (could sort again here for more precise growing)
        continue in this manner until the inner queue is empty and hence outer
            queue is empty.
            assert that visited.size == unassigned map.size

        The same pattern should be applied elsewhere too
        */

        // for each edge, add neighbors with diff &lt; tColor
        //    if an adjacent pixel is part of a short edge cluster,
        //    then all of that short edge is added to the cluster

        // removing short edge points from pointIndexMap and creating
        // shortPointIndexMap to more easily add them as a whole
<span class="fc" id="L5535">        Map&lt;PairInt, Integer&gt; shortPointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="pc bpc" id="L5536" title="1 of 2 branches missed.">        for (Integer index : shortEdgeIndexes) {</span>
<span class="nc" id="L5537">            int idx = index.intValue();</span>
<span class="nc" id="L5538">            Set&lt;PairInt&gt; set = clusterPoints.get(idx);</span>
<span class="nc bnc" id="L5539" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L5540">                shortPointIndexMap.put(p, index);</span>
<span class="nc" id="L5541">                pointIndexMap.remove(p);</span>
<span class="nc" id="L5542">            }</span>
<span class="nc" id="L5543">        }</span>

<span class="fc" id="L5545">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L5547">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L5548">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L5550">        int width = img.getWidth();</span>
<span class="fc" id="L5551">        int height = img.getHeight();</span>

        /*
        on first iteration, the edge regions are grown to include adjacent points
        that are within tColor tolerance and short edges which are ajacent
        regardless of color difference.

        on second iteration, unassigned pixels are added to adjacent indexes
        most similar in color.
        */

<span class="fc" id="L5562">        int lastInnerQ = 0;</span>

<span class="fc bfc" id="L5564" title="All 2 branches covered.">        for (int nIter = 0; nIter &lt; 2; ++nIter) {</span>

<span class="fc" id="L5566">            Map&lt;PairInt, Set&lt;Integer&gt;&gt; unassignedAndIndexes =</span>
<span class="fc" id="L5567">                findUnassignedPixelsAndAdjacentIndexes(img, pointIndexMap);</span>

<span class="pc bpc" id="L5569" title="1 of 2 branches missed.">            if (unassignedAndIndexes.isEmpty()) {</span>
<span class="nc" id="L5570">                return;</span>
            }

<span class="pc bpc" id="L5573" title="1 of 2 branches missed.">            assert(img.getNPixels() == (unassignedAndIndexes.size() +</span>
<span class="nc bnc" id="L5574" title="All 2 branches missed.">                pointIndexMap.size()));</span>

<span class="fc" id="L5576">            int count = 0;</span>
<span class="fc bfc" id="L5577" title="All 2 branches covered.">            for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry : unassignedAndIndexes.entrySet()) {</span>
<span class="fc bfc" id="L5578" title="All 2 branches covered.">                if (entry.getValue().size() &gt; 0) {</span>
<span class="fc" id="L5579">                    ++count;</span>
                }
<span class="fc" id="L5581">            }</span>
<span class="fc" id="L5582">            PairInt[] unassigned = new PairInt[count];</span>
<span class="fc" id="L5583">            int[] nAdjIndexes = new int[unassigned.length];</span>
<span class="fc" id="L5584">            count = 0;</span>
            for (Entry&lt;PairInt, Set&lt;Integer&gt;&gt; entry :
<span class="fc bfc" id="L5586" title="All 2 branches covered.">                unassignedAndIndexes.entrySet()) {</span>
<span class="fc bfc" id="L5587" title="All 2 branches covered.">                if (entry.getValue().size() &gt; 0) {</span>
<span class="fc" id="L5588">                    unassigned[count] = entry.getKey();</span>
<span class="fc" id="L5589">                    nAdjIndexes[count] = entry.getValue().size();</span>
<span class="fc" id="L5590">                    ++count;</span>
                }
<span class="fc" id="L5592">            }</span>
<span class="fc" id="L5593">            QuickSort.sortBy1stArg(nAdjIndexes, unassigned);</span>
<span class="fc" id="L5594">            ArrayDeque&lt;PairInt&gt; outerQueue = new ArrayDeque&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L5595" title="All 2 branches covered.">            for (int i = (unassigned.length - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L5596">                outerQueue.add(unassigned[i]);</span>
            }

<span class="fc" id="L5599">            ArrayDeque&lt;PairInt&gt; innerQueue = new ArrayDeque&lt;PairInt&gt;();</span>
            while (true) {
<span class="fc bfc" id="L5601" title="All 2 branches covered.">                while (!outerQueue.isEmpty()) {</span>
<span class="fc" id="L5602">                    PairInt p = outerQueue.poll();</span>
<span class="fc bfc" id="L5603" title="All 2 branches covered.">                    if (pointIndexMap.containsKey(p)) {</span>
<span class="fc" id="L5604">                        continue;</span>
                    }
<span class="fc" id="L5606">                    int x = p.getX();</span>
<span class="fc" id="L5607">                    int y = p.getY();</span>
<span class="fc" id="L5608">                    boolean isAShortEdge = shortPointIndexMap.containsKey(p);</span>
                    float[] clrs1;
<span class="pc bpc" id="L5610" title="1 of 2 branches missed.">                    if (isAShortEdge) {</span>
<span class="nc" id="L5611">                        clrs1 = clusterDescriptors[shortPointIndexMap.get(p).intValue()];</span>
                    } else {
<span class="fc" id="L5613">                        clrs1 = getColors(img, x, y, clrSpace);</span>
                    }

<span class="fc" id="L5616">                    double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L5617">                    Integer minDiffIndex = null;</span>
<span class="fc bfc" id="L5618" title="All 2 branches covered.">                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L5619">                        int x2 = x + dxs[k];</span>
<span class="fc" id="L5620">                        int y2 = y + dys[k];</span>
<span class="fc bfc" id="L5621" title="All 8 branches covered.">                        if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (width - 1))</span>
                            || (y2 &gt; (height - 1))) {
<span class="fc" id="L5623">                            continue;</span>
                        }
<span class="fc" id="L5625">                        PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L5626">                        Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L5627" title="All 2 branches covered.">                        if (index2 == null) {</span>
<span class="fc" id="L5628">                            continue;</span>
                        } else {
<span class="pc bpc" id="L5630" title="3 of 4 branches missed.">                            if (isAShortEdge &amp;&amp; index2.equals(shortPointIndexMap.get(p))) {</span>
<span class="nc" id="L5631">                                continue;</span>
                            }
<span class="pc bpc" id="L5633" title="1 of 2 branches missed.">                            if (clusterPoints.get(index2.intValue()).isEmpty()) {</span>
<span class="nc" id="L5634">                                continue;</span>
                            }
                        }
<span class="fc" id="L5637">                        float[] desc2 = clusterDescriptors[index2.intValue()];</span>
                        double diff;
<span class="pc bpc" id="L5639" title="1 of 2 branches missed.">                        if (clrSpace == 0) {</span>
<span class="fc" id="L5640">                            diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                                clrs1[0], clrs1[1], clrs1[2], desc2[0], desc2[1], desc2[2]));
                        } else {
<span class="nc" id="L5643">                            double diff1 = clrs1[0] - desc2[0];</span>
<span class="nc" id="L5644">                            double diff2 = clrs1[1] - desc2[1];</span>
<span class="nc" id="L5645">                            double diff3 = clrs1[2] - desc2[2];</span>
<span class="nc" id="L5646">                            diff = Math.sqrt(diff1 * diff1 + diff2 * diff2 + diff3 * diff3);</span>
                        }
<span class="pc bpc" id="L5648" title="1 of 6 branches missed.">                        if ((nIter == 0) &amp;&amp; !isAShortEdge &amp;&amp; (diff &gt; tColor)) {</span>
<span class="fc" id="L5649">                            continue;</span>
                        }
<span class="fc bfc" id="L5651" title="All 2 branches covered.">                        if (diff &lt; minDiff) {</span>
<span class="fc" id="L5652">                            minDiff = diff;</span>
<span class="fc" id="L5653">                            minDiffIndex = index2;</span>
                        }
                    }
<span class="fc bfc" id="L5656" title="All 2 branches covered.">                    if (minDiffIndex == null) {</span>
<span class="fc" id="L5657">                        continue;</span>
                    }
<span class="fc" id="L5659">                    int idx2 = minDiffIndex.intValue();</span>
<span class="fc" id="L5660">                    Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="fc" id="L5661">                    float[] desc2 = clusterDescriptors[idx2];</span>
<span class="pc bpc" id="L5662" title="1 of 2 branches missed.">                    if (isAShortEdge) {</span>
<span class="nc" id="L5663">                        Integer index1 = shortPointIndexMap.get(p);</span>
<span class="nc" id="L5664">                        int idx1 = index1.intValue();</span>
<span class="nc" id="L5665">                        Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="nc" id="L5666">                        float[] desc1 = clusterDescriptors[idx1];</span>
<span class="nc" id="L5667">                        float n1 = set1.size();</span>
<span class="nc" id="L5668">                        float n2 = set2.size();</span>
<span class="nc" id="L5669">                        float nTot = n1 + n2;</span>
                        //{h, s, v, nPix, cenX, cenY}
<span class="nc bnc" id="L5671" title="All 2 branches missed.">                        for (int k = 0; k &lt; 6; ++k) {</span>
<span class="nc bnc" id="L5672" title="All 2 branches missed.">                            if (k == 3) {</span>
<span class="nc" id="L5673">                                desc2[k] = nTot;</span>
                            } else {
<span class="nc" id="L5675">                                desc2[k] = ((desc2[k] * n2) + desc1[k] * n1)/nTot;</span>
                            }
                        }
                        //add unassigned perimeter of short edge to innerqueue
<span class="nc bnc" id="L5679" title="All 2 branches missed.">                        for (PairInt p3 : set1) {</span>
<span class="nc" id="L5680">                            shortPointIndexMap.remove(p3);</span>
<span class="nc" id="L5681">                            pointIndexMap.put(p3, minDiffIndex);</span>
<span class="nc" id="L5682">                            set2.add(p3);</span>
<span class="nc bnc" id="L5683" title="All 2 branches missed.">                            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L5684">                                int x4 = p3.getX() + dxs[k];</span>
<span class="nc" id="L5685">                                int y4 = p3.getY() + dys[k];</span>
<span class="nc bnc" id="L5686" title="All 8 branches missed.">                                if (x4 &lt; 0 || y4 &lt; 0 || (x4 &gt; (width - 1))</span>
                                    || (y4 &gt; (height - 1))) {
<span class="nc" id="L5688">                                    continue;</span>
                                }
<span class="nc" id="L5690">                                PairInt p4 = new PairInt(x4, y4);</span>
<span class="nc bnc" id="L5691" title="All 2 branches missed.">                                if (!shortPointIndexMap.containsKey(p4) &amp;&amp;</span>
<span class="nc bnc" id="L5692" title="All 2 branches missed.">                                    !pointIndexMap.containsKey(p4)) {</span>
<span class="nc" id="L5693">                                    innerQueue.offer(p4);</span>
                                }
                            }
<span class="nc" id="L5696">                        }</span>
<span class="nc" id="L5697">                        clusterDescriptors[idx1] = null;</span>
<span class="nc" id="L5698">                        set1.clear();</span>
<span class="nc" id="L5699">                    } else {</span>
<span class="fc" id="L5700">                        float n2 = set2.size();</span>
<span class="fc" id="L5701">                        float nTot = n2 + 1;</span>
                        //{h, s, v, nPix, cenX, cenY}
<span class="fc" id="L5703">                        desc2[0] = ((desc2[0] * n2) + clrs1[0])/nTot;</span>
<span class="fc" id="L5704">                        desc2[1] = ((desc2[1] * n2) + clrs1[1])/nTot;</span>
<span class="fc" id="L5705">                        desc2[2] = ((desc2[2] * n2) + clrs1[2])/nTot;</span>
<span class="fc" id="L5706">                        desc2[3] = nTot;</span>
<span class="fc" id="L5707">                        desc2[4] = ((desc2[4] * n2) + x)/nTot;</span>
<span class="fc" id="L5708">                        desc2[5] = ((desc2[5] * n2) + y)/nTot;</span>

<span class="fc" id="L5710">                        pointIndexMap.put(p, minDiffIndex);</span>
<span class="fc" id="L5711">                        set2.add(p);</span>
<span class="fc bfc" id="L5712" title="All 2 branches covered.">                        for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L5713">                            int x4 = x + dxs[k];</span>
<span class="fc" id="L5714">                            int y4 = y + dys[k];</span>
<span class="fc bfc" id="L5715" title="All 8 branches covered.">                            if (x4 &lt; 0 || y4 &lt; 0 || (x4 &gt; (width - 1))</span>
                                || (y4 &gt; (height - 1))) {
<span class="fc" id="L5717">                                continue;</span>
                            }
<span class="fc" id="L5719">                            PairInt p4 = new PairInt(x4, y4);</span>
<span class="pc bpc" id="L5720" title="1 of 2 branches missed.">                            if (!shortPointIndexMap.containsKey(p4) &amp;&amp;</span>
<span class="fc bfc" id="L5721" title="All 2 branches covered.">                                !pointIndexMap.containsKey(p4)) {</span>
<span class="fc" id="L5722">                                innerQueue.offer(p4);</span>
                            }
                        }
                    }
<span class="fc" id="L5726">                }</span>
<span class="fc bfc" id="L5727" title="All 2 branches covered.">                if (innerQueue.isEmpty()) {</span>
<span class="fc bfc" id="L5728" title="All 2 branches covered.">                    if (nIter == 0) {</span>
<span class="fc" id="L5729">                        break;</span>
                    }
<span class="pc bpc" id="L5731" title="1 of 2 branches missed.">                    if (!shortPointIndexMap.isEmpty()) {</span>
<span class="nc bnc" id="L5732" title="All 2 branches missed.">                        if (shortPointIndexMap.size() == lastInnerQ) {</span>
<span class="nc" id="L5733">                            return;</span>
                        }
<span class="nc" id="L5735">                        innerQueue.addAll(shortPointIndexMap.keySet());</span>
<span class="nc" id="L5736">                        lastInnerQ = shortPointIndexMap.size();</span>
                    } else {
<span class="fc" id="L5738">                        lastInnerQ = 0;</span>
<span class="fc" id="L5739">                        break;</span>
                    }
                }
<span class="fc" id="L5742">                outerQueue.addAll(innerQueue);</span>
<span class="fc" id="L5743">                innerQueue.clear();</span>
            }
        }

<span class="pc bpc" id="L5747" title="3 of 4 branches missed.">        assert(assertShortEdgesAreEmpty(shortEdgeIndexes, clusterPoints));</span>

<span class="pc bpc" id="L5749" title="3 of 4 branches missed.">        assert(pointIndexMap.size() == img.getNPixels());</span>
<span class="fc" id="L5750">    }</span>

    private void mergeShortEdges(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, int clrSpace, double tColor,
        List&lt;Integer&gt; shortEdgeIndexes) {

        /*
        the paper suggests:
            &quot;The pair of lines where the distance of centroids between them is
            nearest is always merged into one if their color difference is not
            exceeding the predefined threshold Tc.&quot;

        this is only merging a single pair at most for every short edge
        */

        //TODO: consider improvements of this for large shortEdgeIndexes.size()

<span class="fc" id="L5767">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="pc bpc" id="L5769" title="1 of 2 branches missed.">        for (int i = 0; i &lt; shortEdgeIndexes.size(); ++i) {</span>

<span class="nc" id="L5771">            Integer index1 = shortEdgeIndexes.get(i);</span>
<span class="nc" id="L5772">            int idx1 = index1.intValue();</span>
<span class="nc" id="L5773">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="nc bnc" id="L5774" title="All 2 branches missed.">            if (set1.isEmpty()) {</span>
<span class="nc" id="L5775">                continue;</span>
            }

<span class="nc" id="L5778">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="nc bnc" id="L5780" title="All 4 branches missed.">            assert(Math.abs(set1.size() - desc1[3]) &lt; 0.1);</span>

<span class="nc" id="L5782">            double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L5783">            int minDistIdx = -1;</span>

<span class="nc bnc" id="L5785" title="All 2 branches missed.">            for (int j = (i + 1); j &lt; shortEdgeIndexes.size(); ++j) {</span>

<span class="nc" id="L5787">                Integer index2 = shortEdgeIndexes.get(j);</span>
<span class="nc" id="L5788">                int idx2 = index2.intValue();</span>
<span class="nc" id="L5789">                Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="nc bnc" id="L5790" title="All 2 branches missed.">                if (set2.isEmpty()) {</span>
<span class="nc" id="L5791">                    continue;</span>
                }

                //{h, s, v, nPix, cenX, cenY}
<span class="nc" id="L5795">                float[] desc2 = clusterDescriptors[idx2];</span>

<span class="nc bnc" id="L5797" title="All 4 branches missed.">                assert(Math.abs(set2.size() - desc2[3]) &lt; 0.1);</span>

                double diff;
<span class="nc bnc" id="L5800" title="All 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="nc" id="L5801">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2],
                        desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L5805">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L5806">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L5807">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L5808">                    diff = Math.sqrt(diff1 * diff1 + diff2*diff2 + diff3*diff3);</span>
                }

<span class="nc bnc" id="L5811" title="All 2 branches missed.">                if (diff &gt;= tColor) {</span>
<span class="nc" id="L5812">                    continue;</span>
                }

<span class="nc" id="L5815">                float diffX = desc1[4] - desc2[4];</span>
<span class="nc" id="L5816">                float diffY = desc1[5] - desc2[5];</span>
<span class="nc" id="L5817">                double distSq = diffX * diffX + diffY * diffY;</span>

<span class="nc bnc" id="L5819" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L5820">                    minDistSq = distSq;</span>
<span class="nc" id="L5821">                    minDistIdx = idx2;</span>
                }
            }

<span class="nc bnc" id="L5825" title="All 2 branches missed.">            if (minDistIdx == -1) {</span>
<span class="nc" id="L5826">                continue;</span>
            }

            // merge set2 with set1 and update associated data structures
<span class="nc" id="L5830">            Set&lt;PairInt&gt; set2 = clusterPoints.get(minDistIdx);</span>
<span class="nc" id="L5831">            float[] desc2 = clusterDescriptors[minDistIdx];</span>

<span class="nc" id="L5833">            float n1 = set1.size();</span>
<span class="nc" id="L5834">            float n2 = set2.size();</span>
<span class="nc" id="L5835">            float nTot = n1 + n2;</span>

            //{h, s, v, nPix, cenX, cenY}
            // update desc1 contents for contents in desc2
<span class="nc bnc" id="L5839" title="All 2 branches missed.">            for (int k = 0; k &lt; desc1.length; ++k) {</span>
<span class="nc bnc" id="L5840" title="All 2 branches missed.">                if (k == 3) {</span>
<span class="nc" id="L5841">                    desc1[k] = nTot;</span>
                } else {
<span class="nc" id="L5843">                    desc1[k] = ((desc1[k] * n1) + (desc2[k] * n2)) / nTot;</span>
                }
            }
<span class="nc" id="L5846">            clusterDescriptors[minDistIdx] = null;</span>
<span class="nc" id="L5847">            set1.addAll(set2);</span>
<span class="nc" id="L5848">            set2.clear();</span>
        }
<span class="fc" id="L5850">    }</span>

    /**
     * get cie lab or hsv colors from img for coordinates (x, y)
     * @param img
     * @param x
     * @param y
     * @param clrSpace
     * @return
     */
    private float[] getColors(ImageExt img, int x, int y, int clrSpace) {

<span class="pc bpc" id="L5862" title="1 of 2 branches missed.">        if (clrSpace == 0) {</span>
<span class="fc" id="L5863">            float[] lab2 = img.getCIELAB(x, y);</span>
<span class="fc" id="L5864">            return lab2;</span>
        } else {
<span class="nc" id="L5866">            float[] hsv = new float[3];</span>
<span class="nc" id="L5867">            hsv[0] = img.getHue(x, y);</span>
<span class="nc" id="L5868">            hsv[1] = img.getSaturation(x, y);</span>
<span class="nc" id="L5869">            hsv[2] = img.getBrightness(x, y);</span>
<span class="nc" id="L5870">            return hsv;</span>
        }
    }

    private boolean assertDescriptorCounts(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors) {

<span class="nc bnc" id="L5877" title="All 2 branches missed.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="nc" id="L5878">            int n = clusterPoints.get(i).size();</span>
<span class="nc bnc" id="L5879" title="All 2 branches missed.">            if (n == 0) { continue;}</span>
<span class="nc" id="L5880">            float diff = Math.abs(n - clusterDescriptors[i][3]);</span>
<span class="nc bnc" id="L5881" title="All 4 branches missed.">            assert(diff &lt; 0.1);</span>
        }

<span class="nc" id="L5884">        return true;</span>
    }

    private void mergeByColorHistograms(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap,
        int clrSpace, double tR) {

<span class="fc" id="L5892">        int[][][] colorHistograms = calculateColorHistograms(input,</span>
            clusterPoints, clrSpace);

        // key is index1, index2 where index1 &lt; index2
<span class="fc" id="L5896">        Map&lt;PairInt, HeapNode&gt; nodesMap = new HashMap&lt;PairInt, HeapNode&gt;();</span>

<span class="fc" id="L5898">        Heap heap = new Heap();</span>

<span class="fc" id="L5900">        ColorHistogram ch = new ColorHistogram();</span>

        // the histogram intersection range of values
        //   is 0 : nColors * 1
        // so for 3 colors, expect that max similarity is 3.0.
        // need to merge by higher similarity, so need to invert
        //   the keys.
        // 3 - similairty bcomes the new key.
        // a tR of 0.7*3.0 = 2.1 becomes 0.9 and any values larger than
        //    that are less similar...smalled values are more similar
<span class="fc" id="L5910">        double tRInv = 3.0 - tR;</span>

<span class="fc" id="L5912">        long heapKeyFactor = input.getNPixels();</span>

<span class="fc bfc" id="L5914" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>

<span class="fc" id="L5916">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L5917">            int idx1 = index1.intValue();</span>

<span class="fc" id="L5919">            int[][] hist1 = colorHistograms[idx1];</span>
<span class="pc bpc" id="L5920" title="3 of 4 branches missed.">            assert(hist1 != null);</span>

<span class="fc" id="L5922">            Set&lt;Integer&gt; indexes2 = entry.getValue();</span>

<span class="fc bfc" id="L5924" title="All 2 branches covered.">            for (Integer index2 : indexes2) {</span>

<span class="fc" id="L5926">                int idx2 = index2.intValue();</span>

<span class="pc bpc" id="L5928" title="3 of 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p12;
<span class="fc bfc" id="L5930" title="All 2 branches covered.">                if (idx1 &lt; idx2) {</span>
<span class="fc" id="L5931">                    p12 = new PairInt(idx1, idx2);</span>
                } else {
<span class="fc" id="L5933">                    p12 = new PairInt(idx2, idx1);</span>
                }

<span class="fc bfc" id="L5936" title="All 2 branches covered.">                if (nodesMap.containsKey(p12)) {</span>
<span class="fc" id="L5937">                    continue;</span>
                }

<span class="fc" id="L5940">                int[][] hist2 = colorHistograms[index2.intValue()];</span>
<span class="pc bpc" id="L5941" title="3 of 4 branches missed.">                assert(hist2 != null);</span>

<span class="fc" id="L5943">                float similarity = 3.0f - ch.intersection(hist1, hist2);</span>

<span class="fc" id="L5945">                long key = (long)(similarity * (double)heapKeyFactor);</span>
<span class="fc" id="L5946">                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L5947">                node.setData(p12);</span>
<span class="fc" id="L5948">                heap.insert(node);</span>
<span class="fc" id="L5949">                nodesMap.put(p12, node);</span>

<span class="pc bpc" id="L5951" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L5952">            }</span>
<span class="fc" id="L5953">        }</span>

<span class="fc" id="L5955">        int nMerged = 0;</span>

<span class="pc bpc" id="L5957" title="1 of 2 branches missed.">        while(!heap.isEmpty()) {</span>

<span class="fc" id="L5959">            HeapNode node = heap.extractMin();</span>

<span class="fc" id="L5961">            PairInt p12 = (PairInt)node.getData();</span>

<span class="fc" id="L5963">            nodesMap.remove(p12);</span>

            // this is 3.0 - similarity
<span class="fc" id="L5966">            double diff = ((double)node.getKey())/((double)heapKeyFactor);</span>

<span class="fc bfc" id="L5968" title="All 2 branches covered.">            if (diff &gt; tRInv) {</span>
<span class="fc" id="L5969">                break;</span>
            }

<span class="fc" id="L5972">            int idx1 = p12.getX();</span>
<span class="fc" id="L5973">            int idx2 = p12.getY();</span>

<span class="fc" id="L5975">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>
<span class="fc" id="L5976">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>

<span class="pc bpc" id="L5978" title="2 of 4 branches missed.">            if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="nc" id="L5979">                continue;</span>
            }

<span class="fc bfc" id="L5982" title="All 2 branches covered.">            if (set2.size() &gt; set1.size()) {</span>
<span class="fc" id="L5983">                idx1 = p12.getY();</span>
<span class="fc" id="L5984">                idx2 = p12.getX();</span>
<span class="fc" id="L5985">                set1 = set2;</span>
<span class="fc" id="L5986">                set2 = clusterPoints.get(idx2);</span>
            }

            // set1 is largest

<span class="fc" id="L5991">            int[][] hist1 = colorHistograms[idx1];</span>
<span class="fc" id="L5992">            ch.add2To1(hist1, colorHistograms[idx2]);</span>
<span class="fc" id="L5993">            colorHistograms[idx2] = null;</span>

<span class="fc" id="L5995">            float n1 = set1.size();</span>
<span class="fc" id="L5996">            float n2 = set2.size();</span>
<span class="fc" id="L5997">            float nTot = n1 + n2;</span>

<span class="fc" id="L5999">            set1.addAll(set2);</span>
<span class="fc" id="L6000">            set2.clear();</span>

<span class="fc" id="L6002">            Integer index1 = Integer.valueOf(idx1);</span>
<span class="fc" id="L6003">            Integer index2 = Integer.valueOf(idx2);</span>

            // remove the idx1 --&gt; set&lt;integer&gt; pairs from map and heap
            // remove the idx2 --&gt; set&lt;integer&gt; pairs from map and heap
            // update the adjacencyMap
            //   add node for updated idx1 ---&gt; set&lt;integer&gt; to map and node

<span class="fc" id="L6010">            Set&lt;Integer&gt; indexes1 = adjacencyMap.get(index1);</span>
<span class="fc bfc" id="L6011" title="All 2 branches covered.">            for (Integer index3 : indexes1) {</span>
<span class="fc" id="L6012">                int idx3 = index3.intValue();</span>
<span class="fc" id="L6013">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L6014" title="1 of 4 branches missed.">                if (set3.isEmpty() || idx1 == idx3) {</span>
<span class="nc" id="L6015">                    continue;</span>
                }
                PairInt p13;
<span class="fc bfc" id="L6018" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L6019">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L6021">                    p13 = new PairInt(idx3, idx1);</span>
                }
<span class="fc" id="L6023">                HeapNode node3 = nodesMap.get(p13);</span>
<span class="pc bpc" id="L6024" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L6025">                heap.remove(node3);</span>
<span class="fc" id="L6026">                nodesMap.remove(p13);</span>
<span class="pc bpc" id="L6027" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L6028">            }</span>
<span class="fc" id="L6029">            Set&lt;Integer&gt; indexes2 = adjacencyMap.get(index2);</span>
<span class="fc bfc" id="L6030" title="All 2 branches covered.">            for (Integer index3 : indexes2) {</span>
<span class="fc" id="L6031">                int idx3 = index3.intValue();</span>
<span class="fc" id="L6032">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L6033" title="2 of 6 branches missed.">                if (set3.isEmpty() || idx1 == idx3 || idx2 == idx3) {</span>
<span class="nc" id="L6034">                    continue;</span>
                }
                PairInt p23;
<span class="fc bfc" id="L6037" title="All 2 branches covered.">                if (idx2 &lt; idx3) {</span>
<span class="fc" id="L6038">                    p23 = new PairInt(idx2, idx3);</span>
                } else {
<span class="fc" id="L6040">                    p23 = new PairInt(idx3, idx2);</span>
                }
<span class="fc" id="L6042">                HeapNode node3 = nodesMap.get(p23);</span>
<span class="pc bpc" id="L6043" title="3 of 4 branches missed.">                assert(node3 != null);</span>
<span class="fc" id="L6044">                heap.remove(node3);</span>
<span class="fc" id="L6045">                nodesMap.remove(p23);</span>
<span class="pc bpc" id="L6046" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L6047">            }</span>

            //update adjacency map
<span class="fc bfc" id="L6050" title="All 2 branches covered.">            for (Integer index3 : indexes2) {</span>
<span class="fc bfc" id="L6051" title="All 2 branches covered.">                if (!index3.equals(index1)) {</span>
<span class="fc" id="L6052">                    Set&lt;Integer&gt; indexes4 = adjacencyMap.get(index3);</span>
<span class="pc bpc" id="L6053" title="1 of 2 branches missed.">                    if (indexes4 != null) {</span>
<span class="fc" id="L6054">                        indexes4.remove(index2);</span>
<span class="fc" id="L6055">                        indexes4.add(index1);</span>
                    }
                }
<span class="fc" id="L6058">            }</span>
<span class="fc" id="L6059">            indexes1.addAll(indexes2);</span>
<span class="fc" id="L6060">            indexes1.remove(index1);</span>
<span class="fc" id="L6061">            indexes1.remove(index2);</span>
<span class="fc" id="L6062">            adjacencyMap.remove(index2);</span>

            // add nodes back into heap and map for the updated idx1 --&gt; set&lt;integer&gt;
<span class="fc bfc" id="L6065" title="All 2 branches covered.">            for (Integer index3 : indexes1) {</span>
<span class="fc" id="L6066">                int idx3 = index3.intValue();</span>
<span class="fc" id="L6067">                Set&lt;PairInt&gt; set3 = clusterPoints.get(idx3);</span>
<span class="pc bpc" id="L6068" title="3 of 4 branches missed.">                assert(idx1 != idx3);</span>
<span class="pc bpc" id="L6069" title="1 of 2 branches missed.">                if (set3.isEmpty()) {</span>
<span class="nc" id="L6070">                    continue;</span>
                }
<span class="fc" id="L6072">                int[][] hist3 = colorHistograms[idx3];</span>
<span class="pc bpc" id="L6073" title="3 of 4 branches missed.">                assert(hist3 != null);</span>

                PairInt p13;
<span class="fc bfc" id="L6076" title="All 2 branches covered.">                if (idx1 &lt; idx3) {</span>
<span class="fc" id="L6077">                    p13 = new PairInt(idx1, idx3);</span>
                } else {
<span class="fc" id="L6079">                    p13 = new PairInt(idx3, idx1);</span>
                }

<span class="fc" id="L6082">                float similarity3 = 3.0f - ch.intersection(hist1, hist3);</span>

<span class="fc" id="L6084">                long key3 = (long)(similarity3 * (double)heapKeyFactor);</span>
<span class="fc" id="L6085">                HeapNode node3 = new HeapNode(key3);</span>
<span class="fc" id="L6086">                node3.setData(p13);</span>

<span class="fc" id="L6088">                heap.insert(node3);</span>
<span class="fc" id="L6089">                nodesMap.put(p13, node3);</span>
<span class="pc bpc" id="L6090" title="3 of 4 branches missed.">                assert(heap.getNumberOfNodes() == nodesMap.size());</span>
<span class="fc" id="L6091">            }</span>

<span class="fc" id="L6093">            nMerged++;</span>
<span class="fc" id="L6094">        }</span>

<span class="fc" id="L6096">        log.fine(&quot;color histogram nMerged=&quot; + nMerged);</span>
<span class="fc" id="L6097">    }</span>

    public int[][][] calculateColorHistograms(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints, int clrSpace) {

        //0 == cie lab,  1 = hsv, 2 = rgb

<span class="fc" id="L6104">        int n = clusterPoints.size();</span>

<span class="fc" id="L6106">        int[][][] hist = new int[n][][];</span>

<span class="fc" id="L6108">        ColorHistogram ch = new ColorHistogram();</span>

<span class="fc bfc" id="L6110" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="fc" id="L6112">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>

<span class="pc bpc" id="L6114" title="1 of 2 branches missed.">            if (set.isEmpty()) {</span>
<span class="nc" id="L6115">                continue;</span>
            }

<span class="pc bpc" id="L6118" title="1 of 2 branches missed.">            if (clrSpace == 0) {</span>
<span class="fc" id="L6119">                hist[i] = ch.histogramCIELAB(input, set);</span>
<span class="nc bnc" id="L6120" title="All 2 branches missed.">            } else if (clrSpace == 1) {</span>
<span class="nc" id="L6121">                hist[i] = ch.histogramHSV(input, set);</span>
<span class="pc bpc" id="L6122" title="1 of 2 branches missed.">            } if (clrSpace == 2) {</span>
<span class="nc" id="L6123">                hist[i] = ch.histogramRGB(input, set);</span>
            }
        }

<span class="fc" id="L6127">        return hist;</span>
    }

    private Map&lt;Integer, Set&lt;Integer&gt;&gt; createAdjacencyMap(List&lt;Set&lt;PairInt&gt;&gt;
        clusterPoints) {

<span class="fc" id="L6133">        Map&lt;PairInt, Integer&gt; pointIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="fc bfc" id="L6135" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L6136">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L6137">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L6138" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L6139">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L6140">            }</span>
        }

<span class="fc" id="L6143">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L6144">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L6146">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L6148" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>

<span class="fc" id="L6150">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>

<span class="fc" id="L6152">            Set&lt;Integer&gt; indexes2 = new HashSet&lt;Integer&gt;();</span>

<span class="fc bfc" id="L6154" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L6155">                int x = p.getX();</span>
<span class="fc" id="L6156">                int y = p.getY();</span>
<span class="fc bfc" id="L6157" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L6158">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L6159">                    int y2 = y + dys[k];</span>
<span class="fc" id="L6160">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L6161">                    Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L6162" title="All 4 branches covered.">                    if (index2 == null || index2.intValue() == i) {</span>
<span class="fc" id="L6163">                        continue;</span>
                    }
<span class="fc" id="L6165">                    indexes2.add(index2);</span>
                }
<span class="fc" id="L6167">            }</span>

<span class="pc bpc" id="L6169" title="1 of 2 branches missed.">            if (indexes2.isEmpty()) {</span>
<span class="nc" id="L6170">                continue;</span>
            }

            // add these to all point sets in adjacency map

<span class="fc" id="L6175">            indexes2.add(Integer.valueOf(i));</span>

<span class="fc bfc" id="L6177" title="All 2 branches covered.">            for (Integer key : indexes2) {</span>
<span class="fc" id="L6178">                Set&lt;Integer&gt; v = new HashSet&lt;Integer&gt;(indexes2);</span>
<span class="fc" id="L6179">                v.remove(key);</span>

<span class="fc" id="L6181">                Set&lt;Integer&gt; mapV = adjMap.get(key);</span>
<span class="fc bfc" id="L6182" title="All 2 branches covered.">                if (mapV == null) {</span>
<span class="fc" id="L6183">                    adjMap.put(key, v);</span>
                } else {
<span class="fc" id="L6185">                    mapV.addAll(v);</span>
                }
<span class="fc" id="L6187">            }</span>
        }

<span class="fc" id="L6190">        return adjMap;</span>
    }

    private Map&lt;PairInt, Set&lt;Integer&gt;&gt; findUnassignedPixelsAndAdjacentIndexes(
        ImageExt img, Map&lt;PairInt, Integer&gt; pointIndexMap) {

<span class="fc" id="L6196">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; unassignedAndIndexes =</span>
            new HashMap&lt;PairInt, Set&lt;Integer&gt;&gt;();

<span class="fc" id="L6199">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L6200">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L6202">        int w = img.getWidth();</span>
<span class="fc" id="L6203">        int h = img.getHeight();</span>

<span class="fc bfc" id="L6205" title="All 2 branches covered.">        for (int x = 0; x &lt; w; ++x) {</span>
<span class="fc bfc" id="L6206" title="All 2 branches covered.">            for (int y = 0; y &lt; h; ++y) {</span>
<span class="fc" id="L6207">                PairInt p = new PairInt(x, y);</span>
<span class="fc bfc" id="L6208" title="All 2 branches covered.">                if (pointIndexMap.containsKey(p)) {</span>
<span class="fc" id="L6209">                    continue;</span>
                }
<span class="fc" id="L6211">                Set&lt;Integer&gt; adjIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L6212" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L6213">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L6214">                    int y2 = y + dys[k];</span>
<span class="fc" id="L6215">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="fc" id="L6216">                    Integer index2 = pointIndexMap.get(p2);</span>
<span class="fc bfc" id="L6217" title="All 2 branches covered.">                    if (index2 != null) {</span>
<span class="fc" id="L6218">                        adjIndexes.add(index2);</span>
                    }
                }
<span class="fc" id="L6221">                unassignedAndIndexes.put(p, adjIndexes);</span>
            }
        }

<span class="pc bpc" id="L6225" title="3 of 4 branches missed.">        assert(pointIndexMap.size() + unassignedAndIndexes.size() == img.getNPixels());</span>

<span class="fc" id="L6227">        return unassignedAndIndexes;</span>
    }

    private void populateDescriptors(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; pointSets,
        float[][] outputDescripors, int clrSpace) {

        /*
        the descriptors are
             C_i = {h, s, v, nPix, cenX, cenY}  or labL, labA, labB for colorSpace = 0
        */
<span class="fc" id="L6238">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc bfc" id="L6240" title="All 2 branches covered.">        for (int i = 0; i &lt; pointSets.size(); ++i) {</span>

<span class="fc" id="L6242">            Set&lt;PairInt&gt; edgePoints = pointSets.get(i);</span>

<span class="fc" id="L6244">            outputDescripors[i] = new float[6];</span>

<span class="fc" id="L6246">            double[] xyCen = curveHelper.calculateXYCentroids(edgePoints);</span>

<span class="fc" id="L6248">            double c1Sum = 0;</span>
<span class="fc" id="L6249">            double c2Sum = 0;</span>
<span class="fc" id="L6250">            double c3Sum = 0;</span>
<span class="fc bfc" id="L6251" title="All 2 branches covered.">            for (PairInt p : edgePoints) {</span>

<span class="fc" id="L6253">                int x = p.getX();</span>
<span class="fc" id="L6254">                int y = p.getY();</span>

<span class="pc bpc" id="L6256" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L6257">                    float[] lab = img.getCIELAB(x, y);</span>
<span class="fc" id="L6258">                    c1Sum += lab[0];</span>
<span class="fc" id="L6259">                    c2Sum += lab[1];</span>
<span class="fc" id="L6260">                    c3Sum += lab[2];</span>
<span class="fc" id="L6261">                } else {</span>
                    // hsv
<span class="nc" id="L6263">                    c1Sum += img.getHue(x, y);</span>
<span class="nc" id="L6264">                    c2Sum += img.getSaturation(x, y);</span>
<span class="nc" id="L6265">                    c3Sum += img.getBrightness(x, y);</span>
                }
<span class="fc" id="L6267">            }</span>
<span class="fc" id="L6268">            c1Sum /= (float)edgePoints.size();</span>
<span class="fc" id="L6269">            c2Sum /= (float)edgePoints.size();</span>
<span class="fc" id="L6270">            c3Sum /= (float)edgePoints.size();</span>

            //C_i = {h, s, v, nPix, cenX, cenY}
<span class="fc" id="L6273">            outputDescripors[i][0] = (float)c1Sum;</span>
<span class="fc" id="L6274">            outputDescripors[i][1] = (float)c2Sum;</span>
<span class="fc" id="L6275">            outputDescripors[i][2] = (float)c3Sum;</span>
<span class="fc" id="L6276">            outputDescripors[i][3] = edgePoints.size();</span>
<span class="fc" id="L6277">            outputDescripors[i][4] = (float)xyCen[0];</span>
<span class="fc" id="L6278">            outputDescripors[i][5] = (float)xyCen[1];</span>
        }
<span class="fc" id="L6280">    }</span>

    private float[][] condenseAndUpdate(List&lt;Set&lt;PairInt&gt;&gt; clusterPoints,
        float[][] clusterDescriptors, Map&lt;PairInt, Integer&gt; pointIndexMap) {

<span class="fc" id="L6285">        int nNonNull = 0;</span>
<span class="fc bfc" id="L6286" title="All 2 branches covered.">        for (Set&lt;PairInt&gt; set : clusterPoints) {</span>
<span class="fc bfc" id="L6287" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L6288">                nNonNull++;</span>
            }
<span class="fc" id="L6290">        }</span>

<span class="fc" id="L6292">        List&lt;Set&lt;PairInt&gt;&gt; tmp = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>

<span class="fc" id="L6294">        float[][] outputDescriptors = new float[nNonNull][];</span>

<span class="fc bfc" id="L6296" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L6297">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc bfc" id="L6298" title="All 2 branches covered.">            if (!set.isEmpty()) {</span>
<span class="fc" id="L6299">                outputDescriptors[tmp.size()] = clusterDescriptors[i];</span>
<span class="fc" id="L6300">                tmp.add(set);</span>
            }
        }
<span class="fc" id="L6303">        clusterPoints.clear();</span>
<span class="fc" id="L6304">        clusterPoints.addAll(tmp);</span>

<span class="fc" id="L6306">        pointIndexMap.clear();</span>
<span class="fc bfc" id="L6307" title="All 2 branches covered.">        for (int i = 0; i &lt; clusterPoints.size(); ++i) {</span>
<span class="fc" id="L6308">            Set&lt;PairInt&gt; set = clusterPoints.get(i);</span>
<span class="fc" id="L6309">            Integer index = Integer.valueOf(i);</span>
<span class="fc bfc" id="L6310" title="All 2 branches covered.">            for (PairInt p : set) {</span>
<span class="fc" id="L6311">                pointIndexMap.put(p, index);</span>
<span class="fc" id="L6312">            }</span>
        }

<span class="fc" id="L6315">        return outputDescriptors;</span>
    }

    private void mergeSmallClusters(ImageExt img,
        List&lt;Set&lt;PairInt&gt;&gt; clusterPoints, float[][] clusterDescriptors,
        int clrSpace, int tNumber, String debugTag) {

<span class="pc bpc" id="L6322" title="1 of 2 branches missed.">        if (clusterPoints.isEmpty()) {</span>
<span class="nc" id="L6323">            return;</span>
        }

<span class="fc" id="L6326">        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjacencyMap = createAdjacencyMap(</span>
            clusterPoints);

<span class="fc" id="L6329">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc bfc" id="L6331" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>

<span class="fc" id="L6333">            Integer index1 = entry.getKey();</span>

<span class="fc" id="L6335">            int idx1 = index1.intValue();</span>

<span class="fc" id="L6337">            Set&lt;PairInt&gt; set1 = clusterPoints.get(idx1);</span>

<span class="pc bpc" id="L6339" title="1 of 4 branches missed.">            if ((set1.size() &gt; tNumber) || set1.isEmpty()) {</span>
<span class="nc" id="L6340">                continue;</span>
            }

<span class="fc" id="L6343">            Set&lt;Integer&gt; indexes2 = entry.getValue();</span>

            // merge with closest in color

<span class="fc" id="L6347">            float[] desc1 = clusterDescriptors[idx1];</span>

<span class="fc" id="L6349">            double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L6350">            Integer minDiffIndex = null;</span>

<span class="fc bfc" id="L6352" title="All 2 branches covered.">            for (Integer index2 : indexes2) {</span>
<span class="fc" id="L6353">                int idx2 = index2.intValue();</span>
<span class="fc" id="L6354">                Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="fc bfc" id="L6355" title="All 2 branches covered.">                if (set2.isEmpty()) {</span>
<span class="fc" id="L6356">                    continue;</span>
                }
<span class="fc" id="L6358">                float[] desc2 = clusterDescriptors[idx2];</span>
                double diff;
<span class="pc bpc" id="L6360" title="1 of 2 branches missed.">                if (clrSpace == 0) {</span>
<span class="fc" id="L6361">                    diff = Math.abs(cieC.calcDeltaECIE2000(</span>
                        desc1[0], desc1[1], desc1[2], desc2[0], desc2[1], desc2[2]));
                } else {
<span class="nc" id="L6364">                    double diff1 = desc1[0] - desc2[0];</span>
<span class="nc" id="L6365">                    double diff2 = desc1[1] - desc2[1];</span>
<span class="nc" id="L6366">                    double diff3 = desc1[2] - desc2[2];</span>
<span class="nc" id="L6367">                    diff = Math.sqrt(diff1 * diff1 + diff2 * diff2 + diff3 * diff3);</span>
                }
<span class="fc bfc" id="L6369" title="All 2 branches covered.">                if (diff &lt; minDiff) {</span>
<span class="fc" id="L6370">                    minDiff = diff;</span>
<span class="fc" id="L6371">                    minDiffIndex = index2;</span>
                }
<span class="fc" id="L6373">            }</span>

<span class="fc bfc" id="L6375" title="All 2 branches covered.">            if (minDiffIndex == null) {</span>
<span class="fc" id="L6376">                continue;</span>
            }
<span class="fc" id="L6378">            int idx2 = minDiffIndex.intValue();</span>
<span class="fc" id="L6379">            Set&lt;PairInt&gt; set2 = clusterPoints.get(idx2);</span>
<span class="pc bpc" id="L6380" title="3 of 4 branches missed.">            assert(!set2.isEmpty());</span>
<span class="fc" id="L6381">            float[] desc2 = clusterDescriptors[idx2];</span>
<span class="fc" id="L6382">            int n2 = set2.size();</span>
<span class="fc" id="L6383">            int n1 = set1.size();</span>
<span class="fc" id="L6384">            set2.addAll(set1);</span>
<span class="fc" id="L6385">            int nTot = set2.size();</span>
<span class="fc" id="L6386">            set1.clear();</span>

            //{h, s, v, nPix, cenX, cenY}
<span class="fc bfc" id="L6389" title="All 2 branches covered.">            for (int ii = 0; ii &lt; desc1.length; ++ii) {</span>
<span class="fc" id="L6390">                desc2[ii] = ((desc2[ii] * n2) - desc1[ii] * n1) / nTot;</span>
            }
<span class="fc" id="L6392">            desc2[3] = nTot;</span>

<span class="fc" id="L6394">            clusterDescriptors[idx1] = null;</span>
<span class="fc" id="L6395">        }</span>
<span class="fc" id="L6396">    }</span>

    /**
     * order the indexes by decreasing number of neighbors
     * within pixIndexes.
     * runtime complexity is max(O(N*log_2(N)), O(N*9)).
     * @param pixIndexes
     * @param imgWidth
     * @param imgHeight
     * @return
     */
    private ArrayDeque&lt;Integer&gt; populateByNumberOfNeighbors(
        TIntSet pixIndexes, int imgWidth, int imgHeight) {

<span class="fc" id="L6410">        int n = pixIndexes.size();</span>

<span class="fc" id="L6412">        ArrayDeque&lt;Integer&gt; output = new ArrayDeque&lt;Integer&gt;(n);</span>
<span class="pc bpc" id="L6413" title="1 of 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L6414">            return output;</span>
        }

<span class="fc" id="L6417">        int[] idxs = new int[n];</span>
<span class="fc" id="L6418">        int[] nn = new int[n];</span>

<span class="fc" id="L6420">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L6421">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L6423">        int count = 0;</span>
<span class="fc" id="L6424">        TIntIterator iter = pixIndexes.iterator();</span>
<span class="fc bfc" id="L6425" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L6426">            int idx = iter.next();</span>
<span class="fc" id="L6427">            int y = idx/imgWidth;</span>
<span class="fc" id="L6428">            int x = idx - (y * imgWidth);</span>
<span class="fc" id="L6429">            int nc = 0;</span>
<span class="fc bfc" id="L6430" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L6431">                int x2 = x + dxs[k];</span>
<span class="fc" id="L6432">                int y2 = y + dys[k];</span>
<span class="fc bfc" id="L6433" title="All 4 branches covered.">                if (x2 &lt; 0 || x2 &gt; (imgWidth - 1)) {</span>
<span class="fc" id="L6434">                    continue;</span>
                }
<span class="fc bfc" id="L6436" title="All 4 branches covered.">                if (y2 &lt; 0 || y2 &gt; (imgHeight - 1)) {</span>
<span class="fc" id="L6437">                    continue;</span>
                }
<span class="fc" id="L6439">                int pixIdx2 = (y2 * imgWidth) + x2;</span>
<span class="fc bfc" id="L6440" title="All 2 branches covered.">                if (pixIndexes.contains(pixIdx2)) {</span>
<span class="fc" id="L6441">                    nc++;</span>
                }
            }
<span class="fc" id="L6444">            idxs[count] = idx;</span>
<span class="fc" id="L6445">            nn[count] = nc;</span>
<span class="fc" id="L6446">            count++;</span>
<span class="fc" id="L6447">        }</span>

<span class="fc" id="L6449">        MultiArrayMergeSort.sortByDecr(nn, idxs);</span>

<span class="fc bfc" id="L6451" title="All 2 branches covered.">        for (int i = 0; i &lt; nn.length; ++i) {</span>
<span class="fc" id="L6452">            output.add(Integer.valueOf(idxs[i]));</span>
        }

<span class="fc" id="L6455">        return output;</span>
    }

    private List&lt;GroupPixelRGB&gt; calculateRGB(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; sets) {

<span class="nc" id="L6461">        List&lt;GroupPixelRGB&gt; out = new ArrayList&lt;GroupPixelRGB&gt;();</span>

<span class="nc bnc" id="L6463" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : sets) {</span>
<span class="nc" id="L6464">            GroupPixelRGB gp = new GroupPixelRGB(set, input, 0, 0);</span>
<span class="nc" id="L6465">            out.add(gp);</span>
<span class="nc" id="L6466">        }</span>

<span class="nc" id="L6468">        return out;</span>
    }

    private List&lt;Set&lt;PairInt&gt;&gt; copy(
        List&lt;Set&lt;PairInt&gt;&gt; contiguousSets) {

<span class="nc" id="L6474">        List&lt;Set&lt;PairInt&gt;&gt; c = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L6475" title="All 2 branches missed.">        for (int i = 0; i &lt; contiguousSets.size(); ++i) {</span>
<span class="nc" id="L6476">            Set&lt;PairInt&gt; set = contiguousSets.get(i);</span>
<span class="nc" id="L6477">            Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;(set);</span>
<span class="nc" id="L6478">            c.add(set2);</span>
        }

<span class="nc" id="L6481">        return c;</span>
    }

    public void mergeSmallSegments(ImageExt img,
        int[] labels, int sizeLimit, ColorSpace clrSpace) {

<span class="nc" id="L6487">        CIEChromaticity cieC = null;</span>
<span class="nc bnc" id="L6488" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6489">            cieC = new CIEChromaticity();</span>
        }

        //key = label, value = label indexes
<span class="nc" id="L6493">        TIntObjectMap&lt;TIntSet&gt; labelToIndexMap =</span>
<span class="nc" id="L6494">            LabelToColorHelper.createLabelIndexMap(labels);</span>

        // key = label, value = adjacent label indexes
<span class="nc" id="L6497">        TIntObjectMap&lt;TIntSet&gt; adjacencyMap =</span>
<span class="nc" id="L6498">            LabelToColorHelper.createAdjacencyLabelMap(</span>
                img, labels, false);

        //key = label, value = average color in clrSpace
<span class="nc" id="L6502">        TIntObjectMap&lt;Colors&gt; labelColorMap =</span>
            new TIntObjectHashMap&lt;Colors&gt;();

<span class="nc" id="L6505">        TIntObjectMap&lt;Colors&gt; labelRGBMap = new</span>
            TIntObjectHashMap&lt;Colors&gt;();

<span class="nc" id="L6508">        TIntSet merged = new TIntHashSet();</span>

        //labels
<span class="nc" id="L6511">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span>
<span class="nc" id="L6512">        TIntSet labelSet = labelToIndexMap.keySet();</span>
<span class="nc" id="L6513">        TIntIterator iter = labelSet.iterator();</span>
<span class="nc bnc" id="L6514" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L6515">            stack.add(Integer.valueOf(iter.next()));</span>
        }

<span class="nc" id="L6518">        int nSmall = 0;</span>
<span class="nc bnc" id="L6519" title="All 2 branches missed.">        while (!stack.isEmpty()) {</span>
<span class="nc" id="L6520">            int label1 = stack.pop().intValue();</span>
<span class="nc bnc" id="L6521" title="All 2 branches missed.">            if (merged.contains(label1)) {</span>
<span class="nc" id="L6522">                continue;</span>
            }

<span class="nc" id="L6525">            TIntSet set = labelToIndexMap.get(label1);</span>
<span class="nc bnc" id="L6526" title="All 2 branches missed.">            if (set.size() &lt; sizeLimit) {</span>
<span class="nc" id="L6527">                nSmall++;</span>
                // merge w/ closest adjacent above sizeLimit
<span class="nc" id="L6529">                Colors clrs = labelColorMap.get(label1);</span>
<span class="nc" id="L6530">                Colors rgbClrs = labelRGBMap.get(label1);</span>
<span class="nc" id="L6531">                int minLabel = -1;</span>
<span class="nc" id="L6532">                double minDiff = Double.MAX_VALUE;</span>
<span class="nc" id="L6533">                Colors minDiffClrs = null;</span>
<span class="nc" id="L6534">                Colors minDiffRGBClrs = null;</span>

<span class="nc" id="L6536">                TIntSet adj = adjacencyMap.get(label1);</span>
<span class="nc bnc" id="L6537" title="All 2 branches missed.">                if (adj != null) {</span>
<span class="nc" id="L6538">                    TIntIterator iter2 = adj.iterator();</span>
<span class="nc bnc" id="L6539" title="All 2 branches missed.">                    while (iter2.hasNext()) {</span>
<span class="nc" id="L6540">                        int label3 = iter2.next();</span>
<span class="nc bnc" id="L6541" title="All 2 branches missed.">                        if (merged.contains(label3) ||</span>
<span class="nc bnc" id="L6542" title="All 2 branches missed.">                            labelToIndexMap.get(label3).size() &lt; sizeLimit) {</span>
<span class="nc" id="L6543">                            continue;</span>
                        }
<span class="nc bnc" id="L6545" title="All 2 branches missed.">                        if (rgbClrs == null) {</span>
<span class="nc" id="L6546">                            rgbClrs = calculateSetColor(set, img,</span>
                                ColorSpace.RGB);
<span class="nc" id="L6548">                            clrs = calculateSetColor(rgbClrs, clrSpace);</span>
                        }
<span class="nc" id="L6550">                        Colors rgbClrs3 = labelRGBMap.get(label3);</span>
<span class="nc" id="L6551">                        Colors clrs3 = labelColorMap.get(label3);</span>
<span class="nc bnc" id="L6552" title="All 2 branches missed.">                        if (rgbClrs3 == null) {</span>
<span class="nc" id="L6553">                            TIntSet set3 = labelToIndexMap.get(label3);</span>
<span class="nc bnc" id="L6554" title="All 2 branches missed.">                            if (set3.size() &lt; sizeLimit) {</span>
<span class="nc" id="L6555">                                continue;</span>
                            }
<span class="nc" id="L6557">                            rgbClrs3 = calculateSetColor(set3, img,</span>
                                ColorSpace.RGB);
<span class="nc" id="L6559">                            labelRGBMap.put(label3, rgbClrs3);</span>
<span class="nc" id="L6560">                            clrs3 = calculateSetColor(rgbClrs3, clrSpace);</span>
<span class="nc" id="L6561">                            labelColorMap.put(label3, clrs3);</span>
                        }

<span class="nc" id="L6564">                        double diff = colorDiff(clrs, clrs3, clrSpace);</span>
<span class="nc bnc" id="L6565" title="All 2 branches missed.">                        if (diff &lt; 0) {</span>
<span class="nc" id="L6566">                            diff *= -1;</span>
                        }
<span class="nc bnc" id="L6568" title="All 2 branches missed.">                        if (diff &lt; minDiff) {</span>
<span class="nc" id="L6569">                            minDiff = diff;</span>
<span class="nc" id="L6570">                            minLabel = label3;</span>
<span class="nc" id="L6571">                            minDiffClrs = clrs3;</span>
<span class="nc" id="L6572">                            minDiffRGBClrs = rgbClrs3;</span>
                        }
<span class="nc" id="L6574">                    }</span>
                }

<span class="nc bnc" id="L6577" title="All 2 branches missed.">                if (minLabel &gt; -1) {</span>

                    // merge this label's data into minLabel's data

                    //update adjacency maps
<span class="nc" id="L6582">                    TIntSet adjLabels1 = adjacencyMap.get(label1);</span>
<span class="nc" id="L6583">                    TIntIterator iter1 = adjLabels1.iterator();</span>
<span class="nc bnc" id="L6584" title="All 2 branches missed.">                    while (iter1.hasNext()) {</span>
                        // change to adjacent to minLabel instead of label1
<span class="nc" id="L6586">                        int label3 = iter1.next();</span>
<span class="nc bnc" id="L6587" title="All 4 branches missed.">                        if (label3 == minLabel || label3 == label1) {</span>
<span class="nc" id="L6588">                            continue;</span>
                        }
<span class="nc" id="L6590">                        TIntSet adjLabels3 = adjacencyMap.get(label3);</span>
<span class="nc" id="L6591">                        adjLabels3.remove(label1);</span>
<span class="nc" id="L6592">                        adjLabels3.add(minLabel);</span>
<span class="nc" id="L6593">                    }</span>
<span class="nc" id="L6594">                    adjacencyMap.get(minLabel).addAll(adjLabels1);</span>
<span class="nc" id="L6595">                    adjacencyMap.get(minLabel).remove(label1);</span>

                    // reassign label1 indexes to minLabel
<span class="nc" id="L6598">                    TIntSet set1 = labelToIndexMap.get(label1);</span>
<span class="nc" id="L6599">                    float n1 = set.size();</span>
<span class="nc" id="L6600">                    float n2 = set1.size();</span>
<span class="nc" id="L6601">                    float nTot = n1 + n2;</span>
<span class="nc" id="L6602">                    iter1 = set1.iterator();</span>
<span class="nc bnc" id="L6603" title="All 2 branches missed.">                    while (iter1.hasNext()) {</span>
<span class="nc" id="L6604">                        int lIdx = iter1.next();</span>
<span class="nc" id="L6605">                        labels[lIdx] = minLabel;</span>
<span class="nc" id="L6606">                    }</span>

                    // update color maps
<span class="nc" id="L6609">                    int r = Math.round((rgbClrs.getColors()[0]*n1 +</span>
<span class="nc" id="L6610">                        minDiffRGBClrs.getColors()[0]*n2)/nTot);</span>
<span class="nc" id="L6611">                    int g = Math.round((rgbClrs.getColors()[1]*n1 +</span>
<span class="nc" id="L6612">                        minDiffRGBClrs.getColors()[1]*n2)/nTot);</span>
<span class="nc" id="L6613">                    int b = Math.round((rgbClrs.getColors()[2]*n1 +</span>
<span class="nc" id="L6614">                        minDiffRGBClrs.getColors()[2]*n2)/nTot);</span>
<span class="nc" id="L6615">                    minDiffRGBClrs.getColors()[0] = r;</span>
<span class="nc" id="L6616">                    minDiffRGBClrs.getColors()[1] = g;</span>
<span class="nc" id="L6617">                    minDiffRGBClrs.getColors()[2] = b;</span>
<span class="nc bnc" id="L6618" title="All 2 branches missed.">                    if (ColorSpace.RGB.equals(clrSpace)) {</span>
<span class="nc" id="L6619">                        minDiffClrs.getColors()[0] = r;</span>
<span class="nc" id="L6620">                        minDiffClrs.getColors()[1] = g;</span>
<span class="nc" id="L6621">                        minDiffClrs.getColors()[2] = b;</span>
<span class="nc bnc" id="L6622" title="All 2 branches missed.">                    } else if (ColorSpace.HSV.equals(clrSpace)) {</span>
<span class="nc" id="L6623">                        Color.RGBtoHSB(r, g, b, minDiffClrs.getColors());</span>
<span class="nc bnc" id="L6624" title="All 2 branches missed.">                    } else if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6625">                        float[] lab = cieC.rgbToCIELAB(r, g, b);</span>
<span class="nc" id="L6626">                        System.arraycopy(lab, 0, minDiffClrs.getColors(),</span>
                            0, lab.length);
                    }

<span class="nc" id="L6630">                    TIntSet set0 = labelToIndexMap.get(minLabel);</span>
<span class="nc" id="L6631">                    set0.addAll(set);</span>
<span class="nc" id="L6632">                    set.clear();</span>
<span class="nc" id="L6633">                    set0.remove(label1);</span>
<span class="nc" id="L6634">                    set0.remove(minLabel);</span>

<span class="nc" id="L6636">                    merged.add(label1);</span>
<span class="nc" id="L6637">                    stack.add(minLabel);</span>
                }
            }
<span class="nc" id="L6640">        }</span>
<span class="nc" id="L6641">        log.fine(&quot;number of small merges=&quot; + merged.size()</span>
<span class="nc" id="L6642">           + &quot; nSmall=&quot; + nSmall + &quot; nSets=&quot; + labelToIndexMap.size());</span>
<span class="nc" id="L6643">    }</span>

    private Colors calculateSetColor(Colors rgbClrs,
        ColorSpace clrSpace) {

<span class="nc" id="L6648">        CIEChromaticity cieC = null;</span>
<span class="nc bnc" id="L6649" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6650">            cieC = new CIEChromaticity();</span>
        }

<span class="nc" id="L6653">        float r = rgbClrs.getColors()[0];</span>
<span class="nc" id="L6654">        float g = rgbClrs.getColors()[1];</span>
<span class="nc" id="L6655">        float b = rgbClrs.getColors()[2];</span>

<span class="nc bnc" id="L6657" title="All 2 branches missed.">        if (ColorSpace.RGB.equals(clrSpace)) {</span>
<span class="nc" id="L6658">            return new Colors(new float[]{r, g, b});</span>
<span class="nc bnc" id="L6659" title="All 2 branches missed.">        } else if (ColorSpace.HSV.equals(clrSpace)) {</span>
<span class="nc" id="L6660">            float[] hsb = new float[3];</span>
<span class="nc" id="L6661">            Color.RGBtoHSB(Math.round(r), Math.round(g),</span>
<span class="nc" id="L6662">                Math.round(b), hsb);</span>
<span class="nc" id="L6663">            return new Colors(hsb);</span>
<span class="nc bnc" id="L6664" title="All 2 branches missed.">        } else if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6665">            float[] lab = cieC.rgbToCIELAB(</span>
<span class="nc" id="L6666">                Math.round(r), Math.round(g), Math.round(b));</span>
<span class="nc" id="L6667">            return new Colors(lab);</span>
        }

<span class="nc" id="L6670">        throw new IllegalArgumentException(&quot;ColorSpace &quot; +</span>
            clrSpace + &quot; calc is not implemented.&quot;);
    }

    private double colorDiff(Colors clrs1, Colors clrs2,
        ColorSpace clrSpace) {

<span class="nc bnc" id="L6677" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6678">            CIEChromaticity cieC = new CIEChromaticity();</span>
<span class="nc" id="L6679">            double d = cieC.calcDeltaECIE2000(clrs1.getColors(),</span>
<span class="nc" id="L6680">                clrs2.getColors());</span>
<span class="nc" id="L6681">            return d;</span>
<span class="nc bnc" id="L6682" title="All 2 branches missed.">        } else if (ColorSpace.HSV.equals(clrSpace) ||</span>
<span class="nc bnc" id="L6683" title="All 2 branches missed.">            ColorSpace.RGB.equals(clrSpace)) {</span>

<span class="nc" id="L6685">            double diff = 0;</span>
<span class="nc bnc" id="L6686" title="All 2 branches missed.">            for (int i = 0; i &lt; clrs1.getColors().length; ++i) {</span>
<span class="nc" id="L6687">                float d = clrs1.getColors()[i] -</span>
<span class="nc" id="L6688">                    clrs2.getColors()[i];</span>
<span class="nc" id="L6689">                diff = (d * d);</span>
            }

<span class="nc" id="L6692">            return Math.sqrt(diff);</span>
        }

<span class="nc" id="L6695">        throw new IllegalArgumentException(&quot;ColorSpace &quot; +</span>
            clrSpace + &quot; calc is not implemented.&quot;);
    }

    private Colors calculateSetColor(
        TIntSet indexesSet, ImageExt img,
        ColorSpace clrSpace) {

<span class="nc" id="L6703">        CIEChromaticity cieC = null;</span>
<span class="nc bnc" id="L6704" title="All 2 branches missed.">        if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6705">            cieC = new CIEChromaticity();</span>
        }

<span class="nc" id="L6708">        GroupPixelRGB0 gpb = new GroupPixelRGB0();</span>
<span class="nc" id="L6709">        gpb.calculateColors(indexesSet, img, 0, 0);</span>

<span class="nc" id="L6711">        int r = Math.round(gpb.getAvgRed());</span>
<span class="nc" id="L6712">        int g = Math.round(gpb.getAvgGreen());</span>
<span class="nc" id="L6713">        int b = Math.round(gpb.getAvgBlue());</span>
<span class="nc bnc" id="L6714" title="All 2 branches missed.">        if (ColorSpace.RGB.equals(clrSpace)) {</span>
<span class="nc" id="L6715">            return new Colors(new float[]{r, g, b});</span>
<span class="nc bnc" id="L6716" title="All 2 branches missed.">        } else if (ColorSpace.HSV.equals(clrSpace)) {</span>
<span class="nc" id="L6717">            float[] hsb = new float[3];</span>
<span class="nc" id="L6718">            Color.RGBtoHSB(r, g, b, hsb);</span>
<span class="nc" id="L6719">            return new Colors(hsb);</span>
<span class="nc bnc" id="L6720" title="All 2 branches missed.">        } else if (ColorSpace.CIELAB.equals(clrSpace)) {</span>
<span class="nc" id="L6721">            float[] lab = cieC.rgbToCIELAB(r, g, b);</span>
<span class="nc" id="L6722">            return new Colors(lab);</span>
        }

<span class="nc" id="L6725">        throw new IllegalArgumentException(&quot;ColorSpace &quot; +</span>
            clrSpace + &quot; calc is not implemented.&quot;);
    }

    public float[][] createSobelGradient(GreyscaleImage img) {

<span class="nc" id="L6731">        int nPix = img.getNPixels();</span>
<span class="nc" id="L6732">        int width = img.getWidth();</span>
<span class="nc" id="L6733">        int height = img.getHeight();</span>

<span class="nc" id="L6735">        float[][] gradient = new float[width][];</span>
<span class="nc bnc" id="L6736" title="All 2 branches missed.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="nc" id="L6737">            gradient[i] = new float[height];</span>
        }

<span class="nc" id="L6740">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

<span class="nc" id="L6742">        int h = (kernel.length - 1) &gt;&gt; 1;</span>

<span class="nc bnc" id="L6744" title="All 2 branches missed.">        for (int i = 0; i &lt; nPix; ++i) {</span>
<span class="nc" id="L6745">            final int x1 = img.getCol(i);</span>
<span class="nc" id="L6746">            final int y1 = img.getRow(i);</span>

<span class="nc" id="L6748">            float xSum = 0;</span>
<span class="nc" id="L6749">            float ySum = 0;</span>

<span class="nc bnc" id="L6751" title="All 2 branches missed.">            for (int g = 0; g &lt; kernel.length; ++g) {</span>
<span class="nc" id="L6752">                float gg = kernel[g];</span>
<span class="nc bnc" id="L6753" title="All 2 branches missed.">                if (gg == 0) {</span>
<span class="nc" id="L6754">                    continue;</span>
                }

                int x2, y2;
                // calc for X gradient first
<span class="nc" id="L6759">                int delta = g - h;</span>
<span class="nc" id="L6760">                x2 = x1 + delta;</span>
<span class="nc" id="L6761">                y2 = y1;</span>
                // edge corrections.  use replication
<span class="nc bnc" id="L6763" title="All 2 branches missed.">                if (x2 &lt; 0) {</span>
<span class="nc" id="L6764">                    x2 = -1 * x2 - 1;</span>
<span class="nc bnc" id="L6765" title="All 2 branches missed.">                } else if (x2 &gt;= width) {</span>
<span class="nc" id="L6766">                    int diff = x2 - width;</span>
<span class="nc" id="L6767">                    x2 = width - diff - 1;</span>
                }
<span class="nc" id="L6769">                xSum += gg * img.getValue(x2, y2);</span>

                // calc for y
<span class="nc" id="L6772">                y2 = y1 + delta;</span>
<span class="nc" id="L6773">                x2 = x1;</span>
                // edge corrections.  use replication
<span class="nc bnc" id="L6775" title="All 2 branches missed.">                if (y2 &lt; 0) {</span>
<span class="nc" id="L6776">                    y2 = -1 * y2 - 1;</span>
<span class="nc bnc" id="L6777" title="All 2 branches missed.">                } else if (y2 &gt;= height) {</span>
<span class="nc" id="L6778">                    int diff = y2 - height;</span>
<span class="nc" id="L6779">                    y2 = height - diff - 1;</span>
                }
<span class="nc" id="L6781">                ySum += gg * img.getValue(x2, y2);</span>
            }

<span class="nc" id="L6784">            double c = Math.sqrt(xSum * xSum + ySum * ySum);</span>

<span class="nc" id="L6786">            gradient[x1][y1] = (float) c;</span>
        }

<span class="nc" id="L6789">        return gradient;</span>
    }

    /**
     *
     * @param img
     * @param gradientMethod
     * 0=CannyEdgeFilterAdaptiveDeltaE2000,
     * 1=CannyEdgeFilterAdaptive,
     * 2=PhaseCongruencyDetector
     * @param ts timestamp used in debugging image name
     * @return
     */
    public EdgeFilterProducts createGradient(Image img,
        int gradientMethod, long ts) {

<span class="fc" id="L6805">        EdgeFilterProducts products = null;</span>

<span class="pc bpc" id="L6807" title="1 of 2 branches missed.">        if (gradientMethod == 0) {</span>

<span class="nc" id="L6809">            ImageExt imgCp = img.copyToImageExt();</span>
            
<span class="nc" id="L6811">            CannyEdgeFilterAdaptiveDeltaE2000 canny =</span>
                new CannyEdgeFilterAdaptiveDeltaE2000();
<span class="nc" id="L6813">            canny.setOtsuScaleFactor(0.3f);</span>
<span class="nc" id="L6814">            canny.setToUseSingleThresholdIn2LayerFilter();</span>
<span class="nc" id="L6815">            canny.applyFilter(imgCp);</span>

<span class="nc" id="L6817">            products = canny.getFilterProducts();</span>

<span class="pc bpc" id="L6819" title="1 of 2 branches missed.">        } else if (gradientMethod == 1) {</span>
            
<span class="nc" id="L6821">            CannyEdgeFilterAdaptive canny2 = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L6822">            canny2.overrideToNotUseLineThinner();</span>
            //canny2.setOtsuScaleFactor(0.3f);
<span class="nc" id="L6824">            canny2.setToUseSingleThresholdIn2LayerFilter();</span>
<span class="nc" id="L6825">            canny2.applyFilter(img.copyToGreyscale2());</span>

<span class="nc" id="L6827">            products = canny2.getFilterProducts();</span>

<span class="pc bpc" id="L6829" title="1 of 2 branches missed.">        } else if (gradientMethod == 2) {</span>
            
<span class="fc" id="L6831">            products = createPhaseCongruencyGradient(</span>
<span class="fc" id="L6832">                img.copyBlueToGreyscale());</span>

        }

<span class="fc" id="L6836">        return products;</span>
    }

    private int[] calcStdDev(List&lt;GroupAverageColors&gt; listOfColors,
        List&lt;Integer&gt; indexes) {

<span class="nc" id="L6842">        float avgR = 0;</span>
<span class="nc" id="L6843">        float avgG = 0;</span>
<span class="nc" id="L6844">        float avgB = 0;</span>
<span class="nc bnc" id="L6845" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L6846">            GroupAverageColors clrs = listOfColors.get(index.intValue());</span>
<span class="nc" id="L6847">            avgR += clrs.getR();</span>
<span class="nc" id="L6848">            avgG += clrs.getG();</span>
<span class="nc" id="L6849">            avgB += clrs.getB();</span>
<span class="nc" id="L6850">        }</span>
<span class="nc" id="L6851">        float length = (float)indexes.size();</span>
<span class="nc" id="L6852">        avgR /= length;</span>
<span class="nc" id="L6853">        avgG /= length;</span>
<span class="nc" id="L6854">        avgB /= length;</span>

<span class="nc" id="L6856">        float stdvR = 0;</span>
<span class="nc" id="L6857">        float stdvG = 0;</span>
<span class="nc" id="L6858">        float stdvB = 0;</span>
<span class="nc bnc" id="L6859" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L6860">            GroupAverageColors clrs = listOfColors.get(index.intValue());</span>
<span class="nc" id="L6861">            float diffR = clrs.getR() - avgR;</span>
<span class="nc" id="L6862">            float diffG = clrs.getG() - avgG;</span>
<span class="nc" id="L6863">            float diffB = clrs.getB() - avgB;</span>
<span class="nc" id="L6864">            stdvR += (diffR * diffR);</span>
<span class="nc" id="L6865">            stdvG += (diffG * diffG);</span>
<span class="nc" id="L6866">            stdvB += (diffB * diffB);</span>
<span class="nc" id="L6867">        }</span>
<span class="nc" id="L6868">        int stdDevR = (int)Math.round(Math.sqrt(stdvR/(length - 1.0f)));</span>
<span class="nc" id="L6869">        int stdDevG = (int)Math.round(Math.sqrt(stdvG/(length - 1.0f)));</span>
<span class="nc" id="L6870">        int stdDevB = (int)Math.round(Math.sqrt(stdvB/(length - 1.0f)));</span>

<span class="nc" id="L6872">        return new int[]{stdDevR, stdDevG, stdDevB};</span>
    }

    public EdgeFilterProducts packageToEdgeProduct(
        PhaseCongruencyDetector.PhaseCongruencyProducts pr) {
        
<span class="fc" id="L6878">        EdgeFilterProducts eProduct = new EdgeFilterProducts();</span>

<span class="fc" id="L6880">        int nCols = pr.getThinned()[0].length;//img.getWidth();</span>
<span class="fc" id="L6881">        int nRows = pr.getThinned().length;//img.getHeight();</span>

<span class="fc" id="L6883">        GreyscaleImage pcImg = new GreyscaleImage(nCols, nRows);</span>
<span class="fc" id="L6884">        double[][] pc = pr.getPhaseCongruency();</span>
<span class="fc bfc" id="L6885" title="All 2 branches covered.">        for (int i = 0; i &lt; pr.getThinned().length; ++i) {</span>
<span class="fc bfc" id="L6886" title="All 2 branches covered.">            for (int j = 0; j &lt; pr.getThinned()[i].length; ++j) {</span>
<span class="fc bfc" id="L6887" title="All 2 branches covered.">                if (pr.getThinned()[i][j] &gt; 0) {</span>
<span class="fc" id="L6888">                    int v = (int)Math.round(255. * pc[i][j]);</span>
<span class="fc" id="L6889">                    pcImg.setValue(j, i, v);</span>
                }
            }
        }

<span class="fc" id="L6894">        eProduct.setGradientXY(pcImg);</span>

<span class="fc" id="L6896">        GreyscaleImage paImg = new GreyscaleImage(nCols, nRows,</span>
            GreyscaleImage.Type.Bits32FullRangeInt);
        // range -pi to pi
<span class="fc" id="L6899">        double[][] pa = pr.getPhaseAngle();</span>
<span class="fc bfc" id="L6900" title="All 2 branches covered.">        for (int i = 0; i &lt; pa.length; ++i) {</span>
<span class="fc bfc" id="L6901" title="All 2 branches covered.">            for (int j = 0; j &lt; pa[i].length; ++j) {</span>
<span class="fc" id="L6902">                double v = pa[i][j];</span>
<span class="fc" id="L6903">                int d = (int)Math.round(v * 180./Math.PI);</span>
<span class="fc" id="L6904">                paImg.setValue(j, i, d);</span>
            }
        }
<span class="fc" id="L6907">        eProduct.setPhaseAngle(paImg);</span>

<span class="fc" id="L6909">        GreyscaleImage orImg = new GreyscaleImage(nCols, nRows);</span>
<span class="fc" id="L6910">        double[][] or = pr.getOrientation();</span>
        // orientation is already in range 0 to 180
<span class="fc bfc" id="L6912" title="All 2 branches covered.">        for (int i = 0; i &lt; or.length; ++i) {</span>
<span class="fc bfc" id="L6913" title="All 2 branches covered.">            for (int j = 0; j &lt; or[i].length; ++j) {</span>
<span class="fc" id="L6914">                double v = or[i][j];</span>
<span class="fc" id="L6915">                orImg.setValue(j, i, (int)Math.round(v));</span>
            }
        }
<span class="fc" id="L6918">        eProduct.setTheta(orImg);</span>
        
<span class="fc" id="L6920">        return eProduct;</span>
    }
    
    public EdgeFilterProducts createPhaseCongruencyGradient(
        GreyscaleImage img) {
        
<span class="fc" id="L6926">        PhaseCongruencyDetector phaseDetector = new PhaseCongruencyDetector();</span>
<span class="fc" id="L6927">        phaseDetector.setK(2);</span>
        
<span class="fc" id="L6929">        PhaseCongruencyDetector.PhaseCongruencyProducts pr =</span>
<span class="fc" id="L6930">            phaseDetector.phaseCongMono(img);</span>

<span class="fc" id="L6932">        EdgeFilterProducts eProduct = packageToEdgeProduct(pr);</span>
        
<span class="fc" id="L6934">        return eProduct;</span>
    }

    /**
     * for the full 8 neighbor region, determine whether nulling the pixel
     * at (col, row) would disconnect the remaining line.  Note that the
     * boolean logic is embedded in the comments.  One should be able to
     * combine the rules for multiple pixel tests to reduce the redundant
     * comparisons for the regions in common.
     *
     * Note, that row and col are expected to be at least 1 pixel distant
     * from the image borders.
     *
     * @param input
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final GreyscaleImage input,
        PairInt[][] neighborCoords, int col, int row, int edgeValue) {

<span class="nc" id="L6955">        int w = input.getWidth();</span>
<span class="nc" id="L6956">        int h = input.getHeight();</span>

<span class="nc bnc" id="L6958" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L6962">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc bnc" id="L7004" title="All 2 branches missed.">        boolean t6 = (input.getValue(neighborCoords[0][2].getX() + col,</span>
<span class="nc" id="L7005">            neighborCoords[0][2].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7006" title="All 2 branches missed.">        boolean t7 = (input.getValue(neighborCoords[1][2].getX() + col,</span>
<span class="nc" id="L7007">            neighborCoords[1][2].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7008" title="All 2 branches missed.">        boolean t8 = (input.getValue(neighborCoords[2][2].getX() + col,</span>
<span class="nc" id="L7009">            neighborCoords[2][2].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7010" title="All 2 branches missed.">        boolean t11 = (input.getValue(neighborCoords[0][1].getX() + col,</span>
<span class="nc" id="L7011">            neighborCoords[0][1].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7012" title="All 2 branches missed.">        boolean t12 = (input.getValue(neighborCoords[2][1].getX() + col,</span>
<span class="nc" id="L7013">            neighborCoords[2][1].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7014" title="All 2 branches missed.">        boolean t15 = (input.getValue(neighborCoords[0][0].getX() + col,</span>
<span class="nc" id="L7015">            neighborCoords[0][0].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7016" title="All 2 branches missed.">        boolean t16 = (input.getValue(neighborCoords[1][0].getX() + col,</span>
<span class="nc" id="L7017">            neighborCoords[1][0].getY() + row) == edgeValue);</span>
<span class="nc bnc" id="L7018" title="All 2 branches missed.">        boolean t17 = (input.getValue(neighborCoords[2][0].getX() + col,</span>
<span class="nc" id="L7019">            neighborCoords[2][0].getY() + row) == edgeValue);</span>

<span class="nc bnc" id="L7021" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L7022">            return true;</span>
<span class="nc bnc" id="L7023" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7024">            return true;</span>
<span class="nc bnc" id="L7025" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L7026">            return true;</span>
<span class="nc bnc" id="L7027" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L7028">            return true;</span>
<span class="nc bnc" id="L7029" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L7030">            return true;</span>
<span class="nc bnc" id="L7031" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7032">            return true;</span>
<span class="nc bnc" id="L7033" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7034">            return true;</span>
<span class="nc bnc" id="L7035" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7036">            return true;</span>
<span class="nc bnc" id="L7037" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7038">            return true;</span>
<span class="nc bnc" id="L7039" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L7040">            return true;</span>
<span class="nc bnc" id="L7041" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7042">            return true;</span>
<span class="nc bnc" id="L7043" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L7044">            return true;</span>
<span class="nc bnc" id="L7045" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L7046">            return true;</span>
<span class="nc bnc" id="L7047" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L7048">            return true;</span>
<span class="nc bnc" id="L7049" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L7050">            return true;</span>
<span class="nc bnc" id="L7051" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L7052">            return true;</span>
        }

<span class="nc" id="L7055">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final GreyscaleImage input,
        PairInt[][] neighborCoords, int col, int row) {
        
<span class="fc" id="L7073">        int w = input.getWidth();</span>
<span class="fc" id="L7074">        int h = input.getHeight();</span>

<span class="pc bpc" id="L7076" title="4 of 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L7080">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="fc bfc" id="L7122" title="All 2 branches covered.">        boolean t6 = (input.getValue(neighborCoords[0][2].getX() + col,</span>
<span class="fc" id="L7123">            neighborCoords[0][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7124" title="All 2 branches covered.">        boolean t7 = (input.getValue(neighborCoords[1][2].getX() + col,</span>
<span class="fc" id="L7125">            neighborCoords[1][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7126" title="All 2 branches covered.">        boolean t8 = (input.getValue(neighborCoords[2][2].getX() + col,</span>
<span class="fc" id="L7127">            neighborCoords[2][2].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7128" title="All 2 branches covered.">        boolean t11 = (input.getValue(neighborCoords[0][1].getX() + col,</span>
<span class="fc" id="L7129">            neighborCoords[0][1].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7130" title="All 2 branches covered.">        boolean t12 = (input.getValue(neighborCoords[2][1].getX() + col,</span>
<span class="fc" id="L7131">            neighborCoords[2][1].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7132" title="All 2 branches covered.">        boolean t15 = (input.getValue(neighborCoords[0][0].getX() + col,</span>
<span class="fc" id="L7133">            neighborCoords[0][0].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7134" title="All 2 branches covered.">        boolean t16 = (input.getValue(neighborCoords[1][0].getX() + col,</span>
<span class="fc" id="L7135">            neighborCoords[1][0].getY() + row) &gt; 0);</span>
<span class="fc bfc" id="L7136" title="All 2 branches covered.">        boolean t17 = (input.getValue(neighborCoords[2][0].getX() + col,</span>
<span class="fc" id="L7137">            neighborCoords[2][0].getY() + row) &gt; 0);</span>

<span class="pc bpc" id="L7139" title="3 of 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="fc" id="L7140">            return true;</span>
<span class="pc bpc" id="L7141" title="1 of 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="fc" id="L7142">            return true;</span>
<span class="pc bpc" id="L7143" title="5 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="fc" id="L7144">            return true;</span>
<span class="pc bpc" id="L7145" title="1 of 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L7146">            return true;</span>
<span class="pc bpc" id="L7147" title="3 of 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L7148">            return true;</span>
<span class="pc bpc" id="L7149" title="3 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="fc" id="L7150">            return true;</span>
<span class="pc bpc" id="L7151" title="5 of 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7152">            return true;</span>
<span class="fc bfc" id="L7153" title="All 8 branches covered.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="fc" id="L7154">            return true;</span>
<span class="pc bpc" id="L7155" title="2 of 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="fc" id="L7156">            return true;</span>
<span class="pc bpc" id="L7157" title="7 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L7158">            return true;</span>
<span class="pc bpc" id="L7159" title="1 of 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7160">            return true;</span>
<span class="pc bpc" id="L7161" title="3 of 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L7162">            return true;</span>
<span class="fc bfc" id="L7163" title="All 8 branches covered.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="fc" id="L7164">            return true;</span>
<span class="pc bpc" id="L7165" title="5 of 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L7166">            return true;</span>
<span class="pc bpc" id="L7167" title="5 of 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L7168">            return true;</span>
<span class="pc bpc" id="L7169" title="7 of 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L7170">            return true;</span>
        }

<span class="fc" id="L7173">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @param w width of image
     * @param h height of image
     * @return
     */
    public static boolean doesDisconnect(final Set&lt;PairInt&gt; input,
        PairInt[][] neighborCoords, int col, int row, int w, int h) {

<span class="nc bnc" id="L7193" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L7197">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc" id="L7239">        boolean t6 = input.contains(</span>
<span class="nc" id="L7240">            new PairInt(neighborCoords[0][2].getX() + col,</span>
<span class="nc" id="L7241">            neighborCoords[0][2].getY() + row));</span>
<span class="nc" id="L7242">        boolean t7 = input.contains(</span>
<span class="nc" id="L7243">            new PairInt(neighborCoords[1][2].getX() + col,</span>
<span class="nc" id="L7244">            neighborCoords[1][2].getY() + row));</span>
<span class="nc" id="L7245">        boolean t8 = input.contains(</span>
<span class="nc" id="L7246">            new PairInt(neighborCoords[2][2].getX() + col,</span>
<span class="nc" id="L7247">            neighborCoords[2][2].getY() + row));</span>
<span class="nc" id="L7248">        boolean t11 = input.contains(</span>
<span class="nc" id="L7249">            new PairInt(neighborCoords[0][1].getX() + col,</span>
<span class="nc" id="L7250">            neighborCoords[0][1].getY() + row));</span>
<span class="nc" id="L7251">        boolean t12 = input.contains(</span>
<span class="nc" id="L7252">            new PairInt(neighborCoords[2][1].getX() + col,</span>
<span class="nc" id="L7253">            neighborCoords[2][1].getY() + row));</span>
<span class="nc" id="L7254">        boolean t15 = input.contains(</span>
<span class="nc" id="L7255">            new PairInt(neighborCoords[0][0].getX() + col,</span>
<span class="nc" id="L7256">            neighborCoords[0][0].getY() + row));</span>
<span class="nc" id="L7257">        boolean t16 = input.contains(</span>
<span class="nc" id="L7258">            new PairInt(neighborCoords[1][0].getX() + col,</span>
<span class="nc" id="L7259">            neighborCoords[1][0].getY() + row));</span>
<span class="nc" id="L7260">        boolean t17 = input.contains(</span>
<span class="nc" id="L7261">            new PairInt(neighborCoords[2][0].getX() + col,</span>
<span class="nc" id="L7262">            neighborCoords[2][0].getY() + row));</span>

<span class="nc bnc" id="L7264" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L7265">            return true;</span>
<span class="nc bnc" id="L7266" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7267">            return true;</span>
<span class="nc bnc" id="L7268" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L7269">            return true;</span>
<span class="nc bnc" id="L7270" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L7271">            return true;</span>
<span class="nc bnc" id="L7272" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L7273">            return true;</span>
<span class="nc bnc" id="L7274" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7275">            return true;</span>
<span class="nc bnc" id="L7276" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7277">            return true;</span>
<span class="nc bnc" id="L7278" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7279">            return true;</span>
<span class="nc bnc" id="L7280" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7281">            return true;</span>
<span class="nc bnc" id="L7282" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L7283">            return true;</span>
<span class="nc bnc" id="L7284" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7285">            return true;</span>
<span class="nc bnc" id="L7286" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L7287">            return true;</span>
<span class="nc bnc" id="L7288" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L7289">            return true;</span>
<span class="nc bnc" id="L7290" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L7291">            return true;</span>
<span class="nc bnc" id="L7292" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L7293">            return true;</span>
<span class="nc bnc" id="L7294" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L7295">            return true;</span>
        }

<span class="nc" id="L7298">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @param w width of image
     * @param h height of image
     * @return
     */
    public static boolean doesDisconnect(final TIntSet input,
        PairInt[][] neighborCoords, int col, int row, int w, int h) {

<span class="nc bnc" id="L7318" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L7322">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc" id="L7364">        boolean t6 = input.contains(</span>
<span class="nc" id="L7365">            ((neighborCoords[0][2].getY() + row) * w) +</span>
<span class="nc" id="L7366">            neighborCoords[0][2].getX() + col);</span>
<span class="nc" id="L7367">        boolean t7 = input.contains(</span>
<span class="nc" id="L7368">            ((neighborCoords[1][2].getY() + row) * w) +</span>
<span class="nc" id="L7369">            neighborCoords[1][2].getX() + col);</span>
<span class="nc" id="L7370">        boolean t8 = input.contains(</span>
<span class="nc" id="L7371">            ((neighborCoords[2][2].getY() + row) * w) +</span>
<span class="nc" id="L7372">            neighborCoords[2][2].getX() + col);</span>
<span class="nc" id="L7373">        boolean t11 = input.contains(</span>
<span class="nc" id="L7374">            ((neighborCoords[0][1].getY() + row) * w) +</span>
<span class="nc" id="L7375">            neighborCoords[0][1].getX() + col);</span>
<span class="nc" id="L7376">        boolean t12 = input.contains(</span>
<span class="nc" id="L7377">            ((neighborCoords[2][1].getY() + row) * w) +</span>
<span class="nc" id="L7378">            neighborCoords[2][1].getX() + col);</span>
<span class="nc" id="L7379">        boolean t15 = input.contains(</span>
<span class="nc" id="L7380">            ((neighborCoords[0][0].getY() + row) * w) +</span>
<span class="nc" id="L7381">            neighborCoords[0][0].getX() + col);</span>
<span class="nc" id="L7382">        boolean t16 = input.contains(</span>
<span class="nc" id="L7383">            ((neighborCoords[1][0].getY() + row) * w) +</span>
<span class="nc" id="L7384">            neighborCoords[1][0].getX() + col);</span>
<span class="nc" id="L7385">        boolean t17 = input.contains(</span>
<span class="nc" id="L7386">            ((neighborCoords[2][0].getY() + row) * w) +</span>
<span class="nc" id="L7387">            neighborCoords[2][0].getX() + col);</span>

<span class="nc bnc" id="L7389" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L7390">            return true;</span>
<span class="nc bnc" id="L7391" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7392">            return true;</span>
<span class="nc bnc" id="L7393" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L7394">            return true;</span>
<span class="nc bnc" id="L7395" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L7396">            return true;</span>
<span class="nc bnc" id="L7397" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L7398">            return true;</span>
<span class="nc bnc" id="L7399" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7400">            return true;</span>
<span class="nc bnc" id="L7401" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7402">            return true;</span>
<span class="nc bnc" id="L7403" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7404">            return true;</span>
<span class="nc bnc" id="L7405" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7406">            return true;</span>
<span class="nc bnc" id="L7407" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L7408">            return true;</span>
<span class="nc bnc" id="L7409" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7410">            return true;</span>
<span class="nc bnc" id="L7411" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L7412">            return true;</span>
<span class="nc bnc" id="L7413" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L7414">            return true;</span>
<span class="nc bnc" id="L7415" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L7416">            return true;</span>
<span class="nc bnc" id="L7417" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L7418">            return true;</span>
<span class="nc bnc" id="L7419" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L7420">            return true;</span>
        }

<span class="nc" id="L7423">        return false;</span>
    }

    /**
     * for input with zeros for non-neighbor pixels else any value,
     * look within the neighborhood of point (col, row) to see if there are
     * edges points to either side of the point that would be disconnected
     * if this one were removed.   A non-edge point is defined as having value 0.
     *
     * @param input
     * @param neighborCoords
     * @param col
     * @param row
     * @return
     */
    public static boolean doesDisconnect(final double[][] input,
        PairInt[][] neighborCoords, int col, int row) {

<span class="nc" id="L7441">        int w = input.length;</span>
<span class="nc" id="L7442">        int h = input[0].length;</span>

<span class="nc bnc" id="L7444" title="All 8 branches missed.">        if (((col - 1) &lt; 0) || ((row - 1) &lt; 0) || ((col + 1) &gt; (w - 1)) ||</span>
            ((row + 1) &gt; (h - 1))) {
            // general rule so that invoker doesn't disconnect a line that is
            // connected to image boundaries
<span class="nc" id="L7448">            return true;</span>
        }

        /*
        coordinates of the 8 neighbors as already created PairInts without
        bound checks.
        indexes are found as +1 of the difference relative to center,
        for example, a point for (col-1, row-1) is found as neighborCoords[0][0]
        */

         /*
            6  7  8      +1  2      transformed by 90 rot:     15  11  6
           11 *C* 12     0   1                                 16  C*  7
           15  16 17     -1  0                                 17  12  8

           -1  0   1
            0  1   2

        disconnects:
           -- if (6) &amp;&amp; (8) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16) || !(12))
           -- if (6) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; (!(11) || !(16))
           -- if (6) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(16) || !(12) || !(7))
           -- if (6) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(11)
           -- if (6) &amp;&amp; (17) &amp;&amp; ( (!(7) || !(12)) &amp;&amp; (!(11) || !(16)) )
           -- if (7) &amp;&amp; (15) &amp;&amp; !(11) &amp;&amp; (!(12) || !(16))
           -- if (7) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(11) || !(16))
           -- if (7) &amp;&amp; (16) &amp;&amp; !(11) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (11) &amp;&amp; !(7) &amp;&amp; (!(12) || !(16))
           -- if (8) &amp;&amp; (17) &amp;&amp; !(12) &amp;&amp; (!(16) || !(11) || !(7))
           -- if (8) &amp;&amp; (16) &amp;&amp; !(7) &amp;&amp; !(12)
           -- if (8) &amp;&amp; (15) &amp;&amp; ( (!(7) || !(11)) &amp;&amp; (!(12) || !(16)) )
           -- if (11) &amp;&amp; (12) &amp;&amp; !(7) &amp;&amp; !(16)
           -- if (11) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(7) || !(12))
           -- if (12) &amp;&amp; (15) &amp;&amp; !(16) &amp;&amp; (!(7) || !(11))
           -- if (15) &amp;&amp; (17) &amp;&amp; !(16) &amp;&amp; (!(11) || !(7) || !(12))

        does not disconnect
           -- if (6 || 7 || 8) &amp;&amp; !(15) &amp;&amp; !(16) &amp;&amp; !(17) &amp;&amp; !(11) &amp;&amp; !(12)

        then rotate 90 and test, then rotate 90 and test, then rotate 90 and test
        */

<span class="nc" id="L7490">        boolean t6 = (input[neighborCoords[0][2].getX() + col][</span>
<span class="nc bnc" id="L7491" title="All 2 branches missed.">            neighborCoords[0][2].getY() + row] &gt; 0);</span>
<span class="nc" id="L7492">        boolean t7 = (input[neighborCoords[1][2].getX() + col][</span>
<span class="nc bnc" id="L7493" title="All 2 branches missed.">            neighborCoords[1][2].getY() + row] &gt; 0);</span>
<span class="nc" id="L7494">        boolean t8 = (input[neighborCoords[2][2].getX() + col][</span>
<span class="nc bnc" id="L7495" title="All 2 branches missed.">            neighborCoords[2][2].getY() + row] &gt; 0);</span>
<span class="nc" id="L7496">        boolean t11 = (input[neighborCoords[0][1].getX() + col][</span>
<span class="nc bnc" id="L7497" title="All 2 branches missed.">            neighborCoords[0][1].getY() + row] &gt; 0);</span>
<span class="nc" id="L7498">        boolean t12 = (input[neighborCoords[2][1].getX() + col][</span>
<span class="nc bnc" id="L7499" title="All 2 branches missed.">            neighborCoords[2][1].getY() + row] &gt; 0);</span>
<span class="nc" id="L7500">        boolean t15 = (input[neighborCoords[0][0].getX() + col][</span>
<span class="nc bnc" id="L7501" title="All 2 branches missed.">            neighborCoords[0][0].getY() + row] &gt; 0);</span>
<span class="nc" id="L7502">        boolean t16 = (input[neighborCoords[1][0].getX() + col][</span>
<span class="nc bnc" id="L7503" title="All 2 branches missed.">            neighborCoords[1][0].getY() + row] &gt; 0);</span>
<span class="nc" id="L7504">        boolean t17 = (input[neighborCoords[2][0].getX() + col][</span>
<span class="nc bnc" id="L7505" title="All 2 branches missed.">            neighborCoords[2][0].getY() + row] &gt; 0);</span>

<span class="nc bnc" id="L7507" title="All 12 branches missed.">       if ((t6) &amp;&amp; (t8) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16) || !(t12))) {</span>
<span class="nc" id="L7508">            return true;</span>
<span class="nc bnc" id="L7509" title="All 10 branches missed.">        } else if ((t6) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7510">            return true;</span>
<span class="nc bnc" id="L7511" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t16) || !(t12) || !(t7))) {</span>
<span class="nc" id="L7512">            return true;</span>
<span class="nc bnc" id="L7513" title="All 8 branches missed.">        } else if ((t6) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t11)) {</span>
<span class="nc" id="L7514">            return true;</span>
<span class="nc bnc" id="L7515" title="All 12 branches missed.">        } else if ((t6) &amp;&amp; (t17) &amp;&amp; ( (!(t7) || !(t12)) &amp;&amp; (!(t11) || !(t16)) )) {</span>
<span class="nc" id="L7516">            return true;</span>
<span class="nc bnc" id="L7517" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t15) &amp;&amp; !(t11) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7518">            return true;</span>
<span class="nc bnc" id="L7519" title="All 10 branches missed.">        } else if ((t7) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t11) || !(t16))) {</span>
<span class="nc" id="L7520">            return true;</span>
<span class="nc bnc" id="L7521" title="All 8 branches missed.">        } else if ((t7) &amp;&amp; (t16) &amp;&amp; !(t11) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7522">            return true;</span>
<span class="nc bnc" id="L7523" title="All 10 branches missed.">        } else if ((t8) &amp;&amp; (t11) &amp;&amp; !(t7) &amp;&amp; (!(t12) || !(t16))) {</span>
<span class="nc" id="L7524">            return true;</span>
<span class="nc bnc" id="L7525" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t17) &amp;&amp; !(t12) &amp;&amp; (!(t16) || !(t11) || !(t7))) {</span>
<span class="nc" id="L7526">            return true;</span>
<span class="nc bnc" id="L7527" title="All 8 branches missed.">        } else if ((t8) &amp;&amp; (t16) &amp;&amp; !(t7) &amp;&amp; !(t12)) {</span>
<span class="nc" id="L7528">            return true;</span>
<span class="nc bnc" id="L7529" title="All 12 branches missed.">        } else if ((t8) &amp;&amp; (t15) &amp;&amp; ( (!(t7) || !(t11)) &amp;&amp; (!(t12) || !(t16)) )) {</span>
<span class="nc" id="L7530">            return true;</span>
<span class="nc bnc" id="L7531" title="All 8 branches missed.">        } else if ((t11) &amp;&amp; (t12) &amp;&amp; !(t7) &amp;&amp; !(t16)) {</span>
<span class="nc" id="L7532">            return true;</span>
<span class="nc bnc" id="L7533" title="All 10 branches missed.">        } else if ((t11) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t12))) {</span>
<span class="nc" id="L7534">            return true;</span>
<span class="nc bnc" id="L7535" title="All 10 branches missed.">        } else if ((t12) &amp;&amp; (t15) &amp;&amp; !(t16) &amp;&amp; (!(t7) || !(t11))) {</span>
<span class="nc" id="L7536">            return true;</span>
<span class="nc bnc" id="L7537" title="All 12 branches missed.">        } else if ((t15) &amp;&amp; (t17) &amp;&amp; !(t16) &amp;&amp; (!(t11) || !(t7) || !(t12))) {</span>
<span class="nc" id="L7538">            return true;</span>
        }

<span class="nc" id="L7541">        return false;</span>
    }

    /**
     * given a greyscale image, makes edges (0's are edges and the background
     * is 255).
     * @param img
     * @param debugTag
     */
    public void createEdges02(GreyscaleImage img, String debugTag) {

<span class="nc" id="L7552">        GreyscaleImage greyGradient2 = img.copyImage();</span>

<span class="nc" id="L7554">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L7555">        imageProcessor.blur(greyGradient2, SIGMA.ONE);</span>

//TODO: an adaptive gradient might help here

<span class="nc" id="L7559">        CannyEdgeFilterAdaptive fl = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L7560">        fl.applyFilter(greyGradient2);</span>
<span class="nc" id="L7561">        removeIsolatedPixels(greyGradient2, 0, 255, true);</span>
<span class="nc" id="L7562">        removeIsolatedPixels(greyGradient2, 255, 0, true);</span>
<span class="nc" id="L7563">        MedianSmooth s = new MedianSmooth();</span>
<span class="nc" id="L7564">        GreyscaleImage tmp2 = s.calculate(greyGradient2, 2, 2);</span>
<span class="nc" id="L7565">        greyGradient2 = tmp2;</span>
<span class="nc bnc" id="L7566" title="All 2 branches missed.">        for (int i = 0; i &lt; greyGradient2.getNPixels(); ++i) {</span>
<span class="nc" id="L7567">            int v = greyGradient2.getValue(i);</span>
<span class="nc bnc" id="L7568" title="All 2 branches missed.">            if (v &gt; 1) {</span>
<span class="nc" id="L7569">                img.setValue(i, 0);</span>
            } else {
<span class="nc" id="L7571">                img.setValue(i, 255);</span>
            }
        }
<span class="nc" id="L7574">        removeEdgesSmallerThanLimit(img, 0, 255, 2);</span>
        //removeIsolatedPixels(img, 0, 255, true);
<span class="nc" id="L7576">    }</span>

    public void createEdges03(GreyscaleImage img, String debugTag) {
<span class="nc" id="L7579">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L7580">        hEq.applyFilter();</span>
<span class="nc" id="L7581">        createEdges02(img, debugTag);</span>
<span class="nc" id="L7582">    }</span>

    public void createEdges01(GreyscaleImage img, String debugTag) {

<span class="nc" id="L7586">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L7587">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L7588">        hEq.applyFilter();</span>
<span class="nc" id="L7589">        CannyEdgeFilterAdaptive cannyFilter = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L7590">        cannyFilter.applyFilter(img);</span>

        //MiscDebug.writeImage(img, &quot;_canny_&quot; + debugTag);

<span class="nc" id="L7594">        setAllNonZeroTo255(img);</span>
<span class="nc" id="L7595">        removeIsolatedPixels(img, 0, 255, false);</span>
<span class="nc" id="L7596">        removeIsolatedPixels(img, 255, 0, true);</span>

<span class="nc" id="L7598">        MedianSmooth s = new MedianSmooth();</span>
<span class="nc" id="L7599">        GreyscaleImage tmp2 = s.calculate(img, 3, 3);</span>

        //MiscDebug.writeImage(tmp2, &quot;tmp_edges01_2_&quot; + debugTag);

<span class="nc" id="L7603">        removeIsolatedPixels(tmp2, 255, 0, true);</span>
<span class="nc" id="L7604">        removeIsolatedPixels(tmp2, 0, 255, true);</span>
<span class="nc" id="L7605">        invertImage(tmp2);</span>
<span class="nc" id="L7606">        imageProcessor.applyAdaptiveMeanThresholding(tmp2, 1);</span>
<span class="nc" id="L7607">        img.resetTo(tmp2);</span>

        //MiscDebug.writeImage(img, &quot;tmp_edges01_3_&quot; + debugTag);
<span class="nc" id="L7610">    }</span>

     /**
     *
     * @param img
     * @param edgeValue
     * @param nonEdgeValue
     * @param limit edges less than or equal to this size will be removed
     */
    public void removeEdgesSmallerThanLimit(GreyscaleImage img, int edgeValue,
        int nonEdgeValue, int limit) {

<span class="nc" id="L7622">        ConnectedValuesFinder finder = new ConnectedValuesFinder(img);</span>
<span class="nc" id="L7623">        finder.setMinimumNumberInCluster(1);</span>
<span class="nc" id="L7624">        finder.setToUse8Neighbors();</span>
<span class="nc" id="L7625">        finder.findGroups(edgeValue);</span>

<span class="nc bnc" id="L7627" title="All 2 branches missed.">        for (int i = 0; i &lt; finder.getNumberOfGroups(); ++i) {</span>
<span class="nc" id="L7628">            TIntSet edge = finder.getXY(i);</span>
<span class="nc bnc" id="L7629" title="All 2 branches missed.">            if (edge.size() &gt; limit) {</span>
<span class="nc" id="L7630">                continue;</span>
            }
<span class="nc" id="L7632">            TIntIterator iter = edge.iterator();</span>
<span class="nc bnc" id="L7633" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L7634">                int pixIdx = iter.next();</span>
<span class="nc" id="L7635">                int y = pixIdx/img.getWidth();</span>
<span class="nc" id="L7636">                int x = pixIdx - (y * img.getWidth());</span>
            
<span class="nc" id="L7638">                img.setValue(x, y, nonEdgeValue);</span>
<span class="nc" id="L7639">            }</span>
        }
<span class="nc" id="L7641">    }</span>

    /**
     * NOT READY FOR USE.
     * create edges for img using phase congruency edges and then sparse color
     * gradients (b-g, g-b, and r-b) to complete the curves.  The results
     * contain closed curves, but need to be followed by merging similar color
     * cells.
     * Note that the returned result contains values 0 or 255 for
     * easier display.  This returned format in the future will likely hold
     * just binary 0 or 1 in a more compact internal structure in the
     * GreyscaleImage.
     * @param img
     * @return edge image holding values 0 or 255
     */
    public GreyscaleImage createColorEdges(Image img) {

<span class="nc" id="L7658">        GreyscaleImage gsImg = img.copyBlueToGreyscale();</span>

<span class="nc" id="L7660">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L7661">        int[] dys = Misc.dy8;</span>

<span class="nc" id="L7663">        final int w = img.getWidth();</span>
<span class="nc" id="L7664">        final int h = img.getHeight();</span>

        // half width of neighbor region
<span class="nc" id="L7667">        final int hN = 2;//3;</span>

<span class="nc" id="L7669">        PhaseCongruencyDetector phaseDetector = new PhaseCongruencyDetector();</span>
        
<span class="nc" id="L7671">        PhaseCongruencyDetector.PhaseCongruencyProducts products =</span>
<span class="nc" id="L7672">            phaseDetector.phaseCongMono(gsImg);</span>

<span class="nc" id="L7674">        int[][] thinned = products.getThinned();</span>
        {
<span class="nc" id="L7676">            GreyscaleImage out2 = gsImg.createWithDimensions();</span>
<span class="nc bnc" id="L7677" title="All 2 branches missed.">            for (int i = 0; i &lt; thinned.length; ++i) {</span>
<span class="nc bnc" id="L7678" title="All 2 branches missed.">                for (int j = 0; j &lt; thinned[i].length; ++j) {</span>
<span class="nc bnc" id="L7679" title="All 2 branches missed.">                    if (thinned[i][j] &gt; 0) {</span>
<span class="nc" id="L7680">                        out2.setValue(j, i, 255);</span>
                    }
                }
            }
<span class="nc" id="L7684">            MiscDebug.writeImage(out2, &quot;_EDGES_grey_&quot;);</span>
        }

<span class="nc" id="L7687">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="nc" id="L7689">        GreyscaleImage edgeImg = null;</span>

        /*
        sparse color gradients:
            0  r-g
            1  b-g
            2  r-b
        */
<span class="nc bnc" id="L7697" title="All 2 branches missed.">        for (int clrIdx = 0; clrIdx &lt; 3; ++clrIdx) {</span>

<span class="nc" id="L7699">            EdgeExtractorSimple extractor = new EdgeExtractorSimple(thinned);</span>
<span class="nc" id="L7700">            extractor.extractEdges();</span>
<span class="nc" id="L7701">            List&lt;PairIntArray&gt; edgeList = extractor.getEdges();</span>
<span class="nc" id="L7702">            Set&lt;PairInt&gt; junctions = extractor.getJunctions();</span>

<span class="nc" id="L7704">            Map&lt;PairInt, Integer&gt; edgeIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="nc bnc" id="L7705" title="All 2 branches missed.">            for (int i = 0; i &lt; edgeList.size(); ++i) {</span>
<span class="nc" id="L7706">                PairIntArray curve = edgeList.get(i);</span>
<span class="nc" id="L7707">                Integer index = Integer.valueOf(i);</span>
<span class="nc bnc" id="L7708" title="All 2 branches missed.">                for (int j = 0; j &lt; curve.getN(); ++j) {</span>
<span class="nc" id="L7709">                    int x = curve.getX(j);</span>
<span class="nc" id="L7710">                    int y = curve.getY(j);</span>
<span class="nc" id="L7711">                    curve.set(j, y, x);</span>

<span class="nc" id="L7713">                    PairInt p = new PairInt(y, x);</span>
<span class="nc" id="L7714">                    edgeIndexMap.put(p, index);</span>
                }
            }
            {
                // junctions are using format a[row][col] so change to GreyscaleImage col, row
<span class="nc" id="L7719">                Set&lt;PairInt&gt; tmp = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L7720" title="All 2 branches missed.">                for (PairInt p : junctions) {</span>
<span class="nc" id="L7721">                    int x = p.getX();</span>
<span class="nc" id="L7722">                    int y = p.getY();</span>
<span class="nc" id="L7723">                    tmp.add(new PairInt(y, x));</span>
<span class="nc" id="L7724">                }</span>
<span class="nc" id="L7725">                junctions.clear();</span>
<span class="nc" id="L7726">                junctions.addAll(tmp);</span>
            }

<span class="nc" id="L7729">            Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>

            // to avoid processing some of the noise, there's a minimum line
            // length for curves used to initialize the stack,
            // but because the edgeextractorsimple prefers to keep curves with
            // junctions separated by the junction, those curves adjacent to
            // junctions, even when small in length, should be processed.

<span class="nc" id="L7737">            Set&lt;Integer&gt; adjToJunction = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L7738" title="All 2 branches missed.">            for (int i = 0; i &lt; edgeList.size(); ++i) {</span>
<span class="nc" id="L7739">                PairIntArray curve = edgeList.get(i);</span>
<span class="nc bnc" id="L7740" title="All 2 branches missed.">                if ((curve instanceof PairIntArrayWithColor)</span>
<span class="nc bnc" id="L7741" title="All 2 branches missed.">                    &amp;&amp; ((PairIntArrayWithColor) curve).isClosedCurve()) {</span>
<span class="nc" id="L7742">                    continue;</span>
                }
<span class="nc" id="L7744">                int n = curve.getN();</span>
<span class="nc" id="L7745">                boolean foundJunction = false;</span>
<span class="nc bnc" id="L7746" title="All 2 branches missed.">                for (int j = 0; j &lt; 2; ++j) {</span>
<span class="nc bnc" id="L7747" title="All 2 branches missed.">                    PairInt p = (j == 0) ?</span>
<span class="nc" id="L7748">                        new PairInt(curve.getX(0), curve.getY(0)) :</span>
<span class="nc" id="L7749">                        new PairInt(curve.getX(n - 1), curve.getY(n - 1));</span>
<span class="nc bnc" id="L7750" title="All 2 branches missed.">                    for (int dIdx = 0; dIdx &lt; dxs.length; ++dIdx) {</span>
<span class="nc" id="L7751">                        int x2 = p.getX() + dxs[dIdx];</span>
<span class="nc" id="L7752">                        int y2 = p.getY() + dys[dIdx];</span>
<span class="nc" id="L7753">                        PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L7754" title="All 2 branches missed.">                        if (junctions.contains(p2)) {</span>
<span class="nc" id="L7755">                            adjToJunction.add(Integer.valueOf(i));</span>
<span class="nc" id="L7756">                            foundJunction = true;</span>
<span class="nc" id="L7757">                            break;</span>
                        } else {
<span class="nc" id="L7759">                            Integer index2 = edgeIndexMap.get(p2);</span>
<span class="nc bnc" id="L7760" title="All 4 branches missed.">                            if (index2 != null &amp;&amp; index2.intValue() != i) {</span>
<span class="nc" id="L7761">                                adjToJunction.add(Integer.valueOf(i));</span>
<span class="nc" id="L7762">                                foundJunction = true;</span>
<span class="nc" id="L7763">                                break;</span>
                            }
                        }
                    }
<span class="nc bnc" id="L7767" title="All 2 branches missed.">                    if (foundJunction) {</span>
<span class="nc" id="L7768">                        break;</span>
                    }
                }
            }

<span class="nc" id="L7773">            Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L7774">            Stack&lt;PairInt&gt; stack = new Stack&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L7775" title="All 2 branches missed.">            for (int i = 0; i &lt; edgeList.size(); ++i) {</span>
<span class="nc" id="L7776">                PairIntArray curve = edgeList.get(i);</span>
<span class="nc" id="L7777">                int n = curve.getN();</span>

<span class="nc bnc" id="L7779" title="All 2 branches missed.">                if ((curve instanceof PairIntArrayWithColor)</span>
<span class="nc bnc" id="L7780" title="All 2 branches missed.">                    &amp;&amp; ((PairIntArrayWithColor) curve).isClosedCurve()) {</span>
<span class="nc" id="L7781">                    continue;</span>
                }
<span class="nc bnc" id="L7783" title="All 4 branches missed.">                if ((n &gt; 4) || adjToJunction.contains(Integer.valueOf(i))) {</span>
<span class="nc" id="L7784">                    PairInt p = new PairInt(curve.getX(0), curve.getY(0));</span>
<span class="nc" id="L7785">                    stack.add(p);</span>
<span class="nc bnc" id="L7786" title="All 2 branches missed.">                    if (n &gt; 1) {</span>
<span class="nc" id="L7787">                        p = new PairInt(curve.getX(n - 1), curve.getY(n - 1));</span>
<span class="nc" id="L7788">                        stack.add(p);</span>
                    }
                }
            }

<span class="nc" id="L7793">            GreyscaleImage outputGradients = gsImg.createFullRangeIntWithDimensions();</span>
<span class="nc" id="L7794">            outputGradients.fill(-1);</span>

<span class="nc" id="L7796">            int sz = 3;</span>
<span class="nc" id="L7797">            int kHL = 3;</span>

<span class="nc bnc" id="L7799" title="All 2 branches missed.">            while (!stack.isEmpty()) {</span>
<span class="nc" id="L7800">                PairInt p = stack.pop();</span>

<span class="nc bnc" id="L7802" title="All 2 branches missed.">                if (visited.contains(p)) {</span>
<span class="nc" id="L7803">                    continue;</span>
                }
<span class="nc" id="L7805">                visited.add(p);</span>
<span class="nc" id="L7806">                Integer index = edgeIndexMap.get(p);</span>
<span class="nc" id="L7807">                final int x = p.getX();</span>
<span class="nc" id="L7808">                final int y = p.getY();</span>
                // quick check to see if this point is adjacent to another edge.
                // and if so, do not process further.
                // also, if any point is out of bounds, can skip processing

<span class="nc bnc" id="L7813" title="All 2 branches missed.">                if (aMemberIsOutOfBounds(x, y, hN, w, h)) {</span>
<span class="nc" id="L7814">                    continue;</span>
                }
<span class="nc bnc" id="L7816" title="All 2 branches missed.">                if (foundAdjacentEdge(x, y, edgeIndexMap, index, 1)) {</span>
<span class="nc" id="L7817">                    continue;</span>
                }

<span class="nc bnc" id="L7820" title="All 4 branches missed.">                if ((x &lt; (sz + kHL)) || (y &lt; (sz + kHL)) ||</span>
<span class="nc bnc" id="L7821" title="All 2 branches missed.">                    (x &gt; (img.getWidth() - 1 - (sz + kHL))) ||</span>
<span class="nc bnc" id="L7822" title="All 2 branches missed.">                    (y &gt; (img.getHeight() - 1 - (sz + kHL)))) {</span>
                    // TODO: need to adjust the sparse gradient method
                    // to handle points ner image boundaries
<span class="nc" id="L7825">                    continue;</span>
                }

<span class="nc" id="L7828">                CannyEdgeFilterLite cnf = new CannyEdgeFilterLite();</span>

<span class="nc" id="L7830">                int len = (2 * (sz + kHL)) + 1;</span>
<span class="nc" id="L7831">                float[] values = new float[len * len];</span>
<span class="nc" id="L7832">                int count = 0;</span>
<span class="nc" id="L7833">                int startX = (x - sz - kHL);</span>
<span class="nc" id="L7834">                int endX = (x + sz + kHL);</span>
<span class="nc" id="L7835">                int startY = (y - sz - kHL);</span>
<span class="nc" id="L7836">                int endY = (y + sz + kHL);</span>
<span class="nc bnc" id="L7837" title="All 2 branches missed.">                for (int xp = startX; xp &lt;= endX; ++xp) {</span>
<span class="nc bnc" id="L7838" title="All 2 branches missed.">                    for (int yp = startY; yp &lt;= endY; ++yp) {</span>
<span class="nc bnc" id="L7839" title="All 2 branches missed.">                        if (clrIdx == 0) {</span>
<span class="nc" id="L7840">                            values[count] = img.getR(xp, yp) - img.getG(xp, yp);</span>
<span class="nc bnc" id="L7841" title="All 2 branches missed.">                        } else if (clrIdx == 1) {</span>
<span class="nc" id="L7842">                            values[count] = img.getB(xp, yp) - img.getG(xp, yp);</span>
<span class="nc bnc" id="L7843" title="All 2 branches missed.">                        } else if (clrIdx == 2) {</span>
<span class="nc" id="L7844">                            values[count] = img.getR(xp, yp) - img.getB(xp, yp);</span>
                        }

<span class="nc" id="L7847">                        count++;</span>
                    }
                }
<span class="nc" id="L7850">                values = MiscMath.rescale(values, 0, 255);</span>
<span class="nc" id="L7851">                Map&lt;PairInt, Integer&gt; scaledValues = new HashMap&lt;PairInt, Integer&gt;();</span>
<span class="nc" id="L7852">                count = 0;</span>
<span class="nc bnc" id="L7853" title="All 2 branches missed.">                for (int xp = startX; xp &lt;= endX; ++xp) {</span>
<span class="nc bnc" id="L7854" title="All 2 branches missed.">                    for (int yp = startY; yp &lt;= endY; ++yp) {</span>
<span class="nc" id="L7855">                        int v = Math.round(values[count]);</span>
<span class="nc" id="L7856">                        scaledValues.put(new PairInt(xp, yp), v);</span>
<span class="nc" id="L7857">                        count++;</span>
                    }
                }

<span class="nc" id="L7861">                cnf.applyFilterToRegion(scaledValues, outputGradients,</span>
                    x - sz, y - sz, x + sz, y + sz);

<span class="nc" id="L7864">                Stack&lt;PairInt&gt; stack2 = new Stack&lt;PairInt&gt;();</span>
<span class="nc" id="L7865">                stack2.add(new PairInt(x, y));</span>

<span class="nc" id="L7867">                PairInt lastPAdded = null;</span>

<span class="nc bnc" id="L7869" title="All 2 branches missed.">                while (!stack2.isEmpty()) {</span>
<span class="nc" id="L7870">                    PairInt pG = stack2.pop();</span>
<span class="nc" id="L7871">                    int max = Integer.MIN_VALUE;</span>
<span class="nc" id="L7872">                    PairInt maxP = null;</span>
<span class="nc bnc" id="L7873" title="All 2 branches missed.">                    for (int dIdx = 0; dIdx &lt; dxs.length; ++dIdx) {</span>
<span class="nc" id="L7874">                        int x2 = pG.getX() + dxs[dIdx];</span>
<span class="nc" id="L7875">                        int y2 = pG.getY() + dys[dIdx];</span>
<span class="nc" id="L7876">                        PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L7877" title="All 2 branches missed.">                        if (edgeIndexMap.containsKey(p2)) {</span>
<span class="nc" id="L7878">                            continue;</span>
                        }
<span class="nc bnc" id="L7880" title="All 2 branches missed.">                        if (countNeighbors(edgeIndexMap, x2, y2) &gt; 2) {</span>
<span class="nc" id="L7881">                            continue;</span>
                        }
<span class="nc" id="L7883">                        int v2 = outputGradients.getValue(x2, y2);</span>
<span class="nc bnc" id="L7884" title="All 4 branches missed.">                        if ((v2 &gt; 0) &amp;&amp; (v2 &gt; max)) {</span>
<span class="nc" id="L7885">                            max = v2;</span>
<span class="nc" id="L7886">                            maxP = p2;</span>
                        }
                    }
<span class="nc bnc" id="L7889" title="All 2 branches missed.">                    if (maxP != null) {</span>
<span class="nc" id="L7890">                        edgeIndexMap.put(maxP, index);</span>
<span class="nc" id="L7891">                        added.add(maxP);</span>
<span class="nc" id="L7892">                        lastPAdded = maxP;</span>

                        // if a point on the boundary of gradient region is found, exit now
<span class="nc bnc" id="L7895" title="All 2 branches missed.">                        if ((Math.abs(maxP.getX() - x) == (sz - 1)) ||</span>
<span class="nc bnc" id="L7896" title="All 2 branches missed.">                            (Math.abs(maxP.getY() - y) == (sz - 1))) {</span>
<span class="nc" id="L7897">                            break;</span>
                        }
<span class="nc" id="L7899">                        stack2.add(maxP);</span>
                    }
<span class="nc" id="L7901">                }</span>
<span class="nc bnc" id="L7902" title="All 2 branches missed.">                if (lastPAdded != null) {</span>
<span class="nc" id="L7903">                    stack.add(lastPAdded);</span>
                }
<span class="nc" id="L7905">            }</span>
<span class="nc" id="L7906">            System.out.println(&quot;number of points added = &quot; + added.size());</span>

<span class="nc bnc" id="L7908" title="All 2 branches missed.">            for (PairInt p : added) {</span>
<span class="nc" id="L7909">                int x = p.getX();</span>
<span class="nc" id="L7910">                int y = p.getY();</span>
<span class="nc" id="L7911">                thinned[y][x] = 1;</span>
<span class="nc" id="L7912">            }</span>

            {
<span class="nc" id="L7915">                edgeImg = gsImg.createWithDimensions();</span>
<span class="nc bnc" id="L7916" title="All 2 branches missed.">                for (int i = 0; i &lt; thinned.length; ++i) {</span>
<span class="nc bnc" id="L7917" title="All 2 branches missed.">                    for (int j = 0; j &lt; thinned[i].length; ++j) {</span>
<span class="nc bnc" id="L7918" title="All 2 branches missed.">                        if (thinned[i][j] &gt; 0) {</span>
<span class="nc" id="L7919">                            edgeImg.setValue(j, i, 255);</span>
                        }
                    }
                }
<span class="nc" id="L7923">                MiscDebug.writeImage(edgeImg, &quot;_EDGES_2_&quot; + clrIdx + &quot;_&quot;);</span>
            }
        }

<span class="nc" id="L7927">        return edgeImg;</span>
    }

    /**
     * NOT READY FOR USE.
     * create edges for img the maximum of sobel edges that are grey
     * (b-g, g-b, and r-b).
     *
     * Note that the returned result contains values 0 or 255 for
     * easier display.  This returned format in the future will likely hold
     * just binary 0 or 1 in a more compact internal structure in the
     * GreyscaleImage.
     * @param img
     * @return edge image holding values 0 or 255
     */
    public GreyscaleImage createColorEdges_2(Image img) {

<span class="nc" id="L7944">        GreyscaleImage[] gradients = new GreyscaleImage[4];</span>

        /*
        0 grey    min:    0    max: 255
        1 r-g     min: -255    max: 255
        2 b-g       &quot;
        3 r-b       &quot;
        */
<span class="nc bnc" id="L7952" title="All 2 branches missed.">        for (int clrIdx = 0; clrIdx &lt; 4; ++clrIdx) {</span>
<span class="nc" id="L7953">            gradients[clrIdx] = new GreyscaleImage(img.getWidth(),</span>
<span class="nc" id="L7954">                img.getHeight(), GreyscaleImage.Type.Bits32FullRangeInt);</span>
<span class="nc bnc" id="L7955" title="All 2 branches missed.">            if (clrIdx == 0) {</span>
<span class="nc bnc" id="L7956" title="All 2 branches missed.">                for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L7957">                    int v = (img.getR(i) + img.getG(i) + img.getB(i))/3;</span>
<span class="nc" id="L7958">                    gradients[clrIdx].setValue(i, v);</span>
                }
<span class="nc bnc" id="L7960" title="All 2 branches missed.">            } else if (clrIdx == 1) {</span>
<span class="nc bnc" id="L7961" title="All 2 branches missed.">                for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L7962">                    int v = img.getR(i) - img.getG(i);</span>
<span class="nc" id="L7963">                    v = (v + 255)/2;</span>
<span class="nc" id="L7964">                    gradients[clrIdx].setValue(i, v);</span>
                }
<span class="nc bnc" id="L7966" title="All 2 branches missed.">            } else if (clrIdx == 2) {</span>
<span class="nc bnc" id="L7967" title="All 2 branches missed.">                for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L7968">                    int v = img.getB(i) - img.getG(i);</span>
<span class="nc" id="L7969">                    v = (v + 255)/2;</span>
<span class="nc" id="L7970">                    gradients[clrIdx].setValue(i, v);</span>
                }
<span class="nc bnc" id="L7972" title="All 2 branches missed.">            } else if (clrIdx == 3) {</span>
<span class="nc bnc" id="L7973" title="All 2 branches missed.">                for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L7974">                    int v = img.getR(i) - img.getB(i);</span>
<span class="nc" id="L7975">                    v = (v + 255)/2;</span>
<span class="nc" id="L7976">                    gradients[clrIdx].setValue(i, v);</span>
                }
            }
<span class="nc" id="L7979">            CannyEdgeFilterLite filter = new CannyEdgeFilterLite();</span>
<span class="nc" id="L7980">            filter.setToUseSobel();</span>
<span class="nc" id="L7981">            filter.setToUseOtsu();</span>
<span class="nc" id="L7982">            filter.applyFilter(gradients[clrIdx]);</span>
        }

<span class="nc" id="L7985">        GreyscaleImage combined =  new GreyscaleImage(img.getWidth(),</span>
<span class="nc" id="L7986">            img.getHeight(), GreyscaleImage.Type.Bits32FullRangeInt);</span>
<span class="nc bnc" id="L7987" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L7988">            int gradientMax = Integer.MIN_VALUE;</span>
<span class="nc" id="L7989">            int maxClrIdx = -1;</span>
<span class="nc bnc" id="L7990" title="All 2 branches missed.">            for (int clrIdx = 0; clrIdx &lt; 4; ++clrIdx) {</span>
<span class="nc" id="L7991">                int v = gradients[clrIdx].getValue(i);</span>
<span class="nc bnc" id="L7992" title="All 2 branches missed.">                if (Math.abs(v) &gt; Math.abs(gradientMax)) {</span>
<span class="nc" id="L7993">                    gradientMax = v;</span>
<span class="nc" id="L7994">                    maxClrIdx = clrIdx;</span>
                }
            }
<span class="nc" id="L7997">            combined.setValue(i, gradientMax);</span>
        }

<span class="nc" id="L8000">        return combined;</span>
    }

    private int[][] copy(int[][] a) {

<span class="nc" id="L8005">        int[][] b = new int[a.length][];</span>
<span class="nc bnc" id="L8006" title="All 2 branches missed.">        for (int i = 0; i &lt; b.length; ++i) {</span>
<span class="nc" id="L8007">            b[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="nc" id="L8010">        return b;</span>
    }

    private boolean assertShortEdgesAreEmpty(List&lt;Integer&gt; indexes,
        List&lt;Set&lt;PairInt&gt;&gt; clusterSets) {

<span class="nc bnc" id="L8016" title="All 2 branches missed.">        for (Integer index : indexes) {</span>
<span class="nc" id="L8017">            Set&lt;PairInt&gt; set = clusterSets.get(index.intValue());</span>
<span class="nc bnc" id="L8018" title="All 4 branches missed.">            assert(set.isEmpty());</span>
<span class="nc" id="L8019">        }</span>

<span class="nc" id="L8021">        return true;</span>
    }

    /**
     * apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
     * (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public void applySuperPixelsAndNormalizedCuts(ImageExt img) {

<span class="fc" id="L8042">        int[] labels = calcSuperPixelsAndNormalizedCutsLabels(img);</span>

<span class="fc" id="L8044">        LabelToColorHelper.applyLabels(img, labels);</span>
<span class="fc" id="L8045">    }</span>

    /**
     * apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
     * (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public void applySuperPixelsAndNormalizedCuts(ImageExt img, int nIter) {

<span class="nc" id="L8065">        int[] labels = calcSuperPixelsAndNormalizedCutsLabels(img, nIter);</span>

<span class="nc" id="L8067">        LabelToColorHelper.applyLabels(img, labels);</span>
<span class="nc" id="L8068">    }</span>

    /**
     * Apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
       (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public int[] calcSuperPixelsAndNormalizedCutsLabels(ImageExt img) {
        int kCell;

<span class="fc" id="L8089">        int avgDimension = (img.getWidth() + img.getHeight()) / 2;</span>

<span class="pc bpc" id="L8091" title="1 of 2 branches missed.">        if (avgDimension &lt; 25) {</span>
<span class="nc" id="L8092">            kCell = 2 * avgDimension;</span>
<span class="fc bfc" id="L8093" title="All 2 branches covered.">        } else if (avgDimension &lt; 100) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 10);
<span class="fc" id="L8095">            kCell = 200;</span>
<span class="pc bpc" id="L8096" title="1 of 2 branches missed.">        } else if (avgDimension &lt; 200) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 10);
<span class="fc" id="L8098">            kCell = 200;</span>
<span class="nc bnc" id="L8099" title="All 2 branches missed.">        } else if (avgDimension &lt; 301) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 100);
<span class="nc" id="L8101">            kCell = 1050;</span>
<span class="nc bnc" id="L8102" title="All 2 branches missed.">        } else if (avgDimension &lt; 400) {</span>
            //kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 350);
<span class="nc" id="L8104">            kCell = 750;</span>
<span class="nc bnc" id="L8105" title="All 2 branches missed.">        } else if (avgDimension &lt; 500) {</span>
<span class="nc" id="L8106">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
<span class="nc" id="L8107">            kCell *= 2;  // creates a more segmented defined labelling</span>
        } else {
            // this section has not been tested well yet
<span class="nc" id="L8110">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
<span class="nc bnc" id="L8111" title="All 2 branches missed.">            if (kCell &gt; 2000) {</span>
<span class="nc" id="L8112">                kCell = 2000;</span>
            }
        }

<span class="fc" id="L8116">        System.out.println(&quot;kCell=&quot; + kCell + &quot; avgDim=&quot; + avgDimension);</span>

<span class="fc" id="L8118">        kCell = 200;</span>
<span class="fc" id="L8119">        int clNorm = 1;</span>

<span class="fc" id="L8121">        SLICSuperPixels slic</span>
            = new SLICSuperPixels(img, kCell, clNorm);
<span class="fc" id="L8123">        slic.calculate();</span>
<span class="fc" id="L8124">        int[] labels = slic.getLabels();</span>

        //ImageExt img2 = img.copyToImageExt();
        //ImageIOHelper.addAlternatingColorLabelsToRegion(img2, labels);
        //MiscDebug.writeImage(img2, &quot;_slic_&quot; + trainingData[i].imgFileName);

<span class="fc" id="L8130">        NormalizedCuts normCuts = new NormalizedCuts();</span>
<span class="fc" id="L8131">        int[] labels2 = normCuts.normalizedCut(img, labels);</span>

<span class="fc" id="L8133">        return labels2;</span>
    }

    /**
     * Apply a super-pixels algorithm followed by normalized cuts to obtain
     * labels that are still slightly over-segmented, but should be helpful
     * for object identification.
     * Note that images with average width and length less than 100 and larger
     * than 500 have not been tested yet for the automatic setting of number of
     * super pixels (large images, espec. might need internal handling in
     * block sizes near 512 to keep the number of super pixels less than 1000
     * to reduce the eigenvector calculations).
       (Note the algorithms implemented are those of
       &quot;SLIC Superpixels Compared to State-of-the-Art Superpixel Methods&quot;
       by Achanta, Appu Shaji,Smith,  Lucchi, Fua, and Suestrun
       and &quot;Normalized Cuts and Image Segmentation&quot;
       by Jianbo Shi and Jitendra Malik)
     * @param img
     */
    public int[] calcSuperPixelsAndNormalizedCutsLabels(ImageExt img, int nIter) {

        int kCell;

<span class="nc" id="L8156">        int avgDimension = (img.getWidth() + img.getHeight()) / 2;</span>

<span class="nc bnc" id="L8158" title="All 2 branches missed.">        if (avgDimension &lt; 25) {</span>
<span class="nc" id="L8159">            kCell = 2 * avgDimension;</span>
<span class="nc bnc" id="L8160" title="All 2 branches missed.">        } else if (avgDimension &lt; 100) {</span>
<span class="nc" id="L8161">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 100);</span>
<span class="nc bnc" id="L8162" title="All 2 branches missed.">        } else if (avgDimension &lt; 500) {</span>
<span class="nc" id="L8163">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
            //kCell *= 2;  // creates a more segmented defined labelling
        } else {
            // this section has not been tested well yet
<span class="nc" id="L8167">            kCell = Math.round((float) (img.getWidth() * img.getHeight()) / 1000);</span>
<span class="nc bnc" id="L8168" title="All 2 branches missed.">            if (kCell &gt; 2000) {</span>
<span class="nc" id="L8169">                kCell = 2000;</span>
            }
        }

<span class="nc" id="L8173">        System.out.println(&quot;kCell=&quot; + kCell);</span>

<span class="nc" id="L8175">        SLICSuperPixels slic = new SLICSuperPixels(img, kCell);</span>
<span class="nc" id="L8176">        slic.calculate();</span>
<span class="nc" id="L8177">        int[] labels = slic.getLabels();</span>

        //ImageExt img2 = img.copyToImageExt();
        //ImageIOHelper.addAlternatingColorLabelsToRegion(img2, labels);
        //MiscDebug.writeImage(img2, &quot;_slic_&quot; + trainingData[i].imgFileName);

<span class="nc bnc" id="L8183" title="All 2 branches missed.">        for (int i = 0; i &lt; nIter; ++i) {</span>

<span class="nc" id="L8185">            NormalizedCuts normCuts = new NormalizedCuts();</span>
<span class="nc" id="L8186">            labels = normCuts.normalizedCut(img, labels);</span>

        }

<span class="nc" id="L8190">        return labels;</span>
    }

    public static class DecimatedData {
        // decimated comparison size is the closest to 128
        // for that have labels, decimated image, perimeter.
        // for decimated sizes 256 and 512, have
        //    decimated images and labels also.
        // that allows for a range of scale up to 4 in
        // feature comparisons
        public TIntObjectMap&lt;TIntSet&gt; fullLabels;

        // note that a small image may have nulls for
        // dimensions larger than it's image.
        // the 128, 256, and 512 decimated images
        public ImageExt[] dImages = new ImageExt[3];
        public int[] dBinFactors = new int[3];

        // first list indexes are for 128, 256, or 512
        // then map indexes are the labels of the segments
        //  and the values of the maps are the characteristics
        //  of those segments
        public List&lt;TIntObjectMap&lt;TIntSet&gt;&gt; dLabeledIndexes
            = new ArrayList&lt;TIntObjectMap&lt;TIntSet&gt;&gt;();
        public List&lt;TIntObjectMap&lt;PairInt&gt;&gt; dLabelCentroids
            = new ArrayList&lt;TIntObjectMap&lt;PairInt&gt;&gt;();
    }

    /**
     * using default spacing of 6 pixels for a feature.
     * @param dd
     * @param decimatedImageIndex
     * @param imgWidth
     * @param imgHeight
     * @return
     */
    public TIntObjectMap&lt;List&lt;PairInt&gt;&gt; calculateKeyPoints(
        DecimatedData dd, int decimatedImageIndex,
        int imgWidth, int imgHeight) {

<span class="fc" id="L8230">        TIntObjectMap&lt;List&lt;PairInt&gt;&gt; output =</span>
            new TIntObjectHashMap&lt;List&lt;PairInt&gt;&gt;();

        /*
        Filling out keypoints across object shape to cover all
        points (including exterior points is allowed).

        Using a BFS search pattern within dSpace limits of
        current center keyPoint.
        */

<span class="fc" id="L8241">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L8242">        int[] dys = Misc.dy8;</span>

        // -dSpace to +dSpace is the feature range along a col or row
<span class="fc" id="L8245">        int dSpace = 6;</span>

<span class="fc" id="L8247">        TIntObjectMap&lt;TIntSet&gt; labeledIndexes =</span>
<span class="fc" id="L8248">            dd.dLabeledIndexes.get(decimatedImageIndex);</span>

<span class="fc" id="L8250">        TIntObjectIterator&lt;TIntSet&gt; iter =</span>
<span class="fc" id="L8251">            labeledIndexes.iterator();</span>

<span class="fc bfc" id="L8253" title="All 2 branches covered.">        for (int sIdx = 0; sIdx &lt; labeledIndexes.size(); ++sIdx) {</span>

<span class="fc" id="L8255">            iter.advance();</span>

<span class="fc" id="L8257">            int label = iter.key();</span>

<span class="fc" id="L8259">            List&lt;PairInt&gt; keyPoints = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L8260">            output.put(label, keyPoints);</span>

<span class="fc" id="L8262">            TIntSet indexes = iter.value();</span>

            // assign keyPoints to cover all of indexes:
            // BFS search within indexes, adding neighbors
            //    within dSpace.

            // key = pixIdx, value = index of keyPoints list
<span class="fc" id="L8269">            TIntIntMap indexKPMap = new TIntIntHashMap();</span>

            // if need speed, can replace q0 with any order of indexes
<span class="fc" id="L8272">            ArrayDeque&lt;Integer&gt; q0 = populateByNumberOfNeighbors(</span>
                indexes, imgWidth, imgHeight);
<span class="fc" id="L8274">            ArrayDeque&lt;Integer&gt; q1 = new ArrayDeque&lt;Integer&gt;();</span>

<span class="fc" id="L8276">            int nIter = 0;</span>
<span class="fc" id="L8277">            Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();</span>
<span class="pc bpc" id="L8278" title="1 of 4 branches missed.">                while (!q0.isEmpty() || !q1.isEmpty()) {</span>
                Integer uIndex;
<span class="fc bfc" id="L8280" title="All 2 branches covered.">                if (!q1.isEmpty()) {</span>
                    // draw from q1 first if any because it searches
                    // current keypoint
<span class="fc" id="L8283">                    uIndex = q1.poll();</span>
                } else {
<span class="fc" id="L8285">                    uIndex = q0.poll();</span>
                }
<span class="fc bfc" id="L8287" title="All 2 branches covered.">                if (visited.contains(uIndex)) {</span>
<span class="fc" id="L8288">                    continue;</span>
                }
<span class="fc" id="L8290">                visited.add(uIndex);</span>
<span class="fc" id="L8291">                int uIdx = uIndex.intValue();</span>
<span class="fc" id="L8292">                int uY = uIdx / imgWidth;</span>
<span class="fc" id="L8293">                int uX = uIdx - (uY * imgWidth);</span>
                int kpIdx;
                // lookup center point of keyPoint or assign a new
                int xc, yc;
<span class="fc bfc" id="L8297" title="All 2 branches covered.">                if (indexKPMap.containsKey(uIdx)) {</span>
<span class="fc" id="L8298">                    kpIdx = indexKPMap.get(uIdx);</span>
<span class="fc" id="L8299">                    PairInt kp = keyPoints.get(kpIdx);</span>
<span class="fc" id="L8300">                    xc = kp.getX();</span>
<span class="fc" id="L8301">                    yc = kp.getY();</span>
<span class="fc" id="L8302">                } else {</span>
<span class="fc" id="L8303">                    PairInt kp = new PairInt(uX, uY);</span>
<span class="fc" id="L8304">                    kpIdx = keyPoints.size();</span>
<span class="fc" id="L8305">                    indexKPMap.put(uIdx, kpIdx);</span>
<span class="fc" id="L8306">                    keyPoints.add(kp);</span>
<span class="fc" id="L8307">                    xc = uX;</span>
<span class="fc" id="L8308">                    yc = uY;</span>
                }
<span class="fc bfc" id="L8310" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L8311">                    int x2 = uX + dxs[k];</span>
<span class="fc bfc" id="L8312" title="All 4 branches covered.">                    if (x2 &lt; 0 || x2 &gt; (imgWidth - 1)) {</span>
<span class="fc" id="L8313">                        continue;</span>
                    }
<span class="fc" id="L8315">                    int diffX = Math.abs(x2 - xc);</span>
<span class="fc bfc" id="L8316" title="All 2 branches covered.">                    if (diffX &gt; dSpace) {</span>
<span class="fc" id="L8317">                        continue;</span>
                    }
<span class="fc" id="L8319">                    int y2 = uY + dys[k];</span>
<span class="fc bfc" id="L8320" title="All 4 branches covered.">                    if (y2 &lt; 0 || y2 &gt; (imgHeight - 1)) {</span>
<span class="fc" id="L8321">                        continue;</span>
                    }
<span class="fc" id="L8323">                    int diffY = Math.abs(y2 - yc);</span>
<span class="fc bfc" id="L8324" title="All 2 branches covered.">                    if (diffY &gt; dSpace) {</span>
<span class="fc" id="L8325">                        continue;</span>
                    }
<span class="fc" id="L8327">                    int vIdx = (y2 * imgWidth) + x2;</span>
<span class="fc bfc" id="L8328" title="All 2 branches covered.">                    if (!indexKPMap.containsKey(vIdx)) {</span>
<span class="fc" id="L8329">                        indexKPMap.put(vIdx, kpIdx);</span>
<span class="fc" id="L8330">                        q1.add(Integer.valueOf(vIdx));</span>
                    }
                }
<span class="fc" id="L8333">                nIter++;</span>
<span class="fc" id="L8334">            }</span>
        }

<span class="fc" id="L8337">        return output;</span>
    }

    public void replaceSinglePixelLabelsCIELAB(int[] labels,
        ImageExt img) {

        // ----- replace single pixels w/ adjacent nearest in color -----
<span class="fc" id="L8344">        int[] dx2 = Misc.dx4;</span>
<span class="fc" id="L8345">        int[] dy2 = Misc.dy4;</span>
        // single pixels should join closest,,,
<span class="fc bfc" id="L8347" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L8348" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L8349">                int pixIdx = img.getInternalIndex(i, j);</span>
<span class="fc" id="L8350">                int v = labels[pixIdx];</span>
<span class="fc" id="L8351">                boolean oneIsSame = false;</span>
<span class="fc bfc" id="L8352" title="All 2 branches covered.">                for (int z = 0; z &lt; dx2.length; ++z) {</span>
<span class="fc" id="L8353">                    int x2 = i + dx2[z];</span>
<span class="fc" id="L8354">                    int y2 = j + dy2[z];</span>
<span class="fc bfc" id="L8355" title="All 6 branches covered.">                    if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (img.getWidth() - 1))</span>
<span class="fc bfc" id="L8356" title="All 2 branches covered.">                        || (y2 &gt; (img.getHeight() - 1))</span>
                        ) {
<span class="fc" id="L8358">                        continue;</span>
                    }
<span class="fc" id="L8360">                    int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="fc" id="L8361">                    int v2 = labels[pixIdx2];</span>
<span class="fc bfc" id="L8362" title="All 2 branches covered.">                    if (v2 == v) {</span>
<span class="fc" id="L8363">                        oneIsSame = true;</span>
<span class="fc" id="L8364">                        break;</span>
                    }
                }
<span class="fc bfc" id="L8367" title="All 2 branches covered.">                if (!oneIsSame) {</span>
<span class="fc" id="L8368">                    float[] lab = img.getCIELAB(pixIdx);</span>
<span class="fc" id="L8369">                    double minDiff = Double.MAX_VALUE;</span>
<span class="fc" id="L8370">                    int minIdx = -1;</span>
<span class="fc bfc" id="L8371" title="All 2 branches covered.">                    for (int z = 0; z &lt; dx2.length; ++z) {</span>
<span class="fc" id="L8372">                        int x2 = i + dx2[z];</span>
<span class="fc" id="L8373">                        int y2 = j + dy2[z];</span>
<span class="fc bfc" id="L8374" title="All 6 branches covered.">                        if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (img.getWidth() - 1))</span>
<span class="fc bfc" id="L8375" title="All 2 branches covered.">                            || (y2 &gt; (img.getHeight() - 1))) {</span>
<span class="fc" id="L8376">                            continue;</span>
                        }
<span class="fc" id="L8378">                        int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="fc" id="L8379">                        float[] lab2 = img.getCIELAB(pixIdx2);</span>
                        
<span class="fc" id="L8381">                        double dClrSq = 0;</span>
<span class="fc bfc" id="L8382" title="All 2 branches covered.">                        for (int i2 = 0; i2 &lt; 3; ++i2) {</span>
<span class="fc" id="L8383">                            float diff = lab[i2] - lab2[i2];</span>
<span class="fc" id="L8384">                            dClrSq += (diff * diff);</span>
                        }
                        
<span class="fc bfc" id="L8387" title="All 2 branches covered.">                        if (dClrSq &lt; minDiff) {</span>
<span class="fc" id="L8388">                            minDiff = dClrSq;</span>
<span class="fc" id="L8389">                            minIdx = pixIdx2;</span>
                        }
                    }
<span class="fc" id="L8392">                    labels[pixIdx] = labels[minIdx];</span>
                }
            }
        }
<span class="fc" id="L8396">    }</span>

    /**
     * segment the image by creating super pixels, then
     * merging them by a polar cie xy clustering
     * algorithm.  NOTE that the later and this method
     * could be improved.  It's a quick look at merging
     * super pixels.  CIE XY color space helps to lessen
     * the effects of grey illumination.
       &lt;pre&gt;
       To visualize the results:
           for (int j = 0; j lt clusterSets.size(); ++j) {
                int[] rgb = ImageIOHelper.getNextRGB(j);
                Set PairInt  set = clusterSets1S.get(j);
                ImageIOHelper.addToImage(set, 0, 0, img1Labeled,
                    nExtraForDot, rgb[0], rgb[1], rgb[2]);
            }
       &lt;/pre&gt;
     * @param input
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; segmentForObjects(
        ImageExt input) {

<span class="nc" id="L8420">        ImageExt img = input.copyToImageExt();</span>

<span class="nc" id="L8422">        int nClusters = 200;</span>

<span class="nc" id="L8424">        SLICSuperPixels slic</span>
            = new SLICSuperPixels(img, nClusters);
<span class="nc" id="L8426">        slic.calculate();</span>
<span class="nc" id="L8427">        int[] labels = slic.getLabels();</span>

<span class="nc" id="L8429">        LabelToColorHelper.applyLabels(img, labels);</span>

<span class="nc" id="L8431">        List&lt;Set&lt;PairInt&gt;&gt; clusterSets =</span>
<span class="nc" id="L8432">            calculateUsingPolarCIEXYAndFrequency(</span>
            img, 0.1f, true);

<span class="nc" id="L8435">        return clusterSets;</span>
    }

    /**
     * examine cieXY polar theta and black, white, and grey
     * pixels to make a list of merged indexes,
     * where the indexes in the return list are the indexes
     * of the given contiguousSets (which has not been modified).
     */
    public List&lt;TIntList&gt;
        mergeUsingPolarCIEXYAndFrequency(ImageExt input,
        List&lt;Set&lt;PairInt&gt;&gt; contiguousSets, float fracFreqLimit) {

<span class="nc bnc" id="L8448" title="All 2 branches missed.">        if (contiguousSets.isEmpty()) {</span>
<span class="nc" id="L8449">            return new ArrayList&lt;TIntList&gt;();</span>
        }

<span class="nc" id="L8452">        List&lt;GroupPixelRGB&gt; contigRGB = calculateRGB(</span>
            input, contiguousSets);

<span class="nc bnc" id="L8455" title="All 4 branches missed.">        assert(contiguousSets.size() == contigRGB.size());</span>

/*{
ImageExt img00 = input.createWithDimensions();
int nExtraForDot = 0;
MiscellaneousCurveHelper ch = new MiscellaneousCurveHelper();
for (int j = 0; j &lt; contigRGB.size(); ++j) {
    GroupPixelRGB rgb = contigRGB.get(j);
    int r = Math.round(rgb.getAvgRed());
    int g = Math.round(rgb.getAvgGreen());
    int b = Math.round(rgb.getAvgBlue());
    Set&lt;PairInt&gt; set = contiguousSets.get(j);
    ImageIOHelper.addToImage(set, 0, 0, img00,
        nExtraForDot, r, g, b);
    double[] xyCen = ch.calculateXYCentroids(set);
    int x = (int)Math.round(xyCen[0]);
    int y = (int)Math.round(xyCen[1]);
    ImageIOHelper.addPointToImage(x, y, img00,
        1, 255, 0, 0);
    System.out.println(&quot;i=&quot; + j + &quot; xyCen=&quot; + x + &quot;,&quot; + y);
}
MiscDebug.writeImage(img00, &quot;_DEBUG_&quot;);
int z = 1;
}*/
        //making a segmentation method using CIEXY polar theta
        // and the number of points with those colors.
        // choosing the peaks to be the cluster centers, then
        // gathering the pixels by proximity to the theta peaks
        // and when equidistant, chooses the largest peak.

<span class="nc" id="L8485">        TIntList blackPixels = new TIntArrayList();</span>

        // key = avg rgb, values = contigRGB list indexes
<span class="nc" id="L8488">        TIntObjectMap&lt;TIntSet&gt; greyIndexMap</span>
            = new TIntObjectHashMap&lt;TIntSet&gt;();

<span class="nc" id="L8491">        TIntList whitePixels = new TIntArrayList();</span>

<span class="nc" id="L8493">        TIntList points0 = new TIntArrayList();</span>

        // ciexy polar theta in degrees
<span class="nc" id="L8496">        TIntList thetaForPoints0 = new TIntArrayList();</span>

<span class="nc" id="L8498">        populatePixelLists(contigRGB, points0, blackPixels,</span>
            whitePixels, greyIndexMap, thetaForPoints0);

<span class="nc" id="L8501">        int[] minMaxTheta0 = new int[]{thetaForPoints0.min(),</span>
<span class="nc" id="L8502">            thetaForPoints0.max()};</span>

<span class="nc" id="L8504">        List&lt;TIntSet&gt; greyPixelGroups = groupByPeaks(greyIndexMap);</span>

<span class="nc" id="L8506">        List&lt;TIntList&gt; groupList = new ArrayList&lt;TIntList&gt;(greyPixelGroups.size());</span>

<span class="nc bnc" id="L8508" title="All 2 branches missed.">        if ((minMaxTheta0[1] - minMaxTheta0[0]) == 0) {</span>
<span class="nc bnc" id="L8509" title="All 2 branches missed.">             if (!points0.isEmpty()) {</span>
<span class="nc" id="L8510">                 groupList.add(points0);</span>
             }
<span class="nc bnc" id="L8512" title="All 2 branches missed.">             if (!blackPixels.isEmpty()) {</span>
<span class="nc" id="L8513">                 groupList.add(blackPixels);</span>
             }
<span class="nc bnc" id="L8515" title="All 2 branches missed.">             for (TIntSet set : greyPixelGroups) {</span>
<span class="nc" id="L8516">                groupList.add(new TIntArrayList(set));</span>
<span class="nc" id="L8517">             }</span>
<span class="nc bnc" id="L8518" title="All 2 branches missed.">             if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L8519">                 groupList.add(whitePixels);</span>
             }
<span class="nc" id="L8521">             return groupList;</span>
        }

        /* ----- create a map of theta and frequency ----
        need to find the peaks in frequency for frequencies larger than about
        3 percent of max frequency
        but don't want to use a spline3 to smooth, so will average every
        few pixels.
        */

<span class="nc" id="L8531">        int binWidth = 3;//5;//3;</span>
<span class="nc" id="L8532">        TIntObjectMap&lt;TIntSet&gt; thetaPointMap</span>
<span class="nc" id="L8533">            = createThetaCIEXYMap(points0, thetaForPoints0,</span>
            binWidth);

<span class="nc" id="L8536">        int n = (360/binWidth) + 1;</span>

<span class="nc" id="L8538">        log.info(&quot;for all non-white and non-black, minTheta=&quot;</span>
            + minMaxTheta0[0]
            + &quot; maxTheta=&quot; + minMaxTheta0[1]
            + &quot; binWidth=&quot; + binWidth +
<span class="nc" id="L8542">            &quot; thetaMap.size=&quot; + thetaPointMap.size());</span>

<span class="nc" id="L8544">        int[] orderedThetaKeys = new int[n];</span>
<span class="nc bnc" id="L8545" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L8546">            orderedThetaKeys[i] = i;</span>
        }
<span class="nc" id="L8548">        int maxFreq = Integer.MIN_VALUE;</span>
<span class="nc" id="L8549">        int nTot = 0;</span>

<span class="nc" id="L8551">        TIntObjectIterator&lt;TIntSet&gt; iter = thetaPointMap.iterator();</span>
<span class="nc bnc" id="L8552" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaPointMap.size(); ++i) {</span>
<span class="nc" id="L8553">            iter.advance();</span>
<span class="nc" id="L8554">            int count = iter.value().size();</span>
<span class="nc bnc" id="L8555" title="All 2 branches missed.">            if (count &gt; maxFreq) {</span>
<span class="nc" id="L8556">                maxFreq = count;</span>
            }
<span class="nc" id="L8558">            nTot += count;</span>
        }

        /*
        TODO: this is where the DTClusterFinder would be good to use to find
        the peaks.
        */

<span class="nc" id="L8566">        boolean useAll = true;</span>
        PairIntArray peaks;
<span class="nc bnc" id="L8568" title="All 2 branches missed.">        if (useAll) {</span>
<span class="nc" id="L8569">            peaks = new PairIntArray(thetaPointMap.size());</span>
<span class="nc" id="L8570">            iter = thetaPointMap.iterator();</span>
<span class="nc bnc" id="L8571" title="All 2 branches missed.">            for (int i = 0; i &lt; thetaPointMap.size(); ++i) {</span>
<span class="nc" id="L8572">                iter.advance();</span>
<span class="nc" id="L8573">                peaks.add(iter.key(), iter.value().size());</span>
            }
<span class="nc" id="L8575">            peaks.sortByXAsc();</span>
        } else {
<span class="nc" id="L8577">            peaks = findPeaksInThetaPointMap(orderedThetaKeys,</span>
                thetaPointMap,
<span class="nc" id="L8579">                Math.round(fracFreqLimit * maxFreq));</span>
        }

        /*
        // ----- debug ---
        // plot the points as an image to see the data first
        int[] minMaxXY = MiscMath.findMinMaxXY(peaks);
        int nPoints = 0;
        int maxX = Integer.MIN_VALUE;
        int maxY = Integer.MIN_VALUE;
        for (int i : orderedThetaKeys) {
            TIntSet set = thetaPointMap.get(i);
            if (set == null) {
                continue;
            }
            int y = set.size();
            nPoints++;
            if (i &gt; maxX) {
                maxX = i;
            }
            if (y &gt; maxY) {
                maxY = y;
            }
        }
        float[] xPoints = new float[nPoints];
        float[] yPoints = new float[nPoints];
        int count = 0;
        for (int i : orderedThetaKeys) {
            TIntSet set = thetaPointMap.get(i);
            if (set == null) {
                continue;
            }
            int y = set.size();
            xPoints[count] = i;
            yPoints[count] = y;
            count++;
        }
        try {
            //maxY=2000;
            PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();
            plotter.addPlot(0, maxX, 0, maxY, xPoints, yPoints, xPoints, yPoints, &quot;cieXY theta vs freq&quot;);
            plotter.writeFile(&quot;_segmentation3_&quot;);
        } catch (IOException ex) {
            Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE,
                null, ex);
        }
        int z = 1;
        // --- end debug
        */

<span class="nc bnc" id="L8629" title="All 2 branches missed.">        if (peaks.getN() == 0) {</span>
<span class="nc" id="L8630">            iter = thetaPointMap.iterator();</span>
<span class="nc bnc" id="L8631" title="All 2 branches missed.">            for (int i = 0; i &lt; thetaPointMap.size(); ++i) {</span>
<span class="nc" id="L8632">                iter.advance();</span>
<span class="nc" id="L8633">                TIntSet set = iter.value();</span>
<span class="nc" id="L8634">                groupList.add(new TIntArrayList(set));</span>
            }
<span class="nc" id="L8636">            groupList.add(blackPixels);</span>
<span class="nc" id="L8637">            groupList.add(whitePixels);</span>
<span class="nc" id="L8638">            return groupList;</span>
        }

<span class="nc bnc" id="L8641" title="All 2 branches missed.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="nc" id="L8642">            groupList.add(new TIntArrayList());</span>
        }

<span class="nc" id="L8645">        int maxC = (int)Math.ceil(minMaxTheta0[1]/(double)binWidth);</span>
<span class="nc" id="L8646">        NearestNeighbor1D nn1d = new NearestNeighbor1D(maxC);</span>
<span class="nc" id="L8647">        TIntIntMap valueIndexMap = new TIntIntHashMap();</span>
<span class="nc bnc" id="L8648" title="All 2 branches missed.">        for (int i = 0; i &lt; peaks.getN(); ++i) {</span>
<span class="nc" id="L8649">            nn1d.insert(peaks.getX(i));</span>
<span class="nc" id="L8650">            valueIndexMap.put(peaks.getX(i), i);</span>
        }
<span class="nc" id="L8652">        int firstPeak = peaks.getX(0);</span>
<span class="nc" id="L8653">        int lastPeak = peaks.getX(peaks.getN() - 1);</span>

<span class="nc" id="L8655">        iter = thetaPointMap.iterator();</span>
<span class="nc bnc" id="L8656" title="All 2 branches missed.">        for (int i = 0; i &lt; thetaPointMap.size(); ++i) {</span>
<span class="nc" id="L8657">            iter.advance();</span>
<span class="nc" id="L8658">            TIntSet set = iter.value();</span>
<span class="nc" id="L8659">            final int thetaBin = iter.key();</span>

            // find nearest peak, including wrap around if near ends
<span class="nc" id="L8662">            TIntSet nearest = nn1d.findClosest(thetaBin);</span>
<span class="nc" id="L8663">            int idx = -1;</span>
<span class="nc bnc" id="L8664" title="All 2 branches missed.">            if (nearest.size() &gt; 1) {</span>
                // choose by frequency
<span class="nc" id="L8666">                int max = Integer.MIN_VALUE;</span>
<span class="nc" id="L8667">                TIntIterator iter2 = nearest.iterator();</span>
<span class="nc bnc" id="L8668" title="All 2 branches missed.">                while (iter2.hasNext()) {</span>
<span class="nc" id="L8669">                    int t = iter2.next();</span>
<span class="nc" id="L8670">                    int tIdx = valueIndexMap.get(t);</span>
<span class="nc" id="L8671">                    int f = peaks.getY(tIdx);</span>
<span class="nc bnc" id="L8672" title="All 2 branches missed.">                    if (f &gt; max) {</span>
<span class="nc" id="L8673">                        max = f;</span>
<span class="nc" id="L8674">                        idx = tIdx;</span>
                    }
<span class="nc" id="L8676">                }</span>
<span class="nc" id="L8677">            } else {</span>
<span class="nc" id="L8678">                int t = nearest.iterator().next();</span>
<span class="nc" id="L8679">                idx = valueIndexMap.get(t);</span>
            }

<span class="nc bnc" id="L8682" title="All 4 branches missed.">            assert(idx != -1);</span>

<span class="nc bnc" id="L8684" title="All 2 branches missed.">            if (idx == firstPeak) {</span>
                // compare dist to last, wrap around
<span class="nc" id="L8686">                int diffL = Math.abs(thetaBin + 360 - peaks.getX(peaks.getN() - 1));</span>
<span class="nc" id="L8687">                int diff = Math.abs(peaks.getX(idx) - thetaBin);</span>
<span class="nc bnc" id="L8688" title="All 2 branches missed.">                if (diffL &lt; diff) {</span>
<span class="nc" id="L8689">                    idx = peaks.getN() - 1;</span>
<span class="nc bnc" id="L8690" title="All 2 branches missed.">                } else if (diff == diffL) {</span>
<span class="nc" id="L8691">                   int f = peaks.getY(idx);</span>
<span class="nc" id="L8692">                   int fL = peaks.getY(peaks.getN() - 1);</span>
<span class="nc bnc" id="L8693" title="All 2 branches missed.">                   if (fL &gt; f) {</span>
<span class="nc" id="L8694">                       idx = peaks.getN() - 1;</span>
                   }
                }
<span class="nc bnc" id="L8697" title="All 2 branches missed.">            } else if (idx == lastPeak) {</span>
                // compare dist to first, wrap around
<span class="nc" id="L8699">                int diffF = Math.abs(360 - thetaBin + peaks.getX(0));</span>
<span class="nc" id="L8700">                int diff = Math.abs(peaks.getX(idx) - thetaBin);</span>
<span class="nc bnc" id="L8701" title="All 2 branches missed.">                if (diffF &lt; diff) {</span>
<span class="nc" id="L8702">                    idx = 0;</span>
<span class="nc bnc" id="L8703" title="All 2 branches missed.">                } else if (diffF == diff) {</span>
<span class="nc" id="L8704">                    int f = peaks.getY(idx);</span>
<span class="nc" id="L8705">                    int fF = peaks.getY(0);</span>
<span class="nc bnc" id="L8706" title="All 2 branches missed.">                    if (fF &gt; f) {</span>
<span class="nc" id="L8707">                        idx = 0;</span>
                    }
                }
            }

<span class="nc bnc" id="L8712" title="All 4 branches missed.">            assert(idx != -1);</span>
<span class="nc" id="L8713">            groupList.get(idx).addAll(set);</span>
        }

        // create an adjacency map between sets in
        // contiguousSets.
<span class="nc" id="L8718">        TIntObjectMap&lt;TIntSet&gt; contigAdjacencyMap =</span>
<span class="nc" id="L8719">            LabelToColorHelper.createAdjacencySetMap(contiguousSets);</span>

<span class="nc" id="L8721">        mergeOrAppendGreyWithOthers(</span>
            contigAdjacencyMap, contigRGB,
            greyPixelGroups, groupList,
            blackPixels, whitePixels);

        // add back in blackPixels and whitePixels
<span class="nc bnc" id="L8727" title="All 2 branches missed.">        if (!blackPixels.isEmpty()) {</span>
<span class="nc" id="L8728">            groupList.add(blackPixels);</span>
        }
<span class="nc bnc" id="L8730" title="All 2 branches missed.">        if (!whitePixels.isEmpty()) {</span>
<span class="nc" id="L8731">            groupList.add(whitePixels);</span>
        }

<span class="nc" id="L8734">        return groupList;</span>
    }

    /**
     * filters the groups of labeled points to remove those which have color
     * histograms with small intersections with the template color histogram.
     * runs a few more iterations of the reduction to leave roughly 16 segmented
     * cells and then returns the centroids of the contiguous aggregation of
     * those as outputListOfSeeds.  The outputListOfSeeds is meant to be
     * used for a subsequent kmeans clustering.
     *
     * @param img
     * @param labels
     * @param templateImg
     * @param templatePoints
     * @param outputListOfPointSets - this is not empty, it is also
     * used as the input list of point sets, consistent with labels.
     * @param outputListOfCHs
     * @param outputListOfSeeds
     * @param outputSeedColors
     */
    public void filterUsingColorHistogramDifference(ImageExt img,
        int[] labels, ImageExt templateImg, Set&lt;PairInt&gt; templatePoints,
        List&lt;Set&lt;PairInt&gt;&gt; outputListOfPointSets,
        List&lt;TwoDIntArray&gt; outputListOfCHs,
        List&lt;PairInt&gt; outputListOfSeeds,
        List&lt;GroupPixelRGB0&gt; outputSeedColors) {

<span class="nc" id="L8762">        outputListOfCHs.clear();</span>
<span class="nc" id="L8763">        outputListOfSeeds.clear();;</span>
<span class="nc" id="L8764">        outputSeedColors.clear();</span>
        
<span class="nc" id="L8766">        float deltaELimit = 9.5f;//8.5f;</span>

<span class="nc bnc" id="L8768" title="All 4 branches missed.">        assert(labels.length == img.getNPixels());</span>

<span class="nc" id="L8770">        int[] labels2 = Arrays.copyOf(labels, labels.length);</span>

<span class="nc" id="L8772">        List&lt;Set&lt;PairInt&gt;&gt; listOfPointSets = null;</span>
<span class="nc bnc" id="L8773" title="All 2 branches missed.">        if (!outputListOfPointSets.isEmpty()) {</span>
<span class="nc" id="L8774">            listOfPointSets = new ArrayList&lt;Set&lt;PairInt&gt;&gt;(outputListOfPointSets.size());</span>
<span class="nc bnc" id="L8775" title="All 2 branches missed.">            for (int i = 0; i &lt; outputListOfPointSets.size(); ++i) {</span>
<span class="nc" id="L8776">                Set&lt;PairInt&gt; set = outputListOfPointSets.get(i);</span>
<span class="nc" id="L8777">                Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;(set);</span>
<span class="nc" id="L8778">                listOfPointSets.add(set2);</span>
            }
<span class="nc" id="L8780">            outputListOfPointSets.clear();</span>
        } else {
<span class="nc" id="L8782">            listOfPointSets = LabelToColorHelper</span>
<span class="nc" id="L8783">                .extractContiguousLabelPoints(img, labels2);</span>
        }
        
        // get color information for the template:
<span class="nc" id="L8787">        GroupAverageColors templateColors = new GroupAverageColors(</span>
            templateImg, templatePoints);

<span class="nc" id="L8790">        List&lt;GroupAverageColors&gt; listOfColors = new ArrayList&lt;GroupAverageColors&gt;();</span>
<span class="nc" id="L8791">        Set&lt;PairInt&gt; allSetPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L8792">        QuadTree&lt;Integer, Integer&gt; qt = new QuadTree&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L8794">        ColorHistogram clrHist = new ColorHistogram();</span>

<span class="nc" id="L8796">        int[][] templateCH = clrHist.histogramHSV(templateImg, templatePoints);</span>

        // filter sets to remove large differences in deltaE
<span class="nc bnc" id="L8799" title="All 2 branches missed.">        for (int i = 0; i &lt; listOfPointSets.size(); ++i) {</span>
<span class="nc" id="L8800">            Set&lt;PairInt&gt; set = listOfPointSets.get(i);</span>
<span class="nc" id="L8801">            GroupAverageColors setColors = new GroupAverageColors(img, set);</span>
<span class="nc" id="L8802">            DeltaESim deltaESimilarity = new DeltaESim(templateColors, setColors);</span>
<span class="nc bnc" id="L8803" title="All 2 branches missed.">            if (deltaESimilarity.getDeltaE() &lt; deltaELimit) {</span>
<span class="nc" id="L8804">                int idx = outputListOfPointSets.size();</span>
<span class="nc" id="L8805">                outputListOfPointSets.add(set);</span>
<span class="nc" id="L8806">                allSetPoints.addAll(set);</span>
<span class="nc" id="L8807">                listOfColors.add(setColors);</span>

<span class="nc" id="L8809">                qt.insert(setColors.getXCen(), setColors.getYCen(),</span>
<span class="nc" id="L8810">                    Integer.valueOf(idx));</span>

<span class="nc" id="L8812">                TwoDIntArray a = new TwoDIntArray(</span>
<span class="nc" id="L8813">                    clrHist.histogramHSV(img, set));</span>
<span class="nc" id="L8814">                outputListOfCHs.add(a);</span>
            }
        }
<span class="nc bnc" id="L8817" title="All 4 branches missed.">        assert(outputListOfPointSets.size() == outputListOfCHs.size());</span>

        // make a grid of 2D bins across the image of size
        // 1 or 1/2 or 1/3 template size for each dimension.
        // for each bin
        //   -- gather all centers within bin into one point set,
        //   -- make a color histogram and if intersection is very small,
        //      -- check to make sure that the individual cells have
        //         similar color (can safely remove them as a group them)

<span class="nc" id="L8827">        int[] minMaxXY = MiscMath.findMinMaxXY(templatePoints);</span>
<span class="nc" id="L8828">        int xLen = minMaxXY[1] - minMaxXY[0];</span>
<span class="nc" id="L8829">        int yLen = minMaxXY[3] - minMaxXY[2];</span>
<span class="nc" id="L8830">        int maxDim = Math.max(xLen, yLen);</span>

<span class="nc" id="L8832">        int nX = 2 * ((int)Math.floor(img.getWidth()/maxDim) + 1);</span>
<span class="nc" id="L8833">        int nY = 2 * ((int)Math.floor(img.getHeight()/maxDim) + 1);</span>

<span class="nc" id="L8835">        System.out.println(&quot;number of segmented cells=&quot;</span>
<span class="nc" id="L8836">            + outputListOfPointSets.size() + &quot; number removed=&quot; +</span>
<span class="nc" id="L8837">            (listOfPointSets.size() - outputListOfPointSets.size()));</span>

<span class="nc" id="L8839">        TIntSet remove = new TIntHashSet();</span>
<span class="nc" id="L8840">        TIntSet removeForSeeds = new TIntHashSet();</span>
<span class="nc" id="L8841">        Set&lt;PairInt&gt; skipYX = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L8843">        int nIter = 0;</span>
<span class="nc" id="L8844">        float[] chLimit1s = new float[]{</span>
            0.2f
            //, 0.35f, 0.45f, 0.5f, 0.55f, 0.6f
        };

        // iterate until about 16 cells are left
<span class="nc bnc" id="L8850" title="All 2 branches missed.">        while (nIter &lt; chLimit1s.length) {</span>

            //NOTE: can increase this to 0.25 for one test
<span class="nc" id="L8853">            float chLimit1 = chLimit1s[nIter];</span>
<span class="nc" id="L8854">            nIter++;</span>

<span class="nc bnc" id="L8856" title="All 2 branches missed.">            for (int j = 0; j &lt; nY; ++j) {</span>
<span class="nc" id="L8857">                int startY = (maxDim/2) * j;</span>
<span class="nc bnc" id="L8858" title="All 2 branches missed.">                if (startY &gt; (img.getHeight() - 1)) {</span>
<span class="nc" id="L8859">                    continue;</span>
                }
<span class="nc" id="L8861">                int stopY = startY + maxDim;</span>
<span class="nc bnc" id="L8862" title="All 2 branches missed.">                if (stopY &gt;= img.getHeight()) {</span>
<span class="nc" id="L8863">                    stopY = img.getHeight() - 1;</span>
                }
<span class="nc" id="L8865">                Interval&lt;Integer&gt; intY = new Interval&lt;Integer&gt;(startY, stopY);</span>
<span class="nc bnc" id="L8866" title="All 2 branches missed.">                for (int i = 0; i &lt; nX; ++i) {</span>
<span class="nc" id="L8867">                    int startX = (maxDim/2) * i;</span>
<span class="nc bnc" id="L8868" title="All 2 branches missed.">                    if (startX &gt; (img.getWidth() - 1)) {</span>
<span class="nc" id="L8869">                        continue;</span>
                    }
<span class="nc" id="L8871">                    int stopX = startX + maxDim;</span>
<span class="nc bnc" id="L8872" title="All 2 branches missed.">                    if (stopX &gt;= img.getWidth()) {</span>
<span class="nc" id="L8873">                        stopX = img.getWidth() - 1;</span>
                    }

<span class="nc bnc" id="L8876" title="All 2 branches missed.">                    if (skipYX.contains(new PairInt(j, i))) {</span>
<span class="nc" id="L8877">                        continue;</span>
                    }

<span class="nc" id="L8880">                    Interval&lt;Integer&gt; intX = new Interval&lt;Integer&gt;(startX, stopX);</span>
<span class="nc" id="L8881">                    Interval2D&lt;Integer&gt; rect = new Interval2D&lt;Integer&gt;(intX, intY);</span>

<span class="nc" id="L8883">                    List&lt;Integer&gt; indexes = qt.query2D(rect);</span>
<span class="nc bnc" id="L8884" title="All 2 branches missed.">                    if (indexes.isEmpty()) {</span>
<span class="nc" id="L8885">                        continue;</span>
                    }
<span class="nc" id="L8887">                    int[][] ch0 = outputListOfCHs.get(indexes.get(0).intValue()).a;</span>
<span class="nc" id="L8888">                    int[][] ch = Arrays.copyOf(ch0, ch0.length);</span>
<span class="nc bnc" id="L8889" title="All 2 branches missed.">                    for (int k = 1; k &lt; indexes.size(); ++k) {</span>
<span class="nc" id="L8890">                        clrHist.add2To1(ch,</span>
<span class="nc" id="L8891">                            outputListOfCHs.get(indexes.get(k).intValue()).a);</span>
                    }
<span class="nc" id="L8893">                    float intersection = clrHist.intersection(templateCH, ch);</span>

<span class="nc" id="L8895">                    System.out.println(String.format(</span>
<span class="nc" id="L8896">                        &quot;bin (%d:%d, %d:%d)  intersection=%.4f&quot;, startX, stopX,</span>
<span class="nc" id="L8897">                        startY, stopY, intersection));</span>

<span class="nc bnc" id="L8899" title="All 2 branches missed.">                    if (intersection &lt; chLimit1) {</span>
                        // calc avg and std dev rgb and cieX,cieY
<span class="nc" id="L8901">                        int[] avgStdv = calcStdDev(listOfColors, indexes);</span>
<span class="nc" id="L8902">                        System.out.println(&quot;stdv=&quot; + Arrays.toString(avgStdv));</span>
<span class="nc bnc" id="L8903" title="All 2 branches missed.">                        if (avgStdv[1] &lt; (0.06*255)) {</span>
                            //System.out.println(&quot;   removing&quot; );
                            // remove these
<span class="nc bnc" id="L8906" title="All 2 branches missed.">                            if (nIter == 1) {</span>
<span class="nc" id="L8907">                                remove.addAll(indexes);</span>
                            }
<span class="nc" id="L8909">                            removeForSeeds.addAll(indexes);</span>
<span class="nc" id="L8910">                            skipYX.add(new PairInt(j, i));</span>
                        }
                    }
                }
            }

            //TODO: this could be revised
<span class="nc" id="L8917">            int ns = outputListOfPointSets.size() - removeForSeeds.size();</span>
<span class="nc bnc" id="L8918" title="All 2 branches missed.">            if (ns &lt; 2*16) {</span>
<span class="nc" id="L8919">                break;</span>
            }
<span class="nc" id="L8921">        }</span>

        // copy outputListOfPointSets for separate seeds calc
<span class="nc" id="L8924">        List&lt;Set&lt;PairInt&gt;&gt; tmpSeedSets = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="nc bnc" id="L8925" title="All 2 branches missed.">        for (Set&lt;PairInt&gt; set : outputListOfPointSets) {</span>
<span class="nc" id="L8926">            tmpSeedSets.add(new HashSet&lt;PairInt&gt;(set));</span>
<span class="nc" id="L8927">        }</span>

<span class="nc" id="L8929">        System.out.println(&quot;removing &quot; + remove.size() + &quot; more segmented cells&quot;);</span>

<span class="nc bnc" id="L8931" title="All 4 branches missed.">        if (!remove.isEmpty() || !removeForSeeds.isEmpty()) {</span>

<span class="nc" id="L8933">            TIntList sorted = new TIntArrayList(remove);</span>
<span class="nc" id="L8934">            sorted.sort();</span>
<span class="nc bnc" id="L8935" title="All 2 branches missed.">            for (int i = (sorted.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L8936">                int idx = sorted.get(i);</span>
<span class="nc" id="L8937">                outputListOfPointSets.remove(idx);</span>
<span class="nc" id="L8938">                outputListOfCHs.remove(idx);</span>
            }

<span class="nc" id="L8941">            sorted = new TIntArrayList(removeForSeeds);</span>
<span class="nc" id="L8942">            sorted.sort();</span>
<span class="nc bnc" id="L8943" title="All 2 branches missed.">            for (int i = (sorted.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L8944">                int idx = sorted.get(i);</span>
<span class="nc" id="L8945">                tmpSeedSets.remove(idx);</span>
            }
        }

<span class="nc" id="L8949">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="nc bnc" id="L8950" title="All 2 branches missed.">        for (int i = 0; i &lt; tmpSeedSets.size(); ++i) {</span>

<span class="nc" id="L8952">            Set&lt;PairInt&gt; set = tmpSeedSets.get(i);</span>

<span class="nc" id="L8954">            double[] xyCen = curveHelper.calculateXYCentroids(set);</span>
<span class="nc" id="L8955">            outputListOfSeeds.add(new PairInt(</span>
<span class="nc" id="L8956">                (int)Math.round(xyCen[0]), (int)Math.round(xyCen[1])));</span>

<span class="nc" id="L8958">            GroupPixelRGB0 clrs = new GroupPixelRGB0();</span>
<span class="nc" id="L8959">            clrs.calculateColors(set, img, 0, 0);</span>
<span class="nc" id="L8960">            outputSeedColors.add(clrs);</span>
        }

<span class="nc" id="L8963">        Arrays.fill(labels, -1);</span>
<span class="nc bnc" id="L8964" title="All 2 branches missed.">        for (int i = 0; i &lt; outputListOfPointSets.size(); ++i) {</span>
<span class="nc" id="L8965">            Set&lt;PairInt&gt; set = outputListOfPointSets.get(i);</span>
<span class="nc bnc" id="L8966" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L8967">                int pixIdx = img.getInternalIndex(p);</span>
<span class="nc" id="L8968">                labels[pixIdx] = i;</span>
<span class="nc" id="L8969">            }</span>
        }
<span class="nc" id="L8971">    }</span>

    /**
     * NOT READY FOR USE:
     * 
     * method to merge segmented cells using texture information.
     * Some of the logic is derived from the Malik et al. 2001
     * texture segmentation paper.
     * NOTE that some images have noise which does not contain patterns that
     * you might want to use for segmentation, so consider when to use
     * this method.
     * 
     * @param img
     * @param products
     * @param listOfCells
     * @param debugTag 
     */
    public void mergeByTexture(ImageExt img, 
        PhaseCongruencyDetector.PhaseCongruencyProducts products,
        List&lt;Set&lt;PairInt&gt;&gt; listOfCells, String debugTag) {
        
<span class="nc" id="L8992">        TIntIntMap pointIndexMap = new TIntIntHashMap();</span>
<span class="nc bnc" id="L8993" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; listOfCells.size(); ++lIdx) {</span>
<span class="nc" id="L8994">            Set&lt;PairInt&gt; set = listOfCells.get(lIdx);            </span>
<span class="nc bnc" id="L8995" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L8996">                int pIdx = img.getInternalIndex(p);</span>
<span class="nc" id="L8997">                pointIndexMap.put(pIdx, lIdx);</span>
<span class="nc" id="L8998">            }</span>
        }
        
<span class="nc" id="L9001">        int w = img.getWidth();</span>
<span class="nc" id="L9002">        int h = img.getHeight();</span>
        
<span class="nc" id="L9004">        UnsupervisedTextureFinder finder = new UnsupervisedTextureFinder();</span>

<span class="nc" id="L9006">        UnsupervisedTextureFinder.TexturePatchesAndResponse[] tpar</span>
<span class="nc" id="L9007">            = finder.createTextureImages(img, products, debugTag);</span>
 
<span class="nc" id="L9009">        mergeByTexture(img, products, listOfCells, tpar, debugTag);</span>
<span class="nc" id="L9010">    }</span>
    
    /**
     * NOT READY FOR USE:
     * 
     * method to merge segmented cells using texture information.
     * Some of the logic is derived from the Malik et al. 2001
     * texture segmentation paper.
     * NOTE that some images have noise which does not contain patterns that
     * you might want to use for segmentation, so consider when to use
     * this method.
     * 
     * @param img
     * @param products
     * @param listOfCells
     * @param debugTag 
     */
    public void mergeByTexture(ImageExt img, 
        PhaseCongruencyDetector.PhaseCongruencyProducts products,
        List&lt;Set&lt;PairInt&gt;&gt; listOfCells, 
        UnsupervisedTextureFinder.TexturePatchesAndResponse[] tpar,
        String debugTag) {
        
<span class="nc" id="L9033">        TIntIntMap pointIndexMap = new TIntIntHashMap();</span>
<span class="nc bnc" id="L9034" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; listOfCells.size(); ++lIdx) {</span>
<span class="nc" id="L9035">            Set&lt;PairInt&gt; set = listOfCells.get(lIdx);            </span>
<span class="nc bnc" id="L9036" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L9037">                int pIdx = img.getInternalIndex(p);</span>
<span class="nc" id="L9038">                pointIndexMap.put(pIdx, lIdx);</span>
<span class="nc" id="L9039">            }</span>
        }
        
<span class="nc" id="L9042">        int w = img.getWidth();</span>
<span class="nc" id="L9043">        int h = img.getHeight();</span>
       
        // key=pixel, value=texture class index
<span class="nc" id="L9046">        TIntIntMap textureClassMap = new TIntIntHashMap();</span>
        
        // key=pixel, value=listOfCells index
<span class="nc" id="L9049">        TIntIntMap textureIndexMap = new TIntIntHashMap();</span>
      
        // key=listOfCells index, value = texture class index
<span class="nc" id="L9052">        TIntIntMap indexTextureClassMap = new TIntIntHashMap();</span>
      
        // key=listOfCells index, value = texture points
<span class="nc" id="L9055">        TIntObjectMap&lt;Set&lt;PairInt&gt;&gt; indexTexturesMap = new</span>
            TIntObjectHashMap&lt;Set&lt;PairInt&gt;&gt;();
            
        // these are listOfCells indexes containing more than one texture
        // class
<span class="nc" id="L9060">        TIntSet skipThese = new TIntHashSet();</span>
        
<span class="nc bnc" id="L9062" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; tpar.length; ++lIdx) {</span>
<span class="nc" id="L9063">            TexturePatchesAndResponse tp = tpar[lIdx];</span>
<span class="nc" id="L9064">            GreyscaleImage gImg = tp.responseImage;</span>
<span class="nc bnc" id="L9065" title="All 2 branches missed.">            for (int pixIdx = 0; pixIdx &lt; gImg.getNPixels(); ++pixIdx) {</span>
<span class="nc" id="L9066">                int v = gImg.getValue(pixIdx);</span>
<span class="nc bnc" id="L9067" title="All 2 branches missed.">                if (v == 0) {</span>
<span class="nc" id="L9068">                    continue;</span>
                }
<span class="nc bnc" id="L9070" title="All 2 branches missed.">                if (!pointIndexMap.containsKey(pixIdx)) {</span>
<span class="nc" id="L9071">                    continue;</span>
                }
<span class="nc" id="L9073">                int idx = pointIndexMap.get(pixIdx);</span>
                
                {
<span class="nc" id="L9076">                    Set&lt;PairInt&gt; tPoints = indexTexturesMap.get(idx);</span>
<span class="nc bnc" id="L9077" title="All 2 branches missed.">                    if (tPoints == null) {</span>
<span class="nc" id="L9078">                        tPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L9079">                        indexTexturesMap.put(idx, tPoints);</span>
                    }
<span class="nc" id="L9081">                    PairInt p2 = new PairInt(gImg.getCol(pixIdx), </span>
<span class="nc" id="L9082">                        gImg.getRow(pixIdx));</span>
<span class="nc" id="L9083">                    tPoints.add(p2);</span>
                }
               
<span class="nc bnc" id="L9086" title="All 2 branches missed.">                if (indexTextureClassMap.containsKey(idx)) {</span>
<span class="nc" id="L9087">                    int lIdx2 = indexTextureClassMap.get(idx);</span>
<span class="nc bnc" id="L9088" title="All 2 branches missed.">                    if (lIdx2 != lIdx) {</span>
<span class="nc" id="L9089">                        skipThese.add(idx);</span>
<span class="nc" id="L9090">                        continue;</span>
                    }
<span class="nc" id="L9092">                } else {</span>
<span class="nc" id="L9093">                    indexTextureClassMap.put(idx, lIdx);</span>
                }
                
<span class="nc" id="L9096">                textureClassMap.put(pixIdx, lIdx);</span>
                
<span class="nc" id="L9098">                textureIndexMap.put(pixIdx, idx);</span>
            }
        }
        
<span class="nc" id="L9102">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L9103">        int[] dys = Misc.dy8;</span>
<span class="nc" id="L9104">        TIntObjectMap&lt;TIntSet&gt; adjMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
<span class="nc bnc" id="L9105" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; listOfCells.size(); ++lIdx) {</span>
<span class="nc bnc" id="L9106" title="All 2 branches missed.">            if (skipThese.contains(lIdx)) {</span>
<span class="nc" id="L9107">                continue;</span>
            }
<span class="nc" id="L9109">            TIntSet indexes = new TIntHashSet();</span>
<span class="nc" id="L9110">            Set&lt;PairInt&gt; set = listOfCells.get(lIdx);            </span>
<span class="nc bnc" id="L9111" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L9112">                int x = p.getX();</span>
<span class="nc" id="L9113">                int y = p.getY();</span>
<span class="nc bnc" id="L9114" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L9115">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L9116">                    int y2 = y + dys[k];</span>
<span class="nc bnc" id="L9117" title="All 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L9118">                        continue;</span>
                    }
<span class="nc" id="L9120">                    int pixIdx2 = img.getInternalIndex(x2, y2);</span>
<span class="nc" id="L9121">                    int lIdx2 = pointIndexMap.get(pixIdx2);</span>
<span class="nc bnc" id="L9122" title="All 2 branches missed.">                    if (skipThese.contains(lIdx2)) {</span>
<span class="nc" id="L9123">                        continue;</span>
                    }
<span class="nc bnc" id="L9125" title="All 2 branches missed.">                    if (lIdx2 != lIdx) {</span>
<span class="nc" id="L9126">                        indexes.add(lIdx2);</span>
                    }
                }
<span class="nc" id="L9129">            }</span>
<span class="nc bnc" id="L9130" title="All 2 branches missed.">            if (!indexes.isEmpty()) {</span>
<span class="nc" id="L9131">                adjMap.put(lIdx, indexes);</span>
            }
        }
        
<span class="nc" id="L9135">        PerimeterFinder2 pFinder2 = new PerimeterFinder2();</span>
        
        // key = index of listOfCells, value = texture perimeter points
<span class="nc" id="L9138">        TIntObjectMap&lt;Set&lt;PairInt&gt;&gt; texturePerimeters </span>
            = new TIntObjectHashMap&lt;Set&lt;PairInt&gt;&gt;();

<span class="nc bnc" id="L9141" title="All 2 branches missed.">        for (int i = 0; i &lt; listOfCells.size(); ++i) {</span>

<span class="nc bnc" id="L9143" title="All 2 branches missed.">            if (skipThese.contains(i)) {</span>
<span class="nc" id="L9144">                continue;</span>
            }
            
<span class="nc" id="L9147">            Set&lt;PairInt&gt; tPoints = indexTexturesMap.get(i);</span>
<span class="nc bnc" id="L9148" title="All 4 branches missed.">            if (tPoints == null || tPoints.isEmpty()) {</span>
<span class="nc" id="L9149">                continue;</span>
            }
            
<span class="nc" id="L9152">            Set&lt;PairInt&gt; set = listOfCells.get(i);</span>
            
<span class="nc" id="L9154">            Set&lt;PairInt&gt; border = pFinder2.extractBorder(set);</span>
<span class="nc" id="L9155">            int[] minMaxXY = MiscMath.findMinMaxXY(border);</span>
            
            // for the texture points within this same set, the
            // perimeter is the closest of them to the border
          
<span class="nc" id="L9160">            Set&lt;PairInt&gt; tPer = new HashSet&lt;PairInt&gt;();</span>
            
<span class="nc" id="L9162">            NearestNeighbor2D nn = new NearestNeighbor2D(tPoints, </span>
                minMaxXY[1] + 1, minMaxXY[3] + 1);
            
<span class="nc" id="L9165">            int tClassIdx = -1;</span>
            
<span class="nc bnc" id="L9167" title="All 2 branches missed.">            for (PairInt p2 : border) {</span>
                
                // find closest texture point to p2
<span class="nc" id="L9170">                Set&lt;PairInt&gt; nearest = nn.findClosest(p2.getX(), p2.getY());</span>
<span class="nc bnc" id="L9171" title="All 4 branches missed.">                if (nearest == null || nearest.isEmpty()) {</span>
<span class="nc" id="L9172">                    continue;</span>
                }
                
<span class="nc bnc" id="L9175" title="All 2 branches missed.">                for (PairInt p3 : nearest) {</span>
<span class="nc" id="L9176">                    int pixIdx2 = img.getInternalIndex(p3);</span>
<span class="nc bnc" id="L9177" title="All 2 branches missed.">                    if (!textureClassMap.containsKey(pixIdx2)) {</span>
<span class="nc" id="L9178">                        continue;</span>
                    }
<span class="nc" id="L9180">                    int classIdx = textureClassMap.get(pixIdx2);</span>
<span class="nc bnc" id="L9181" title="All 2 branches missed.">                    if (tClassIdx == -1) {</span>
<span class="nc" id="L9182">                        tClassIdx = classIdx;</span>
<span class="nc bnc" id="L9183" title="All 2 branches missed.">                    } else if (tClassIdx != classIdx) {</span>
<span class="nc" id="L9184">                        tPer = null;</span>
<span class="nc" id="L9185">                        break;</span>
                    }
<span class="nc" id="L9187">                    tPer.add(p3);</span>
<span class="nc" id="L9188">                }</span>
<span class="nc bnc" id="L9189" title="All 2 branches missed.">                if (tPer == null) {</span>
<span class="nc" id="L9190">                    break;</span>
                }
<span class="nc" id="L9192">            }</span>
<span class="nc bnc" id="L9193" title="All 4 branches missed.">            if (tPer != null &amp;&amp; !tPer.isEmpty()) {</span>
<span class="nc" id="L9194">                texturePerimeters.put(i, tPer);</span>
            }
        }
        
        //-- next, compare each cell to each other cell
        //         to merge those which do not have edge points 
        //         between nearest neighboring adjacent texture perimeter points
        
        // row-major format array of edges
<span class="nc" id="L9203">        int[][] thinned = products.getThinned();</span>
        
        // key=old cell index, value = new cell index
<span class="nc" id="L9206">        TIntIntMap mergedIndexMap = new TIntIntHashMap();</span>
        
        // the 2 indexes i0 and i1 already compared.
        // there are entries as keys and as values for both.
<span class="nc" id="L9210">        TIntObjectMap&lt;TIntSet&gt; alreadyCompared = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
        /*
        for the segmented cells w/ texture points in them,
           comparing each cell to its adjacent cells w. texture in them.
           -- if an adjacent cell has a different texture class, then
              the two cells should not be merged.
           -- else, for each cell to cell comparision,
              looking for the closest point from each 
              texture perimeter and vice versa from the other
              cell to avoid comparing far side texture points
              with near side of other cells.
        */
        
<span class="nc" id="L9224">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span>
<span class="nc bnc" id="L9225" title="All 2 branches missed.">        for (int i : texturePerimeters.keys()) {</span>
<span class="nc" id="L9226">            stack.add(Integer.valueOf(i));</span>
        }
        
<span class="nc bnc" id="L9229" title="All 2 branches missed.">        while (!stack.isEmpty()) {</span>
            
<span class="nc" id="L9231">            int i0 = stack.pop().intValue();</span>
<span class="nc bnc" id="L9232" title="All 2 branches missed.">            if (skipThese.contains(i0)) {</span>
<span class="nc" id="L9233">                continue;</span>
            }
            
            // update the index if it has merged into another already
<span class="nc bnc" id="L9237" title="All 2 branches missed.">            while (mergedIndexMap.containsKey(i0)) {</span>
<span class="nc" id="L9238">                i0 = mergedIndexMap.get(i0);</span>
            }

<span class="nc" id="L9241">            Set&lt;PairInt&gt; tSet0 = texturePerimeters.get(i0);</span>
<span class="nc" id="L9242">            TIntSet adjIndexes = adjMap.get(i0);</span>
<span class="nc bnc" id="L9243" title="All 4 branches missed.">            if (adjIndexes == null || adjIndexes.isEmpty()) {</span>
<span class="nc" id="L9244">                continue;</span>
            }
            
            //the nearest neighbor needs maxX and maxY to be as large as any
            // possible query, so for convenience, this is image size
<span class="nc" id="L9249">            NearestNeighbor2D nn0 = new NearestNeighbor2D(tSet0, w, h);</span>
  
<span class="nc" id="L9251">            TIntSet updateThese = new TIntHashSet();</span>
           
<span class="nc" id="L9253">            TIntIterator iter1 = adjIndexes.iterator();</span>
<span class="nc bnc" id="L9254" title="All 2 branches missed.">            while (iter1.hasNext()) {</span>
                
<span class="nc" id="L9256">                int i1 = iter1.next();</span>
                
<span class="nc bnc" id="L9258" title="All 2 branches missed.">                if (skipThese.contains(i1)) {</span>
<span class="nc" id="L9259">                    continue;</span>
                }
                
<span class="nc bnc" id="L9262" title="All 2 branches missed.">                if (!texturePerimeters.containsKey(i1)) {</span>
<span class="nc" id="L9263">                    continue;</span>
                }
                
                // update the index if it has merged into another already
<span class="nc bnc" id="L9267" title="All 2 branches missed.">                while (mergedIndexMap.containsKey(i1)) {</span>
<span class="nc" id="L9268">                    i1 = mergedIndexMap.get(i1);</span>
                }
<span class="nc bnc" id="L9270" title="All 2 branches missed.">                if (i0 == i1) {</span>
<span class="nc" id="L9271">                    continue;</span>
                }
                // --- if has already been compared, check if can skip ---
<span class="nc bnc" id="L9274" title="All 2 branches missed.">                if (alreadyCompared.containsKey(i0) &amp;&amp; </span>
<span class="nc bnc" id="L9275" title="All 2 branches missed.">                    alreadyCompared.get(i0).contains(i1)) {</span>
<span class="nc" id="L9276">                    continue;</span>
<span class="nc bnc" id="L9277" title="All 2 branches missed.">                } else if (alreadyCompared.containsKey(i1) &amp;&amp; </span>
<span class="nc bnc" id="L9278" title="All 2 branches missed.">                    alreadyCompared.get(i1).contains(i0)) {</span>
<span class="nc" id="L9279">                    continue;</span>
                }
                
<span class="nc" id="L9282">                Set&lt;PairInt&gt; tSet1 = texturePerimeters.get(i1);</span>
                
<span class="nc bnc" id="L9284" title="All 4 branches missed.">                if (tSet1 == null || tSet1.isEmpty()) {</span>
<span class="nc" id="L9285">                    continue;</span>
                }
                
                //int[] minMaxXY1 = MiscMath.findMinMaxXY(tSet1);
                // this can be sped up by finding maxes of tSet0 and also
                // of tSet1 and setting the dimensions here to the max of those
<span class="nc" id="L9291">                NearestNeighbor2D nn1 = new NearestNeighbor2D(tSet1, w, h);</span>
            
<span class="nc" id="L9293">                boolean canMerge = true;</span>
<span class="nc" id="L9294">                int nC = 0;</span>
                
<span class="nc bnc" id="L9296" title="All 2 branches missed.">                for (PairInt p1 : tSet1) {</span>
<span class="nc" id="L9297">                    int x1 = p1.getX();</span>
<span class="nc" id="L9298">                    int y1 = p1.getY();</span>
                    
<span class="nc" id="L9300">                    Set&lt;PairInt&gt; nearest0 = nn0.findClosest(x1, y1);    </span>
<span class="nc bnc" id="L9301" title="All 4 branches missed.">                    if (nearest0 == null || nearest0.isEmpty()) {</span>
<span class="nc" id="L9302">                        continue;</span>
                    }
                   
<span class="nc bnc" id="L9305" title="All 2 branches missed.">                    for (PairInt p0 : nearest0) {</span>
                        
<span class="nc" id="L9307">                        int x0 = p0.getX();</span>
<span class="nc" id="L9308">                        int y0 = p0.getY();</span>
                   
                        // if this point's nearest is not x1, y1, skip
<span class="nc" id="L9311">                        Set&lt;PairInt&gt; nearest1 = nn1.findClosest(x0, y0);</span>
<span class="nc bnc" id="L9312" title="All 4 branches missed.">                        if (nearest1 == null || nearest1.isEmpty()) {</span>
<span class="nc" id="L9313">                            continue;</span>
                        }
<span class="nc bnc" id="L9315" title="All 2 branches missed.">                        if (!nearest1.contains(p1)) {</span>
<span class="nc" id="L9316">                            continue;</span>
                        }
                    
                        // draw a line between p1 and nearest, and if there's
                        // an edge point on that line, then cannot merge
                        
<span class="nc" id="L9322">                        Set&lt;PairInt&gt; linePoints = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L9324">                        BresenhamsLine.createLinePoints(x0, y0, x1, y1,</span>
                            linePoints);
                        
<span class="nc bnc" id="L9327" title="All 2 branches missed.">                        for (PairInt p3 : linePoints) {</span>
                            // NOTE: Malik et al. 2001 use the phase energy
                            // magnitude here too and direction.
<span class="nc bnc" id="L9330" title="All 2 branches missed.">                            if (thinned[p3.getY()][p3.getX()] &gt; 0) {</span>
<span class="nc" id="L9331">                                canMerge = false;</span>
<span class="nc" id="L9332">                                break;</span>
                            }
<span class="nc" id="L9334">                        }</span>
                        
<span class="nc bnc" id="L9336" title="All 2 branches missed.">                        if (!canMerge) {</span>
<span class="nc" id="L9337">                            break;</span>
                        }
<span class="nc" id="L9339">                        nC++;</span>
<span class="nc" id="L9340">                    }</span>
<span class="nc bnc" id="L9341" title="All 2 branches missed.">                    if (!canMerge) {</span>
<span class="nc" id="L9342">                        break;</span>
                    }
<span class="nc" id="L9344">                } // end over all points in tSet1</span>
                
<span class="nc" id="L9346">                TIntSet t0 = alreadyCompared.get(i0);</span>
<span class="nc bnc" id="L9347" title="All 2 branches missed.">                if (t0 == null) {</span>
<span class="nc" id="L9348">                    t0 = new TIntHashSet();</span>
<span class="nc" id="L9349">                    alreadyCompared.put(i0, t0);</span>
                }
<span class="nc" id="L9351">                t0.add(i1);</span>

<span class="nc" id="L9353">                TIntSet t1 = alreadyCompared.get(i1);</span>
<span class="nc bnc" id="L9354" title="All 2 branches missed.">                if (t1 == null) {</span>
<span class="nc" id="L9355">                    t1 = new TIntHashSet();</span>
<span class="nc" id="L9356">                    alreadyCompared.put(i1, t1);</span>
                }
<span class="nc" id="L9358">                t1.add(i0);</span>
                
<span class="nc bnc" id="L9360" title="All 4 branches missed.">                if (!canMerge || nC == 0) {                    </span>
<span class="nc" id="L9361">                    continue;</span>
                }
                
<span class="nc" id="L9364">                updateThese.add(i1);</span>
                
                //--- merge i1 and i0 and update variables ----
                //    adj map is updated after loop over neighbors
                
                // update alreadyCompared using t1
<span class="nc" id="L9370">                TIntIterator iter2 = t1.iterator();</span>
<span class="nc bnc" id="L9371" title="All 2 branches missed.">                while (iter2.hasNext()) {</span>
<span class="nc" id="L9372">                    int idx3 = iter2.next();</span>
<span class="nc bnc" id="L9373" title="All 2 branches missed.">                    if (idx3 == i1) {</span>
<span class="nc" id="L9374">                        continue;</span>
                    }
<span class="nc" id="L9376">                    TIntSet setContainingI1 = alreadyCompared.get(idx3);</span>
<span class="nc bnc" id="L9377" title="All 2 branches missed.">                    if (setContainingI1 == null) {</span>
<span class="nc" id="L9378">                        continue;</span>
                    }
<span class="nc" id="L9380">                    setContainingI1.remove(i1);</span>
<span class="nc" id="L9381">                    setContainingI1.add(i0);</span>
<span class="nc" id="L9382">                }</span>
<span class="nc" id="L9383">                t0.addAll(t1);</span>
<span class="nc" id="L9384">                alreadyCompared.remove(i1);</span>
                
<span class="nc" id="L9386">                mergedIndexMap.put(i1, i0);</span>
                
<span class="nc" id="L9388">            } // end loop over adjacent neighbors</span>
            
            // update adjacency map
<span class="nc bnc" id="L9391" title="All 2 branches missed.">            if (!updateThese.isEmpty()) {</span>
                
                // add i0 back to the stack once to visit neighbors of neigbhors
<span class="nc" id="L9394">                stack.add(Integer.valueOf(i0));</span>
                                
                // for every index merged into i0, update
                // to replace i1 with i0
<span class="nc" id="L9398">                TIntIterator iterU = updateThese.iterator();</span>
<span class="nc bnc" id="L9399" title="All 2 branches missed.">                while (iterU.hasNext()) {</span>
<span class="nc" id="L9400">                    int i1 = iterU.next();</span>
                     
                    // update // key = index of listOfCells, 
                    //           value = texture perimeter points
                    // TIntObjectMap&lt;Set&lt;PairInt&gt;&gt; texturePerimeters
<span class="nc" id="L9405">                    Set&lt;PairInt&gt; tSet1 = texturePerimeters.remove(i1);</span>
<span class="nc" id="L9406">                    texturePerimeters.get(i0).addAll(tSet1);</span>
                
                    
<span class="nc" id="L9409">                    TIntSet adj1 = adjMap.remove(i1);</span>
<span class="nc" id="L9410">                    adj1.remove(i0);</span>
<span class="nc" id="L9411">                    adjMap.get(i0).addAll(adj1);</span>
                    
                    // the adj1 set's map value pointing to i1 should
                    // be changed to point to i0 now
<span class="nc" id="L9415">                    TIntIterator iter2 = adj1.iterator();</span>
<span class="nc bnc" id="L9416" title="All 2 branches missed.">                    while (iter2.hasNext()) {</span>
<span class="nc" id="L9417">                        int i2 = iter2.next();</span>
<span class="nc" id="L9418">                        TIntSet adj2 = adjMap.get(i2);</span>
<span class="nc bnc" id="L9419" title="All 2 branches missed.">                        if (adj2 == null) {</span>
<span class="nc" id="L9420">                            continue;</span>
                        }
<span class="nc" id="L9422">                        adj2.remove(i1);</span>
<span class="nc" id="L9423">                        adj2.add(i0);</span>
<span class="nc" id="L9424">                    }</span>
                    
                    // update list of cells
<span class="nc" id="L9427">                    Set&lt;PairInt&gt; setI1 = listOfCells.get(i1);</span>
<span class="nc" id="L9428">                    listOfCells.get(i0).addAll(setI1);</span>
<span class="nc" id="L9429">                    setI1.clear();</span>
<span class="nc" id="L9430">                }</span>
            }
<span class="nc" id="L9432">        }</span>
        
<span class="nc" id="L9434">        int nR = 0;</span>
<span class="nc bnc" id="L9435" title="All 2 branches missed.">        for (int i = (listOfCells.size() - 1);  i &gt; -1; --i) {</span>
<span class="nc bnc" id="L9436" title="All 2 branches missed.">            if (listOfCells.get(i).isEmpty()) {</span>
<span class="nc" id="L9437">                listOfCells.remove(i);</span>
<span class="nc" id="L9438">                nR++;</span>
            }
        }
<span class="nc" id="L9441">        System.out.println(&quot;textures nMerged=&quot; + nR);</span>
<span class="nc" id="L9442">    }</span>
    
    public boolean filterByLUVDeltaE(ImageExt templateImage, 
        Set&lt;PairInt&gt; templateSet, ImageExt img, 
        List&lt;Set&lt;PairInt&gt;&gt; pointSets, float luvDeltaELimit) {
        
<span class="nc" id="L9448">        GroupPixelCIELUV luvTemplate = new GroupPixelCIELUV(</span>
            templateSet, templateImage);
<span class="nc" id="L9450">        luvTemplate.calculateColors(templateSet, templateImage, 0, 0);</span>
        
<span class="nc" id="L9452">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="nc" id="L9454">        TIntList rm = new TIntArrayList();</span>
                
<span class="nc bnc" id="L9456" title="All 2 branches missed.">        for (int i = 0; i &lt; pointSets.size(); ++i) {</span>
            
<span class="nc" id="L9458">            Set&lt;PairInt&gt; set = pointSets.get(i);</span>
            
<span class="nc" id="L9460">            GroupPixelCIELUV luv = new GroupPixelCIELUV(set, img);</span>
<span class="nc" id="L9461">            luv.calculateColors(set, img, 0, 0);</span>
            
<span class="nc" id="L9463">            double deltaE = cieC.calcDeltaECIE2000(</span>
<span class="nc" id="L9464">                luvTemplate.getAvgL(), luvTemplate.getAvgU(),</span>
<span class="nc" id="L9465">                luvTemplate.getAvgV(),</span>
<span class="nc" id="L9466">                luv.getAvgL(), luv.getAvgU(), luv.getAvgV());</span>
             
            // TODO: this may need to be a higher limit
<span class="nc bnc" id="L9469" title="All 2 branches missed.">            if (Math.abs(deltaE) &gt; luvDeltaELimit) {</span>
<span class="nc" id="L9470">                rm.add(i);</span>
            }
        }
        
<span class="nc bnc" id="L9474" title="All 2 branches missed.">        for (int i = (rm.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L9475">            int rmIdx = rm.get(i);</span>
<span class="nc" id="L9476">            pointSets.remove(rmIdx);</span>
        }
                
<span class="nc bnc" id="L9479" title="All 2 branches missed.">        return !rm.isEmpty();</span>
    }
    
    public boolean filterByCIETheta(ImageExt templateImage, 
        Set&lt;PairInt&gt; templateSet, ImageExt img, 
        List&lt;Set&lt;PairInt&gt;&gt; pointSets) {
     
<span class="nc" id="L9486">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="nc" id="L9487">        GreyscaleImage theta1 = </span>
<span class="nc" id="L9488">            imageProcessor.createCIELUVTheta(templateImage, 255);</span>
        
<span class="nc" id="L9490">        GreyscaleImage theta2 = </span>
<span class="nc" id="L9491">            imageProcessor.createCIELUVTheta(img, 255);</span>
        
        //TODO:  may need special handling for colors near center,
        //   that is grey-ish colors, because the polar direction
        //   error in that small radius is large.
        //  looking at bigger picture changes to use deltaE2000
        //  again...
        
<span class="nc" id="L9499">        ColorHistogram ch = new ColorHistogram();</span>
        
<span class="nc" id="L9501">        int[] tHist = ch.histogram1D(theta1, templateSet, 255);</span>
        
<span class="nc" id="L9503">        TIntList rm = new TIntArrayList();</span>
        
<span class="nc" id="L9505">        float limit = 0.5f;//0.2f;</span>
        
<span class="nc bnc" id="L9507" title="All 2 branches missed.">        for (int i = 0; i &lt; pointSets.size(); ++i) {</span>
<span class="nc" id="L9508">            Set&lt;PairInt&gt; set = pointSets.get(i);</span>
<span class="nc" id="L9509">            int[] hist = ch.histogram1D(theta2, set, 255);</span>
<span class="nc" id="L9510">            float intersection = ch.intersection(tHist, hist);</span>
<span class="nc bnc" id="L9511" title="All 2 branches missed.">            if (intersection &lt; limit) {</span>
<span class="nc" id="L9512">                rm.add(i);</span>
            }
        }
        
<span class="nc bnc" id="L9516" title="All 2 branches missed.">        for (int i = (rm.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L9517">            int rmIdx = rm.get(i);</span>
<span class="nc" id="L9518">            pointSets.remove(rmIdx);</span>
        }
                
<span class="nc bnc" id="L9521" title="All 2 branches missed.">        return !rm.isEmpty();</span>
    }
    
    public boolean filterByCIECH(ImageExt templateImage, 
        Set&lt;PairInt&gt; templateSet, ImageExt img, 
        List&lt;Set&lt;PairInt&gt;&gt; pointSets, float lowerLimit) {
     
<span class="nc" id="L9528">        ColorHistogram ch = new ColorHistogram();</span>
        
<span class="nc" id="L9530">        int[] tHist = ch.histogramCIECH64(templateImage, </span>
            templateSet);
        
<span class="nc" id="L9533">        TIntList rm = new TIntArrayList();</span>
                
<span class="nc bnc" id="L9535" title="All 2 branches missed.">        for (int i = 0; i &lt; pointSets.size(); ++i) {</span>
<span class="nc" id="L9536">            Set&lt;PairInt&gt; set = pointSets.get(i);</span>
<span class="nc" id="L9537">            int[] hist = ch.histogramCIECH64(img, set);</span>
<span class="nc" id="L9538">            float intersection = ch.intersection(tHist, hist);</span>
<span class="nc bnc" id="L9539" title="All 2 branches missed.">            if (intersection &lt; lowerLimit) {</span>
<span class="nc" id="L9540">                rm.add(i);</span>
            }
        }
        
<span class="nc bnc" id="L9544" title="All 2 branches missed.">        for (int i = (rm.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L9545">            int rmIdx = rm.get(i);</span>
<span class="nc" id="L9546">            pointSets.remove(rmIdx);</span>
        }
                
<span class="nc bnc" id="L9549" title="All 2 branches missed.">        return !rm.isEmpty();</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BlobScaleFinderWrapper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">BlobScaleFinderWrapper.java</span></div><h1>BlobScaleFinderWrapper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.SegmentedImageHelper.SegmentationType;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

/**
 * determine scale between 2 images using blob contours.
 * NOT READY FOR USE YET.
 *
 * @author nichole
 */
public class BlobScaleFinderWrapper {

<span class="nc" id="L18">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="nc" id="L20">    protected boolean debug = true;</span>

<span class="nc" id="L22">    protected final int binnedImageMaxDimension = 300;</span>

    protected final SegmentedImageHelper img1Helper;

    protected final SegmentedImageHelper img2Helper;

    /**
     *
     * @param img1 the first image holding objects for which a Euclidean
     * transformation is found that can be applied to put it in
     * the same scale reference frame as image2.
     * @param img2 the second image representing the reference frame that
     * image1 is transformed to using the resulting parameters,
     */
<span class="nc" id="L36">    public BlobScaleFinderWrapper(ImageExt img1, ImageExt img2) {</span>

<span class="nc" id="L38">        img1Helper = new SegmentedImageHelper(img1, &quot;1&quot;);</span>

<span class="nc" id="L40">        img2Helper = new SegmentedImageHelper(img2, &quot;2&quot;);</span>

<span class="nc" id="L42">    }</span>

    public void setToDebug() {
<span class="nc" id="L45">        debug = true;</span>
<span class="nc" id="L46">    }</span>

    /**
     * NOT READY FOR USE YET.
     * From the given images, determine the scale between them and roughly
     * estimate the rotation and translation too.
     *
     * This method does not require pre-processing such as sky subtraction
     * because it uses adaptive mean thresholding, but if sky subtraction is
     * already performed, you might want to use the alternate method
     * calculateScale0().
     *
     * Note that it is expected that this transformation result will be followed
     * by a more rigorous solver such as the FeatureMatcher for a correspondence
     * list (and a better Euclidean transform) to be used in.

     &lt;pre&gt;
     The blobs are found through two different ways depending upon the image
     statistics.
     If the image appears to be very bright, a method which is better at finding
     dark blobs is used:
         img0 = img.copyToGreyscale();
         img0 = imageProcessor.binImage(img0, binFactor);
         imageProcessor.applyImageSegmentation(img0, 2);
         imageProcessor.applyAdaptiveMeanThresholding(img0, 20/binFactor);
     else:
         img0 = imageProcessor.binImage(img0, binFactor);
         img0 = imageProcessor.createGreyscaleFromColorSegmentation(img, 4)
         imageProcessor.applyAdaptiveMeanThresholding(img0, 2); 2 is for unbinned so may need tuning
     &lt;/pre&gt;

     * @return Euclidean scale to be applied to image1 to place it in the same
     * scale reference frame as image2.  Rotation and transformation are also
     * roughly solved for.
     * @throws java.io.IOException
     * @throws java.security.NoSuchAlgorithmException
     */
    public TransformationParameters calculateScale() throws IOException,
        NoSuchAlgorithmException {

<span class="nc" id="L86">        ImageStatistics stats1 = ImageStatisticsHelper.examineImage(</span>
<span class="nc" id="L87">            img1Helper.getGreyscaleImage(), true);</span>
<span class="nc" id="L88">        ImageStatistics stats2 = ImageStatisticsHelper.examineImage(</span>
<span class="nc" id="L89">            img2Helper.getGreyscaleImage(), true);</span>
        
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L92">            log.info(stats1.toString());</span>
<span class="nc" id="L93">            log.info(stats2.toString());</span>
        }

        /*
        depending on image statistics, different combinations of segmentation
        and binning are tried.
        */

        SegmentationType[] orderOfSeg1;
        boolean[] orderOfBinning1;
        SegmentationType[] orderOfSeg2;
        boolean[] orderOfBinning2;
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (stats1.getHistAreas()[1] &gt;= 0.75) {</span>
<span class="nc" id="L106">            orderOfSeg1 = new SegmentationType[]{</span>
                SegmentationType.BINARY, SegmentationType.BINARY,
                SegmentationType.COLOR_POLARCIEXY_ADAPT, SegmentationType.COLOR_POLARCIEXY_ADAPT};
<span class="nc" id="L109">            orderOfBinning1 = new boolean[] {true, false, true, false};</span>
        } else {
<span class="nc" id="L111">            orderOfSeg1 = new SegmentationType[]{</span>
                SegmentationType.GREYSCALE_KMPP, SegmentationType.GREYSCALE_KMPP,
                SegmentationType.COLOR_POLARCIEXY_ADAPT, SegmentationType.COLOR_POLARCIEXY_ADAPT};
<span class="nc" id="L114">            orderOfBinning1 = new boolean[] {true, false, true, false};</span>
<span class="nc" id="L115">            boolean didApplyHistEq =</span>
<span class="nc" id="L116">                img1Helper.applyEqualizationIfNeededByComparison(img2Helper);</span>
<span class="nc" id="L117">            log.info(&quot;didApplyHistEq=&quot; + didApplyHistEq);</span>
        }
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (stats2.getHistAreas()[1] &gt;= 0.75) {</span>
            // for BINARY should only use binning
<span class="nc" id="L121">            orderOfSeg2 = new SegmentationType[]{</span>
                SegmentationType.BINARY, SegmentationType.BINARY,
                SegmentationType.COLOR_POLARCIEXY_ADAPT, SegmentationType.COLOR_POLARCIEXY_ADAPT};
<span class="nc" id="L124">            orderOfBinning2 = new boolean[] {true, false, true, false};</span>
        } else {
            // for COLOR_POLARCIEXY_ADAPT: looks like should not use binning
<span class="nc" id="L127">            orderOfSeg2 = new SegmentationType[]{</span>
                SegmentationType.GREYSCALE_KMPP, SegmentationType.GREYSCALE_KMPP,
                SegmentationType.COLOR_POLARCIEXY_ADAPT, SegmentationType.COLOR_POLARCIEXY_ADAPT};
<span class="nc" id="L130">            orderOfBinning2 = new boolean[] {true, false, true, false};</span>
        }
        
<span class="nc" id="L133">        int ordered1Idx = 0;</span>
<span class="nc" id="L134">        int ordered2Idx = 0;</span>

<span class="nc bnc" id="L136" title="All 4 branches missed.">        while ((ordered1Idx &lt; orderOfSeg1.length) &amp;&amp; (ordered2Idx &lt; orderOfSeg2.length)) {</span>

<span class="nc" id="L138">            boolean useBinned1 = orderOfBinning1[ordered1Idx];</span>

<span class="nc" id="L140">            boolean useBinned2 = orderOfBinning2[ordered2Idx];</span>

<span class="nc" id="L142">            SegmentationType segmentationType1 = orderOfSeg1[ordered1Idx];</span>

<span class="nc" id="L144">            SegmentationType segmentationType2 = orderOfSeg2[ordered2Idx];</span>

<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (useBinned1) {</span>
<span class="nc" id="L147">                img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            }

<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (useBinned2) {</span>
<span class="nc" id="L151">                img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            }

<span class="nc" id="L154">            img1Helper.applySegmentationToBinned(segmentationType1, useBinned1);</span>
            
<span class="nc" id="L156">            img2Helper.applySegmentationToBinned(segmentationType2, useBinned2);</span>

<span class="nc" id="L158">            img1Helper.extractBlobsAndContours(segmentationType1, useBinned1);</span>

<span class="nc" id="L160">            img2Helper.extractBlobsAndContours(segmentationType2, useBinned2);</span>

<span class="nc" id="L162">            BlobScaleFinder bsFinder = new BlobScaleFinder();</span>

<span class="nc" id="L164">            float[] outputScaleRotTransXYStDev = new float[4];</span>
<span class="nc" id="L165">            TransformationParameters params = bsFinder.solveForScale(</span>
                img1Helper, segmentationType1, useBinned1,
                img2Helper, segmentationType2, useBinned2,
                outputScaleRotTransXYStDev);

<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (params != null) {</span>

<span class="nc" id="L172">                log.info(&quot;params for type&quot;</span>
<span class="nc" id="L173">                    + &quot; (&quot; + segmentationType1.name() + &quot;, binned=&quot; + useBinned1 + &quot;)&quot;</span>
<span class="nc" id="L174">                    + &quot; (&quot; + segmentationType2.name() + &quot;, binned=&quot; + useBinned2 + &quot;)&quot;</span>
<span class="nc" id="L175">                    + &quot; : &quot; + params.toString());</span>

<span class="nc" id="L177">                log.info(String.format(</span>
                    &quot;stDev scale=%.1f  stDev rot=%.0f  stDev tX=%.0f  stDev tY=%.0f&quot;,
<span class="nc" id="L179">                    outputScaleRotTransXYStDev[0], outputScaleRotTransXYStDev[1],</span>
<span class="nc" id="L180">                    outputScaleRotTransXYStDev[2], outputScaleRotTransXYStDev[3]));</span>

                //TODO: review this limit
<span class="nc" id="L183">                if (</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">                    ((outputScaleRotTransXYStDev[0]/params.getScale()) &lt; 0.2)</span>
                    ) {
<span class="nc" id="L186">                    return params;</span>
                }
            }

            // if arrive here, have to decide to keep current segmentation and binning or increment.
            // at least one index has to change
            
<span class="nc" id="L193">            int nContours1 = sumContours(img1Helper, segmentationType1, useBinned1);</span>

<span class="nc" id="L195">            int nContours2 = sumContours(img2Helper, segmentationType2, useBinned2);</span>
            
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (nContours1 &gt; 10) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if (nContours2 &gt; 10) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                    if (nContours1 &gt; nContours2) {</span>
<span class="nc" id="L200">                        ordered2Idx++;</span>
                    } else {
<span class="nc" id="L202">                        ordered1Idx++;</span>
                    }
                } else {
<span class="nc" id="L205">                    ordered1Idx++;</span>
                }
<span class="nc" id="L207">                continue;</span>
            }
            
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (nContours2 &gt; 10) {</span>
<span class="nc" id="L211">                ordered1Idx++;</span>
<span class="nc" id="L212">                continue;</span>
            }

<span class="nc" id="L215">            ordered1Idx++;</span>
<span class="nc" id="L216">            ordered2Idx++;</span>
<span class="nc" id="L217">        }</span>
        
<span class="nc" id="L219">        return null;</span>
    }

    /**
     * NOT READY FOR USE YET.
     * From the given images, determine the scale between them and roughly
     * estimate the rotation and translation too.  Note that image processing
     * such as sky masks should be applied before using this method.
     * Also note that it is expected that it will be followed by a more rigorous
     * solver such as the FeatureMatcher for a correspondence list
     * (and a better Euclidean transform) to be used in.

     This method does not use adaptive mean thresholding and was originally 
     created for use on images where background processing such as sky masking 
     has already occurred.

     * @return Euclidean scale to be applied to image1 to place it in the same
     * scale reference frame as image2.  Rotation and transformation are also
     * roughly solved for.
     * @throws java.io.IOException
     * @throws java.security.NoSuchAlgorithmException
     */
    public TransformationParameters calculateScale0() throws IOException,
        NoSuchAlgorithmException {

        /*
        Tries to solve using various combinations of binning and segmentation,
        starting with binned images because the solution if possible with them
        is faster.
        (1) Greyscale binned, k=2
        (2) Clr binned, k=2
            -- possibly watershed on blobs if no solution
        (3) Greyscale not binned, k=2
        (4) Clr binned, k=2
            -- possibly watershed on blobs if no solution
        (5) Clr not binned, k=3 or 4
        */

<span class="nc" id="L257">        SegmentationType[] orderOfSeg1 = new SegmentationType[]{</span>
            SegmentationType.GREYSCALE_KMPP, 
            SegmentationType.COLOR_POLARCIEXY,
            SegmentationType.GREYSCALE_KMPP, 
            SegmentationType.COLOR_POLARCIEXY};
<span class="nc" id="L262">        boolean[] orderOfBinning1 = new boolean[] {true, true, false, false};</span>
        
<span class="nc" id="L264">        boolean didApplyHistEq =</span>
<span class="nc" id="L265">            img1Helper.applyEqualizationIfNeededByComparison(img2Helper);</span>
<span class="nc" id="L266">        log.info(&quot;didApplyHistEq=&quot; + didApplyHistEq);</span>
        
<span class="nc" id="L268">        SegmentationType[] orderOfSeg2 = Arrays.copyOf(orderOfSeg1, orderOfSeg1.length);</span>
<span class="nc" id="L269">        boolean[] orderOfBinning2 = Arrays.copyOf(orderOfBinning1, orderOfBinning1.length);</span>

<span class="nc" id="L271">        int ordered1Idx = 0;</span>
<span class="nc" id="L272">        int ordered2Idx = 0;</span>

<span class="nc bnc" id="L274" title="All 4 branches missed.">        while ((ordered1Idx &lt; orderOfSeg1.length) &amp;&amp; (ordered2Idx &lt; orderOfSeg2.length)) {</span>

<span class="nc" id="L276">            boolean useBinned1 = orderOfBinning1[ordered1Idx];</span>

<span class="nc" id="L278">            boolean useBinned2 = orderOfBinning2[ordered2Idx];</span>

<span class="nc" id="L280">            SegmentationType segmentationType1 = orderOfSeg1[ordered1Idx];</span>

<span class="nc" id="L282">            SegmentationType segmentationType2 = orderOfSeg2[ordered2Idx];</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (useBinned1) {</span>
<span class="nc" id="L285">                img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            }

<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (useBinned2) {</span>
<span class="nc" id="L289">                img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            }

<span class="nc" id="L292">            img1Helper.applySegmentationToBinned(segmentationType1, useBinned1);</span>

<span class="nc" id="L294">            img2Helper.applySegmentationToBinned(segmentationType2, useBinned2);</span>

<span class="nc" id="L296">            img1Helper.extractBlobsAndContours(segmentationType1, useBinned1);</span>

<span class="nc" id="L298">            img2Helper.extractBlobsAndContours(segmentationType2, useBinned2);</span>

<span class="nc" id="L300">            BlobScaleFinder bsFinder = new BlobScaleFinder();</span>

<span class="nc" id="L302">            float[] outputScaleRotTransXYStDev = new float[4];</span>
<span class="nc" id="L303">            TransformationParameters params = bsFinder.solveForScale(</span>
                img1Helper, segmentationType1, useBinned1,
                img2Helper, segmentationType2, useBinned2,
                outputScaleRotTransXYStDev);

<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (params != null) {</span>

<span class="nc" id="L310">                log.info(&quot;params for type&quot;</span>
<span class="nc" id="L311">                    + &quot; (&quot; + segmentationType1.name() + &quot;, binned=&quot; + useBinned1 + &quot;)&quot;</span>
<span class="nc" id="L312">                    + &quot; (&quot; + segmentationType2.name() + &quot;, binned=&quot; + useBinned2 + &quot;)&quot;</span>
<span class="nc" id="L313">                    + &quot; : &quot; + params.toString());</span>

<span class="nc" id="L315">                log.info(String.format(</span>
                    &quot;stDev scale=%.1f  stDev rot=%.0f  stDev tX=%.0f  stDev tY=%.0f&quot;,
<span class="nc" id="L317">                    outputScaleRotTransXYStDev[0], outputScaleRotTransXYStDev[1],</span>
<span class="nc" id="L318">                    outputScaleRotTransXYStDev[2], outputScaleRotTransXYStDev[3]));</span>

                //TODO: review this limit
<span class="nc" id="L321">                if (</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                    ((outputScaleRotTransXYStDev[0]/params.getScale()) &lt; 0.2)</span>
                    ) {
<span class="nc" id="L324">                    return params;</span>
                }
            }

            // if arrive here, have to decide to keep current segmentation and binning or increment.
            // at least one index has to change
            
<span class="nc" id="L331">            int nContours1 = sumContours(img1Helper, segmentationType1, useBinned1);</span>

<span class="nc" id="L333">            int nContours2 = sumContours(img2Helper, segmentationType2, useBinned2);</span>
            
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (nContours1 &gt; 10) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (nContours2 &gt; 10) {</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                    if (nContours1 &gt; nContours2) {</span>
<span class="nc" id="L338">                        ordered2Idx++;</span>
                    } else {
<span class="nc" id="L340">                        ordered1Idx++;</span>
                    }
                } else {
<span class="nc" id="L343">                    ordered1Idx++;</span>
                }
<span class="nc" id="L345">                continue;</span>
            }
            
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (nContours2 &gt; 10) {</span>
<span class="nc" id="L349">                ordered1Idx++;</span>
<span class="nc" id="L350">                continue;</span>
            }

<span class="nc" id="L353">            ordered1Idx++;</span>
<span class="nc" id="L354">            ordered2Idx++;</span>
<span class="nc" id="L355">        }</span>

<span class="nc" id="L357">        return null;</span>
    }

    private int sumContours(SegmentedImageHelper imgHelper, 
        SegmentationType segmentationType, boolean useBinned) {
        
<span class="nc" id="L363">        BlobsAndContours bc = imgHelper.getBlobsAndContours(segmentationType, useBinned);</span>
        
<span class="nc" id="L365">        int n = 0;</span>
        
<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (List&lt;CurvatureScaleSpaceContour&gt; list : bc.getContours()) {</span>
<span class="nc" id="L368">            n += list.size();</span>
<span class="nc" id="L369">        }</span>
        
<span class="nc" id="L371">        return n;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
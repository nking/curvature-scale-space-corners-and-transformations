<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EdgeExtractorWithJunctions.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">EdgeExtractorWithJunctions.java</span></div><h1>EdgeExtractorWithJunctions.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.CountingSort;
import algorithms.MultiArrayMergeSort;
import algorithms.QuickSort;
import algorithms.Rotate;
import algorithms.misc.MiscDebug;
import algorithms.util.PairIntArray;
import algorithms.util.PairInt;
import algorithms.util.PairIntArrayDescendingComparator;
import algorithms.util.PairIntArrayWithColor;
import algorithms.util.PointPairInt;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;

/**
 * Edge extractor operates on an image that has already been reduced to
 * single pixel width lines and extracts edges from it, attempting to make
 * the longest edges it can - this specific edge extractor stores and uses
 * junction information, so is not as fast as EdgeExtractor.java.
 *
 Edge extraction
    Local Methods:
        (1) DFS walk through adjacent non-zero pixels to form a sequence of
            pixels called an edge.

        (2) find join points

        (3) join edges using join points

        (4) find junction points

        (5) using the junction points, splice together the edges to improve
            the edges.  Currently, improve means to make the edges longer
            (which is good for an image expected to have one contour for
             example, and doesn't harm corner finding for non-contour goals).

        (7) remove edges shorter than a minimum length (this may of may not
            be currently enabled)

  @see AbstractEdgeExtractor
  *
 * @author nichole
 */
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">public class EdgeExtractorWithJunctions extends AbstractEdgeExtractor {</span>

<span class="pc" id="L55">    private boolean debug = false;</span>

    /**
     * map with key = center of junction pixel coordinates;
     * value = set of adjacent pixels when there are more than the preceding
     * and next.
     */
<span class="pc" id="L62">    private Map&lt;Integer, Set&lt;Integer&gt;&gt; junctionMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>

    /**
     * map with key = pixel coordinates of all pixels involved in junctions;
     * value = PairInt holding index of edge that pixel is located in and
     * holding the index within that edge of the pixel.
     * for example, a pixel located in edges(0) at offset=100
     * would have PairInt(0, 100) as a value.
     */
<span class="pc" id="L71">    private Map&lt;Integer, PairInt&gt; junctionLocationMap = new HashMap&lt;Integer, PairInt&gt;();</span>

<span class="pc" id="L73">    private int defaultMaxIterJunctionJoin = 1;</span>

<span class="pc" id="L75">    private boolean singleClosedEdge = false;</span>

    // ordered so that closest are first, then the diagonals
<span class="fc" id="L78">    private static int[] dxs8 = new int[]{-1, 0, 1,  0, -1,   1, 1, -1};</span>
<span class="fc" id="L79">    private static int[] dys8 = new int[]{ 0, 1, 0, -1, -1,  -1, 1,  1};</span>

    /**
     * NOTE:  input should have a black (empty) background and edges should
     * have values &gt; 125 counts.  Edges should also have width of 1 and no larger.
     *
     * @param input
     */
    public EdgeExtractorWithJunctions(GreyscaleImage input) {

<span class="fc" id="L89">        super(input);</span>
<span class="fc" id="L90">    }</span>

    /**
     * NOTE:  input should have a black (empty) background and edges should
     * have values &gt; 125 counts.  Edges should also have width of 1 and no larger.
     * The guide image is used to alter the extracted edges back towards the
     * highest intensity pixels of the guide image.  The guide image is expected
     * to be the combined X and Y gradient image from earlier processing
     * stages.
     *
     * @param input
     * @param anEdgeGuideImage
     */
    public EdgeExtractorWithJunctions(GreyscaleImage input,
        final GreyscaleImage anEdgeGuideImage) {

<span class="nc" id="L106">        super(input, anEdgeGuideImage);</span>
<span class="nc" id="L107">    }</span>
    
    public void setToDebug() {
<span class="fc" id="L110">        debug = true;</span>
<span class="fc" id="L111">    }</span>

    public void overrideMaxNumberIterationsJunctionSplice(int nMaxIter) {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (nMaxIter &lt; 2) {</span>
<span class="nc" id="L115">            return;</span>
        }
<span class="fc" id="L117">        defaultMaxIterJunctionJoin = nMaxIter;</span>
<span class="fc" id="L118">    }</span>

    /**
     * get a hashmap of the junctions within the edges, that is the regions
     * where there are more than 2 adjacent pixels to a pixel.
     * @return hashmap with key = image pixel indexes, values = set of adjacent
     * pixels as pixel indexes.
     */
    public Map&lt;Integer, Set&lt;Integer&gt; &gt; getJunctionMap() {
<span class="fc" id="L127">        return junctionMap;</span>
    }

    /**
     * contains information needed to find any of the pixels that are part of
     * a junction.
     * @return hashmap with key = image pixel indexes, values = a PairInt with
     * x holding the edge index and y holding the offset index of the point
     * within the edge.
     */
    public Map&lt;Integer, PairInt&gt; getLocatorForJunctionAssociatedPoints() {
<span class="fc" id="L138">        return junctionLocationMap;</span>
    }

    /**
     * find the edges and return as a list of points.  The method uses a
     * DFS search through all points in the image with values &gt; 0 to link
     * adjacent sequential points into edges.
     * As a side effect, the method also populates
     * member variables edgeJunctionMap and outputIndexLocatorForJunctionPoints.
     *
     * @return
     */
    @Override
    public List&lt;PairIntArray&gt; findEdgesIntermediateSteps(List&lt;PairIntArray&gt; edges) {

<span class="fc" id="L153">        List&lt;PairIntArray&gt; output = edges;</span>

        //O(N)
<span class="fc" id="L156">        Map&lt;PairInt, PairInt&gt; joinPoints = findJoinPoints(output);</span>

        if (false &amp;&amp; debug) {
            algorithms.misc.MiscDebug.printJoinPoints(joinPoints, output);
            algorithms.misc.MiscDebug.writeJoinPointsImage(joinPoints, output,
                img);
        }

<span class="fc" id="L164">        log.fine(&quot;edges.size()=&quot; + output.size() + &quot; before join-points&quot;);</span>

<span class="fc" id="L166">        output = joinOnJoinPoints(joinPoints, output);</span>

<span class="fc" id="L168">        log.fine(&quot;edges.size()=&quot; + output.size() + &quot; after join-points&quot;);</span>

<span class="fc" id="L170">        final int nMaxIter = defaultMaxIterJunctionJoin;</span>
<span class="fc" id="L171">        int nIter = 0;</span>
<span class="fc" id="L172">        int nSplices = 0;</span>
        
<span class="fc" id="L174">        findJunctions(output);</span>
        
<span class="fc bfc" id="L176" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L177">MiscDebug.writeEdges(output, img.copyImage(), &quot;splice_before_pt1_&quot;  + </span>
<span class="fc" id="L178">MiscDebug.getCurrentTimeFormatted());</span>
}

<span class="fc bfc" id="L181" title="All 6 branches covered.">        while ((nIter == 0) || ((nIter &lt; nMaxIter) &amp;&amp; (nSplices &gt; 0))) {</span>

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (output.size() &gt; 10000) {</span>
<span class="nc" id="L184">            return output;</span>
        }

<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (debug) {</span>
<span class="fc" id="L188">                algorithms.misc.MiscDebug.printJunctions(this.junctionMap,</span>
                    output, img);
            }

            //TODO: could improve thisfor nIter &gt; 0 by only visiting the
            // edges which had changed (been spliced and fused on previous iter)

<span class="fc" id="L195">            nSplices = spliceEdgesAtJunctionsIfImproves(output);</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">            if (nSplices &gt; 0) {</span>
                
<span class="fc" id="L199">                removeEdgesShorterThan(output, 1);</span>
                
<span class="fc" id="L201">                findJunctions(output);</span>
                
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">if (debug) {</span>
<span class="nc" id="L204">MiscDebug.writeEdges(output, img.copyImage(), &quot;splice_pt1_&quot;  + </span>
<span class="nc" id="L205">MiscDebug.getCurrentTimeFormatted());</span>
}
            }

<span class="fc" id="L209">            ++nIter;</span>
        }

<span class="fc" id="L212">        findJunctions(output);</span>

<span class="fc" id="L214">        log.fine(&quot;nIter=&quot; + nIter);</span>

<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (!this.singleClosedEdge) {</span>
<span class="fc" id="L217">            return output;</span>
        }

<span class="fc" id="L220">        nIter = 0;</span>
<span class="fc" id="L221">        nSplices = 0;</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L224">MiscDebug.writeEdges(output, img.copyImage(), &quot;splice_afterpt1_&quot; </span>
<span class="fc" id="L225">+ MiscDebug.getCurrentTimeFormatted());</span>
}

<span class="fc bfc" id="L228" title="All 6 branches covered.">        while ((nIter == 0) || ((nIter &lt; nMaxIter) &amp;&amp; (nSplices &gt; 0))) {</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (nSplices &gt; 0) {</span>

<span class="fc" id="L232">                removeEdgesShorterThan(output, 1);</span>

                //TODO: this is handled in the methods invoked now so consider reducing number of times used
<span class="fc" id="L235">                findJunctions(output);</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">if (debug) {</span>
<span class="nc" id="L238">MiscDebug.writeEdges(output, img.copyImage(), &quot;splice_pt2_&quot; </span>
<span class="nc" id="L239">+ MiscDebug.getCurrentTimeFormatted());</span>
}

            }

<span class="fc" id="L244">            nSplices = 0;</span>

<span class="fc" id="L246">            int nIns = insertAdjacentForClosedCurve(output);</span>

            //nIns += insertBetweenAdjacentForClosedCurve(output);

<span class="fc" id="L250">            nSplices += nIns;</span>

<span class="fc" id="L252">            ++nIter;</span>
<span class="fc" id="L253">        }</span>

<span class="fc" id="L255">        log.fine(&quot;nIter=&quot; + nIter);</span>

<span class="fc" id="L257">        return output;</span>
    }

    /**
     * Find the join points of edges which are adjacent to one another and to
     * no other edges.  This method is intended to follow the first creation
     * of edges from the line thinned edge image to find the unambiguously
     * connectable edges.  (Note that the method findJunctions(...) is later
     * used to find where there are more than 2 adjacent pixels to any pixel.)
     *
     * runtime complexity is O(N).
     *
     * @param edges
     * @return hashmap with key = edge index and index within edge of pixel;
     * value = the adjacent pixel's edge index and index within its edge
     */
    protected Map&lt;PairInt, PairInt&gt; findJoinPoints(List&lt;PairIntArray&gt; edges) {

<span class="fc" id="L275">        int n = edges.size();</span>

<span class="fc" id="L277">        int w = img.getWidth();</span>
<span class="fc" id="L278">        int h = img.getHeight();</span>

        //with key = x, y of point
        //with value = edge index, index within edge
<span class="fc" id="L282">        Map&lt;PairInt, PairInt&gt; endPointMap = new HashMap&lt;PairInt, PairInt&gt;(2 * n);</span>

        // holds x,y points of first and last points of the edges
<span class="fc" id="L285">        ArrayDeque&lt;PairInt&gt; endPointQueue = new ArrayDeque&lt;PairInt&gt;(2 * n);</span>

        //with key = edge index, index within edge of one join point
        //                 (the join point with the smaller edge number)
        //       with value = edge index, index within edge of other join point
<span class="fc" id="L290">        Set&lt;PointPairInt&gt; theJoinPoints = new HashSet&lt;PointPairInt&gt;(2 * n);</span>

        //with key = edge number
        //with value = set of the entries in theJoinPoints for which one has a
        //first end point in this edge
<span class="fc" id="L295">        Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; edgeFirstEndPointMap =</span>
            new HashMap&lt;Integer, Set&lt;PointPairInt&gt;&gt;();

<span class="fc" id="L298">        Map&lt;Integer, Set&lt;PointPairInt&gt;&gt;  edgeLastEndPointMap =</span>
            new HashMap&lt;Integer, Set&lt;PointPairInt&gt;&gt; ();

        // 2* O(N_edges)
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (int edgeIdx = 0; edgeIdx &lt; n; edgeIdx++) {</span>

<span class="fc" id="L304">            PairIntArray edge = edges.get(edgeIdx);</span>

<span class="fc" id="L306">            int nEdge = edge.getN();</span>

<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (nEdge == 0) {</span>
<span class="nc" id="L309">                continue;</span>
            }

<span class="fc" id="L312">            PairInt xy = new PairInt(edge.getX(0), edge.getY(0));</span>
<span class="fc" id="L313">            PairInt loc = new PairInt(edgeIdx, 0);</span>

<span class="fc" id="L315">            endPointMap.put(xy, loc);</span>
<span class="fc" id="L316">            endPointQueue.add(xy);</span>

<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if (nEdge == 1) {</span>
<span class="nc" id="L319">                continue;</span>
            }

<span class="fc" id="L322">            xy = new PairInt(edge.getX(nEdge - 1), edge.getY(nEdge - 1));</span>
<span class="fc" id="L323">            loc = new PairInt(edgeIdx, nEdge - 1);</span>

<span class="fc" id="L325">            endPointMap.put(xy, loc);</span>
<span class="fc" id="L326">            endPointQueue.add(xy);</span>

<span class="fc bfc" id="L328" title="All 2 branches covered.">            if (nEdge == 2) {</span>
<span class="fc" id="L329">                continue;</span>
            }

            // add the second and second to last to endPointMap only
<span class="fc" id="L333">            xy = new PairInt(edge.getX(1), edge.getY(1));</span>
<span class="fc" id="L334">            loc = new PairInt(edgeIdx, 1);</span>
<span class="fc" id="L335">            endPointMap.put(xy, loc);</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">            if (nEdge == 3) {</span>
<span class="fc" id="L338">                continue;</span>
            }

<span class="fc" id="L341">            xy = new PairInt(edge.getX(nEdge - 2), edge.getY(nEdge - 2));</span>
<span class="fc" id="L342">            loc = new PairInt(edgeIdx, nEdge - 2);</span>
<span class="fc" id="L343">            endPointMap.put(xy, loc);</span>
        }

<span class="pc bpc" id="L346" title="3 of 4 branches missed.">        assert(endPointQueue.size() &gt;= n);</span>
<span class="pc bpc" id="L347" title="3 of 4 branches missed.">        assert(endPointMap.size() &gt;= 2*n);</span>

<span class="fc bfc" id="L349" title="All 2 branches covered.">        while (!endPointQueue.isEmpty()) {</span>

<span class="fc" id="L351">            PairInt uXY = endPointQueue.poll();</span>
<span class="fc" id="L352">            int uX = uXY.getX();</span>
<span class="fc" id="L353">            int uY = uXY.getY();</span>

<span class="fc" id="L355">            PairInt uLoc = endPointMap.get(uXY);</span>

<span class="pc bpc" id="L357" title="3 of 4 branches missed.">            assert(uLoc != null);</span>

<span class="fc" id="L359">            int uEdgeIdx = uLoc.getX();</span>

<span class="fc" id="L361">            Set&lt;Integer&gt; neighborEdgeNumbers = new HashSet&lt;Integer&gt;();</span>

<span class="fc" id="L363">            PairInt vClosestXY = null;</span>
<span class="fc" id="L364">            PairInt vClosestLoc = null;</span>
<span class="fc" id="L365">            int closestDistSq = Integer.MAX_VALUE;</span>
<span class="fc" id="L366">            int vClosestCanBeReordered = -99;</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">            for (int nIdx = 0; nIdx &lt; dxs8.length; nIdx++) {</span>
<span class="fc" id="L369">                int vX = uX + dxs8[nIdx];</span>
<span class="fc" id="L370">                int vY = uY + dys8[nIdx];</span>
<span class="fc bfc" id="L371" title="All 8 branches covered.">                if ((vX &lt; 0) || (vX &gt; (w - 1)) || (vY &lt; 0) || (vY &gt; (h - 1))) {</span>
<span class="fc" id="L372">                    continue;</span>
                }
<span class="fc" id="L374">                PairInt vXY = new PairInt(vX, vY);</span>

<span class="fc" id="L376">                PairInt vLoc = endPointMap.get(vXY);</span>

<span class="fc bfc" id="L378" title="All 4 branches covered.">                if ((vLoc == null) || (vLoc.getX() == uEdgeIdx)) {</span>
<span class="fc" id="L379">                    continue;</span>
                }

<span class="fc" id="L382">                int vEdgeIdx = vLoc.getX();</span>

<span class="fc" id="L384">                neighborEdgeNumbers.add(Integer.valueOf(vEdgeIdx));</span>

<span class="fc bfc" id="L386" title="All 2 branches covered.">                if (neighborEdgeNumbers.size() &gt; 1) {</span>
                    // this is a junction, so break and continue at next uXY
<span class="fc" id="L388">                    break;</span>
                }

<span class="fc" id="L391">                PairIntArray vEdge = edges.get(vEdgeIdx);</span>

<span class="fc" id="L393">                int canBeReordered = canBeReordered(vLoc, vEdge);</span>

<span class="fc bfc" id="L395" title="All 2 branches covered.">                if (canBeReordered == -1) {</span>
<span class="fc" id="L396">                    continue;</span>
                }

<span class="fc" id="L399">                int diffX = uX - vX;</span>
<span class="fc" id="L400">                int diffY = uY - vY;</span>
<span class="fc" id="L401">                int distSq = (diffX * diffX) + (diffY * diffY);</span>

<span class="pc bpc" id="L403" title="1 of 6 branches missed.">                if ((distSq &lt; closestDistSq) || ((distSq == closestDistSq)</span>
                    &amp;&amp; (canBeReordered == 0))) {

<span class="fc" id="L406">                    closestDistSq = distSq;</span>
<span class="fc" id="L407">                    vClosestLoc = vLoc;</span>
<span class="fc" id="L408">                    vClosestXY = vXY;</span>
<span class="fc" id="L409">                    vClosestCanBeReordered = canBeReordered;</span>
                }
            }

<span class="fc bfc" id="L413" title="All 4 branches covered.">            if ((neighborEdgeNumbers.size() != 1) || (vClosestXY == null)) {</span>
<span class="fc" id="L414">                continue;</span>
            }

            // make the smaller edge number as variables '0'
<span class="fc" id="L418">            PairInt xy0 = uXY;</span>
<span class="fc" id="L419">            PairInt xy1 = vClosestXY;</span>
<span class="fc" id="L420">            PairInt loc0 = uLoc;</span>
<span class="fc" id="L421">            PairInt loc1 = vClosestLoc;</span>
<span class="fc" id="L422">            boolean smallestEdgeIdxIsV = false;</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (loc0.getX() &gt; loc1.getX()) {</span>
<span class="fc" id="L424">                PairInt swap = loc0;</span>
<span class="fc" id="L425">                loc0 = loc1;</span>
<span class="fc" id="L426">                loc1 = swap;</span>
<span class="fc" id="L427">                smallestEdgeIdxIsV = true;</span>
<span class="fc" id="L428">                swap = xy0;</span>
<span class="fc" id="L429">                xy0 = xy1;</span>
<span class="fc" id="L430">                xy1 = swap;</span>
            }
<span class="fc" id="L432">            int n0 = edges.get(loc0.getX()).getN();</span>
<span class="fc" id="L433">            int n1 = edges.get(loc1.getX()).getN();</span>

<span class="fc" id="L435">            theJoinPoints.add(new PointPairInt(loc0, loc1));</span>

            // add the location points to the edgeFirstEndPointMap and
            // edgeLastEndPointMap maps
<span class="fc bfc" id="L439" title="All 2 branches covered.">            for (int ii = 0; ii &lt; 2; ++ii) {</span>
<span class="fc" id="L440">                int locX = loc0.getX();</span>
<span class="fc" id="L441">                int locY = loc0.getY();</span>
<span class="fc" id="L442">                int nEdge = n0;</span>

<span class="fc bfc" id="L444" title="All 2 branches covered.">                if (ii == 1) {</span>
<span class="fc" id="L445">                    locX = loc1.getX();</span>
<span class="fc" id="L446">                    locY = loc1.getY();</span>
<span class="fc" id="L447">                    nEdge = n1;</span>
                }

<span class="fc bfc" id="L450" title="All 2 branches covered.">                boolean addToFirst = (locY &lt; 2);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                boolean addToLast = (locY &gt; (nEdge - 3));</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">                if (nEdge == 2) {</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                    if (locY == 1) {</span>
<span class="fc" id="L454">                        addToFirst = false;</span>
<span class="fc" id="L455">                        addToLast = true;</span>
                    } else {
<span class="fc" id="L457">                        addToFirst = true;</span>
<span class="fc" id="L458">                        addToLast = false;</span>
                    }
                }

<span class="fc bfc" id="L462" title="All 8 branches covered.">                if ((ii == 0) &amp;&amp; smallestEdgeIdxIsV &amp;&amp; (vClosestCanBeReordered == 1) &amp;&amp; (n0 == 3)) {</span>
<span class="fc" id="L463">                    log.fine(String.format(</span>
                    &quot;creating a join point for an edge with size 3: xy=(%d,%d) loc=%d:%d&quot;,
<span class="fc" id="L465">                    vClosestLoc.getX(), vClosestLoc.getY(), vClosestLoc.getX(),</span>
<span class="fc" id="L466">                    vClosestLoc.getY()));</span>
                    // an entry is added to both edge maps because we don't know yet
                    // which to use.
                }

<span class="fc bfc" id="L471" title="All 2 branches covered.">                if (addToFirst) {</span>
<span class="fc" id="L472">                    Integer key = Integer.valueOf(locX);</span>
<span class="fc" id="L473">                    Set&lt;PointPairInt&gt; joinPointSet = edgeFirstEndPointMap.get(key);</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">                    if (joinPointSet == null) {</span>
<span class="fc" id="L475">                        joinPointSet = new HashSet&lt;PointPairInt&gt;();</span>
                    }
<span class="fc" id="L477">                    PointPairInt joinPoint = new PointPairInt(loc0, loc1);</span>
<span class="fc" id="L478">                    joinPointSet.add(joinPoint);</span>
<span class="fc" id="L479">                    edgeFirstEndPointMap.put(key, joinPointSet);</span>
                }

<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (addToLast) {</span>
<span class="fc" id="L483">                    Integer key = Integer.valueOf(locX);</span>
<span class="fc" id="L484">                    Set&lt;PointPairInt&gt; joinPointSet = edgeLastEndPointMap.get(key);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">                    if (joinPointSet == null) {</span>
<span class="fc" id="L486">                        joinPointSet = new HashSet&lt;PointPairInt&gt;();</span>
                    }
<span class="fc" id="L488">                    PointPairInt joinPoint = new PointPairInt(loc0, loc1);</span>
<span class="fc" id="L489">                    joinPointSet.add(joinPoint);</span>
<span class="fc" id="L490">                    edgeLastEndPointMap.put(key, joinPointSet);</span>
                }
            }
<span class="fc" id="L493">        }</span>

<span class="fc" id="L495">        reduceMultipleEndpointsForEdge(edges, edgeFirstEndPointMap,</span>
            edgeLastEndPointMap, endPointMap, theJoinPoints);

<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (debug) {</span>
            // 2 of the same join points for edges of size 3 in which
            // the join point is movable to the first or last point in edge.
            // the next block removes that possibility
<span class="fc" id="L502">            boolean skipForSize3 = true;</span>
<span class="fc" id="L503">            algorithms.misc.MiscDebug.assertConsistentJoinPointStructures(edges,</span>
                edgeFirstEndPointMap, edgeLastEndPointMap, theJoinPoints,
                skipForSize3);
        }

        // edges that are size 3 and have join points that are not in the
        // first or last position, can be moved to either, so keep
        // track of them to avoid moving to the same position twice
<span class="fc" id="L511">        Map&lt;PairInt, Set&lt;Integer&gt;&gt; edgeSize3NonEndPoints = new HashMap&lt;PairInt,</span>
            Set&lt;Integer&gt;&gt;();
<span class="fc bfc" id="L513" title="All 2 branches covered.">        for (PointPairInt entry : theJoinPoints) {</span>
<span class="fc" id="L514">            PairInt loc0 = entry.getKey();</span>
<span class="fc" id="L515">            PairInt loc1 = entry.getValue();</span>
<span class="fc" id="L516">            int n0 = edges.get(loc0.getX()).getN();</span>
<span class="fc" id="L517">            int n1 = edges.get(loc1.getX()).getN();</span>
<span class="fc bfc" id="L518" title="All 4 branches covered.">            if ((n0 == 3) &amp;&amp; (loc0.getY() == 1)) {</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">                if (!edgeSize3NonEndPoints.containsKey(loc0)) {</span>
<span class="fc" id="L520">                    edgeSize3NonEndPoints.put(loc0, new HashSet&lt;Integer&gt;());</span>
                }
            }
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">            if ((n1 == 3) &amp;&amp; (loc1.getY() == 1)) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                if (!edgeSize3NonEndPoints.containsKey(loc1)) {</span>
<span class="nc" id="L525">                    edgeSize3NonEndPoints.put(loc1, new HashSet&lt;Integer&gt;());</span>
                }
            }
<span class="fc" id="L528">        }</span>

        // 2 * O(N_join_points)
        // re-order the endpoints which are not first or last position in edge
<span class="fc bfc" id="L532" title="All 2 branches covered.">        for (PointPairInt entry : theJoinPoints) {</span>
<span class="fc" id="L533">            PairInt loc0 = entry.getKey();</span>
<span class="fc" id="L534">            PairInt loc1 = entry.getValue();</span>

<span class="fc" id="L536">            PairIntArray edge0 = edges.get(loc0.getX());</span>
<span class="fc" id="L537">            PairIntArray edge1 = edges.get(loc1.getX());</span>

<span class="fc" id="L539">            PairInt origLoc0 = new PairInt(loc0.getX(), loc0.getY());</span>

<span class="fc" id="L541">            int swapIdx = -1;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (edgeSize3NonEndPoints.containsKey(loc0)) {</span>
<span class="fc" id="L543">                swapIdx = 0;</span>
<span class="fc" id="L544">                Set&lt;Integer&gt; takenPositions = edgeSize3NonEndPoints.get(loc0);</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">                if (takenPositions.size() &gt; 1) {</span>
<span class="nc" id="L546">                    throw new IllegalStateException(</span>
                        &quot;then are more than 2 join points for the same edge of size 3.&quot; +
<span class="nc" id="L548">                        &quot; edge &quot; + loc0.getX() + &quot; xy=(&quot; + edge0.getX(loc0.getY())</span>
<span class="nc" id="L549">                        + &quot;,&quot; + edge0.getY(loc0.getY()) +&quot;)&quot;);</span>
                }
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (!takenPositions.isEmpty()) {</span>
<span class="nc" id="L552">                    swapIdx = 2;</span>
                }
<span class="fc" id="L554">                takenPositions.add(Integer.valueOf(swapIdx));</span>
<span class="fc" id="L555">            } else  {</span>
<span class="fc" id="L556">                int canBeReordered = canBeReordered(loc0, edge0);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                if (canBeReordered == 1) {</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">                    if (loc0.getY() &lt; 2) {</span>
<span class="nc" id="L559">                        swapIdx = 0;</span>
                    } else {
<span class="fc" id="L561">                        swapIdx = edge0.getN() - 1;</span>
                    }
                }
            }
<span class="fc bfc" id="L565" title="All 2 branches covered.">            if (swapIdx &gt; -1) {</span>
<span class="fc" id="L566">                int swapX = edge0.getX(swapIdx);</span>
<span class="fc" id="L567">                int swapY = edge0.getY(swapIdx);</span>
<span class="fc" id="L568">                edge0.set(swapIdx, edge0.getX(1), edge0.getY(1));</span>
<span class="fc" id="L569">                edge0.set(1, swapX, swapY);</span>
<span class="fc" id="L570">                loc0.setY(swapIdx);</span>
            }

<span class="fc" id="L573">            swapIdx = -1;</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">            if (edgeSize3NonEndPoints.containsKey(loc1)) {</span>
<span class="nc" id="L575">                swapIdx = 0;</span>
<span class="nc" id="L576">                Set&lt;Integer&gt; takenPositions = edgeSize3NonEndPoints.get(loc1);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if (takenPositions.size() &gt; 1) {</span>
<span class="nc" id="L578">                    throw new IllegalStateException(</span>
                        &quot;then are more than 2 join points for the same edge of size 3.&quot; +
<span class="nc" id="L580">                        &quot; edge &quot; + loc1.getX() + &quot; xy=(&quot; + edge1.getX(loc1.getY())</span>
<span class="nc" id="L581">                        + &quot;,&quot; + edge1.getY(loc1.getY()) +&quot;)&quot;);</span>
                }
<span class="nc bnc" id="L583" title="All 2 branches missed.">                if (!takenPositions.isEmpty()) {</span>
<span class="nc" id="L584">                    swapIdx = 2;</span>
                }
<span class="nc" id="L586">                takenPositions.add(Integer.valueOf(swapIdx));</span>
<span class="nc" id="L587">            } else  {</span>
<span class="fc" id="L588">                int canBeReordered = canBeReordered(loc1, edge1);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">                if (canBeReordered == 1) {</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">                    if (loc1.getY() &lt; 2) {</span>
<span class="nc" id="L591">                        swapIdx = 0;</span>
                    } else {
<span class="fc" id="L593">                        swapIdx = edge1.getN() - 1;</span>
                    }
                }
            }
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (swapIdx &gt; -1) {</span>
<span class="fc" id="L598">                int swapX = edge1.getX(swapIdx);</span>
<span class="fc" id="L599">                int swapY = edge1.getY(swapIdx);</span>
<span class="fc" id="L600">                edge1.set(swapIdx, edge1.getX(1), edge1.getY(1));</span>
<span class="fc" id="L601">                edge1.set(1, swapX, swapY);</span>
<span class="fc" id="L602">                loc1.setY(swapIdx);</span>
            }
<span class="fc" id="L604">        }</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L607">            boolean skipForSize3 = false;</span>
<span class="fc" id="L608">            algorithms.misc.MiscDebug.assertConsistentJoinPointStructures(edges,</span>
                edgeFirstEndPointMap, edgeLastEndPointMap, theJoinPoints,
                skipForSize3);
        }

<span class="fc" id="L613">        Map&lt;PairInt, PairInt&gt; result = new HashMap&lt;PairInt, PairInt&gt;();</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        for (PointPairInt entry : theJoinPoints) {</span>
<span class="fc" id="L615">            PairInt loc0 = entry.getKey();</span>
<span class="fc" id="L616">            PairInt loc1 = entry.getValue();</span>
<span class="fc" id="L617">            result.put(loc0, loc1);</span>
<span class="fc" id="L618">        }</span>

<span class="fc" id="L620">        return result;</span>
    }

    /**
     * Iterate over each point looking for its neighbors and noting when
     * there are more than 2, and store the found junctions as member variables.
     *
     * runtime complexity is O(N)
     *
     * @param edges
     */
    protected void findJunctions(List&lt;PairIntArray&gt; edges) {

        // key = center of junction pixel coordinates
        // value = set of adjacent pixels when there are more than the preceding
        //         and next.
<span class="fc" id="L636">        Map&lt;Integer, Set&lt;Integer&gt; &gt; theJunctionMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>

        // key = pixel coordinates of all pixels involved in junctions
        // value = PairInt holding index of edge that pixel is located in and
        //         holding the index within that edge of the pixel.
        //         for example, a pixel located in edges(0) at offset=100
        //         would have PairInt(0, 100) as a value.
<span class="fc" id="L643">        Map&lt;Integer, PairInt&gt; theJunctionLocationMap = new HashMap&lt;Integer, PairInt&gt;();</span>

<span class="fc" id="L645">        int w = img.getWidth();</span>
<span class="fc" id="L646">        int h = img.getHeight();</span>

<span class="fc" id="L648">        findJunctions(edges, theJunctionMap, theJunctionLocationMap, w, h);</span>

<span class="fc" id="L650">        junctionMap = theJunctionMap;</span>
<span class="fc" id="L651">        junctionLocationMap = theJunctionLocationMap;</span>
<span class="fc" id="L652">    }</span>

    /**
     * Iterate over each point looking for its neighbors and noting when
     * there are more than 2, and store the found junctions as member variables.
     *
     * runtime complexity is O(N)
     *
     * @param edges
     */
    protected static void findJunctions(List&lt;PairIntArray&gt; edges,
        Map&lt;Integer, Set&lt;Integer&gt; &gt; theJunctionMap,
        Map&lt;Integer, PairInt&gt; theJunctionLocationMap,
        int imageWidth, int imageHeight) {

<span class="fc" id="L667">        int n = edges.size();</span>

        // key = image pixel index,
        // value = pairint of edge index, and index within edge
<span class="fc" id="L671">        Map&lt;Integer, PairInt&gt; pointLocator = new HashMap&lt;Integer, PairInt&gt;();</span>

        // key = center of junction pixel coordinates
        // value = number of times this point is a value in the first theJunctionMap
<span class="fc" id="L675">        Map&lt;Integer, Integer&gt; theJunctionFrequencyMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="fc" id="L677">        int w = imageWidth;</span>
<span class="fc" id="L678">        int h = imageHeight;</span>

        // O(N)
<span class="fc bfc" id="L681" title="All 2 branches covered.">        for (int edgeIdx = 0; edgeIdx &lt; n; ++edgeIdx) {</span>

<span class="fc" id="L683">            PairIntArray edge = edges.get(edgeIdx);</span>

<span class="fc bfc" id="L685" title="All 2 branches covered.">            for (int uIdx = 0; uIdx &lt; edge.getN(); ++uIdx) {</span>

<span class="fc" id="L687">                int col = edge.getX(uIdx);</span>
<span class="fc" id="L688">                int row = edge.getY(uIdx);</span>

<span class="fc" id="L690">                int uPixIdx = (row * w) + col;</span>

<span class="fc" id="L692">                pointLocator.put(Integer.valueOf(uPixIdx), new PairInt(edgeIdx,</span>
                    uIdx));
            }
        }

        // 8 * O(N)
<span class="fc bfc" id="L698" title="All 2 branches covered.">        for (int edgeIdx = 0; edgeIdx &lt; n; ++edgeIdx) {</span>

<span class="fc" id="L700">            PairIntArray edge = edges.get(edgeIdx);</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">            for (int uIdx = 0; uIdx &lt; edge.getN(); ++uIdx) {</span>

<span class="fc" id="L704">                int col = edge.getX(uIdx);</span>
<span class="fc" id="L705">                int row = edge.getY(uIdx);</span>

<span class="fc" id="L707">                int uPixIdx = (row * w) + col;</span>

<span class="fc" id="L709">                Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L711" title="All 2 branches covered.">                for (int nIdx = 0; nIdx &lt; dxs8.length; ++nIdx) {</span>

<span class="fc" id="L713">                    int x = col + dxs8[nIdx];</span>
<span class="fc" id="L714">                    int y = row + dys8[nIdx];</span>

<span class="fc bfc" id="L716" title="All 8 branches covered.">                    if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="fc" id="L717">                        continue;</span>
                    }

<span class="fc" id="L720">                    int vPixIdx = (y * w) + x;</span>

<span class="fc" id="L722">                    PairInt vLoc = pointLocator.get(Integer.valueOf(vPixIdx));</span>

<span class="fc bfc" id="L724" title="All 2 branches covered.">                    if (vLoc != null) {</span>
<span class="fc" id="L725">                        neighbors.add(vLoc);</span>
                    }
                }

<span class="fc bfc" id="L729" title="All 2 branches covered.">                if (neighbors.size() &gt; 2) {</span>

<span class="fc" id="L731">                    Set&lt;Integer&gt; indexes = new HashSet&lt;Integer&gt;();</span>

<span class="fc bfc" id="L733" title="All 2 branches covered.">                    for (PairInt p : neighbors) {</span>

<span class="fc" id="L735">                        int edge2Idx = p.getX();</span>
<span class="fc" id="L736">                        int vIdx = p.getY();</span>

<span class="fc" id="L738">                        PairIntArray vEdge = edges.get(edge2Idx);</span>

<span class="fc" id="L740">                        int vPixIdx = (vEdge.getY(vIdx) * w) + vEdge.getX(vIdx);</span>

<span class="fc" id="L742">                        Integer key = Integer.valueOf(vPixIdx);</span>

<span class="fc" id="L744">                        theJunctionLocationMap.put(key, p);</span>

<span class="fc" id="L746">                        indexes.add(key);</span>

<span class="fc" id="L748">                        Integer freq = theJunctionFrequencyMap.get(key);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">                        if (freq == null) {</span>
<span class="fc" id="L750">                            theJunctionFrequencyMap.put(key, Integer.valueOf(1));</span>
                        } else {
<span class="fc" id="L752">                            theJunctionFrequencyMap.put(key,</span>
<span class="fc" id="L753">                                Integer.valueOf(freq.intValue() + 1));</span>
                        }
<span class="fc" id="L755">                    }</span>

<span class="fc" id="L757">                    theJunctionMap.put(Integer.valueOf(uPixIdx), indexes);</span>

<span class="fc" id="L759">                    theJunctionLocationMap.put(Integer.valueOf(uPixIdx),</span>
                        new PairInt(edgeIdx, uIdx));
                }

                // if (neighbors.size() == 2) is handled in findJoinPoints
            }
        }

        // visit each junction and make sure the real center is the only one
        // stored
<span class="fc" id="L769">        Set&lt;Integer&gt; remove = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L770">        Set&lt;Integer&gt; doNotRemove = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : theJunctionMap.entrySet()) {</span>

<span class="fc" id="L773">            Integer pixelIndex = entry.getKey();</span>

<span class="fc" id="L775">            Set&lt;Integer&gt; neighborIndexes = entry.getValue();</span>
<span class="fc" id="L776">            int nN = neighborIndexes.size();</span>

<span class="fc" id="L778">            int maxN = Integer.MIN_VALUE;</span>

<span class="fc bfc" id="L780" title="All 2 branches covered.">            for (Integer pixelIndex2 : neighborIndexes) {</span>

<span class="fc bfc" id="L782" title="All 2 branches covered.">                if (remove.contains(pixelIndex2)) {</span>
<span class="fc" id="L783">                    continue;</span>
                }

<span class="fc" id="L786">                Set&lt;Integer&gt; neighborIndexes2 = theJunctionMap.get(pixelIndex2);</span>

<span class="fc bfc" id="L788" title="All 2 branches covered.">                if (neighborIndexes2 == null) {</span>
<span class="fc" id="L789">                    continue;</span>
                }

<span class="fc bfc" id="L792" title="All 2 branches covered.">                if (neighborIndexes2.size() &gt; nN) {</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">                    if (neighborIndexes2.size() &gt; maxN) {</span>
<span class="fc" id="L794">                        maxN = neighborIndexes2.size();</span>
                    }
                }
<span class="fc" id="L797">            }</span>

<span class="fc bfc" id="L799" title="All 2 branches covered.">            if (maxN &gt; Integer.MIN_VALUE) {</span>

<span class="pc bpc" id="L801" title="1 of 2 branches missed.">                if (!doNotRemove.contains(pixelIndex)) {</span>
<span class="fc" id="L802">                    remove.add(pixelIndex);</span>
                }

            } else {
<span class="fc" id="L806">                doNotRemove.add(pixelIndex);</span>
                // remove the neighbors from the junction map
<span class="fc bfc" id="L808" title="All 2 branches covered.">                for (Integer pixelIndex2 : neighborIndexes) {</span>
<span class="fc" id="L809">                    int mapFreq2 = theJunctionFrequencyMap.get(pixelIndex2);</span>

<span class="fc bfc" id="L811" title="All 4 branches covered.">                    if (!doNotRemove.contains(pixelIndex2) &amp;&amp; (mapFreq2 == 1)) {</span>
<span class="fc" id="L812">                        remove.add(pixelIndex2);</span>
                    }
<span class="fc" id="L814">                }</span>
            }
<span class="fc" id="L816">        }</span>

<span class="fc bfc" id="L818" title="All 2 branches covered.">        for (Integer pixelIndex : remove) {</span>
<span class="fc" id="L819">            theJunctionMap.remove(pixelIndex);</span>
<span class="fc" id="L820">        }</span>

<span class="fc" id="L822">    }</span>

    private Map&lt;Integer, PairIntArray&gt; createIndexedMap(List&lt;PairIntArray&gt; edges) {

<span class="fc" id="L826">        Map&lt;Integer, PairIntArray&gt; output = new HashMap&lt;Integer, PairIntArray&gt;();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
<span class="fc" id="L828">            output.put(Integer.valueOf(i), edges.get(i));</span>
        }

<span class="fc" id="L831">        return output;</span>
    }

    /**
     * join edges using information in the member variable joinPoints
     * and update the junction and joinPoint information after the
     * changes.  Note that the join points must be first or last positions
     * in an edge in edges.
     * @param joinPoints map with key = the PairInt with x being the edge index
     * and y being the index of the first join point within the edge, value =
     * the PairInt with x being the edge index
     * and y being the index of the other join point within the edge
     * @param edges
     * @return
     */
    protected List&lt;PairIntArray&gt; joinOnJoinPoints(Map&lt;PairInt, PairInt&gt;
        joinPoints, List&lt;PairIntArray&gt; edges) {

        //order the join points by the edge number of the first join point

<span class="fc" id="L851">        int[] indexes = new int[joinPoints.size()];</span>
<span class="fc" id="L852">        PairInt[][] edgeJoins = new PairInt[joinPoints.size()][2];</span>
<span class="fc" id="L853">        int count = 0;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">        for (Entry&lt;PairInt, PairInt&gt; entry : joinPoints.entrySet()) {</span>
<span class="fc" id="L855">            PairInt loc0 = entry.getKey();</span>
<span class="fc" id="L856">            PairInt loc1 = entry.getValue();</span>
<span class="fc" id="L857">            indexes[count] = loc0.getX();</span>
<span class="fc" id="L858">            edgeJoins[count] = new PairInt[]{loc0, loc1};</span>
<span class="fc" id="L859">            count++;</span>
<span class="fc" id="L860">        }</span>
<span class="fc" id="L861">        QuickSort.sortBy1stArg(indexes, edgeJoins);</span>

<span class="fc" id="L863">long nPointsBefore = countPixelsInEdges(edges);</span>

        // put the edges in a map to remove and search updates faster
<span class="fc" id="L866">        Map&lt;Integer, PairIntArray&gt; edgesMap = createIndexedMap(edges);</span>

<span class="fc" id="L868">        int n = edgeJoins.length;</span>

<span class="fc bfc" id="L870" title="All 2 branches covered.">        for (int i = (n - 1); i &gt; -1; --i) {</span>

//algorithms.misc.MiscDebug.printJoinPoints(edgeJoins, 0, i, edgesMap);

<span class="fc" id="L874">            PairInt[] entry = edgeJoins[i];</span>

<span class="fc" id="L876">            PairInt loc0 = entry[0];</span>

<span class="fc" id="L878">            PairInt loc1 = entry[1];</span>

            // if they've already been merged
<span class="fc bfc" id="L881" title="All 2 branches covered.">            if (loc0.getX() == loc1.getX()) {</span>
<span class="fc" id="L882">                continue;</span>
            }

            // the smaller edge index should be loc1 and the larger loc0,
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">            if (loc1.getX() &gt; loc0.getX()) {</span>
<span class="fc" id="L887">                PairInt tmp = loc0;</span>
<span class="fc" id="L888">                loc0 = loc1;</span>
<span class="fc" id="L889">                loc1 = tmp;</span>
            }
<span class="fc" id="L891">            final int edge0Idx = loc0.getX();</span>
<span class="fc" id="L892">            final int edge1Idx = loc1.getX();</span>

            // edge to move
<span class="fc" id="L895">            int removedEdgeIdx = edge0Idx;</span>
<span class="fc" id="L896">            PairIntArray edge0 = edgesMap.remove(Integer.valueOf(removedEdgeIdx));</span>

<span class="fc" id="L898">            int n0 = edge0.getN();</span>

<span class="pc bpc" id="L900" title="1 of 4 branches missed.">            if ((loc0.getY() != 0) &amp;&amp; (loc0.getY() != (n0 - 1))){</span>
                /*
                this can happen if there is an error in the join point algorithm
                resulting in the same join point to 2 different edges.  an update
                in the location will eventually be an error in one of them.

                After more testing, will change this to discard the join point
                and warn of error.
                */
<span class="nc" id="L909">                throw new IllegalStateException(&quot;ERROR in the updates? &quot; +</span>
<span class="nc" id="L910">                    &quot; loc0=&quot; + edge0Idx + &quot;,&quot; + loc0.getY() + &quot; n=&quot; + n0 +</span>
                    &quot; i=&quot; + i + &quot; (nedges=&quot; + n + &quot;) to append edge &quot;
                    + edge0Idx + &quot; to edge &quot; + edge1Idx);
            }

            // join point should be at the beginning, so reverse if not
<span class="fc bfc" id="L916" title="All 2 branches covered.">            if (loc0.getY() == (n0 - 1)) {</span>

<span class="fc" id="L918">                edge0.reverse();</span>
<span class="fc" id="L919">                loc0.setY(0);</span>

                // everything with smaller index than i in edgeJoins with
                // edgeIndex==loc0.getX() needs to be updated for this reversal.
                // idx becomes n-idx-1
<span class="fc bfc" id="L924" title="All 2 branches covered.">                for (int j = (i - 1); j &gt; -1; --j) {</span>
<span class="fc" id="L925">                    PairInt[] vEntry = edgeJoins[j];</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">                    for (int k = 0; k &lt; 2; k++) {</span>
<span class="fc" id="L927">                        PairInt vLoc = vEntry[k];</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">                        if (vLoc.getX() == edge0Idx) {</span>
<span class="fc" id="L929">                            int idxRev = n0 - vLoc.getY() - 1;</span>
<span class="fc" id="L930">                            vLoc.setY(idxRev);</span>
                        }
                    }
                }
            }
            // edge to receive new edge
<span class="fc" id="L936">            PairIntArray edge1 = edgesMap.get(Integer.valueOf(loc1.getX()));</span>
<span class="fc" id="L937">            int n1 = edge1.getN();</span>
            // endpoint should be at the end, so reverse if not
<span class="fc bfc" id="L939" title="All 2 branches covered.">            if (loc1.getY() == 0) {</span>

<span class="fc" id="L941">                edge1.reverse();</span>
<span class="fc" id="L942">                loc1.setY(n1 - 1);</span>

                // everything with smaller index than i in edgeJoins that has
                // edgeIndex==loc1.getX() needs to be updated for this reversal.
                // idx becomes n-idx-1
<span class="fc bfc" id="L947" title="All 2 branches covered.">                for (int j = (i - 1); j &gt; -1; --j) {</span>
<span class="fc" id="L948">                    PairInt[] vEntry = edgeJoins[j];</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">                    for (int k = 0; k &lt; 2; k++) {</span>
<span class="fc" id="L950">                        PairInt vLoc = vEntry[k];</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">                        if (vLoc.getX() == edge1Idx) {</span>
<span class="fc" id="L952">                            int idxRev = n1 - vLoc.getY() - 1;</span>
<span class="fc" id="L953">                            vLoc.setY(idxRev);</span>
                        }
                    }
                }
            }

<span class="fc" id="L959">            final int indexWithinEdge0 = loc0.getY();</span>
<span class="fc" id="L960">            final int indexWithinEdge1 = loc1.getY();</span>

            // --- append edge0 to edge1 ----
<span class="fc" id="L963">            edge1.addAll(edge0);</span>

            // for earlier items in array edgeJoins
            // need to update all edge indexes and indexes within edge.

            // loc0 got appended to loc1 --&gt; [edge1][edge0]
            // points in edge0 need n1 added to them

            // first, will only update the indexes within the edge for
            // edgeIndex == loc0.getX()
            //     the new offset index = n0 + index
<span class="fc bfc" id="L974" title="All 2 branches covered.">            for (int j = (i - 1); j &gt; -1; --j) {</span>
<span class="fc" id="L975">                PairInt[] vEntry = edgeJoins[j];</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">                for (int k = 0; k &lt; 2; k++) {</span>
<span class="fc" id="L977">                    PairInt vLoc = vEntry[k];</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">                    if (vLoc.getX() == edge0Idx) {</span>
<span class="fc" id="L979">                        int idxEdit = vLoc.getY() + n1;</span>
<span class="fc" id="L980">                        vLoc.setY(idxEdit);</span>
                    }
                }
            }

            // any edge index &gt; loc0 gets reduced by one, but if == it gets replaced by loc1.getX()
<span class="fc bfc" id="L986" title="All 2 branches covered.">            for (int j = (i - 1); j &gt; -1; --j) {</span>
<span class="fc" id="L987">                PairInt[] vEntry = edgeJoins[j];</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">                for (int k = 0; k &lt; 2; k++) {</span>
<span class="fc" id="L989">                    PairInt vLoc = vEntry[k];</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">                    if (vLoc.getX() &gt; edge0Idx) {</span>
<span class="fc" id="L991">                        int editX = vLoc.getX() - 1;</span>
<span class="fc" id="L992">                        vLoc.setX(editX);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">                    } else if (vLoc.getX() == edge0Idx) {</span>
<span class="fc" id="L994">                        int editX = edge1Idx;</span>
<span class="fc" id="L995">                        vLoc.setX(editX);</span>
                    }
                }
            }

            // the output map keeps 0 to loc1.getx(),
            // but loc0.getX() + 1 gets moved to loc0.getX()
            //    and on until have reached size() - 1
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            for (int j = (removedEdgeIdx + 1); j &lt;= edgesMap.size(); ++j) {</span>
<span class="fc" id="L1004">                PairIntArray v = edgesMap.remove(Integer.valueOf(j));</span>
<span class="pc bpc" id="L1005" title="3 of 4 branches missed.">                assert(v != null);</span>
<span class="fc" id="L1006">                edgesMap.put(Integer.valueOf(j - 1), v);</span>
            }

        }

<span class="fc" id="L1011">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">        for (int i = 0; i &lt; edgesMap.size(); i++) {</span>
<span class="fc" id="L1013">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L1014">            PairIntArray v = edgesMap.get(key);</span>
<span class="pc bpc" id="L1015" title="3 of 4 branches missed.">            assert(v != null);</span>
<span class="fc" id="L1016">            output.add(v);</span>
        }

<span class="fc" id="L1019">        return output;</span>
    }

    /**
     * return whether the point can be swapped with the nearest endpoint.
     * &lt;pre&gt;
     * returns
     *     0: for no need to reorder
     *     1: for it not being an endpoint but can be re-ordered
     *     -1: for cannot be re-ordered
     * &lt;/pre&gt;
     * @param pointEdgeLocation
     * @param edge
     * @return code
       &lt;pre&gt; returns
           0: for no need to reorder
           1: for it not being an endpoint but can be re-ordered
           -1: for cannot be re-ordered,
       &lt;/pre&gt;
     */
    private int canBeReordered(PairInt pointEdgeLocation, PairIntArray edge) {

<span class="fc" id="L1041">        int n = edge.getN();</span>

<span class="fc bfc" id="L1043" title="All 4 branches covered.">        if ((pointEdgeLocation.getY() == 0) || (pointEdgeLocation.getY() == (n - 1))) {</span>
<span class="fc" id="L1044">            return 0;</span>
        }

<span class="pc bpc" id="L1047" title="1 of 4 branches missed.">        if ((pointEdgeLocation.getY() &gt; 2) &amp;&amp; (pointEdgeLocation.getY() &lt; (n - 3))) {</span>
<span class="nc" id="L1048">            return -1;</span>
        }

<span class="fc" id="L1051">        int idxOrig = pointEdgeLocation.getY();</span>

<span class="fc" id="L1053">        int check0Idx = 0;</span>
<span class="fc" id="L1054">        int check1Idx = 2;</span>

<span class="fc bfc" id="L1056" title="All 4 branches covered.">        if ((n &gt; 3) &amp;&amp; (idxOrig == (n - 2))) {</span>
<span class="fc" id="L1057">            check0Idx = n - 3;</span>
<span class="fc" id="L1058">            check1Idx = n - 1;</span>
        }

<span class="fc" id="L1061">        int diffX = edge.getX(check0Idx) - edge.getX(check1Idx);</span>
<span class="fc" id="L1062">        int diffY = edge.getY(check0Idx) - edge.getY(check1Idx);</span>
<span class="fc bfc" id="L1063" title="All 4 branches covered.">        if ((Math.abs(diffX) &gt; 1) || (Math.abs(diffY) &gt; 1)) {</span>
<span class="fc" id="L1064">            return -1;</span>
        }

<span class="fc" id="L1067">        return 1;</span>
    }

    /**
     * If pointEdgeLocation is near the beginning or end of edge,
     * swap it with the point that is the endpoint and update the given
     * data structures with the updated information.
     * @param pointEdgeLocation
     * @param edge
     * @return 1 for did re-order, 0 for no need to re-order, else -1 for cannot
     * re-order
     */
    private int reorderIfNearEnd(PairInt pointEdgeLocation,
        PairIntArray edge,
        PairInt connectingEdgeLocation, PairIntArray connectingEdge) {

<span class="nc" id="L1083">        int n = edge.getN();</span>

<span class="nc bnc" id="L1085" title="All 4 branches missed.">        if ((pointEdgeLocation.getY() == 0) || (pointEdgeLocation.getY() == (n - 1))) {</span>
<span class="nc" id="L1086">            return 0;</span>
        }

        /*
        looks like max offset from end is 2
         @ . [....]

         @ .
         . [....]
        */

<span class="nc bnc" id="L1097" title="All 4 branches missed.">        if ((pointEdgeLocation.getY() &gt; 2) &amp;&amp; (pointEdgeLocation.getY() &lt; (n - 3))) {</span>
<span class="nc" id="L1098">            return 0;</span>
        }

<span class="nc" id="L1101">        int idxOrig = pointEdgeLocation.getY();</span>
        int idxSwap;
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (idxOrig == 1) {</span>
<span class="nc" id="L1104">            idxSwap = 0;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        } else if (idxOrig == (n - 2)) {</span>
<span class="nc" id="L1106">            idxSwap = n - 1;</span>
        } else {
            /*
            can just swap it with first or last point if the swapped point
            is adjacent to the point right before the point to be swapped,
            in other words, does not break a connection in the edge
            */
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if (idxOrig == 2) {</span>
<span class="nc" id="L1114">                idxSwap = 0;</span>
            } else {
<span class="nc" id="L1116">                idxSwap = n - 1;</span>
            }
<span class="nc" id="L1118">            int prevX = edge.getX(idxOrig - 1);</span>
<span class="nc" id="L1119">            int prevY = edge.getY(idxOrig - 1);</span>
<span class="nc" id="L1120">            int endX = edge.getX(0);</span>
<span class="nc" id="L1121">            int endY = edge.getY(0);</span>
<span class="nc bnc" id="L1122" title="All 4 branches missed.">            if ((Math.abs(prevX - endX) &gt; 1) || (Math.abs(prevY - endY) &gt; 1)) {</span>
<span class="nc" id="L1123">                return -1;</span>
            }
        }

        /*
        if swap position is still adjacent to the connecting point,
        can complete the change.
        */
<span class="nc" id="L1131">        int connectedX = connectingEdge.getX(connectingEdgeLocation.getY());</span>
<span class="nc" id="L1132">        int connectedY = connectingEdge.getY(connectingEdgeLocation.getY());</span>

<span class="nc" id="L1134">        int swapX = edge.getX(idxSwap);</span>
<span class="nc" id="L1135">        int swapY = edge.getY(idxSwap);</span>

<span class="nc bnc" id="L1137" title="All 4 branches missed.">        if ((Math.abs(connectedX - swapX) &gt; 1) || (Math.abs(connectedY - swapY) &gt; 1)) {</span>
<span class="nc" id="L1138">            return -1;</span>
        }

<span class="nc" id="L1141">        pointEdgeLocation.setY(idxSwap);</span>

<span class="nc" id="L1143">        return 1;</span>
    }

    private int spliceEdgesAtJunctionsIfImproves(List&lt;PairIntArray&gt; edges) {

        /*
        The main goal is to make better contours.

        Edges with junctions can sometimes be spliced and rejoined with another
        junction edge to make a better edge where better edge may be a longer
        edge or a closed contour useful for determining transformations
        between images containing the contour.

        could be used with shape templates...

        For now, will make a simple algorithm which tries to increase the
        length of the longest edges in a junction.
        */

<span class="fc" id="L1162">        int nSplices = 0;</span>

        // key = edge index.
        // value = pixel indexes.
        //   the pixel indexes are used to find values in junctionLocatorMap
        //   to update it as points are moved to and from edges.
        // key = edge index.
        // value = pixel indexes.
        //   the pixel indexes are used to find values in junctionLocatorMap
        //   to update it as points are moved to and from edges.
<span class="fc" id="L1172">        Map&lt;Integer, Set&lt;Integer&gt;&gt; theEdgeToPixelIndexMap = createEdgeToPixelIndexMap();</span>

<span class="fc bfc" id="L1174" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L1175">            algorithms.misc.MiscDebug.assertConsistentEdgeCapacity(</span>
                theEdgeToPixelIndexMap, junctionLocationMap, junctionMap,
                edges);
        }

        /*
        TODO: consider handling splices of edges of size 1 after this
        block.  They can be inserted in a way that does not affect line
        continuity

        For example:

            0
             1 &lt; where '&lt;' can be inserted after 1 and before 2 or vice versa
             2
             3
        */

<span class="fc bfc" id="L1193" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : junctionMap.entrySet()) {</span>

<span class="fc" id="L1195">            Integer centerPixelIndex = entry.getKey();</span>
<span class="fc" id="L1196">            PairInt centerLoc = junctionLocationMap.get(centerPixelIndex);</span>
<span class="pc bpc" id="L1197" title="3 of 4 branches missed.">            assert(centerLoc != null);</span>

            /*
            if (debug) {

                log.info(&quot;processing junction w/ center pixel index=&quot; + centerPixelIndex
                    + &quot; and loc=&quot; + centerLoc.getX() + &quot;:&quot; + centerLoc.getY());

                String str = algorithms.misc.MiscDebug.printJunctionsToString(
                    junctionLocationMap, junctionMap, edges, img);
                log.info(str);

            }
            */

<span class="fc" id="L1212">            Set&lt;Integer&gt; adjIndexes = entry.getValue();</span>

<span class="fc" id="L1214">            int[] pixIndexes = new int[adjIndexes.size() + 1];</span>

            // lengths holds the edge up until the junction.  splices the edge
            // at the junction figuratively and counts number of pixels before
            // and after splice and keeps the longest.
<span class="fc" id="L1219">            int[] lengths = new int[pixIndexes.length];</span>

<span class="fc" id="L1221">            pixIndexes[0] = centerPixelIndex.intValue();</span>
<span class="fc" id="L1222">            lengths[0] = (new Splice(edges.get(centerLoc.getX())))</span>
<span class="fc" id="L1223">                .getLengthOfLongestSide(centerLoc.getY());</span>

<span class="fc" id="L1225">            int maxN = lengths[0];</span>
<span class="fc" id="L1226">            int maxNPixIdx = pixIndexes[0];</span>
<span class="fc" id="L1227">            boolean foundAnotherEdge = false;</span>

<span class="fc" id="L1229">            int count = 1;</span>

            // for junctions on the same edge, need to count the portions
            // of their edge which are on oppossite sides of the junction,
            // so need to track the maxN, then correct the lengths of splice
            // from same edge afterwards

<span class="fc bfc" id="L1236" title="All 2 branches covered.">            for (Integer pixIndex : adjIndexes) {</span>

<span class="fc" id="L1238">                pixIndexes[count] = pixIndex.intValue();</span>

<span class="fc" id="L1240">                PairInt loc = junctionLocationMap.get(pixIndex);</span>

<span class="fc bfc" id="L1242" title="All 2 branches covered.">                if ((centerLoc.getX() == loc.getX())) {</span>
<span class="fc" id="L1243">                    count++;</span>
<span class="fc" id="L1244">                    continue;</span>
                }

<span class="fc" id="L1247">                foundAnotherEdge = true;</span>

<span class="fc" id="L1249">                Splice splice = new Splice(edges.get(loc.getX()));</span>

<span class="fc" id="L1251">                lengths[count] = splice.getLengthOfLongestSide(loc.getY());</span>

<span class="fc bfc" id="L1253" title="All 2 branches covered.">                if (lengths[count] &gt; maxN) {</span>
<span class="fc" id="L1254">                    maxN = lengths[count];</span>
<span class="fc" id="L1255">                    maxNPixIdx = pixIndex;</span>
                }

<span class="fc" id="L1258">                count++;</span>
<span class="fc" id="L1259">            }</span>

<span class="fc bfc" id="L1261" title="All 2 branches covered.">            if (!foundAnotherEdge) {</span>
<span class="fc" id="L1262">                continue;</span>
            }

            //-- correct the lengths for the junctions from edge maxNEdgeIdx --
<span class="fc" id="L1266">            PairInt maxNLoc = junctionLocationMap.get(maxNPixIdx);</span>
<span class="fc" id="L1267">            Splice maxNSplice = new Splice(edges.get(maxNLoc.getX()));</span>
<span class="fc" id="L1268">            int maxNSpliceOtherSideN = maxNSplice.splice(new int[]{maxNLoc.getY()})[1].getN();</span>
            // correct the splice lengths if they are from the same edge
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            for (int ii = 0; ii &lt; count; ++ii) {</span>
<span class="fc" id="L1271">                int pixIdx = pixIndexes[ii];</span>
<span class="fc" id="L1272">                PairInt loc = junctionLocationMap.get(pixIdx);</span>
<span class="fc bfc" id="L1273" title="All 4 branches covered.">                if ((loc.getX() != maxNLoc.getX()) || (pixIdx == maxNPixIdx)) {</span>
<span class="fc" id="L1274">                    continue;</span>
                }
<span class="fc" id="L1276">                lengths[ii] = maxNSpliceOtherSideN;</span>
            }

<span class="pc bpc" id="L1279" title="1 of 4 branches missed.">            if ((maxN &gt; lengths.length) || (maxN &gt; 10000000)) {</span>
<span class="fc" id="L1280">                MultiArrayMergeSort.sortByDecr(lengths, pixIndexes);</span>
            } else {
<span class="fc" id="L1282">                CountingSort.sortByDecr(lengths, pixIndexes, maxN);</span>
            }

<span class="fc" id="L1285">            int pixIdx0 = pixIndexes[0];</span>

<span class="fc" id="L1287">            int pixIdx1 = pixIndexes[1];</span>

<span class="fc" id="L1289">            PairInt loc0 = junctionLocationMap.get(Integer.valueOf(pixIdx0));</span>
<span class="fc" id="L1290">            final int edge0Idx = loc0.getX();</span>
<span class="fc" id="L1291">            final int indexWithinEdge0 = loc0.getY();</span>

<span class="fc" id="L1293">            PairInt loc1 = junctionLocationMap.get(Integer.valueOf(pixIdx1));</span>
<span class="fc" id="L1294">            final int edge1Idx = loc1.getX();</span>
<span class="fc" id="L1295">            final int indexWithinEdge1 = loc1.getY();</span>

<span class="pc bpc" id="L1297" title="2 of 6 branches missed.">            if (edge0Idx != edge1Idx &amp;&amp; (lengths[0] != 0) &amp;&amp; (lengths[1] != 0)) {</span>

<span class="fc" id="L1299">                Set&lt;Integer&gt; edgePixelIndexes =</span>
<span class="fc" id="L1300">                    theEdgeToPixelIndexMap.get(Integer.valueOf(edge0Idx));</span>
<span class="pc bpc" id="L1301" title="3 of 4 branches missed.">                assert(edgePixelIndexes != null);</span>

<span class="fc" id="L1303">                int[] splice0Y = new int[]{indexWithinEdge0};</span>
<span class="fc" id="L1304">                Splice splice0 = new Splice(edges.get(edge0Idx));</span>

<span class="fc" id="L1306">                Map&lt;Integer, PairInt&gt; smallerSpliceLocations0 = new</span>
                    HashMap&lt;Integer, PairInt&gt;();
<span class="fc" id="L1308">                Map&lt;Integer, PairInt&gt; largerSpliceLocations0 = new</span>
                    HashMap&lt;Integer, PairInt&gt;();
                // splice splice0 into 2 edges and put updated i
<span class="fc" id="L1311">                PairIntArray[] spliced0 = splice0.splice(splice0Y,</span>
                    edgePixelIndexes, junctionLocationMap,
                    smallerSpliceLocations0, largerSpliceLocations0);

<span class="fc" id="L1315">                int[] splice1Y = new int[]{indexWithinEdge1};</span>
<span class="fc" id="L1316">                Splice splice1 = new Splice(edges.get(edge1Idx));</span>

<span class="fc" id="L1318">                edgePixelIndexes =</span>
<span class="fc" id="L1319">                    theEdgeToPixelIndexMap.get(Integer.valueOf(edge1Idx));</span>
<span class="pc bpc" id="L1320" title="3 of 4 branches missed.">                assert(edgePixelIndexes != null);</span>
<span class="fc" id="L1321">                Map&lt;Integer, PairInt&gt; smallerSpliceLocations1 = new</span>
                    HashMap&lt;Integer, PairInt&gt;();
<span class="fc" id="L1323">                Map&lt;Integer, PairInt&gt; largerSpliceLocations1 = new</span>
                    HashMap&lt;Integer, PairInt&gt;();
<span class="fc" id="L1325">                PairIntArray[] spliced1 = splice1.splice(splice1Y,</span>
                    edgePixelIndexes, junctionLocationMap,
                    smallerSpliceLocations1, largerSpliceLocations1);

                // if not spliced, continue.
<span class="pc bpc" id="L1330" title="2 of 4 branches missed.">                if ((spliced0[0].getN() == 0) || (spliced1[0].getN() == 0)) {</span>
<span class="nc" id="L1331">                    continue;</span>
                }

<span class="fc" id="L1334">                int splice01InsertedIdx = edges.size();</span>

                // add the smaller part of spliced0 and spliced1 to edges
<span class="fc" id="L1337">                edges.add(spliced0[1]);</span>

<span class="fc" id="L1339">                int splice11InsertedIdx = edges.size();</span>

<span class="fc" id="L1341">                edges.add(spliced1[1]);</span>

<span class="fc" id="L1343">                int splice00N = spliced0[0].getN();</span>
<span class="fc" id="L1344">                int splice10N = spliced1[0].getN();</span>

                // if splice0Y[0] is first point, reverse the edge before append
<span class="fc bfc" id="L1347" title="All 2 branches covered.">                if (splice0Y[0] == 0) {</span>
<span class="fc" id="L1348">                    spliced0[0].reverse();</span>
<span class="fc" id="L1349">                    splice0Y[0] = splice00N - 1;</span>

                    // --- update largerSpliceLocations0 to reverse index within edge
<span class="fc bfc" id="L1352" title="All 2 branches covered.">                    for (Entry&lt;Integer, PairInt&gt; sEntry : largerSpliceLocations0.entrySet()) {</span>
<span class="fc" id="L1353">                        PairInt sLoc = sEntry.getValue();</span>
<span class="fc" id="L1354">                        int idxRev = splice00N - sLoc.getY() - 1;</span>

<span class="fc" id="L1356">                        sLoc.setY(idxRev);</span>
<span class="pc bpc" id="L1357" title="3 of 4 branches missed.">                        assert(idxRev &lt; splice00N);</span>
<span class="fc" id="L1358">                    }</span>
                }

                // if splice1Y[0] is not the first point, reverse the edge before append
<span class="fc bfc" id="L1362" title="All 2 branches covered.">                if (splice1Y[0] != 0) {</span>
<span class="fc" id="L1363">                    spliced1[0].reverse();</span>
<span class="fc" id="L1364">                    splice1Y[0] = 0;</span>

                    // --- update largerSpliceLocations1 to reverse index within edge
<span class="fc bfc" id="L1367" title="All 2 branches covered.">                    for (Entry&lt;Integer, PairInt&gt; sEntry : largerSpliceLocations1.entrySet()) {</span>
<span class="fc" id="L1368">                        PairInt sLoc = sEntry.getValue();</span>
<span class="fc" id="L1369">                        int idxRev = splice10N - sLoc.getY() - 1;</span>

<span class="fc" id="L1371">                        sLoc.setY(idxRev);</span>
<span class="pc bpc" id="L1372" title="3 of 4 branches missed.">                        assert(idxRev &lt; splice10N);</span>
<span class="fc" id="L1373">                    }</span>
                }

                // append splice1 to splice0
<span class="fc" id="L1377">                spliced0[0].addAll(spliced1[0]);</span>

<span class="fc" id="L1379">                ++nSplices;</span>

<span class="fc" id="L1381">                PairIntArray edge0 = edges.get(edge0Idx);</span>
<span class="fc" id="L1382">                edge0.swapContents(spliced0[0]);</span>
<span class="fc" id="L1383">                spliced0[0] = null;</span>

                // --- update location map for information in
                // --- smallerSpliceLocations0, largerSpliceLocations0 and
                // --- smallerSpliceLocations1, largerSpliceLocations1
<span class="fc bfc" id="L1388" title="All 2 branches covered.">                for (Entry&lt;Integer, PairInt&gt; sEntry : largerSpliceLocations0.entrySet()) {</span>
<span class="fc" id="L1389">                    Integer sPixelIndex = sEntry.getKey();</span>
<span class="fc" id="L1390">                    PairInt sLoc = sEntry.getValue();</span>
<span class="fc" id="L1391">                    PairInt loc = junctionLocationMap.get(sPixelIndex);</span>
<span class="pc bpc" id="L1392" title="3 of 4 branches missed.">                    assert (loc != null);</span>

                    // edge index remains same, but the index within edge may have changed
<span class="fc" id="L1395">                    loc.setY(sLoc.getY());</span>
<span class="pc bpc" id="L1396" title="3 of 4 branches missed.">                    assert(sLoc.getY() &lt; edge0.getN());</span>
<span class="fc" id="L1397">                }</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">                for (Entry&lt;Integer, PairInt&gt; sEntry : smallerSpliceLocations0.entrySet()) {</span>
<span class="fc" id="L1399">                    Integer sPixelIndex = sEntry.getKey();</span>
<span class="fc" id="L1400">                    PairInt sLoc = sEntry.getValue();</span>
<span class="fc" id="L1401">                    PairInt loc = junctionLocationMap.get(sPixelIndex);</span>
<span class="pc bpc" id="L1402" title="3 of 4 branches missed.">                    assert (loc != null);</span>

                    // location is new edge with edited index within edge
<span class="fc" id="L1405">                    loc.setX(splice01InsertedIdx);</span>
<span class="fc" id="L1406">                    loc.setY(sLoc.getY());</span>

                    //-- move item from theEdgeToPixelIndexMap too
                    //-- remove sPixelIndex from edge loc0.getX() and add it to splice01InsertedIdx
<span class="fc" id="L1410">                    Set&lt;Integer&gt; sPixelIndexes = theEdgeToPixelIndexMap.get(Integer.valueOf(edge0Idx));</span>
<span class="fc" id="L1411">                    boolean removed = sPixelIndexes.remove(sPixelIndex);</span>
<span class="pc bpc" id="L1412" title="3 of 4 branches missed.">                    assert(removed == true);</span>

<span class="fc" id="L1414">                    sPixelIndexes = theEdgeToPixelIndexMap.get(Integer.valueOf(splice01InsertedIdx));</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">                    if (sPixelIndexes == null) {</span>
<span class="fc" id="L1416">                        sPixelIndexes = new HashSet&lt;Integer&gt;();</span>
                    }
<span class="fc" id="L1418">                    sPixelIndexes.add(sPixelIndex);</span>
<span class="fc" id="L1419">                    theEdgeToPixelIndexMap.put(Integer.valueOf(splice01InsertedIdx), sPixelIndexes);</span>
<span class="fc" id="L1420">                }</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">                for (Entry&lt;Integer, PairInt&gt; sEntry : smallerSpliceLocations1.entrySet()) {</span>
<span class="fc" id="L1422">                    Integer sPixelIndex = sEntry.getKey();</span>
<span class="fc" id="L1423">                    PairInt sLoc = sEntry.getValue();</span>
<span class="fc" id="L1424">                    PairInt loc = junctionLocationMap.get(sPixelIndex);</span>
<span class="pc bpc" id="L1425" title="3 of 4 branches missed.">                    assert (loc != null);</span>

                    // location is new edge with edited index within edge
<span class="fc" id="L1428">                    loc.setX(splice11InsertedIdx);</span>
<span class="fc" id="L1429">                    loc.setY(sLoc.getY());</span>

                    //-- move item from theEdgeToPixelIndexMap too
                    //-- remove sPixelIndex from edge loc1.getX() and add it to splice11InsertedIdx
<span class="fc" id="L1433">                    Set&lt;Integer&gt; sPixelIndexes =</span>
<span class="fc" id="L1434">                        theEdgeToPixelIndexMap.get(Integer.valueOf(edge1Idx));</span>
<span class="fc" id="L1435">                    boolean removed = sPixelIndexes.remove(sPixelIndex);</span>
<span class="pc bpc" id="L1436" title="3 of 4 branches missed.">                    assert(removed == true);</span>
<span class="fc" id="L1437">                    theEdgeToPixelIndexMap.put(Integer.valueOf(edge1Idx), sPixelIndexes);</span>

<span class="fc" id="L1439">                    sPixelIndexes = theEdgeToPixelIndexMap.get(Integer.valueOf(splice11InsertedIdx));</span>
<span class="fc bfc" id="L1440" title="All 2 branches covered.">                    if (sPixelIndexes == null) {</span>
<span class="fc" id="L1441">                        sPixelIndexes = new HashSet&lt;Integer&gt;();</span>
                    }
<span class="fc" id="L1443">                    sPixelIndexes.add(sPixelIndex);</span>
<span class="fc" id="L1444">                    theEdgeToPixelIndexMap.put(Integer.valueOf(splice11InsertedIdx), sPixelIndexes);</span>
<span class="fc" id="L1445">                }</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">                for (Entry&lt;Integer, PairInt&gt; sEntry : largerSpliceLocations1.entrySet()) {</span>
<span class="fc" id="L1447">                    Integer sPixelIndex = sEntry.getKey();</span>
<span class="fc" id="L1448">                    PairInt sLoc = sEntry.getValue();</span>
<span class="fc" id="L1449">                    PairInt loc = junctionLocationMap.get(sPixelIndex);</span>
<span class="pc bpc" id="L1450" title="3 of 4 branches missed.">                    assert (loc != null);</span>

                    // location after append is loc0.getX() with offset of splice00N
<span class="fc" id="L1453">                    loc.setX(edge0Idx);</span>
<span class="fc" id="L1454">                    loc.setY(sLoc.getY() + splice00N);</span>
<span class="pc bpc" id="L1455" title="3 of 4 branches missed.">                    assert(loc.getY() &lt; edge0.getN());</span>

                    //-- move item from theEdgeToPixelIndexMap too
                    //-- remove sPixelIndex from edge loc1.getX() and add it to loc0.getX()
<span class="fc" id="L1459">                    Integer key = Integer.valueOf(edge1Idx);</span>
<span class="fc" id="L1460">                    Set&lt;Integer&gt; sPixelIndexes = theEdgeToPixelIndexMap.get(key);</span>
<span class="fc" id="L1461">                    boolean removed = sPixelIndexes.remove(sPixelIndex);</span>
<span class="pc bpc" id="L1462" title="3 of 4 branches missed.">                    assert(removed == true);</span>
<span class="fc" id="L1463">                    theEdgeToPixelIndexMap.put(key, sPixelIndexes);</span>

<span class="fc" id="L1465">                    key = Integer.valueOf(edge0Idx);</span>
<span class="fc" id="L1466">                    sPixelIndexes = theEdgeToPixelIndexMap.get(key);</span>
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">                    if (sPixelIndexes == null) {</span>
<span class="nc" id="L1468">                        sPixelIndexes = new HashSet&lt;Integer&gt;();</span>
                    }
<span class="fc" id="L1470">                    sPixelIndexes.add(sPixelIndex);</span>
<span class="fc" id="L1471">                    theEdgeToPixelIndexMap.put(key, sPixelIndexes);</span>
<span class="fc" id="L1472">                }</span>

                // remove edge1Idx from edges as it's now part of edge edge0Idx
<span class="fc" id="L1475">                PairIntArray removedEdge = edges.remove(edge1Idx);</span>
<span class="pc bpc" id="L1476" title="3 of 4 branches missed.">                assert(removedEdge != null);</span>

<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">                if (debug) {</span>
                    // assert that theEdgeToPixelIndexMap does not have any
                    // entries for the edge that was just removed.
                    // all entries in theEdgeToPixelIndexMap and the junction
                    // maps should have been updated above for edge1Idx
<span class="nc" id="L1483">                    Set&lt;Integer&gt; pixelIndexes = theEdgeToPixelIndexMap.get(edge1Idx);</span>
<span class="nc bnc" id="L1484" title="All 6 branches missed.">                    assert(pixelIndexes == null || pixelIndexes.isEmpty());</span>
                }

                // ---- update all entries in junctionLocationMap and pixelIndexes for the removal
                // ---- there shouldn't be any entries in for loc1.getX() at this point though
                /*
                0                0
                ...             ...
                49               49
                50 &lt;-- rm        prev 51, now 50.
                51
                */
<span class="fc bfc" id="L1496" title="All 2 branches covered.">                for (int eIdx = (edge1Idx + 1); eIdx &lt;= edges.size(); ++eIdx) {</span>

<span class="fc" id="L1498">                    Integer edgeIndex = Integer.valueOf(eIdx);</span>

<span class="fc" id="L1500">                    Set&lt;Integer&gt; pixelIndexes = theEdgeToPixelIndexMap.get(edgeIndex);</span>

<span class="fc bfc" id="L1502" title="All 2 branches covered.">                    if (pixelIndexes != null) {</span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">                        for (Integer pixelIndex : pixelIndexes) {</span>
<span class="fc" id="L1504">                            PairInt loc = junctionLocationMap.get(pixelIndex);</span>
<span class="fc" id="L1505">                            loc.setX(loc.getX() - 1);</span>
<span class="fc" id="L1506">                        }</span>

<span class="fc" id="L1508">                        theEdgeToPixelIndexMap.remove(edgeIndex);</span>

<span class="fc" id="L1510">                        Integer edgeIndexEarlier = Integer.valueOf(eIdx - 1);</span>

<span class="fc" id="L1512">                        theEdgeToPixelIndexMap.put(edgeIndexEarlier, pixelIndexes);</span>
                    }
                }

<span class="pc bpc" id="L1516" title="1 of 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L1517">                    algorithms.misc.MiscDebug.assertConsistentEdgeCapacity(</span>
                        theEdgeToPixelIndexMap, junctionLocationMap,
                        junctionMap, edges);
                }
            }
<span class="fc" id="L1522">        }</span>

<span class="fc" id="L1524">        return nSplices;</span>
    }

    protected void reduceMultipleEndpointsForEdge(
        List&lt;PairIntArray&gt; edges,
        Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; edgeFirstEndPointMap,
        Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; edgeLastEndPointMap,
        Map&lt;PairInt, PairInt&gt; endPointMap, Set&lt;PointPairInt&gt; theJoinPoints) {

<span class="fc" id="L1533">        Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; tmpFirstRemoveMap = new HashMap&lt;Integer, Set&lt;PointPairInt&gt;&gt;();</span>

<span class="fc" id="L1535">        Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; tmpLastRemoveMap = new HashMap&lt;Integer, Set&lt;PointPairInt&gt;&gt;();</span>

<span class="fc bfc" id="L1537" title="All 2 branches covered.">        for (int type = 0; type &lt; 2; ++type) {</span>

<span class="fc" id="L1539">            Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; edgeMap = edgeFirstEndPointMap;</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">            if (type == 1) {</span>
<span class="fc" id="L1541">                edgeMap = edgeLastEndPointMap;</span>
            }

<span class="fc bfc" id="L1544" title="All 2 branches covered.">            for (Entry&lt;Integer, Set&lt;PointPairInt&gt;&gt; entry : edgeMap.entrySet()) {</span>

<span class="fc" id="L1546">                Set&lt;PointPairInt&gt; joinPointSet = entry.getValue();</span>

<span class="fc bfc" id="L1548" title="All 2 branches covered.">                if (joinPointSet.size() &lt; 2) {</span>
<span class="fc" id="L1549">                    continue;</span>
                }

                // has more than one joint point for this endpoint, though some
                // might have already been removed and are in tmpFirstRemoveMap
                // if so

<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">                if (log.isLoggable(Level.FINE)) {</span>
                    // construct a warning
<span class="nc" id="L1558">                    StringBuilder sb = new StringBuilder(&quot;edge &quot;);</span>
<span class="nc" id="L1559">                    sb.append(entry.getKey().toString())</span>
<span class="nc" id="L1560">                        .append(&quot; has &quot;).append(Integer.toString(joinPointSet.size()))</span>
<span class="nc" id="L1561">                        .append(&quot; first endpoints, so deciding between them:&quot;);</span>

<span class="nc bnc" id="L1563" title="All 2 branches missed.">                    for (PointPairInt joinPoint : entry.getValue()) {</span>
<span class="nc" id="L1564">                        PairInt loc0 = joinPoint.getKey();</span>
<span class="nc" id="L1565">                        PairInt loc1 = joinPoint.getValue();</span>
<span class="nc" id="L1566">                        PairIntArray edge0 = edges.get(loc0.getX());</span>
<span class="nc" id="L1567">                        PairIntArray edge1 = edges.get(loc1.getX());</span>
<span class="nc" id="L1568">                        int x0 = edge0.getX(loc0.getY());</span>
<span class="nc" id="L1569">                        int y0 = edge0.getY(loc0.getY());</span>
<span class="nc" id="L1570">                        int x1 = edge1.getX(loc1.getY());</span>
<span class="nc" id="L1571">                        int y1 = edge1.getY(loc1.getY());</span>
<span class="nc" id="L1572">                        sb.append(&quot;\n&quot;)</span>
<span class="nc" id="L1573">                            .append(&quot; &quot;).append(Integer.toString(loc0.getX())).append(&quot;:&quot;)</span>
<span class="nc" id="L1574">                            .append(Integer.toString(loc0.getY()))</span>
<span class="nc" id="L1575">                            .append(&quot; (&quot;).append(Integer.toString(x0)).append(&quot;,&quot;)</span>
<span class="nc" id="L1576">                            .append(Integer.toString(y0)).append(&quot;)&lt;--&gt;&quot;)</span>
<span class="nc" id="L1577">                            .append(&quot; &quot;).append(Integer.toString(loc1.getX())).append(&quot;:&quot;)</span>
<span class="nc" id="L1578">                            .append(Integer.toString(loc1.getY()))</span>
<span class="nc" id="L1579">                            .append(&quot; (&quot;).append(Integer.toString(x1)).append(&quot;,&quot;)</span>
<span class="nc" id="L1580">                            .append(Integer.toString(y1)).append(&quot;)&quot;);</span>
<span class="nc" id="L1581">                    }</span>
<span class="nc" id="L1582">                    log.warning(sb.toString());</span>
                }

                // choose closest join point pair, and break ties with those that
                // have higher number of members that are already endpoints.

<span class="fc" id="L1588">                PointPairInt closestJoinPoint = null;</span>
<span class="fc" id="L1589">                int closestDistSq = Integer.MAX_VALUE;</span>
<span class="fc" id="L1590">                int closestCanBeReordered0 = -99;</span>
<span class="fc" id="L1591">                int closestCanBeReordered1 = -99;</span>

<span class="fc bfc" id="L1593" title="All 2 branches covered.">                for (PointPairInt joinPoint : joinPointSet) {</span>

<span class="fc" id="L1595">                    PairInt loc0 = joinPoint.getKey();</span>
<span class="fc" id="L1596">                    PairIntArray edge0 = edges.get(loc0.getX());</span>
<span class="fc" id="L1597">                    int n0 = edge0.getN();</span>

<span class="fc" id="L1599">                    Set&lt;PointPairInt&gt; removedFirstSet =</span>
<span class="fc" id="L1600">                        tmpFirstRemoveMap.get(Integer.valueOf(loc0.getX()));</span>
<span class="fc bfc" id="L1601" title="All 2 branches covered.">                    if (removedFirstSet == null) {</span>
<span class="fc" id="L1602">                        removedFirstSet = new HashSet&lt;PointPairInt&gt;();</span>
<span class="fc" id="L1603">                        tmpFirstRemoveMap.put(Integer.valueOf(loc0.getX()), removedFirstSet);</span>
                    }

<span class="fc" id="L1606">                    Set&lt;PointPairInt&gt; removedLastSet =</span>
<span class="fc" id="L1607">                        tmpLastRemoveMap.get(Integer.valueOf(loc0.getX()));</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">                    if (removedLastSet == null) {</span>
<span class="fc" id="L1609">                        removedLastSet = new HashSet&lt;PointPairInt&gt;();</span>
<span class="fc" id="L1610">                        tmpLastRemoveMap.put(Integer.valueOf(loc0.getX()), removedLastSet);</span>
                    }

<span class="pc bpc" id="L1613" title="1 of 6 branches missed.">                    if ((n0 != 3) &amp;&amp; (loc0.getY() &lt; 2) &amp;&amp; removedFirstSet.contains(joinPoint)) {</span>
<span class="nc" id="L1614">                        continue;</span>
                    }
<span class="fc bfc" id="L1616" title="All 6 branches covered.">                    if ((n0 != 3) &amp;&amp; (loc0.getY() &gt; (n0 - 3)) &amp;&amp; removedLastSet.contains(joinPoint)) {</span>
<span class="fc" id="L1617">                        continue;</span>
                    }

<span class="fc" id="L1620">                    PairInt loc1 = joinPoint.getValue();</span>
<span class="fc" id="L1621">                    PairIntArray edge1 = edges.get(loc1.getX());</span>

<span class="pc bpc" id="L1623" title="3 of 4 branches missed.">                    assert(edge0 != null);</span>
<span class="pc bpc" id="L1624" title="3 of 4 branches missed.">                    assert(edge1 != null);</span>

<span class="fc" id="L1626">                    int diffX = edge0.getX(loc0.getY()) - edge1.getX(loc1.getY());</span>
<span class="fc" id="L1627">                    int diffY = edge0.getY(loc0.getY()) - edge1.getY(loc1.getY());</span>
<span class="fc" id="L1628">                    int distSq = (diffX * diffX) + (diffY * diffY);</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">                    if (distSq &lt; closestDistSq) {</span>
<span class="fc" id="L1630">                        closestDistSq = distSq;</span>
<span class="fc" id="L1631">                        closestJoinPoint = joinPoint;</span>
<span class="fc" id="L1632">                        closestCanBeReordered0 = canBeReordered(loc0, edge0);</span>
<span class="fc" id="L1633">                        closestCanBeReordered1 = canBeReordered(loc1, edge1);</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">                    } else if (distSq == closestDistSq) {</span>
<span class="fc" id="L1635">                        int cr0 = canBeReordered(loc0, edge0);</span>
<span class="fc" id="L1636">                        int cr1 = canBeReordered(loc1, edge1);;</span>
<span class="fc bfc" id="L1637" title="All 4 branches covered.">                        if (closestCanBeReordered0 == 0 &amp;&amp; closestCanBeReordered1 == 0) {</span>
<span class="fc" id="L1638">                            continue;</span>
                        }
<span class="pc bpc" id="L1640" title="10 of 12 branches missed.">                        if (((cr0 == 0) &amp;&amp; (cr1 == 0)) ||</span>
                            (closestCanBeReordered0 != 0 &amp;&amp; closestCanBeReordered1 != 0
                                &amp;&amp; ((cr0 == 0) || cr1 == 0))
                            ) {
<span class="fc" id="L1644">                            closestDistSq = distSq;</span>
<span class="fc" id="L1645">                            closestJoinPoint = joinPoint;</span>
<span class="fc" id="L1646">                            closestCanBeReordered0 = cr0;</span>
<span class="fc" id="L1647">                            closestCanBeReordered1 = cr1;</span>
                        }
                    }
<span class="fc" id="L1650">                }</span>

                //TODO: revisit this
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">                if (closestJoinPoint == null) {</span>
<span class="nc" id="L1654">                    continue;</span>
                }
                //assert (closestJoinPoint != null);

<span class="fc bfc" id="L1658" title="All 2 branches covered.">                for (PointPairInt joinPoint : joinPointSet) {</span>

<span class="fc bfc" id="L1660" title="All 2 branches covered.">                    if (joinPoint.equals(closestJoinPoint)) {</span>
<span class="fc" id="L1661">                        continue;</span>
                    }

<span class="fc" id="L1664">                    PairInt loc0 = joinPoint.getKey();</span>
<span class="fc" id="L1665">                    PairIntArray edge0 = edges.get(loc0.getX());</span>
<span class="fc" id="L1666">                    int n0 = edge0.getN();</span>

<span class="fc" id="L1668">                    Set&lt;PointPairInt&gt; removedFirstSet0 =</span>
<span class="fc" id="L1669">                        tmpFirstRemoveMap.get(Integer.valueOf(loc0.getX()));</span>

<span class="fc" id="L1671">                    Set&lt;PointPairInt&gt; removedLastSet0 =</span>
<span class="fc" id="L1672">                        tmpLastRemoveMap.get(Integer.valueOf(loc0.getX()));</span>

<span class="pc bpc" id="L1674" title="1 of 6 branches missed.">                    if ((n0 != 3) &amp;&amp; (loc0.getY() &lt; 2) &amp;&amp; removedFirstSet0.contains(joinPoint)) {</span>
<span class="nc" id="L1675">                        continue;</span>
                    }
<span class="fc bfc" id="L1677" title="All 6 branches covered.">                    if ((n0 != 3) &amp;&amp; (loc0.getY() &gt; (n0 - 3)) &amp;&amp; removedLastSet0.contains(joinPoint)) {</span>
<span class="fc" id="L1678">                        continue;</span>
                    }

<span class="fc" id="L1681">                    PairInt loc1 = joinPoint.getValue();</span>
<span class="fc" id="L1682">                    PairIntArray edge1 = edges.get(loc1.getX());</span>
<span class="fc" id="L1683">                    int n1 = edge1.getN();</span>

<span class="pc bpc" id="L1685" title="3 of 4 branches missed.">                    assert(edge0 != null);</span>
<span class="pc bpc" id="L1686" title="3 of 4 branches missed.">                    assert(edge1 != null);</span>

<span class="fc bfc" id="L1688" title="All 4 branches covered.">                    if ((n0 == 3) &amp;&amp; (loc0.getY() == 1)) {</span>
<span class="fc" id="L1689">                        log.fine(String.format(</span>
                            &quot;removing point (%d,%d) but it is in the middle of an edge of size 3&quot;,
<span class="fc" id="L1691">                            edge0.getX(1), edge0.getY(1)));</span>
                    }

<span class="fc" id="L1694">                    Set&lt;PointPairInt&gt; removedFirstSet1 =</span>
<span class="fc" id="L1695">                        tmpFirstRemoveMap.get(Integer.valueOf(loc1.getX()));</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">                    if (removedFirstSet1 == null) {</span>
<span class="fc" id="L1697">                        removedFirstSet1 = new HashSet&lt;PointPairInt&gt;();</span>
<span class="fc" id="L1698">                        tmpFirstRemoveMap.put(Integer.valueOf(loc1.getX()), removedFirstSet1);</span>
                    }

<span class="fc" id="L1701">                    Set&lt;PointPairInt&gt; removedLastSet1 =</span>
<span class="fc" id="L1702">                        tmpLastRemoveMap.get(Integer.valueOf(loc1.getX()));</span>
<span class="fc bfc" id="L1703" title="All 2 branches covered.">                    if (removedLastSet1 == null) {</span>
<span class="fc" id="L1704">                        removedLastSet1 = new HashSet&lt;PointPairInt&gt;();</span>
<span class="fc" id="L1705">                        tmpLastRemoveMap.put(Integer.valueOf(loc1.getX()), removedLastSet1);</span>
                    }

<span class="fc" id="L1708">                    boolean isFirstEndPoint0 = false;</span>
<span class="fc bfc" id="L1709" title="All 2 branches covered.">                    if (loc0.getY() == 0) {</span>
<span class="fc" id="L1710">                        isFirstEndPoint0 = true;</span>
<span class="fc bfc" id="L1711" title="All 4 branches covered.">                    } else if ((loc0.getY() != (n0 - 1)) &amp;&amp; (loc0.getY() &lt; 2)) {</span>
<span class="fc" id="L1712">                        isFirstEndPoint0 = true;</span>
                    }
<span class="fc" id="L1714">                    boolean isFirstEndPoint1 = false;</span>
<span class="fc bfc" id="L1715" title="All 2 branches covered.">                    if (loc1.getY() == 0) {</span>
<span class="fc" id="L1716">                        isFirstEndPoint1 = true;</span>
<span class="pc bpc" id="L1717" title="1 of 4 branches missed.">                    } else if ((loc1.getY() != (n1 - 1)) &amp;&amp; (loc1.getY() &lt; 2)) {</span>
<span class="nc" id="L1718">                        isFirstEndPoint1 = true;</span>
                    }

<span class="pc bpc" id="L1721" title="1 of 4 branches missed.">                    if (isFirstEndPoint0 &amp;&amp; removedFirstSet0.contains(joinPoint)) {</span>
<span class="nc" id="L1722">                        continue;</span>
<span class="pc bpc" id="L1723" title="1 of 4 branches missed.">                    } else if (!isFirstEndPoint0 &amp;&amp; removedLastSet0.contains(joinPoint)) {</span>
<span class="nc" id="L1724">                        continue;</span>
                    }

<span class="fc bfc" id="L1727" title="All 2 branches covered.">                    if (isFirstEndPoint0) {</span>
<span class="fc" id="L1728">                        removedFirstSet0.add(joinPoint);</span>
                    } else {
<span class="fc" id="L1730">                        removedLastSet0.add(joinPoint);</span>
                    }
<span class="fc bfc" id="L1732" title="All 2 branches covered.">                    if (isFirstEndPoint1) {</span>
<span class="fc" id="L1733">                        removedFirstSet1.add(joinPoint);</span>
                    } else {
<span class="fc" id="L1735">                        removedLastSet1.add(joinPoint);</span>
                    }

<span class="fc" id="L1738">                    boolean removed = theJoinPoints.remove(joinPoint);</span>
<span class="pc bpc" id="L1739" title="3 of 4 branches missed.">                    assert(removed);</span>

<span class="fc" id="L1741">                    tmpFirstRemoveMap.put(Integer.valueOf(loc0.getX()), removedFirstSet0);</span>
<span class="fc" id="L1742">                    tmpLastRemoveMap.put(Integer.valueOf(loc0.getX()), removedLastSet0);</span>

<span class="fc" id="L1744">                    tmpFirstRemoveMap.put(Integer.valueOf(loc1.getX()), removedFirstSet1);</span>
<span class="fc" id="L1745">                    tmpLastRemoveMap.put(Integer.valueOf(loc1.getX()), removedLastSet1);</span>
<span class="fc" id="L1746">                }</span>
<span class="fc" id="L1747">            }</span>

            // --- update the edge maps for the changes ---

<span class="fc" id="L1751">            Map&lt;Integer, Set&lt;PointPairInt&gt;&gt; tmpMap = new HashMap&lt;Integer, Set&lt;PointPairInt&gt;&gt;();</span>

<span class="fc bfc" id="L1753" title="All 2 branches covered.">            for (Entry&lt;Integer, Set&lt;PointPairInt&gt;&gt; entry : edgeFirstEndPointMap.entrySet()) {</span>

<span class="fc" id="L1755">                Set&lt;PointPairInt&gt; rmJoinPointSet = tmpFirstRemoveMap.get(entry.getKey());</span>

<span class="fc bfc" id="L1757" title="All 4 branches covered.">                if (rmJoinPointSet == null || rmJoinPointSet.isEmpty()) {</span>
<span class="fc" id="L1758">                    tmpMap.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L1759">                    continue;</span>
                }

<span class="fc" id="L1762">                Set&lt;PointPairInt&gt; tmpJoinPointSet = new HashSet&lt;PointPairInt&gt;();</span>
<span class="fc bfc" id="L1763" title="All 2 branches covered.">                for (PointPairInt joinPoint : entry.getValue()) {</span>
<span class="fc bfc" id="L1764" title="All 2 branches covered.">                    if (!rmJoinPointSet.contains(joinPoint)) {</span>
<span class="fc" id="L1765">                        tmpJoinPointSet.add(joinPoint);</span>
                    }
<span class="fc" id="L1767">                }</span>
<span class="fc" id="L1768">                tmpMap.put(entry.getKey(), tmpJoinPointSet);</span>
<span class="fc" id="L1769">            }</span>
<span class="fc" id="L1770">            edgeFirstEndPointMap.clear();</span>
<span class="fc" id="L1771">            edgeFirstEndPointMap.putAll(tmpMap);</span>

<span class="fc" id="L1773">            tmpMap = new HashMap&lt;Integer, Set&lt;PointPairInt&gt;&gt;();</span>

<span class="fc bfc" id="L1775" title="All 2 branches covered.">            for (Entry&lt;Integer, Set&lt;PointPairInt&gt;&gt; entry : edgeLastEndPointMap.entrySet()) {</span>

<span class="fc" id="L1777">                Set&lt;PointPairInt&gt; rmJoinPointSet = tmpLastRemoveMap.get(entry.getKey());</span>

<span class="fc bfc" id="L1779" title="All 4 branches covered.">                if (rmJoinPointSet == null || rmJoinPointSet.isEmpty()) {</span>
<span class="fc" id="L1780">                    tmpMap.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L1781">                    continue;</span>
                }

<span class="fc" id="L1784">                Set&lt;PointPairInt&gt; tmpJoinPointSet = new HashSet&lt;PointPairInt&gt;();</span>
<span class="fc bfc" id="L1785" title="All 2 branches covered.">                for (PointPairInt joinPoint : entry.getValue()) {</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">                    if (!rmJoinPointSet.contains(joinPoint)) {</span>
<span class="fc" id="L1787">                        tmpJoinPointSet.add(joinPoint);</span>
                    }
<span class="fc" id="L1789">                }</span>
<span class="fc" id="L1790">                tmpMap.put(entry.getKey(), tmpJoinPointSet);</span>
<span class="fc" id="L1791">            }</span>
<span class="fc" id="L1792">            edgeLastEndPointMap.clear();</span>
<span class="fc" id="L1793">            edgeLastEndPointMap.putAll(tmpMap);</span>
        }

<span class="fc" id="L1796">    }</span>

    public PairIntArray findAsSingleClosedEdge() {

<span class="fc" id="L1800">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L1802">        this.singleClosedEdge = true;</span>

<span class="fc" id="L1804">        List&lt;PairIntArray&gt; output = connectPixelsViaDFSForBounds();</span>

<span class="fc bfc" id="L1806" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L1807">Image img0 = ImageIOHelper.convertImage(img);</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">for (int i = 0; i &lt; output.size(); ++i) {</span>
<span class="fc" id="L1809">    PairIntArray pa = output.get(i);</span>
<span class="fc bfc" id="L1810" title="All 2 branches covered.">    for (int j = 0; j &lt; pa.getN(); ++j) {</span>
<span class="fc" id="L1811">        int x = pa.getX(j);</span>
<span class="fc" id="L1812">        int y = pa.getY(j);</span>
<span class="fc bfc" id="L1813" title="All 2 branches covered.">        if (i == 0) {</span>
<span class="fc bfc" id="L1814" title="All 4 branches covered.">            if (j == 0 || (j == (pa.getN() - 1))) {</span>
<span class="fc" id="L1815">                ImageIOHelper.addPointToImage(x, y, img0, 0, 200, 100, 0);</span>
            } else {
<span class="fc" id="L1817">                ImageIOHelper.addPointToImage(x, y, img0, 0, 255, 0, 0);</span>
            }
<span class="pc bpc" id="L1819" title="1 of 2 branches missed.">        } else if (i == 1) {</span>
<span class="fc" id="L1820">            ImageIOHelper.addPointToImage(x, y, img0, 0, 0, 255, 0);</span>
        } else {
<span class="nc" id="L1822">            ImageIOHelper.addPointToImage(x, y, img0, 0, 0, 0, 255);</span>
        }
    }
}
<span class="fc" id="L1826">MiscDebug.writeImageCopy(img0, &quot;output_before_merges_&quot; + MiscDebug.getCurrentTimeFormatted() + &quot;.png&quot;);</span>
}
<span class="fc" id="L1828">        output = findEdgesIntermediateSteps(output);</span>

<span class="fc bfc" id="L1830" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L1831">Image img2 = ImageIOHelper.convertImage(img);</span>
<span class="fc bfc" id="L1832" title="All 2 branches covered.">for (int i = 0; i &lt; output.size(); ++i) {</span>
<span class="fc" id="L1833">    PairIntArray pa = output.get(i);</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">    for (int j = 0; j &lt; pa.getN(); ++j) {</span>
<span class="fc" id="L1835">        int x = pa.getX(j);</span>
<span class="fc" id="L1836">        int y = pa.getY(j);</span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        if (i == 0) {</span>
<span class="fc bfc" id="L1838" title="All 4 branches covered.">            if (j == 0 || (j == (pa.getN() - 1))) {</span>
<span class="fc" id="L1839">                ImageIOHelper.addPointToImage(x, y, img2, 0, 200, 100, 0);</span>
            } else {
<span class="fc" id="L1841">                ImageIOHelper.addPointToImage(x, y, img2, 0, 255, 0, 0);</span>
            }
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        } else if (i == 1) {</span>
<span class="nc" id="L1844">            ImageIOHelper.addPointToImage(x, y, img2, 0, 0, 255, 0);</span>
        } else {
<span class="nc" id="L1846">            ImageIOHelper.addPointToImage(x, y, img2, 0, 0, 0, 255);</span>
        }
    }
}
<span class="fc" id="L1850">MiscDebug.writeImageCopy(img2, &quot;output_after_merges_&quot; + MiscDebug.getCurrentTimeFormatted() + &quot;.png&quot;);</span>
}

<span class="pc bpc" id="L1853" title="1 of 2 branches missed.">        if (output.isEmpty()) {</span>
<span class="nc" id="L1854">            return null;</span>
        }
        
<span class="fc bfc" id="L1857" title="All 2 branches covered.">        if (output.size() &gt; 1) {</span>
<span class="fc" id="L1858">            Collections.sort(output, new PairIntArrayDescendingComparator());</span>
        }

<span class="fc" id="L1861">        PairIntArray out = output.get(0);</span>

<span class="fc" id="L1863">        reorderEndpointsIfNeeded(out);</span>
        
<span class="fc" id="L1865">        boolean isAdjacent = curveHelper.isAdjacent(out, 0, out.getN() - 1);</span>
        
<span class="fc bfc" id="L1867" title="All 2 branches covered.">        if (isAdjacent) {</span>
<span class="fc" id="L1868">            PairIntArrayWithColor p = new PairIntArrayWithColor(out);</span>
<span class="fc" id="L1869">            p.setColor(1);</span>
<span class="fc" id="L1870">            out = p;</span>
        }

<span class="fc bfc" id="L1873" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L1874">Image img2 = ImageIOHelper.convertImage(img);</span>
<span class="fc bfc" id="L1875" title="All 2 branches covered.">for (int j = 0; j &lt; out.getN(); ++j) {</span>
<span class="fc" id="L1876">    int x = out.getX(j);</span>
<span class="fc" id="L1877">    int y = out.getY(j);</span>
<span class="fc bfc" id="L1878" title="All 4 branches covered.">    if (j == 0 || (j == (out.getN() - 1))) {</span>
<span class="fc" id="L1879">        ImageIOHelper.addPointToImage(x, y, img2, 0, 200, 100, 0);</span>
    } else {
<span class="fc" id="L1881">        ImageIOHelper.addPointToImage(x, y, img2, 0, 255, 0, 0);</span>
    }
}
<span class="fc" id="L1884">MiscDebug.writeImageCopy(img2, &quot;output_after_reorder_endpoints_&quot; + MiscDebug.getCurrentTimeFormatted() + &quot;.png&quot;);</span>
}

<span class="fc" id="L1887">        return out;</span>
    }

    private Map&lt;Integer, Set&lt;Integer&gt;&gt; createEdgeToPixelIndexMap() {

        // key = edge index.
        // value = pixel indexes.
        //    the pixel indexes are used to find values in junctionLocatorMap
        //    to update it as points are moved to and from edges.
<span class="fc" id="L1896">        Map&lt;Integer, Set&lt;Integer&gt;&gt; theEdgeToPixelIndexMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L1898" title="All 2 branches covered.">        for (Entry&lt;Integer, PairInt&gt; entry : junctionLocationMap.entrySet()) {</span>
<span class="fc" id="L1899">            Integer pixelIndex = entry.getKey();</span>
<span class="fc" id="L1900">            PairInt loc = entry.getValue();</span>
<span class="fc" id="L1901">            Integer edgeIndex = Integer.valueOf(loc.getX());</span>
<span class="fc" id="L1902">            Set&lt;Integer&gt; pixelIndexes = theEdgeToPixelIndexMap.get(edgeIndex);</span>
<span class="fc bfc" id="L1903" title="All 2 branches covered.">            if (pixelIndexes == null) {</span>
<span class="fc" id="L1904">                pixelIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1905">                theEdgeToPixelIndexMap.put(edgeIndex, pixelIndexes);</span>
            }
<span class="fc" id="L1907">            pixelIndexes.add(pixelIndex);</span>
<span class="fc" id="L1908">        }</span>

<span class="fc" id="L1910">        return theEdgeToPixelIndexMap;</span>
    }

    private int insertAdjacentForClosedCurve(List&lt;PairIntArray&gt; edges) {

<span class="pc bpc" id="L1915" title="2 of 4 branches missed.">        if (edges == null || edges.isEmpty()) {</span>
<span class="nc" id="L1916">            return 0;</span>
        }

<span class="fc" id="L1919">        Collections.sort(edges, new PairIntArrayDescendingComparator());</span>

<span class="fc" id="L1921">        int maxEdgeIdx = 0;</span>

<span class="fc" id="L1923">        findJunctions(edges);</span>

        // key = edge index.
        // value = pixel indexes.
        //     the pixel indexes are used to find values in junctionLocatorMap
        //     to update it as points are moved to and from edges.
<span class="fc" id="L1929">        Map&lt;Integer, Set&lt;Integer&gt;&gt; theEdgeToPixelIndexMap = createEdgeToPixelIndexMap();</span>

<span class="fc" id="L1931">        int nChanged = 0;</span>

<span class="fc bfc" id="L1933" title="All 2 branches covered.">        for (int i = (edges.size() - 1); i &gt; -1; --i) {</span>

<span class="pc bpc" id="L1935" title="1 of 4 branches missed.">            if (i == maxEdgeIdx || (edges.get(i).getN() == 0)) {</span>
<span class="nc" id="L1936">                continue;</span>
            }

            // i may be merged into maxEdgeIdx
<span class="fc" id="L1940">            int nInserted = insert(theEdgeToPixelIndexMap, edges, maxEdgeIdx, i);</span>

<span class="fc bfc" id="L1942" title="All 2 branches covered.">            if (nInserted &gt; 0) {</span>

<span class="fc" id="L1944">                findJunctions(edges);</span>

<span class="fc" id="L1946">                theEdgeToPixelIndexMap = createEdgeToPixelIndexMap();</span>
            }

<span class="fc" id="L1949">            nChanged += nInserted;</span>
        }

<span class="fc" id="L1952">        int nMerged = 0;</span>
<span class="fc" id="L1953">        int nIter = 0;</span>
<span class="fc" id="L1954">        int nMaxIter = 10;</span>
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">        if (edges.size() &gt; nMaxIter) {</span>
<span class="nc" id="L1956">            nMaxIter = edges.size();</span>
        }

<span class="pc bpc" id="L1959" title="2 of 6 branches missed.">        while ((nIter == 0) || ((nIter &lt; nMaxIter) &amp;&amp; (nMerged &gt; 0))) {</span>

<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">            if (nMerged &gt; 0) {</span>
<span class="nc" id="L1962">                findJunctions(edges);</span>
<span class="nc" id="L1963">                theEdgeToPixelIndexMap = createEdgeToPixelIndexMap();</span>
            }

<span class="fc" id="L1966">            nMerged = 0;</span>

<span class="fc bfc" id="L1968" title="All 2 branches covered.">            for (int i = 0; i &lt; edges.size(); ++i) {</span>

                //TODO: consider skipping single pixel edges because they're
                // handled in insertAdjacentForClosedCurve?
<span class="pc bpc" id="L1972" title="1 of 2 branches missed.">                if (edges.get(i).getN() == 0) {</span>
<span class="nc" id="L1973">                    continue;</span>
                }

<span class="fc" id="L1976">                PairIntArray curve = edges.get(i);</span>

<span class="fc" id="L1978">                int x1 = curve.getX(0);</span>
<span class="fc" id="L1979">                int y1 = curve.getY(0);</span>
<span class="fc" id="L1980">                int xn = curve.getX(curve.getN() - 1);</span>
<span class="fc" id="L1981">                int yn = curve.getY(curve.getN() - 1);</span>

                // uses the junctionLocationMap to search for neighbors of given point
<span class="fc" id="L1984">                Set&lt;PairInt&gt; adjToFirstLoc = findAdjacentInOtherEdge(x1, y1, i);</span>

<span class="fc" id="L1986">                Set&lt;PairInt&gt; adjToLastLoc = findAdjacentInOtherEdge(xn, yn, i);</span>

                /*
                See if there's an unambiguous closest among the 2 sets,
                and choose that if there is
                */

<span class="fc" id="L1993">                double minDist = Double.MAX_VALUE;</span>
<span class="fc" id="L1994">                PairInt closest = null;</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">                for (PairInt loc : adjToFirstLoc) {</span>
<span class="fc" id="L1996">                    int x = edges.get(loc.getX()).getX(loc.getY());</span>
<span class="fc" id="L1997">                    int y = edges.get(loc.getX()).getY(loc.getY());</span>
<span class="fc" id="L1998">                    int diffX = x1 - x;</span>
<span class="fc" id="L1999">                    int diffY = y1 - y;</span>
<span class="fc" id="L2000">                    double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">                    if (dist == minDist) {</span>
                        // discard because of ambiguity
<span class="fc" id="L2003">                        closest = null;</span>
<span class="fc" id="L2004">                        break;</span>
<span class="fc bfc" id="L2005" title="All 2 branches covered.">                    } else if (dist &lt; minDist) {</span>
<span class="fc" id="L2006">                        minDist = dist;</span>
<span class="fc" id="L2007">                        closest = loc;</span>
                    }
<span class="fc" id="L2009">                }</span>

<span class="fc bfc" id="L2011" title="All 2 branches covered.">                if (closest != null) {</span>
                    //edge i is the one being inserted into by edge 2
<span class="fc" id="L2013">                    int ins = insert(theEdgeToPixelIndexMap, edges, i, closest.getX());</span>

                    /*
                    TODO: consider this instead:
                    int nInserted = insertForEdge1FirstLocation(edges, i, closest.getX(), set);
                    */
<span class="fc bfc" id="L2019" title="All 2 branches covered.">                    if (ins &gt; 0) {</span>
<span class="fc" id="L2020">                        return ins;</span>
                    }
<span class="fc" id="L2022">                } else {</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">                    for (PairInt loc : adjToFirstLoc) {</span>
<span class="fc" id="L2024">                        int edge2Idx = loc.getX();</span>
<span class="fc" id="L2025">                        int ins = insert(theEdgeToPixelIndexMap, edges, i, edge2Idx);</span>
<span class="fc bfc" id="L2026" title="All 2 branches covered.">                        if (ins &gt; 0) {</span>
<span class="fc" id="L2027">                            return ins;</span>
                        }
<span class="fc" id="L2029">                    }</span>
                }

<span class="fc" id="L2032">                closest = null;</span>
<span class="fc" id="L2033">                minDist = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L2034" title="All 2 branches covered.">                for (PairInt loc : adjToLastLoc) {</span>
<span class="fc" id="L2035">                    int x = edges.get(loc.getX()).getX(loc.getY());</span>
<span class="fc" id="L2036">                    int y = edges.get(loc.getX()).getY(loc.getY());</span>
<span class="fc" id="L2037">                    int diffX = xn - x;</span>
<span class="fc" id="L2038">                    int diffY = yn - y;</span>
<span class="fc" id="L2039">                    double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">                    if (dist == minDist) {</span>
                        // discard because of ambiguity
<span class="fc" id="L2042">                        closest = null;</span>
<span class="fc" id="L2043">                        break;</span>
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">                    } else if (dist &lt; minDist) {</span>
<span class="fc" id="L2045">                        minDist = dist;</span>
<span class="fc" id="L2046">                        closest = loc;</span>
                    }
<span class="fc" id="L2048">                }</span>

<span class="fc bfc" id="L2050" title="All 2 branches covered.">                if (closest != null) {</span>
                    //edge i is the one being inserted into by edge 2
<span class="fc" id="L2052">                    int ins = insert(theEdgeToPixelIndexMap, edges, i, closest.getX());</span>
                    /*
                    TODO: consider instead
                    int nInserted = insertForEdge1LastLocation(edges, i, closest.getX(), set);
                    */
<span class="fc bfc" id="L2057" title="All 2 branches covered.">                    if (ins &gt; 0) {</span>
<span class="fc" id="L2058">                        return ins;</span>
                    }
<span class="fc" id="L2060">                } else {</span>
<span class="fc bfc" id="L2061" title="All 2 branches covered.">                    for (PairInt loc : adjToLastLoc) {</span>
<span class="fc" id="L2062">                        int edge2Idx = loc.getX();</span>
<span class="fc" id="L2063">                        int ins = insert(theEdgeToPixelIndexMap, edges, i, edge2Idx);</span>
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">                        if (ins &gt; 0) {</span>
<span class="nc" id="L2065">                            return ins;</span>
                        }
<span class="fc" id="L2067">                    }</span>
                }
            }

<span class="fc" id="L2071">            ++nIter;</span>
        }

<span class="fc" id="L2074">        return nChanged;</span>
    }

    private int insertBetweenAdjacentForClosedCurve(List&lt;PairIntArray&gt; output) {

        //NOT YET IMPLEMENTED

<span class="nc bnc" id="L2081" title="All 4 branches missed.">        if (output == null || output.isEmpty()) {</span>
<span class="nc" id="L2082">            return 0;</span>
        }

<span class="nc" id="L2085">        int nChanged = 0;</span>

        /*
        unlike insertAdjacentForClosedCurve, this method does not attempt to
        join all curves exclusively to the largest curve.
        instead it attempts to join a curve to the adjacent curves at its
        endpoints.

        previous join points and junction splice operations should have joined
        most curves, but there may be the case where two curves
        have an open curve in between them and neither of the two would ever gain
        length by adding it, so all 3 remain separate.

        Here's a case:
          1 1 1
                1
                  1
          1 1 1 1   3 3
                  2     3 3
                    2 3     3
                        3  3

        For each curve, looks at it's endpoints and searches the junction
        location map to find adjacent edge points (junctions).

        It finds the closest for both endpoints.

        Then it looks to see if those 2 edges have a junction.
        (If there is only one edge it is adjacent to, that's handled in the
        other method, insertAdjacentForClosedCurve).

        If those 2 edges are adjacent, and if that adjacency is adjacent
        to one of the endpoints of the open curve in between,
        the 3 are joined.

        */

<span class="nc bnc" id="L2122" title="All 2 branches missed.">        for (int i = 0; i &lt; output.size(); ++i) {</span>

            //TODO: consider skipping single pixel edges because they're handled in insertAdjacentForClosedCurve?
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            if (output.get(i).getN() == 0) {</span>
<span class="nc" id="L2126">                continue;</span>
            }

<span class="nc" id="L2129">            PairIntArray curve = output.get(i);</span>

<span class="nc" id="L2131">            int x1 = curve.getX(0);</span>
<span class="nc" id="L2132">            int y1 = curve.getY(0);</span>
<span class="nc" id="L2133">            int xn = curve.getX(curve.getN() - 1);</span>
<span class="nc" id="L2134">            int yn = curve.getY(curve.getN() - 1);</span>
            /*
            PairInt[] adjLoc = findTwoAdjacent(i, x1, y1, xn, yn);

            if (firstLastAdjLoc == null) {
                continue;
            }

            // skipping for insert into same edge because it's handled in another method
            if (firstLastAdjLoc[0].getX() == firstLastAdjLoc[1].getX()) {
                continue;
            }

            check that adjToFirstPointLoc is adjacent to adjToLastPointLoc
            */
            /*
            Here's a case:
              1 1 1
                    1
                      1
              1 1 1 1   3 3
                      2     3 3
                        2 3     3
                            3  3
            */

        }

<span class="nc" id="L2162">        return nChanged;</span>
    }

    /**
     * populate the output lists with adjacent pixel locations for
     * the edge next to the reference edge (where reference edge is usually the
     * one with largest number of points).
     *
     * @param theEdgeToPixelIndexMap
     * @param edge1Idx
     * @param edge2Idx
     * @param outputAdjacentToEdge1LocMap key is a location in edge1, value is
     * a set of locations in edge2 adjacent to the key
     */
    private void populateWithAdjacentLocations(
        Map&lt;Integer, Set&lt;Integer&gt;&gt; theEdgeToPixelIndexMap,
        final int edge1Idx, final int edge2Idx,
        Map&lt;PairInt, Set&lt;PairInt&gt;&gt; outputAdjacentToEdge1LocMap) {

<span class="fc" id="L2181">        Set&lt;Integer&gt; edge1PixIndexes = theEdgeToPixelIndexMap.get(Integer.valueOf(edge1Idx));</span>

<span class="pc bpc" id="L2183" title="1 of 4 branches missed.">        if (edge1PixIndexes == null || edge1PixIndexes.isEmpty()) {</span>
<span class="fc" id="L2184">            return;</span>
        }
        
<span class="fc bfc" id="L2187" title="All 2 branches covered.">        for (Integer edge1PixIndex : edge1PixIndexes) {</span>

<span class="fc" id="L2189">            PairInt edge1Loc = junctionLocationMap.get(edge1PixIndex);</span>

            // search the 8 neighbors to see if any are in maxEdgePixelIndexes
<span class="fc" id="L2192">            int x = img.getCol(edge1PixIndex);</span>
<span class="fc" id="L2193">            int y = img.getRow(edge1PixIndex);</span>

<span class="fc bfc" id="L2195" title="All 2 branches covered.">            for (int i = 0; i &lt; dxs8.length; ++i) {</span>

<span class="fc" id="L2197">                int x2 = x + dxs8[i];</span>
<span class="fc" id="L2198">                int y2 = y + dys8[i];</span>
<span class="pc bpc" id="L2199" title="4 of 8 branches missed.">                if (x2 &lt; 0 || (y2 &lt; 0) || (x2 &gt; (img.getWidth() - 1) || (y2 &gt; (img.getHeight() - 1)))) {</span>
<span class="nc" id="L2200">                    continue;</span>
                }

<span class="fc" id="L2203">                int pixIdx2 = img.getIndex(x2, y2);</span>

                // if this is in edge2, add it to the set
<span class="fc" id="L2206">                PairInt adjacentToEdge1Loc = junctionLocationMap.get(pixIdx2);</span>

<span class="fc bfc" id="L2208" title="All 4 branches covered.">                if ((adjacentToEdge1Loc != null) &amp;&amp; (adjacentToEdge1Loc.getX() == edge2Idx)) {</span>

                    // edge1JunctionLoc is next to edge1Loc
<span class="fc" id="L2211">                    Set&lt;PairInt&gt; edge2LocSet = outputAdjacentToEdge1LocMap.get(edge1Loc);</span>
<span class="fc bfc" id="L2212" title="All 2 branches covered.">                    if (edge2LocSet == null) {</span>
<span class="fc" id="L2213">                        edge2LocSet = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2214">                        outputAdjacentToEdge1LocMap.put(edge1Loc, edge2LocSet);</span>
                    }
<span class="fc" id="L2216">                    edge2LocSet.add(adjacentToEdge1Loc);</span>
                }
            }
<span class="fc" id="L2219">        }</span>
<span class="fc" id="L2220">    }</span>

    void reorderEndpointsIfNeeded(PairIntArray out) {

<span class="pc bpc" id="L2224" title="1 of 4 branches missed.">        if (out == null || out.getN() &lt; 3) {</span>
<span class="fc" id="L2225">            return;</span>
        }

<span class="fc" id="L2228">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc bfc" id="L2230" title="All 2 branches covered.">        if (curveHelper.isAdjacent(out, 0, out.getN() - 1)) {</span>
<span class="fc" id="L2231">            return;</span>
        }

<span class="fc" id="L2234">        int x1 = out.getX(0);</span>
<span class="fc" id="L2235">        int y1 = out.getY(0);</span>

<span class="fc" id="L2237">        int xn = out.getX(out.getN() - 1);</span>
<span class="fc" id="L2238">        int yn = out.getY(out.getN() - 1);</span>

<span class="fc" id="L2240">        int closestPivotIdx = -1;</span>

<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">        for (int idx = (out.getN() - 2); idx &gt; 0; --idx) {</span>

<span class="fc" id="L2244">            int x = out.getX(idx);</span>
<span class="fc" id="L2245">            int y = out.getY(idx);</span>

<span class="fc bfc" id="L2247" title="All 4 branches covered.">            if ((Math.abs(x - x1) &lt; 2) &amp;&amp; (Math.abs(y - y1) &lt; 2)) {</span>
<span class="fc" id="L2248">                closestPivotIdx = idx;</span>
<span class="fc" id="L2249">                break;</span>
            }
        }

<span class="pc bpc" id="L2253" title="1 of 2 branches missed.">        if (closestPivotIdx == -1) {</span>
            // it's not a closed curve
<span class="nc" id="L2255">            return;</span>
        }

<span class="fc bfc" id="L2258" title="All 2 branches covered.">        if (closestPivotIdx &gt; (out.getN() - closestPivotIdx - 1)) {</span>
            // closest to end
            /*
            If point before closestPivotIdx is next to (x1, y1), can just
            reverse the points from closestPivotIdx to n-1.
            */
<span class="fc" id="L2264">            int xPrev = out.getX(closestPivotIdx - 1);</span>
<span class="fc" id="L2265">            int yPrev = out.getY(closestPivotIdx - 1);</span>
<span class="pc bpc" id="L2266" title="1 of 4 branches missed.">            if ((Math.abs(xPrev - xn) &gt; 1) || (Math.abs(yPrev - yn) &gt; 1)) {</span>
<span class="fc" id="L2267">                return;</span>
            }

<span class="fc" id="L2270">            int count = 0;</span>
<span class="fc" id="L2271">            int nSep = (out.getN() - closestPivotIdx) &gt;&gt; 1;</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            for (int idx = closestPivotIdx; idx &lt; (closestPivotIdx + nSep); ++idx) {</span>
<span class="fc" id="L2273">                int idx2 = out.getN() - count - 1;</span>
<span class="fc" id="L2274">                int swapX = out.getX(idx);</span>
<span class="fc" id="L2275">                int swapY = out.getY(idx);</span>
<span class="fc" id="L2276">                out.set(idx, out.getX(idx2), out.getY(idx2));</span>
<span class="fc" id="L2277">                out.set(idx2, swapX, swapY);</span>
<span class="fc" id="L2278">                count++;</span>
            }

<span class="fc" id="L2281">        } else {</span>
            // closest to beginning
            /*
            If point after closestPivotIdx is next to (xn, yn), can reverse the
            points from 0 to closestPivotIdx.
            */

<span class="fc" id="L2288">            closestPivotIdx = -1;</span>

<span class="pc bpc" id="L2290" title="1 of 2 branches missed.">            for (int idx = 1; idx &lt; (out.getN() - 1); ++idx) {</span>

<span class="fc" id="L2292">                int x = out.getX(idx);</span>
<span class="fc" id="L2293">                int y = out.getY(idx);</span>

<span class="fc bfc" id="L2295" title="All 4 branches covered.">                if ((Math.abs(x - xn) &lt; 2) &amp;&amp; (Math.abs(y - yn) &lt; 2)) {</span>
<span class="fc" id="L2296">                    closestPivotIdx = idx;</span>
<span class="fc" id="L2297">                    break;</span>
                }
            }

<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">            if (closestPivotIdx == -1) {</span>
                // it's not a closed curve
<span class="nc" id="L2303">                return;</span>
            }
            
            // if x[0],y[0] is adj to x[closestPivotIdx+1],y[closestPivotIdx+1]

<span class="fc" id="L2308">            int xNext = out.getX(closestPivotIdx + 1);</span>
<span class="fc" id="L2309">            int yNext = out.getY(closestPivotIdx + 1);</span>
<span class="pc bpc" id="L2310" title="1 of 4 branches missed.">            if ((Math.abs(xNext - x1) &gt; 1) || (Math.abs(yNext - y1) &gt; 1)) {</span>
<span class="fc" id="L2311">                return;</span>
            }

<span class="nc" id="L2314">            out.reverse0toIdx(closestPivotIdx);</span>
        }
<span class="fc" id="L2316">    }</span>

    private int insert(Map&lt;Integer, Set&lt;Integer&gt;&gt; theEdgeToPixelIndexMap,
        List&lt;PairIntArray&gt; output, int edge1Idx, int edge2Idx) {

<span class="fc" id="L2321">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
        /*
        edge 1 is the one being inserted into by edge 2
        */

<span class="fc" id="L2327">        PairIntArray edge1 = output.get(edge1Idx);</span>

<span class="fc" id="L2329">        PairIntArray edge2 = output.get(edge2Idx);</span>

        /*
        key is a location in edge1,
        value is a set of locations in edge2 adjacent to the key
        */
<span class="fc" id="L2335">        Map&lt;PairInt, Set&lt;PairInt&gt;&gt; adjToEdge1LocMap = new HashMap&lt;PairInt, Set&lt;PairInt&gt;&gt;();</span>
<span class="fc" id="L2336">        populateWithAdjacentLocations(theEdgeToPixelIndexMap, edge1Idx, edge2Idx,</span>
            adjToEdge1LocMap);

<span class="fc bfc" id="L2339" title="All 2 branches covered.">        if (adjToEdge1LocMap.isEmpty()) {</span>
<span class="fc" id="L2340">            return 0;</span>
        }

        // if can insert at index = 0 or last index for edge1, prefer that
<span class="fc" id="L2344">        Set&lt;PairInt&gt; edge2LocForEdge1FirstLoc = null;</span>
<span class="fc" id="L2345">        Set&lt;PairInt&gt; edge2LocForEdge1LastLoc = null;</span>

<span class="fc bfc" id="L2347" title="All 2 branches covered.">        for (Entry&lt;PairInt, Set&lt;PairInt&gt;&gt; entry : adjToEdge1LocMap.entrySet()) {</span>
<span class="fc" id="L2348">            PairInt edge1Loc = entry.getKey();</span>
<span class="fc bfc" id="L2349" title="All 2 branches covered.">            if (edge1Loc.getY() == 0) {</span>
<span class="fc" id="L2350">                edge2LocForEdge1FirstLoc = entry.getValue();</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">            } else if (edge1Loc.getY() == (edge1.getN() - 1)) {</span>
<span class="fc" id="L2352">                edge2LocForEdge1LastLoc = entry.getValue();</span>
            }
<span class="fc" id="L2354">        }</span>

<span class="pc bpc" id="L2356" title="1 of 4 branches missed.">        if ((edge2LocForEdge1FirstLoc != null) &amp;&amp; !edge2LocForEdge1FirstLoc.isEmpty()) {</span>

<span class="fc" id="L2358">            int nIns = insertForEdge1FirstLocation(output, edge1Idx, edge2Idx,</span>
                edge2LocForEdge1FirstLoc);

<span class="fc bfc" id="L2361" title="All 2 branches covered.">            if (nIns &gt; 0) {</span>
<span class="fc" id="L2362">                return nIns;</span>
            }
        }

<span class="pc bpc" id="L2366" title="1 of 4 branches missed.">        if ((edge2LocForEdge1LastLoc != null) &amp;&amp; !edge2LocForEdge1LastLoc.isEmpty()) {</span>

<span class="fc" id="L2368">            int nIns = insertForEdge1LastLocation(output, edge1Idx, edge2Idx,</span>
                edge2LocForEdge1LastLoc);

<span class="fc bfc" id="L2371" title="All 2 branches covered.">            if (nIns &gt; 0) {</span>
<span class="fc" id="L2372">                return nIns;</span>
            }
        }

        /*
        if have arrived here, the locations in edge1 are not at its endpoints.

        can insert another curve if both insertion points in edge1 are next to
        one another.

        edge1 is '@''s
                               @ @ @ @
                             @
                           @
                    0 1 2 @
                    5 4 3 @
                            @ @
        */

<span class="fc bfc" id="L2391" title="All 2 branches covered.">        if (adjToEdge1LocMap.size() &lt; 2) {</span>
            // there aren't 2 points to
<span class="fc" id="L2393">            return 0;</span>
        }

        /*
        key is a location in edge1,
        value is a set of locations in edge2 adjacent to the key
        Map&lt;PairInt, Set&lt;PairInt&gt;&gt; adjToEdge1LocMap
        */

        // ---- looking for 2 keys in adjToEdge1LocMap that are adjacent to
        //      one another

<span class="fc" id="L2405">        List&lt;PairInt&gt; edge1ALocKeys = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L2406">        List&lt;PairInt&gt; edge1BLocKeys = new ArrayList&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2408" title="All 2 branches covered.">        for (Entry&lt;PairInt, Set&lt;PairInt&gt;&gt; entryA : adjToEdge1LocMap.entrySet()) {</span>

<span class="fc" id="L2410">            PairInt edge1ALoc = entryA.getKey();</span>

<span class="pc bpc" id="L2412" title="3 of 4 branches missed.">            assert(edge1ALoc.getX() == edge1Idx);</span>

<span class="fc" id="L2414">            int xA = edge1.getX(edge1ALoc.getY());</span>
<span class="fc" id="L2415">            int yA = edge1.getY(edge1ALoc.getY());</span>

<span class="fc bfc" id="L2417" title="All 2 branches covered.">            for (Entry&lt;PairInt, Set&lt;PairInt&gt;&gt; entryB : adjToEdge1LocMap.entrySet()) {</span>

<span class="fc" id="L2419">                PairInt edge1BLoc = entryB.getKey();</span>

<span class="pc bpc" id="L2421" title="3 of 4 branches missed.">                assert(edge1BLoc.getX() == edge1Idx);</span>

<span class="fc bfc" id="L2423" title="All 2 branches covered.">                if (edge1ALoc.equals(edge1BLoc)) {</span>
<span class="fc" id="L2424">                    continue;</span>
                }

<span class="fc" id="L2427">                int xB = edge1.getX(edge1BLoc.getY());</span>
<span class="fc" id="L2428">                int yB = edge1.getY(edge1BLoc.getY());</span>

<span class="fc" id="L2430">                int diffX = Math.abs(xA - xB);</span>
<span class="fc bfc" id="L2431" title="All 2 branches covered.">                if (diffX &gt; 1) {</span>
<span class="fc" id="L2432">                    continue;</span>
                }
<span class="fc" id="L2434">                int diffY = Math.abs(yA - yB);</span>
<span class="fc bfc" id="L2435" title="All 2 branches covered.">                if (diffY &gt; 1) {</span>
<span class="fc" id="L2436">                    continue;</span>
                }

<span class="fc" id="L2439">                int idxA = edge1ALocKeys.indexOf(edge1BLoc);</span>
<span class="fc bfc" id="L2440" title="All 2 branches covered.">                if (idxA &gt; -1) {</span>
<span class="fc bfc" id="L2441" title="All 2 branches covered.">                    if (edge1BLocKeys.get(idxA).equals(edge1ALoc)) {</span>
<span class="fc" id="L2442">                        continue;</span>
                    }
                }

<span class="fc" id="L2446">                edge1ALocKeys.add(edge1ALoc);</span>
<span class="fc" id="L2447">                edge1BLocKeys.add(edge1BLoc);</span>
<span class="fc" id="L2448">            }</span>
<span class="fc" id="L2449">        }</span>

<span class="fc bfc" id="L2451" title="All 2 branches covered.">        if (edge1ALocKeys.isEmpty()) {</span>
<span class="fc" id="L2452">            return 0;</span>
        }

        /*
        if edge2 are endpoints can simply insert
        else have to see if can re-order edge 2 points so
        that the closest points are both placable at endpoints
        */

<span class="fc" id="L2461">        List&lt;PairInt&gt; edge1ALocClosestEdge2Loc = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L2462">        List&lt;PairInt&gt; edge1BLocClosestEdge2Loc = new ArrayList&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2464" title="All 2 branches covered.">        for (int i = 0; i &lt; edge1ALocKeys.size(); ++i) {</span>
<span class="fc" id="L2465">            PairInt edge1ALoc = edge1ALocKeys.get(i);</span>
<span class="fc" id="L2466">            int x1 = edge1.getX(edge1ALoc.getY());</span>
<span class="fc" id="L2467">            int y1 = edge1.getY(edge1ALoc.getY());</span>

<span class="fc" id="L2469">            Set&lt;PairInt&gt; edge2LocSet = adjToEdge1LocMap.get(edge1ALoc);</span>
<span class="fc" id="L2470">            double minDist = Double.MAX_VALUE;</span>
<span class="fc" id="L2471">            PairInt closest = null;</span>
<span class="fc bfc" id="L2472" title="All 2 branches covered.">            for (PairInt edge2Loc : edge2LocSet) {</span>
<span class="fc" id="L2473">                int x2 = edge2.getX(edge2Loc.getY());</span>
<span class="fc" id="L2474">                int y2 = edge2.getY(edge2Loc.getY());</span>
<span class="fc" id="L2475">                int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L2476">                int diffY = Math.abs(y1 - y2);</span>
<span class="fc" id="L2477">                double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>
<span class="fc bfc" id="L2478" title="All 2 branches covered.">                if (dist &lt; minDist) {</span>
<span class="fc" id="L2479">                    minDist = dist;</span>
<span class="fc" id="L2480">                    closest = edge2Loc;</span>
                }
<span class="fc" id="L2482">            }</span>
<span class="fc" id="L2483">            edge1ALocClosestEdge2Loc.add(closest);</span>
        }

<span class="fc bfc" id="L2486" title="All 2 branches covered.">        for (int i = 0; i &lt; edge1BLocKeys.size(); ++i) {</span>
<span class="fc" id="L2487">            PairInt edge1BLoc = edge1BLocKeys.get(i);</span>
<span class="fc" id="L2488">            int x1 = edge1.getX(edge1BLoc.getY());</span>
<span class="fc" id="L2489">            int y1 = edge1.getY(edge1BLoc.getY());</span>

<span class="fc" id="L2491">            Set&lt;PairInt&gt; edge2LocSet = adjToEdge1LocMap.get(edge1BLoc);</span>
<span class="fc" id="L2492">            double minDist = Double.MAX_VALUE;</span>
<span class="fc" id="L2493">            PairInt closest = null;</span>
<span class="fc bfc" id="L2494" title="All 2 branches covered.">            for (PairInt edge2Loc : edge2LocSet) {</span>
<span class="fc" id="L2495">                int x2 = edge2.getX(edge2Loc.getY());</span>
<span class="fc" id="L2496">                int y2 = edge2.getY(edge2Loc.getY());</span>
<span class="fc" id="L2497">                int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L2498">                int diffY = Math.abs(y1 - y2);</span>
<span class="fc" id="L2499">                double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>
<span class="fc bfc" id="L2500" title="All 2 branches covered.">                if (dist &lt; minDist) {</span>
<span class="fc" id="L2501">                    minDist = dist;</span>
<span class="fc" id="L2502">                    closest = edge2Loc;</span>
                }
<span class="fc" id="L2504">            }</span>
<span class="fc" id="L2505">            edge1BLocClosestEdge2Loc.add(closest);</span>
        }

<span class="fc bfc" id="L2508" title="All 2 branches covered.">        for (int i = 0; i &lt; edge1ALocKeys.size(); ++i) {</span>

<span class="fc" id="L2510">            PairInt edge1ALoc = edge1ALocKeys.get(i);</span>
<span class="fc" id="L2511">            PairInt edge1BLoc = edge1BLocKeys.get(i);</span>

<span class="fc" id="L2513">            PairInt edge2ALoc = edge1ALocClosestEdge2Loc.get(i);</span>
<span class="fc" id="L2514">            PairInt edge2BLoc = edge1BLocClosestEdge2Loc.get(i);</span>

<span class="fc bfc" id="L2516" title="All 4 branches covered.">            if ((edge2ALoc.getY() == 0) &amp;&amp; (edge2BLoc.getY() == (edge2.getN() - 1))) {</span>

<span class="pc bpc" id="L2518" title="1 of 2 branches missed.">                if (edge1ALoc.getY() &lt; edge1BLoc.getY()) {</span>
<span class="fc" id="L2519">                    edge1.insertAll(edge1ALoc.getY() + 1, edge2);</span>
<span class="fc" id="L2520">                    output.remove(edge2Idx);</span>
<span class="fc" id="L2521">                    return 1;</span>
                } else {
<span class="nc" id="L2523">                    edge2.reverse();</span>
<span class="nc" id="L2524">                    edge1.insertAll(edge1BLoc.getY() + 1, edge2);</span>
<span class="nc" id="L2525">                    output.remove(edge2Idx);</span>
<span class="nc" id="L2526">                    return 1;</span>
                }

<span class="fc bfc" id="L2529" title="All 4 branches covered.">            } else if ((edge2BLoc.getY() == 0) &amp;&amp; (edge2ALoc.getY() == (edge2.getN() - 1))) {</span>
<span class="pc bpc" id="L2530" title="1 of 2 branches missed.">                if (edge1ALoc.getY() &lt; edge1BLoc.getY()) {</span>
<span class="fc" id="L2531">                    edge2.reverse();</span>
<span class="fc" id="L2532">                    edge1.insertAll(edge1ALoc.getY() + 1, edge2);</span>
<span class="fc" id="L2533">                    output.remove(edge2Idx);</span>
<span class="fc" id="L2534">                    return 1;</span>
                } else {
<span class="nc" id="L2536">                    edge1.insertAll(edge1BLoc.getY() + 1, edge2);</span>
<span class="nc" id="L2537">                    output.remove(edge2Idx);</span>
<span class="nc" id="L2538">                    return 1;</span>
                }

            } else {

                // --- if here, then edge1 and edge2 closest points weren't
                //     endpoints so we try to reorder points to make the
                //     curves joinable sequentially

<span class="fc" id="L2547">                boolean edge1IsClosed = curveHelper.isAdjacent(edge1, 0, edge1.getN() - 1);</span>

<span class="fc" id="L2549">                boolean edge2IsClosed = curveHelper.isAdjacent(edge2, 0, edge2.getN() - 1);</span>

<span class="fc" id="L2551">                int nReversed = 0;</span>

<span class="fc bfc" id="L2553" title="All 4 branches covered.">                if (output.size() == 2 &amp;&amp; !edge1IsClosed) {</span>

                    // attempt to reorder and then set edge1IsClosed to true

<span class="fc" id="L2557">                    int edge1EndIdx = findAdjacentToTopAtBottom(edge1);</span>

<span class="fc" id="L2559">                    boolean didReverse = false;</span>

<span class="pc bpc" id="L2561" title="1 of 2 branches missed.">                    if (edge1EndIdx &gt; -1) {</span>
   // TODO: invoke even if edge1EndIdx &lt;&lt; (edge1.getN()/2) ?
<span class="fc" id="L2563">                        didReverse = reverseBottomIfPossible(edge1, edge1EndIdx);</span>
<span class="pc bpc" id="L2564" title="1 of 2 branches missed.">                        if (didReverse) {</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">                            if (edge1ALoc.getY() &gt; edge1EndIdx) {</span>
<span class="nc" id="L2566">                                edge1ALoc.setY(edge1.getN() - edge1ALoc.getY() + edge1EndIdx - 1);</span>
                            }
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                            if (edge1BLoc.getY() &gt; edge1EndIdx) {</span>
<span class="nc" id="L2569">                                edge1BLoc.setY(edge1.getN() - edge1BLoc.getY() + edge1EndIdx - 1);</span>
                            }
<span class="nc" id="L2571">                            edge1IsClosed = curveHelper.isAdjacent(edge1, 0, edge1.getN() - 1);</span>
<span class="nc" id="L2572">                            nReversed++;</span>

                        } else {

<span class="fc bfc" id="L2576" title="All 2 branches covered.">                            if (edge1EndIdx &lt; (edge1.getN()/2)) {</span>

<span class="pc bpc" id="L2578" title="1 of 2 branches missed.">                                if (reverseTopIfPossible(edge1, edge1EndIdx - 1)) {</span>
<span class="pc bpc" id="L2579" title="1 of 2 branches missed.">                                    if (edge1ALoc.getY() &lt; (edge1EndIdx - 1)) {</span>
<span class="nc" id="L2580">                                        edge1ALoc.setY(edge1EndIdx - 1 - edge1ALoc.getY());</span>
                                    }
<span class="pc bpc" id="L2582" title="1 of 2 branches missed.">                                    if (edge1BLoc.getY() &lt; (edge1EndIdx - 1)) {</span>
<span class="nc" id="L2583">                                        edge1BLoc.setY(edge1EndIdx - 1 - edge1BLoc.getY());</span>
                                    }
<span class="fc" id="L2585">                                    nReversed++;</span>
<span class="fc" id="L2586">                                    edge1IsClosed = curveHelper.isAdjacent(edge1, 0, edge1.getN() - 1);</span>
                                }
                            }
                        }
                    }

<span class="pc bpc" id="L2592" title="1 of 2 branches missed.">                    if (!didReverse) {</span>

<span class="fc" id="L2594">                        int edge1BeginIdx = findAdjacentToBottomAtTop(edge1);</span>

<span class="fc bfc" id="L2596" title="All 2 branches covered.">                        if (edge1BeginIdx &gt; -1) {</span>
<span class="fc" id="L2597">                            didReverse = reverseTopIfPossible(edge1, edge1BeginIdx);</span>
<span class="pc bpc" id="L2598" title="1 of 2 branches missed.">                            if (didReverse) {</span>
<span class="nc bnc" id="L2599" title="All 2 branches missed.">                                if (edge1ALoc.getY() &lt; edge1BeginIdx) {</span>
<span class="nc" id="L2600">                                    edge1ALoc.setY(edge1BeginIdx - edge1ALoc.getY());</span>
                                }
<span class="nc bnc" id="L2602" title="All 2 branches missed.">                                if (edge1BLoc.getY() &lt; edge1BeginIdx) {</span>
<span class="nc" id="L2603">                                    edge1BLoc.setY(edge1BeginIdx - edge1BLoc.getY());</span>
                                }
<span class="nc" id="L2605">                                edge1IsClosed = curveHelper.isAdjacent(edge1, 0, edge1.getN() - 1);</span>
<span class="nc" id="L2606">                                nReversed++;</span>
                            } else {

<span class="fc bfc" id="L2609" title="All 2 branches covered.">                                if (edge1BeginIdx &gt; (edge1.getN()/2)) {</span>
<span class="pc bpc" id="L2610" title="1 of 2 branches missed.">                                    if (reverseBottomIfPossible(edge1, edge1BeginIdx + 1)) {</span>
<span class="pc bpc" id="L2611" title="1 of 2 branches missed.">                                        if (edge1ALoc.getY() &gt; (edge1BeginIdx + 1)) {</span>
<span class="nc" id="L2612">                                            edge1ALoc.setY(edge1.getN() - edge1ALoc.getY() + edge1BeginIdx);</span>
                                        }
<span class="pc bpc" id="L2614" title="1 of 2 branches missed.">                                        if (edge1BLoc.getY() &gt; (edge1BeginIdx + 1)) {</span>
<span class="nc" id="L2615">                                            edge1BLoc.setY(edge1.getN() - edge1BLoc.getY() + edge1BeginIdx);</span>
                                        }
<span class="fc" id="L2617">                                        nReversed++;</span>
<span class="fc" id="L2618">                                        edge1IsClosed = curveHelper.isAdjacent(edge1, 0, edge1.getN() - 1);</span>
                                    }
                                }
                            }
                        }
                    }
                }

<span class="fc bfc" id="L2626" title="All 6 branches covered.">                if (output.size() == 2 &amp;&amp; edge1IsClosed &amp;&amp; !edge2IsClosed) {</span>

                    // attempt to reorder and then set edge2IsClosed to true

<span class="fc" id="L2630">                    int edge2EndIdx = findAdjacentToTopAtBottom(edge2);</span>

<span class="fc" id="L2632">                    boolean didReverse = false;</span>

<span class="pc bpc" id="L2634" title="1 of 2 branches missed.">                    if (edge2EndIdx &gt; -1) {</span>

<span class="fc" id="L2636">                        didReverse = reverseBottomIfPossible(edge2, edge2EndIdx);</span>
<span class="pc bpc" id="L2637" title="1 of 2 branches missed.">                        if (didReverse) {</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">                            if (edge2ALoc.getY() &gt; edge2EndIdx) {</span>
<span class="nc" id="L2639">                                edge2ALoc.setY(edge2.getN() - edge2ALoc.getY() + edge2EndIdx - 1);</span>
                            }
<span class="nc bnc" id="L2641" title="All 2 branches missed.">                            if (edge2BLoc.getY() &gt; edge2EndIdx) {</span>
<span class="nc" id="L2642">                                edge2BLoc.setY(edge2.getN() - edge2BLoc.getY() + edge2EndIdx - 1);</span>
                            }
<span class="nc" id="L2644">                            edge2IsClosed = curveHelper.isAdjacent(edge2, 0, edge2.getN() - 1);</span>
<span class="nc" id="L2645">                            nReversed++;</span>
                        } else {

<span class="pc bpc" id="L2648" title="1 of 2 branches missed.">                            if (edge2EndIdx &lt; (edge2.getN()/2)) {</span>

<span class="pc bpc" id="L2650" title="1 of 2 branches missed.">                                if (reverseTopIfPossible(edge2, edge2EndIdx - 1)) {</span>
<span class="pc bpc" id="L2651" title="1 of 2 branches missed.">                                    if (edge2ALoc.getY() &lt; (edge2EndIdx - 1)) {</span>
<span class="nc" id="L2652">                                        edge2ALoc.setY(edge2EndIdx - 1 - edge2ALoc.getY());</span>
                                    }
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">                                    if (edge2BLoc.getY() &lt; (edge2EndIdx - 1)) {</span>
<span class="nc" id="L2655">                                        edge2BLoc.setY(edge2EndIdx - 1 - edge2BLoc.getY());</span>
                                    }
<span class="fc" id="L2657">                                    nReversed++;</span>
<span class="fc" id="L2658">                                    edge2IsClosed = curveHelper.isAdjacent(edge2, 0, edge2.getN() - 1);</span>
                                }
                            }
                        }
                    }

<span class="pc bpc" id="L2664" title="1 of 2 branches missed.">                    if (!didReverse) {</span>

<span class="fc" id="L2666">                        int edge2BeginIdx = findAdjacentToBottomAtTop(edge2);</span>

<span class="pc bpc" id="L2668" title="1 of 2 branches missed.">                        if (edge2BeginIdx &gt; -1) {</span>
<span class="fc" id="L2669">                            didReverse = reverseTopIfPossible(edge2, edge2BeginIdx);</span>
<span class="pc bpc" id="L2670" title="1 of 2 branches missed.">                            if (didReverse) {</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">                                if (edge2ALoc.getY() &lt; edge2BeginIdx) {</span>
<span class="nc" id="L2672">                                    edge2ALoc.setY(edge2BeginIdx - edge2ALoc.getY());</span>
                                }
<span class="nc bnc" id="L2674" title="All 2 branches missed.">                                if (edge2BLoc.getY() &lt; edge2BeginIdx) {</span>
<span class="nc" id="L2675">                                    edge2BLoc.setY(edge2BeginIdx - edge2BLoc.getY());</span>
                                }
<span class="nc" id="L2677">                                edge2IsClosed = curveHelper.isAdjacent(edge2, 0, edge2.getN() - 1);</span>
<span class="nc" id="L2678">                                nReversed++;</span>
                            } else {
<span class="pc bpc" id="L2680" title="1 of 2 branches missed.">                                if (edge2BeginIdx &gt; (edge2.getN()/2)) {</span>
<span class="nc bnc" id="L2681" title="All 2 branches missed.">                                    if (reverseBottomIfPossible(edge2, edge2BeginIdx + 1)) {</span>
<span class="nc bnc" id="L2682" title="All 2 branches missed.">                                        if (edge2ALoc.getY() &gt; (edge2BeginIdx + 1)) {</span>
<span class="nc" id="L2683">                                            edge2ALoc.setY(edge2.getN() - edge2ALoc.getY() + edge2BeginIdx);</span>
                                        }
<span class="nc bnc" id="L2685" title="All 2 branches missed.">                                        if (edge2BLoc.getY() &gt; (edge2BeginIdx + 1)) {</span>
<span class="nc" id="L2686">                                            edge2BLoc.setY(edge2.getN() - edge2BLoc.getY() + edge2BeginIdx);</span>
                                        }
<span class="nc" id="L2688">                                        nReversed++;</span>
<span class="nc" id="L2689">                                        edge2IsClosed = curveHelper.isAdjacent(edge2, 0, edge2.getN() - 1);</span>
                                    }
                                }
                            }
                        }
                    }
                }

<span class="fc bfc" id="L2697" title="All 4 branches covered.">                if (edge1IsClosed &amp;&amp; edge2IsClosed) {</span>

<span class="pc bpc" id="L2699" title="1 of 2 branches missed.">                    if (edge1ALoc.getY() &gt; edge1BLoc.getY()) {</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">                        if (edge2ALoc.getY() &gt; edge2BLoc.getY()) {</span>
<span class="nc" id="L2701">                            circularlyShift(edge1, (edge1.getN() - edge1BLoc.getY() - 1));</span>
<span class="nc" id="L2702">                            circularlyShift(edge2, (edge2.getN() - edge2BLoc.getY() - 1));</span>
<span class="nc" id="L2703">                            edge2.reverse();</span>
<span class="nc" id="L2704">                            edge1.addAll(edge2);</span>
<span class="nc" id="L2705">                            output.remove(edge2Idx);</span>
<span class="nc" id="L2706">                            return 1;</span>
                        } else {
<span class="nc" id="L2708">                            circularlyShift(edge1, (edge1.getN() - edge1BLoc.getY() - 1));</span>
<span class="nc" id="L2709">                            circularlyShift(edge2, (edge2.getN() - edge2ALoc.getY() - 1));</span>
<span class="nc" id="L2710">                            edge1.addAll(edge2);</span>
<span class="nc" id="L2711">                            output.remove(edge2Idx);</span>
<span class="nc" id="L2712">                            return 1;</span>
                        }

                    } else {
<span class="pc bpc" id="L2716" title="1 of 2 branches missed.">                        if (edge2ALoc.getY() &gt; edge2BLoc.getY()) {</span>
<span class="nc" id="L2717">                            circularlyShift(edge1, (edge1.getN() - edge1ALoc.getY() - 1));</span>
<span class="nc" id="L2718">                            circularlyShift(edge2, (edge2.getN() - edge2BLoc.getY() - 1));</span>
<span class="nc" id="L2719">                            edge1.addAll(edge2);</span>
<span class="nc" id="L2720">                            output.remove(edge2Idx);</span>
<span class="nc" id="L2721">                            return 1;</span>
                        } else {
<span class="fc" id="L2723">                            circularlyShift(edge1, (edge1.getN() - edge1ALoc.getY() - 1));</span>
<span class="fc" id="L2724">                            circularlyShift(edge2, (edge2.getN() - edge2ALoc.getY() - 1));</span>
<span class="fc" id="L2725">                            edge2.reverse();</span>
<span class="fc" id="L2726">                            edge1.addAll(edge2);</span>
<span class="fc" id="L2727">                            output.remove(edge2Idx);</span>
<span class="fc" id="L2728">                            return 1;</span>
                        }
                    }
<span class="fc bfc" id="L2731" title="All 2 branches covered.">                } else if (nReversed &gt; 0) {</span>
<span class="fc" id="L2732">                    return 1;</span>
                }
            }
        }

<span class="fc" id="L2737">        return 0;</span>
    }

    private Set&lt;PairInt&gt; findAdjacentInOtherEdge(final int x, final int y,
        final int edgeIdx) {

<span class="fc" id="L2743">        Set&lt;PairInt&gt; locs = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2745" title="All 2 branches covered.">        for (int i = 0; i &lt; dxs8.length; ++i) {</span>

<span class="fc" id="L2747">            int x2 = x + dxs8[i];</span>
<span class="fc" id="L2748">            int y2 = y + dys8[i];</span>

<span class="pc bpc" id="L2750" title="3 of 6 branches missed.">            if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (img.getWidth() - 1)) ||</span>
<span class="pc bpc" id="L2751" title="1 of 2 branches missed.">                (y2 &gt; (img.getHeight() - 1))) {</span>
<span class="nc" id="L2752">                continue;</span>
            }

<span class="fc" id="L2755">            Integer pixIndex2 = img.getIndex(x2, y2);</span>

<span class="fc" id="L2757">            PairInt loc2 = junctionLocationMap.get(pixIndex2);</span>

<span class="fc bfc" id="L2759" title="All 4 branches covered.">            if (loc2 != null &amp;&amp; (loc2.getX() != edgeIdx)) {</span>
<span class="fc" id="L2760">                locs.add(loc2);</span>
            }
        }

<span class="fc" id="L2764">        return locs;</span>
    }

    private boolean reverseTopIfPossible(PairIntArray edge, int cIdx) {

        /*
            reversing beginning of edge:

                                  0          Can reverse segment 0 to cIdx if
                                  1          the point at index 0 is
                                 cIdx - 1    adjacent to cIdx + 1
            edge1 0      edge2   cIdx
                                 cIdx + 1
        */

<span class="fc" id="L2779">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L2781">        boolean isAdjacent = curveHelper.isAdjacent(edge, 0, cIdx + 1);</span>

<span class="fc bfc" id="L2783" title="All 2 branches covered.">        if (isAdjacent) {</span>

<span class="fc" id="L2785">            edge.reverse0toIdx(cIdx);</span>

<span class="fc" id="L2787">            return true;</span>
        }

<span class="fc" id="L2790">        return false;</span>
    }

    private boolean reverseBottomIfPossible(PairIntArray edge, int cIdx) {

        /*            ----  cIdx - 1 ---
            edge1 0      edge2 cIdx          Can reverse segment cIdx to end if
                               cIdx + 1      the point at n-1 is adjacent to
                               cIdx + 2      the point at cIdx - 1
                               n - 1
        */

<span class="fc" id="L2802">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L2804">        boolean isAdjacent = curveHelper.isAdjacent(edge, cIdx - 1, edge.getN() - 1);</span>

<span class="fc bfc" id="L2806" title="All 2 branches covered.">        if (isAdjacent) {</span>

<span class="fc" id="L2808">            edge.reverseIdxtoEnd(cIdx);</span>

<span class="fc" id="L2810">            return true;</span>
        }

<span class="fc" id="L2813">        return false;</span>
    }

    private void circularlyShift(PairIntArray edge, int positiveNumber) {

<span class="pc bpc" id="L2818" title="1 of 2 branches missed.">        if (positiveNumber == 0) {</span>
<span class="nc" id="L2819">            return;</span>
<span class="pc bpc" id="L2820" title="1 of 2 branches missed.">        } else if (positiveNumber &lt; 0) {</span>
<span class="nc" id="L2821">            throw new IllegalArgumentException(</span>
            &quot;method currently requires positiveNumber to be a positive number&quot;);
        }

<span class="fc" id="L2825">        Rotate rotate = new Rotate();</span>

        //TODO: implement the faster logic for shift rights in rotate2
<span class="fc" id="L2828">        rotate.rotate2(edge.getX(), edge.getN(), -1*positiveNumber);</span>

<span class="fc" id="L2830">        rotate.rotate2(edge.getY(), edge.getN(), -1*positiveNumber);</span>

<span class="fc" id="L2832">    }</span>

    private int insertForEdge1LastLocation(List&lt;PairIntArray&gt; edges,
        final int edge1Idx, final int edge2Idx, Set&lt;PairInt&gt; edge2LocForEdge1LastLoc) {

<span class="fc" id="L2837">        PairIntArray edge1 = edges.get(edge1Idx);</span>

<span class="fc" id="L2839">        PairIntArray edge2 = edges.get(edge2Idx);</span>

         /*
         have found locations in edge2 close to the last point in edge1

         (1) if edge2 location is an edge2 endpoint, the insert is simply
         an append or a reverse and append
         (2) ELSE try 2 tests for re-ordering edge2

         (2a) reversing end of edge2:

         ----  cIdx - 1 ---
         edge1 (n-1)    edge2 cIdx          Can reverse segment cIdx to end if
                              cIdx + 1      the point at n-1 is adjacent to
                              cIdx + 2      the point at cIdx - 1
                              n - 1

         (2a) reversing beginning of edge2:

                               0          Can reverse segment 0 to cIdx if
                               1          the point at index 0 is
                              cIdx - 1      adjacent to cIdx + 1
       edge1 (n-1)    edge2   cIdx
                              cIdx + 1
         */
<span class="fc bfc" id="L2864" title="All 2 branches covered.">        for (PairInt edge2Loc : edge2LocForEdge1LastLoc) {</span>
<span class="pc bpc" id="L2865" title="1 of 2 branches missed.">            if (edge2Loc.getY() == 0) {</span>
<span class="nc" id="L2866">                edge1.addAll(edge2);</span>
<span class="nc" id="L2867">                edges.remove(edge2Idx);</span>
<span class="nc" id="L2868">                return 1;</span>
<span class="pc bpc" id="L2869" title="1 of 2 branches missed.">            } else if (edge2Loc.getY() == (edge2.getN() - 1)) {</span>
<span class="nc" id="L2870">                edge2.reverse();</span>
<span class="nc" id="L2871">                edge1.addAll(edge2);</span>
<span class="nc" id="L2872">                edges.remove(edge2Idx);</span>
<span class="nc" id="L2873">                return 1;</span>
            }
<span class="fc" id="L2875">        }</span>

        // prefer the closest to the edge1 point
<span class="fc" id="L2878">        int xn = edge1.getX(edge1.getN() - 1);</span>
<span class="fc" id="L2879">        int yn = edge1.getY(edge1.getN() - 1);</span>
<span class="fc" id="L2880">        PairInt closest = null;</span>
<span class="fc" id="L2881">        double closestDist = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L2882" title="All 2 branches covered.">        for (PairInt edge2Loc : edge2LocForEdge1LastLoc) {</span>
<span class="pc bpc" id="L2883" title="3 of 4 branches missed.">            assert(edge2Loc.getX() == edge2Idx);</span>
<span class="fc" id="L2884">            int x2 = edge2.getX(edge2Loc.getY());</span>
<span class="fc" id="L2885">            int y2 = edge2.getY(edge2Loc.getY());</span>
<span class="fc" id="L2886">            int diffX = Math.abs(xn - x2);</span>
<span class="fc" id="L2887">            int diffY = Math.abs(yn - y2);</span>
<span class="fc" id="L2888">            double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>
<span class="fc bfc" id="L2889" title="All 2 branches covered.">            if (dist &lt; closestDist) {</span>
<span class="fc" id="L2890">                closestDist = dist;</span>
<span class="fc" id="L2891">                closest = edge2Loc;</span>
            }
<span class="fc" id="L2893">        }</span>

<span class="fc" id="L2895">        boolean didReverse = reverseTopIfPossible(edge2, closest.getY());</span>

<span class="fc bfc" id="L2897" title="All 2 branches covered.">        if (didReverse) {</span>
<span class="fc" id="L2898">            edge1.addAll(edge2);</span>
<span class="fc" id="L2899">            edges.remove(edge2Idx);</span>
<span class="fc" id="L2900">            return 1;</span>
        } else {
<span class="fc" id="L2902">            didReverse = reverseBottomIfPossible(edge2, closest.getY());</span>
<span class="pc bpc" id="L2903" title="1 of 2 branches missed.">            if (didReverse) {</span>
<span class="nc" id="L2904">                edge2.reverse();</span>
<span class="nc" id="L2905">                edge1.addAll(edge2);</span>
<span class="nc" id="L2906">                edges.remove(edge2Idx);</span>
<span class="nc" id="L2907">                return 1;</span>
            }
        }

        // if arrived here, try the points in set that are not same as 'closest'
<span class="fc bfc" id="L2912" title="All 2 branches covered.">        for (PairInt edge2Loc : edge2LocForEdge1LastLoc) {</span>

<span class="fc bfc" id="L2914" title="All 2 branches covered.">            if (edge2Loc.equals(closest)) {</span>
<span class="fc" id="L2915">                continue;</span>
            }

<span class="fc" id="L2918">            int idx = edge2Loc.getY();</span>

            // same checks for whether can re-order to have an endpoint
<span class="fc" id="L2921">            didReverse = reverseTopIfPossible(edge2, idx);</span>

<span class="pc bpc" id="L2923" title="1 of 2 branches missed.">            if (didReverse) {</span>
<span class="nc" id="L2924">                edge1.addAll(edge2);</span>
<span class="nc" id="L2925">                edges.remove(edge2Idx);</span>
<span class="nc" id="L2926">                return 1;</span>
            } else {
<span class="fc" id="L2928">                didReverse = reverseBottomIfPossible(edge2, idx);</span>
<span class="pc bpc" id="L2929" title="1 of 2 branches missed.">                if (didReverse) {</span>
<span class="nc" id="L2930">                    edge2.reverse();</span>
<span class="nc" id="L2931">                    edge1.addAll(edge2);</span>
<span class="nc" id="L2932">                    edges.remove(edge2Idx);</span>
<span class="nc" id="L2933">                    return 1;</span>
                }
            }
<span class="fc" id="L2936">        }</span>

<span class="fc" id="L2938">        return 0;</span>
    }

    private int insertForEdge1FirstLocation(List&lt;PairIntArray&gt; edges,
        final int edge1Idx, final int edge2Idx, Set&lt;PairInt&gt; edge2LocForEdge1FirstLoc) {

<span class="fc" id="L2944">        PairIntArray edge1 = edges.get(edge1Idx);</span>

<span class="fc" id="L2946">        PairIntArray edge2 = edges.get(edge2Idx);</span>

        /*
        have found locations in edge2 close to the first point in edge1

        (1) if edge2 location is an edge2 endpoint, the insert is simply
            and append or a reverse and append
        (2) ELSE try 2 tests for re-ordering edge2

        (2a) reversing end of edge2:

                     ----  cIdx - 1 ---
        edge1 0      edge2 cIdx          Can reverse segment cIdx to end if
                           cIdx + 1      the point at n-1 is adjacent to
                           cIdx + 2      the point at cIdx - 1
                           n - 1

        (2a) reversing beginning of edge2:

                              0          Can reverse segment 0 to cIdx if
                              1          the point at index 0 is
                             cIdx - 1    adjacent to cIdx + 1
        edge1 0      edge2   cIdx
                             cIdx + 1
        */

<span class="fc bfc" id="L2972" title="All 2 branches covered.">        for (PairInt edge2Loc : edge2LocForEdge1FirstLoc) {</span>
<span class="fc bfc" id="L2973" title="All 2 branches covered.">            if (edge2Loc.getY() == 0) {</span>
<span class="fc" id="L2974">                edge2.reverse();</span>
<span class="fc" id="L2975">                edge1.insertAll(0, edge2);</span>
<span class="fc" id="L2976">                edges.remove(edge2Idx);</span>
<span class="fc" id="L2977">                return 1;</span>
<span class="pc bpc" id="L2978" title="1 of 2 branches missed.">            } else if (edge2Loc.getY() == (edge2.getN() - 1)) {</span>
<span class="nc" id="L2979">                edge2.addAll(edge1);</span>
<span class="nc" id="L2980">                edges.set(edge1Idx, edge2);</span>
<span class="nc" id="L2981">                edges.remove(edge2Idx);</span>
<span class="nc" id="L2982">                return 1;</span>
            }
<span class="fc" id="L2984">        }</span>

        // prefer the closest to the edge1 point
<span class="fc" id="L2987">        int x1 = edge1.getX(0);</span>
<span class="fc" id="L2988">        int y1 = edge1.getY(0);</span>
<span class="fc" id="L2989">        PairInt closest = null;</span>
<span class="fc" id="L2990">        double closestDist = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L2991" title="All 2 branches covered.">        for (PairInt edge2Loc : edge2LocForEdge1FirstLoc) {</span>
<span class="pc bpc" id="L2992" title="3 of 4 branches missed.">            assert(edge2Loc.getX() == edge2Idx);</span>
<span class="fc" id="L2993">            int x2 = edge2.getX(edge2Loc.getY());</span>
<span class="fc" id="L2994">            int y2 = edge2.getY(edge2Loc.getY());</span>
<span class="fc" id="L2995">            int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L2996">            int diffY = Math.abs(y1 - y2);</span>
<span class="fc" id="L2997">            double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>
<span class="fc bfc" id="L2998" title="All 2 branches covered.">            if (dist &lt; closestDist) {</span>
<span class="fc" id="L2999">                closestDist = dist;</span>
<span class="fc" id="L3000">                closest = edge2Loc;</span>
            }
<span class="fc" id="L3002">        }</span>

<span class="fc" id="L3004">        boolean didReverse = reverseTopIfPossible(edge2, closest.getY());</span>

<span class="fc bfc" id="L3006" title="All 2 branches covered.">        if (didReverse) {</span>
<span class="fc" id="L3007">            edge2.reverse();</span>
<span class="fc" id="L3008">            edge1.insertAll(0, edge2);</span>
<span class="fc" id="L3009">            edges.remove(edge2Idx);</span>
<span class="fc" id="L3010">            return 1;</span>
        } else {
<span class="fc" id="L3012">            didReverse = reverseBottomIfPossible(edge2, closest.getY());</span>
<span class="fc bfc" id="L3013" title="All 2 branches covered.">            if (didReverse) {</span>
<span class="fc" id="L3014">                edge2.addAll(edge1);</span>
<span class="fc" id="L3015">                edges.set(edge1Idx, edge2);</span>
<span class="fc" id="L3016">                edges.remove(edge2Idx);</span>
<span class="fc" id="L3017">                return 1;</span>
            }
        }

        // if arrived here, try the points in set that are not same as 'closest'
<span class="fc bfc" id="L3022" title="All 2 branches covered.">        for (PairInt edge2Loc : edge2LocForEdge1FirstLoc) {</span>

<span class="fc bfc" id="L3024" title="All 2 branches covered.">            if (edge2Loc.equals(closest)) {</span>
<span class="fc" id="L3025">                continue;</span>
            }

<span class="fc" id="L3028">            int idx = edge2Loc.getY();</span>

            // same checks for whether can re-order to have an endpoint
<span class="fc" id="L3031">            didReverse = reverseTopIfPossible(edge2, idx);</span>

<span class="pc bpc" id="L3033" title="1 of 2 branches missed.">            if (didReverse) {</span>
<span class="nc" id="L3034">                edge2.reverse();</span>
<span class="nc" id="L3035">                edge1.insertAll(0, edge2);</span>
<span class="nc" id="L3036">                edges.remove(edge2Idx);</span>
<span class="nc" id="L3037">                return 1;</span>
            } else {
<span class="fc" id="L3039">                didReverse = reverseBottomIfPossible(edge2, idx);</span>
<span class="pc bpc" id="L3040" title="1 of 2 branches missed.">                if (didReverse) {</span>
<span class="nc" id="L3041">                    edge2.addAll(edge1);</span>
<span class="nc" id="L3042">                    edges.set(edge1Idx, edge2);</span>
<span class="nc" id="L3043">                    edges.remove(edge2Idx);</span>
<span class="nc" id="L3044">                    return 1;</span>
                }
            }
<span class="fc" id="L3047">        }</span>
<span class="fc" id="L3048">        return 0;</span>
    }

    private boolean find(List&lt;PairIntArray&gt; output, int x, int y) {

<span class="nc bnc" id="L3053" title="All 2 branches missed.">        for (int i = 0; i &lt; output.size(); ++i) {</span>

<span class="nc" id="L3055">            PairIntArray p = output.get(i);</span>

<span class="nc bnc" id="L3057" title="All 2 branches missed.">            for (int idx = 0; idx &lt; p.getN(); ++idx) {</span>
<span class="nc bnc" id="L3058" title="All 4 branches missed.">                if ((p.getX(idx) == x) &amp;&amp; (p.getY(idx) == y)) {</span>
<span class="nc" id="L3059">                    return true;</span>
                }
            }
        }
<span class="nc" id="L3063">        return false;</span>
    }

    /**
     * find a point starting from the last index that is adjacent to the first
     * index.  the method is used to learn whether there is a reversible section.
     * @param edge
     * @return
     */
    int findAdjacentToTopAtBottom(PairIntArray edge) {

<span class="fc" id="L3074">        int x1 = edge.getX(0);</span>
<span class="fc" id="L3075">        int y1 = edge.getY(0);</span>

<span class="pc bpc" id="L3077" title="1 of 2 branches missed.">        for (int idx = (edge.getN() - 1); idx &gt; 0; --idx) {</span>

<span class="fc" id="L3079">            int x2 = edge.getX(idx);</span>
<span class="fc" id="L3080">            int y2 = edge.getY(idx);</span>

<span class="fc" id="L3082">            int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L3083">            int diffY = Math.abs(y1 - y2);</span>

<span class="fc bfc" id="L3085" title="All 4 branches covered.">            if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L3086">                return idx;</span>
            }
        }

<span class="nc" id="L3090">        return -1;</span>
    }

    int findAdjacentToBottomAtTop(PairIntArray edge) {

<span class="fc" id="L3095">        int xn = edge.getX(edge.getN() - 1);</span>
<span class="fc" id="L3096">        int yn = edge.getY(edge.getN() - 1);</span>

<span class="fc bfc" id="L3098" title="All 2 branches covered.">        for (int idx = 0; idx &lt; (edge.getN() - 2); ++idx) {</span>

<span class="fc" id="L3100">            int x2 = edge.getX(idx);</span>
<span class="fc" id="L3101">            int y2 = edge.getY(idx);</span>

<span class="fc" id="L3103">            int diffX = Math.abs(xn - x2);</span>
<span class="fc" id="L3104">            int diffY = Math.abs(yn - y2);</span>

<span class="fc bfc" id="L3106" title="All 4 branches covered.">            if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L3107">                return idx;</span>
            }
        }

<span class="fc" id="L3111">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
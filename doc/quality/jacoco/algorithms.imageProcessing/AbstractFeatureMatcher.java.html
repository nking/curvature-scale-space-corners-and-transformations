<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractFeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">AbstractFeatureMatcher.java</span></div><h1>AbstractFeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.HoughTransform;
import algorithms.compGeometry.HoughTransform.HoughTransformLines;
import algorithms.compGeometry.RotatedOffsets;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L23" title="1 of 2 branches missed.">public abstract class AbstractFeatureMatcher {</span>
    
<span class="fc" id="L25">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L27">    protected final int binnedImageMaxDimension = 512;</span>
    
    protected final BlobPerimeterCornerHelper img1Helper;
    
    protected final BlobPerimeterCornerHelper img2Helper;
    
    // use with img1Helper.getImage() or getGreyscaleImage(), but not both
    protected final IntensityFeatures features1;
    
    // use img2Helper.getGreyscaleImageBinned(),
    protected final IntensityFeatures featuresBinned1;
    
    protected final IntensityFeatures features2;
    
    protected final IntensityFeatures featuresBinned2;
    
    protected final FeatureMatcherSettings settings;
    
<span class="fc" id="L45">    protected boolean useSameSegmentation = false;</span>
    
<span class="fc" id="L47">    protected List&lt;FeatureComparisonStat&gt; solutionStats = null;</span>
    
<span class="fc" id="L49">    protected List&lt;PairInt&gt; solutionMatched1 = null;</span>
    
<span class="fc" id="L51">    protected List&lt;PairInt&gt; solutionMatched2 = null;</span>
    
    public AbstractFeatureMatcher(ImageExt img1, ImageExt img2, 
<span class="fc" id="L54">        FeatureMatcherSettings settings) {</span>
        
<span class="fc" id="L56">        RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
        
<span class="fc" id="L58">        this.settings = settings.copy();</span>
                
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
            
<span class="fc" id="L62">            img1Helper = new BlobPerimeterCornerHelper(img1, settings.getDebugTag() + &quot;_1&quot;);</span>

<span class="fc" id="L64">            img2Helper = new BlobPerimeterCornerHelper(img2, settings.getDebugTag() + &quot;_2&quot;);</span>
            
        } else {
            
<span class="nc" id="L68">            img1Helper = new BlobPerimeterCornerHelper(img1);</span>

<span class="nc" id="L70">            img2Helper = new BlobPerimeterCornerHelper(img2);</span>
        }
              
        // delaying creation of gradient images for full images until needed:
<span class="fc" id="L74">        features1 = new IntensityFeatures(5, settings.useNormalizedFeatures(),</span>
            rotatedOffsets);

<span class="fc" id="L77">        features2 = new IntensityFeatures(5, settings.useNormalizedFeatures(),</span>
            rotatedOffsets);
                        
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        if (settings.startWithBinnedImages()) {</span>
            
<span class="fc" id="L82">            img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            
<span class="fc" id="L84">            img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
                        
<span class="fc" id="L86">            featuresBinned1 = new IntensityFeatures(5, </span>
<span class="fc" id="L87">                settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L88">            featuresBinned1.calculateGradientWithGreyscale(img1Helper.getGreyscaleImageBinned());</span>
            
<span class="fc" id="L90">            featuresBinned2 = new IntensityFeatures(5, </span>
<span class="fc" id="L91">                settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L92">            featuresBinned2.calculateGradientWithGreyscale(img2Helper.getGreyscaleImageBinned());</span>
            
        } else {
            
<span class="nc" id="L96">            featuresBinned1 = null;</span>
            
<span class="nc" id="L98">            featuresBinned2 = null;  </span>
        }
<span class="fc" id="L100">    }</span>

    public boolean match() throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L104">        ImageStatistics statsR1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L105">            img1Helper.getImage().getRValues(), true);</span>
<span class="fc" id="L106">        ImageStatistics statsB1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L107">            img1Helper.getImage().getBValues(), true);</span>
<span class="fc" id="L108">        ImageStatistics statsG1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L109">            img1Helper.getImage().getGValues(), true);</span>
<span class="fc" id="L110">        ImageStatistics statsR2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L111">            img2Helper.getImage().getRValues(), true);</span>
<span class="fc" id="L112">        ImageStatistics statsB2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L113">            img2Helper.getImage().getBValues(), true);</span>
<span class="fc" id="L114">        ImageStatistics statsG2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L115">            img2Helper.getImage().getGValues(), true);</span>
        
<span class="fc" id="L117">        log.info(&quot;stats R1=&quot; + statsR1.toString());</span>
<span class="fc" id="L118">        log.info(&quot;stats G1=&quot; + statsG1.toString());</span>
<span class="fc" id="L119">        log.info(&quot;stats B1=&quot; + statsB1.toString());</span>
<span class="fc" id="L120">        log.info(&quot;stats R2=&quot; + statsR2.toString());</span>
<span class="fc" id="L121">        log.info(&quot;stats G2=&quot; + statsG2.toString());</span>
<span class="fc" id="L122">        log.info(&quot;stats B2=&quot; + statsB2.toString());</span>
<span class="fc" id="L123">        int limit = 20;</span>
<span class="fc" id="L124">        useSameSegmentation = false;</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if ((Math.abs(statsR1.getMode() - statsR2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">            (Math.abs(statsG1.getMode() - statsG2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            (Math.abs(statsB1.getMode() - statsB2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">            (Math.abs(statsR1.getMedian() - statsR2.getMedian()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            (Math.abs(statsG1.getMedian() - statsG2.getMedian()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            (Math.abs(statsB1.getMedian() - statsB2.getMedian()) &lt; limit)) {</span>
<span class="fc" id="L131">            useSameSegmentation = true;</span>
        }
        
        //TODO: document this logic for the user
<span class="fc" id="L135">        SegmentationType type = SegmentationType.GREYSCALE_WAVELET;</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (settings.doOverrideWithCannySegmentation()) {</span>
<span class="nc" id="L137">            type = SegmentationType.GREYSCALE_CANNY;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        } else if (settings.doUse2ndDerivCorners()) {</span>
<span class="fc" id="L139">            type = SegmentationType.NONE;</span>
        }
        
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        boolean[] useBinned = settings.startWithBinnedImages() ? </span>
            new boolean[]{true, false} : new boolean[]{false};
        
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        for (boolean ub : useBinned) {</span>
            
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if (!ub) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (!features1.gradientWasCreated()) {</span>
<span class="nc" id="L149">                    features1.calculateGradientWithGreyscale(</span>
<span class="nc" id="L150">                        img1Helper.getGreyscaleImage());</span>
                }
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (!features2.gradientWasCreated()) {</span>
<span class="nc" id="L153">                    features2.calculateGradientWithGreyscale(</span>
<span class="nc" id="L154">                        img2Helper.getGreyscaleImage());</span>
                }
            }
            
<span class="fc" id="L158">            boolean solved = generateAndMatchCornerRegions(type, ub);</span>
            
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">            if (solved) {</span>
<span class="fc" id="L161">                return true;</span>
            }
        }
        
<span class="nc" id="L165">        return false;</span>
    }

    protected void prepareCorners(SegmentationType type, boolean useBinned) 
        throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L171">        log.info(type.name() + &quot; binned=&quot; + useBinned + &quot; useSameSegmentation=&quot; </span>
            + useSameSegmentation);
        
        IntensityFeatures f1, f2;
        
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (useBinned) {</span>
<span class="fc" id="L177">            img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
<span class="fc" id="L178">            img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
<span class="fc" id="L179">            f1 = featuresBinned1;</span>
<span class="fc" id="L180">            f2 = featuresBinned2;</span>
        } else {
<span class="nc" id="L182">            f1 = features1;</span>
<span class="nc" id="L183">            f2 = features2;</span>
        }
        
<span class="fc" id="L186">        img1Helper.applySegmentation(type, useBinned);</span>
<span class="fc" id="L187">        img2Helper.applySegmentation(type, useBinned);</span>
        
        List&lt;HoughTransformLines&gt; houghTransformLines1;
        List&lt;HoughTransformLines&gt; houghTransformLines2;
                
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (type.equals(SegmentationType.GREYSCALE_CANNY)) {</span>
            
<span class="nc" id="L194">            boolean filterOutImageBoundaryBlobs = true;</span>
<span class="nc" id="L195">            boolean filterOutZeroPixels = false;</span>
<span class="nc" id="L196">            boolean doNotAddPoints = true;</span>
            
            // pre-make the blobs using non-default variables:
<span class="nc" id="L199">            img1Helper.getBlobs(type, useBinned, filterOutImageBoundaryBlobs, </span>
                filterOutZeroPixels);
            
<span class="nc" id="L202">            img2Helper.getBlobs(type, useBinned, filterOutImageBoundaryBlobs, </span>
                filterOutZeroPixels); 
            
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (settings.doUse2ndDerivCorners()) {</span>
                //TODO: consider using extractSecondDerivativeCornersithoutBlobs instead
<span class="nc" id="L207">                img1Helper.extractSecondDerivativeCorners(type, useBinned);</span>
<span class="nc" id="L208">                img2Helper.extractSecondDerivativeCorners(type, useBinned);</span>
            } else {
<span class="nc" id="L210">                img1Helper.extractBlobPerimeterAsCornerRegions(type, useBinned, </span>
                    doNotAddPoints);
<span class="nc" id="L212">                img2Helper.extractBlobPerimeterAsCornerRegions(type, useBinned, </span>
                    doNotAddPoints);
            }
        }
        
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (settings.doUse2ndDerivCorners()) {</span>
<span class="fc" id="L218">            img1Helper.extractSecondDerivativeCornersWithoutBlobs(type, useBinned);</span>
<span class="fc" id="L219">            img2Helper.extractSecondDerivativeCornersWithoutBlobs(type, useBinned);</span>
        } else {
<span class="fc" id="L221">            img1Helper.extractBlobPerimeterAsCornerRegions(type, useBinned);</span>
<span class="fc" id="L222">            img2Helper.extractBlobPerimeterAsCornerRegions(type, useBinned);</span>
        
<span class="fc" id="L224">            houghTransformLines1 = findLinesUsingHoughTransform(img1Helper, </span>
                type, useBinned);
<span class="fc" id="L226">            houghTransformLines2 = findLinesUsingHoughTransform(img2Helper, </span>
                type, useBinned);
<span class="fc" id="L228">            removeLineArtifactCorners(houghTransformLines1, img1Helper, type, </span>
                useBinned);
<span class="fc" id="L230">            removeLineArtifactCorners(houghTransformLines2, img2Helper, type, </span>
                useBinned);
        }
<span class="fc" id="L233">    }</span>

    protected boolean generateAndMatchCornerRegions(SegmentationType type, 
        boolean useBinned) throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L238">        log.info(type.name() + &quot; binned=&quot; + useBinned + &quot; useSameSegmentation=&quot; </span>
            + useSameSegmentation);
        
<span class="fc" id="L241">        prepareCorners(type, useBinned);</span>
                        
<span class="fc" id="L243">        return match(type, useBinned);</span>
    }
    
    protected abstract boolean match(SegmentationType type, boolean useBinned);

    protected List&lt;HoughTransform.HoughTransformLines&gt; 
        findLinesUsingHoughTransform(BlobPerimeterCornerHelper blobCornerHelper, 
        SegmentationType segmentationType, boolean useBinnedImage) {
        
<span class="fc" id="L252">        List&lt;PairIntArray&gt; perimeterLists = blobCornerHelper.getBlobPerimeters(</span>
            segmentationType, useBinnedImage);
        
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        int imageWidth = useBinnedImage ? </span>
<span class="pc" id="L256">            blobCornerHelper.getGreyscaleImageBinned().getWidth() : </span>
<span class="pc" id="L257">            blobCornerHelper.getGreyscaleImage().getWidth();</span>
        
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        int imageHeight = useBinnedImage ? </span>
<span class="pc" id="L260">            blobCornerHelper.getGreyscaleImageBinned().getHeight() : </span>
<span class="pc" id="L261">            blobCornerHelper.getGreyscaleImage().getHeight();</span>
        
<span class="fc" id="L263">        int thetaTol = 1;</span>
<span class="fc" id="L264">        int radiusTol = 7;</span>
        
<span class="fc" id="L266">        HoughTransform ht = new HoughTransform();</span>
        
<span class="fc" id="L268">        List&lt;HoughTransform.HoughTransformLines&gt; lineList = </span>
            new ArrayList&lt;HoughTransform.HoughTransformLines&gt;();
        
<span class="fc bfc" id="L271" title="All 2 branches covered.">        for (int ii = 0; ii &lt; perimeterLists.size(); ++ii) {</span>
            
            // NOTE: in testable method for this, should allow ability to
            // pass in junctions and not delete corners that are in
            // junctions.
            // For these blob perimeters, there are not junctions.
<span class="fc" id="L277">            PairIntArray edge = perimeterLists.get(ii);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (edge.getN() == 0) {</span>
<span class="nc" id="L279">                HoughTransformLines htl = ht.new HoughTransformLines(</span>
                    new HashMap&lt;PairInt, PairInt&gt;(), new ArrayList&lt;Set&lt;PairInt&gt;&gt;());
<span class="nc" id="L281">                lineList.add(htl);</span>
<span class="nc" id="L282">                continue;</span>
            }
            
<span class="fc" id="L285">            Map&lt;PairInt, Set&lt;PairInt&gt;&gt; outputPolarCoordsPixMap = </span>
<span class="fc" id="L286">                ht.calculateLineGivenEdge(edge, imageWidth, imageHeight);</span>
            
<span class="fc" id="L288">            List&lt;PairInt&gt; outSortedKeys = ht.sortByVotes(outputPolarCoordsPixMap);</span>
            
            // === find indiv lines within the edge ====
<span class="fc" id="L291">            HoughTransform.HoughTransformLines htl = </span>
<span class="fc" id="L292">                ht.createPixTRMapsFromSorted(outSortedKeys, </span>
                outputPolarCoordsPixMap, thetaTol, radiusTol);
            
<span class="fc" id="L295">            lineList.add(htl);</span>
        }
<span class="fc" id="L297">        return lineList;</span>
    }

    protected void removeLineArtifactCorners(List&lt;HoughTransformLines&gt; 
        houghTransformLines, BlobPerimeterCornerHelper blobCornerHelper, 
        SegmentationType segmentationType, boolean useBinnedImage) {
        
<span class="fc" id="L304">        List&lt;PairIntArray&gt; perimeterLists = blobCornerHelper.getBlobPerimeters(</span>
            segmentationType, useBinnedImage);
        
<span class="fc" id="L307">        List&lt;List&lt;CornerRegion&gt;&gt; cornerRegionLists = </span>
<span class="fc" id="L308">            blobCornerHelper.getPerimeterCorners(segmentationType, useBinnedImage);</span>
        
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        int imageWidth = useBinnedImage ? </span>
<span class="pc" id="L311">            blobCornerHelper.getGreyscaleImageBinned().getWidth() : </span>
<span class="pc" id="L312">            blobCornerHelper.getGreyscaleImage().getWidth();</span>
        
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        int imageHeight = useBinnedImage ? </span>
<span class="pc" id="L315">            blobCornerHelper.getGreyscaleImageBinned().getHeight() : </span>
<span class="pc" id="L316">            blobCornerHelper.getGreyscaleImage().getHeight();</span>
        
<span class="fc" id="L318">        int thetaTol = 1;</span>
<span class="fc" id="L319">        int radiusTol = 7;</span>
        
        //use hough transform for lines to remove corners from line artifacts
<span class="fc" id="L322">        CornerCorrector.removeCornersFromLineArtifacts(houghTransformLines, </span>
            perimeterLists, cornerRegionLists, thetaTol, radiusTol, imageWidth, 
            imageHeight);
<span class="fc" id="L325">    }</span>

    protected List&lt;FeatureComparisonStat&gt; reviseStatsForFullImages(
        GreyscaleImage gsImg1, GreyscaleImage gsImg2, 
        List&lt;FeatureComparisonStat&gt; stats, int prevBinFactor1, 
        int prevBinFactor2, RotatedOffsets rotatedOffsets) {
        
<span class="fc" id="L332">        log.info(&quot;refine stats for full image reference frames&quot;);</span>
        
<span class="fc" id="L334">        List&lt;FeatureComparisonStat&gt; revised = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="fc" id="L336">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
        
<span class="fc" id="L338">        IntensityFeatures f1 = new IntensityFeatures(5, </span>
<span class="fc" id="L339">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L340">        f1.calculateGradientWithGreyscale(gsImg1);</span>
        
<span class="fc" id="L342">        IntensityFeatures f2 = new IntensityFeatures(5, </span>
<span class="fc" id="L343">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L344">        f2.calculateGradientWithGreyscale(gsImg2);</span>
        
<span class="fc" id="L346">        int dither = 2;</span>
        
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
            
<span class="fc" id="L350">            FeatureComparisonStat stat = stats.get(i);</span>
            
<span class="fc" id="L352">            int x1 = stat.getImg1Point().getX() * prevBinFactor1;</span>
<span class="fc" id="L353">            int y1 = stat.getImg1Point().getY() * prevBinFactor1;</span>
<span class="fc" id="L354">            int x2 = stat.getImg2Point().getX() * prevBinFactor2;</span>
<span class="fc" id="L355">            int y2 = stat.getImg2Point().getY() * prevBinFactor2;</span>
            
            // have to discard the best angles found in stat and derive new
            // for these higher resolution images
<span class="fc" id="L359">            FeatureComparisonStat compStat = </span>
<span class="fc" id="L360">                featureMatcher.ditherAndRotateForBestLocation2(f1, </span>
                    f2, x1, y1, x2, y2, dither, gsImg1, gsImg2);
            
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (compStat == null || (compStat.getSumIntensitySqDiff() &gt; </span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                compStat.getImg2PointIntensityErr())) {</span>
<span class="nc" id="L365">                continue;</span>
            }
            
<span class="fc" id="L368">            revised.add(compStat);</span>
        }
        
<span class="fc" id="L371">        return revised;</span>
    }

    public void copyToInstanceVars(List&lt;FeatureComparisonStat&gt; stats) {
        
<span class="fc" id="L376">        this.solutionStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L377">        this.solutionMatched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L378">        this.solutionMatched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="fc" id="L381">            solutionStats.add(stat.copy());</span>
<span class="fc" id="L382">            solutionMatched1.add(stat.getImg1Point().copy());</span>
<span class="fc" id="L383">            solutionMatched2.add(stat.getImg2Point().copy());</span>
<span class="fc" id="L384">        }</span>
<span class="fc" id="L385">    }</span>
    
    protected void extractCannyCornerRegions(GreyscaleImage img1,
        GreyscaleImage img2, Set&lt;CornerRegion&gt; outputCornerRegions1,
        Set&lt;CornerRegion&gt; outputCornerRegions2) {

<span class="fc" id="L391">        GreyscaleImage gsImg1 = img1.copyImage();</span>
<span class="fc" id="L392">        GreyscaleImage gsImg2 = img2.copyImage();</span>

<span class="fc" id="L394">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L395">        imageProcessor.blur(gsImg1, SIGMA.ONE);</span>

<span class="fc" id="L397">        CurvatureScaleSpaceCornerDetector detector = new CurvatureScaleSpaceCornerDetector(gsImg1);</span>
<span class="fc" id="L398">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L399">        detector.findCorners();</span>

<span class="fc" id="L401">        Set&lt;CornerRegion&gt; cornerRegions1 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions1 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);

<span class="fc" id="L404">        outputCornerRegions1.addAll(cornerRegions1);</span>

<span class="fc" id="L406">        imageProcessor.blur(gsImg2, SIGMA.ONE);</span>

<span class="fc" id="L408">        detector = new CurvatureScaleSpaceCornerDetector(gsImg2);</span>
<span class="fc" id="L409">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L410">        detector.findCorners();</span>
<span class="fc" id="L411">        Set&lt;CornerRegion&gt; cornerRegions2 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions2 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);

<span class="fc" id="L414">        outputCornerRegions2.addAll(cornerRegions2);</span>
<span class="fc" id="L415">    }</span>
    
    protected List&lt;FeatureComparisonStat&gt; findCorrespondence(GreyscaleImage img1,
        GreyscaleImage img2, Set&lt;CornerRegion&gt; cornerRegions1,
        Set&lt;CornerRegion&gt; cornerRegions2, TransformationParameters parameters,
        RotatedOffsets rotatedOffsets, int dither2, int transXYTol,
        float scaleTol, float rotationInRadiansTol) {

<span class="fc" id="L423">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

<span class="fc" id="L425">        List&lt;FeatureComparisonStat&gt; stats = </span>
<span class="fc" id="L426">            featureMatcher.findSimilarFeaturesAsStats(img1,</span>
<span class="fc" id="L427">            cornerRegions1.toArray(new CornerRegion[cornerRegions1.size()]),</span>
<span class="fc" id="L428">            img2, cornerRegions2.toArray(new CornerRegion[cornerRegions2.size()]),</span>
            parameters, scaleTol, rotationInRadiansTol, transXYTol,
            dither2, rotatedOffsets);
        
<span class="fc" id="L432">        return stats;</span>
    }

    protected MatchingSolution transformSolutionToFullFrames(MatchingSolution 
        soln, BlobPerimeterCornerHelper img1Helper, 
        BlobPerimeterCornerHelper img2Helper, int binFactor1, int binFactor2) {
        
<span class="pc bpc" id="L439" title="3 of 4 branches missed.">        if (binFactor1 == 1 &amp;&amp; binFactor2 == 1) {</span>
<span class="nc" id="L440">            return soln;</span>
        }
       
<span class="fc" id="L443">        RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
        
<span class="pc bpc" id="L445" title="3 of 4 branches missed.">        assert(rotatedOffsets.containsData());</span>
        
<span class="fc" id="L447">        List&lt;FeatureComparisonStat&gt; stats = soln.getComparisonStats();</span>
        
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
<span class="fc" id="L450">            FeatureComparisonStat stat = stats.get(i);</span>
<span class="fc" id="L451">            stat.setBinFactor1(binFactor1);</span>
<span class="fc" id="L452">            stat.setBinFactor2(binFactor2);</span>
        }
        
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            GreyscaleImage im1 = (binFactor1 != 1) ? </span>
<span class="pc" id="L457">                img1Helper.getGreyscaleImageBinned() :</span>
<span class="pc" id="L458">                img1Helper.getGreyscaleImage();</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            GreyscaleImage im2 = (binFactor2 != 1) ? </span>
<span class="pc" id="L460">                img2Helper.getGreyscaleImageBinned() :</span>
<span class="pc" id="L461">                img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L462">            MiscDebug.writeImages(im1, im2, stats, </span>
<span class="fc" id="L463">                &quot;_matched_binned_&quot; + settings.getDebugTag() </span>
<span class="fc" id="L464">                + MiscDebug.getCurrentTimeFormatted(), 1);</span>
        }
        
<span class="fc" id="L467">        FeatureMatcher matcher = new FeatureMatcher();</span>
        
<span class="fc" id="L469">        List&lt;FeatureComparisonStat&gt; fullStats = matcher.reviseStatsForFullImages(</span>
<span class="fc" id="L470">            img1Helper.getGreyscaleImage(),</span>
<span class="fc" id="L471">            img2Helper.getGreyscaleImage(),</span>
            settings,
<span class="fc" id="L473">            soln.getParams(), soln.getComparisonStats(),</span>
            binFactor1, binFactor2, rotatedOffsets);
            
<span class="pc bpc" id="L476" title="2 of 4 branches missed.">        if ((fullStats == null) || fullStats.isEmpty()) {</span>
<span class="nc" id="L477">            return null;</span>
        }
        
<span class="fc" id="L480">        TransformationParameters revisedParams = </span>
<span class="fc" id="L481">            MiscStats.calculateTransformation(1, 1, fullStats,</span>
                new float[4], false);
        
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (revisedParams == null) {</span>
<span class="fc" id="L485">            return null;</span>
        }
        
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="fc" id="L489">            GreyscaleImage im1 = img1Helper.getGreyscaleImage();</span>
<span class="fc" id="L490">            GreyscaleImage im2 = img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L491">            MiscDebug.writeImages(im1, im2, fullStats, </span>
<span class="fc" id="L492">                &quot;_matched_&quot; + settings.getDebugTag() +</span>
<span class="fc" id="L493">                MiscDebug.getCurrentTimeFormatted(), 2);</span>
        }
        
<span class="fc" id="L496">        MatchingSolution fullSoln = new MatchingSolution(revisedParams, </span>
            fullStats, 1, 1);
        
<span class="fc" id="L499">        return fullSoln;</span>
    }

    protected void filterForLocalization(GreyscaleImage img, 
        IntensityFeatures f, List&lt;CornerRegion&gt; corners) {
                
<span class="fc" id="L505">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L507" title="All 2 branches covered.">        for (int i = 0; i &lt; corners.size(); ++i) {</span>
<span class="fc" id="L508">            CornerRegion cr = corners.get(i);</span>
            
            try {
<span class="fc" id="L511">                int x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L512">                int y = cr.getY()[cr.getKMaxIdx()];</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">                if (f.removeDueToLocalization(img, x, y,</span>
<span class="fc" id="L514">                    f.calculateOrientation(x, y))) {</span>
<span class="fc" id="L515">                    remove.add(Integer.valueOf(i));</span>
                }
<span class="nc" id="L517">            } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L518">            }</span>
        }
        
<span class="fc bfc" id="L521" title="All 2 branches covered.">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L522">            int idx = remove.get(i);</span>
<span class="fc" id="L523">            corners.remove(idx);</span>
        }
<span class="fc" id="L525">    }</span>
    
    protected void filterForLocalization2(GreyscaleImage img, 
        IntensityFeatures f, List&lt;List&lt;CornerRegion&gt;&gt; corners) {
                        
<span class="fc bfc" id="L530" title="All 2 branches covered.">        for (int i = 0; i &lt; corners.size(); ++i) {</span>
<span class="fc" id="L531">            List&lt;CornerRegion&gt; cr = corners.get(i);</span>
<span class="fc" id="L532">            filterForLocalization(img, f, cr);</span>
        }
<span class="fc" id="L534">    }</span>
    
    /**
     * get a copy of the solution's feature stats.
     * @return 
     */
    public List&lt;FeatureComparisonStat&gt; getSolutionStats() {
<span class="fc" id="L541">        return solutionStats;</span>
    }

    /**
     * get the matched points from image 1
     * @return the solutionMatched1
     */
    public List&lt;PairInt&gt; getSolutionMatched1() {
<span class="fc" id="L549">        return solutionMatched1;</span>
    }

    /**
     * get the matched points from image 2
     * @return the solutionMatched2
     */
    public List&lt;PairInt&gt; getSolutionMatched2() {
<span class="fc" id="L557">        return solutionMatched2;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
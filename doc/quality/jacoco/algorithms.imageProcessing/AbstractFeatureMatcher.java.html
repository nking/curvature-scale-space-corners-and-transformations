<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractFeatureMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">AbstractFeatureMatcher.java</span></div><h1>AbstractFeatureMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.HoughTransform;
import algorithms.compGeometry.HoughTransform.HoughTransformLines;
import algorithms.compGeometry.RotatedOffsets;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
public abstract class AbstractFeatureMatcher {
    
<span class="fc" id="L23">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L25">    protected final int binnedImageMaxDimension = 512;</span>
    
    protected final BlobPerimeterCornerHelper img1Helper;
    
    protected final BlobPerimeterCornerHelper img2Helper;
    
    // use with img1Helper.getImage() or getGreyscaleImage(), but not both
    protected final IntensityFeatures features1;
    
    // use img2Helper.getGreyscaleImageBinned(),
    protected final IntensityFeatures featuresBinned1;
    
    protected final IntensityFeatures features2;
    
    protected final IntensityFeatures featuresBinned2;
    
    protected final FeatureMatcherSettings settings;
    
<span class="fc" id="L43">    protected boolean useSameSegmentation = false;</span>
    
<span class="fc" id="L45">    protected List&lt;FeatureComparisonStat&gt; solutionStats = null;</span>
    
<span class="fc" id="L47">    protected List&lt;PairInt&gt; solutionMatched1 = null;</span>
    
<span class="fc" id="L49">    protected List&lt;PairInt&gt; solutionMatched2 = null;</span>
    
    public AbstractFeatureMatcher(ImageExt img1, ImageExt img2, 
<span class="fc" id="L52">        FeatureMatcherSettings settings) {</span>
        
<span class="fc" id="L54">        RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
        
<span class="fc" id="L56">        this.settings = settings.copy();</span>
                
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
            
<span class="fc" id="L60">            img1Helper = new BlobPerimeterCornerHelper(img1, settings.getDebugTag() + &quot;_1&quot;);</span>

<span class="fc" id="L62">            img2Helper = new BlobPerimeterCornerHelper(img2, settings.getDebugTag() + &quot;_2&quot;);</span>
            
        } else {
            
<span class="nc" id="L66">            img1Helper = new BlobPerimeterCornerHelper(img1);</span>

<span class="nc" id="L68">            img2Helper = new BlobPerimeterCornerHelper(img2);</span>
        }
              
        // delaying creation of gradient images for full images until needed:
<span class="fc" id="L72">        features1 = new IntensityFeatures(5, settings.useNormalizedFeatures(),</span>
            rotatedOffsets);

<span class="fc" id="L75">        features2 = new IntensityFeatures(5, settings.useNormalizedFeatures(),</span>
            rotatedOffsets);
                        
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (settings.startWithBinnedImages()) {</span>
            
<span class="fc" id="L80">            img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
            
<span class="fc" id="L82">            img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
                        
<span class="fc" id="L84">            featuresBinned1 = new IntensityFeatures(5, </span>
<span class="fc" id="L85">                settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L86">            featuresBinned1.calculateGradientWithGreyscale(img1Helper.getGreyscaleImageBinned());</span>
            
<span class="fc" id="L88">            featuresBinned2 = new IntensityFeatures(5, </span>
<span class="fc" id="L89">                settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L90">            featuresBinned2.calculateGradientWithGreyscale(img2Helper.getGreyscaleImageBinned());</span>
            
        } else {
            
<span class="nc" id="L94">            featuresBinned1 = null;</span>
            
<span class="nc" id="L96">            featuresBinned2 = null;  </span>
        }
<span class="fc" id="L98">    }</span>

    public boolean match() throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L102">        ImageStatistics statsR1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L103">            img1Helper.getImage().getRValues(), true);</span>
<span class="fc" id="L104">        ImageStatistics statsB1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L105">            img1Helper.getImage().getBValues(), true);</span>
<span class="fc" id="L106">        ImageStatistics statsG1 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L107">            img1Helper.getImage().getGValues(), true);</span>
<span class="fc" id="L108">        ImageStatistics statsR2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L109">            img2Helper.getImage().getRValues(), true);</span>
<span class="fc" id="L110">        ImageStatistics statsB2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L111">            img2Helper.getImage().getBValues(), true);</span>
<span class="fc" id="L112">        ImageStatistics statsG2 = ImageStatisticsHelper.examine(</span>
<span class="fc" id="L113">            img2Helper.getImage().getGValues(), true);</span>
        
<span class="fc" id="L115">        log.info(&quot;stats R1=&quot; + statsR1.toString());</span>
<span class="fc" id="L116">        log.info(&quot;stats G1=&quot; + statsG1.toString());</span>
<span class="fc" id="L117">        log.info(&quot;stats B1=&quot; + statsB1.toString());</span>
<span class="fc" id="L118">        log.info(&quot;stats R2=&quot; + statsR2.toString());</span>
<span class="fc" id="L119">        log.info(&quot;stats G2=&quot; + statsG2.toString());</span>
<span class="fc" id="L120">        log.info(&quot;stats B2=&quot; + statsB2.toString());</span>
<span class="fc" id="L121">        int limit = 20;</span>
<span class="fc" id="L122">        useSameSegmentation = false;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if ((Math.abs(statsR1.getMode() - statsR2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            (Math.abs(statsG1.getMode() - statsG2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            (Math.abs(statsB1.getMode() - statsB2.getMode()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">            (Math.abs(statsR1.getMedian() - statsR2.getMedian()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            (Math.abs(statsG1.getMedian() - statsG2.getMedian()) &lt; limit) &amp;&amp; </span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">            (Math.abs(statsB1.getMedian() - statsB2.getMedian()) &lt; limit)) {</span>
<span class="fc" id="L129">            useSameSegmentation = true;</span>
        }
        
<span class="fc" id="L132">        SegmentationType type = SegmentationType.GREYSCALE_WAVELET;</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (settings.doOverrideWithCannySegmentation()) {</span>
<span class="nc" id="L134">            type = SegmentationType.GREYSCALE_CANNY;</span>
        }
        
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        boolean[] useBinned = settings.startWithBinnedImages() ? </span>
            new boolean[]{true, false} : new boolean[]{false};
        
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        for (boolean ub : useBinned) {</span>
            
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if (!ub) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                if (!features1.gradientWasCreated()) {</span>
<span class="nc" id="L144">                    features1.calculateGradientWithGreyscale(</span>
<span class="nc" id="L145">                        img1Helper.getGreyscaleImage());</span>
                }
<span class="nc bnc" id="L147" title="All 2 branches missed.">                if (!features2.gradientWasCreated()) {</span>
<span class="nc" id="L148">                    features2.calculateGradientWithGreyscale(</span>
<span class="nc" id="L149">                        img2Helper.getGreyscaleImage());</span>
                }
            }
            
<span class="fc" id="L153">            boolean solved = generateAndMatchCornerRegions(type, ub);</span>
            
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">            if (solved) {</span>
<span class="fc" id="L156">                return true;</span>
            }
        }
        
<span class="nc" id="L160">        return false;</span>
    }

    protected void prepareCorners(SegmentationType type, boolean useBinned) 
        throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L166">        log.info(type.name() + &quot; binned=&quot; + useBinned + &quot; useSameSegmentation=&quot; </span>
            + useSameSegmentation);
        
        IntensityFeatures f1, f2;
        
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (useBinned) {</span>
<span class="fc" id="L172">            img1Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
<span class="fc" id="L173">            img2Helper.createBinnedGreyscaleImage(binnedImageMaxDimension);</span>
<span class="fc" id="L174">            f1 = featuresBinned1;</span>
<span class="fc" id="L175">            f2 = featuresBinned2;</span>
        } else {
<span class="nc" id="L177">            f1 = features1;</span>
<span class="nc" id="L178">            f2 = features2;</span>
        }
        
<span class="fc" id="L181">        img1Helper.applySegmentation(type, useBinned);</span>
<span class="fc" id="L182">        img2Helper.applySegmentation(type, useBinned);</span>
        
        List&lt;HoughTransformLines&gt; houghTransformLines1;
        List&lt;HoughTransformLines&gt; houghTransformLines2;
                
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (type.equals(SegmentationType.GREYSCALE_CANNY)) {</span>
            
<span class="nc" id="L189">            boolean filterOutImageBoundaryBlobs = true;</span>
<span class="nc" id="L190">            boolean filterOutZeroPixels = false;</span>
<span class="nc" id="L191">            boolean doNotAddPoints = true;</span>
            
            // pre-make the blobs using non-default variables:
<span class="nc" id="L194">            img1Helper.getBlobs(type, useBinned, filterOutImageBoundaryBlobs, </span>
                filterOutZeroPixels);
            
            // pre-make the blobs using non-default variables:
<span class="nc" id="L198">            img2Helper.getBlobs(type, useBinned, filterOutImageBoundaryBlobs, </span>
                filterOutZeroPixels);           
        }
        
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (settings.doUse2ndDerivCorners()) {</span>
<span class="fc" id="L203">            img1Helper.extractSecondDerivativeCorners(type, useBinned);</span>
<span class="fc" id="L204">            img2Helper.extractSecondDerivativeCorners(type, useBinned);</span>
        } else {
<span class="fc" id="L206">            img1Helper.extractBlobPerimeterAsCornerRegions(type, useBinned);</span>
<span class="fc" id="L207">            img2Helper.extractBlobPerimeterAsCornerRegions(type, useBinned);</span>
        
<span class="fc" id="L209">            houghTransformLines1 = findLinesUsingHoughTransform(img1Helper, </span>
                type, useBinned);
<span class="fc" id="L211">            houghTransformLines2 = findLinesUsingHoughTransform(img2Helper, </span>
                type, useBinned);
<span class="fc" id="L213">            removeLineArtifactCorners(houghTransformLines1, img1Helper, type, </span>
                useBinned);
<span class="fc" id="L215">            removeLineArtifactCorners(houghTransformLines2, img2Helper, type, </span>
                useBinned);
        }
<span class="fc" id="L218">    }</span>

    protected boolean generateAndMatchCornerRegions(SegmentationType type, 
        boolean useBinned) throws IOException, NoSuchAlgorithmException {
        
<span class="fc" id="L223">        log.info(type.name() + &quot; binned=&quot; + useBinned + &quot; useSameSegmentation=&quot; </span>
            + useSameSegmentation);
        
<span class="fc" id="L226">        prepareCorners(type, useBinned);</span>
                        
<span class="fc" id="L228">        return match(type, useBinned);</span>
    }
    
    protected abstract boolean match(SegmentationType type, boolean useBinned);

    protected List&lt;HoughTransform.HoughTransformLines&gt; 
        findLinesUsingHoughTransform(BlobPerimeterCornerHelper blobCornerHelper, 
        SegmentationType segmentationType, boolean useBinnedImage) {
        
<span class="fc" id="L237">        List&lt;PairIntArray&gt; perimeterLists = blobCornerHelper.getBlobPerimeters(</span>
            segmentationType, useBinnedImage);
        
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        int imageWidth = useBinnedImage ? </span>
<span class="pc" id="L241">            blobCornerHelper.getGreyscaleImageBinned().getWidth() : </span>
<span class="pc" id="L242">            blobCornerHelper.getGreyscaleImage().getWidth();</span>
        
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        int imageHeight = useBinnedImage ? </span>
<span class="pc" id="L245">            blobCornerHelper.getGreyscaleImageBinned().getHeight() : </span>
<span class="pc" id="L246">            blobCornerHelper.getGreyscaleImage().getHeight();</span>
        
<span class="fc" id="L248">        int thetaTol = 1;</span>
<span class="fc" id="L249">        int radiusTol = 7;</span>
        
<span class="fc" id="L251">        HoughTransform ht = new HoughTransform();</span>
        
<span class="fc" id="L253">        List&lt;HoughTransform.HoughTransformLines&gt; lineList = </span>
            new ArrayList&lt;HoughTransform.HoughTransformLines&gt;();
        
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (int ii = 0; ii &lt; perimeterLists.size(); ++ii) {</span>
            
            // NOTE: in testable method for this, should allow ability to
            // pass in junctions and not delete corners that are in
            // junctions.
            // For these blob perimeters, there are not junctions.
<span class="fc" id="L262">            PairIntArray edge = perimeterLists.get(ii);</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (edge.getN() == 0) {</span>
<span class="nc" id="L264">                HoughTransformLines htl = ht.new HoughTransformLines(</span>
                    new HashMap&lt;PairInt, PairInt&gt;(), new ArrayList&lt;Set&lt;PairInt&gt;&gt;());
<span class="nc" id="L266">                lineList.add(htl);</span>
<span class="nc" id="L267">                continue;</span>
            }
            
<span class="fc" id="L270">            Map&lt;PairInt, Set&lt;PairInt&gt;&gt; outputPolarCoordsPixMap = </span>
<span class="fc" id="L271">                ht.calculateLineGivenEdge(edge, imageWidth, imageHeight);</span>
            
<span class="fc" id="L273">            List&lt;PairInt&gt; outSortedKeys = ht.sortByVotes(outputPolarCoordsPixMap);</span>
            
            // === find indiv lines within the edge ====
<span class="fc" id="L276">            HoughTransform.HoughTransformLines htl = </span>
<span class="fc" id="L277">                ht.createPixTRMapsFromSorted(outSortedKeys, </span>
                outputPolarCoordsPixMap, thetaTol, radiusTol);
            
<span class="fc" id="L280">            lineList.add(htl);</span>
        }
<span class="fc" id="L282">        return lineList;</span>
    }

    protected void removeLineArtifactCorners(List&lt;HoughTransformLines&gt; 
        houghTransformLines, BlobPerimeterCornerHelper blobCornerHelper, 
        SegmentationType segmentationType, boolean useBinnedImage) {
        
<span class="fc" id="L289">        List&lt;PairIntArray&gt; perimeterLists = blobCornerHelper.getBlobPerimeters(</span>
            segmentationType, useBinnedImage);
        
<span class="fc" id="L292">        List&lt;List&lt;CornerRegion&gt;&gt; cornerRegionLists = </span>
<span class="fc" id="L293">            blobCornerHelper.getPerimeterCorners(segmentationType, useBinnedImage);</span>
        
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        int imageWidth = useBinnedImage ? </span>
<span class="pc" id="L296">            blobCornerHelper.getGreyscaleImageBinned().getWidth() : </span>
<span class="pc" id="L297">            blobCornerHelper.getGreyscaleImage().getWidth();</span>
        
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        int imageHeight = useBinnedImage ? </span>
<span class="pc" id="L300">            blobCornerHelper.getGreyscaleImageBinned().getHeight() : </span>
<span class="pc" id="L301">            blobCornerHelper.getGreyscaleImage().getHeight();</span>
        
<span class="fc" id="L303">        int thetaTol = 1;</span>
<span class="fc" id="L304">        int radiusTol = 7;</span>
        
        //use hough transform for lines to remove corners from line artifacts
<span class="fc" id="L307">        CornerCorrector.removeCornersFromLineArtifacts(houghTransformLines, </span>
            perimeterLists, cornerRegionLists, thetaTol, radiusTol, imageWidth, 
            imageHeight);
<span class="fc" id="L310">    }</span>

    protected List&lt;FeatureComparisonStat&gt; reviseStatsForFullImages(
        GreyscaleImage gsImg1, GreyscaleImage gsImg2, 
        List&lt;FeatureComparisonStat&gt; stats, int prevBinFactor1, 
        int prevBinFactor2, RotatedOffsets rotatedOffsets) {
        
<span class="fc" id="L317">        log.info(&quot;refine stats for full image reference frames&quot;);</span>
        
<span class="fc" id="L319">        List&lt;FeatureComparisonStat&gt; revised = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="fc" id="L321">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
        
<span class="fc" id="L323">        IntensityFeatures f1 = new IntensityFeatures(5, </span>
<span class="fc" id="L324">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L325">        f1.calculateGradientWithGreyscale(gsImg1);</span>
        
<span class="fc" id="L327">        IntensityFeatures f2 = new IntensityFeatures(5, </span>
<span class="fc" id="L328">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
<span class="fc" id="L329">        f2.calculateGradientWithGreyscale(gsImg2);</span>
        
<span class="fc" id="L331">        int dither = 2;</span>
        
<span class="fc bfc" id="L333" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
            
<span class="fc" id="L335">            FeatureComparisonStat stat = stats.get(i);</span>
            
<span class="fc" id="L337">            int x1 = stat.getImg1Point().getX() * prevBinFactor1;</span>
<span class="fc" id="L338">            int y1 = stat.getImg1Point().getY() * prevBinFactor1;</span>
<span class="fc" id="L339">            int x2 = stat.getImg2Point().getX() * prevBinFactor2;</span>
<span class="fc" id="L340">            int y2 = stat.getImg2Point().getY() * prevBinFactor2;</span>
            
            // have to discard the best angles found in stat and derive new
            // for these higher resolution images
<span class="fc" id="L344">            FeatureComparisonStat compStat = </span>
<span class="fc" id="L345">                featureMatcher.ditherAndRotateForBestLocation2(f1, </span>
                    f2, x1, y1, x2, y2, dither, gsImg1, gsImg2);
            
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (compStat == null || (compStat.getSumIntensitySqDiff() &gt; </span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                compStat.getImg2PointIntensityErr())) {</span>
<span class="nc" id="L350">                continue;</span>
            }
            
<span class="fc" id="L353">            revised.add(compStat);</span>
        }
        
<span class="fc" id="L356">        return revised;</span>
    }

    public void copyToInstanceVars(List&lt;FeatureComparisonStat&gt; stats) {
        
<span class="fc" id="L361">        this.solutionStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L362">        this.solutionMatched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L363">        this.solutionMatched2 = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="fc" id="L366">            solutionStats.add(stat.copy());</span>
<span class="fc" id="L367">            solutionMatched1.add(stat.getImg1Point().copy());</span>
<span class="fc" id="L368">            solutionMatched2.add(stat.getImg2Point().copy());</span>
<span class="fc" id="L369">        }</span>
<span class="fc" id="L370">    }</span>
    
    /**
     * get a copy of the solution's feature stats.
     * @return 
     */
    public List&lt;FeatureComparisonStat&gt; getSolutionStats() {
<span class="fc" id="L377">        return solutionStats;</span>
    }

    /**
     * get the matched points from image 1
     * @return the solutionMatched1
     */
    public List&lt;PairInt&gt; getSolutionMatched1() {
<span class="fc" id="L385">        return solutionMatched1;</span>
    }

    /**
     * get the matched points from image 2
     * @return the solutionMatched2
     */
    public List&lt;PairInt&gt; getSolutionMatched2() {
<span class="fc" id="L393">        return solutionMatched2;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BlobContoursScaleFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">BlobContoursScaleFinder.java</span></div><h1>BlobContoursScaleFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.NearestPoints;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import thirdparty.HungarianAlgorithm;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L23" title="1 of 2 branches missed.">public class BlobContoursScaleFinder extends AbstractBlobScaleFinder {</span>

    public MatchingSolution solveForScale(
        BlobContourHelper img1Helper, IntensityFeatures features1,
        SegmentationType type1, boolean useBinned1,
        BlobContourHelper img2Helper, IntensityFeatures features2,
        SegmentationType type2, boolean useBinned2) {

<span class="fc" id="L31">        GreyscaleImage img1 = img1Helper.imgHelper.getGreyscaleImage(useBinned1);</span>
            
<span class="fc" id="L33">        GreyscaleImage img2 = img2Helper.imgHelper.getGreyscaleImage(useBinned2);</span>
        
<span class="fc" id="L35">        int binFactor1 = img1Helper.imgHelper.getBinFactor(useBinned1);</span>
<span class="fc" id="L36">        int binFactor2 = img2Helper.imgHelper.getBinFactor(useBinned2);</span>
        
<span class="fc" id="L38">        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1List = </span>
<span class="fc" id="L39">            img1Helper.getPerimeterContours(type1, useBinned1);</span>
        
<span class="fc" id="L41">        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours2List = </span>
<span class="fc" id="L42">            img2Helper.getPerimeterContours(type2, useBinned2);</span>
        
<span class="fc" id="L44">        List&lt;Set&lt;PairInt&gt;&gt; blobs1 = img1Helper.imgHelper.getBlobs(type1, useBinned1);</span>
<span class="fc" id="L45">        List&lt;Set&lt;PairInt&gt;&gt; blobs2 = img2Helper.imgHelper.getBlobs(type2, useBinned2);</span>
<span class="fc" id="L46">        List&lt;PairIntArray&gt; perimeters1 = img1Helper.imgHelper.getBlobPerimeters(type1, useBinned1);</span>
<span class="fc" id="L47">        List&lt;PairIntArray&gt; perimeters2 = img2Helper.imgHelper.getBlobPerimeters(type2, useBinned2);</span>

<span class="fc" id="L49">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L51">        Map&lt;PairInt, CSSContourMatcherWrapper&gt; singleSolnMap =</span>
            new HashMap&lt;PairInt,  CSSContourMatcherWrapper&gt;();

        /*
        Note that the matching contours are improved and filtered by using 
        feature descriptors.
        
        Finding the best match if any for each index1.
        If a subsequent match to the that index1's index2 is present, it will
        only be considered if the cost is less than the previous.
        It's a greedy best approach.
        After all of the index1 solutions are gathered, the best is found
        by adjusting the costs by the largest sigma from the first peak contours 
        from edges1 (i.e. applying the penalty from the paper to smaller peak
        sigma's costs).
        The best agreeing solutions are kept.
        
        If instead wanted a bipartite matching of best costs, would want to
        keep the top 2 or so of each index1.
        Would need to be careful to not include large peak contour false matches.
        All costs in the top would need to be adjusted by the penalty mentioned
        above.
        Then the best among more than one would be defined by cost.  
        Then more than one solutions points would be kept if similarity
        in difference of theta and scale were within a limit.
        */
       
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
<span class="fc" id="L79">            index1BestMap = new HashMap&lt;Integer, </span>
            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt;();

<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int idx1 = 0; idx1 &lt; blobs1.size(); ++idx1) {</span>

<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            if (contours1List.get(idx1).isEmpty()) {</span>
<span class="nc" id="L85">                continue;</span>
            }

<span class="fc" id="L88">            Integer index1 = Integer.valueOf(idx1);</span>

<span class="fc" id="L90">            PairIntArray curve1 = perimeters1.get(idx1);</span>

<span class="fc" id="L92">            Set&lt;PairInt&gt; blob1 = blobs1.get(idx1);</span>

<span class="fc" id="L94">            double[] xyCen1 = curveHelper.calculateXYCentroids(blob1);</span>

            // keeping the top '2' for each index1.  comparison is by cost.
            // choosing more than one because later bipartite matching attempts
            // to match best for all index1 matchings
<span class="fc" id="L99">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; bestStats </span>
                = new FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;(2, 
                IntensityFeatureComparisonStats.class);

<span class="fc bfc" id="L103" title="All 2 branches covered.">            for (int idx2 = 0; idx2 &lt; blobs2.size(); ++idx2) {</span>

<span class="fc bfc" id="L105" title="All 2 branches covered.">                if (contours2List.get(idx2).isEmpty()) {</span>
<span class="fc" id="L106">                    continue;</span>
                }

<span class="fc" id="L109">                Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L111">                PairIntArray curve2 = perimeters2.get(idx2);</span>

<span class="fc" id="L113">                Set&lt;PairInt&gt; blob2 = blobs2.get(idx2);</span>
                
<span class="fc" id="L115">                CurvatureScaleSpaceInflectionSingleEdgeMapper mapper =</span>
                    new CurvatureScaleSpaceInflectionSingleEdgeMapper(
                    0, 0, 0, 0);

<span class="fc" id="L119">                TransformationParameters params = mapper.matchContours(</span>
<span class="fc" id="L120">                    contours1List.get(idx1), contours2List.get(idx2));</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">                if ((params == null) ||</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                    (mapper.getMatcher().getSolutionMatchedContours1().size() &lt; 2)) {</span>

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                    if ((mapper.getMatcher() != null) &amp;&amp;</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">                        (mapper.getMatcher().getSolutionMatchedContours1().size() == 1)) {</span>

<span class="fc" id="L128">                        singleSolnMap.put(new PairInt(idx1, idx2), mapper.getMatcher());</span>
                    }

                    continue;
                }

                // edit points using feature descriptors and remove outliers:
<span class="fc" id="L135">                List&lt;FeatureComparisonStat&gt; compStats =</span>
<span class="fc" id="L136">                    filterContourPointsByFeatures(img1, img2, index1, index2,</span>
                    blob1, blob2, curve1, curve2, features1, features2,
<span class="fc" id="L138">                    mapper.getMatcher());</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">                if (compStats.size() &lt; 2) {</span>
<span class="fc" id="L141">                    continue;</span>
                }

                //TODO: consider moving this type of statistic into the
                //cost during contour matching.  wanting to avoid accepting
                //solutions which are a small number of spurious matches due
                //to one contour having many points to match to.
<span class="fc" id="L148">                int nc1 = contours1List.get(index1.intValue()).size();</span>
<span class="fc" id="L149">                int nc2 = contours2List.get(index2.intValue()).size();</span>
<span class="fc" id="L150">                float frac = (float)nc1/(float)nc2;</span>
<span class="fc bfc" id="L151" title="All 8 branches covered.">                boolean lgDiffN = ((nc1 &gt; nc2) &amp;&amp; frac &gt; 2)</span>
                    || ((nc1 &lt; nc2) &amp;&amp; frac &lt; 0.5);
                
                // also, discard if fraction of matched/maxmatchable is too low
<span class="fc bfc" id="L155" title="All 2 branches covered.">                if (!lgDiffN) {</span>
<span class="fc" id="L156">                    float nmm = Math.min(nc1, nc2);</span>
<span class="fc" id="L157">                    float nm = compStats.size();</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                    if ((nm/nmm) &lt; 0.5) {</span>
<span class="fc" id="L159">                        lgDiffN = true;</span>
                    }
                }
                
<span class="fc" id="L163">                log.info(String.format(</span>
                    &quot;   nc1=%d nc2=%d (frac=%.2f) nMCs=%d&quot;,
<span class="fc" id="L165">                    nc1, nc2, frac, </span>
<span class="fc" id="L166">                    mapper.getMatcher().getSolutionMatchedContours1().size()));</span>
                
<span class="fc bfc" id="L168" title="All 2 branches covered.">                if (lgDiffN) {                    </span>
<span class="fc" id="L169">                    log.info(</span>
                        &quot;discarding a good match because frac of maxMatchable is low.&quot;);
<span class="fc" id="L171">                    continue;</span>
                }
                
                //double combinedStat = calculateCombinedIntensityStat(compStats);

<span class="fc" id="L176">                IntensityFeatureComparisonStats stats = new </span>
<span class="fc" id="L177">                    IntensityFeatureComparisonStats(index1.intValue(), </span>
<span class="fc" id="L178">                    index2.intValue(), mapper.getMatcher().getSolvedCost(), </span>
<span class="fc" id="L179">                    mapper.getMatcher().getSolvedScale());</span>
<span class="fc" id="L180">                stats.addAll(compStats);</span>
                
                // bestStats keeps the top '2' smallest cost solutions added to it
                // (though combinedStats are used when nMatched is 2 or less)
<span class="fc" id="L184">                boolean added = bestStats.add(stats);</span>
                
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (added) {</span>
<span class="fc" id="L187">                    log.info(&quot;  added to best for [&quot; + index1.toString() + &quot;] [&quot;</span>
<span class="fc" id="L188">                        + index2.toString() + &quot;] cost=&quot; + stats.getCost()</span>
<span class="fc" id="L189">                        + &quot; with n=&quot; + stats.getComparisonStats().size());</span>
                }
            }
           
<span class="fc bfc" id="L193" title="All 2 branches covered.">            if (bestStats.getNumberOfItems() == 0) {</span>
<span class="fc" id="L194">                continue;</span>
            }

<span class="fc" id="L197">            index1BestMap.put(index1, bestStats);</span>
        }
        
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (index1BestMap.isEmpty()) {</span>
<span class="nc" id="L201">            return null;</span>
        }

<span class="fc" id="L204">        MatchingSolution soln = checkForNonDegenerateSolution(index1BestMap, binFactor1, </span>
            binFactor2);
       
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (soln != null) {</span>
<span class="nc" id="L208">            return soln;</span>
        }
     
<span class="fc" id="L211">        int n1 = perimeters1.size();</span>
<span class="fc" id="L212">        int n2 = perimeters2.size();</span>

<span class="fc" id="L214">        float[][] cost = new float[n1][n2];</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L216">            cost[i] = new float[n2];</span>
<span class="fc" id="L217">            Arrays.fill(cost[i], Float.MAX_VALUE);</span>
        }
     
<span class="fc" id="L220">        int nMaxMatchable = countMaxMatchable2(contours1List, contours2List);</span>

<span class="fc" id="L222">        Set&lt;PairInt&gt; present = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L223">        List&lt;IntensityFeatureComparisonStats&gt; ifsList = new ArrayList&lt;IntensityFeatureComparisonStats&gt;();</span>
<span class="fc" id="L224">        List&lt;TransformationParameters&gt; paramsList = new ArrayList&lt;TransformationParameters&gt;();</span>

<span class="fc" id="L226">        Map&lt;PairInt, Float&gt; indexScore = new HashMap&lt;PairInt, Float&gt;();</span>

        /* for the cost, need to consider the evaluation of the parameters,
            and the SSD of the point.
            The score for the evaluation is nMaxMatchable/nEval and its range is
            1 to nMaxMatchable.
            The SSD is filtered above to a max of 1500.  Will add '1' to it
            to avoid a zero for a perfect match, then the score for SSD ranges
            from 1 to 1500.
            Can make the cost the multiplication of the two scores as long as
            the value (nMaxMatchable/1500) stays below ((1&lt;&lt;31)-1).
            
            have normalized both scores by their maximum values so that their
            contributions to the cost are equal.
            */
        
<span class="fc" id="L242">        int tolTransXY = 10;</span>

        for (Entry&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; entry 
<span class="fc bfc" id="L245" title="All 2 branches covered.">            : index1BestMap.entrySet()) {</span>
            
<span class="fc" id="L247">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; vector = entry.getValue();</span>
<span class="fc" id="L248">            IntensityFeatureComparisonStats[] ind1To2Pairs = vector.getArray();            </span>
            
<span class="fc bfc" id="L250" title="All 2 branches covered.">            for (int i = 0; i &lt; vector.getNumberOfItems(); ++i) {</span>
                
<span class="fc" id="L252">                IntensityFeatureComparisonStats ifcs = ind1To2Pairs[i];   </span>
                                
<span class="fc" id="L254">                TransformationParameters params = MiscStats.calculateTransformation(</span>
<span class="fc" id="L255">                    binFactor1, binFactor2, ifcs.getComparisonStats(),</span>
                    new float[4]);
<span class="fc bfc" id="L257" title="All 2 branches covered.">                if (params == null) {</span>
<span class="fc" id="L258">                    continue;</span>
                }
<span class="fc" id="L260">                int idx1 = ifcs.getIndex1();</span>
<span class="fc" id="L261">                int idx2 = ifcs.getIndex2();</span>
                
<span class="fc" id="L263">                PairInt p = new PairInt(idx1, idx2);</span>
                
<span class="fc" id="L265">                int nEval = evaluate2(params, contours1List, contours2List, tolTransXY);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (nEval == 0) {</span>
<span class="nc" id="L267">                    continue;</span>
                }
<span class="fc" id="L269">                float score1 = (float)nMaxMatchable/(float)nEval;</span>
<span class="fc" id="L270">                float score2 = (float)ifcs.getCost() + 1;</span>
<span class="fc" id="L271">                float score = score1 * score2;</span>
<span class="fc" id="L272">                float normalizedScore = (score2/(float)nEval)/1500.f;</span>
<span class="fc" id="L273">                cost[idx1][idx2] = normalizedScore;</span>
<span class="fc" id="L274">                indexScore.put(p, Float.valueOf(normalizedScore));</span>
                
<span class="fc" id="L276">                present.add(p);                </span>
<span class="fc" id="L277">                ifsList.add(ifcs);</span>
<span class="fc" id="L278">                paramsList.add(params);                </span>
            }
<span class="fc" id="L280">        }</span>

<span class="fc" id="L282">        boolean transposed = false;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (n1 &gt; n2) {</span>
<span class="nc" id="L284">            cost = MatrixUtil.transpose(cost);</span>
<span class="nc" id="L285">            transposed = true;</span>
        }

<span class="fc" id="L288">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="fc" id="L289">        int[][] match = b.computeAssignments(cost);</span>
        
<span class="fc" id="L291">        Set&lt;PairInt&gt; matched = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="fc" id="L293">            int idx1 = match[i][0];</span>
<span class="fc" id="L294">            int idx2 = match[i][1];</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="fc" id="L296">                continue;</span>
            }
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L299">                int swap = idx1;</span>
<span class="nc" id="L300">                idx1 = idx2;</span>
<span class="nc" id="L301">                idx2 = swap;</span>
            }
<span class="fc" id="L303">            PairInt p = new PairInt(idx1, idx2);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (present.contains(p)) {</span>
<span class="fc" id="L305">                 matched.add(p);</span>
            }
        }
        
<span class="fc" id="L309">        int n = ifsList.size();</span>
<span class="fc" id="L310">        int i = 0;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        while (i &lt; n) {</span>
<span class="fc" id="L312">            IntensityFeatureComparisonStats ifcs = ifsList.get(i);</span>
<span class="fc" id="L313">            PairInt p = new PairInt(ifcs.getIndex1(), ifcs.getIndex2());</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (matched.contains(p)) {</span>
<span class="fc" id="L315">                ++i;</span>
<span class="fc" id="L316">                continue;</span>
            }
<span class="fc" id="L318">            ifsList.remove(i);</span>
<span class="fc" id="L319">            paramsList.remove(i);</span>
<span class="fc" id="L320">            n = ifsList.size();</span>
<span class="fc" id="L321">        }</span>
        
        // to correct for wrap around from 360 to 0, repeating same calc with shifted values
        
<span class="fc" id="L325">        int[] indexesToKeep = MiscStats.filterForRotationUsingHist(paramsList, 0);</span>
        
<span class="fc" id="L327">        int[] indexesToKeepShifted = MiscStats.filterForRotationUsingHist(paramsList, 30);</span>
        
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (indexesToKeepShifted.length &gt; indexesToKeep.length) {</span>
<span class="fc" id="L330">            indexesToKeep = indexesToKeepShifted;</span>
        }
        
<span class="fc" id="L333">        filter(ifsList, paramsList, indexesToKeep);</span>
        
<span class="fc" id="L335">        indexesToKeep = MiscStats.filterForScaleUsingHist(paramsList);</span>
        
<span class="fc" id="L337">        filter(ifsList, paramsList, indexesToKeep);</span>
        
        //indexesToKeep = MiscStats.filterForTranslation(paramsList);
        
<span class="fc" id="L341">        indexesToKeep = MiscStats.filterForTranslationXUsingHist(paramsList);</span>
        
<span class="fc" id="L343">        filter(ifsList, paramsList, indexesToKeep);</span>
        
<span class="fc" id="L345">        indexesToKeep = MiscStats.filterForTranslationYUsingHist(paramsList);</span>
        
<span class="fc" id="L347">        filter(ifsList, paramsList, indexesToKeep);</span>
        
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (paramsList.size() == 0) {</span>
<span class="nc" id="L350">            return null;</span>
        }
        
<span class="fc" id="L353">        List&lt;FeatureComparisonStat&gt; combined = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (i = 0; i &lt; ifsList.size(); ++i) {</span>
<span class="fc" id="L355">            IntensityFeatureComparisonStats ifs = ifsList.get(i);</span>
<span class="fc" id="L356">            combined.addAll(ifs.getComparisonStats());</span>
        }
        
<span class="fc" id="L359">        TransformationParameters combinedParams = MiscStats.calculateTransformation(</span>
            binFactor1, binFactor2, combined, new float[4]);
        
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (combinedParams == null) {</span>
<span class="nc" id="L363">            return null;</span>
        }
        
        // pre-check for delta tx, deltaty essentially
<span class="fc" id="L367">        boolean check = true;</span>
<span class="pc bpc" id="L368" title="1 of 4 branches missed.">        while (check &amp;&amp; (paramsList.size() &gt; 1)) {</span>
            
<span class="fc" id="L370">            boolean small = MiscStats.standardDeviationsAreSmall(combinedParams);</span>
            
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            if (small) {</span>
<span class="nc" id="L373">                check = false;</span>
            } else {
                // --- either keep only smallest SSD or remove highest SSD ---
<span class="fc" id="L376">                double maxCost = Double.MIN_VALUE;</span>
<span class="fc" id="L377">                int maxCostIdx = -1;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                for (int ii = 0; ii &lt; ifsList.size(); ++ii) {</span>
<span class="fc" id="L379">                    IntensityFeatureComparisonStats ifs = ifsList.get(ii);</span>
<span class="fc" id="L380">                    PairInt p = new PairInt(ifs.getIndex1(), ifs.getIndex2());</span>
<span class="fc" id="L381">                    float score1 = indexScore.get(p).floatValue();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                    if (score1 &gt; maxCost) {</span>
<span class="fc" id="L383">                        maxCost = score1;</span>
<span class="fc" id="L384">                        maxCostIdx = ii;</span>
                    }
                }
<span class="fc" id="L387">                ifsList.remove(maxCostIdx);</span>
<span class="fc" id="L388">                paramsList.remove(maxCostIdx);</span>
<span class="fc" id="L389">                combined.clear();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                for (i = 0; i &lt; ifsList.size(); ++i) {</span>
<span class="fc" id="L391">                    IntensityFeatureComparisonStats ifs = ifsList.get(i);</span>
<span class="fc" id="L392">                    combined.addAll(ifs.getComparisonStats());</span>
                }
<span class="fc" id="L394">                combinedParams = MiscStats.calculateTransformation(</span>
                    binFactor1, binFactor2, combined, new float[4]);
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                if (combinedParams == null) {</span>
<span class="nc" id="L397">                    return null;</span>
                }
            }
<span class="fc" id="L400">        }</span>
        
<span class="fc" id="L402">        soln = new MatchingSolution(combinedParams, combined);</span>
            
<span class="fc" id="L404">        return soln;      </span>
    }

    protected List&lt;FeatureComparisonStat&gt; filterContourPointsByFeatures(
        GreyscaleImage img1, GreyscaleImage img2,
        Integer index1, Integer index2,
        Set&lt;PairInt&gt; blob1, Set&lt;PairInt&gt; blob2,
        PairIntArray curve1, PairIntArray curve2,
        IntensityFeatures features1, IntensityFeatures features2,
        CSSContourMatcherWrapper matcher) {

<span class="fc" id="L415">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

<span class="fc" id="L417">        int dither = 1;</span>

<span class="fc" id="L419">        List&lt;FeatureComparisonStat&gt; compStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L421">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L423">        double[] xyCen1 = curveHelper.calculateXYCentroids(curve1);</span>
<span class="fc" id="L424">        double[] xyCen2 = curveHelper.calculateXYCentroids(curve2);</span>

<span class="fc" id="L426">        double statSqSum = 0;</span>

<span class="fc" id="L428">        int nMaxMatchable = matcher.getNMaxMatchable();</span>
<span class="fc" id="L429">        int nMaxStats = 0;</span>
<span class="fc" id="L430">        int nStats = 0;</span>

<span class="fc" id="L432">        double cost = matcher.getSolvedCost();</span>

<span class="fc" id="L434">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L435">        sb.append(String.format(</span>
            &quot;[%d](%d,%d) [%d](%d,%d) cost=%.1f scale=%.2f  nMatched=%d &quot;,
<span class="fc" id="L437">            index1.intValue(), (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="fc" id="L438">            index2.intValue(), (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1]),</span>
<span class="fc" id="L439">            (float)cost, (float)matcher.getSolvedScale(),</span>
<span class="fc" id="L440">            matcher.getSolutionMatchedContours1().size()));</span>

<span class="fc" id="L442">        FeatureComparisonStat bestCompStat = null;</span>

//TODO: refactor this to be able to reuse blob perimeter regions
//  from the invoker, the blob scale finer wrapper
        
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (int j = 0; j &lt; matcher.getSolutionMatchedContours1().size(); ++j) {</span>

<span class="fc" id="L449">            CurvatureScaleSpaceContour c1 = matcher.getSolutionMatchedContours1().get(j);</span>
<span class="fc" id="L450">            CurvatureScaleSpaceContour c2 = matcher.getSolutionMatchedContours2().get(j);</span>

            // the sizes of the peak details will be the same
<span class="fc" id="L453">            CurvatureScaleSpaceImagePoint[] details1 = c1.getPeakDetails();</span>
<span class="fc" id="L454">            CurvatureScaleSpaceImagePoint[] details2 = c2.getPeakDetails();</span>

<span class="fc" id="L456">            nMaxStats += details1.length;</span>

<span class="fc bfc" id="L458" title="All 2 branches covered.">            for (int jj = 0; jj &lt; details1.length; ++jj) {</span>

<span class="fc" id="L460">                BlobPerimeterRegion region1 = </span>
<span class="fc" id="L461">                    BlobsAndContours.extractBlobPerimeterRegion(</span>
<span class="fc" id="L462">                    index1.intValue(), details1[jj], curve1, blob1</span>
                );
<span class="fc" id="L464">                region1.setIndexWithinCurve(details1[jj].getCoordIdx());</span>

<span class="fc" id="L466">                BlobPerimeterRegion region2 = </span>
<span class="fc" id="L467">                    BlobsAndContours.extractBlobPerimeterRegion(</span>
<span class="fc" id="L468">                    index2.intValue(), details2[jj], curve2, blob2</span>
                );
<span class="fc" id="L470">                region1.setIndexWithinCurve(details2[jj].getCoordIdx());</span>
   
<span class="fc" id="L472">                FeatureComparisonStat compStat = null;</span>
                
                try {
                    
<span class="fc" id="L476">                    compStat =</span>
<span class="fc" id="L477">                        featureMatcher.ditherAndRotateForBestLocation(</span>
                        features1, features2, region1, region2, dither, img1, img2);

<span class="fc" id="L480">sb.append(</span>
<span class="fc" id="L481">    String.format(&quot; (%d,%d) theta1=%d   (%d,%d) theta2=%d&quot;,</span>
<span class="fc" id="L482">    region1.getX()[1], region1.getY()[1],</span>
<span class="fc" id="L483">    Math.round(region1.getRelativeOrientationInDegrees()),</span>
<span class="fc" id="L484">    region2.getX()[1], region2.getY()[1],</span>
<span class="fc" id="L485">    Math.round(region2.getRelativeOrientationInDegrees())));</span>

<span class="nc" id="L487">                } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L488">                }</span>
                
<span class="fc bfc" id="L490" title="All 2 branches covered.">                if (compStat != null) {</span>
<span class="fc" id="L491">                    float sumIntSqDiff = compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L492">                    float intErrDiff = compStat.getImg2PointIntensityErr();</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">                    if (sumIntSqDiff &lt; intErrDiff) {</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                        if (bestCompStat == null) {</span>
<span class="fc" id="L495">                            bestCompStat = compStat;</span>
                        } else {
<span class="fc bfc" id="L497" title="All 2 branches covered.">                            if (sumIntSqDiff &lt; bestCompStat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L498">                                bestCompStat = compStat;</span>
                            }
                        }
<span class="fc" id="L501">                        statSqSum += (sumIntSqDiff*sumIntSqDiff);</span>
<span class="fc" id="L502">                        sb.append(String.format(&quot;  %.1f(%.1f), &quot;, sumIntSqDiff, intErrDiff));</span>
<span class="fc" id="L503">                        compStats.add(compStat);</span>
<span class="fc" id="L504">                        nStats++;</span>
                    }
                }
            } // end details
        }// end matching contours for index1, index2

<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (bestCompStat == null) {</span>
<span class="fc" id="L511">            return compStats;</span>
        }

<span class="fc" id="L514">        log.info(sb.toString());</span>

        // if bestCompStat's difference in orientation is different than the
        // others', re-do the others to see if have an improved calculation.
        // the &quot;re-do&quot; should try a dither of 1 or 2
<span class="fc" id="L519">        float bestDiffTheta = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L520">            bestCompStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L521">            bestCompStat.getImg1PointRotInDegrees());</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (bestDiffTheta &lt; 0) {</span>
<span class="fc" id="L523">            bestDiffTheta += 360;</span>
        }

<span class="fc" id="L526">        boolean redoStats = false;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">        for (FeatureComparisonStat cStat : compStats) {</span>
<span class="fc" id="L528">            float diffTheta = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L529">                cStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L530">                cStat.getImg1PointRotInDegrees());</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (diffTheta &lt; 0) {</span>
<span class="fc" id="L532">                diffTheta += 360;</span>
            }
<span class="fc bfc" id="L534" title="All 2 branches covered.">            if (Math.abs(bestDiffTheta - diffTheta) &gt; 25) {</span>
<span class="fc" id="L535">                redoStats = true;</span>
<span class="fc" id="L536">                break;</span>
            }
<span class="fc" id="L538">        }</span>

        //TODO: may need to consider re-doing if compStats.size() is &lt;&lt; nMaxStats too
<span class="fc" id="L541">redoStats = true;</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (redoStats) {</span>

<span class="fc" id="L544">            compStats = redoFilterContourPointsByFeatures(img1, img2, index1,</span>
                index2, blob1, blob2, curve1, curve2,
<span class="fc" id="L546">                bestCompStat.getImg1PointRotInDegrees(),</span>
<span class="fc" id="L547">                bestCompStat.getImg2PointRotInDegrees(), matcher);</span>
            
<span class="fc" id="L549">            log.fine(&quot;redone: &quot; + printToString(compStats) + &quot; combinedStat=&quot;</span>
<span class="fc" id="L550">                + calculateCombinedIntensityStat(compStats));</span>
       
<span class="fc" id="L552">            FeatureMatcher.removeDiscrepantThetaDiff(compStats);</span>

<span class="fc" id="L554">            log.fine(&quot;theta diff filtered: &quot; + printToString(compStats) + &quot; combinedStat=&quot;</span>
<span class="fc" id="L555">                + calculateCombinedIntensityStat(compStats));</span>
            
<span class="fc" id="L557">            FeatureMatcher.removeIntensityOutliers(compStats);</span>
        }

<span class="fc" id="L560">        return compStats;</span>
    }

    List&lt;FeatureComparisonStat&gt; redoFilterContourPointsByFeatures(
        GreyscaleImage img1, GreyscaleImage img2,
        Integer index1, Integer index2,
        Set&lt;PairInt&gt; blob1, Set&lt;PairInt&gt; blob2,
        PairIntArray curve1, PairIntArray curve2,
        float theta1, float theta2,
        CSSContourMatcherWrapper matcher) {

<span class="fc" id="L571">        log.info(&quot;redoFilterContourPointsByFeatures&quot;);</span>
        
<span class="fc" id="L573">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

        // for the redo, because the orientations are set rather than found,
        // not going to re-use the invoker's instance of Features
<span class="fc" id="L577">        IntensityFeatures features1 = new IntensityFeatures(img1, 5, true);</span>
<span class="fc" id="L578">        IntensityFeatures features2 = new IntensityFeatures(img2, 5, true);</span>

<span class="fc" id="L580">        int dither = 2;</span>

<span class="fc" id="L582">        List&lt;FeatureComparisonStat&gt; compStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L584">        int nMaxMatchable = matcher.getNMaxMatchable();</span>
<span class="fc" id="L585">        int nMaxStats = 0;</span>

<span class="fc" id="L587">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L588">        sb.append(String.format(&quot;[%d] [%d] &quot;, index1.intValue(), index2.intValue()));</span>

<span class="fc" id="L590">        float theta1Radians = (float)(theta1 * Math.PI/180.);</span>
<span class="fc" id="L591">        float theta2Radians = (float)(theta2 * Math.PI/180.);</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">        for (int j = 0; j &lt; matcher.getSolutionMatchedContours1().size(); ++j) {</span>

<span class="fc" id="L595">            CurvatureScaleSpaceContour c1 = matcher.getSolutionMatchedContours1().get(j);</span>
<span class="fc" id="L596">            CurvatureScaleSpaceContour c2 = matcher.getSolutionMatchedContours2().get(j);</span>

            // the sizes of the peak details will be the same
<span class="fc" id="L599">            CurvatureScaleSpaceImagePoint[] details1 = c1.getPeakDetails();</span>
<span class="fc" id="L600">            CurvatureScaleSpaceImagePoint[] details2 = c2.getPeakDetails();</span>

<span class="fc" id="L602">            nMaxStats += details1.length;</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">            for (int jj = 0; jj &lt; details1.length; ++jj) {</span>

<span class="fc" id="L606">                BlobPerimeterRegion region1 = </span>
<span class="fc" id="L607">                    BlobsAndContours.extractBlobPerimeterRegion(</span>
<span class="fc" id="L608">                    index1.intValue(), details1[jj], curve1, blob1</span>
                );
<span class="fc" id="L610">                region1.setIndexWithinCurve(details1[jj].getCoordIdx());</span>
<span class="fc" id="L611">                region1.overrideRelativeOrientation(theta1Radians);</span>

<span class="fc" id="L613">                BlobPerimeterRegion region2 = </span>
<span class="fc" id="L614">                    BlobsAndContours.extractBlobPerimeterRegion(</span>
<span class="fc" id="L615">                    index2.intValue(), details2[jj], curve2, blob2</span>
                );
<span class="fc" id="L617">                region2.setIndexWithinCurve(details2[jj].getCoordIdx());</span>
<span class="fc" id="L618">                region2.overrideRelativeOrientation(theta2Radians);</span>

<span class="fc" id="L620">                FeatureComparisonStat compStat = null;</span>
                
                try {
<span class="fc" id="L623">                    compStat =</span>
<span class="fc" id="L624">                        featureMatcher.ditherAndRotateForBestLocation(</span>
                        features1, features2, region1, region2, dither);
<span class="nc" id="L626">                } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L627">                }</span>
                
<span class="fc bfc" id="L629" title="All 2 branches covered.">                if (compStat != null) {</span>

<span class="fc" id="L631">                    float sumIntSqDiff = compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L632">                    float intErrDiff = compStat.getImg2PointIntensityErr();</span>

<span class="pc bpc" id="L634" title="1 of 2 branches missed.">                    if (sumIntSqDiff &lt; intErrDiff) {</span>
<span class="fc" id="L635">                        compStats.add(compStat);</span>
                    }

                }
            } // end details
        }// end matching contours for index1, index2

<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L643">            sb.append(printToString(compStats)).append(&quot; nMaxStats=&quot;).append(nMaxStats);</span>

<span class="nc" id="L645">            log.info(sb.toString());</span>
        }
        
        //removeOutliers(compStats);

<span class="fc" id="L650">        return compStats;</span>
    }

    private MatchingSolution checkForNonDegenerateSolution(
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
            index1BestMap, int binFactor1, int binFactor2) {
        
<span class="fc" id="L657">        List&lt;IntensityFeatureComparisonStats&gt; ifcsList = new ArrayList&lt;IntensityFeatureComparisonStats&gt;();</span>
        
<span class="fc" id="L659">        Set&lt;Integer&gt; indexes2 = new HashSet&lt;Integer&gt;();</span>
        
        for (Entry&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; entry :
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            index1BestMap.entrySet()) {</span>
            
<span class="fc" id="L664">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; vector = entry.getValue();</span>
            
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (vector.getArray().length &gt; 1) {</span>
<span class="fc" id="L667">                return null;</span>
            }
<span class="nc bnc" id="L669" title="All 4 branches missed.">            assert(vector.getArray().length == 1);</span>
            
<span class="nc" id="L671">            IntensityFeatureComparisonStats ifcs = vector.getArray()[0];</span>
            
<span class="nc" id="L673">            Integer key2 = Integer.valueOf(ifcs.getIndex2());</span>
            
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (indexes2.contains(key2)) {</span>
<span class="nc" id="L676">                return null;</span>
            }
            
<span class="nc" id="L679">            indexes2.add(key2);</span>
            
<span class="nc" id="L681">            ifcsList.add(ifcs);</span>
<span class="nc" id="L682">        }</span>
        
        // the matches are unique, so will look for the smallest cost
        // and then add similar to it
        
<span class="nc" id="L687">        double minCost = Double.MAX_VALUE;</span>
<span class="nc" id="L688">        int minCostIdx = -1;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        for (int i = 0; i &lt; ifcsList.size(); ++i) {</span>
<span class="nc" id="L690">            IntensityFeatureComparisonStats tp4 = ifcsList.get(i);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (tp4.getCost() &lt; minCost) {</span>
<span class="nc" id="L692">                minCost = tp4.getCost();</span>
<span class="nc" id="L693">                minCostIdx = i;</span>
            }
        }
        
<span class="nc" id="L697">        TransformationParameters minCostParams = MiscStats.calculateTransformation(</span>
<span class="nc" id="L698">            binFactor1, binFactor2, ifcsList.get(minCostIdx).getComparisonStats(),</span>
            new float[4]);
        
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (minCostParams == null) {</span>
<span class="nc" id="L702">            return null;</span>
        }
        
<span class="nc" id="L705">        List&lt;FeatureComparisonStat&gt; combined = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="nc" id="L706">        combined.addAll(ifcsList.get(minCostIdx).getComparisonStats());</span>
        
<span class="nc bnc" id="L708" title="All 2 branches missed.">        for (int i = 0; i &lt; ifcsList.size(); ++i) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (i == minCostIdx) {</span>
<span class="nc" id="L710">                continue;</span>
            }
<span class="nc" id="L712">            IntensityFeatureComparisonStats ifcs = ifcsList.get(i);</span>
<span class="nc" id="L713">            TransformationParameters params = MiscStats.calculateTransformation(</span>
<span class="nc" id="L714">               binFactor1, binFactor2, ifcs.getComparisonStats(),</span>
                new float[4]);
            
<span class="nc bnc" id="L717" title="All 2 branches missed.">            if (params == null) {</span>
<span class="nc" id="L718">                continue;</span>
            }
            
<span class="nc bnc" id="L721" title="All 2 branches missed.">            if (Math.abs(params.getScale() - minCostParams.getScale()) &lt; 0.05) {</span>
<span class="nc" id="L722">                float angleDiff = AngleUtil.getAngleAverageInDegrees(</span>
<span class="nc" id="L723">                    params.getRotationInDegrees(), minCostParams.getRotationInDegrees());</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (Math.abs(angleDiff) &lt; 10) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                    if (Math.abs(params.getTranslationX() - minCostParams.getTranslationX()) &lt; 10) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                        if (Math.abs(params.getTranslationY() - minCostParams.getTranslationY()) &lt; 10) {</span>
<span class="nc" id="L727">                            combined.addAll(ifcs.getComparisonStats());</span>
                        }
                    }
                }
            }
        }
        
<span class="nc" id="L734">        TransformationParameters combinedParams = MiscStats.calculateTransformation(</span>
            binFactor1, binFactor2, combined, new float[4]);
        
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (combinedParams == null) {</span>
<span class="nc" id="L738">            return null;</span>
        }
        
<span class="nc" id="L741">        MatchingSolution soln = new MatchingSolution(combinedParams, combined);</span>
        
<span class="nc" id="L743">        return soln;</span>
    }

    private int countMaxMatchable2(List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; c1List, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; c2List) {
        
<span class="fc" id="L749">        int n1 = 0;</span>
<span class="fc" id="L750">        int n2 = 0;</span>
        
<span class="fc bfc" id="L752" title="All 2 branches covered.">        for (List&lt;CurvatureScaleSpaceContour&gt; list : c1List) {</span>
<span class="fc" id="L753">            n1 += list.size();</span>
<span class="fc" id="L754">        }</span>
        
<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (List&lt;CurvatureScaleSpaceContour&gt; list : c2List) {</span>
<span class="fc" id="L757">            n2 += list.size();</span>
<span class="fc" id="L758">        }</span>
        
<span class="fc" id="L760">        return Math.max(n1, n2);</span>
    }
    
    private int evaluate2(TransformationParameters params, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; c1List, 
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; c2List, int tolTransXY) {
        
        //TODO: move this method to a class for utility methods
        
<span class="fc" id="L769">        int nMatched = 0;</span>
        
<span class="fc" id="L771">        int[] xPoints = convertToXPoints2(c2List);</span>
<span class="fc" id="L772">        int[] yPoints = convertToYPoints2(c2List);</span>
        
<span class="fc" id="L774">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L776">        NearestPoints np = new NearestPoints(xPoints, yPoints);</span>
        
<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (int i = 0; i &lt; c1List.size(); ++i) {</span>
            
<span class="fc" id="L780">            List&lt;CurvatureScaleSpaceContour&gt; contours1 = c1List.get(i);</span>
            
<span class="fc bfc" id="L782" title="All 2 branches covered.">            for (int ii = 0; ii &lt; contours1.size(); ++ii) {</span>
                
<span class="fc" id="L784">                CurvatureScaleSpaceContour cr = contours1.get(ii);</span>
                
<span class="fc" id="L786">                double[] xyTr = transformer.applyTransformation(params, </span>
<span class="fc" id="L787">                    cr.getPeakDetails()[0].getXCoord(), </span>
<span class="fc" id="L788">                    cr.getPeakDetails()[0].getYCoord());</span>
                
<span class="fc" id="L790">                Set&lt;Integer&gt; indexes = np.findNeighborIndexes(</span>
<span class="fc" id="L791">                    (int)Math.round(xyTr[0]), (int)Math.round(xyTr[1]), </span>
                    tolTransXY);
                
<span class="pc bpc" id="L794" title="1 of 4 branches missed.">                if (indexes != null &amp;&amp; indexes.size() &gt; 0) {</span>
<span class="fc" id="L795">                    nMatched++;</span>
                }
            }
        }
        
<span class="fc" id="L800">        return nMatched;</span>
    }

    private void filter(List&lt;IntensityFeatureComparisonStats&gt; ifcsList, 
        List&lt;TransformationParameters&gt; paramsList, int[] indexesToKeep) {
        
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">        if (indexesToKeep.length &lt; 2) {</span>
<span class="nc" id="L807">            return;</span>
        }
        
<span class="fc" id="L810">        List&lt;IntensityFeatureComparisonStats&gt; ifcsList2 = </span>
            new ArrayList&lt;IntensityFeatureComparisonStats&gt;(indexesToKeep.length);
        
<span class="fc" id="L813">        List&lt;TransformationParameters&gt; paramsList2 = </span>
            new ArrayList&lt;TransformationParameters&gt;();
        
<span class="fc bfc" id="L816" title="All 2 branches covered.">        for (int i = 0; i &lt; indexesToKeep.length;++i) {</span>
<span class="fc" id="L817">            int idx = indexesToKeep[i];</span>
<span class="fc" id="L818">            ifcsList2.add(ifcsList.get(idx));</span>
<span class="fc" id="L819">            paramsList2.add(paramsList.get(idx));</span>
        }
        
<span class="fc" id="L822">        ifcsList.clear();</span>
<span class="fc" id="L823">        ifcsList.addAll(ifcsList2);</span>
        
<span class="fc" id="L825">        paramsList.clear();</span>
<span class="fc" id="L826">        paramsList.addAll(paramsList2);</span>
<span class="fc" id="L827">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
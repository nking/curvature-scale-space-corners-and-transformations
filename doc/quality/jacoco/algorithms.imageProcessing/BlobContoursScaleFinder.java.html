<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BlobContoursScaleFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">BlobContoursScaleFinder.java</span></div><h1>BlobContoursScaleFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.MultiArrayMergeSort;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.ResourceFinder;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public class BlobContoursScaleFinder extends AbstractBlobScaleFinder {</span>

    public TransformationParameters solveForScale(
        BlobContourHelper img1Helper, IntensityFeatures features1,
        SegmentationType type1, boolean useBinned1,
        BlobContourHelper img2Helper, IntensityFeatures features2,
        SegmentationType type2, boolean useBinned2,
        float[] outputScaleRotTransXYStDev) {

<span class="fc" id="L35">        GreyscaleImage img1 = img1Helper.imgHelper.getGreyscaleImage(useBinned1);</span>
            
<span class="fc" id="L37">        GreyscaleImage img2 = img2Helper.imgHelper.getGreyscaleImage(useBinned2);</span>

<span class="fc" id="L39">        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1List = </span>
<span class="fc" id="L40">            img1Helper.getPerimeterContours(type1, useBinned1);</span>
        
<span class="fc" id="L42">        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours2List = </span>
<span class="fc" id="L43">            img2Helper.getPerimeterContours(type2, useBinned2);</span>
        
<span class="fc" id="L45">        List&lt;Set&lt;PairInt&gt;&gt; blobs1 = img1Helper.imgHelper.getBlobs(type1, useBinned1);</span>
<span class="fc" id="L46">        List&lt;Set&lt;PairInt&gt;&gt; blobs2 = img2Helper.imgHelper.getBlobs(type2, useBinned2);</span>
<span class="fc" id="L47">        List&lt;PairIntArray&gt; perimeters1 = img1Helper.imgHelper.getBlobPerimeters(type1, useBinned1);</span>
<span class="fc" id="L48">        List&lt;PairIntArray&gt; perimeters2 = img2Helper.imgHelper.getBlobPerimeters(type2, useBinned2);</span>

<span class="fc" id="L50">        Map&lt;PairInt, CSSContourMatcherWrapper&gt; singleSolnMap =</span>
            new HashMap&lt;PairInt,  CSSContourMatcherWrapper&gt;();

<span class="fc" id="L53">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

        /*
        Note that the matching contours are improved and filtered by using 
        feature descriptors.
        
        Finding the best match if any for each index1.
        If a subsequent match to the that index1's index2 is present, it will
        only be considered if the cost is less than the previous.
        It's a greedy best approach.
        After all of the index1 solutions are gathered, the best is found
        by adjusting the costs by the largest sigma from the first peak contours 
        from edges1 (i.e. applying the penalty from the paper to smaller peak
        sigma's costs).
        The best agreeing solutions are kept.
        
        If instead wanted a bipartite matching of best costs, would want to
        keep the top 2 or so of each index1.
        Would need to be careful to not include large peak contour false matches.
        All costs in the top would need to be adjusted by the penalty mentioned
        above.
        Then the best among more than one would be defined by cost.  
        Then more than one solutions points would be kept if similarity
        in difference of theta and scale were within a limit.
        */
       
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
<span class="fc" id="L80">            index1BestMap = new HashMap&lt;Integer, </span>
            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt;();

<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int idx1 = 0; idx1 &lt; blobs1.size(); ++idx1) {</span>

<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (contours1List.get(idx1).isEmpty()) {</span>
<span class="fc" id="L86">                continue;</span>
            }

<span class="fc" id="L89">            Integer index1 = Integer.valueOf(idx1);</span>

<span class="fc" id="L91">            PairIntArray curve1 = perimeters1.get(idx1);</span>

<span class="fc" id="L93">            Set&lt;PairInt&gt; blob1 = blobs1.get(idx1);</span>

<span class="fc" id="L95">            double[] xyCen1 = curveHelper.calculateXYCentroids(blob1);</span>

            // keeping the top '2' for each index1.  comparison is by cost.
            // choosing more than one because later bipartite matching attempts
            // to match best for all index1 matchings
<span class="fc" id="L100">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; bestStats </span>
                = new FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;(2, 
                IntensityFeatureComparisonStats.class);

<span class="fc bfc" id="L104" title="All 2 branches covered.">            for (int idx2 = 0; idx2 &lt; blobs2.size(); ++idx2) {</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">                if (contours2List.get(idx2).isEmpty()) {</span>
<span class="fc" id="L107">                    continue;</span>
                }

<span class="fc" id="L110">                Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L112">                PairIntArray curve2 = perimeters2.get(idx2);</span>

<span class="fc" id="L114">                Set&lt;PairInt&gt; blob2 = blobs2.get(idx2);</span>
                
<span class="fc" id="L116">                CurvatureScaleSpaceInflectionSingleEdgeMapper mapper =</span>
                    new CurvatureScaleSpaceInflectionSingleEdgeMapper(
                    0, 0, 0, 0);

<span class="fc" id="L120">                TransformationParameters params = mapper.matchContours(</span>
<span class="fc" id="L121">                    contours1List.get(idx1), contours2List.get(idx2));</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">                if ((params == null) ||</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                    (mapper.getMatcher().getSolutionMatchedContours1().size() &lt; 2)) {</span>

<span class="pc bpc" id="L126" title="1 of 2 branches missed.">                    if ((mapper.getMatcher() != null) &amp;&amp;</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                        (mapper.getMatcher().getSolutionMatchedContours1().size() == 1)) {</span>

<span class="fc" id="L129">                        singleSolnMap.put(new PairInt(idx1, idx2), mapper.getMatcher());</span>
                    }

                    continue;
                }

                // edit points using feature descriptors and remove outliers:
<span class="fc" id="L136">                List&lt;FeatureComparisonStat&gt; compStats =</span>
<span class="fc" id="L137">                    filterContourPointsByFeatures(img1, img2, index1, index2,</span>
                    blob1, blob2, curve1, curve2, features1, features2,
<span class="fc" id="L139">                    mapper.getMatcher());</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">                if (compStats.size() &lt; 2) {</span>
<span class="fc" id="L142">                    continue;</span>
                }

                //TODO: consider moving this type of statistic into the
                //cost during contour matching.  wanting to avoid accepting
                //solutions which are a small number of spurious matches due
                //to one contour having many points to match to.
<span class="fc" id="L149">                int nc1 = contours1List.get(index1.intValue()).size();</span>
<span class="fc" id="L150">                int nc2 = contours2List.get(index2.intValue()).size();</span>
<span class="fc" id="L151">                float frac = (float)nc1/(float)nc2;</span>
<span class="fc bfc" id="L152" title="All 8 branches covered.">                boolean lgDiffN = ((nc1 &gt; nc2) &amp;&amp; frac &gt; 2)</span>
                    || ((nc1 &lt; nc2) &amp;&amp; frac &lt; 0.5);
                
                // also, discard if fraction of matched/maxmatchable is too low
<span class="fc bfc" id="L156" title="All 2 branches covered.">                if (!lgDiffN) {</span>
<span class="fc" id="L157">                    float nmm = Math.min(nc1, nc2);</span>
<span class="fc" id="L158">                    float nm = compStats.size();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                    if ((nm/nmm) &lt; 0.5) {</span>
<span class="fc" id="L160">                        lgDiffN = true;</span>
                    }
                }
                
<span class="fc" id="L164">                log.info(String.format(</span>
                    &quot;   nc1=%d nc2=%d (frac=%.2f) nMCs=%d&quot;,
<span class="fc" id="L166">                    nc1, nc2, frac, </span>
<span class="fc" id="L167">                    mapper.getMatcher().getSolutionMatchedContours1().size()));</span>
                
<span class="fc bfc" id="L169" title="All 2 branches covered.">                if (lgDiffN) {                    </span>
<span class="fc" id="L170">                    log.info(</span>
                        &quot;discarding a good match because frac of maxMatchable is low.&quot;);
<span class="fc" id="L172">                    continue;</span>
                }
                
                //double combinedStat = calculateCombinedIntensityStat(compStats);

<span class="fc" id="L177">                IntensityFeatureComparisonStats stats = new </span>
<span class="fc" id="L178">                    IntensityFeatureComparisonStats(index1.intValue(), </span>
<span class="fc" id="L179">                    index2.intValue(), mapper.getMatcher().getSolvedCost(), </span>
<span class="fc" id="L180">                        mapper.getMatcher().getSolvedScale());</span>
<span class="fc" id="L181">                stats.addAll(compStats);</span>
                
                // bestStats keeps the top '2' smallest cost solutions added to it
                // (though combinedStats are used when nMatched is 2 or less)
<span class="fc" id="L185">                boolean added = bestStats.add(stats);</span>
                
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (added) {</span>
<span class="fc" id="L188">                    log.info(&quot;  added to best for [&quot; + index1.toString() + &quot;] [&quot;</span>
<span class="fc" id="L189">                        + index2.toString() + &quot;] cost=&quot; + stats.getCost()</span>
<span class="fc" id="L190">                        + &quot; with n=&quot; + stats.getComparisonStats().size());</span>
                }
            }

<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (bestStats.getNumberOfItems() == 0) {</span>
<span class="fc" id="L195">                continue;</span>
            }

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                for (int k = 0; k &lt; bestStats.getNumberOfItems(); ++k) {</span>
<span class="nc" id="L200">                    IntensityFeatureComparisonStats stats = bestStats.getArray()[k];</span>
<span class="nc" id="L201">                    double[] xyCen2 = curveHelper.calculateXYCentroids(</span>
<span class="nc" id="L202">                        blobs2.get(stats.getIndex2()));</span>
<span class="nc" id="L203">                    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L204">                    sb.append(String.format(</span>
                        &quot;==&gt;[%d](%d,%d) [%d](%d,%d) cost=%.2f scale=%.2f nMatched=%d(%d,%d) intSqDiff=%.1f&quot;,
<span class="nc" id="L206">                        stats.getIndex1(), (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="nc" id="L207">                        stats.getIndex2(), (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1]),</span>
<span class="nc" id="L208">                        (float)stats.getCost(), (float)stats.getScale(), </span>
<span class="nc" id="L209">                        stats.getComparisonStats().size(),</span>
<span class="nc" id="L210">                        contours1List.get(stats.getIndex1()).size(), </span>
<span class="nc" id="L211">                        calculateCombinedIntensityStat(stats.getComparisonStats())));</span>
<span class="nc" id="L212">                    log.info(sb.toString());</span>
                }
            }

<span class="fc" id="L216">            index1BestMap.put(index1, bestStats);</span>
        }
        
<span class="fc" id="L219">        List&lt;FeatureComparisonStat&gt; bestOverall = null;</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (index1BestMap.isEmpty()) {</span>
            
            // -------- process the single solution compStats ------------
            
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (singleSolnMap.size() &gt; 1) {</span>
<span class="nc" id="L225">                bestOverall = processSingleSolutionsIfNoBest(img1, img2,</span>
                    singleSolnMap, blobs1, blobs2, perimeters1, perimeters2,
                    features1, features2);
            }

<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (index1BestMap.isEmpty()) {</span>
<span class="nc" id="L231">                return null;</span>
            }
        } else {
<span class="fc" id="L234">            bestOverall = filterToBestConsistent(index1BestMap, contours1List,</span>
                contours2List);
        }

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (bestOverall == null) {</span>
<span class="nc" id="L239">            return null;</span>
        }

<span class="fc" id="L242">        TransformationParameters params = calculateTransformation(</span>
<span class="fc" id="L243">            img1Helper.imgHelper.getBinFactor(useBinned1),</span>
<span class="fc" id="L244">            img2Helper.imgHelper.getBinFactor(useBinned2),</span>
            bestOverall, outputScaleRotTransXYStDev);

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L248">            return null;</span>
        }

<span class="fc" id="L251">        return params;</span>
    }

    protected List&lt;FeatureComparisonStat&gt; filterContourPointsByFeatures(
        GreyscaleImage img1, GreyscaleImage img2,
        Integer index1, Integer index2,
        Set&lt;PairInt&gt; blob1, Set&lt;PairInt&gt; blob2,
        PairIntArray curve1, PairIntArray curve2,
        IntensityFeatures features1, IntensityFeatures features2,
        CSSContourMatcherWrapper matcher) {

<span class="fc" id="L262">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

<span class="fc" id="L264">        int dither = 1;</span>

<span class="fc" id="L266">        List&lt;FeatureComparisonStat&gt; compStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L268">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L270">        double[] xyCen1 = curveHelper.calculateXYCentroids(curve1);</span>
<span class="fc" id="L271">        double[] xyCen2 = curveHelper.calculateXYCentroids(curve2);</span>

<span class="fc" id="L273">        double statSqSum = 0;</span>

<span class="fc" id="L275">        int nMaxMatchable = matcher.getNMaxMatchable();</span>
<span class="fc" id="L276">        int nMaxStats = 0;</span>
<span class="fc" id="L277">        int nStats = 0;</span>

<span class="fc" id="L279">        double cost = matcher.getSolvedCost();</span>

<span class="fc" id="L281">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L282">        sb.append(String.format(</span>
            &quot;[%d](%d,%d) [%d](%d,%d) cost=%.1f scale=%.2f  nMatched=%d &quot;,
<span class="fc" id="L284">            index1.intValue(), (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="fc" id="L285">            index2.intValue(), (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1]),</span>
<span class="fc" id="L286">            (float)cost, (float)matcher.getSolvedScale(),</span>
<span class="fc" id="L287">            matcher.getSolutionMatchedContours1().size()));</span>

<span class="fc" id="L289">        FeatureComparisonStat bestCompStat = null;</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">        for (int j = 0; j &lt; matcher.getSolutionMatchedContours1().size(); ++j) {</span>

<span class="fc" id="L293">            CurvatureScaleSpaceContour c1 = matcher.getSolutionMatchedContours1().get(j);</span>
<span class="fc" id="L294">            CurvatureScaleSpaceContour c2 = matcher.getSolutionMatchedContours2().get(j);</span>

            // the sizes of the peak details will be the same
<span class="fc" id="L297">            CurvatureScaleSpaceImagePoint[] details1 = c1.getPeakDetails();</span>
<span class="fc" id="L298">            CurvatureScaleSpaceImagePoint[] details2 = c2.getPeakDetails();</span>

<span class="fc" id="L300">            nMaxStats += details1.length;</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">            for (int jj = 0; jj &lt; details1.length; ++jj) {</span>

<span class="fc" id="L304">                BlobPerimeterRegion region1 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L305">                    index1.intValue(), details1[jj], curve1, blob1</span>
                );

<span class="fc" id="L308">                BlobPerimeterRegion region2 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L309">                    index2.intValue(), details2[jj], curve2, blob2</span>
                );
   
<span class="fc" id="L312">                FeatureComparisonStat compStat =</span>
<span class="fc" id="L313">                    featureMatcher.ditherAndRotateForBestLocation(</span>
                    features1, features2, region1, region2, dither, img1, img2);

<span class="fc" id="L316">sb.append(</span>
<span class="fc" id="L317">    String.format(&quot; (%d,%d) theta1=%d   (%d,%d) theta2=%d&quot;,</span>
<span class="fc" id="L318">    region1.getX(), region1.getY(),</span>
<span class="fc" id="L319">    Math.round(region1.getRelativeOrientationInDegrees()),</span>
<span class="fc" id="L320">    region2.getX(), region2.getY(),</span>
<span class="fc" id="L321">    Math.round(region2.getRelativeOrientationInDegrees())));</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">                if (compStat != null) {</span>
<span class="fc" id="L324">                    float sumIntSqDiff = compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L325">                    float intErrDiff = compStat.getImg2PointIntensityErr();</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                    if (sumIntSqDiff &lt; intErrDiff) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                        if (bestCompStat == null) {</span>
<span class="fc" id="L328">                            bestCompStat = compStat;</span>
                        } else {
<span class="fc bfc" id="L330" title="All 2 branches covered.">                            if (sumIntSqDiff &lt; bestCompStat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L331">                                bestCompStat = compStat;</span>
                            }
                        }
<span class="fc" id="L334">                        statSqSum += (sumIntSqDiff*sumIntSqDiff);</span>
<span class="fc" id="L335">                        sb.append(String.format(&quot;  %.1f(%.1f), &quot;, sumIntSqDiff, intErrDiff));</span>
<span class="fc" id="L336">                        compStats.add(compStat);</span>
<span class="fc" id="L337">                        nStats++;</span>
                    }
                }
            } // end details
        }// end matching contours for index1, index2

<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (bestCompStat == null) {</span>
<span class="fc" id="L344">            return compStats;</span>
        }

<span class="fc" id="L347">        log.info(sb.toString());</span>

        // if bestCompStat's difference in orientation is different than the
        // others', re-do the others to see if have an improved calculation.
        // the &quot;re-do&quot; should try a dither of 1 or 2
<span class="fc" id="L352">        float bestDiffTheta = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L353">            bestCompStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L354">            bestCompStat.getImg1PointRotInDegrees());</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (bestDiffTheta &lt; 0) {</span>
<span class="fc" id="L356">            bestDiffTheta += 360;</span>
        }

<span class="fc" id="L359">        boolean redoStats = false;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (FeatureComparisonStat cStat : compStats) {</span>
<span class="fc" id="L361">            float diffTheta = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L362">                cStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L363">                cStat.getImg1PointRotInDegrees());</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            if (diffTheta &lt; 0) {</span>
<span class="fc" id="L365">                diffTheta += 360;</span>
            }
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (Math.abs(bestDiffTheta - diffTheta) &gt; 25) {</span>
<span class="fc" id="L368">                redoStats = true;</span>
<span class="fc" id="L369">                break;</span>
            }
<span class="fc" id="L371">        }</span>

        //TODO: may need to consider re-doing if compStats.size() is &lt;&lt; nMaxStats too
<span class="fc" id="L374">redoStats = true;</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (redoStats) {</span>

<span class="fc" id="L377">            compStats = redoFilterContourPointsByFeatures(img1, img2, index1,</span>
                index2, blob1, blob2, curve1, curve2,
<span class="fc" id="L379">                bestCompStat.getImg1PointRotInDegrees(),</span>
<span class="fc" id="L380">                bestCompStat.getImg2PointRotInDegrees(), matcher);</span>
            
<span class="fc" id="L382">            log.fine(&quot;redone: &quot; + printToString(compStats) + &quot; combinedStat=&quot;</span>
<span class="fc" id="L383">                + calculateCombinedIntensityStat(compStats));</span>
       
<span class="fc" id="L385">            removeDiscrepantThetaDiff(compStats);</span>

<span class="fc" id="L387">            log.fine(&quot;theta diff filtered: &quot; + printToString(compStats) + &quot; combinedStat=&quot;</span>
<span class="fc" id="L388">                + calculateCombinedIntensityStat(compStats));</span>
            
<span class="fc" id="L390">            removeIntensityOutliers(compStats);</span>
        }

<span class="fc" id="L393">        return compStats;</span>
    }

    List&lt;FeatureComparisonStat&gt; redoFilterContourPointsByFeatures(
        GreyscaleImage img1, GreyscaleImage img2,
        Integer index1, Integer index2,
        Set&lt;PairInt&gt; blob1, Set&lt;PairInt&gt; blob2,
        PairIntArray curve1, PairIntArray curve2,
        float theta1, float theta2,
        CSSContourMatcherWrapper matcher) {

<span class="fc" id="L404">        log.info(&quot;redoFilterContourPointsByFeatures&quot;);</span>
        
<span class="fc" id="L406">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

        // for the redo, because the orientations are set rather than found,
        // not going to re-use the invoker's instance of Features
<span class="fc" id="L410">        IntensityFeatures features1 = new IntensityFeatures(img1, 5, true);</span>
<span class="fc" id="L411">        IntensityFeatures features2 = new IntensityFeatures(img2, 5, true);</span>

<span class="fc" id="L413">        int dither = 2;</span>

<span class="fc" id="L415">        List&lt;FeatureComparisonStat&gt; compStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L417">        int nMaxMatchable = matcher.getNMaxMatchable();</span>
<span class="fc" id="L418">        int nMaxStats = 0;</span>

<span class="fc" id="L420">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L421">        sb.append(String.format(&quot;[%d] [%d] &quot;, index1.intValue(), index2.intValue()));</span>

<span class="fc" id="L423">        float theta1Radians = (float)(theta1 * Math.PI/180.);</span>
<span class="fc" id="L424">        float theta2Radians = (float)(theta2 * Math.PI/180.);</span>

<span class="fc bfc" id="L426" title="All 2 branches covered.">        for (int j = 0; j &lt; matcher.getSolutionMatchedContours1().size(); ++j) {</span>

<span class="fc" id="L428">            CurvatureScaleSpaceContour c1 = matcher.getSolutionMatchedContours1().get(j);</span>
<span class="fc" id="L429">            CurvatureScaleSpaceContour c2 = matcher.getSolutionMatchedContours2().get(j);</span>

            // the sizes of the peak details will be the same
<span class="fc" id="L432">            CurvatureScaleSpaceImagePoint[] details1 = c1.getPeakDetails();</span>
<span class="fc" id="L433">            CurvatureScaleSpaceImagePoint[] details2 = c2.getPeakDetails();</span>

<span class="fc" id="L435">            nMaxStats += details1.length;</span>

<span class="fc bfc" id="L437" title="All 2 branches covered.">            for (int jj = 0; jj &lt; details1.length; ++jj) {</span>

<span class="fc" id="L439">                BlobPerimeterRegion region1 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L440">                    index1.intValue(), details1[jj], curve1, blob1</span>
                );
<span class="fc" id="L442">                region1.overrideRelativeOrientation(theta1Radians);</span>

<span class="fc" id="L444">                BlobPerimeterRegion region2 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L445">                    index2.intValue(), details2[jj], curve2, blob2</span>
                );
<span class="fc" id="L447">                region2.overrideRelativeOrientation(theta2Radians);</span>

<span class="fc" id="L449">                FeatureComparisonStat compStat =</span>
<span class="fc" id="L450">                    featureMatcher.ditherAndRotateForBestLocation(</span>
                    features1, features2, region1, region2, dither);

<span class="fc bfc" id="L453" title="All 2 branches covered.">                if (compStat != null) {</span>

<span class="fc" id="L455">                    float sumIntSqDiff = compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L456">                    float intErrDiff = compStat.getImg2PointIntensityErr();</span>

<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                    if (sumIntSqDiff &lt; intErrDiff) {</span>
<span class="fc" id="L459">                        compStats.add(compStat);</span>
                    }

                }
            } // end details
        }// end matching contours for index1, index2

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L467">            sb.append(printToString(compStats)).append(&quot; nMaxStats=&quot;).append(nMaxStats);</span>

<span class="nc" id="L469">            log.info(sb.toString());</span>
        }
        
        //removeOutliers(compStats);

<span class="fc" id="L474">        return compStats;</span>
    }

    protected List&lt;FeatureComparisonStat&gt; filterToBestConsistent(
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
        index1StatsMap, List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1Lists,
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours2Lists) {

<span class="pc bpc" id="L482" title="2 of 4 branches missed.">        if (index1StatsMap == null || index1StatsMap.isEmpty()) {</span>
<span class="nc" id="L483">            return null;</span>
        }
        
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (index1StatsMap.size() &gt; 1) {</span>
            // make corrections for cost between different edges            
<span class="fc" id="L488">            correctCostsUsingMaxSigma(index1StatsMap, contours1Lists);            </span>
        }
       
<span class="fc" id="L491">        TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; bestMatches = </span>
<span class="fc" id="L492">            findBestMatchesUsingBipartite(index1StatsMap, </span>
<span class="fc" id="L493">            contours1Lists.size(), contours2Lists.size());</span>

<span class="fc" id="L495">        int nMaxMatchable = 2 * Math.max(contours1Lists.size(), contours2Lists.size());</span>
     
<span class="fc" id="L497">        Map&lt;Integer, IntensityFeatureComparisonStats&gt; index1Map = new</span>
            HashMap&lt;Integer, IntensityFeatureComparisonStats&gt;();
            
<span class="fc" id="L500">        Map&lt;PairInt, PairFloat&gt; indexesDiffTheta = new HashMap&lt;PairInt, PairFloat&gt;();</span>
        
        /* calculate the highest number of similar transformations and the
        lowest cost from those.  store nSimilar, indexes, cost for each iteration*/
<span class="fc" id="L504">        int[] nSimilarSummary = new int[nMaxMatchable];</span>
<span class="fc" id="L505">        Integer[][] indexesSummary = new Integer[nMaxMatchable][];</span>
<span class="fc" id="L506">        double[] costsSummary = new double[nMaxMatchable];</span>
<span class="fc" id="L507">        int[] mainIndexSummary = new int[nMaxMatchable];</span>

<span class="fc" id="L509">        int count = 0;</span>
        
<span class="fc bfc" id="L511" title="All 2 branches covered.">        for (Map.Entry&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; entry : bestMatches.entrySet()) {</span>

<span class="fc" id="L513">            Double adjustedCost = entry.getKey();</span>
            
<span class="fc" id="L515">            List&lt;IntensityFeatureComparisonStats&gt; stats = entry.getValue();</span>
            
<span class="fc bfc" id="L517" title="All 2 branches covered.">            for (IntensityFeatureComparisonStats stat : stats) {</span>
<span class="fc" id="L518">                int idx1 = stat.getIndex1();</span>
<span class="fc" id="L519">                int idx2 = stat.getIndex2();</span>
<span class="pc bpc" id="L520" title="3 of 4 branches missed.">                assert(index1Map.get(Integer.valueOf(idx1)) == null);</span>
<span class="fc" id="L521">                index1Map.put(Integer.valueOf(idx1), stat);</span>
<span class="fc" id="L522">                PairInt p = new PairInt(idx1, idx2);</span>
<span class="fc" id="L523">                PairFloat diffThetaMnStdv = indexesDiffTheta.get(p);</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">                if (diffThetaMnStdv == null) {</span>
<span class="fc" id="L525">                    float[] diffThetas = new float[stat.getComparisonStats().size()];</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                    for (int i = 0; i &lt; stat.getComparisonStats().size(); ++i) {</span>
<span class="fc" id="L527">                        FeatureComparisonStat fcs = stat.getComparisonStats().get(i);                </span>
<span class="fc" id="L528">                        float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L529">                           fcs.getImg1PointRotInDegrees(), fcs.getImg2PointRotInDegrees());</span>
<span class="fc" id="L530">                        diffThetas[i] = diff;</span>
                    }
<span class="fc" id="L532">                    float[] msv = MiscMath.getAvgAndStDev(diffThetas);</span>
                    
                    // TODO: consider whether need to exclude points further from
                    // the mean than a difference in thetaDiff of 20
                    // unless edits have changed it, this was run previously,
                    // so what is present here should already be consistent
                    // diffThetas:
                    //removeDiscrepantThetaDiff(stat.getComparisonStats());
                    
<span class="fc" id="L541">                    diffThetaMnStdv = new PairFloat(msv[0], msv[1]);</span>
                }
                
<span class="fc" id="L544">                double scale = stat.getScale();</span>
                
<span class="fc" id="L546">                Set&lt;Integer&gt; similarParamsIndexes1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L547">                similarParamsIndexes1.add(Integer.valueOf(idx1));</span>
                
                // count the number of solutions similar in diffTheta and scale
<span class="fc bfc" id="L550" title="All 2 branches covered.">                for (Map.Entry&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; entry2 : bestMatches.entrySet()) {</span>
<span class="fc" id="L551">                    Double adjustedCost2 = entry2.getKey();</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">                    if (adjustedCost2.equals(adjustedCost)) {</span>
<span class="fc" id="L553">                        continue;</span>
                    }
<span class="fc bfc" id="L555" title="All 2 branches covered.">                    for (IntensityFeatureComparisonStats stat2 : entry2.getValue()) {</span>
<span class="fc" id="L556">                        int idx1P = stat2.getIndex1();</span>
<span class="fc" id="L557">                        int idx2P = stat2.getIndex2();</span>
                        // bipartite matching should have made unique idx1 already:
<span class="pc bpc" id="L559" title="3 of 4 branches missed.">                        assert(idx1 != idx1P);</span>
<span class="fc" id="L560">                        PairInt p2 = new PairInt(idx1P, idx2P);</span>
<span class="fc" id="L561">                        PairFloat diffThetaMnStdv2 = indexesDiffTheta.get(p2);</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                        if (diffThetaMnStdv2 == null) {</span>
<span class="fc" id="L563">                            float[] diffThetas = new float[stat2.getComparisonStats().size()];</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">                            for (int i = 0; i &lt; stat2.getComparisonStats().size(); ++i) {</span>
<span class="fc" id="L565">                                FeatureComparisonStat fcs = stat2.getComparisonStats().get(i);                </span>
<span class="fc" id="L566">                                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L567">                                    fcs.getImg1PointRotInDegrees(), fcs.getImg2PointRotInDegrees());</span>
<span class="fc" id="L568">                                diffThetas[i] = diff;</span>
                            }
<span class="fc" id="L570">                            float[] msv = MiscMath.getAvgAndStDev(diffThetas);</span>
<span class="fc" id="L571">                            diffThetaMnStdv2 = new PairFloat(msv[0], msv[1]);</span>
                        }
                        
                        //--- compare diffTheta and scale with ---
<span class="fc bfc" id="L575" title="All 2 branches covered.">                        if ((Math.abs(diffThetaMnStdv.getX() - diffThetaMnStdv2.getX()) &lt; 10)</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                            &amp;&amp; (Math.abs(scale - stat2.getScale()) &lt; 0.1)) {</span>
<span class="fc" id="L577">                            similarParamsIndexes1.add(Integer.valueOf(idx1P));</span>
                        }
<span class="fc" id="L579">                    }</span>
<span class="fc" id="L580">                }</span>
                
                // store for sort and combine
<span class="fc" id="L583">                nSimilarSummary[count] = similarParamsIndexes1.size();</span>
<span class="fc" id="L584">                indexesSummary[count] = similarParamsIndexes1.toArray(new Integer[similarParamsIndexes1.size()]);</span>
<span class="fc" id="L585">                costsSummary[count] = adjustedCost;</span>
<span class="fc" id="L586">                mainIndexSummary[count] = idx1;</span>
                
<span class="fc" id="L588">                count++;</span>
<span class="fc" id="L589">            }</span>
<span class="fc" id="L590">        }</span>
        
<span class="fc" id="L592">        nSimilarSummary = Arrays.copyOf(nSimilarSummary, count);</span>
<span class="fc" id="L593">        indexesSummary = Arrays.copyOf(indexesSummary, count);</span>
<span class="fc" id="L594">        costsSummary = Arrays.copyOf(costsSummary, count);</span>
<span class="fc" id="L595">        mainIndexSummary = Arrays.copyOf(mainIndexSummary, count);</span>
        
        // sort to prefer the solution w/ largest number of similar solutions:
        //MultiArrayMergeSort.sortBy1stDescThen2ndAsc(nSimilarSummary, costsSummary, indexesSummary, mainIndexSummary);

        // OR sort to refer the solution w/ best cost and any it is similar to:
        //--- these are still sorted by costs already, so no need to resort again ---
        // MultiArrayMergeSort.sortBy1stAscThen2ndDesc(costsSummary, nSimilarSummary, indexesSummary, mainIndexSummary, 0, costsSummary.length - 1);

<span class="fc" id="L604">        Integer[] indexes = indexesSummary[0];</span>
       
<span class="fc" id="L606">        List&lt;FeatureComparisonStat&gt; output = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">        for (Integer index1 : indexes) {</span>
<span class="fc" id="L608">            IntensityFeatureComparisonStats stats = index1Map.get(index1);</span>
<span class="fc" id="L609">            output.addAll(stats.getComparisonStats());</span>
        }
<span class="fc" id="L611">        return output;</span>
    }
    
    private List&lt;FeatureComparisonStat&gt; processSingleSolutionsIfNoBest(
        GreyscaleImage img1, GreyscaleImage img2,
        Map&lt;PairInt, CSSContourMatcherWrapper&gt; singleSolnMap,
        List&lt;Set&lt;PairInt&gt;&gt; blobs1, List&lt;Set&lt;PairInt&gt;&gt; blobs2,
        List&lt;PairIntArray&gt; perimeters1, List&lt;PairIntArray&gt; perimeters2,
        IntensityFeatures features1, IntensityFeatures features2) {

<span class="nc" id="L621">log.info(&quot;WARNING: processing single solutions... may remove these in future&quot;);</span>

<span class="nc" id="L623">        List&lt;FeatureComparisonStat&gt; csList = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="nc" id="L625">        int nm = singleSolnMap.size();</span>
        
<span class="nc" id="L627">        double[] costs = new double[nm];</span>
<span class="nc" id="L628">        int[] idx1s = new int[nm];</span>
<span class="nc" id="L629">        int[] idx2s = new int[nm];</span>
<span class="nc" id="L630">        FeatureComparisonStat[] ifs = new FeatureComparisonStat[nm];</span>
        
<span class="nc" id="L632">        int count = 0;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">        for (Entry&lt;PairInt, CSSContourMatcherWrapper&gt; entry : singleSolnMap.entrySet()) {</span>
            
<span class="nc" id="L635">            PairInt index1Index2 = entry.getKey();</span>
<span class="nc" id="L636">            int idx1 = index1Index2.getX();</span>
<span class="nc" id="L637">            int idx2 = index1Index2.getY();</span>
            
<span class="nc" id="L639">            CSSContourMatcherWrapper matcher = entry.getValue();</span>
            
<span class="nc" id="L641">            PairIntArray curve1 = perimeters1.get(idx1);</span>
<span class="nc" id="L642">            Set&lt;PairInt&gt; blob1 = blobs1.get(idx1);</span>
<span class="nc" id="L643">            PairIntArray curve2 = perimeters2.get(idx2);</span>
<span class="nc" id="L644">            Set&lt;PairInt&gt; blob2 = blobs2.get(idx2);</span>

<span class="nc" id="L646">            List&lt;FeatureComparisonStat&gt; compStats =</span>
<span class="nc" id="L647">                filterContourPointsByFeatures(img1, img2,</span>
<span class="nc" id="L648">                Integer.valueOf(idx1), Integer.valueOf(idx2),</span>
                blob1, blob2, curve1, curve2, features1, features2,
                matcher);

<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (compStats.isEmpty()) {</span>
<span class="nc" id="L653">                continue;</span>
            }
            
<span class="nc bnc" id="L656" title="All 4 branches missed.">            assert(compStats.size() == 1);</span>

<span class="nc" id="L658">            double combStat = calculateCombinedIntensityStat(compStats);</span>

<span class="nc" id="L660">            idx1s[count] = idx1;</span>
<span class="nc" id="L661">            idx2s[count] = idx2;</span>
<span class="nc" id="L662">            ifs[count] = compStats.get(0);</span>

            //ssd of intensity is a better selector for one dataset. this may change w/ more testing
            //costs[count] = stats.getAdjustedCost();
<span class="nc" id="L666">            costs[count] = combStat;</span>
            
<span class="nc" id="L668">            count++;</span>
<span class="nc" id="L669">        }</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L671">            return null;</span>
        }
<span class="nc" id="L673">        costs = Arrays.copyOf(costs, count);</span>
<span class="nc" id="L674">        idx1s = Arrays.copyOf(idx1s, count);</span>
<span class="nc" id="L675">        idx2s = Arrays.copyOf(idx2s, count);</span>
<span class="nc" id="L676">        ifs = Arrays.copyOf(ifs, count);</span>
<span class="nc" id="L677">        int[] lookupIndexes = new int[count];</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L679">            lookupIndexes[i] = i;</span>
        }
        // best will be at bottom of list:
<span class="nc" id="L682">        MultiArrayMergeSort.sortByDecr(costs, lookupIndexes);</span>
        
<span class="nc" id="L684">        float ssdBest = ifs[lookupIndexes[count - 1]].getSumIntensitySqDiff();</span>
        
<span class="nc" id="L686">        float thetaDiffBest = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L687">            ifs[lookupIndexes[count - 1]].getImg1PointRotInDegrees(),</span>
<span class="nc" id="L688">            ifs[lookupIndexes[count - 1]].getImg2PointRotInDegrees());</span>
        
<span class="nc" id="L690">        int count2 = 0;</span>
<span class="nc" id="L691">        double[] costs2 = new double[count];</span>
<span class="nc" id="L692">        int[] idx1s2 = new int[count];</span>
<span class="nc" id="L693">        int[] idx2s2 = new int[count];</span>
<span class="nc" id="L694">        FeatureComparisonStat[] ifs2 = new FeatureComparisonStat[count];</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L696">            int idx0 = lookupIndexes[i];</span>
<span class="nc" id="L697">            FeatureComparisonStat fcs = ifs[idx0];</span>
<span class="nc" id="L698">            double ssd = fcs.getSumIntensitySqDiff();</span>

<span class="nc" id="L700">            float dtm = AngleUtil.getAngleDifference(</span>
<span class="nc" id="L701">                fcs.getImg1PointRotInDegrees(), fcs.getImg2PointRotInDegrees());</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (Math.abs(dtm - thetaDiffBest) &gt; 20) {</span>
<span class="nc" id="L704">                continue;</span>
            }
            
<span class="nc bnc" id="L707" title="All 2 branches missed.">            if (ssd &gt; (3 * ssdBest)) {</span>
<span class="nc" id="L708">                continue;</span>
            }

<span class="nc" id="L711">            costs2[count2] = costs[i];</span>
<span class="nc" id="L712">            idx1s2[count2] = idx1s[idx0];</span>
<span class="nc" id="L713">            idx2s2[count2] = idx2s[idx0];</span>
<span class="nc" id="L714">            ifs2[count2] = fcs;</span>
            
<span class="nc" id="L716">            count2++;</span>
        }
<span class="nc" id="L718">        costs2 = Arrays.copyOf(costs2, count2);</span>
<span class="nc" id="L719">        idx1s2 = Arrays.copyOf(idx1s2, count2);</span>
<span class="nc" id="L720">        idx2s2 = Arrays.copyOf(idx2s2, count2);</span>
<span class="nc" id="L721">        ifs2 = Arrays.copyOf(ifs2, count2);</span>
        
<span class="nc" id="L723">        Set&lt;Integer&gt; chosen1 = new HashSet&lt;Integer&gt;();</span>
<span class="nc" id="L724">        Set&lt;Integer&gt; chosen2 = new HashSet&lt;Integer&gt;();</span>

<span class="nc bnc" id="L726" title="All 2 branches missed.">        for (int i = 0; i &lt; count2; ++i) {</span>

<span class="nc" id="L728">            Integer index1 = Integer.valueOf(idx1s2[i]);</span>
<span class="nc" id="L729">            Integer index2 = Integer.valueOf(idx2s2[i]);</span>

<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (chosen1.contains(index1)) {</span>
<span class="nc" id="L732">                continue;</span>
            }
<span class="nc bnc" id="L734" title="All 2 branches missed.">            if (chosen2.contains(index2)) {</span>
<span class="nc" id="L735">                continue;</span>
            }
            
<span class="nc" id="L738">            Double cost = Double.valueOf(costs2[i]);</span>
<span class="nc" id="L739">            FeatureComparisonStat ifcs = ifs2[i];</span>

            // only true if still using costs rather than SSD:
            //assert(Math.abs(cost.doubleValue() - ifcs.getAdjustedCost()) &lt; 0.01);

<span class="nc" id="L744">            csList.add(ifcs);</span>

<span class="nc" id="L746">            chosen1.add(index1);</span>
<span class="nc" id="L747">            chosen2.add(index2);</span>
        }
        
<span class="nc" id="L750">        return csList;</span>
    }

    private void correctCostsUsingMaxSigma(
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
            index1StatsMap, List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1Lists) {
                
<span class="fc" id="L757">        float maxPeakSigma = Float.MIN_VALUE;</span>
        
<span class="fc" id="L759">        Map&lt;Integer, Float&gt; index1PeakSigma = new HashMap&lt;Integer, Float&gt;();</span>
        
        for (Entry&lt;Integer, FixedSizeSortedVector&lt;
<span class="fc bfc" id="L762" title="All 2 branches covered.">            IntensityFeatureComparisonStats&gt;&gt; entry : index1StatsMap.entrySet()) {</span>
            
<span class="fc" id="L764">            Integer index1 = entry.getKey();</span>
            
<span class="fc" id="L766">            List&lt;CurvatureScaleSpaceContour&gt; contours = contours1Lists.get(index1.intValue());</span>
           
            // contours are ordered, so just need the first.
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">            if (contours.isEmpty()) {</span>
<span class="nc" id="L770">                continue;</span>
            }
<span class="fc" id="L772">            float peakSigma = contours.get(0).getPeakSigma();</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">            if (peakSigma &gt; maxPeakSigma) {</span>
<span class="fc" id="L774">                maxPeakSigma = peakSigma;</span>
            }
            // contour 6 is not a strong blob by has maxsigma=166 which is &gt;4*expected from 0
<span class="fc" id="L777">            index1PeakSigma.put(index1, Float.valueOf(peakSigma));</span>
<span class="fc" id="L778">        }</span>
        
<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (Entry&lt;Integer, Float&gt; entry : index1PeakSigma.entrySet()) {</span>
            
<span class="fc" id="L782">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L783">            double penalty = maxPeakSigma - entry.getValue().floatValue();</span>
            
<span class="fc" id="L785">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; index1Stats =</span>
<span class="fc" id="L786">                index1StatsMap.get(index1);</span>
            
<span class="fc bfc" id="L788" title="All 2 branches covered.">            for (int i = 0; i &lt; index1Stats.getNumberOfItems(); ++i) {</span>
                
<span class="fc" id="L790">                IntensityFeatureComparisonStats stats = index1Stats.getArray()[i];</span>
                                
<span class="fc" id="L792">                stats.setAdjustedCost(stats.getCost() + penalty);</span>
            }
<span class="fc" id="L794">        }</span>
<span class="fc" id="L795">    }</span>

    /**
     * bipartite matching after sorting by largest number of matches and lowest
     * cost then greedily choosing from that order.
     * @param index1StatsMap
     * @param n1
     * @param n2
     * @return 
     */
    private TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; 
    findBestMatchesUsingBipartite(Map&lt;Integer, 
        FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; index1StatsMap,
        int n1, int n2) {
        
<span class="fc" id="L810">        TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; matched = new</span>
            TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt;();
        
<span class="fc" id="L813">        int maxMatchable = 2 * Math.max(n1, n2);</span>
                
<span class="fc" id="L815">        double[] costs = new double[maxMatchable];</span>
<span class="fc" id="L816">        int[] idx1s = new int[maxMatchable];</span>
<span class="fc" id="L817">        int[] idx2s = new int[maxMatchable];</span>
<span class="fc" id="L818">        int[] nMatches = new int[maxMatchable];</span>
<span class="fc" id="L819">        IntensityFeatureComparisonStats[] ics = new IntensityFeatureComparisonStats[maxMatchable];</span>
        
<span class="fc" id="L821">        int count = 0;</span>
        for (Entry&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt;
<span class="fc bfc" id="L823" title="All 2 branches covered.">            entry : index1StatsMap.entrySet()) {</span>
<span class="fc" id="L824">            Integer index1 = entry.getKey();            </span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">            for (IntensityFeatureComparisonStats stats : entry.getValue().getArray()) {</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">                if (stats == null) {</span>
<span class="fc" id="L827">                    continue;</span>
                }
<span class="pc bpc" id="L829" title="3 of 4 branches missed.">                assert(index1.intValue() == stats.getIndex1());</span>
                
<span class="fc" id="L831">                idx1s[count] = stats.getIndex1();</span>
<span class="fc" id="L832">                idx2s[count] = stats.getIndex2();</span>
<span class="fc" id="L833">                ics[count] = stats;</span>
<span class="fc" id="L834">                nMatches[count] = stats.getComparisonStats().size();</span>
                
                //ssd of intensity is a better selector for one dataset. this may change w/ more testing
                //costs[count] = stats.getAdjustedCost();
<span class="fc" id="L838">                costs[count] = calculateCombinedIntensityStat(stats.getComparisonStats());</span>
                
<span class="fc" id="L840">                count++;</span>
            }
<span class="fc" id="L842">        }</span>
<span class="fc" id="L843">        costs = Arrays.copyOf(costs, count);</span>
<span class="fc" id="L844">        idx1s = Arrays.copyOf(idx1s, count);</span>
<span class="fc" id="L845">        idx2s = Arrays.copyOf(idx2s, count);</span>
<span class="fc" id="L846">        ics = Arrays.copyOf(ics, count);</span>
<span class="fc" id="L847">        nMatches = Arrays.copyOf(nMatches, count);</span>
<span class="fc" id="L848">        int[] lookupIndexes = new int[count];</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L850">            lookupIndexes[i] = i;</span>
        }
        
        //sort for the highest number of matches having the lowest costs.
        // decr nMatches, asc costs
<span class="fc" id="L855">        MultiArrayMergeSort.sortBy1stDescThen2ndAsc(nMatches, costs, lookupIndexes);</span>
        
        /*
        adding another filter based upon the SSD of intensity features for the
        top number of matches and lowest cost.
        This uses the average and standard deviation from it if there are
        more than 2 SSD stats and removes all other matches in the list
        where the SSD is larger than 2 sigma or so from that difference.
        It's not the most stable filter considering that some regions surrounding
        a contour may have extremely high variability, but it should usually be
        better to use this filter.
        
        Also, looks like it's necessary to filter for the difference in theta
        when it's much larger than the top difference in theta.
        */
<span class="fc" id="L870">        float[] ssdMeanStDv = calcIntensitySSDMeanAndStDev(</span>
<span class="fc" id="L871">            ics[lookupIndexes[0]].getComparisonStats());</span>
        
<span class="fc" id="L873">        float diffInThetaMean = calculateDiffThetaMean(ics[lookupIndexes[0]].getComparisonStats());</span>
        
<span class="fc" id="L875">        int count2 = 0;</span>
<span class="fc" id="L876">        double[] costs2 = new double[count];</span>
<span class="fc" id="L877">        int[] idx1s2 = new int[count];</span>
<span class="fc" id="L878">        int[] idx2s2 = new int[count];</span>
<span class="fc" id="L879">        int[] nMatches2 = new int[count];</span>
<span class="fc" id="L880">        IntensityFeatureComparisonStats[] ics2 = new IntensityFeatureComparisonStats[count];</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L882">            int idx0 = lookupIndexes[i];</span>
<span class="fc" id="L883">            IntensityFeatureComparisonStats ifcs = ics[idx0];</span>
<span class="fc" id="L884">            double ssd = calculateCombinedIntensityStat(ifcs.getComparisonStats());</span>
            
<span class="fc bfc" id="L886" title="All 2 branches covered.">            if (ssd &gt; (ssdMeanStDv[0] + (2 * ssdMeanStDv[1]))) {</span>
<span class="fc" id="L887">                continue;</span>
            }
                            
<span class="fc" id="L890">            float dtm = calculateDiffThetaMean(ifcs.getComparisonStats());</span>
                
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (Math.abs(dtm - diffInThetaMean) &gt; 20) {</span>
<span class="fc" id="L893">                continue;</span>
            }
                
<span class="fc" id="L896">            costs2[count2] = costs[i];</span>
<span class="fc" id="L897">            idx1s2[count2] = idx1s[idx0];</span>
<span class="fc" id="L898">            idx2s2[count2] = idx2s[idx0];</span>
<span class="fc" id="L899">            ics2[count2] = ics[idx0];</span>
<span class="fc" id="L900">            nMatches2[count2] = nMatches[i];</span>
<span class="fc" id="L901">            count2++;</span>
        }
<span class="fc" id="L903">        costs2 = Arrays.copyOf(costs2, count2);</span>
<span class="fc" id="L904">        idx1s2 = Arrays.copyOf(idx1s2, count2);</span>
<span class="fc" id="L905">        idx2s2 = Arrays.copyOf(idx2s2, count2);</span>
<span class="fc" id="L906">        ics2 = Arrays.copyOf(ics2, count2);</span>
<span class="fc" id="L907">        nMatches2 = Arrays.copyOf(nMatches2, count2);</span>
        
<span class="fc" id="L909">        Set&lt;Integer&gt; chosen1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L910">        Set&lt;Integer&gt; chosen2 = new HashSet&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L912" title="All 2 branches covered.">        for (int i = 0; i &lt; count2; ++i) {</span>
                        
<span class="fc" id="L914">            Integer index1 = Integer.valueOf(idx1s2[i]);</span>
<span class="fc" id="L915">            Integer index2 = Integer.valueOf(idx2s2[i]);</span>
            
<span class="fc bfc" id="L917" title="All 2 branches covered.">            if (chosen1.contains(index1)) {</span>
<span class="fc" id="L918">                continue;</span>
            }
<span class="fc bfc" id="L920" title="All 2 branches covered.">            if (chosen2.contains(index2)) {</span>
<span class="fc" id="L921">                continue;</span>
            }
            
<span class="fc" id="L924">            Double cost = Double.valueOf(costs2[i]);</span>
<span class="fc" id="L925">            IntensityFeatureComparisonStats ifcs = ics2[i];</span>
              
            // only true if still using costs rather than SSD:
            //assert(Math.abs(cost.doubleValue() - ifcs.getAdjustedCost()) &lt; 0.01);
            
            /*
            TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; matched
            */
<span class="fc" id="L933">            List&lt;IntensityFeatureComparisonStats&gt; ifcsList = matched.get(cost);</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">            if (ifcsList == null) {</span>
<span class="fc" id="L935">                ifcsList = new ArrayList&lt;IntensityFeatureComparisonStats&gt;();</span>
<span class="fc" id="L936">                matched.put(cost, ifcsList);</span>
            }
<span class="fc" id="L938">            ifcsList.add(ifcs);</span>
                
<span class="fc" id="L940">            chosen1.add(index1);</span>
<span class="fc" id="L941">            chosen2.add(index2);</span>
        }
        
<span class="fc" id="L944">        return matched;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
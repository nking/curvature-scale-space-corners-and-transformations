<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EdgeExtractorForBlobBorder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">EdgeExtractorForBlobBorder.java</span></div><h1>EdgeExtractorForBlobBorder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.ButterflySectionFinder;
import algorithms.compGeometry.ButterflySectionFinder.Routes;
import algorithms.compGeometry.PerimeterFinder;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

/**
 * 
 * @see AbstractEdgeExtractor

 * @author nichole
 */
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class EdgeExtractorForBlobBorder {</span>
            
<span class="fc" id="L27">    protected boolean debug = false;</span>
    
<span class="fc" id="L29">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L31">    public EdgeExtractorForBlobBorder() {</span>
                    
<span class="fc" id="L33">    }</span>
    
    public void setToDebug() {
<span class="fc" id="L36">        debug = true;</span>
<span class="fc" id="L37">    }</span>
    
    /*
     * NOT READY FOR USE.
     * given the set of contiguous points, find the perimeter of them and order
     * the points into a closed single pixel width curve.  
     * use extractAndOrderTheBorder0() instead for now.
     * @param contiguousPoints
     * @param imageWidth
     * @param imageHeight
     * @param discardWhenCavityIsSmallerThanBorder
     * @return 
    PairIntArray extractAndOrderTheBorder(Set&lt;PairInt&gt; contiguousPoints,
        int imageWidth, int imageHeight, boolean discardWhenCavityIsSmallerThanBorder) {
        
        if (contiguousPoints == null) {
            return null;
        }
   
if (debug) {
MiscDebug.plotPoints(contiguousPoints, imageWidth, imageHeight, MiscDebug.getCurrentTimeFormatted());        
}

        // ------- define the perimeter of contiguousPoints ----------

        PerimeterFinder perimeterFinder = new PerimeterFinder();
        
        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();
        
        int imageMaxColumn = imageWidth - 1;
        int imageMaxRow = imageHeight - 1;
       
        int[] rowMinMax = new int[2];
                
        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges = perimeterFinder.find(
            contiguousPoints, rowMinMax, imageMaxColumn, outputEmbeddedGapPoints);
       
        if (!outputEmbeddedGapPoints.isEmpty()) {
            // update the perimeter for &quot;filling in&quot; embedded points
            perimeterFinder.updateRowColRangesForAddedPoints(rowColRanges, 
                rowMinMax, imageMaxColumn, outputEmbeddedGapPoints);
        }
        
        // --- walk around the boundary of contiguousPoints, forming a closed curve path ----------
        PairIntArray out = perimeterFinder.getOrderedBorderPixels(
            contiguousPoints, rowColRanges, rowMinMax, imageMaxColumn, imageMaxRow);
  
        int nBorder = out.getN();
        int nCavity = contiguousPoints.size() + outputEmbeddedGapPoints.size()
            - nBorder;
               
        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();
        double[] xyCen = curveHelper.calculateXYCentroids(out);  
        
log.fine(String.format(&quot;LIMIT: (%d,%d) nPerimeter=%d nCavity=%d&quot;, (int)Math.round(xyCen[0]),
(int)Math.round(xyCen[1]), nBorder, nCavity));

        log.fine(&quot;LIMIT: number of border points=&quot; + nBorder + &quot; nCavity=&quot; + nCavity);
        
        if (discardWhenCavityIsSmallerThanBorder 
            &amp;&amp; ((nBorder &gt; 0.8*nCavity) &amp;&amp; 
                (Math.abs(nBorder - nCavity) &gt; 0.1*nCavity))) {
            return null;
        }
        
if (debug) {       
MiscDebug.plotPoints(out, imageWidth, imageHeight, MiscDebug.getCurrentTimeFormatted());
}
        return out;
    }
    */
    
    /**
     * given the set of contiguous points, find the perimeter of them and order
     * the points into a closed single pixel width curve.  For closed curves,
     * the points are ordered in counter clock-wise manner too (note, in
     * image frame where Y is 0 is upper left corner, CCW appears as CW
     * in image).
     * (Note, still testing this, but for structures without many junctions,
     * the results looks good so far.)
     * @param contiguousPoints
     * @param imageWidth
     * @param imageHeight
     * @param discardWhenCavityIsSmallerThanBorder
     * @return 
     */
    public PairIntArray extractAndOrderTheBorder0(Set&lt;PairInt&gt; contiguousPoints,
        int imageWidth, int imageHeight, boolean discardWhenCavityIsSmallerThanBorder) {
        
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (contiguousPoints == null) {</span>
<span class="nc" id="L127">            return null;</span>
        }
        
<span class="fc" id="L130">long ts = MiscDebug.getCurrentTimeFormatted(); </span>

        // ---- extract the border pixels from contiguousPoints ------

<span class="fc" id="L134">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>
        
<span class="fc" id="L136">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L138">        int imageMaxColumn = imageWidth - 1;</span>
<span class="fc" id="L139">        int imageMaxRow = imageHeight - 1;</span>
       
<span class="fc" id="L141">        int[] rowMinMax = new int[2];</span>
                
<span class="fc" id="L143">        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRanges = perimeterFinder.find(</span>
            contiguousPoints, rowMinMax, imageMaxColumn, outputEmbeddedGapPoints);
       
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (!outputEmbeddedGapPoints.isEmpty()) {</span>
            // update the perimeter for &quot;filling in&quot; embedded points
<span class="fc" id="L148">            perimeterFinder.updateRowColRangesForAddedPoints(rowColRanges, </span>
                rowMinMax, imageMaxColumn, outputEmbeddedGapPoints);
        }
       
<span class="fc" id="L152">        Set&lt;PairInt&gt; borderPixels = perimeterFinder.getBorderPixels(</span>
            rowColRanges, rowMinMax, imageMaxColumn, imageMaxRow);
        
<span class="fc" id="L155">        int nBorder = borderPixels.size();</span>
<span class="fc" id="L156">        int nCavity = contiguousPoints.size() + outputEmbeddedGapPoints.size()</span>
            - nBorder;

<span class="fc bfc" id="L159" title="All 2 branches covered.">if (debug) {        </span>
<span class="fc" id="L160">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">for (PairInt p : borderPixels) {</span>
<span class="fc" id="L162">    img3.setRGB(p.getX(), p.getY(), 255, 0, 0);</span>
<span class="fc" id="L163">}</span>
<span class="fc" id="L164">MiscDebug.writeImage(img3, &quot;border_perimeter_&quot; + ts);</span>
}
        
<span class="fc" id="L167">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="fc" id="L168">        double[] xyCen = curveHelper.calculateXYCentroids(borderPixels);  </span>
        
<span class="fc" id="L170">log.fine(String.format(&quot;LIMIT: (%d,%d) nPerimeter=%d nCavity=%d&quot;, (int)Math.round(xyCen[0]),</span>
<span class="fc" id="L171">(int)Math.round(xyCen[1]), nBorder, nCavity));</span>

        // expecting nBorder to be &lt; nCavity

<span class="fc bfc" id="L175" title="All 4 branches covered.">        if (discardWhenCavityIsSmallerThanBorder </span>
            &amp;&amp; ((nBorder &gt; 0.9*nCavity) &amp;&amp; 
<span class="fc bfc" id="L177" title="All 2 branches covered.">                (Math.abs(nBorder - nCavity) &gt; 0.1*nCavity))) {</span>
           
<span class="fc" id="L179">            log.info(String.format(</span>
                &quot;discarding (%d, %d) number of border points=%d nCavity=%d &quot;, 
<span class="fc" id="L181">                (int)Math.round(xyCen[0]), (int)Math.round(xyCen[1]), </span>
<span class="fc" id="L182">                nBorder, nCavity));</span>
            
<span class="fc" id="L184">            return null;</span>
        }
        
        // ----- remove spurs, merge curves, re-order points to form a 
        //       single closed curve if possible -------
        
<span class="fc" id="L190">log.fine(&quot;for &quot; + ts + &quot; starting additional line processing&quot;);</span>
/*
try {
Misc.persistToFile(&quot;blob_&quot; + ts + &quot;.dat&quot;, borderPixels);
int z = 1;
} catch(java.io.IOException e){}
*/
        // persist specific features to restore if thinned:
<span class="fc" id="L198">        ButterflySectionFinder finder = new ButterflySectionFinder();</span>
<span class="fc" id="L199">        List&lt;Routes&gt; butterFlySections = finder.findButterflySections(</span>
<span class="fc" id="L200">            Misc.convertWithoutOrder(borderPixels));</span>
        
<span class="fc" id="L202">        ZhangSuenLineThinner lt = new ZhangSuenLineThinner();</span>
<span class="fc" id="L203">        lt.applyLineThinner(borderPixels, 0, imageWidth, 0, imageHeight);</span>
<span class="fc" id="L204">        PostLineThinnerCorrections pltc = new PostLineThinnerCorrections();</span>
<span class="fc" id="L205">        pltc.correctForExtCorner(borderPixels, imageWidth, imageHeight);</span>
                
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (borderPixels.isEmpty()) {</span>
<span class="fc" id="L208">            return null;</span>
        }
        
        // restore butterFlySections if any
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">        if (butterFlySections != null &amp;&amp; !butterFlySections.isEmpty()) {</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            for (Routes butterFlySection : butterFlySections) {</span>
<span class="fc" id="L214">                borderPixels.addAll(butterFlySection.getRoute0());</span>
<span class="fc" id="L215">                borderPixels.addAll(butterFlySection.getRoute1());</span>
<span class="fc" id="L216">            }</span>
        }
        
<span class="fc bfc" id="L219" title="All 2 branches covered.">if (debug) {        </span>
<span class="fc" id="L220">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">for (PairInt p : borderPixels) {</span>
<span class="fc" id="L222">    img3.setRGB(p.getX(), p.getY(), 255, 0, 0);</span>
<span class="fc" id="L223">}</span>
<span class="fc" id="L224">MiscDebug.writeImage(img3, &quot;border_before_spur_removal_&quot; + ts);</span>
}
<span class="fc" id="L226">        SpurRemover spurRm = new SpurRemover();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L228">            spurRm.setToDebug();</span>
        }
<span class="fc" id="L230">        spurRm.remove(borderPixels, imageWidth, imageHeight);</span>
        
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (borderPixels.isEmpty()) {</span>
<span class="nc" id="L233">            return null;</span>
        }
       
<span class="fc bfc" id="L236" title="All 2 branches covered.">if (debug) {        </span>
<span class="fc" id="L237">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">for (PairInt p : borderPixels) {</span>
<span class="fc" id="L239">    img3.setRGB(p.getX(), p.getY(), 255, 0, 0);</span>
<span class="fc" id="L240">}</span>
<span class="fc" id="L241">MiscDebug.writeImage(img3, &quot;border_after_spur_removal_&quot; + ts);</span>
}
<span class="fc bfc" id="L243" title="All 2 branches covered.">if (debug) {     </span>
try {
<span class="fc" id="L245">Misc.persistToFile(</span>
&quot;tmp_blob_&quot; + ts + &quot;_&quot; + imageWidth + &quot;_&quot; + imageHeight + &quot;.dat&quot;, borderPixels);
<span class="fc" id="L247">log.info(&quot;for &quot; + ts + &quot; imageWidth=&quot; + imageWidth + &quot; imageHeight=&quot; + imageHeight);</span>
<span class="fc" id="L248">int z = 1;</span>
<span class="pc" id="L249">} catch(java.io.IOException e){}</span>
}

        // one more pass after line thinner and spur remover
<span class="fc" id="L253">        finder = new ButterflySectionFinder();</span>
<span class="fc" id="L254">        List&lt;Routes&gt; butterFlySections2 = finder.findButterflySections(</span>
<span class="fc" id="L255">            Misc.convertWithoutOrder(borderPixels));</span>
        
<span class="fc" id="L257">        Set&lt;PairInt&gt; exclude = new HashSet&lt;PairInt&gt;();</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">        if (butterFlySections != null &amp;&amp; !butterFlySections.isEmpty()) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">            for (Routes butterFlySection : butterFlySections) {</span>
<span class="fc" id="L260">                exclude.addAll(butterFlySection.getRoute0());</span>
<span class="fc" id="L261">                exclude.addAll(butterFlySection.getRoute1());</span>
<span class="fc" id="L262">            }</span>
        }
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (!butterFlySections2.isEmpty()) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for (Routes butterFlySection : butterFlySections2) {</span>
<span class="fc" id="L266">                exclude.addAll(butterFlySection.getRoute0());</span>
<span class="fc" id="L267">                exclude.addAll(butterFlySection.getRoute1());</span>
<span class="fc" id="L268">            }</span>
        }
        
<span class="fc" id="L271">log.fine(&quot;for &quot; + ts + &quot; start UntraversableLobeRemover&quot;);</span>

<span class="fc" id="L273">        UntraversableLobeRemover remover = new UntraversableLobeRemover();</span>
<span class="fc" id="L274">        remover.applyFilter(borderPixels, exclude, imageWidth, imageHeight);</span>
                
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (borderPixels.isEmpty()) {</span>
<span class="nc" id="L277">            return null;</span>
        }
        
<span class="fc bfc" id="L280" title="All 2 branches covered.">if (debug) {        </span>
<span class="fc" id="L281">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">for (PairInt p : borderPixels) {</span>
<span class="fc" id="L283">    img3.setRGB(p.getX(), p.getY(), 255, 0, 0);</span>
<span class="fc" id="L284">}</span>
<span class="fc" id="L285">MiscDebug.writeImage(img3, &quot;border_after_untraversable_removal_&quot; + ts);</span>
}
<span class="fc" id="L287">log.fine(&quot;for &quot; + ts + &quot; finished UntraversableLobeRemover&quot;);</span>

        //xMin, xMax, yMin, yMax
<span class="fc" id="L290">        int[] minMaxXY = MiscMath.findMinMaxXY(borderPixels);</span>
      
<span class="fc" id="L292">        int xOffset = minMaxXY[0] - 5;</span>
<span class="fc" id="L293">        int yOffset = minMaxXY[2] - 5;</span>
<span class="fc" id="L294">        int w = minMaxXY[1] - xOffset + 10;</span>
<span class="fc" id="L295">        int h = minMaxXY[3] - yOffset + 10;</span>
        
<span class="fc" id="L297">        GreyscaleImage img = new GreyscaleImage(w, h);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (PairInt p : borderPixels) {</span>
<span class="fc" id="L299">            int x = p.getX() - xOffset;</span>
<span class="fc" id="L300">            int y = p.getY() - yOffset;</span>
<span class="fc" id="L301">            img.setValue(x, y, 1);</span>
<span class="fc" id="L302">        }</span>
<span class="fc" id="L303">        img.setXRelativeOffset(xOffset);</span>
<span class="fc" id="L304">        img.setYRelativeOffset(yOffset);</span>
        
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (!butterFlySections2.isEmpty()) {</span>
            // remove offsets to put into same frame as img
            //NOTE: that some of these have been removed from the curve
<span class="fc" id="L309">            List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">            for (int i = 0; i &lt; butterFlySections2.size(); ++i) {</span>
<span class="fc" id="L311">                Routes routes = butterFlySections2.get(i);</span>
<span class="fc" id="L312">                routes.applyOffsets(-1*xOffset, -1*yOffset);</span>
<span class="fc" id="L313">                boolean rm = false;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                for (PairInt p : routes.getRoute0()) {</span>
<span class="pc bpc" id="L315" title="1 of 6 branches missed.">                    if (p.getX() &lt; 0 || p.getY() &lt; 0 || (p.getX() &gt; (w - 1)) ||</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                        (p.getY() &gt; (h - 1)) || </span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                        (img.getValue(p.getX(), p.getY()) == 0)) {</span>
<span class="fc" id="L318">                        rm = true;</span>
<span class="fc" id="L319">                        break;</span>
                    }
<span class="fc" id="L321">                }</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                if (!rm) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                    for (PairInt p : routes.getRoute1()) {</span>
<span class="pc bpc" id="L324" title="3 of 6 branches missed.">                        if (p.getX() &lt; 0 || p.getY() &lt; 0|| (p.getX() &gt; (w - 1)) ||</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                            (p.getY() &gt; (h - 1)) || </span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                            (img.getValue(p.getX(), p.getY()) == 0)) {</span>
<span class="nc" id="L327">                            rm = true;</span>
<span class="nc" id="L328">                            break;</span>
                        }
<span class="fc" id="L330">                    }</span>
                }
<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (rm) {</span>
<span class="fc" id="L333">                    remove.add(Integer.valueOf(i));</span>
                }
            }
<span class="fc bfc" id="L336" title="All 2 branches covered.">            for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L337">                int rmIdx = remove.get(i).intValue();</span>
<span class="fc" id="L338">                butterFlySections2.remove(rmIdx);</span>
            }
        }
        
<span class="fc bfc" id="L342" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L343">Image img2 = new Image(img.getWidth(), img.getHeight());</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">for (int col = 0; col &lt; img.getWidth(); ++col) {</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">    for (int row = 0; row &lt; img.getHeight(); ++row) {</span>
<span class="fc" id="L346">        int v = img.getValue(col, row);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (v &gt; 0) {</span>
<span class="fc" id="L348">            img2.setRGB(col, row, 255, 255, 255);</span>
        }
    }
}
<span class="fc" id="L352">MiscDebug.writeImage(img2, &quot;before_single_curve_extraction_&quot; + ts);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">for (Routes routes : butterFlySections2) {</span>
<span class="fc" id="L354">    Iterator&lt;PairInt&gt; iter = routes.getRoute0().iterator();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc" id="L356">        PairInt p = iter.next();</span>
<span class="fc" id="L357">        int r = img2.getR(p.getX(), p.getY());</span>
<span class="pc bpc" id="L358" title="3 of 4 branches missed.">        assert(r == 255);</span>
<span class="fc" id="L359">        img2.setRGB(p.getX(), p.getY(), 255, 0, 0);</span>
<span class="fc" id="L360">    }</span>
<span class="fc" id="L361">    iter = routes.getRoute1().iterator();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc" id="L363">        PairInt p = iter.next();</span>
<span class="fc" id="L364">        int r = img2.getR(p.getX(), p.getY());</span>
<span class="pc bpc" id="L365" title="3 of 4 branches missed.">        assert(r == 255);</span>
<span class="fc" id="L366">        img2.setRGB(p.getX(), p.getY(), 0, 0, 255);</span>
<span class="fc" id="L367">    }</span>
<span class="fc" id="L368">}</span>
<span class="fc" id="L369">MiscDebug.writeImage(img2, &quot;before_single_curve_extraction_&quot; + ts);</span>
}

<span class="fc" id="L372">        EdgeExtractorWithJunctions extractor = new EdgeExtractorWithJunctions(img);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L374">            extractor.setToDebug();</span>
        }
<span class="fc" id="L376">        extractor.overrideMaxNumberIterationsJunctionSplice(10);</span>
        
<span class="fc" id="L378">        PairIntArray out = extractor.findAsSingleClosedEdge(butterFlySections2);</span>
               
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (out == null) {</span>
<span class="fc" id="L381">            return null;</span>
        }
        
        /*
        some curves are originally composed of a single pixel width connector 
        between more than one potentially closed curve and the algorithm 
        eventually chooses the longest closed curve and follows the other out 
        until it ends without being adjacent to another point in the larger 
        curve.  in other words, these single pixel connections between
        multiple curves sometimes end in a long spur that should be trimmed.
        Note that the algorithm could be redesigned to look for such regions
        first and discard the smaller half with a warning.
        */
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (!curveHelper.isAdjacent(out, 0, out.getN() - 1)) {</span>
   
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">if (debug) {        </span>
<span class="nc" id="L397">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">for (int i = 0; i &lt; out.getN(); ++i) {</span>
<span class="nc" id="L399">    img3.setRGB(out.getX(i), out.getY(i), 255, 0, 0);</span>
}
<span class="nc" id="L401">img3.setRGB(out.getX(0), out.getY(0), 255, 255, 0);</span>
<span class="nc" id="L402">img3.setRGB(out.getX(out.getN() - 1), out.getY(out.getN() - 1), 255, 255, 0);</span>
<span class="nc" id="L403">MiscDebug.writeImage(img3, &quot;border_trimEndpointSpurs&quot;);</span>
}

<span class="fc" id="L406">            boolean altered = trimEndpointSpursIfAny(out, img.getWidth(), </span>
<span class="fc" id="L407">                img.getHeight());</span>

<span class="pc bpc" id="L409" title="1 of 2 branches missed.">if (debug) {        </span>
<span class="nc" id="L410">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">for (int i = 0; i &lt; out.getN(); ++i) {</span>
<span class="nc" id="L412">    img3.setRGB(out.getX(i), out.getY(i), 255, 0, 0);</span>
}
<span class="nc" id="L414">img3.setRGB(out.getX(0), out.getY(0), 255, 255, 0);</span>
<span class="nc" id="L415">img3.setRGB(out.getX(out.getN() - 1), out.getY(out.getN() - 1), 255, 255, 0);</span>
<span class="nc" id="L416">MiscDebug.writeImage(img3, &quot;border_before_reorder_endpoints&quot;);</span>
}

<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (!curveHelper.isAdjacent(out, 0, out.getN() - 1)) {</span>
                                
<span class="fc" id="L421">                extractor.reorderEndpointsIfNeeded(out);</span>
                
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">if (debug) {        </span>
<span class="nc" id="L424">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">for (int i = 0; i &lt; out.getN(); ++i) {</span>
<span class="nc" id="L426">    img3.setRGB(out.getX(i), out.getY(i), 255, 0, 0);</span>
}
<span class="nc" id="L428">img3.setRGB(out.getX(0), out.getY(0), 255, 255, 0);</span>
<span class="nc" id="L429">img3.setRGB(out.getX(out.getN() - 1), out.getY(out.getN() - 1), 255, 255, 0);</span>
<span class="nc" id="L430">MiscDebug.writeImage(img3, &quot;border_after_reorder_endpoints&quot;);</span>
}               

<span class="fc bfc" id="L433" title="All 2 branches covered.">                if (!curveHelper.isAdjacent(out, 0, out.getN() - 1)) {</span>
                    
<span class="fc" id="L435">                    trimForMultipleClosedCurves(extractor, out, img.getWidth(), </span>
<span class="fc" id="L436">                        img.getHeight());</span>
                    
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">if (debug) {        </span>
<span class="nc" id="L439">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">for (int i = 0; i &lt; out.getN(); ++i) {</span>
<span class="nc" id="L441">    img3.setRGB(out.getX(i), out.getY(i), 255, 0, 0);</span>
}
<span class="nc" id="L443">img3.setRGB(out.getX(0), out.getY(0), 255, 255, 0);</span>
<span class="nc" id="L444">img3.setRGB(out.getX(out.getN() - 1), out.getY(out.getN() - 1), 255, 255, 0);</span>
<span class="nc" id="L445">MiscDebug.writeImage(img3, &quot;border_trim_multiple_curves&quot;);</span>
<span class="nc" id="L446">int z = 1;</span>
}                    

                }
            }
        }
       
        // add the shifts back
        //PairIntArray out = output.get(0);
        
<span class="fc bfc" id="L456" title="All 2 branches covered.">        for (int i = 0; i &lt; out.getN(); ++i) {</span>
<span class="fc" id="L457">            int x = out.getX(i) + xOffset;</span>
<span class="fc" id="L458">            int y = out.getY(i) + yOffset;</span>
<span class="fc" id="L459">            out.set(i, x, y);</span>
        }

<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (curveHelper.isAdjacent(out, 0, out.getN() - 1)) {</span>
<span class="fc" id="L463">            boolean isCW = curveHelper.curveIsOrderedClockwise2(out);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            if (isCW) {</span>
<span class="fc" id="L465">                out.reverse();</span>
            }
        }
        
<span class="fc bfc" id="L469" title="All 2 branches covered.">if (debug) {</span>
<span class="fc" id="L470">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">for (int j = 0; j &lt; out.getN(); ++j) {</span>
<span class="fc" id="L472">    int x = out.getX(j);</span>
<span class="fc" id="L473">    int y = out.getY(j);</span>
<span class="fc bfc" id="L474" title="All 4 branches covered.">    if (j == 0 || (j == (out.getN() - 1))) {</span>
<span class="fc" id="L475">        ImageIOHelper.addPointToImage(x, y, img3, 0, 200, 150, 0);</span>
    } else {
<span class="fc" id="L477">        ImageIOHelper.addPointToImage(x, y, img3, 0, 255, 0, 0);</span>
    }
}
<span class="fc" id="L480">MiscDebug.writeImage(img3, &quot;output_&quot; + ts);</span>
}

<span class="fc" id="L483">        return out;</span>
    }

    private boolean trimEndpointSpursIfAny(final PairIntArray curve, 
        final int imageWidth, final int imageHeight) {

<span class="fc" id="L489">        boolean edited = false;</span>
        
<span class="fc" id="L491">        SpurRemover spurRemover = new SpurRemover();</span>
        
        // try beginning of curve        
        while (true) {
            
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">if (debug) {        </span>
<span class="nc" id="L497">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">for (int i = 0; i &lt; curve.getN(); ++i) {</span>
<span class="nc" id="L499">    int x = curve.getX(i);</span>
<span class="nc" id="L500">    int y = curve.getY(i);</span>
<span class="nc" id="L501">    img3.setRGB(x, y, 255, 0, 0);</span>
}
<span class="nc" id="L503">MiscDebug.writeImage(img3, &quot;before_trim_endpoints_&quot; + MiscDebug.getCurrentTimeFormatted());</span>
}      

<span class="fc" id="L506">            Set&lt;PairInt&gt; points = Misc.convert(curve);</span>
            
<span class="fc" id="L508">            int idx = 0;</span>
                
<span class="fc" id="L510">            int x = curve.getX(idx);                </span>
<span class="fc" id="L511">            int y = curve.getY(idx);</span>
                
<span class="fc" id="L513">            boolean isASpur = spurRemover.isASpur(x, y, points, imageWidth,</span>
                imageHeight);
                
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (isASpur) {</span>
                
<span class="fc" id="L518">                curve.removeRange(idx, idx);</span>
                
<span class="fc" id="L520">                edited = true;</span>
                
            } else {
                break;
            }
<span class="fc" id="L525">        }</span>
        
        // try end of curve        
        while (true) {

<span class="pc bpc" id="L530" title="1 of 2 branches missed.">if (debug) {        </span>
<span class="nc" id="L531">Image img3 = new Image(imageWidth, imageHeight);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">for (int i = 0; i &lt; curve.getN(); ++i) {</span>
<span class="nc" id="L533">    int x = curve.getX(i);</span>
<span class="nc" id="L534">    int y = curve.getY(i);</span>
<span class="nc" id="L535">    img3.setRGB(x, y, 255, 0, 0);</span>
}
<span class="nc" id="L537">MiscDebug.writeImage(img3, &quot;before_trim_endpoints_&quot; + MiscDebug.getCurrentTimeFormatted());</span>
}

<span class="fc" id="L540">            Set&lt;PairInt&gt; points = Misc.convert(curve);</span>
            
<span class="fc" id="L542">            int idx = (curve.getN() - 1);</span>
                
<span class="fc" id="L544">            int x = curve.getX(idx);                </span>
<span class="fc" id="L545">            int y = curve.getY(idx);</span>
                
<span class="fc" id="L547">            boolean isASpur = spurRemover.isASpur(x, y, points, imageWidth,</span>
                imageHeight);
                
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (isASpur) {</span>
                
<span class="fc" id="L552">                curve.removeRange(idx, idx);</span>
                
<span class="fc" id="L554">                edited = true;</span>
                
            } else {
                break;
            }
<span class="fc" id="L559">        }</span>
        
<span class="fc" id="L561">        return edited;</span>
    }

    private boolean trimForMultipleClosedCurves(final EdgeExtractorWithJunctions 
        extractor, final PairIntArray curve, int imageWidth, int imageHeight) {

<span class="fc" id="L567">        int idxA = extractor.findAdjacentToTopAtBottom(curve);</span>
        
<span class="fc" id="L569">        int idxB = extractor.findAdjacentToBottomAtTop(curve);</span>
        
<span class="pc bpc" id="L571" title="1 of 4 branches missed.">        if (idxA == -1 || idxB == -1) {</span>
<span class="fc" id="L572">            return false;</span>
        }
        
        /*
        TODO:
        revisit this...
        
        one case:
           idxA and idxB are both closer to same endpoint and are not the same
           number and the difference is small.
           this is potentially a knot in the curve, separated by a single
           width pixel curve (that therefore cannot be approaching the
           knot and leaving the knot).  If there's a single pixel width
           bottle neck in the region between them, can trim the whole
           section off.
        for idxA = 7 and idxB = 11,
        looking for when the path between them only has one choice, that is
        one neighbor other than the previous.  for that case, should be able
        to trim off the end section.
        
        0  41, 27
        1  41, 26
        2  41, 25
        3  40, 25
        
        6  39, 27
        7  40, 28 =======
        8  39, 28
           38, 28  &lt;- *
        10 37, 29  &lt;- *
        11 36, 29 =======
        12 36, 30
        ...
        n-1 35, 30
        */
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (idxA == idxB) {</span>
<span class="nc" id="L608">            return false;</span>
        }
        
<span class="fc" id="L611">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="fc" id="L612">        Set&lt;PairInt&gt; points = Misc.convert(curve);</span>
        
<span class="fc" id="L614">        double limit = Math.sqrt(2);</span>
        
<span class="fc" id="L616">        int mid = curve.getN() &gt;&gt; 1;</span>
        
<span class="pc bpc" id="L618" title="3 of 4 branches missed.">        boolean trimBeginning = ((idxA &lt; mid) &amp;&amp; (idxB &lt; mid));</span>
        
<span class="pc bpc" id="L620" title="2 of 4 branches missed.">        boolean trimEnd = ((idxA &gt; mid) &amp;&amp; (idxB &gt; mid));</span>
        
<span class="pc bpc" id="L622" title="2 of 4 branches missed.">        if (trimBeginning || trimEnd) {</span>
            
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">            if (idxB &lt; idxA) {</span>
<span class="nc" id="L625">                int swap = idxB;</span>
<span class="nc" id="L626">                idxB = idxA;</span>
<span class="nc" id="L627">                idxA = swap;</span>
            }
            
            // looking for the point between them where there is no
            // other point within a circular radius of 1            
<span class="fc bfc" id="L632" title="All 2 branches covered.">            for (int i = idxA; i &lt; idxB; ++i) {</span>
                
<span class="fc" id="L634">                int x1 = curve.getX(i);</span>
<span class="fc" id="L635">                int y1 = curve.getY(i);</span>
                
<span class="fc" id="L637">                Set&lt;PairInt&gt; neighbors1 = curveHelper.findNeighbors(x1, y1, </span>
                    points);
                
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">                if (neighbors1.size() == 2) {</span>
<span class="nc" id="L641">                    curve.removeRange(0, (idxB - 1));</span>
<span class="nc" id="L642">                    return true;</span>
                }
                
<span class="fc" id="L645">                PairInt p1 = new PairInt(x1, y1);</span>
                                
<span class="fc bfc" id="L647" title="All 2 branches covered.">                for (PairInt p2 : neighbors1) {</span>
                    
<span class="fc" id="L649">                    int x2 = p2.getX();</span>
<span class="fc" id="L650">                    int y2 = p2.getY();</span>
                    
<span class="fc" id="L652">                    float xMidPt = (x1 + x2)/2.f;</span>
<span class="fc" id="L653">                    float yMidPt = (y1 + y2)/2.f;</span>
                    
<span class="fc" id="L655">                    int nWithinR1 = 0;</span>
                    
<span class="fc" id="L657">                    Set&lt;PairInt&gt; neighbors2 = curveHelper.findNeighbors(x2, y2, </span>
                        points);
<span class="fc" id="L659">                    Set&lt;PairInt&gt; neighborsTot = new HashSet&lt;PairInt&gt;(neighbors1);</span>
<span class="fc" id="L660">                    neighborsTot.addAll(neighbors2);</span>
                    
<span class="fc bfc" id="L662" title="All 2 branches covered.">                    for (PairInt pt : neighborsTot) {</span>
                        
<span class="fc bfc" id="L664" title="All 4 branches covered.">                        if (pt.equals(p1) || pt.equals(p2)) {</span>
<span class="fc" id="L665">                            continue;</span>
                        }
                        
<span class="fc" id="L668">                        float diffX = Math.abs(xMidPt - pt.getX());</span>
<span class="fc" id="L669">                        float diffY = Math.abs(yMidPt - pt.getY());</span>
<span class="fc" id="L670">                        double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">                        if (dist &lt;= limit) {</span>
<span class="fc" id="L673">                            nWithinR1++;</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">                            if (nWithinR1 &gt; 1) {</span>
<span class="fc" id="L675">                                break;</span>
                            }
                        }
<span class="fc" id="L678">                    }</span>
                       
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                    if (nWithinR1 == 0) {</span>
                        
                        // only p1 and p2 within radius of 1 of midpt
<span class="nc bnc" id="L683" title="All 2 branches missed.">                        if (trimBeginning) {</span>
<span class="nc" id="L684">                            curve.removeRange(0, (idxB - 1));</span>
                        } else {
<span class="nc" id="L686">                            curve.removeRange((idxB + 1), curve.getN() - 1);</span>
                        }
                        
<span class="nc" id="L689">                        trimEndpointSpursIfAny(curve, imageWidth, imageHeight);</span>

<span class="nc" id="L691">                        return true;</span>
                    }
<span class="fc" id="L693">                }</span>
            }
        }
        
<span class="fc" id="L697">        return false;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
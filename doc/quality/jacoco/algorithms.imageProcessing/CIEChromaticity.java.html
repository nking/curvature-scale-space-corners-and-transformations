<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CIEChromaticity.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">CIEChromaticity.java</span></div><h1>CIEChromaticity.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.misc.MiscMath;
import java.util.ArrayList;
import java.util.List;

/**
 *  convenience methods for color space not present
    in jdk.
 * see http://hyperphysics.phy-astr.gsu.edu/hbase/vision/cie.html
 * and
 * http://en.wikipedia.org/wiki/CIE_1931_color_space#mediaviewer/File:CIE1931xy_blank.svg
 *
 * and
 *
 * @author nichole
 */
<span class="fc" id="L18">public class CIEChromaticity {</span>

    /**
     * the offset from (0.35, 0.35) considered &quot;white&quot;
     */
    private static final float deltaWhite = 0.0125f;

    /**
     * convert from CIE XYZ 1931, to CIE XY chromaticity 1931.
     *
     * useful for more information:
     * http://www.efg2.com/Lab/Graphics/Colors/Chromaticity.htm
     * http://en.wikipedia.org/wiki/CIE_1931_color_space
     * http://hyperphysics.phy-astr.gsu.edu/hbase/vision/cie.html
     *
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] rgbToXYChromaticity(int r, int g, int b) {

<span class="fc bfc" id="L40" title="All 6 branches covered.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
            // not really defined on the diagram since chromaticity is color
            // without intensity.  since all 0's is the lack of all color
            // will return 0,0, but it's N/A
<span class="fc" id="L44">            return new float[]{0, 0};</span>
        }

<span class="fc" id="L47">        float[] capXYZ = rgbToCIEXYZ(r, g, b);</span>

<span class="fc" id="L49">        float zz = capXYZ[0] + capXYZ[1] + capXYZ[2];</span>

<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        if (zz == 0.f) {</span>
<span class="nc" id="L52">            return new float[]{0, 0};</span>
        }

<span class="fc" id="L55">        float x = capXYZ[0]/zz;</span>

<span class="fc" id="L57">        float y = capXYZ[1]/zz;</span>

<span class="fc" id="L59">        return new float[]{x, y};</span>
    }

    /**
     * convert from CIE XYZ 1931, to CIE XY chromaticity 1931.
     *
     * useful for more information:
     * http://www.efg2.com/Lab/Graphics/Colors/Chromaticity.htm
     * http://en.wikipedia.org/wiki/CIE_1931_color_space
     * http://hyperphysics.phy-astr.gsu.edu/hbase/vision/cie.html
     *
     * expects r, g, b in range 0 to 255, inclusive.
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] _rgbToXYChromaticity(int r, int g, int b) {

<span class="nc bnc" id="L78" title="All 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
            // not really defined on the diagram since chromaticity is color
            // without intensity.  since all 0's is the lack of all color
            // will return 0,0, but it's N/A
<span class="nc" id="L82">            return new float[]{0, 0};</span>
        }
        
<span class="nc" id="L85">        return _rgbToXYChromaticity((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>
    }

    /**
     * convert from CIE XYZ 1931, to CIE XY chromaticity 1931.
     *
     * useful for more information:
     * http://www.efg2.com/Lab/Graphics/Colors/Chromaticity.htm
     * http://en.wikipedia.org/wiki/CIE_1931_color_space
     * http://hyperphysics.phy-astr.gsu.edu/hbase/vision/cie.html
     *
     * expects r, g, b in range 0 to 1.0, inclusive.
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] _rgbToXYChromaticity(float r, float g, float b) {

<span class="nc bnc" id="L104" title="All 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
            // not really defined on the diagram since chromaticity is color
            // without intensity.  since all 0's is the lack of all color
            // will return 0,0, but it's N/A
<span class="nc" id="L108">            return new float[]{0, 0};</span>
        }

<span class="nc" id="L111">        float[] capXYZ = _rgbToCIEXYZ(r, g, b);</span>

<span class="nc" id="L113">        float zz = capXYZ[0] + capXYZ[1] + capXYZ[2];</span>

<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (zz == 0.f) {</span>
<span class="nc" id="L116">            return new float[]{0, 0};</span>
        }

<span class="nc" id="L119">        float x = capXYZ[0]/zz;</span>

<span class="nc" id="L121">        float y = capXYZ[1]/zz;</span>

<span class="nc" id="L123">        return new float[]{x, y};</span>
    }

    // NOTE: not thread safe:
<span class="fc" id="L127">    private float[] cieXYTmpHolder = new float[3];</span>
    /**
     * convert from CIE XYZ 1931, to CIE XY chromaticity 1931.
     *
     * useful for more information:
     * http://www.efg2.com/Lab/Graphics/Colors/Chromaticity.htm
     * http://en.wikipedia.org/wiki/CIE_1931_color_space
     * http://hyperphysics.phy-astr.gsu.edu/hbase/vision/cie.html
     *
     * @param r
     * @param g
     * @param b
     * @param outputcieXY the float array of length 2 that the output will be
     * placed in.
     */
    public void rgbToXYChromaticity(int r, int g, int b, float[] outputcieXY) {

<span class="nc bnc" id="L144" title="All 4 branches missed.">        if (outputcieXY == null || outputcieXY.length != 2) {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;outputcieXY must be length 2&quot;);</span>
        }

<span class="nc bnc" id="L148" title="All 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
            // not really defined on the diagram since chromaticity is color
            // without intensity.  since all 0's is the lack of all color
            // will return 0,0, but it's N/A
<span class="nc" id="L152">            outputcieXY[0] = 0;</span>
<span class="nc" id="L153">            outputcieXY[1] = 0;</span>
<span class="nc" id="L154">            return;</span>
        }

<span class="nc" id="L157">        rgbToCIEXYZ(r, g, b, cieXYTmpHolder);</span>

<span class="nc" id="L159">        float x = cieXYTmpHolder[0]/(cieXYTmpHolder[0] + cieXYTmpHolder[1] + cieXYTmpHolder[2]);</span>

<span class="nc" id="L161">        float y = cieXYTmpHolder[1]/(cieXYTmpHolder[0] + cieXYTmpHolder[1] + cieXYTmpHolder[2]);</span>

<span class="nc" id="L163">        outputcieXY[0] = x;</span>
<span class="nc" id="L164">        outputcieXY[1] = y;</span>
<span class="nc" id="L165">    }</span>

    /**
     * convert rgb to CIE LAB.
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * range of return values is
     * &lt;pre&gt;
     *    L    0 to 28.5
     *    A  -46.9  62.5
     *    B  -45.7  48.0
     * &lt;/pre&gt;
     *
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] rgbToCIELAB(int r, int g, int b) {

<span class="pc bpc" id="L187" title="6 of 12 branches missed.">        if (r &lt; 0 || r &gt; 255 || g &lt; 0 || g &gt; 255 || b &lt; 0 || b &gt; 255) {</span>
<span class="nc" id="L188">            throw new IllegalArgumentException(&quot;r, g, and b must be 0 to 255&quot;);</span>
        }
<span class="fc bfc" id="L190" title="All 6 branches covered.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="fc" id="L191">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L194">        float[] a = _rgbToCIEXYZ(r, g, b);</span>

<span class="fc" id="L196">        a = cieXYZToCIELAB(a);</span>
        
<span class="fc" id="L198">        return a;</span>
    }

    /**
     * convert rgb to CIE LAB 1931.
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * range of return values for
     * L* 0 to 105
     * a* -190 to 103
     * b* -113 to 99
     *
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] rgbToCIELAB1931(int r, int g, int b) {

<span class="pc bpc" id="L219" title="5 of 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="nc" id="L220">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L223">        float[] a = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="fc" id="L225">        a = cieXYZToCIELAB(a);</span>

<span class="fc" id="L227">        return a;</span>
    }

    /**
     * convert rgb to CIE LCH, polar coordinates of CIELAB1931.
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * range of return values for
     * L* 0 to 105
     * c  0 to 139
     * h  0 to 359
     *
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] rgbToCIELCH(int r, int g, int b) {

<span class="pc bpc" id="L248" title="1 of 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="fc" id="L249">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L252">        float[] xyz = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="fc" id="L254">        float[] lch = cieXYZToCIELCH(xyz);</span>

<span class="fc" id="L256">        return lch;</span>
    }

    /**
     * convert rgb to polar coordinates of CIELUV (a.k.a. CIEL*A*B* 1976?)
     *
     * CIE 1976 (L*, u*, v*).
     * 
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * &lt;pre&gt;
     * using the standard illuminant of daylight, D65,
     * the range of return values is
     range of CIE LUV using default standard illumination of
        D65 daylight is:
        L       0 to 104.5
        u   -86.9 to 183.8
        v  -141.4 to 112.3
        luminosity L*  0 to 104.5
        magnitude, m:  sqrt(2) * 183.8 = 260
        angle,     a:  0 to 359
     * &lt;/pre&gt;
     * @param r in range 0 to 255, inclusive
     * @param g in range 0 to 255, inclusive
     * @param b in range 0 to 255, inclusive
     * @return luv[0], (float)m, (float)t where
     * the first item is luminosity, the
     * second is the magnitude of the color, that
     * is sqrt of square sums of U and V,
     * and the third is the polar theta angle
     */
    public float[] rgbToPolarCIELUV(int r, int g, int b) {

<span class="fc bfc" id="L290" title="All 6 branches covered.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="fc" id="L291">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L294">        float[] xyz = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="fc" id="L296">        float[] luv = cieXYZToCIELUV(xyz);</span>

<span class="fc" id="L298">        double t = Math.atan2(luv[2], luv[1]);</span>
<span class="fc" id="L299">        t *= (180. / Math.PI);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (t &lt; 0) {</span>
<span class="fc" id="L301">            t += 360;</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        } else if (t &gt; 359) {</span>
<span class="nc" id="L303">            t -= 360;</span>
        }

<span class="fc" id="L306">        double m = Math.sqrt(luv[1]*luv[1] + luv[2]*luv[2]);</span>

<span class="fc" id="L308">        return new float[]{luv[0], (float)m, (float)t};</span>
    }

    /**
     * convert rgb to polar coordinates of CIELUV.
     *  CIE 1976 (L*, u*, v*) 
     * 
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * range of return values for
     * L*
     * magnitude:
     * angle:      0 to 359
     *
     * @param r
     * @param g
     * @param b
     * @param Xn standard illuminant
     * @param Yn standard illuminant
     * @param Zn standard illuminant
     * @return
     */
    public float[] rgbToPolarCIELUV(int r, int g, int b, float Xn, float Yn,
        float Zn) {

<span class="fc bfc" id="L334" title="All 6 branches covered.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="fc" id="L335">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L338">        float[] xyz = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="fc" id="L340">        float[] luv = cieXYZToCIELUV(xyz, Xn, Yn, Zn);</span>

<span class="fc" id="L342">        double t = Math.atan2(luv[2], luv[1]);</span>
<span class="fc" id="L343">        t *= (180. / Math.PI);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (t &lt; 0) {</span>
<span class="fc" id="L345">            t += 360;</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        } else if (t &gt; 359) {</span>
<span class="nc" id="L347">            t -= 360;</span>
        }

<span class="fc" id="L350">        double m = Math.sqrt(luv[1]*luv[1] + luv[2]*luv[2]);</span>

<span class="fc" id="L352">        return new float[]{luv[0], (float)m, (float)t};</span>
    }
    
    /**
     * convert rgb to CIELUV. CIE 1976 (L*, u*, v*) 
     * 
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * uses standard illuminant &quot;wide range lightness&quot;.
     * Wide-range Lightness data were generated by Fairchild et al., 
     * who conducted two different experiments to scale lightness above and 
     * below diffuse white (CIE * L = 100 ). 
     * In the Scaling Lightness Experiment 1 (SL1) they used a luminance
       range from 156 to 2 3692cd m with 2 842 Y cd m n = 
       (Yn represents the luminance of reference white) 
      whereas in the Scaling Lightness Experiment 2 (SL2) the
      luminance range was extended from 0 to 2 7432cd m with 2 997 Y cd m n = . 
     The SL2 data set was used to drive the adapted lightness ( z J ) 
     formula of the proposed color space (see later) while the SL1 data set was 
     used as a test data set. Each of the sets includes 19 samples. 

     * https://www.osapublishing.org/DirectPDFAccess/B810E9AE-C7C9-E594-C72DC7FBE1424F0A_368272/oe-25-13-15131.pdf?da=1&amp;id=368272&amp;seq=0&amp;mobile=no
     * 
     * SL2 Training D65/2° (x,y,z)=968.08 997 883.51 
     * L_a=199 
     * C=0.69. N_C=1, F=1 
     * 
     * range of return values is:
     * L       0 to 104.8
     * u   -99.9 to 176.8
     * v  -150.0 to 95.0
     * 
     * @param r in range 0 to 255, inclusive
     * @param g in range 0 to 255, inclusive
     * @param b in range 0 to 255, inclusive
     * @return
     */
    public float[] rgbToCIELUV_WideRangeLightness(int r, int g, int b) {

<span class="fc bfc" id="L392" title="All 6 branches covered.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="fc" id="L393">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L396">        float Xn = 96.808f;//0.96808f;</span>
<span class="fc" id="L397">        float Yn = 99.7f;//0.997f;</span>
<span class="fc" id="L398">        float Zn = 88.35f;//0.88351f;</span>
        
<span class="fc" id="L400">        float[] xyz = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="fc" id="L402">        float[] luv = cieXYZToCIELUV(xyz, Xn, Yn, Zn);</span>

<span class="fc" id="L404">        return luv;</span>
    }

    /**
     * convert rgb to CIE LUV (a.k.a. CIEL*A*B* 1976)
     * CIE 1976 (L*, u*, v*) 
     * 
     * Note that differences in CIELUV are simply the differences
     * in each component added in quadrature (no deltaE formula).
     * 
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16
     *
     * range of return values when using default standard illumination of
     * D65 daylight is:
     * L       0 to 104.5
     * u   -86.9 to 183.8
     * v  -141.4 to 112.3
     *
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] rgbToCIELUV(int r, int g, int b) {

<span class="fc bfc" id="L431" title="All 6 branches covered.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="fc" id="L432">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L435">        float[] a = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="fc" id="L437">        a = cieXYZToCIELUV(a);</span>

<span class="fc" id="L439">        return a;</span>
    }

    /**
     * convert rgb to CIE LUV (a.k.a. CIEL*A*B* 1976?)
     * CIE 1976 (L*, u*, v*) 
     * and use the given standard illumination in tristimulus coordinates.
     * 
      &lt;pre&gt;
      Incandescent:
          109.850, 100, 35.585
          range of return values for incandescent
           L       0 to 104.5
           u  -156.2 to 141.6
           v  -172.0 to 45.6
      Daylight, midday (D65):
          95.047, 100, 108.883
          range of return values for D65
           L       0 to 104.5
           u   -86.9 to 183.8
           v  -141.4 to 112.3
      Fluorescent:
          99.187, 100, 67.395
          range of return values for Fluorescent
           L       0 to 104.5
           u  -113.6 to 167.5
           v  -158.5 to 75.0
      D75:
          94.972,  100, 122.638
          range of return values for D75
           L       0 to 104.5
           u   -81.7 to 186.9
           v  -136.2 to 124.5
      &lt;/pre&gt;
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     * and http://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16
     
     * @param r
     * @param g
     * @param b
     * @param Xn standard illuminant X
     * @param Yn standard illuminant Y
     * #param Zn standard illuminant Z
     * @return
     */
    public float[] rgbToCIELUV(int r, int g, int b,
        float Xn, float Yn, float Zn) {

<span class="nc bnc" id="L488" title="All 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="nc" id="L489">            return new float[]{0, 0, 0};</span>
        }
        
<span class="nc" id="L492">        float[] a = _rgbToCIEXYZ2((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>

<span class="nc" id="L494">        a = cieXYZToCIELUV(a, Xn, Yn, Zn);</span>

<span class="nc" id="L496">        return a;</span>
    }

    /**
     * convert rgb to CIE XYZ (1931).
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     *
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] rgbToCIEXYZ(int r, int g, int b) {

        /*
            | X |       1     | 0.49     0.31      0.20     |   | R |
            | Y | = --------- | 0.17697  0.81240   0.01063  | * | G |
            | Z |    0.17697  | 0.00     0.01      0.99     |   | B |

        0.436  0.385  0.143
        0.222  0.7169 0.0606
        0.0139 0.097  0.7139
        */

<span class="fc" id="L521">        float capX = (0.49f * r +  0.31f * g + 0.20f * b)/0.17697f;</span>

<span class="fc" id="L523">        float capY = (0.17697f * r +  0.81240f * g + 0.01063f * b)/0.17697f;</span>

<span class="fc" id="L525">        float capZ = (0.01f * g + 0.99f * b)/0.17697f;</span>

<span class="fc" id="L527">        return new float[]{capX, capY, capZ};</span>
    }

    /**
     * convert rgb to CIE XYZ (1931).
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     *
     * normalizes the r,g,b values to lie between 0 and 1.0 assuming the
     * arguments are given as a range 0 to 255.
     *
     * for r=0, g=0, b=0, CIEXY is (0, 0, 0).
     * for r=1, g=1, b=1, CIEXY is (5.65, 5.65, 5.65)
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] _rgbToCIEXYZ(int r, int g, int b) {

<span class="pc bpc" id="L547" title="1 of 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="nc" id="L548">            return new float[]{0, 0, 0};</span>
        }
        
<span class="fc" id="L551">        return _rgbToCIEXYZ((float)r/255.f, (float)g/255.f, (float)b/255.f);</span>
    }

    /**
     * convert rgb to CIE XYZ (1931).
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     *
     * expects r,g,b values between 0 and 1, inclusive.
     *
     * for r=0, g=0, b=0, CIEXY is (0, 0, 0).
     * for r=1, g=1, b=1, CIEXY is (5.65, 5.65, 5.65)
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] _rgbToCIEXYZ(float r, float g, float b) {

        /*
            | X |       1     | 0.49     0.31      0.20     |   | R |
            | Y | = --------- | 0.17697  0.81240   0.01063  | * | G |
            | Z |    0.17697  | 0.00     0.01      0.99     |   | B |

        D50 matrix:
        0.436  0.385  0.143
        0.222  0.7169 0.0606
        0.0139 0.097  0.7139
        */

<span class="fc" id="L581">        float capX = (0.49f * r +  0.31f * g + 0.20f * b)/0.17697f;</span>

<span class="fc" id="L583">        float capY = (0.17697f * r +  0.81240f * g + 0.01063f * b)/0.17697f;</span>

<span class="fc" id="L585">        float capZ = (0.01f * g + 0.99f * b)/0.17697f;</span>

<span class="fc" id="L587">        return new float[]{capX, capY, capZ};</span>
    }

    /**
     * convert rgb to CIE XYZ (1931).
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     *
     * expects r,g,b values between 0 and 1, inclusive.
     *
     * for r=0, g=0, b=0, CIEXY is (0, 0, 0).
     * for r=1, g=1, b=1, CIEXY is (5.65, 5.65, 5.65)
     * @param r
     * @param g
     * @param b
     * @return
     */
    public float[] _rgbToCIEXYZ2(float r, float g, float b) {

<span class="pc bpc" id="L606" title="1 of 6 branches missed.">        if ((r == 0) &amp;&amp; (g == 0) &amp;&amp; (b == 0)) {</span>
<span class="nc" id="L607">            return new float[]{0, 0, 0};</span>
        }
        
        //http://www.easyrgb.com/index.php?X=MATH&amp;H=02#text2

<span class="fc" id="L612">        float fR = 0;</span>
<span class="fc" id="L613">        float fG = 0;</span>
<span class="fc" id="L614">        float fB = 0;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
            double d;
<span class="fc bfc" id="L617" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L618">                d = r;</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            } else if (i == 1) {</span>
<span class="fc" id="L620">                d = g;</span>
            } else {
<span class="fc" id="L622">                d = b;</span>
            }
            double f;
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (d &gt; 0.04045) {</span>
<span class="fc" id="L626">                f = Math.pow(d + 0.055/1.055, 2.4);</span>
            } else {
<span class="fc" id="L628">                f = d/12.92;</span>
            }
<span class="fc" id="L630">            f *= 100.f;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L632">                fR = (float)f;</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">            } else if (i == 1) {</span>
<span class="fc" id="L634">                fG = (float)f;</span>
            } else {
<span class="fc" id="L636">                fB = (float)f;</span>
            }
        }

<span class="fc" id="L640">        float capX = fR * 0.4124f + fG * 0.3576f + fB * 0.1805f;</span>
<span class="fc" id="L641">        float capY = fR * 0.2126f + fG * 0.7152f + fB * 0.0722f;</span>
<span class="fc" id="L642">        float capZ = fR * 0.0193f + fG * 0.1192f + fB * 0.9505f;</span>

<span class="fc" id="L644">        return new float[]{capX, capY, capZ};</span>
    }

    /**
     * convert CIE XYZ (1931) to CIE LAB.
     *
     * uses https://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * L is from 0 to 100
     * a is from - to +  (negative are green, pos are red)
     * b is from - to +  (negative are blue, pos are yellow)
     *
     * to change the reference point, see
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=15#text15
     *
     *
     * @param cieXYZ
     * @return
     */
    public float[] cieXYZToCIELAB(float[] cieXYZ) {

        /*
        Incandescent:
            109.850, 100, 35.585
        Daylight, midday (D65):
            95.047, 100, 108.883
        Fluorescent:
            99.187, 100, 67.395

        D75:
           94.972,  100, 122.638


        would like tristimulus colors for a range of cloud and shade
        conditions.  Mie scattering for clouds and Rayleigh scattering for air,
        then consideration for aerosols... these aren't single scattering
        conditions, so empirically gathered data might be more useful to derive
        ranges from...many interesting databases with relevant data...
        */

<span class="fc" id="L684">        float Xn = 95.047f;</span>
<span class="fc" id="L685">        float Yn = 100.0f;</span>
<span class="fc" id="L686">        float Zn = 108.883f;</span>

<span class="fc" id="L688">        return cieXYZToCIELAB(cieXYZ, Xn, Yn, Zn);</span>
    }

    /**
     * convert CIE XYZ (1931) to cylindrical LCH
     * where H is the polar angle between V and U and C is the
     * magnitude of that vector.
     *
     * uses https://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=15#text15
     *
     * @param cieXYZ
     * @return
     */
    public float[] cieXYZToCIELCH(float[] cieXYZ) {

        /*
        Incandescent:
            109.850, 100, 35.585
        Daylight, midday (D65):
            95.047, 100, 108.883
        Fluorescent:
            99.187, 100, 67.395

        D75:
           94.972,  100, 122.638


        would like tristimulus colors for a range of cloud and shade
        conditions.  Mie scattering for clouds and Rayleigh scattering for air,
        then consideration for aerosols... these aren't single scattering
        conditions, so empirically gathered data might be more useful to derive
        ranges from...many interesting databases with relevant data...
        */

<span class="fc" id="L724">        float Xn = 95.047f;</span>
<span class="fc" id="L725">        float Yn = 100.0f;</span>
<span class="fc" id="L726">        float Zn = 108.883f;</span>

<span class="fc" id="L728">        float[] lab = cieXYZToCIELAB(cieXYZ, Xn, Yn, Zn);</span>

<span class="fc" id="L730">        double t = Math.atan2(lab[2], lab[1]);</span>
<span class="fc" id="L731">        t *= (180. / Math.PI);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        if (t &lt; 0) {</span>
<span class="fc" id="L733">            t += 360;</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        } else if (t &gt; 359) {</span>
<span class="nc" id="L735">            t -= 360;</span>
        }

<span class="fc" id="L738">        double m = Math.sqrt(lab[1]*lab[1] + lab[2]*lab[2]);</span>

<span class="fc" id="L740">        return new float[]{lab[0], (float)m, (float)t};</span>
    }

    /**
     * convert CIE XYZ (1931) to CIE LUV.
     * CIE 1976 (L*, u*, v*) 
     * 
     * uses https://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=15#text15
     *
     * @param cieXYZ
     * @return
     */
    public float[] cieXYZToCIELUV(float[] cieXYZ) {

        /*
        Incandescent:
            109.850, 100, 35.585
        Daylight, midday (D65):
            95.047, 100, 108.883
        Fluorescent:
            99.187, 100, 67.395

        D75:
           94.972,  100, 122.638


        would like tristimulus colors for a range of cloud and shade
        conditions.  Mie scattering for clouds and Rayleigh scattering for air,
        then consideration for aerosols... these aren't single scattering
        conditions, so empirically gathered data might be more useful to derive
        ranges from...many interesting databases with relevant data...
        */

<span class="fc" id="L775">        float Xn = 95.047f;</span>
<span class="fc" id="L776">        float Yn = 100.0f;</span>
<span class="fc" id="L777">        float Zn = 108.883f;</span>

<span class="fc" id="L779">        return cieXYZToCIELUV(cieXYZ, Xn, Yn, Zn);</span>
    }

    /**
     * convert CIE XYZ (1931) to CIE LUV.
     * CIE 1976 (L*, u*, v*) 
     * 
     * uses https://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=15#text15
     *
     * @param cieXYZ
     * @param Xn standard illuminant X
     * @param Yn standard illuminant Y
     * @param Zn standard illuminant Z
     * @return
     */
    public float[] cieXYZToCIELUV(float[] cieXYZ, float Xn, float Yn, float Zn) {

<span class="fc" id="L798">        float[] lab = cieXYZToCIELAB(cieXYZ, Xn, Yn, Zn);</span>

<span class="pc bpc" id="L800" title="5 of 6 branches missed.">        if (lab[0] == 0 &amp;&amp; lab[1] == 0 &amp;&amp; lab[2] == 0) {</span>
<span class="nc" id="L801">            return lab;</span>
        }
        
<span class="fc" id="L804">        float u = (4.f * cieXYZ[0]) /</span>
            (cieXYZ[0] + (15.f * cieXYZ[1]) + (3.f * cieXYZ[2]));

<span class="fc" id="L807">        float v = (9.f * cieXYZ[1]) /</span>
            (cieXYZ[0] + (15.f * cieXYZ[1]) + (3.f * cieXYZ[2]));

<span class="fc" id="L810">        float y = cieXYZ[1]/100.f;</span>

<span class="fc bfc" id="L812" title="All 2 branches covered.">        if (y &gt; 0.008856) {</span>
<span class="fc" id="L813">            y = (float)Math.pow(y, 1./3.);</span>
        } else {
<span class="fc" id="L815">            y = (7.787f * y) + (16.f / 116.f);</span>
        }

<span class="fc" id="L818">        float Un = (4.f * Xn) / (Xn + (15.f * Yn) + (3.f * Zn));</span>
<span class="fc" id="L819">        float Vn = (9.f * Yn) / (Xn + (15.f * Yn) + (3.f * Zn));</span>

<span class="fc" id="L821">        float cieL = (116.f * y) - 16.f;</span>
<span class="fc" id="L822">        float cieU = 13.f * cieL * (u - Un);</span>
<span class="fc" id="L823">        float cieV = 13.f * cieL * (v - Vn);</span>

<span class="fc" id="L825">        return new float[] {cieL, cieU, cieV};</span>
    }

    /**
     * convert CIE XYZ (1931) to CIE LAB.
     *
     * uses https://en.wikipedia.org/wiki/Lab_color_space#Forward_transformation
     *
     * L is from 0 to 100
     * a is from - to +  (negative are green, pos are red)
     * b is from - to +  (negative are blue, pos are yellow)
     *
     * to change the reference point, see
     * http://www.easyrgb.com/index.php?X=MATH&amp;H=15#text15
     *
     *
     * @param cieXYZ
     * @param Xn standard illuminant X
     * @param Yn standard illuminant Y
     * @param Zn standard illuminant Z
     * @return
     */
    public float[] cieXYZToCIELAB(float[] cieXYZ, float Xn, float Yn, float Zn) {

<span class="fc" id="L849">        float xDiv = cieXYZ[0]/Xn;</span>
<span class="fc" id="L850">        float yDiv = cieXYZ[1]/Yn;</span>
<span class="fc" id="L851">        float zDiv = cieXYZ[2]/Zn;</span>

<span class="fc" id="L853">        double deltaSq = (6./29.)*(6./29.);</span>
<span class="fc" id="L854">        double deltaCubed = deltaSq * (6./29.);</span>
<span class="fc" id="L855">        float fX = 0;</span>
<span class="fc" id="L856">        float fY = 0;</span>
<span class="fc" id="L857">        float fZ = 0;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
            double d;
<span class="fc bfc" id="L860" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L861">                d = xDiv;</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">            } else if (i == 1) {</span>
<span class="fc" id="L863">                d = yDiv;</span>
            } else {
<span class="fc" id="L865">                d = zDiv;</span>
            }
            double f;
<span class="fc bfc" id="L868" title="All 2 branches covered.">            if (d &gt; deltaCubed) {</span>
<span class="fc" id="L869">                f = Math.pow(d, 1./3.);</span>
            } else {
<span class="fc" id="L871">                f = (d/(3.*deltaSq)) + (4./29.);</span>
            }
<span class="fc bfc" id="L873" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L874">                fX = (float)f;</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">            } else if (i == 1) {</span>
<span class="fc" id="L876">                fY = (float)f;</span>
            } else {
<span class="fc" id="L878">                fZ = (float)f;</span>
            }
        }

<span class="fc" id="L882">        float ell = (116.f * fY) - 16.f;</span>
<span class="fc" id="L883">        float a = 500.f * (fX - fY);</span>
<span class="fc" id="L884">        float b = 200.f * (fY - fZ);</span>

<span class="fc" id="L886">        return new float[]{ell, a, b};</span>
    }

    /**
     * calculate the CIE76 delta E for 2 sets of CIE LAB.
     *
     * uses https://en.wikipedia.org/wiki/Color_difference
     *
     * the &quot;Just noticeable difference&quot;, JND, begins at E_ab ~ 2.3
     *
     * @param cieLAB1
     * @param cieLAB2
     * @return deltaE
     */
    public double calcDeltaECIE76(float[] cieLAB1, float[] cieLAB2) {

<span class="nc" id="L902">        double eAB = Math.sqrt(</span>
            ((cieLAB2[0] - cieLAB1[0])*(cieLAB2[0] - cieLAB1[0])) +
            ((cieLAB2[1] - cieLAB1[1])*(cieLAB2[1] - cieLAB1[1])) +
            ((cieLAB2[2] - cieLAB1[2])*(cieLAB2[2] - cieLAB1[2])));

<span class="nc" id="L907">        return eAB;</span>
    }

    /**
     * calculate the CIE76 delta E for 2 sets of CIE LAB.
     *
     * uses https://en.wikipedia.org/wiki/Color_difference
     *
     * the &quot;Just noticeable difference&quot;, JND, begins at E_ab ~ 2.3
     *
     * the range of resulting values is 0 through 28.78.
     *
     * @param cieLAB1
     * @param cieLAB2
     * @return deltaE
     */
    public double calcDeltaECIE94(float[] cieLAB1, float[] cieLAB2) {

<span class="nc" id="L925">        return calcDeltaECIE94(cieLAB1[0], cieLAB1[1], cieLAB1[2], cieLAB2[0],</span>
            cieLAB2[1], cieLAB2[2]);

    }

    /**
     * calculate the delta E 1994 for 2 sets of CIE LAB.
     *
     * uses https://en.wikipedia.org/wiki/Color_difference
     *
     * the &quot;Just noticeable difference&quot;, JND, begins at E_ab ~ 2.3.
     *
     * the range of resulting values is 0 through 28.78.
     *
     * @return deltaE
     */
    public double calcDeltaECIE94(float ell1, float a1, float b1,
        float ell2, float a2, float b2) {

        // use graphic arts or textiles approx for K's
<span class="nc" id="L945">        boolean useGA = true;</span>
        double kL, K1, K2;
<span class="nc bnc" id="L947" title="All 2 branches missed.">        if (useGA) {</span>
<span class="nc" id="L948">            kL = 1;</span>
<span class="nc" id="L949">            K1 = 0.045;</span>
<span class="nc" id="L950">            K2 = 0.015;</span>
        } else {
<span class="nc" id="L952">            kL = 2;</span>
<span class="nc" id="L953">            K1 = 0.048;</span>
<span class="nc" id="L954">            K2 = 0.014;</span>
        }

<span class="nc" id="L957">        float deltaEll = ell1 - ell2;</span>
<span class="nc" id="L958">        double deltaA = a1 - a2;</span>
<span class="nc" id="L959">        double deltaB = b1 - b2;</span>

<span class="nc" id="L961">        double cA1 = Math.sqrt((a1*a1) + (b1*b1));</span>
<span class="nc" id="L962">        double cA2 = Math.sqrt((a2*a2) + (b2*b2));</span>
<span class="nc" id="L963">        double deltaCab = cA1 - cA2;</span>

<span class="nc" id="L965">        double aa = (deltaA*deltaA) + (deltaB*deltaB) - (deltaCab*deltaCab);</span>
        double deltaHab;
<span class="nc bnc" id="L967" title="All 2 branches missed.">        if (aa &lt; 1E-10) {</span>
<span class="nc" id="L968">            deltaHab = 0;</span>
        } else {
<span class="nc" id="L970">            deltaHab = Math.sqrt(aa);</span>
        }

<span class="nc" id="L973">        double sL = 1;</span>
<span class="nc" id="L974">        double sC = 1 + (K1*cA1);</span>
<span class="nc" id="L975">        double sH = 1 + (K2*cA1);</span>

<span class="nc" id="L977">        double t1 = deltaEll/(kL * sL);</span>
<span class="nc" id="L978">        t1 *= t1;</span>
<span class="nc" id="L979">        double t2 = deltaCab/sC;</span>
<span class="nc" id="L980">        t2 *= t2;</span>
<span class="nc" id="L981">        double t3 = deltaHab/sH;</span>
<span class="nc" id="L982">        t3 *= t3;</span>

<span class="nc" id="L984">        double e94 = Math.sqrt(t1 + t2 + t3);</span>

<span class="nc" id="L986">        return e94;</span>
    }

    /**
     * calculate the delta E 2000 for 2 sets of CIE LAB, specifically, CIEDE2000.
     *
     * uses https://en.wikipedia.org/wiki/Color_difference
     * and
     * http://www.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf
     * Sharma, Wu, and Dalal 2004
     *
     * The implementation is adapted from
     * https://github.com/wuchubuzai/OpenIMAJ/blob/master/image/image-processing/src/main/java/org/openimaj/image/analysis/colour/CIEDE2000.java
     * which has copyright 2011, The University of Southampton and allows
     * redistribution of source with or without modification.
     *
     * Note that the &quot;Just noticeable difference&quot;, JND, begins at E_ab ~ 2.3.
     *
     * The range of resulting values if CIELUV values are given
     * is 0 to about 130-ish.
     *
     * The range of resulting values if CIELAB1931 values are given
     * is 0 to about 120-ish.
     *
     * @return deltaE
     */
    public double calcDeltaECIE2000(float[] lab1, float[] lab2) {

<span class="fc" id="L1014">        return calcDeltaECIE2000(lab1[0], lab1[1], lab1[2], lab2[0], lab2[1],</span>
            lab2[2]);
    }

    /**
     * calculate the delta E 2000 for 2 sets of CIE LAB, specifically, CIEDE2000.
     * see https://en.wikipedia.org/wiki/Color_difference
     * and
     * http://www.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf
     * Sharma, Wu, and Dalal 2004
     *
     * The implementation is adapted from
     * https://github.com/wuchubuzai/OpenIMAJ/blob/master/image/image-processing/src/main/java/org/openimaj/image/analysis/colour/CIEDE2000.java
     * which has copyright 2011, The University of Southampton and allows
     * redistribution of source with or without modification.
     *
     * Note that the &quot;Just noticeable difference&quot;, JND, begins at E_ab ~ 2.3.
     *
     * The range of resulting values if CIELUV values are given
     * is 0 to about 130-ish.
     *
     * The range of resulting values if CIELAB1931 values are given
     * is 0 to about 120-ish.
     * 
     * @return deltaE
     */
    public double calcDeltaECIE2000(float L1, float a1, float b1,
        float L2, float a2, float b2) {

<span class="fc" id="L1043">        double Lmean = (L1 + L2) / 2.0;</span>
<span class="fc" id="L1044">		double C1 =  Math.sqrt(a1*a1 + b1*b1);</span>
<span class="fc" id="L1045">		double C2 =  Math.sqrt(a2*a2 + b2*b2);</span>
<span class="fc" id="L1046">		double Cmean = (C1 + C2) / 2.0;</span>

<span class="fc" id="L1048">        double pow7 = Math.pow(Cmean, 7);</span>
<span class="fc" id="L1049">        double pow257 =  Math.pow(25, 7);</span>

<span class="fc" id="L1051">		double G =  (1. - Math.sqrt(pow7/(pow7 + pow257)))/2.;</span>
<span class="fc" id="L1052">		double a1prime = a1 * (1. + G);</span>
<span class="fc" id="L1053">		double a2prime = a2 * (1. + G);</span>

<span class="fc" id="L1055">		double C1prime =  Math.sqrt(a1prime*a1prime + b1*b1);</span>
<span class="fc" id="L1056">		double C2prime =  Math.sqrt(a2prime*a2prime + b2*b2);</span>
<span class="fc" id="L1057">		double Cmeanprime = (C1prime + C2prime) / 2;</span>

<span class="fc bfc" id="L1059" title="All 2 branches covered.">		double h1prime =  Math.atan2(b1, a1prime) + 2*Math.PI * (Math.atan2(b1, a1prime)&lt;0 ? 1 : 0);</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">		double h2prime =  Math.atan2(b2, a2prime) + 2*Math.PI * (Math.atan2(b2, a2prime)&lt;0 ? 1 : 0);</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">		double Hmeanprime =  ((Math.abs(h1prime - h2prime) &gt; Math.PI) ? (h1prime + h2prime + 2*Math.PI) / 2 : (h1prime + h2prime) / 2);</span>

<span class="fc" id="L1063">		double T =  1.0 - 0.17 * Math.cos(Hmeanprime - Math.PI/6.0) + 0.24 * Math.cos(2*Hmeanprime)</span>
<span class="fc" id="L1064">            + 0.32 * Math.cos(3*Hmeanprime + Math.PI/30) - 0.2 * Math.cos(4*Hmeanprime - 21*Math.PI/60);</span>

<span class="fc bfc" id="L1066" title="All 2 branches covered.">		double deltahprime =  ((Math.abs(h1prime - h2prime) &lt;= Math.PI) ? h2prime - h1prime :</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">            (h2prime &lt;= h1prime) ? h2prime - h1prime + 2*Math.PI : h2prime - h1prime - 2*Math.PI);</span>

<span class="fc" id="L1069">		double deltaLprime = L2 - L1;</span>
<span class="fc" id="L1070">		double deltaCprime = C2prime - C1prime;</span>
<span class="fc" id="L1071">		double deltaHprime =  2.0 * Math.sqrt(C1prime*C2prime) * Math.sin(deltahprime / 2.0);</span>
<span class="fc" id="L1072">		double SL =  1.0 + ( (0.015*(Lmean - 50)*(Lmean - 50)) / (Math.sqrt( 20 + (Lmean - 50)*(Lmean - 50) )) );</span>
<span class="fc" id="L1073">		double SC =  1.0 + 0.045 * Cmeanprime;</span>
<span class="fc" id="L1074">		double SH =  1.0 + 0.015 * Cmeanprime * T;</span>

<span class="fc" id="L1076">		double deltaTheta =  (30 * Math.PI / 180) * Math.exp(-((180/Math.PI*Hmeanprime-275)/25)*((180/Math.PI*Hmeanprime-275)/25));</span>
<span class="fc" id="L1077">		double RC =  (2 * Math.sqrt(Math.pow(Cmeanprime, 7) / (Math.pow(Cmeanprime, 7) + Math.pow(25, 7))));</span>
<span class="fc" id="L1078">		double RT =  (-RC * Math.sin(2 * deltaTheta));</span>

<span class="fc" id="L1080">		double KL = 1;</span>
<span class="fc" id="L1081">		double KC = 1;</span>
<span class="fc" id="L1082">		double KH = 1;</span>

<span class="fc" id="L1084">		double deltaE = Math.sqrt(</span>
				((deltaLprime/(KL*SL)) * (deltaLprime/(KL*SL))) +
				((deltaCprime/(KC*SC)) * (deltaCprime/(KC*SC))) +
				((deltaHprime/(KH*SH)) * (deltaHprime/(KH*SH))) +
				(RT * (deltaCprime/(KC*SC)) * (deltaHprime/(KH*SH)))
				);

<span class="fc" id="L1091">		return deltaE;</span>
    }

    /**
     * convert rgb to CIE XYZ (1931).
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     *
     * @param r
     * @param g
     * @param b
     * @param outputCIEXYZ output array of length 3 that will be populated with
     * cieX, cieY and cieZ.
     */
    public void rgbToCIEXYZ(int r, int g, int b, float[] outputCIEXYZ) {

<span class="nc bnc" id="L1107" title="All 4 branches missed.">        if (outputCIEXYZ == null || outputCIEXYZ.length != 3) {</span>
<span class="nc" id="L1108">            throw new IllegalArgumentException(&quot;outputCIEXYZ has to be length 3&quot;);</span>
        }

        /*
            | X |       1     | 0.49     0.31      0.20     |   | R |
            | Y | = --------- | 0.17697  0.81240   0.01063  | * | G |
            | Z |    0.17697  | 0.00     0.01      0.99     |   | B |
        */

<span class="nc" id="L1117">        float capX = (0.49f * r +  0.31f * g + 0.20f * b)/0.17697f;</span>

<span class="nc" id="L1119">        float capY = (0.17697f * r +  0.81240f * g + 0.01063f * b)/0.17697f;</span>

<span class="nc" id="L1121">        float capZ = (0.01f * g + 0.99f * b)/0.17697f;</span>

<span class="nc" id="L1123">        outputCIEXYZ[0] = capX;</span>
<span class="nc" id="L1124">        outputCIEXYZ[1] = capY;</span>
<span class="nc" id="L1125">        outputCIEXYZ[2] = capZ;</span>
<span class="nc" id="L1126">    }</span>

    /**
     * convert CIE XYZ (1931) to rgb.
     *
     * uses http://en.wikipedia.org/wiki/CIE_1931_color_space#Experimental_results:_the_CIE_RGB_color_space
     *
     * @param cieX
     * @param cieY
     * @param cieZ
     * @return
     */
    public int[] cieXYZToRGB(float cieX, float cieY, float cieZ) {

        /*
            | R |   |  0.41847    -0.15866   -0.082835 |   | X |
            | G | = | -0.091169    0.25243    0.015708 | * | Y |
            | B |   |  0.00092090 -0.0025498  0.17860  |   | Z |
        */

<span class="nc" id="L1146">        float capR = (0.41847f * cieX +  -0.15866f * cieY + -0.082835f * cieZ);</span>

<span class="nc" id="L1148">        float capG = (-0.091169f * cieX +  0.25243f * cieY + 0.015708f * cieZ);</span>

<span class="nc" id="L1150">        float capB = (0.00092090f * cieX +  -0.0025498f * cieY + 0.17860f * cieZ);</span>

<span class="nc" id="L1152">        return new int[]{(int)capR, (int)capG, (int)capB};</span>
    }

    public List&lt;Double&gt; calcAvgAndStdDevXY(int[] r, int[] g, int[] b) {

<span class="nc" id="L1157">        double xSum = 0;</span>
<span class="nc" id="L1158">        double ySum = 0;</span>
<span class="nc" id="L1159">        float[] x = new float[r.length];</span>
<span class="nc" id="L1160">        float[] y = new float[r.length];</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        for (int i = 0; i &lt; r.length; i++) {</span>
<span class="nc" id="L1162">            float[] xy = rgbToXYChromaticity(r[i], g[i], b[i]);</span>
<span class="nc" id="L1163">            x[i] = xy[0];</span>
<span class="nc" id="L1164">            y[i] = xy[1];</span>
<span class="nc" id="L1165">            xSum += xy[0];</span>
<span class="nc" id="L1166">            ySum += xy[1];</span>
<span class="nc" id="L1167">            i++;</span>
        }
<span class="nc" id="L1169">        double avgX = xSum/(double)r.length;</span>
<span class="nc" id="L1170">        double avgY = ySum/(double)r.length;</span>

<span class="nc" id="L1172">        xSum = 0;</span>
<span class="nc" id="L1173">        ySum = 0;</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        for (int i = 0; i &lt; r.length; i++) {</span>
<span class="nc" id="L1175">            double diffX = x[i] - avgX;</span>
<span class="nc" id="L1176">            double diffY = y[i] - avgY;</span>
<span class="nc" id="L1177">            xSum += (diffX * diffX);</span>
<span class="nc" id="L1178">            ySum += (diffY * diffY);</span>
        }
<span class="nc" id="L1180">        double stDevX = Math.sqrt(xSum/((double)r.length - 1));</span>
<span class="nc" id="L1181">        double stDevY = Math.sqrt(ySum/((double)r.length - 1));</span>

<span class="nc" id="L1183">        List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L1184">        list.add(Double.valueOf(avgX));</span>
<span class="nc" id="L1185">        list.add(Double.valueOf(avgY));</span>
<span class="nc" id="L1186">        list.add(Double.valueOf(stDevX));</span>
<span class="nc" id="L1187">        list.add(Double.valueOf(stDevY));</span>

<span class="nc" id="L1189">        return list;</span>
    }

    /**
     * returns roughly whether the CIE (X,Y) coordinate lands within the large
     * white zone in the center of the diagram.
     * @param cieX
     * @param cieY
     * @return
     */
    public boolean isWhite(float cieX, float cieY) {

<span class="nc" id="L1201">        double diffX = Math.abs(cieX - 0.35);</span>

<span class="nc" id="L1203">        double diffY = Math.abs(cieY - 0.35);</span>

<span class="nc bnc" id="L1205" title="All 4 branches missed.">        return ((diffX &lt;= deltaWhite) &amp;&amp; (diffY &lt;= deltaWhite));</span>
    }

    /**
     * returns roughly whether the CIE (X,Y) coordinate lands within the large
     * white zone in the center of the diagram.
     * Note that this returns true for grey too, so test for lower intensities
     * first
     * @param cieX
     * @param cieY
     * @return
     */
    public boolean isWhite2(float cieX, float cieY) {

<span class="nc" id="L1219">        double diffX = Math.abs(cieX - 0.35);</span>

<span class="nc" id="L1221">        double diffY = Math.abs(cieY - 0.35);</span>

<span class="nc" id="L1223">        double delta = 2.*(0.1/7.);</span>

<span class="nc bnc" id="L1225" title="All 4 branches missed.">        return ((diffX &lt;= delta) &amp;&amp; (diffY &lt;= delta));</span>
    }

    /**
     * calculate the angle in radians of the point (cieX, cieY) in the
     * CIE chromaticity
     * diagram with respect to an origin of (0.35, 0.35).
     * Note that one should check for white before using this as the resulting
     * angle will not be a significant answer if it is.
     * The angles are
     * &lt;pre&gt;    90(=pi/2)
     *            |
     *            |
     *   180 ----------- 0
     *   (=pi)    |
     *            |
     *          270(=3pi/2)
     * &lt;/pre&gt;
     * @param cieX
     * @param cieY
     * @return the angle in radians of the point (cieX, cieY) with respect to
     * an origin of (0.35, 0.35). The invoker should check the original r,g,b
     * for black and white to avoid use here.  A value of -1 is returned for
     * white.
     */
    public double calculateXYTheta(float cieX, float cieY) {

<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if (cieX == 0.35) {</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            if (cieY &gt; (0.35 + deltaWhite)) {</span>
<span class="nc" id="L1254">                return Math.PI/2.;</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            } else if (cieY &lt; (0.35 - deltaWhite)) {</span>
<span class="nc" id="L1256">                return 1.5 * Math.PI;</span>
            } else {
                // this should have been found as white to avoid use here
<span class="nc" id="L1259">                return -1;</span>
            }
        }

<span class="nc" id="L1263">        double theta = MiscMath.calculatePolarTheta(cieX - 0.35f, cieY - 0.35f);</span>

<span class="nc" id="L1265">        return theta;</span>
    }

<span class="fc" id="L1268">    private static double wd = Math.sqrt(Math.pow((0.425 - 0.275), 2) +</span>
<span class="fc" id="L1269">        Math.pow((0.3875 - 0.2625), 2));</span>

    /**
     * Is within the bounds of large white central region in the CIE 1931 xy
     * chromaticity diagram.  Note that this region has small amount of color
     * in it too, so you may want to further process any point in rgb too.
     * Also note that grey pixels are found here too centered at (0.33, 0.33).
     *
     * @param cieX
     * @param cieY
     * @return
     */
    public boolean isInLargeWhiteCenter(float cieX, float cieY) {

        /*              (0.425, 0.3875)
                           /
                       /           within 0.075 from the line
                    /              between these two points
          (0.275, 0.2625)


        2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)

        If define (x1, y1) and (x2, y2) as points on the line and
        (x0, y0) as the point that is distant from the line:

        dist = | (x2-x1)(y1-y0) - (x1-x0)(y2-y1)  |
                 --------------------------------
                  sqrt( (x2-x1)^2 + (y2-y1)^2) )
        */
<span class="nc" id="L1299">        double numer = Math.abs((0.425 - 0.275) * (0.2625 - cieY)</span>
            - (0.275 - cieX) * (0.3875 - 0.2625));

<span class="nc" id="L1302">        double dist = numer/wd;</span>

<span class="nc bnc" id="L1304" title="All 2 branches missed.">        return (dist &lt;= 0.03333);//(dist &lt;= 0.075);</span>
    }

    /**
     * calculate the difference in L,A,B 1931 between between the two sets and
     * normalize the values to a sum of &quot;1&quot; using the range of values
     * possible from the use of a standard illuminant, D65.
     * 
     * @return 
     */
    public float calcNormalizedDifferenceLAB31(float ell1, float a1, float b1,
        float ell2, float a2, float b2) {
       
        /*
        * using the standard illuminant of daylight, D65,
        * the range of return values is
        * L*    0 to 104.5
        * a* -190 to 103
        * b* -113 to 99
        */
        
<span class="nc" id="L1325">        float diff1 = Math.abs(ell1 - ell2)/104.5f;</span>
<span class="nc" id="L1326">        float diff2 = Math.abs(a1 - a2)/(103f + 190f);</span>
<span class="nc" id="L1327">        float diff3 = Math.abs(b1 - b2)/(99f + 113.f);</span>
        
<span class="nc" id="L1329">        return (diff1 + diff2 + diff3)/3.f;</span>
    }
    
    /**
     * calculate the difference in L, U, V 1976 WideRangeLightness
     * between between the two sets and
     * normalize the values to a sum of &quot;1&quot; using the range of values
     * possible.
     * 
     * * uses standard illuminant &quot;wide range lightness&quot;.
     * Wide-range Lightness data were generated by Fairchild et al., 
     * who conducted two different experiments to scale lightness above and 
     * below diffuse white (CIE * L = 100 ). 
     * In the Scaling Lightness Experiment 1 (SL1) they used a luminance
       range from 156 to 2 3692cd m with 2 842 Y cd m n = 
       (Yn represents the luminance of reference white) 
      whereas in the Scaling Lightness Experiment 2 (SL2) the
      luminance range was extended from 0 to 2 7432cd m with 2 997 Y cd m n = . 
     The SL2 data set was used to drive the adapted lightness ( z J ) 
     formula of the proposed color space (see later) while the SL1 data set was 
     used as a test data set. Each of the sets includes 19 samples. 

     * https://www.osapublishing.org/DirectPDFAccess/B810E9AE-C7C9-E594-C72DC7FBE1424F0A_368272/oe-25-13-15131.pdf?da=1&amp;id=368272&amp;seq=0&amp;mobile=no
     * 
     * SL2 Training D65/2° (x,y,z)=968.08 997 883.51 
     * L_a=199 
     * C=0.69. N_C=1, F=1 
     *
     * @return 
     */
    public float calcNormalizedDifferenceLUV_WideRangeLightness(
        int r1, int g1, int b1, int r2, int g2, int b2) {
       
<span class="nc" id="L1362">        float[] luv1 = rgbToCIELUV_WideRangeLightness(r1, g1, b1);</span>
<span class="nc" id="L1363">        float[] luv2 = rgbToCIELUV_WideRangeLightness(r2, g2, b2);</span>
        
<span class="nc" id="L1365">        return calcNormalizedDifferenceLUV_WideRangeLightness(luv1, luv2);</span>
    }
    
    /**
     * calculate the difference in L, U, V 1976 WideRangeLightness
     * between between the two sets and
     * normalize the values to a sum of &quot;1&quot; using the range of values
     * possible.
     * 
     * * uses standard illuminant &quot;wide range lightness&quot;.
     * Wide-range Lightness data were generated by Fairchild et al., 
     * who conducted two different experiments to scale lightness above and 
     * below diffuse white (CIE * L = 100 ). 
     * In the Scaling Lightness Experiment 1 (SL1) they used a luminance
       range from 156 to 2 3692cd m with 2 842 Y cd m n = 
       (Yn represents the luminance of reference white) 
      whereas in the Scaling Lightness Experiment 2 (SL2) the
      luminance range was extended from 0 to 2 7432cd m with 2 997 Y cd m n = . 
     The SL2 data set was used to drive the adapted lightness ( z J ) 
     formula of the proposed color space (see later) while the SL1 data set was 
     used as a test data set. Each of the sets includes 19 samples. 

     * https://www.osapublishing.org/DirectPDFAccess/B810E9AE-C7C9-E594-C72DC7FBE1424F0A_368272/oe-25-13-15131.pdf?da=1&amp;id=368272&amp;seq=0&amp;mobile=no
     * 
     * SL2 Training D65/2° (x,y,z)=968.08 997 883.51 
     * L_a=199 
     * C=0.69. N_C=1, F=1 
     *
     * @return 
     */
    public float calcNormalizedDifferenceLUV_WideRangeLightness(
        float[] luv1, int r2, int g2, int b2) {
       
<span class="nc" id="L1398">        float[] luv2 = rgbToCIELUV_WideRangeLightness(r2, g2, b2);</span>
         
<span class="nc" id="L1400">        return calcNormalizedDifferenceLUV_WideRangeLightness(luv1, luv2);</span>
    }
    
    /**
     * calculate the difference in L, U, V 1976 WideRangeLightness
     * between between the two sets and
     * normalize the values to a sum of &quot;1&quot; using the range of values
     * possible.
     * 
     * * uses standard illuminant &quot;wide range lightness&quot;.
     * Wide-range Lightness data were generated by Fairchild et al., 
     * who conducted two different experiments to scale lightness above and 
     * below diffuse white (CIE * L = 100 ). 
     * In the Scaling Lightness Experiment 1 (SL1) they used a luminance
       range from 156 to 2 3692cd m with 2 842 Y cd m n = 
       (Yn represents the luminance of reference white) 
      whereas in the Scaling Lightness Experiment 2 (SL2) the
      luminance range was extended from 0 to 2 7432cd m with 2 997 Y cd m n = . 
     The SL2 data set was used to drive the adapted lightness ( z J ) 
     formula of the proposed color space (see later) while the SL1 data set was 
     used as a test data set. Each of the sets includes 19 samples. 

     * https://www.osapublishing.org/DirectPDFAccess/B810E9AE-C7C9-E594-C72DC7FBE1424F0A_368272/oe-25-13-15131.pdf?da=1&amp;id=368272&amp;seq=0&amp;mobile=no
     * 
     * SL2 Training D65/2° (x,y,z)=968.08 997 883.51 
     * L_a=199 
     * C=0.69. N_C=1, F=1 
     *
     * @return 
     */
    public float calcNormalizedDifferenceLUV_WideRangeLightness(
        float[] luv1, float[] luv2) {
       
        /*
        * L       0 to 104.8
        * u   -99.9 to 176.8
        * v  -150.0 to 95.0
        */        
<span class="fc" id="L1438">        float diff1 = Math.abs(luv1[0] - luv2[1])/104.8f;</span>
<span class="fc" id="L1439">        float diff2 = Math.abs(luv1[1] - luv2[1])/(176.8f + 99.9f);</span>
<span class="fc" id="L1440">        float diff3 = Math.abs(luv1[2] - luv2[2])/(95.0f + 150.0f);</span>
        
<span class="fc" id="L1442">        return (diff1 + diff2 + diff3)/3.f;</span>
    }
    
    public float calcNormalizedDifferenceLUV(float ell1, float u1, float v1,
        float ell2, float u2, float v2) {
       
        /*
        * using the standard illuminant of daylight, D65,
        * the range of return values is
        * L       0 to 104.5
        * u   -86.9 to 183.8
        * v  -141.4 to 112.3
        */
        
<span class="nc" id="L1456">        float diff1 = Math.abs(ell1 - ell2)/104.5f;</span>
<span class="nc" id="L1457">        float diff2 = Math.abs(u1 - u2)/(183.8f + 86.9f);</span>
<span class="nc" id="L1458">        float diff3 = Math.abs(v1 - v2)/(112.3f + 141.4f);</span>
        
<span class="nc" id="L1460">        return (diff1 + diff2 + diff3)/3.f;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BlobScaleFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">BlobScaleFinder.java</span></div><h1>BlobScaleFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.MultiArrayMergeSort;
import algorithms.imageProcessing.SegmentedImageHelper.SegmentationType;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.Errors;
import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.ResourceFinder;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">public class BlobScaleFinder {</span>

<span class="fc" id="L36">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L38">    protected boolean debug = false;</span>

    public void setToDebug() {
<span class="nc" id="L41">        debug = true;</span>
<span class="nc" id="L42">    }</span>

    /**
     * sum the intensity of the points with an option to subtract the mean.
     * @param img
     * @param points
     * @return
     */
    protected double sumIntensity(GreyscaleImage img, Set&lt;PairInt&gt; points) {
<span class="nc bnc" id="L51" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L52">            throw new IllegalStateException(&quot;img cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L54" title="All 2 branches missed.">        if (points == null) {</span>
<span class="nc" id="L55">            throw new IllegalStateException(&quot;points cannot be null&quot;);</span>
        }
<span class="nc" id="L57">        double sum = 0;</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L59">            int x = p.getX();</span>
<span class="nc" id="L60">            int y = p.getY();</span>
<span class="nc" id="L61">            double v = img.getValue(x, y);</span>
<span class="nc" id="L62">            sum += v;</span>
<span class="nc" id="L63">        }</span>
<span class="nc" id="L64">        return sum;</span>
    }

    public TransformationParameters solveForScale(
        SegmentedImageHelper img1Helper, SegmentationType type1,
        boolean useBinned1,
        SegmentedImageHelper img2Helper, SegmentationType type2,
        boolean useBinned2,
        float[] outputScaleRotTransXYStDev) {

<span class="fc" id="L74">        BlobsAndContours bc1 = img1Helper.getBlobsAndContours(type1, useBinned1);</span>
<span class="fc" id="L75">        GreyscaleImage img1 = img1Helper.getGreyscaleImage(useBinned1);</span>

<span class="fc" id="L77">        BlobsAndContours bc2 = img2Helper.getBlobsAndContours(type2, useBinned2);</span>
<span class="fc" id="L78">        GreyscaleImage img2 = img2Helper.getGreyscaleImage(useBinned2);</span>

<span class="fc" id="L80">        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1List = bc1.getContours();</span>
<span class="fc" id="L81">        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours2List = bc2.getContours();</span>
<span class="fc" id="L82">        List&lt;Set&lt;PairInt&gt;&gt; blobs1 = bc1.getBlobs();</span>
<span class="fc" id="L83">        List&lt;Set&lt;PairInt&gt;&gt; blobs2 = bc2.getBlobs();</span>
<span class="fc" id="L84">        List&lt;PairIntArray&gt; perimeters1 = bc1.getBlobOrderedPerimeters();</span>
<span class="fc" id="L85">        List&lt;PairIntArray&gt; perimeters2 = bc2.getBlobOrderedPerimeters();</span>

<span class="fc" id="L87">        Map&lt;PairInt, CSSContourMatcherWrapper&gt; singleSolnMap =</span>
            new HashMap&lt;PairInt,  CSSContourMatcherWrapper&gt;();

<span class="fc" id="L90">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L92">        IntensityFeatures features1 = new IntensityFeatures(img1, 5, true);</span>
<span class="fc" id="L93">        IntensityFeatures features2 = new IntensityFeatures(img2, 5, true);</span>

        /*
        Note that the matching contours are improved and filtered by using 
        feature descriptors.
        
        Finding the best match if any for each index1.
        If a subsequent match to the that index1's index2 is present, it will
        only be considered if the cost is less than the previous.
        It's a greedy best approach.
        After all of the index1 solutions are gathered, the best is found
        by adjusting the costs by the largest sigma from the first peak contours 
        from edges1 (i.e. applying the penalty from the paper to smaller peak
        sigma's costs).
        The best agreeing solutions are kept.
        
        If instead wanted a bipartite matching of best costs, would want to
        keep the top 2 or so of each index1.
        Would need to be careful to not include large peak contour false matches.
        All costs in the top would need to be adjusted by the penalty mentioned
        above.
        Then the best among more than one would be defined by cost.  
        Then more than one solutions points would be kept if similarity
        in difference of theta and scale were within a limit.
        */
       
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
<span class="fc" id="L120">            index1BestMap = new HashMap&lt;Integer, </span>
            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt;();

<span class="fc bfc" id="L123" title="All 2 branches covered.">        for (int idx1 = 0; idx1 &lt; blobs1.size(); ++idx1) {</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (contours1List.get(idx1).isEmpty()) {</span>
<span class="fc" id="L126">                continue;</span>
            }

<span class="fc" id="L129">            Integer index1 = Integer.valueOf(idx1);</span>

<span class="fc" id="L131">            PairIntArray curve1 = perimeters1.get(idx1);</span>

<span class="fc" id="L133">            Set&lt;PairInt&gt; blob1 = blobs1.get(idx1);</span>

<span class="fc" id="L135">            double[] xyCen1 = curveHelper.calculateXYCentroids(blob1);</span>

            // keeping the top '2' for each index1.  comparison is by cost.
            // choosing more than one because later bipartite matching attempts
            // to match best for all index1 matchings
<span class="fc" id="L140">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; bestStats </span>
                = new FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;(2, 
                IntensityFeatureComparisonStats.class);

<span class="fc bfc" id="L144" title="All 2 branches covered.">            for (int idx2 = 0; idx2 &lt; blobs2.size(); ++idx2) {</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">                if (contours2List.get(idx2).isEmpty()) {</span>
<span class="fc" id="L147">                    continue;</span>
                }

<span class="fc" id="L150">                Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L152">                PairIntArray curve2 = perimeters2.get(idx2);</span>

<span class="fc" id="L154">                Set&lt;PairInt&gt; blob2 = blobs2.get(idx2);</span>
                
<span class="fc" id="L156">double[] xyCen2 = curveHelper.calculateXYCentroids(curve2);</span>
<span class="fc" id="L157">log.info(&quot;index1=&quot; + index1.toString() + &quot; index2=&quot; + index2.toString()</span>
<span class="fc" id="L158"> + &quot; xyCen1=&quot; + Arrays.toString(xyCen1) + &quot; xyCen2=&quot; + Arrays.toString(xyCen2));</span>

<span class="fc" id="L160">                CurvatureScaleSpaceInflectionSingleEdgeMapper mapper =</span>
                    new CurvatureScaleSpaceInflectionSingleEdgeMapper(
                    0, 0, 0, 0);

<span class="fc" id="L164">                TransformationParameters params = mapper.matchContours(</span>
<span class="fc" id="L165">                    contours1List.get(idx1), contours2List.get(idx2));</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">                if ((params == null) ||</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">                    (mapper.getMatcher().getSolutionMatchedContours1().size() &lt; 2)) {</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">                    if ((mapper.getMatcher() != null) &amp;&amp;</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">                        (mapper.getMatcher().getSolutionMatchedContours1().size() == 1)) {</span>

<span class="fc" id="L173">                        singleSolnMap.put(new PairInt(idx1, idx2), mapper.getMatcher());</span>
                    }

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">if (mapper.getMatcher() != null) {</span>
<span class="fc" id="L177">log.info(String.format(&quot;discarding [%d] (%d,%d)  [%d] (%d,%d)  nMCs=%d&quot;,</span>
<span class="fc" id="L178">idx1, (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="fc" id="L179">idx2, (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1]),</span>
<span class="fc" id="L180">mapper.getMatcher().getSolutionMatchedContours1().size()));</span>
} else {
<span class="nc" id="L182">log.info(String.format(&quot;discarding [%d] (%d,%d)  [%d] (%d,%d)&quot;,</span>
<span class="nc" id="L183">idx1, (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="nc" id="L184">idx2, (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1])));</span>
}

<span class="nc" id="L187">                    continue;</span>
                }

                // edit points using feature descriptors and remove outliers:
<span class="fc" id="L191">                List&lt;FeatureComparisonStat&gt; compStats =</span>
<span class="fc" id="L192">                    filterContourPointsByFeatures(img1, img2, index1, index2,</span>
                    blob1, blob2, curve1, curve2, features1, features2,
<span class="fc" id="L194">                    mapper.getMatcher());</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (compStats.size() &lt; 2) {</span>
<span class="fc" id="L197">                    continue;</span>
                }

                //TODO: consider moving this type of statistic into the
                //cost during contour matching.  wanting to avoid accepting
                //solutions which are a small number of spurious matches due
                //to one contour having many points to match to.
<span class="fc" id="L204">                int nc1 = contours1List.get(index1.intValue()).size();</span>
<span class="fc" id="L205">                int nc2 = contours2List.get(index2.intValue()).size();</span>
<span class="fc" id="L206">                float frac = (float)nc1/(float)nc2;</span>
<span class="fc bfc" id="L207" title="All 8 branches covered.">                boolean lgDiffN = ((nc1 &gt; nc2) &amp;&amp; frac &gt; 2)</span>
                    || ((nc1 &lt; nc2) &amp;&amp; frac &lt; 0.5);
                
                // also, discard if fraction of matched/maxmatchable is too low
<span class="fc bfc" id="L211" title="All 2 branches covered.">                if (!lgDiffN) {</span>
<span class="fc" id="L212">                    float nmm = Math.min(nc1, nc2);</span>
<span class="fc" id="L213">                    float nm = compStats.size();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                    if ((nm/nmm) &lt; 0.5) {</span>
<span class="fc" id="L215">                        lgDiffN = true;</span>
                    }
                }
                
<span class="fc" id="L219">                log.info(String.format(</span>
                    &quot;   nc1=%d nc2=%d (frac=%.2f) nMCs=%d&quot;,
<span class="fc" id="L221">                    nc1, nc2, frac, </span>
<span class="fc" id="L222">                    mapper.getMatcher().getSolutionMatchedContours1().size()));</span>
                
<span class="fc bfc" id="L224" title="All 2 branches covered.">                if (lgDiffN) {                    </span>
<span class="fc" id="L225">                    log.info(</span>
                        &quot;discarding a good match because frac of maxMatchable is low.&quot;);
<span class="fc" id="L227">                    continue;</span>
                }
                
                //double combinedStat = calculateCombinedIntensityStat(compStats);

<span class="fc" id="L232">                IntensityFeatureComparisonStats stats = new </span>
<span class="fc" id="L233">                    IntensityFeatureComparisonStats(index1.intValue(), </span>
<span class="fc" id="L234">                    index2.intValue(), mapper.getMatcher().getSolvedCost(), </span>
<span class="fc" id="L235">                        mapper.getMatcher().getSolvedScale());</span>
<span class="fc" id="L236">                stats.addAll(compStats);</span>
                
                // bestStats keeps the top '2' smallest cost solutions added to it
                // (though combinedStats are used when nMatched is 2 or less)
<span class="fc" id="L240">                boolean added = bestStats.add(stats);</span>
                
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                if (added) {</span>
<span class="fc" id="L243">                    log.info(&quot;  added to best for [&quot; + index1.toString() + &quot;] [&quot;</span>
<span class="fc" id="L244">                        + index2.toString() + &quot;] cost=&quot; + stats.getCost()</span>
<span class="fc" id="L245">                        + &quot; with n=&quot; + stats.getComparisonStats().size());</span>
                }
            }

<span class="fc bfc" id="L249" title="All 2 branches covered.">            if (bestStats.getNumberOfItems() == 0) {</span>
<span class="fc" id="L250">                continue;</span>
            }

<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                for (int k = 0; k &lt; bestStats.getNumberOfItems(); ++k) {</span>
<span class="nc" id="L255">                    IntensityFeatureComparisonStats stats = bestStats.getArray()[k];</span>
<span class="nc" id="L256">                    double[] xyCen2 = curveHelper.calculateXYCentroids(</span>
<span class="nc" id="L257">                        blobs2.get(stats.getIndex2()));</span>
<span class="nc" id="L258">                    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L259">                    sb.append(String.format(</span>
                        &quot;==&gt;[%d](%d,%d) [%d](%d,%d) cost=%.2f scale=%.2f nMatched=%d(%d,%d) intSqDiff=%.1f&quot;,
<span class="nc" id="L261">                        stats.getIndex1(), (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="nc" id="L262">                        stats.getIndex2(), (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1]),</span>
<span class="nc" id="L263">                        (float)stats.getCost(), (float)stats.getScale(), </span>
<span class="nc" id="L264">                        stats.getComparisonStats().size(),</span>
<span class="nc" id="L265">                        contours1List.get(stats.getIndex1()).size(), </span>
<span class="nc" id="L266">                        calculateCombinedIntensityStat(stats.getComparisonStats())));</span>
<span class="nc" id="L267">                    log.info(sb.toString());</span>
                }
            }

<span class="fc" id="L271">            index1BestMap.put(index1, bestStats);</span>
        }
        
<span class="fc" id="L274">        List&lt;FeatureComparisonStat&gt; bestOverall = null;</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (index1BestMap.isEmpty()) {</span>
            
            // -------- process the single solution compStats ------------
            
<span class="fc bfc" id="L279" title="All 2 branches covered.">            if (singleSolnMap.size() &gt; 1) {</span>
<span class="fc" id="L280">                bestOverall = processSingleSolutionsIfNoBest(img1, img2,</span>
                    singleSolnMap, blobs1, blobs2, perimeters1, perimeters2,
                    features1, features2);
            }

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">            if (index1BestMap.isEmpty()) {</span>
<span class="fc" id="L286">                return null;</span>
            }
        } else {
<span class="fc" id="L289">            bestOverall = filterToBestConsistent(index1BestMap, contours1List,</span>
                contours2List);
        }

<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (bestOverall == null) {</span>
<span class="nc" id="L294">            return null;</span>
        }

<span class="fc" id="L297">        TransformationParameters params = calculateTransformation(</span>
            img1Helper, type1, useBinned1,
            img2Helper, type2, useBinned2,
            bestOverall, outputScaleRotTransXYStDev);

<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L303">            return null;</span>
        }

<span class="fc" id="L306">        return params;</span>
    }

    /**
     * extract the local points surrounding (x, y) on the
     * perimeter and return an object when creating descriptors.
     * Note that the perimeter is expected to be a closed curve.
     * @param theEdgeIndex
     * @param perimeter
     * @param blob
     * @return
     */
    protected BlobPerimeterRegion extractBlobPerimeterRegion(
        int theEdgeIndex, CurvatureScaleSpaceImagePoint peakDetail,
        PairIntArray perimeter, Set&lt;PairInt&gt; blob) {

<span class="pc bpc" id="L322" title="2 of 4 branches missed.">        if (perimeter == null || (perimeter.getN() &lt; 4)) {</span>
<span class="nc" id="L323">            throw new IllegalArgumentException(</span>
            &quot;perimeter cannot be null and must have at least 4 points&quot;);
        }

<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (blob == null) {</span>
<span class="nc" id="L328">            throw new IllegalArgumentException(&quot;blob cannot be null&quot;);</span>
        }

        //TODO: consider asserting that this is a closed curve

        // because of averaging for some peaks, sometimes
        // (x[detailIdx, y[detailIdx]) != (peakDetail.getXCoord(), peakDetail.getYCoord())
        // so for those, have to use the preceding index and then
        // the next + 1 (instead of next)

<span class="fc" id="L338">        int detailIdx = peakDetail.getCoordIdx();</span>

        // inflection points are found in between extremes of curvature,
        // so detailIdx must not be one of the curve endpoints.

<span class="fc" id="L343">        int xm = peakDetail.getXCoord();</span>
<span class="fc" id="L344">        int ym = peakDetail.getYCoord();</span>

        int xPrev, yPrev;
        int xNext, yNext;

<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (detailIdx == 0) {</span>
            // wrap around closed curve
<span class="fc" id="L351">            xPrev = perimeter.getX(perimeter.getN() - 1);</span>
<span class="fc" id="L352">            yPrev = perimeter.getY(perimeter.getN() - 1);</span>
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">            if ((xm != perimeter.getX(detailIdx)) || (ym != perimeter.getY(detailIdx))) {</span>
<span class="nc" id="L354">                xNext = perimeter.getX(detailIdx + 2);</span>
<span class="nc" id="L355">                yNext = perimeter.getY(detailIdx + 2);</span>
            } else {
<span class="fc" id="L357">                xNext = perimeter.getX(detailIdx + 1);</span>
<span class="fc" id="L358">                yNext = perimeter.getY(detailIdx + 1);</span>
            }
<span class="pc bpc" id="L360" title="2 of 4 branches missed.">        } else if ((xm != perimeter.getX(detailIdx)) || (ym != perimeter.getY(detailIdx))) {</span>
<span class="nc" id="L361">            xPrev = perimeter.getX(detailIdx - 1);</span>
<span class="nc" id="L362">            yPrev = perimeter.getY(detailIdx - 1);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if ((detailIdx + 2) &lt; perimeter.getN()) {</span>
<span class="nc" id="L364">                xNext = perimeter.getX(detailIdx + 2);</span>
<span class="nc" id="L365">                yNext = perimeter.getY(detailIdx + 2);</span>
            } else {
                // this is a closed curve, so wrap around
<span class="nc" id="L368">                xNext = perimeter.getX(0);</span>
<span class="nc" id="L369">                yNext = perimeter.getY(0);</span>
            }
        } else {
<span class="fc" id="L372">            xPrev = perimeter.getX(detailIdx - 1);</span>
<span class="fc" id="L373">            yPrev = perimeter.getY(detailIdx - 1);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">            if ((detailIdx + 1) &lt; perimeter.getN()) {</span>
<span class="fc" id="L375">                xNext = perimeter.getX(detailIdx + 1);</span>
<span class="fc" id="L376">                yNext = perimeter.getY(detailIdx + 1);</span>
            } else {
                // this is a closed curve, so wrap around
<span class="nc" id="L379">                xNext = perimeter.getX(0);</span>
<span class="nc" id="L380">                yNext = perimeter.getY(0);</span>
            }
        }

<span class="fc" id="L384">        BlobPerimeterRegion region = new BlobPerimeterRegion(theEdgeIndex,</span>
            xPrev, yPrev, xm, ym, xNext, yNext, blob);

<span class="fc" id="L387">        return region;</span>
    }

    protected List&lt;FeatureComparisonStat&gt; filterContourPointsByFeatures(
        GreyscaleImage img1, GreyscaleImage img2,
        Integer index1, Integer index2,
        Set&lt;PairInt&gt; blob1, Set&lt;PairInt&gt; blob2,
        PairIntArray curve1, PairIntArray curve2,
        IntensityFeatures features1, IntensityFeatures features2,
        CSSContourMatcherWrapper matcher) {

<span class="fc" id="L398">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

<span class="fc" id="L400">        int dither = 1;</span>

<span class="fc" id="L402">        List&lt;FeatureComparisonStat&gt; compStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L404">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L406">        double[] xyCen1 = curveHelper.calculateXYCentroids(curve1);</span>
<span class="fc" id="L407">        double[] xyCen2 = curveHelper.calculateXYCentroids(curve2);</span>

<span class="fc" id="L409">        double statSqSum = 0;</span>

<span class="fc" id="L411">        int nMaxMatchable = matcher.getNMaxMatchable();</span>
<span class="fc" id="L412">        int nMaxStats = 0;</span>
<span class="fc" id="L413">        int nStats = 0;</span>

<span class="fc" id="L415">        double cost = matcher.getSolvedCost();</span>

<span class="fc" id="L417">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L418">        sb.append(String.format(</span>
            &quot;[%d](%d,%d) [%d](%d,%d) cost=%.1f scale=%.2f  nMatched=%d &quot;,
<span class="fc" id="L420">            index1.intValue(), (int)Math.round(xyCen1[0]), (int)Math.round(xyCen1[1]),</span>
<span class="fc" id="L421">            index2.intValue(), (int)Math.round(xyCen2[0]), (int)Math.round(xyCen2[1]),</span>
<span class="fc" id="L422">            (float)cost, (float)matcher.getSolvedScale(),</span>
<span class="fc" id="L423">            matcher.getSolutionMatchedContours1().size()));</span>

<span class="fc" id="L425">        FeatureComparisonStat bestCompStat = null;</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">        for (int j = 0; j &lt; matcher.getSolutionMatchedContours1().size(); ++j) {</span>

<span class="fc" id="L429">            CurvatureScaleSpaceContour c1 = matcher.getSolutionMatchedContours1().get(j);</span>
<span class="fc" id="L430">            CurvatureScaleSpaceContour c2 = matcher.getSolutionMatchedContours2().get(j);</span>

            // the sizes of the peak details will be the same
<span class="fc" id="L433">            CurvatureScaleSpaceImagePoint[] details1 = c1.getPeakDetails();</span>
<span class="fc" id="L434">            CurvatureScaleSpaceImagePoint[] details2 = c2.getPeakDetails();</span>

<span class="fc" id="L436">            nMaxStats += details1.length;</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">            for (int jj = 0; jj &lt; details1.length; ++jj) {</span>

<span class="fc" id="L440">                BlobPerimeterRegion region1 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L441">                    index1.intValue(), details1[jj], curve1, blob1</span>
                );

<span class="fc" id="L444">                BlobPerimeterRegion region2 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L445">                    index2.intValue(), details2[jj], curve2, blob2</span>
                );

<span class="fc" id="L448">                FeatureComparisonStat compStat =</span>
<span class="fc" id="L449">                    featureMatcher.ditherAndRotateForBestLocation(</span>
                    features1, features2, region1, region2, dither);

<span class="fc" id="L452">sb.append(</span>
<span class="fc" id="L453">    String.format(&quot; (%d,%d) theta1=%d   (%d,%d) theta2=%d&quot;,</span>
<span class="fc" id="L454">    region1.getX(), region1.getY(),</span>
<span class="fc" id="L455">    Math.round(region1.getRelativeOrientationInDegrees()),</span>
<span class="fc" id="L456">    region2.getX(), region2.getY(),</span>
<span class="fc" id="L457">    Math.round(region2.getRelativeOrientationInDegrees())));</span>

<span class="fc bfc" id="L459" title="All 2 branches covered.">                if (compStat != null) {</span>
<span class="fc" id="L460">                    float sumIntSqDiff = compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L461">                    float intErrDiff = compStat.getImg2PointIntensityErr();</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                    if (sumIntSqDiff &lt; intErrDiff) {</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">                        if (bestCompStat == null) {</span>
<span class="fc" id="L464">                            bestCompStat = compStat;</span>
                        } else {
<span class="fc bfc" id="L466" title="All 2 branches covered.">                            if (sumIntSqDiff &lt; bestCompStat.getSumIntensitySqDiff()) {</span>
<span class="fc" id="L467">                                bestCompStat = compStat;</span>
                            }
                        }
<span class="fc" id="L470">                        statSqSum += (sumIntSqDiff*sumIntSqDiff);</span>
<span class="fc" id="L471">                        sb.append(String.format(&quot;  %.1f(%.1f), &quot;, sumIntSqDiff, intErrDiff));</span>
<span class="fc" id="L472">                        compStats.add(compStat);</span>
<span class="fc" id="L473">                        nStats++;</span>
                    }
                }
            } // end details
        }// end matching contours for index1, index2

<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (bestCompStat == null) {</span>
<span class="fc" id="L480">            return compStats;</span>
        }

<span class="fc" id="L483">        log.info(sb.toString());</span>

// looking at idx=2, 7 for full image and idx=0, 0 for binned
//if ((index1.intValue() == 2) &amp;&amp; (index2.intValue() == 6)) {
<span class="fc bfc" id="L487" title="All 4 branches covered.">if (((index1.intValue() == 0) &amp;&amp; (index2.intValue() == 0)) ||</span>
<span class="fc bfc" id="L488" title="All 4 branches covered.">((index1.intValue() == 3) &amp;&amp; (index2.intValue() == 3))) {</span>
try {
<span class="fc" id="L490">ImageExt img1C = img1.createColorGreyscaleExt();</span>
<span class="fc" id="L491">ImageExt img2C = img2.createColorGreyscaleExt();</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">for (FeatureComparisonStat compStat : compStats) {</span>
<span class="fc" id="L493">    int x1 = compStat.getImg1Point().getX();</span>
<span class="fc" id="L494">    int y1 = compStat.getImg1Point().getY();</span>
<span class="fc" id="L495">    int x2 = compStat.getImg2Point().getX();</span>
<span class="fc" id="L496">    int y2 = compStat.getImg2Point().getY();</span>
<span class="fc" id="L497">    img1C.setRGB(x1, y1, 255, 0, 0);</span>
<span class="fc" id="L498">    img2C.setRGB(x2, y2, 255, 0, 0);</span>
<span class="fc" id="L499">}</span>
<span class="fc" id="L500">String bin = ResourceFinder.findDirectory(&quot;bin&quot;);</span>
<span class="fc" id="L501">ImageIOHelper.writeOutputImage(bin + &quot;/features1_before_redo.png&quot;, img1C);</span>
<span class="fc" id="L502">ImageIOHelper.writeOutputImage(bin + &quot;/features2_before_redo.png&quot;, img2C);</span>
<span class="fc" id="L503">int z = 1;</span>
<span class="nc" id="L504">} catch(IOException e) {</span>
<span class="fc" id="L505">}</span>
}

        // if bestCompStat's difference in orientation is different than the
        // others', re-do the others to see if have an improved calculation.
        // the &quot;re-do&quot; should try a dither of 1 or 2
<span class="fc" id="L511">        float bestDiffTheta = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L512">            bestCompStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L513">            bestCompStat.getImg1PointRotInDegrees());</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (bestDiffTheta &lt; 0) {</span>
<span class="fc" id="L515">            bestDiffTheta += 360;</span>
        }

<span class="fc" id="L518">        boolean redoStats = false;</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        for (FeatureComparisonStat cStat : compStats) {</span>
<span class="fc" id="L520">            float diffTheta = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L521">                cStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L522">                cStat.getImg1PointRotInDegrees());</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (diffTheta &lt; 0) {</span>
<span class="fc" id="L524">                diffTheta += 360;</span>
            }
<span class="fc bfc" id="L526" title="All 2 branches covered.">            if (Math.abs(bestDiffTheta - diffTheta) &gt; 25) {</span>
<span class="fc" id="L527">                redoStats = true;</span>
<span class="fc" id="L528">                break;</span>
            }
<span class="fc" id="L530">        }</span>

        //TODO: may need to consider re-doing if compStats.size() is &lt;&lt; nMaxStats too
<span class="fc" id="L533">redoStats = true;</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (redoStats) {</span>

<span class="fc" id="L536">            compStats = redoFilterContourPointsByFeatures(img1, img2, index1,</span>
                index2, blob1, blob2, curve1, curve2,
<span class="fc" id="L538">                bestCompStat.getImg1PointRotInDegrees(),</span>
<span class="fc" id="L539">                bestCompStat.getImg2PointRotInDegrees(), matcher);</span>
            
<span class="fc" id="L541">            log.info(&quot;redone: &quot; + printToString(compStats) + &quot; combinedStat=&quot;</span>
<span class="fc" id="L542">                + calculateCombinedIntensityStat(compStats));</span>
       
<span class="fc" id="L544">            removeDiscrepantThetaDiff(compStats);</span>

<span class="fc" id="L546">            log.info(&quot;theta diff filtered: &quot; + printToString(compStats) + &quot; combinedStat=&quot;</span>
<span class="fc" id="L547">                + calculateCombinedIntensityStat(compStats));</span>
            
<span class="fc" id="L549">            removeIntensityOutliers(compStats);</span>
        }

<span class="fc" id="L552">        return compStats;</span>
    }

    List&lt;FeatureComparisonStat&gt; redoFilterContourPointsByFeatures(
        GreyscaleImage img1, GreyscaleImage img2,
        Integer index1, Integer index2,
        Set&lt;PairInt&gt; blob1, Set&lt;PairInt&gt; blob2,
        PairIntArray curve1, PairIntArray curve2,
        float theta1, float theta2,
        CSSContourMatcherWrapper matcher) {

<span class="fc" id="L563">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>

        // for the redo, because the orientations are set rather than found,
        // not going to re-use the invoker's instance of Features
<span class="fc" id="L567">        IntensityFeatures features1 = new IntensityFeatures(img1, 5, true);</span>
<span class="fc" id="L568">        IntensityFeatures features2 = new IntensityFeatures(img2, 5, true);</span>

<span class="fc" id="L570">        int dither = 2;</span>

<span class="fc" id="L572">        List&lt;FeatureComparisonStat&gt; compStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L574">        int nMaxMatchable = matcher.getNMaxMatchable();</span>
<span class="fc" id="L575">        int nMaxStats = 0;</span>

<span class="fc" id="L577">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L578">        sb.append(String.format(&quot;[%d] [%d] &quot;, index1.intValue(), index2.intValue()));</span>

<span class="fc" id="L580">        float theta1Radians = (float)(theta1 * Math.PI/180.);</span>
<span class="fc" id="L581">        float theta2Radians = (float)(theta2 * Math.PI/180.);</span>

<span class="fc bfc" id="L583" title="All 2 branches covered.">        for (int j = 0; j &lt; matcher.getSolutionMatchedContours1().size(); ++j) {</span>

<span class="fc" id="L585">            CurvatureScaleSpaceContour c1 = matcher.getSolutionMatchedContours1().get(j);</span>
<span class="fc" id="L586">            CurvatureScaleSpaceContour c2 = matcher.getSolutionMatchedContours2().get(j);</span>

            // the sizes of the peak details will be the same
<span class="fc" id="L589">            CurvatureScaleSpaceImagePoint[] details1 = c1.getPeakDetails();</span>
<span class="fc" id="L590">            CurvatureScaleSpaceImagePoint[] details2 = c2.getPeakDetails();</span>

<span class="fc" id="L592">            nMaxStats += details1.length;</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">            for (int jj = 0; jj &lt; details1.length; ++jj) {</span>

<span class="fc" id="L596">                BlobPerimeterRegion region1 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L597">                    index1.intValue(), details1[jj], curve1, blob1</span>
                );
<span class="fc" id="L599">                region1.overrideRelativeOrientation(theta1Radians);</span>

<span class="fc" id="L601">                BlobPerimeterRegion region2 = extractBlobPerimeterRegion(</span>
<span class="fc" id="L602">                    index2.intValue(), details2[jj], curve2, blob2</span>
                );
<span class="fc" id="L604">                region2.overrideRelativeOrientation(theta2Radians);</span>

<span class="fc" id="L606">                FeatureComparisonStat compStat =</span>
<span class="fc" id="L607">                    featureMatcher.ditherAndRotateForBestLocation(</span>
                    features1, features2, region1, region2, dither);

<span class="fc bfc" id="L610" title="All 2 branches covered.">                if (compStat != null) {</span>

<span class="fc" id="L612">                    float sumIntSqDiff = compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L613">                    float intErrDiff = compStat.getImg2PointIntensityErr();</span>

<span class="pc bpc" id="L615" title="1 of 2 branches missed.">                    if (sumIntSqDiff &lt; intErrDiff) {</span>
<span class="fc" id="L616">                        compStats.add(compStat);</span>
                    }

                }
            } // end details
        }// end matching contours for index1, index2

<span class="fc" id="L623">        sb.append(printToString(compStats)).append(&quot; nMaxStats=&quot;).append(nMaxStats);</span>

<span class="fc" id="L625">        log.info(sb.toString());</span>

// looking at idx=2, 7 for full image and idx=0, 0 for binned
//if ((index1.intValue() == 2) &amp;&amp; (index2.intValue() == 6)) {
<span class="fc bfc" id="L629" title="All 4 branches covered.">if (((index1.intValue() == 0) &amp;&amp; (index2.intValue() == 0)) ||</span>
<span class="fc bfc" id="L630" title="All 4 branches covered.">((index1.intValue() == 3) &amp;&amp; (index2.intValue() == 3))) {</span>
try {
<span class="fc" id="L632">ImageExt img1C = img1.createColorGreyscaleExt();</span>
<span class="fc" id="L633">ImageExt img2C = img2.createColorGreyscaleExt();</span>
<span class="fc" id="L634">MiscDebug.debugPlot(matcher.getSolutionMatchedContours1(), img1C,</span>
    0, 0, &quot;1_&quot; + index1 + &quot;_redone&quot;);
<span class="fc" id="L636">MiscDebug.debugPlot(matcher.getSolutionMatchedContours2(), img2C,</span>
    0, 0, &quot;2_&quot; + index2 + &quot;_redone&quot;);
<span class="fc bfc" id="L638" title="All 2 branches covered.">for (FeatureComparisonStat compStat : compStats) {</span>
<span class="fc" id="L639">    int x1 = compStat.getImg1Point().getX();</span>
<span class="fc" id="L640">    int y1 = compStat.getImg1Point().getY();</span>
<span class="fc" id="L641">    int x2 = compStat.getImg2Point().getX();</span>
<span class="fc" id="L642">    int y2 = compStat.getImg2Point().getY();</span>
<span class="fc" id="L643">    img1C.setRGB(x1, y1, 0, 255, 0);</span>
<span class="fc" id="L644">    img2C.setRGB(x2, y2, 0, 255, 0);</span>
<span class="fc" id="L645">}</span>
<span class="fc" id="L646">String bin = ResourceFinder.findDirectory(&quot;bin&quot;);</span>
<span class="fc" id="L647">ImageIOHelper.writeOutputImage(bin + &quot;/contours_1_redone.png&quot;, img1C);</span>
<span class="fc" id="L648">ImageIOHelper.writeOutputImage(bin + &quot;/contours_2_redone.png&quot;, img2C);</span>
<span class="fc" id="L649">int z = 1;</span>
<span class="nc" id="L650">} catch(IOException e) {</span>
<span class="fc" id="L651">}</span>
}

<span class="fc" id="L654">        removeOutliersByLocation(compStats);</span>
        
        //removeOutliers(compStats);

<span class="fc" id="L658">        return compStats;</span>
    }

    protected String printToString(List&lt;FeatureComparisonStat&gt; compStats) {

<span class="fc" id="L663">        StringBuilder sb = new StringBuilder();</span>

<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (FeatureComparisonStat compStat : compStats) {</span>

<span class="fc" id="L667">            sb.append(String.format(</span>
                &quot; (%d,%d) (%d,%d) theta1=%.0f theta2=%.0f intSqDiff=%.1f(%.1f)&quot;,
<span class="fc" id="L669">                compStat.getImg1Point().getX(), compStat.getImg1Point().getY(),</span>
<span class="fc" id="L670">                compStat.getImg2Point().getX(), compStat.getImg2Point().getY(),</span>
<span class="fc" id="L671">                compStat.getImg1PointRotInDegrees(), compStat.getImg2PointRotInDegrees(),</span>
<span class="fc" id="L672">                compStat.getSumIntensitySqDiff(),</span>
<span class="fc" id="L673">                compStat.getImg2PointIntensityErr()));</span>
<span class="fc" id="L674">        }</span>

<span class="fc" id="L676">        return sb.toString();</span>
    }

    protected double calculateCombinedIntensityStat(
        List&lt;FeatureComparisonStat&gt; compStats) {

<span class="fc" id="L682">        double sum = 0;</span>

<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (FeatureComparisonStat compStat : compStats) {</span>
<span class="fc" id="L685">            sum += compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L686">        }</span>

<span class="fc" id="L688">        sum /= (double)compStats.size();</span>

<span class="fc" id="L690">        return sum;</span>
    }

    protected TransformationParameters calculateTransformation(
        SegmentedImageHelper img1Helper, SegmentationType type1,
        boolean useBinned1,
        SegmentedImageHelper img2Helper, SegmentationType type2,
        boolean useBinned2,
        List&lt;FeatureComparisonStat&gt; compStats,
        float[] outputScaleRotTransXYStDev) {

<span class="pc bpc" id="L701" title="3 of 4 branches missed.">        assert(compStats.isEmpty() == false);</span>
        
<span class="fc" id="L703">        removeIntensityOutliers(compStats);</span>

<span class="fc" id="L705">        int binFactor1 = img1Helper.getBinFactor(useBinned1);</span>

<span class="fc" id="L707">        int binFactor2 = img2Helper.getBinFactor(useBinned2);</span>


<span class="fc" id="L710">        MatchedPointsTransformationCalculator tc = new</span>
            MatchedPointsTransformationCalculator();

<span class="fc" id="L713">        int centroidX1 = 0;</span>
<span class="fc" id="L714">        int centroidY1 = 0;</span>

<span class="fc" id="L716">        PairIntArray matchedXY1 = new PairIntArray();</span>
<span class="fc" id="L717">        PairIntArray matchedXY2 = new PairIntArray();</span>

<span class="fc" id="L719">        float[] weights = new float[compStats.size()];</span>

<span class="fc" id="L721">        double sum = 0;</span>

<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>

<span class="fc" id="L725">            FeatureComparisonStat compStat = compStats.get(i);</span>

<span class="fc" id="L727">            int x1 = compStat.getImg1Point().getX() * binFactor1;</span>
<span class="fc" id="L728">            int y1 = compStat.getImg1Point().getY() * binFactor1;</span>
<span class="fc" id="L729">            matchedXY1.add(x1, y1);</span>

<span class="fc" id="L731">            int x2 = compStat.getImg2Point().getX() * binFactor2;</span>
<span class="fc" id="L732">            int y2 = compStat.getImg2Point().getY() * binFactor2;</span>
<span class="fc" id="L733">            matchedXY2.add(x2, y2);</span>

<span class="fc" id="L735">            weights[i] = compStat.getSumIntensitySqDiff();</span>

<span class="fc" id="L737">            sum += weights[i];</span>
        }

<span class="fc" id="L740">        double tot = 0;</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
<span class="fc" id="L742">            double div = (sum - weights[i])/((compStats.size() - 1) * sum);</span>
<span class="fc" id="L743">            weights[i] = (float)div;</span>
<span class="fc" id="L744">            tot += div;</span>
        }

<span class="pc bpc" id="L747" title="3 of 4 branches missed.">        assert(Math.abs(tot - 1.) &lt; 0.03);</span>

<span class="fc" id="L749">        TransformationParameters params = tc.calulateEuclidean(</span>
            matchedXY1, matchedXY2, weights, centroidX1, centroidY1,
            outputScaleRotTransXYStDev);

<span class="fc" id="L753">        return params;</span>
    }
    
    /**
     * NOTE: this should only be used on a small area because it assumes that
     * rotation is negligible within region compared here.  It's assumed that
     * it's used on a blob of the size within min and max ranges passed
     * from BlobScaleFinderWrapper.
     * 
     * @param compStats 
     */
    protected void removeOutliersByLocation(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (compStats.size() &lt; 2) {</span>
<span class="fc" id="L767">            return;</span>
        }
        
        /* calculating avg dx and dy from the smallest intensities
        
        sorting by ascending SSD of intensity and keeping top half of them.
        then calculating avg dx and dy from those.
        */
        
<span class="fc" id="L776">        int n = compStats.size();</span>
<span class="fc" id="L777">        int nHalf = n/2;</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        if (nHalf == 0) {</span>
<span class="nc" id="L779">            nHalf = 1;</span>
        }
<span class="fc" id="L781">        FixedSizeSortedVector&lt;FeatureComparisonStat&gt; sorted </span>
            = new FixedSizeSortedVector&lt;FeatureComparisonStat&gt;(nHalf,
            FeatureComparisonStat.class);    
<span class="fc bfc" id="L784" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L785">            sorted.add(compStats.get(i));</span>
        }
<span class="fc" id="L787">        double avgDX = 0;</span>
<span class="fc" id="L788">        double avgDY = 0;</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        for (int i = 0; i &lt; sorted.getNumberOfItems(); ++i) {</span>
<span class="fc" id="L790">            FeatureComparisonStat stat = sorted.getArray()[i];</span>
<span class="fc" id="L791">            int diffX = stat.getImg1Point().getX() - stat.getImg2Point().getX();</span>
<span class="fc" id="L792">            int diffY = stat.getImg1Point().getY() - stat.getImg2Point().getY();</span>
<span class="fc" id="L793">            avgDX += diffX;</span>
<span class="fc" id="L794">            avgDY += diffY;</span>
        }
<span class="fc" id="L796">        avgDX /= (double)sorted.getNumberOfItems();</span>
<span class="fc" id="L797">        avgDY /= (double)sorted.getNumberOfItems();</span>
        
<span class="fc" id="L799">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L801">            FeatureComparisonStat stat = compStats.get(i);</span>
<span class="fc" id="L802">            int diffX = stat.getImg1Point().getX() - stat.getImg2Point().getX();</span>
<span class="fc" id="L803">            int diffY = stat.getImg1Point().getY() - stat.getImg2Point().getY();</span>
<span class="fc bfc" id="L804" title="All 4 branches covered.">            if ((Math.abs(diffX - avgDX) &gt; 5) || (Math.abs(diffY - avgDY) &gt; 5)) {</span>
<span class="fc" id="L805">                remove.add(Integer.valueOf(i));</span>
            }
        }
<span class="fc bfc" id="L808" title="All 2 branches covered.">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L809">            int idx = remove.get(i).intValue();</span>
<span class="fc" id="L810">            compStats.remove(idx);</span>
        }
<span class="fc" id="L812">    }</span>

    protected void removeOutliers(List&lt;FeatureComparisonStat&gt; compStats) {

<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (compStats.size() &lt; 2) {</span>
<span class="nc" id="L817">            return;</span>
        }

        //TODO: improve w/ a more robust outlier removal

<span class="nc" id="L822">        double[] errDivInt = new double[compStats.size()];</span>

<span class="nc" id="L824">        float[] weights = new float[compStats.size()];</span>
<span class="nc" id="L825">        double sum = 0;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
<span class="nc" id="L827">            FeatureComparisonStat compStat = compStats.get(i);</span>
<span class="nc" id="L828">            weights[i] = compStat.getSumIntensitySqDiff();</span>
<span class="nc" id="L829">            sum += weights[i];</span>
<span class="nc" id="L830">            errDivInt[i] = compStat.getImg2PointIntensityErr()/compStat.getSumIntensitySqDiff();</span>
        }
<span class="nc bnc" id="L832" title="All 2 branches missed.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
<span class="nc" id="L833">            double div = (sum - weights[i]) / ((compStats.size() - 1) * sum);</span>
<span class="nc" id="L834">            weights[i] = (float) div;</span>
        }
<span class="nc" id="L836">        float[] wghtsMeanAndStDev = MiscMath.getAvgAndStDev(weights);</span>
<span class="nc" id="L837">        float maxWeight = MiscMath.findMax(weights);</span>

        /*
        if all stats have intensities &lt; 5 times their errors and
        if the stdev is approx 0.15 times the mean or less, should filter here
        */
<span class="nc" id="L843">        boolean doNotFilter = true;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">        if ((wghtsMeanAndStDev[1]/wghtsMeanAndStDev[0]) &gt; 0.15) {</span>
<span class="nc" id="L845">            doNotFilter = false;</span>
        }
<span class="nc bnc" id="L847" title="All 2 branches missed.">        if (doNotFilter) {</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            for (int i = 0; i &lt; errDivInt.length; ++i) {</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">                if (errDivInt[i] &lt; 5) {</span>
<span class="nc" id="L850">                    doNotFilter = false;</span>
<span class="nc" id="L851">                    break;</span>
                }
            }
        }
        //TODO: may need revision
<span class="nc bnc" id="L856" title="All 4 branches missed.">        if (doNotFilter &amp;&amp; (weights.length &lt;= 4)) {</span>
<span class="nc" id="L857">            return;</span>
        }

<span class="nc" id="L860">        List&lt;FeatureComparisonStat&gt; filteredCompStats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
<span class="nc" id="L862">            float w = weights[i];</span>
<span class="nc" id="L863">            float diffW = Math.abs(maxWeight - w);</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (diffW &lt; (1.5 * wghtsMeanAndStDev[1])) {</span>
<span class="nc" id="L865">                filteredCompStats.add(compStats.get(i));</span>
            }
        }

<span class="nc" id="L869">        compStats.clear();</span>

<span class="nc" id="L871">        compStats.addAll(filteredCompStats);</span>
<span class="nc" id="L872">    }</span>

    protected List&lt;FeatureComparisonStat&gt; filterToBestConsistent(
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
        index1StatsMap, List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1Lists,
        List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours2Lists) {

<span class="pc bpc" id="L879" title="2 of 4 branches missed.">        if (index1StatsMap == null || index1StatsMap.isEmpty()) {</span>
<span class="nc" id="L880">            return null;</span>
        }
        
<span class="fc bfc" id="L883" title="All 2 branches covered.">        if (index1StatsMap.size() &gt; 1) {</span>
            // make corrections for cost between different edges            
<span class="fc" id="L885">            correctCostsUsingMaxSigma(index1StatsMap, contours1Lists);            </span>
        }
       
<span class="fc" id="L888">        TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; bestMatches = </span>
<span class="fc" id="L889">            findBestMatchesUsingBipartite(index1StatsMap, </span>
<span class="fc" id="L890">            contours1Lists.size(), contours2Lists.size());</span>

<span class="fc" id="L892">        int nMaxMatchable = 2 * Math.max(contours1Lists.size(), contours2Lists.size());</span>
     
<span class="fc" id="L894">        Map&lt;Integer, IntensityFeatureComparisonStats&gt; index1Map = new</span>
            HashMap&lt;Integer, IntensityFeatureComparisonStats&gt;();
            
<span class="fc" id="L897">        Map&lt;PairInt, PairFloat&gt; indexesDiffTheta = new HashMap&lt;PairInt, PairFloat&gt;();</span>
        
        /* calculate the highest number of similar transformations and the
        lowest cost from those.  store nSimilar, indexes, cost for each iteration*/
<span class="fc" id="L901">        int[] nSimilarSummary = new int[nMaxMatchable];</span>
<span class="fc" id="L902">        Integer[][] indexesSummary = new Integer[nMaxMatchable][];</span>
<span class="fc" id="L903">        double[] costsSummary = new double[nMaxMatchable];</span>
<span class="fc" id="L904">        int[] mainIndexSummary = new int[nMaxMatchable];</span>

<span class="fc" id="L906">        int count = 0;</span>
        
<span class="fc bfc" id="L908" title="All 2 branches covered.">        for (Map.Entry&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; entry : bestMatches.entrySet()) {</span>

<span class="fc" id="L910">            Double adjustedCost = entry.getKey();</span>
            
<span class="fc" id="L912">            List&lt;IntensityFeatureComparisonStats&gt; stats = entry.getValue();</span>
            
<span class="fc bfc" id="L914" title="All 2 branches covered.">            for (IntensityFeatureComparisonStats stat : stats) {</span>
<span class="fc" id="L915">                int idx1 = stat.getIndex1();</span>
<span class="fc" id="L916">                int idx2 = stat.getIndex2();</span>
<span class="pc bpc" id="L917" title="3 of 4 branches missed.">                assert(index1Map.get(Integer.valueOf(idx1)) == null);</span>
<span class="fc" id="L918">                index1Map.put(Integer.valueOf(idx1), stat);</span>
<span class="fc" id="L919">                PairInt p = new PairInt(idx1, idx2);</span>
<span class="fc" id="L920">                PairFloat diffThetaMnStdv = indexesDiffTheta.get(p);</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">                if (diffThetaMnStdv == null) {</span>
<span class="fc" id="L922">                    float[] diffThetas = new float[stat.getComparisonStats().size()];</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">                    for (int i = 0; i &lt; stat.getComparisonStats().size(); ++i) {</span>
<span class="fc" id="L924">                        FeatureComparisonStat fcs = stat.getComparisonStats().get(i);                </span>
<span class="fc" id="L925">                        float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L926">                           fcs.getImg1PointRotInDegrees(), fcs.getImg2PointRotInDegrees());</span>
<span class="fc" id="L927">                        diffThetas[i] = diff;</span>
                    }
<span class="fc" id="L929">                    float[] msv = MiscMath.getAvgAndStDev(diffThetas);</span>
                    
                    // TODO: consider whether need to exclude points further from
                    // the mean than a difference in thetaDiff of 20
                    // unless edits have changed it, this was run previously,
                    // so what is present here should already be consistent
                    // diffThetas:
                    //removeDiscrepantThetaDiff(stat.getComparisonStats());
                    
<span class="fc" id="L938">                    diffThetaMnStdv = new PairFloat(msv[0], msv[1]);</span>
                }
                
<span class="fc" id="L941">                double scale = stat.getScale();</span>
                
<span class="fc" id="L943">                Set&lt;Integer&gt; similarParamsIndexes1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L944">                similarParamsIndexes1.add(Integer.valueOf(idx1));</span>
                
                // count the number of solutions similar in diffTheta and scale
<span class="fc bfc" id="L947" title="All 2 branches covered.">                for (Map.Entry&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; entry2 : bestMatches.entrySet()) {</span>
<span class="fc" id="L948">                    Double adjustedCost2 = entry2.getKey();</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">                    if (adjustedCost2.equals(adjustedCost)) {</span>
<span class="fc" id="L950">                        continue;</span>
                    }
<span class="fc bfc" id="L952" title="All 2 branches covered.">                    for (IntensityFeatureComparisonStats stat2 : entry2.getValue()) {</span>
<span class="fc" id="L953">                        int idx1P = stat2.getIndex1();</span>
<span class="fc" id="L954">                        int idx2P = stat2.getIndex2();</span>
                        // bipartite matching should have made unique idx1 already:
<span class="pc bpc" id="L956" title="3 of 4 branches missed.">                        assert(idx1 != idx1P);</span>
<span class="fc" id="L957">                        PairInt p2 = new PairInt(idx1P, idx2P);</span>
<span class="fc" id="L958">                        PairFloat diffThetaMnStdv2 = indexesDiffTheta.get(p2);</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">                        if (diffThetaMnStdv2 == null) {</span>
<span class="fc" id="L960">                            float[] diffThetas = new float[stat2.getComparisonStats().size()];</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                            for (int i = 0; i &lt; stat2.getComparisonStats().size(); ++i) {</span>
<span class="fc" id="L962">                                FeatureComparisonStat fcs = stat2.getComparisonStats().get(i);                </span>
<span class="fc" id="L963">                                float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L964">                                    fcs.getImg1PointRotInDegrees(), fcs.getImg2PointRotInDegrees());</span>
<span class="fc" id="L965">                                diffThetas[i] = diff;</span>
                            }
<span class="fc" id="L967">                            float[] msv = MiscMath.getAvgAndStDev(diffThetas);</span>
<span class="fc" id="L968">                            diffThetaMnStdv2 = new PairFloat(msv[0], msv[1]);</span>
                        }
                        
                        //--- compare diffTheta and scale with ---
<span class="fc bfc" id="L972" title="All 2 branches covered.">                        if ((Math.abs(diffThetaMnStdv.getX() - diffThetaMnStdv2.getX()) &lt; 10)</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                            &amp;&amp; (Math.abs(scale - stat2.getScale()) &lt; 0.1)) {</span>
<span class="fc" id="L974">                            similarParamsIndexes1.add(Integer.valueOf(idx1P));</span>
                        }
<span class="fc" id="L976">                    }</span>
<span class="fc" id="L977">                }</span>
                
                // store for sort and combine
<span class="fc" id="L980">                nSimilarSummary[count] = similarParamsIndexes1.size();</span>
<span class="fc" id="L981">                indexesSummary[count] = similarParamsIndexes1.toArray(new Integer[similarParamsIndexes1.size()]);</span>
<span class="fc" id="L982">                costsSummary[count] = adjustedCost;</span>
<span class="fc" id="L983">                mainIndexSummary[count] = idx1;</span>
                
<span class="fc" id="L985">                count++;</span>
<span class="fc" id="L986">            }</span>
<span class="fc" id="L987">        }</span>
        
<span class="fc" id="L989">        nSimilarSummary = Arrays.copyOf(nSimilarSummary, count);</span>
<span class="fc" id="L990">        indexesSummary = Arrays.copyOf(indexesSummary, count);</span>
<span class="fc" id="L991">        costsSummary = Arrays.copyOf(costsSummary, count);</span>
<span class="fc" id="L992">        mainIndexSummary = Arrays.copyOf(mainIndexSummary, count);</span>
        
        // sort to prefer the solution w/ largest number of similar solutions:
        //MultiArrayMergeSort.sortBy1stDescThen2ndAsc(nSimilarSummary, costsSummary, indexesSummary, mainIndexSummary);

        // OR sort to refer the solution w/ best cost and any it is similar to:
        //--- these are still sorted by costs already, so no need to resort again ---
        // MultiArrayMergeSort.sortBy1stAscThen2ndDesc(costsSummary, nSimilarSummary, indexesSummary, mainIndexSummary, 0, costsSummary.length - 1);

<span class="fc" id="L1001">        Integer[] indexes = indexesSummary[0];</span>
       
<span class="fc" id="L1003">        List&lt;FeatureComparisonStat&gt; output = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        for (Integer index1 : indexes) {</span>
<span class="fc" id="L1005">            IntensityFeatureComparisonStats stats = index1Map.get(index1);</span>
<span class="fc" id="L1006">            output.addAll(stats.getComparisonStats());</span>
        }
<span class="fc" id="L1008">        return output;</span>
    }
    
    private List&lt;FeatureComparisonStat&gt; processSingleSolutionsIfNoBest(
        GreyscaleImage img1, GreyscaleImage img2,
        Map&lt;PairInt, CSSContourMatcherWrapper&gt; singleSolnMap,
        List&lt;Set&lt;PairInt&gt;&gt; blobs1, List&lt;Set&lt;PairInt&gt;&gt; blobs2,
        List&lt;PairIntArray&gt; perimeters1, List&lt;PairIntArray&gt; perimeters2,
        IntensityFeatures features1, IntensityFeatures features2) {

<span class="fc" id="L1018">log.info(&quot;WARNING: processing single solutions... may remove these in future&quot;);</span>

<span class="fc" id="L1020">        List&lt;FeatureComparisonStat&gt; csList = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc" id="L1022">        int nm = singleSolnMap.size();</span>
        
<span class="fc" id="L1024">        double[] costs = new double[nm];</span>
<span class="fc" id="L1025">        int[] idx1s = new int[nm];</span>
<span class="fc" id="L1026">        int[] idx2s = new int[nm];</span>
<span class="fc" id="L1027">        FeatureComparisonStat[] ifs = new FeatureComparisonStat[nm];</span>
        
<span class="fc" id="L1029">        int count = 0;</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">        for (Entry&lt;PairInt, CSSContourMatcherWrapper&gt; entry : singleSolnMap.entrySet()) {</span>
            
<span class="fc" id="L1032">            PairInt index1Index2 = entry.getKey();</span>
<span class="fc" id="L1033">            int idx1 = index1Index2.getX();</span>
<span class="fc" id="L1034">            int idx2 = index1Index2.getY();</span>
            
<span class="fc" id="L1036">            CSSContourMatcherWrapper matcher = entry.getValue();</span>
            
<span class="fc" id="L1038">            PairIntArray curve1 = perimeters1.get(idx1);</span>
<span class="fc" id="L1039">            Set&lt;PairInt&gt; blob1 = blobs1.get(idx1);</span>
<span class="fc" id="L1040">            PairIntArray curve2 = perimeters2.get(idx2);</span>
<span class="fc" id="L1041">            Set&lt;PairInt&gt; blob2 = blobs2.get(idx2);</span>

<span class="fc" id="L1043">            List&lt;FeatureComparisonStat&gt; compStats =</span>
<span class="fc" id="L1044">                filterContourPointsByFeatures(img1, img2,</span>
<span class="fc" id="L1045">                Integer.valueOf(idx1), Integer.valueOf(idx2),</span>
                blob1, blob2, curve1, curve2, features1, features2,
                matcher);

<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">            if (compStats.isEmpty()) {</span>
<span class="nc" id="L1050">                continue;</span>
            }
            
<span class="pc bpc" id="L1053" title="3 of 4 branches missed.">            assert(compStats.size() == 1);</span>

<span class="fc" id="L1055">            double combStat = calculateCombinedIntensityStat(compStats);</span>

<span class="fc" id="L1057">            idx1s[count] = idx1;</span>
<span class="fc" id="L1058">            idx2s[count] = idx2;</span>
<span class="fc" id="L1059">            ifs[count] = compStats.get(0);</span>

            //ssd of intensity is a better selector for one dataset. this may change w/ more testing
            //costs[count] = stats.getAdjustedCost();
<span class="fc" id="L1063">            costs[count] = combStat;</span>
            
<span class="fc" id="L1065">            count++;</span>
<span class="fc" id="L1066">        }</span>
<span class="fc" id="L1067">        costs = Arrays.copyOf(costs, count);</span>
<span class="fc" id="L1068">        idx1s = Arrays.copyOf(idx1s, count);</span>
<span class="fc" id="L1069">        idx2s = Arrays.copyOf(idx2s, count);</span>
<span class="fc" id="L1070">        ifs = Arrays.copyOf(ifs, count);</span>
<span class="fc" id="L1071">        int[] lookupIndexes = new int[count];</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L1073">            lookupIndexes[i] = i;</span>
        }
        // best will be at bottom of list:
<span class="fc" id="L1076">        MultiArrayMergeSort.sortByDecr(costs, lookupIndexes);</span>
        
<span class="fc" id="L1078">        float ssdBest = ifs[lookupIndexes[count - 1]].getSumIntensitySqDiff();</span>
        
<span class="fc" id="L1080">        float thetaDiffBest = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L1081">            ifs[lookupIndexes[count - 1]].getImg1PointRotInDegrees(),</span>
<span class="fc" id="L1082">            ifs[lookupIndexes[count - 1]].getImg2PointRotInDegrees());</span>
        
<span class="fc" id="L1084">        int count2 = 0;</span>
<span class="fc" id="L1085">        double[] costs2 = new double[count];</span>
<span class="fc" id="L1086">        int[] idx1s2 = new int[count];</span>
<span class="fc" id="L1087">        int[] idx2s2 = new int[count];</span>
<span class="fc" id="L1088">        FeatureComparisonStat[] ifs2 = new FeatureComparisonStat[count];</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L1090">            int idx0 = lookupIndexes[i];</span>
<span class="fc" id="L1091">            FeatureComparisonStat fcs = ifs[idx0];</span>
<span class="fc" id="L1092">            double ssd = fcs.getSumIntensitySqDiff();</span>

<span class="fc" id="L1094">            float dtm = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L1095">                fcs.getImg1PointRotInDegrees(), fcs.getImg2PointRotInDegrees());</span>

<span class="fc bfc" id="L1097" title="All 2 branches covered.">            if (Math.abs(dtm - thetaDiffBest) &gt; 20) {</span>
<span class="fc" id="L1098">                continue;</span>
            }
            
<span class="fc bfc" id="L1101" title="All 2 branches covered.">            if (ssd &gt; (3 * ssdBest)) {</span>
<span class="fc" id="L1102">                continue;</span>
            }

<span class="fc" id="L1105">            costs2[count2] = costs[i];</span>
<span class="fc" id="L1106">            idx1s2[count2] = idx1s[idx0];</span>
<span class="fc" id="L1107">            idx2s2[count2] = idx2s[idx0];</span>
<span class="fc" id="L1108">            ifs2[count2] = fcs;</span>
            
<span class="fc" id="L1110">            count2++;</span>
        }
<span class="fc" id="L1112">        costs2 = Arrays.copyOf(costs2, count2);</span>
<span class="fc" id="L1113">        idx1s2 = Arrays.copyOf(idx1s2, count2);</span>
<span class="fc" id="L1114">        idx2s2 = Arrays.copyOf(idx2s2, count2);</span>
<span class="fc" id="L1115">        ifs2 = Arrays.copyOf(ifs2, count2);</span>
        
<span class="fc" id="L1117">        Set&lt;Integer&gt; chosen1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1118">        Set&lt;Integer&gt; chosen2 = new HashSet&lt;Integer&gt;();</span>

<span class="fc bfc" id="L1120" title="All 2 branches covered.">        for (int i = 0; i &lt; count2; ++i) {</span>

<span class="fc" id="L1122">            Integer index1 = Integer.valueOf(idx1s2[i]);</span>
<span class="fc" id="L1123">            Integer index2 = Integer.valueOf(idx2s2[i]);</span>

<span class="fc bfc" id="L1125" title="All 2 branches covered.">            if (chosen1.contains(index1)) {</span>
<span class="fc" id="L1126">                continue;</span>
            }
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">            if (chosen2.contains(index2)) {</span>
<span class="nc" id="L1129">                continue;</span>
            }
            
<span class="fc" id="L1132">            Double cost = Double.valueOf(costs2[i]);</span>
<span class="fc" id="L1133">            FeatureComparisonStat ifcs = ifs2[i];</span>

            // only true if still using costs rather than SSD:
            //assert(Math.abs(cost.doubleValue() - ifcs.getAdjustedCost()) &lt; 0.01);

<span class="fc" id="L1138">            csList.add(ifcs);</span>

<span class="fc" id="L1140">            chosen1.add(index1);</span>
<span class="fc" id="L1141">            chosen2.add(index2);</span>
        }
        
<span class="fc" id="L1144">        return csList;</span>
    }
    
    private float[] calculateThetaDiff(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="pc bpc" id="L1149" title="2 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="nc" id="L1150">            return null;</span>
        }
        
<span class="fc" id="L1153">        float[] values = new float[compStats.size()];</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">        for (int i = 0; i &lt; compStats.size(); ++i) {</span>
<span class="fc" id="L1155">            FeatureComparisonStat stat = compStats.get(i);</span>
<span class="fc" id="L1156">            float diff = AngleUtil.getAngleDifference(</span>
<span class="fc" id="L1157">                stat.getImg1PointRotInDegrees(),</span>
<span class="fc" id="L1158">                stat.getImg2PointRotInDegrees());</span>
<span class="fc" id="L1159">            values[i] = diff;</span>
        }
        
<span class="fc" id="L1162">        return values;</span>
    }

    private void removeDiscrepantThetaDiff(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="pc bpc" id="L1167" title="1 of 4 branches missed.">        if (compStats == null || compStats.isEmpty()) {</span>
<span class="fc" id="L1168">            return;</span>
        }
        
<span class="fc" id="L1171">        float[] values = calculateThetaDiff(compStats);</span>
        
        // 20 degree wide bins
<span class="fc" id="L1174">        HistogramHolder hist = Histogram.createSimpleHistogram(20.f,</span>
<span class="fc" id="L1175">            values, Errors.populateYErrorsBySqrt(values));</span>
<span class="fc" id="L1176">        int yMaxIdx = MiscMath.findYMaxIndex(hist.getYHist());</span>
        float thetaDiff;
<span class="fc bfc" id="L1178" title="All 2 branches covered.">        if (yMaxIdx == -1) {</span>
<span class="fc" id="L1179">            float[] thetaDiffMeanStDev = MiscMath.getAvgAndStDev(values);</span>
<span class="fc" id="L1180">            thetaDiff = thetaDiffMeanStDev[0];</span>
<span class="fc" id="L1181">        } else {</span>
<span class="fc" id="L1182">            thetaDiff = hist.getXHist()[yMaxIdx];</span>
        }        
        
        //TODO: consider a bin larger than 20 degrees... 25
<span class="fc" id="L1186">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1188">            float diffRot = Math.abs(values[i] - thetaDiff);</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            if (diffRot &gt; 20) {</span>
<span class="fc" id="L1190">                remove.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1195">            int idx = remove.get(i);</span>
<span class="fc" id="L1196">            compStats.remove(idx);</span>
        }
<span class="fc" id="L1198">    }</span>

    private void correctCostsUsingMaxSigma(
        Map&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; 
            index1StatsMap, List&lt;List&lt;CurvatureScaleSpaceContour&gt;&gt; contours1Lists) {
                
<span class="fc" id="L1204">        float maxPeakSigma = Float.MIN_VALUE;</span>
        
<span class="fc" id="L1206">        Map&lt;Integer, Float&gt; index1PeakSigma = new HashMap&lt;Integer, Float&gt;();</span>
        
        for (Entry&lt;Integer, FixedSizeSortedVector&lt;
<span class="fc bfc" id="L1209" title="All 2 branches covered.">            IntensityFeatureComparisonStats&gt;&gt; entry : index1StatsMap.entrySet()) {</span>
            
<span class="fc" id="L1211">            Integer index1 = entry.getKey();</span>
            
<span class="fc" id="L1213">            List&lt;CurvatureScaleSpaceContour&gt; contours = contours1Lists.get(index1.intValue());</span>
           
            // contours are ordered, so just need the first.
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">            if (contours.isEmpty()) {</span>
<span class="nc" id="L1217">                continue;</span>
            }
<span class="fc" id="L1219">            float peakSigma = contours.get(0).getPeakSigma();</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">            if (peakSigma &gt; maxPeakSigma) {</span>
<span class="fc" id="L1221">                maxPeakSigma = peakSigma;</span>
            }
            // contour 6 is not a strong blob by has maxsigma=166 which is &gt;4*expected from 0
<span class="fc" id="L1224">            index1PeakSigma.put(index1, Float.valueOf(peakSigma));</span>
<span class="fc" id="L1225">        }</span>
        
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        for (Entry&lt;Integer, Float&gt; entry : index1PeakSigma.entrySet()) {</span>
            
<span class="fc" id="L1229">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L1230">            double penalty = maxPeakSigma - entry.getValue().floatValue();</span>
            
<span class="fc" id="L1232">            FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt; index1Stats =</span>
<span class="fc" id="L1233">                index1StatsMap.get(index1);</span>
            
<span class="fc bfc" id="L1235" title="All 2 branches covered.">            for (int i = 0; i &lt; index1Stats.getNumberOfItems(); ++i) {</span>
                
<span class="fc" id="L1237">                IntensityFeatureComparisonStats stats = index1Stats.getArray()[i];</span>
                                
<span class="fc" id="L1239">                stats.setAdjustedCost(stats.getCost() + penalty);</span>
            }
<span class="fc" id="L1241">        }</span>
<span class="fc" id="L1242">    }</span>

    /**
     * bipartite matching after sorting by largest number of matches and lowest
     * cost then greedily choosing from that order.
     * @param index1StatsMap
     * @param n1
     * @param n2
     * @return 
     */
    private TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; 
    findBestMatchesUsingBipartite(Map&lt;Integer, 
        FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt; index1StatsMap,
        int n1, int n2) {
        
<span class="fc" id="L1257">        TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; matched = new</span>
            TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt;();
        
<span class="fc" id="L1260">        int maxMatchable = 2 * Math.max(n1, n2);</span>
                
<span class="fc" id="L1262">        double[] costs = new double[maxMatchable];</span>
<span class="fc" id="L1263">        int[] idx1s = new int[maxMatchable];</span>
<span class="fc" id="L1264">        int[] idx2s = new int[maxMatchable];</span>
<span class="fc" id="L1265">        int[] nMatches = new int[maxMatchable];</span>
<span class="fc" id="L1266">        IntensityFeatureComparisonStats[] ics = new IntensityFeatureComparisonStats[maxMatchable];</span>
        
<span class="fc" id="L1268">        int count = 0;</span>
        for (Entry&lt;Integer, FixedSizeSortedVector&lt;IntensityFeatureComparisonStats&gt;&gt;
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            entry : index1StatsMap.entrySet()) {</span>
<span class="fc" id="L1271">            Integer index1 = entry.getKey();            </span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">            for (IntensityFeatureComparisonStats stats : entry.getValue().getArray()) {</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">                if (stats == null) {</span>
<span class="fc" id="L1274">                    continue;</span>
                }
<span class="pc bpc" id="L1276" title="3 of 4 branches missed.">                assert(index1.intValue() == stats.getIndex1());</span>
                
<span class="fc" id="L1278">                idx1s[count] = stats.getIndex1();</span>
<span class="fc" id="L1279">                idx2s[count] = stats.getIndex2();</span>
<span class="fc" id="L1280">                ics[count] = stats;</span>
<span class="fc" id="L1281">                nMatches[count] = stats.getComparisonStats().size();</span>
                
                //ssd of intensity is a better selector for one dataset. this may change w/ more testing
                //costs[count] = stats.getAdjustedCost();
<span class="fc" id="L1285">                costs[count] = calculateCombinedIntensityStat(stats.getComparisonStats());</span>
                
<span class="fc" id="L1287">                count++;</span>
            }
<span class="fc" id="L1289">        }</span>
<span class="fc" id="L1290">        costs = Arrays.copyOf(costs, count);</span>
<span class="fc" id="L1291">        idx1s = Arrays.copyOf(idx1s, count);</span>
<span class="fc" id="L1292">        idx2s = Arrays.copyOf(idx2s, count);</span>
<span class="fc" id="L1293">        ics = Arrays.copyOf(ics, count);</span>
<span class="fc" id="L1294">        nMatches = Arrays.copyOf(nMatches, count);</span>
<span class="fc" id="L1295">        int[] lookupIndexes = new int[count];</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L1297">            lookupIndexes[i] = i;</span>
        }
        
        //sort for the highest number of matches having the lowest costs.
        // decr nMatches, asc costs
<span class="fc" id="L1302">        MultiArrayMergeSort.sortBy1stDescThen2ndAsc(nMatches, costs, lookupIndexes);</span>
        
        /*
        adding another filter based upon the SSD of intensity features for the
        top number of matches and lowest cost.
        This uses the average and standard deviation from it if there are
        more than 2 SSD stats and removes all other matches in the list
        where the SSD is larger than 2 sigma or so from that difference.
        It's not the most stable filter considering that some regions surrounding
        a contour may have extremely high variability, but it should usually be
        better to use this filter.
        
        Also, looks like it's necessary to filter for the difference in theta
        when it's much larger than the top difference in theta.
        */
<span class="fc" id="L1317">        float[] ssdMeanStDv = calcIntensitySSDMeanAndStDev(</span>
<span class="fc" id="L1318">            ics[lookupIndexes[0]].getComparisonStats());</span>
        
<span class="fc" id="L1320">        float diffInThetaMean = calculateDiffThetaMean(ics[lookupIndexes[0]].getComparisonStats());</span>
        
<span class="fc" id="L1322">        int count2 = 0;</span>
<span class="fc" id="L1323">        double[] costs2 = new double[count];</span>
<span class="fc" id="L1324">        int[] idx1s2 = new int[count];</span>
<span class="fc" id="L1325">        int[] idx2s2 = new int[count];</span>
<span class="fc" id="L1326">        int[] nMatches2 = new int[count];</span>
<span class="fc" id="L1327">        IntensityFeatureComparisonStats[] ics2 = new IntensityFeatureComparisonStats[count];</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="fc" id="L1329">            int idx0 = lookupIndexes[i];</span>
<span class="fc" id="L1330">            IntensityFeatureComparisonStats ifcs = ics[idx0];</span>
<span class="fc" id="L1331">            double ssd = calculateCombinedIntensityStat(ifcs.getComparisonStats());</span>
            
<span class="fc bfc" id="L1333" title="All 2 branches covered.">            if (ssd &gt; (ssdMeanStDv[0] + (2 * ssdMeanStDv[1]))) {</span>
<span class="fc" id="L1334">                continue;</span>
            }
                            
<span class="fc" id="L1337">            float dtm = calculateDiffThetaMean(ifcs.getComparisonStats());</span>
                
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">            if (Math.abs(dtm - diffInThetaMean) &gt; 20) {</span>
<span class="nc" id="L1340">                continue;</span>
            }
                
<span class="fc" id="L1343">            costs2[count2] = costs[i];</span>
<span class="fc" id="L1344">            idx1s2[count2] = idx1s[idx0];</span>
<span class="fc" id="L1345">            idx2s2[count2] = idx2s[idx0];</span>
<span class="fc" id="L1346">            ics2[count2] = ics[idx0];</span>
<span class="fc" id="L1347">            nMatches2[count2] = nMatches[i];</span>
<span class="fc" id="L1348">            count2++;</span>
        }
<span class="fc" id="L1350">        costs2 = Arrays.copyOf(costs2, count2);</span>
<span class="fc" id="L1351">        idx1s2 = Arrays.copyOf(idx1s2, count2);</span>
<span class="fc" id="L1352">        idx2s2 = Arrays.copyOf(idx2s2, count2);</span>
<span class="fc" id="L1353">        ics2 = Arrays.copyOf(ics2, count2);</span>
<span class="fc" id="L1354">        nMatches2 = Arrays.copyOf(nMatches2, count2);</span>
        
<span class="fc" id="L1356">        Set&lt;Integer&gt; chosen1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L1357">        Set&lt;Integer&gt; chosen2 = new HashSet&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L1359" title="All 2 branches covered.">        for (int i = 0; i &lt; count2; ++i) {</span>
                        
<span class="fc" id="L1361">            Integer index1 = Integer.valueOf(idx1s2[i]);</span>
<span class="fc" id="L1362">            Integer index2 = Integer.valueOf(idx2s2[i]);</span>
            
<span class="fc bfc" id="L1364" title="All 2 branches covered.">            if (chosen1.contains(index1)) {</span>
<span class="fc" id="L1365">                continue;</span>
            }
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">            if (chosen2.contains(index2)) {</span>
<span class="nc" id="L1368">                continue;</span>
            }
            
<span class="fc" id="L1371">            Double cost = Double.valueOf(costs2[i]);</span>
<span class="fc" id="L1372">            IntensityFeatureComparisonStats ifcs = ics2[i];</span>
              
            // only true if still using costs rather than SSD:
            //assert(Math.abs(cost.doubleValue() - ifcs.getAdjustedCost()) &lt; 0.01);
            
            /*
            TreeMap&lt;Double, List&lt;IntensityFeatureComparisonStats&gt;&gt; matched
            */
<span class="fc" id="L1380">            List&lt;IntensityFeatureComparisonStats&gt; ifcsList = matched.get(cost);</span>
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">            if (ifcsList == null) {</span>
<span class="fc" id="L1382">                ifcsList = new ArrayList&lt;IntensityFeatureComparisonStats&gt;();</span>
<span class="fc" id="L1383">                matched.put(cost, ifcsList);</span>
            }
<span class="fc" id="L1385">            ifcsList.add(ifcs);</span>
                
<span class="fc" id="L1387">            chosen1.add(index1);</span>
<span class="fc" id="L1388">            chosen2.add(index2);</span>
        }
        
<span class="fc" id="L1391">        return matched;</span>
    }
    
    private float[] calcIntensitySSDMeanAndStDev(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc" id="L1396">        int n = compStats.size();</span>
        
<span class="fc" id="L1398">        float[] ssds = new float[n];</span>
        
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1401">            FeatureComparisonStat stat = compStats.get(i);</span>
<span class="fc" id="L1402">            ssds[i] = stat.getSumIntensitySqDiff();</span>
        }
        
<span class="fc" id="L1405">        float[] meanStDv = MiscMath.getAvgAndStDev(ssds);</span>
        
<span class="fc" id="L1407">        return meanStDv;</span>
    }

    private void removeIntensityOutliers(List&lt;FeatureComparisonStat&gt; compStats) {
        
<span class="fc bfc" id="L1412" title="All 2 branches covered.">        if (compStats.size() &lt; 3) {</span>
<span class="fc" id="L1413">            return;</span>
        }
                
<span class="fc" id="L1416">        int n = compStats.size();</span>
        
<span class="fc" id="L1418">        float[] meanStDv = calcIntensitySSDMeanAndStDev(compStats);</span>
        
<span class="fc" id="L1420">        List&lt;Integer&gt; rm = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1422">            FeatureComparisonStat stat = compStats.get(i);</span>
<span class="fc" id="L1423">            float diff = Math.abs(stat.getSumIntensitySqDiff() - meanStDv[0]);</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">            if (diff &gt; (1.25*meanStDv[1])) {</span>
<span class="fc" id="L1425">                rm.add(Integer.valueOf(i));</span>
            }
        }
        
<span class="fc bfc" id="L1429" title="All 2 branches covered.">        for (int i = (rm.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1430">            int idx = rm.get(i).intValue();</span>
<span class="fc" id="L1431">            compStats.remove(idx);</span>
        }
<span class="fc" id="L1433">    }</span>

    private float calculateDiffThetaMean(List&lt;FeatureComparisonStat&gt; comparisonStats) {
        
<span class="fc" id="L1437">        float[] values = calculateThetaDiff(comparisonStats);</span>
        
<span class="pc bpc" id="L1439" title="2 of 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="nc" id="L1440">            return Float.POSITIVE_INFINITY;</span>
        }

<span class="fc" id="L1443">        double sum = 0;</span>
        
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1446">            sum += values[i];</span>
        }
        
<span class="fc" id="L1449">        return (float)(sum/((float)values.length));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
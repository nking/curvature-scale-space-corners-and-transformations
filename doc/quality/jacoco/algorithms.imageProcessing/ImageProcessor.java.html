<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageProcessor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageProcessor.java</span></div><h1>ImageProcessor.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.MultiArrayMergeSort;
import algorithms.bipartite.MinHeapForRT2012;
import algorithms.compGeometry.PerimeterFinder2;
import algorithms.imageProcessing.features.orb.ORB;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonAndPointPlotter;
import algorithms.util.PairInt;
import algorithms.misc.Complex;
import algorithms.misc.ComplexModifiable;
import algorithms.misc.Histogram;
import algorithms.misc.MedianSmooth;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.StatsInSlidingWindow;
import algorithms.util.ResourceFinder;
import algorithms.util.TwoDFloatArray;
import algorithms.util.VeryLongBitString;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TFloatArrayList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.TObjectIntMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;
import thirdparty.ca.uol.aig.fftpack.Complex1D;
import thirdparty.ca.uol.aig.fftpack.ComplexDoubleFFT;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">public class ImageProcessor {</span>

<span class="fc" id="L59">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * use a sobel (first deriv gaussian sigma=0.5, binomial [-1, 0,1]
     * and return gradients in X and y. note the image may contain
     * negative values.
     * @param input
     * @return 
     */
    public GreyscaleImage[] createSobelGradients(GreyscaleImage input) {
    
<span class="fc" id="L70">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>
        
<span class="fc" id="L72">        GreyscaleImage gX = input.copyToFullRangeIntImage();</span>
<span class="fc" id="L73">        GreyscaleImage gY = input.copyToFullRangeIntImage();</span>
<span class="fc" id="L74">        applyKernel1D(gX, kernel, true);</span>
<span class="fc" id="L75">        applyKernel1D(gY, kernel, false);</span>
        
<span class="fc" id="L77">        return new GreyscaleImage[]{gX, gY};</span>
    }

    public void applySobelKernel(GreyscaleImage input) {

<span class="fc" id="L82">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>
        
<span class="fc" id="L84">        GreyscaleImage gX = input.copyToFullRangeIntImage();</span>
<span class="fc" id="L85">        GreyscaleImage gY = input.copyToFullRangeIntImage();</span>
<span class="fc" id="L86">        applyKernel1D(gX, kernel, true);</span>
<span class="fc" id="L87">        applyKernel1D(gY, kernel, false);</span>
        
<span class="fc" id="L89">        GreyscaleImage img2 = combineConvolvedImages(gX, gY);</span>

<span class="fc" id="L91">        input.resetTo(img2);</span>
<span class="fc" id="L92">    }</span>
    
    /**
     * given a color image array with first dimension being color index
     * and the second dimension being the image pixel index,
     * apply the sobel kernel to each pixel and combine the results
     * as SSD.
     * @param ptImg polar theta image of a color space such as 
     * H of LCH that contains values between 0 and 255.
     * @param lowerDiff value in degrees for which a difference in
     * pixels results in a final value of &quot;1&quot;.  For example,
     * 20 degrees.
     */
    public GreyscaleImage createBinarySobelForPolarTheta(
        GreyscaleImage ptImg, int lowerDiff) {

<span class="fc" id="L108">        int nPix = ptImg.getNPixels();</span>
<span class="fc" id="L109">        int w = ptImg.getWidth();</span>
<span class="fc" id="L110">        int h = ptImg.getHeight();</span>
        
<span class="fc" id="L112">        GreyscaleImage out = ptImg.createWithDimensions();</span>
        
        // sobel is .5, 0, -.5 so looking for difference in pixels on either
        //   side being .lte. lowerDiff
<span class="fc" id="L116">        int[] diffs = new int[4];</span>
        int offset;
        int above;
<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (int i = 1; i &lt; w - 1; ++i) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            for (int j = 1; j &lt; h - 1; ++j) {</span>
                
<span class="fc" id="L122">                diffs[0] = ptImg.getValue(i - 1, j);</span>
<span class="fc" id="L123">                diffs[1] = ptImg.getValue(i + 1, j);                </span>
<span class="fc" id="L124">                diffs[2] = ptImg.getValue(i, j - 1);</span>
<span class="fc" id="L125">                diffs[3] = ptImg.getValue(i, j + 1);</span>
<span class="fc" id="L126">                offset = 0;            </span>
<span class="fc" id="L127">                above = 0;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">                for (int k = 0; k &lt; 2; ++k) {</span>
                    // in case there is wrap around, test adding a phase
                    //   and take the smaller of the results for each diff.
<span class="fc bfc" id="L131" title="All 2 branches covered.">                    if (diffs[offset] &gt; diffs[offset + 1]) {</span>
                        // add a phase to next value if it's closer to current with addition
<span class="fc bfc" id="L133" title="All 2 branches covered.">                        if ((diffs[offset] - diffs[offset + 1]) &gt; </span>
                            (diffs[offset + 1] + 255) - diffs[offset]) {
<span class="fc" id="L135">                            diffs[offset + 1] += 255;</span>
                        }
<span class="fc bfc" id="L137" title="All 2 branches covered.">                    } else if (diffs[offset + 1] &gt; diffs[offset]) {</span>
                        // add a phase to next value if it's closer to current with addition
<span class="fc bfc" id="L139" title="All 2 branches covered.">                        if ((diffs[offset + 1] - diffs[offset]) &gt; </span>
                            (diffs[offset] + 255) - diffs[offset + 1]) {
<span class="fc" id="L141">                            diffs[offset] += 255;</span>
                        }
                    }
<span class="fc" id="L144">                    int d = diffs[offset] - diffs[offset + 1];</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                    if (Math.abs(d) &gt;= lowerDiff) {</span>
<span class="fc" id="L146">                        above = 1;</span>
<span class="fc" id="L147">                        break;</span>
                    }
<span class="fc" id="L149">                    offset += 2;</span>
                }

<span class="fc bfc" id="L152" title="All 2 branches covered.">                if (above == 1) {                </span>
<span class="fc" id="L153">                    out.setValue(i, j, 1);</span>
                }
            }
        }
        
<span class="fc" id="L158">        return out;</span>
    }
    
    /**
     * given a color image array with first dimension being color index
     * and the second dimension being the image pixel index,
     * apply the sobel kernel to each pixel and combine the results
     * as SSD.
     * @param ptImg polar theta image of a color space such as 
     * H of LCH that contains values between 0 and 255.
     * @param lowerDiff value in degrees for which a difference in
     * pixels results in a final value of &quot;1&quot;.  For example,
     * 20 degrees.
     * @return 
     */
    public GreyscaleImage createBinary2ndDerivForPolarTheta(
        GreyscaleImage ptImg, int lowerDiff) {

<span class="nc" id="L176">        int nPix = ptImg.getNPixels();</span>
<span class="nc" id="L177">        int w = ptImg.getWidth();</span>
<span class="nc" id="L178">        int h = ptImg.getHeight();</span>
        
<span class="nc" id="L180">        GreyscaleImage out = ptImg.createWithDimensions();</span>
        
        // sobel is .5, 0, -.5 so looking for difference in pixels on either
        //   side being .lte. lowerDiff
<span class="nc" id="L184">        int[] diffs = new int[2];</span>
        int offset;
        int above;
<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (int i = 1; i &lt; w - 1; ++i) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            for (int j = 1; j &lt; h - 1; ++j) {</span>
                
                // kernel for 2nd deriv, binomial 1 -2  1 
                
<span class="nc" id="L192">                int v = 2 * ptImg.getValue(i, j);</span>
                
<span class="nc" id="L194">                diffs[0] = ptImg.getValue(i - 1, j) + ptImg.getValue(i + 1, j);                </span>
<span class="nc" id="L195">                diffs[1] = ptImg.getValue(i, j - 1) + ptImg.getValue(i, j + 1);</span>
<span class="nc" id="L196">                offset = 0;            </span>
<span class="nc" id="L197">                above = 0;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                for (int k = 0; k &lt; 2; ++k) {</span>
<span class="nc" id="L199">                    int v0 = v;</span>
                    // in case there is wrap around, test adding a phase
                    //   and take the smaller of the results for each diff.
<span class="nc bnc" id="L202" title="All 2 branches missed.">                    if (diffs[offset] &gt; v0) {</span>
                        // add a phase to next value if it's closer to current with addition
<span class="nc bnc" id="L204" title="All 2 branches missed.">                        if ((diffs[offset] - v0) &gt; </span>
                            (v0 + 255) - diffs[offset]) {
<span class="nc" id="L206">                            v0 += 255;</span>
                        }
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    } else if (v0 &gt; diffs[offset]) {</span>
                        // add a phase to next value if it's closer to current with addition
<span class="nc bnc" id="L210" title="All 2 branches missed.">                        if ((v0 - diffs[offset]) &gt; </span>
                            (diffs[offset] + 255) - v0) {
<span class="nc" id="L212">                            diffs[offset] += 255;</span>
                        }
                    }
<span class="nc" id="L215">                    int d = diffs[offset] - v0;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                    if (Math.abs(d) &gt;= lowerDiff) {</span>
<span class="nc" id="L217">                        above = 1;</span>
<span class="nc" id="L218">                        break;</span>
                    }
<span class="nc" id="L220">                    offset++;</span>
                }

<span class="nc bnc" id="L223" title="All 2 branches missed.">                if (above == 1) {                </span>
<span class="nc" id="L224">                    out.setValue(i, j, 1);</span>
                }
            }
        }
        
<span class="nc" id="L229">        return out;</span>
    }
    
    /**
     * create  a float array from the image (the image is not scaled).
     * @param img
     * @return 
     */
    public float[] convertToFloat(GreyscaleImage img) {
        
<span class="nc" id="L239">        float[] a = new float[img.getNPixels()];</span>
        
<span class="nc bnc" id="L241" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L242">            a[i] = img.getValue(i);</span>
        }
        
<span class="nc" id="L245">        return a;</span>
    }
    
    /**
     * create  a int array from the image (the image is not scaled).
     * @param img
     * @return 
     */
    public int[] convertToInt(GreyscaleImage img) {
        
<span class="fc" id="L255">        int[] a = new int[img.getNPixels()];</span>
        
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L258">            a[i] = img.getValue(i);</span>
        }
        
<span class="fc" id="L261">        return a;</span>
    }
    
    /**
     * using the binary results from createBinarySobelForPolarTheta
     * and the greyscale results from sobel operator,
     * scale the greyscale sobel so that the maximum value is 1.f,
     * add both and divide by 2.
     * NOTE: for other uses, may want to make a method which does not
     * scale the greyscale results or uses a different weighting 
     * in the addition.
     * 
     * @param gsImg
     * @param ptImg
     * @param lowerDiff
     * @return 
     */
    public float[] createSobelColorScores(GreyscaleImage gsImg,
        GreyscaleImage ptImg, int lowerDiff) {
        
<span class="nc" id="L281">        int nPix = gsImg.getNPixels();</span>
<span class="nc" id="L282">        int w = gsImg.getWidth();</span>
<span class="nc" id="L283">        int h = gsImg.getHeight();</span>
        
<span class="nc bnc" id="L285" title="All 4 branches missed.">        if (ptImg.getWidth() != w || ptImg.getHeight() != h) {</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(&quot;images must be same size&quot;);</span>
        }
        
<span class="nc" id="L289">        GreyscaleImage ptGrad = createBinarySobelForPolarTheta(</span>
            ptImg, lowerDiff);
        
<span class="nc" id="L292">        float[] out = new float[nPix];</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        for (int i = 0; i &lt; gsImg.getNPixels(); ++i) {</span>
<span class="nc" id="L294">            out[i] = gsImg.getValue(i);</span>
        }
        
<span class="nc" id="L297">        out = createSobelConvolution(out, w, h);</span>
<span class="nc" id="L298">        float maxV = MiscMath.findMax(out);</span>
<span class="nc" id="L299">        float factor = 0.5f/maxV;</span>
        int pixIdx;
<span class="nc bnc" id="L301" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L303">                pixIdx = (j * w) + i;</span>
                
<span class="nc" id="L305">                int v0 = ptGrad.getValue(pixIdx);</span>
<span class="nc" id="L306">                float v = out[pixIdx] * factor;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                if (v0 == 1) {</span>
<span class="nc" id="L308">                    v += 0.5f;</span>
                }
<span class="nc" id="L310">                out[pixIdx] = v;</span>
            }
        }
        
<span class="nc" id="L314">        return out;</span>
    }
    
    /**
     * create a greyscale adaptive threshold gradient with canny algorithm
     * and then a color contrast gradient with &quot;H&quot; of LCH, and sobel with
     * a threshold of 20 degrees for binarization, scale them to 
     * 127 and add them.
     * The color binary sobel pixels are scaled to 1/4th the maximum
     * of the greyscale gradient.
     * 
     * The results could be improved in various ways, but for now
     * is a quick way to look at completing greyscale intensity
     * gradient contours with the color contrast gradient.
     * 
     * @param img
     * @return 
     */
    public GreyscaleImage createGradientWithColorAndGreyscale(Image img) {

<span class="nc" id="L334">        int w = img.getWidth();</span>
<span class="nc" id="L335">        int h = img.getHeight();</span>
        
<span class="nc" id="L337">        GreyscaleImage gsImg = img.copyToGreyscale2();</span>
        
<span class="nc" id="L339">        CannyEdgeFilterAdaptive canny = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L340">        canny.overrideToUseAdaptiveThreshold();</span>
<span class="nc" id="L341">        canny.overrideToNotUseLineThinner();</span>
<span class="nc" id="L342">        canny.applyFilter(gsImg);</span>
<span class="nc" id="L343">        EdgeFilterProducts prod = canny.getFilterProducts();</span>

<span class="nc" id="L345">        float[] gsCanny = convertToFloat(prod.getGradientXY());</span>

<span class="nc" id="L347">        GreyscaleImage scaled = MiscMath.rescaleAndCreateImage(gsCanny, w, h);</span>

        //TODO: could consider using the sobel polar theta in canny edges
        //   as additional cues for strong edges in the 2-layer filter
        //   and then only use that result here.
        
<span class="nc" id="L353">        GreyscaleImage ptImg = createCIELUVTheta(img, 255);</span>
<span class="nc" id="L354">        GreyscaleImage ptGrad = </span>
            //createBinary2ndDerivForPolarTheta(ptImg, 20);
<span class="nc" id="L356">            createBinarySobelForPolarTheta(ptImg, 20);</span>
        
        /*
        ptGrad.multiply(255);
        applyAdaptiveMeanThresholding(ptGrad, 1);
        for (int j = 0; j &lt; ptGrad.getNPixels(); ++j) {
            ptGrad.setValue(j, 255 - ptGrad.getValue(j));
        }*/
         
<span class="nc" id="L365">        float[] ptSobel = convertToFloat(ptGrad);</span>

<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (int j = 0; j &lt; ptSobel.length; ++j) {</span>
<span class="nc" id="L368">            ptSobel[j] *= 63;</span>
<span class="nc" id="L369">            ptSobel[j] += scaled.getValue(j);</span>
        }

<span class="nc" id="L372">        scaled = MiscMath.rescaleAndCreateImage(ptSobel, w, h);</span>

<span class="nc" id="L374">        return scaled;</span>
    }

    /**
     * given a color image array with first dimension being color index
     * and the second dimension being the image pixel index,
     * apply the sobel kernel to each pixel and combine the results
     * as SSD.
     * @param colorInput with first dimension being color index
     * and the second dimension being the image pixel index
     */
    public float[] createSobelConvolution(float[][] colorInput, int imgWidth, 
        int imgHeight) {

<span class="nc" id="L388">        int nClrs = colorInput.length;</span>
<span class="nc" id="L389">        int nPix = colorInput[0].length;</span>
        
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (nPix != (imgWidth * imgHeight)) {</span>
<span class="nc" id="L392">            throw new IllegalArgumentException(&quot;image width X height must equal &quot;</span>
                + &quot; colorInput[0].length&quot;);
        }
        
<span class="nc" id="L396">        float[] out = new float[nPix];</span>
       
<span class="nc" id="L398">        Kernel1DHelper kernelHelper = new Kernel1DHelper();</span>
        
<span class="nc" id="L400">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>
        
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (int i = 0; i &lt; imgWidth; ++i) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            for (int j = 0; j &lt; imgHeight; ++j) {</span>
                
<span class="nc" id="L405">                double sqSum = 0;</span>
                
<span class="nc bnc" id="L407" title="All 2 branches missed.">                for (int c = 0; c &lt; nClrs; ++c) {</span>
                    
<span class="nc" id="L409">                    float convX = kernelHelper.convolvePointWithKernel(</span>
                        colorInput[c], i, j, kernel, true, imgWidth, imgHeight);
                    
<span class="nc" id="L412">                    float convY = kernelHelper.convolvePointWithKernel(</span>
                        colorInput[c], i, j, kernel, false, imgWidth, imgHeight);
                
<span class="nc" id="L415">                    sqSum += (convX * convX + convY * convY);</span>
                }

<span class="nc" id="L418">                int pixIdx = (j * imgWidth) + i;</span>
                
<span class="nc" id="L420">                out[pixIdx] = (float)Math.sqrt(sqSum/(double)nClrs);</span>
            }
        }
        
<span class="nc" id="L424">        return out;</span>
    }
    
    /**
     * given a greyscale image
     * apply the sobel kernel to each pixel and combine the results
     * as SSD.
     * @param greyscaleInput with index being the image pixel index
     */
    public float[] createSobelConvolution(float[] greyscaleInput, int imgWidth, 
        int imgHeight) {

<span class="nc" id="L436">        int nPix = greyscaleInput.length;</span>
        
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (nPix != (imgWidth * imgHeight)) {</span>
<span class="nc" id="L439">            throw new IllegalArgumentException(&quot;image width X height must equal &quot;</span>
                + &quot; colorInput[0].length&quot;);
        }
        
<span class="nc" id="L443">        float[] out = new float[nPix];</span>
       
<span class="nc" id="L445">        Kernel1DHelper kernelHelper = new Kernel1DHelper();</span>
        
<span class="nc" id="L447">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>
        double sqSum;
        int pixIdx;
        
<span class="nc bnc" id="L451" title="All 2 branches missed.">        for (int i = 0; i &lt; imgWidth; ++i) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            for (int j = 0; j &lt; imgHeight; ++j) {</span>
                
<span class="nc" id="L454">                sqSum = 0;</span>
                                    
<span class="nc" id="L456">                float convX = kernelHelper.convolvePointWithKernel(</span>
                    greyscaleInput, i, j, kernel, true, imgWidth, imgHeight);
                    
<span class="nc" id="L459">                float convY = kernelHelper.convolvePointWithKernel(</span>
                    greyscaleInput, i, j, kernel, false, imgWidth, imgHeight);
                
<span class="nc" id="L462">                sqSum += (convX * convX + convY * convY);</span>

<span class="nc" id="L464">                pixIdx = (j * imgWidth) + i;</span>
                
<span class="nc" id="L466">                out[pixIdx] = (float)Math.sqrt(sqSum);</span>
            }
        }
        
<span class="nc" id="L470">        return out;</span>
    }
    
    public void applySobelX(float[][] input) {

<span class="fc" id="L475">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>
        
<span class="fc" id="L477">        applyKernel1D(input, kernel, true);</span>
<span class="fc" id="L478">    }</span>
    
    public void applySobelY(float[][] input) {

<span class="fc" id="L482">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>
        
<span class="fc" id="L484">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L485">    }</span>
    
    public Map&lt;PairInt, Integer&gt; applySobelKernel(GreyscaleImage input, 
        Set&lt;PairInt&gt; points) {
       
<span class="nc" id="L490">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernel(</span>
            SIGMA.ZEROPOINTSEVENONE);

<span class="nc" id="L493">        return applyKernel(input, points, kernel);</span>
    }
        
    /**
     * calculate the sobel gradient of the color image using CIELAB DeltaE 2000
     * and return gX, gY, and gXY with array indices being pixel
     * indexes of the image.
     * @param img
     * @return float[][]{gX, gY, gXY}
     */
    public float[][] calculateGradientUsingDeltaE2000(ImageExt img) {
        
<span class="fc" id="L505">        int n = img.getNPixels();</span>
        
<span class="fc" id="L507">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="fc" id="L509">        int w = img.getWidth();</span>
<span class="fc" id="L510">        int h = img.getHeight();</span>
        
<span class="fc" id="L512">        float jnd = 2.3f;</span>
        
        // using 1D sobel kernel -1,0,1, calculating deltaE
        // between the pixels to either side of center pixel
        
        int x1, y1, x2, y2;
        
<span class="fc" id="L519">        float[] outX = new float[n];                    </span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
            
<span class="fc" id="L522">            x1 = i - 1;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (x1 &lt; 0) {</span>
<span class="fc" id="L524">                x1 = 0;</span>
            }
<span class="fc" id="L526">            x2 = i + 1;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            if (x2 &gt; (w - 1)) {</span>
<span class="fc" id="L528">                x2 = w - 1;</span>
            }
            
<span class="fc bfc" id="L531" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
                
<span class="fc" id="L533">                float[] lab1 = img.getCIELAB(x1, j);</span>
<span class="fc" id="L534">                float[] lab2 = img.getCIELAB(x2, j);</span>
                
<span class="fc" id="L536">                double deltaE = cieC.calcDeltaECIE2000(</span>
                    lab1, lab2);
                
<span class="fc" id="L539">                outX[img.getInternalIndex(i, j)] = (float)deltaE;</span>
            }                    
        }
        
<span class="fc" id="L543">        float[] outY = new float[n];                    </span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
           
<span class="fc bfc" id="L546" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
                
<span class="fc" id="L548">                y1 = j - 1;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                if (y1 &lt; 0) {</span>
<span class="fc" id="L550">                    y1 = 0;</span>
                }
<span class="fc" id="L552">                y2 = j + 1;</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                if (y2 &gt; (h - 1)) {</span>
<span class="fc" id="L554">                    y2 = h - 1;</span>
                }
                
<span class="fc" id="L557">                float[] lab1 = img.getCIELAB(i, y1);</span>
<span class="fc" id="L558">                float[] lab2 = img.getCIELAB(i, y2);</span>
                
<span class="fc" id="L560">                double deltaE = cieC.calcDeltaECIE2000(</span>
                    lab1, lab2);
                
<span class="fc" id="L563">                outY[img.getInternalIndex(i, j)] = (float)deltaE;</span>
            }                    
        }
        
        // make a combined array
<span class="fc" id="L568">        float[] outXY = new float[outX.length];</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        for (int i = 0; i &lt; outX.length; ++i) {</span>
<span class="fc" id="L570">            double gXY = Math.sqrt(outX[i] * outX[i] + outY[i] * outY[i]);</span>
<span class="fc" id="L571">            outXY[i] = (float)gXY;</span>
        }
      
<span class="fc" id="L574">        return new float[][]{outX, outY, outXY};</span>
    }
    
    /**
     * apply a sobel kernel (gaussian first derivative, binomial approx 
     * for sigma=sqrt(2)/2) to the points in the region bounded by
     * (xLL, yLL) to (xUR, yUR), inclusive and return the results as a map.
     * @param pointValues values for points in the bounding region
     * @param xLL lower left corner x coordinate of bounding box.  xLL is less than xUR.
     * @param yLL lower left corner y coordinate of bounding box.  yLL is less than yUR.
     * @param xUR upper right corner x coordinate of bounding box.  xUR is larger than xLL.
     * @param yUR upper right corner y coordinate of bounding box.  yUR is larger than yLL.
     * @param outputGradientValues
     */
    public void applySobelKernel(Map&lt;PairInt, Integer&gt; pointValues,
        int xLL, int yLL, int xUR, int yUR,
        Map&lt;PairInt, Integer&gt; outputGradientValues) {
       
<span class="nc" id="L592">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernel(</span>
            SIGMA.ZEROPOINTSEVENONE);

<span class="nc" id="L595">        applyKernel(pointValues, xLL, yLL, xUR, yUR, kernel, </span>
            outputGradientValues);
<span class="nc" id="L597">    }</span>

    public void applyLaplacianKernel(GreyscaleImage input) {

<span class="nc" id="L601">        IKernel kernel = new Laplacian();</span>
<span class="nc" id="L602">        Kernel kernelXY = kernel.getKernel();</span>

<span class="nc" id="L604">        float norm = kernel.getNormalizationFactor();</span>

<span class="nc" id="L606">        applyKernel(input, kernelXY, norm);</span>
<span class="nc" id="L607">    }</span>

    /**
     * apply the kernels to the input.  Note that the current image format
     * only accepts value between 0 and 255, inclusive.
     * @param input
     * @param kernelX
     * @param kernelY
     * @param normFactorX
     * @param normFactorY
     */
    protected void applyKernels(Image input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L627">        Image imgX = input.copyImage();</span>

<span class="nc" id="L629">        Image imgY = input.copyImage();</span>

<span class="nc" id="L631">        applyKernel(imgX, kernelX, normFactorX);</span>

<span class="nc" id="L633">        applyKernel(imgY, kernelY, normFactorY);</span>

<span class="nc" id="L635">        Image img2 = combineConvolvedImages(imgX, imgY);</span>

<span class="nc" id="L637">        input.resetTo(img2);</span>
<span class="nc" id="L638">    }</span>

    protected void applyKernels(GreyscaleImage input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

<span class="nc" id="L643">        GreyscaleImage[] gXgY = convolveWithKernels(input, kernelX, kernelY, normFactorX,</span>
            normFactorY);

<span class="nc" id="L646">        GreyscaleImage img2 = combineConvolvedImages(gXgY[0], gXgY[1]);</span>

<span class="nc" id="L648">        input.resetTo(img2);</span>
<span class="nc" id="L649">    }</span>
    
    protected GreyscaleImage[] convolveWithKernels(GreyscaleImage input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L660">        GreyscaleImage imgX = input.copyImage();</span>

<span class="nc" id="L662">        GreyscaleImage imgY = input.copyImage();</span>

<span class="nc" id="L664">        applyKernel(imgX, kernelX, normFactorX);</span>

<span class="nc" id="L666">        applyKernel(imgY, kernelY, normFactorY);</span>

<span class="nc" id="L668">        return new GreyscaleImage[]{imgX, imgY};</span>
    }

    protected Map&lt;PairInt, Integer&gt; applyKernel(GreyscaleImage input, 
        Set&lt;PairInt&gt; points, float[] kernel) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L680">        Map&lt;PairInt, Integer&gt; convX = applyKernel(input, points, kernel, true);</span>

<span class="nc" id="L682">        Map&lt;PairInt, Integer&gt; convY = applyKernel(input, points, kernel, false);</span>
        
<span class="nc" id="L684">        Map&lt;PairInt, Integer&gt; output = new HashMap&lt;PairInt, Integer&gt;();</span>
        
<span class="nc bnc" id="L686" title="All 2 branches missed.">        for (PairInt p : points) {</span>
            
<span class="nc" id="L688">            int vX = convX.get(p).intValue();</span>
            
<span class="nc" id="L690">            int vY = convY.get(p).intValue();</span>
            
<span class="nc" id="L692">            int v = (int)Math.round(Math.sqrt(vX * vX + vY * vY));</span>
            
<span class="nc" id="L694">            output.put(p, Integer.valueOf(v));</span>
<span class="nc" id="L695">        }</span>
        
<span class="nc" id="L697">        return output;</span>
    }

    protected void applyKernel(Map&lt;PairInt, Integer&gt; pointValues, 
        int xLL, int yLL, int xUR, int yUR, float[] kernel,
        Map&lt;PairInt, Integer&gt; outputGradientValues) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L710">        Map&lt;PairInt, Integer&gt; convX = applyKernel(pointValues, xLL, yLL, xUR, yUR,</span>
            kernel, true);

<span class="nc" id="L713">        Map&lt;PairInt, Integer&gt; convY = applyKernel(pointValues, xLL, yLL, xUR, yUR,</span>
            kernel, false);
                
<span class="nc bnc" id="L716" title="All 2 branches missed.">        for (int xp = xLL; xp &lt;= xUR; ++xp) {</span>
            
<span class="nc bnc" id="L718" title="All 2 branches missed.">            for (int yp = yLL; yp &lt;= yUR; ++yp) {</span>
                
<span class="nc" id="L720">                PairInt p = new PairInt(xp, yp);</span>
                
<span class="nc bnc" id="L722" title="All 4 branches missed.">                if (!convX.containsKey(p) || !convY.containsKey(p)) {</span>
<span class="nc" id="L723">                    continue;</span>
                }
                
<span class="nc" id="L726">                int vX = convX.get(p).intValue();</span>

<span class="nc" id="L728">                int vY = convY.get(p).intValue();</span>
                
<span class="nc" id="L730">                int v = (int) Math.round(Math.sqrt(vX * vX + vY * vY));</span>

<span class="nc bnc" id="L732" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L733">                    outputGradientValues.put(p, Integer.valueOf(v));</span>
                }
            }
        }        
<span class="nc" id="L737">    }</span>

    public Image combineConvolvedImages(Image imageX, Image imageY) {

<span class="fc" id="L741">        Image img2 = new Image(imageX.getWidth(), imageX.getHeight());</span>

<span class="fc bfc" id="L743" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L746">                int rX = imageX.getR(i, j);</span>
<span class="fc" id="L747">                int gX = imageX.getG(i, j);</span>
<span class="fc" id="L748">                int bX = imageX.getB(i, j);</span>

<span class="fc" id="L750">                int rY = imageY.getR(i, j);</span>
<span class="fc" id="L751">                int gY = imageY.getG(i, j);</span>
<span class="fc" id="L752">                int bY = imageY.getB(i, j);</span>

<span class="fc" id="L754">                double r = Math.sqrt(rX*rX + rY*rY);</span>
<span class="fc" id="L755">                double g = Math.sqrt(gX*gX + gY*gY);</span>
<span class="fc" id="L756">                double b = Math.sqrt(bX*bX + bY*bY);</span>

<span class="pc bpc" id="L758" title="1 of 2 branches missed.">                r = (r &gt; 255) ? 255 : r;</span>
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">                g = (g &gt; 255) ? 255 : g;</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">                b = (b &gt; 255) ? 255 : b;</span>

                //int rgb = (int)(((rSum &amp; 0x0ff) &lt;&lt; 16)
                //    | ((gSum &amp; 0x0ff) &lt;&lt; 8) | (bSum &amp; 0x0ff));

<span class="fc" id="L765">                img2.setRGB(i, j, (int)r, (int)g, (int)b);</span>
            }
        }

<span class="fc" id="L769">        return img2;</span>
    }

    /**
     * @param imageX
     * @param imageY
     * @return
     */
    public GreyscaleImage combineConvolvedImages(final GreyscaleImage imageX,
        final GreyscaleImage imageY) {

<span class="fc" id="L780">        GreyscaleImage img2 = imageX.createWithDimensions();</span>

<span class="fc bfc" id="L782" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L785">                int gX = imageX.getValue(i, j);</span>

<span class="fc" id="L787">                int gY = imageY.getValue(i, j);</span>

<span class="fc" id="L789">                double g = Math.sqrt(gX*gX + gY*gY);</span>

<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                if (g &gt; 255) {</span>
<span class="nc" id="L792">                    g = 255;</span>
                }
                
<span class="fc" id="L795">                img2.setValue(i, j, (int)g);</span>
            }
        }

<span class="fc" id="L799">        return img2;</span>
    }
    
    public int[][] applyKernel(int[][] a, int[][] b) {
        
<span class="fc" id="L804">        final int na0 = a.length;</span>
<span class="fc" id="L805">        final int na1 = a[0].length;</span>
<span class="fc" id="L806">        final int nb0 = b.length;</span>
<span class="fc" id="L807">        final int nb1 = b[0].length;</span>
        
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        if (nb1 &gt; nb0) {</span>
<span class="nc" id="L810">            throw new IllegalArgumentException(&quot;expecting first argument to be &quot; </span>
            + &quot; data and the 2nd to be the kernel to convolve the data with&quot;);
        }

<span class="fc" id="L814">        int nbmid0 = (nb0 - 1)/2;</span>
<span class="fc" id="L815">        int nbmid1 = (nb1 - 1)/2;</span>
        
<span class="fc" id="L817">        int[][] output = new int[na0][na1];</span>
        
<span class="fc bfc" id="L819" title="All 2 branches covered.">        for (int i = 0; i &lt; na0; i++) {</span>

<span class="fc" id="L821">            output[i] = new int[na1];</span>

<span class="fc bfc" id="L823" title="All 2 branches covered.">            for (int j = 0; j &lt; na1; j++) {</span>

<span class="fc" id="L825">                int sum = 0;</span>

<span class="fc bfc" id="L827" title="All 2 branches covered.">                for (int col = 0; col &lt; nb0; col++) {</span>

<span class="fc" id="L829">                    int x = col - nbmid0;</span>

<span class="fc" id="L831">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="fc bfc" id="L834" title="All 2 branches covered.">                    if (imgX &lt; 0) {</span>
<span class="fc" id="L835">                        imgX = -1 * imgX - 1;</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                    } else if (imgX &gt;= na0) {</span>
<span class="fc" id="L837">                        int diff = imgX - na0;</span>
<span class="fc" id="L838">                        imgX = na0 - diff - 1;</span>
                    }

<span class="fc bfc" id="L841" title="All 2 branches covered.">                    for (int row = 0; row &lt; nb1; row++) {</span>

<span class="fc" id="L843">                        int y = row - nbmid1;</span>

<span class="fc" id="L845">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="fc bfc" id="L848" title="All 2 branches covered.">                        if (imgY &lt; 0) {</span>
<span class="fc" id="L849">                            imgY = -1 * imgY - 1;</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">                        } else if (imgY &gt;= na1) {</span>
<span class="fc" id="L851">                            int diff = imgY - na1;</span>
<span class="fc" id="L852">                            imgY = na1 - diff - 1;</span>
                        }

<span class="fc" id="L855">                        int k = b[col][row];</span>

<span class="fc" id="L857">                        sum += k * a[imgX][imgY];</span>
                    }
                }
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">if (sum &gt; 511) {</span>
<span class="nc" id="L861">    int z = 1;//  59, 125</span>
}
                
<span class="fc" id="L864">                output[i][j] = sum;</span>
            }
        }

<span class="fc" id="L868">        return output;</span>
    }

    /**
     * apply kernel to input. NOTE, that because the image is composed of
     * vectors that should have values between 0 and 255, inclusive, if the
     * kernel application results in a value outside of that range, the value
     * is reset to 0 or 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(Image input, Kernel kernel, float normFactor) {

<span class="nc" id="L882">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="nc" id="L884">        Image output = new Image(input.getWidth(), input.getHeight());</span>

<span class="nc bnc" id="L886" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="nc" id="L889">                long rValue = 0;</span>
<span class="nc" id="L890">                long gValue = 0;</span>
<span class="nc" id="L891">                long bValue = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L895" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="nc" id="L897">                    int x = col - h;</span>

<span class="nc" id="L899">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L902" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L903">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="nc" id="L905">                        int diff = imgX - input.getWidth();</span>
<span class="nc" id="L906">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="nc bnc" id="L909" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="nc" id="L911">                        int y = row - h;</span>

<span class="nc" id="L913">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L916" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L917">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="nc" id="L919">                            int diff = imgY - input.getHeight();</span>
<span class="nc" id="L920">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="nc" id="L923">                        int rPixel = input.getR(imgX, imgY);</span>
<span class="nc" id="L924">                        int gPixel = input.getG(imgX, imgY);</span>
<span class="nc" id="L925">                        int bPixel = input.getB(imgX, imgY);</span>

<span class="nc" id="L927">                        int k = kernel.getValue(col, row);</span>

<span class="nc" id="L929">                        rValue += k * rPixel;</span>
<span class="nc" id="L930">                        gValue += k * gPixel;</span>
<span class="nc" id="L931">                        bValue += k * bPixel;</span>
                    }
                }

<span class="nc" id="L935">                rValue *= normFactor;</span>
<span class="nc" id="L936">                gValue *= normFactor;</span>
<span class="nc" id="L937">                bValue *= normFactor;</span>

                /*
                if ((rValue &gt; 255) || (rValue &lt; 0)) {
                    throw new IllegalStateException(&quot;rValue is &quot; + rValue);
                }
                if ((gValue &gt; 255) || (gValue &lt; 0)) {
                    throw new IllegalStateException(&quot;gValue is &quot; + gValue);
                }
                if ((bValue &gt; 255) || (bValue &lt; 0)) {
                    throw new IllegalStateException(&quot;bValue is &quot; + bValue);
                }*/

<span class="nc bnc" id="L950" title="All 2 branches missed.">                if (rValue &lt; 0) {</span>
<span class="nc" id="L951">                    rValue = 0;</span>
                }
<span class="nc bnc" id="L953" title="All 2 branches missed.">                if (rValue &gt; 255) {</span>
<span class="nc" id="L954">                    rValue = 255;</span>
                }
<span class="nc bnc" id="L956" title="All 2 branches missed.">                if (gValue &lt; 0) {</span>
<span class="nc" id="L957">                    gValue = 0;</span>
                }
<span class="nc bnc" id="L959" title="All 2 branches missed.">                if (gValue &gt; 255) {</span>
<span class="nc" id="L960">                    gValue = 255;</span>
                }
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (bValue &lt; 0) {</span>
<span class="nc" id="L963">                    bValue = 0;</span>
                }
<span class="nc bnc" id="L965" title="All 2 branches missed.">                if (bValue &gt; 255) {</span>
<span class="nc" id="L966">                    bValue = 255;</span>
                }

<span class="nc" id="L969">                output.setRGB(i, j, (int)rValue, (int)gValue, (int)bValue);</span>
            }
        }

<span class="nc" id="L973">        input.resetTo(output);</span>
<span class="nc" id="L974">    }</span>
    
    /**
     * apply kernel to input. NOTE, that because the image is composed of
     * vectors that should have values between 0 and 255, inclusive, if the
     * kernel application results in a value outside of that range, the value
     * is reset to 0 or 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(float[][] input, Kernel kernel, float normFactor) {

<span class="nc" id="L987">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="nc" id="L989">        int width = input.length;</span>
<span class="nc" id="L990">        int height = input[0].length;</span>
        
<span class="nc" id="L992">        float[][] output = new float[width][];</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="nc" id="L994">            output[i] = new float[height];</span>
        }
        
<span class="nc bnc" id="L997" title="All 2 branches missed.">        for (int i = 0; i &lt; width; i++) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">            for (int j = 0; j &lt; height; j++) {</span>

<span class="nc" id="L1000">                double value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L1004" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="nc" id="L1006">                    int x = col - h;</span>

<span class="nc" id="L1008">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L1012">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                    } else if (imgX &gt;= width) {</span>
<span class="nc" id="L1014">                        int diff = imgX - width;</span>
<span class="nc" id="L1015">                        imgX = width - diff - 1;</span>
                    }

<span class="nc bnc" id="L1018" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="nc" id="L1020">                        int y = row - h;</span>

<span class="nc" id="L1022">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L1026">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                        } else if (imgY &gt;= height) {</span>
<span class="nc" id="L1028">                            int diff = imgY - height;</span>
<span class="nc" id="L1029">                            imgY = height - diff - 1;</span>
                        }

<span class="nc" id="L1032">                        float v = input[imgX][imgY];</span>

<span class="nc" id="L1034">                        int k = kernel.getValue(col, row);</span>

<span class="nc" id="L1036">                        value += k * v;</span>
                    }
                }

<span class="nc" id="L1040">                value *= normFactor;</span>

<span class="nc" id="L1042">                output[i][j] = (float)value;</span>
            }
        }
        
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="nc" id="L1047">            System.arraycopy(output[i], 0, input[i], 0, height);</span>
        }
<span class="nc" id="L1049">    }</span>
    
    /**
     * apply kernel to input for pixels in points.
     * @param input
     * @param points
     * @param kernel
     * @param calcForX
     * @return 
     */
    protected Map&lt;PairInt, Integer&gt; applyKernel(GreyscaleImage input, 
        Set&lt;PairInt&gt; points, float[] kernel, boolean calcForX) {

<span class="nc" id="L1062">        int h = (kernel.length - 1) &gt;&gt; 1;</span>

<span class="nc" id="L1064">        Map&lt;PairInt, Integer&gt; output = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc bnc" id="L1066" title="All 2 branches missed.">        for (PairInt p : points) {</span>
            
<span class="nc" id="L1068">            int i = p.getX();</span>
<span class="nc" id="L1069">            int j = p.getY();</span>

<span class="nc" id="L1071">            float sum = 0;</span>

            // apply the kernel to pixels centered in (i, j)
<span class="nc bnc" id="L1074" title="All 2 branches missed.">            for (int g = 0; g &lt; kernel.length; g++) {</span>
<span class="nc" id="L1075">                float gg = kernel[g];</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                if (gg == 0) {</span>
<span class="nc" id="L1077">                    continue;</span>
                }
                
                int x2, y2;
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                if (calcForX) {</span>
<span class="nc" id="L1082">                    int delta = g - h;</span>
<span class="nc" id="L1083">                    x2 = i + delta;</span>
<span class="nc" id="L1084">                    y2 = j;</span>
                    // edge corrections.  use replication
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                    if (x2 &lt; 0) {</span>
<span class="nc" id="L1087">                        x2 = -1 * x2 - 1;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                    } else if (x2 &gt;= input.getWidth()) {</span>
<span class="nc" id="L1089">                        int diff = x2 - input.getWidth();</span>
<span class="nc" id="L1090">                        x2 = input.getWidth() - diff - 1;</span>
                    }
<span class="nc" id="L1092">                } else {</span>
<span class="nc" id="L1093">                    int delta = g - h;</span>
<span class="nc" id="L1094">                    y2 = j + delta;</span>
<span class="nc" id="L1095">                    x2 = i;</span>
                    // edge corrections.  use replication
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                    if (y2 &lt; 0) {</span>
<span class="nc" id="L1098">                        y2 = -1 * y2 - 1;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                    } else if (y2 &gt;= input.getHeight()) {</span>
<span class="nc" id="L1100">                        int diff = y2 - input.getHeight();</span>
<span class="nc" id="L1101">                        y2 = input.getHeight() - diff - 1;</span>
                    }
                }
                
<span class="nc" id="L1105">                int v = input.getValue(x2, y2);</span>

<span class="nc" id="L1107">                sum += gg * v;</span>
            }
            
<span class="nc" id="L1110">            output.put(p, Integer.valueOf((int) sum));</span>
<span class="nc" id="L1111">        }</span>

<span class="nc" id="L1113">        return output;</span>
    }

    protected Map&lt;PairInt, Integer&gt; applyKernel(
        Map&lt;PairInt, Integer&gt; pointValues, int xLL, int yLL, int xUR, int yUR,
        float[] kernel, boolean calcForX) {

<span class="nc" id="L1120">        int h = (kernel.length - 1) &gt;&gt; 1;</span>

<span class="nc" id="L1122">        Map&lt;PairInt, Integer&gt; output = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">        for (int xp = xLL; xp &lt;= xUR; ++xp) {</span>
            
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            for (int yp = yLL; yp &lt;= yUR; ++yp) {</span>
                
<span class="nc" id="L1128">                PairInt p = new PairInt(xp, yp);</span>
                
<span class="nc" id="L1130">                float sum = 0;</span>

                // apply the kernel to pixels centered in (i, j)
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                for (int g = 0; g &lt; kernel.length; g++) {</span>
<span class="nc" id="L1134">                    float gg = kernel[g];</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">                    if (gg == 0) {</span>
<span class="nc" id="L1136">                        continue;</span>
                    }

                    int x2, y2;
<span class="nc bnc" id="L1140" title="All 2 branches missed.">                    if (calcForX) {</span>
<span class="nc" id="L1141">                        int delta = g - h;</span>
<span class="nc" id="L1142">                        x2 = xp + delta;</span>
<span class="nc" id="L1143">                        y2 = yp;</span>
                        // edge corrections.  use replication
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                        if (x2 &lt; 0) {</span>
<span class="nc" id="L1146">                            x2 = -1 * x2 - 1;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                        } else if (x2 &gt; xUR) {</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                            if (!pointValues.containsKey(new PairInt(x2, y2))) {</span>
<span class="nc" id="L1149">                                x2 = xUR;</span>
                            }
                        }
<span class="nc" id="L1152">                    } else {</span>
<span class="nc" id="L1153">                        int delta = g - h;</span>
<span class="nc" id="L1154">                        y2 = yp + delta;</span>
<span class="nc" id="L1155">                        x2 = xp;</span>
                        // edge corrections.  use replication
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                        if (y2 &lt; 0) {</span>
<span class="nc" id="L1158">                            y2 = -1 * y2 - 1;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                        } else if (y2 &gt; yUR) {</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                            if (!pointValues.containsKey(new PairInt(x2, y2))) {</span>
<span class="nc" id="L1161">                                y2 = yUR;</span>
                            }
                        }
                    }
                    
                    // TODO: revisit this for normalization
<span class="nc" id="L1167">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                    if (!pointValues.containsKey(p2)) {</span>
<span class="nc" id="L1169">                        continue;</span>
                    }
                    
<span class="nc" id="L1172">                    int v = pointValues.get(p2).intValue();</span>

<span class="nc" id="L1174">                    sum += gg * v;</span>
                    
                } // end sum over kernl for a pixel
                
<span class="nc" id="L1178">                int v = Math.round(sum);</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L1180">                    output.put(p, Integer.valueOf(v));</span>
                }
            }
        }

<span class="nc" id="L1185">        return output;</span>
    }

    /**
     * apply kernel to input. NOTE, that because the image is composed of vectors
     * that should have values between 0 and 255, inclusive, if the kernel application
     * results in a value outside of that range, the value is reset to 0 or
     * 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(GreyscaleImage input, Kernel kernel, float normFactor) {

<span class="nc" id="L1199">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="nc" id="L1201">        GreyscaleImage output = input.createWithDimensions();</span>

        //TODO: consider changing normalization to be similar to Kernel1DHelper

<span class="nc bnc" id="L1205" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="nc" id="L1208">                double value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L1212" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="nc" id="L1214">                    int x = col - h;</span>

<span class="nc" id="L1216">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L1220">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="nc" id="L1222">                        int diff = imgX - input.getWidth();</span>
<span class="nc" id="L1223">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="nc bnc" id="L1226" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="nc" id="L1228">                        int y = row - h;</span>

<span class="nc" id="L1230">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L1234">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="nc" id="L1236">                            int diff = imgY - input.getHeight();</span>
<span class="nc" id="L1237">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="nc" id="L1240">                        int pixel = input.getValue(imgX, imgY);</span>
<span class="nc" id="L1241">                        int k = kernel.getValue(col, row);</span>

<span class="nc" id="L1243">                        value += k * pixel;</span>
                    }
                }
<span class="nc" id="L1246">                value *= normFactor;</span>
                                
<span class="nc" id="L1248">                int v = (int)value;</span>

<span class="nc bnc" id="L1250" title="All 2 branches missed.">                if (v &lt; 0) {</span>
<span class="nc" id="L1251">                    v = 0;</span>
                }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                if (v &gt; 255) {</span>
<span class="nc" id="L1254">                    v = 255;</span>
                }
<span class="nc" id="L1256">                output.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L1260">        input.resetTo(output);</span>
<span class="nc" id="L1261">    }</span>

    /**
     * calculate theta from the gradient x and y images.
     * &lt;pre&gt;
     * The results are given as quadrants of values from 0 to 90.
     * 
     *     -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45

           when X is 0: if Y &gt; 0, theta is 90
           when Y is 0: if X &gt;= 0, theta is 0
     * &lt;/pre&gt;
     * @param convolvedX
     * @param convolvedY
     * @return 
     */
    public GreyscaleImage computeTheta(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="fc" id="L1284">        GreyscaleImage output = convolvedX.createSignedWithDimensions();</span>

<span class="fc bfc" id="L1286" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L1287" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L1289">                double gX = convolvedX.getValue(i, j);</span>

<span class="fc" id="L1291">                double gY = convolvedY.getValue(i, j);</span>

<span class="fc" id="L1293">                int thetaG = calculateTheta(gX, gY);</span>

<span class="fc" id="L1295">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="fc" id="L1300">        return output;</span>
    }

    /**
     * calculate theta from the gradient x and y images and transform to
     * range 0 to 180.
     * &lt;pre&gt;
     * 
     *           90    45          y/x
                -  |  +
          180 -----|----- 0
                +  |  -
                         
     * &lt;/pre&gt;
     * 
     * @param convolvedX
     * @param convolvedY
     * @return 
     */
    public GreyscaleImage computeTheta180(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="fc" id="L1322">        GreyscaleImage output = convolvedX.createWithDimensions();</span>

<span class="fc bfc" id="L1324" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L1327">                double gX = convolvedX.getValue(i, j);</span>

<span class="fc" id="L1329">                double gY = convolvedY.getValue(i, j);</span>
                
<span class="fc bfc" id="L1331" title="All 2 branches covered.">                if (gY &lt; 0) {</span>
<span class="fc" id="L1332">                    gX *= -1;</span>
<span class="fc" id="L1333">                    gY *= -1;</span>
                }

<span class="fc" id="L1336">                double radians = Math.atan2(gY, gX);</span>
             
<span class="fc" id="L1338">                int theta = (int)(radians * 180./Math.PI);</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">                if (theta == 180) {</span>
<span class="fc" id="L1340">                    theta = 0;</span>
                }

<span class="fc" id="L1343">                output.setValue(i, j, theta);</span>

            }
        }

<span class="fc" id="L1348">        return output;</span>
    }

    /**
     * calculate theta, transforming values from -pi to pi to range 0 to 360.
     * Note that the value of theta for pixel with gradientX or gradientY
     * smaller than the resolution of the data (FWHM of PSF) is actually
     * orthogonal to it's real value, so those need to be interpreted
     * differently.
     * To calculate the minimum resolvable angle, combine the sigmas in
     * quadrature for all stages used to create the gradients.
     * For example, a blur using sigma=1 followed by a gradient using
     * sigma sqrt(1)/2 results in a sigma of
     * sqrt( (1*1) + (sqrt(1)/2)*(sqrt(1)/2) ).  The FWHM of the combined
     * operations is then approx 2.35 * sigma, so that's 3 pixels.
     * The minimum resolvable angle is then math.atan2(1, 3)*180./Math.PI is
     * 18.4 degrees for this example, so any theta within 19 degrees of
     * horizontal or vertical where there is signal in the image, has to be
     * corrected by 90 degrees.
     * Such correction isn't made here to allow the method to be used without
     * such knowledge.
     * &lt;pre&gt;
     *           Y
     *          90
     *     135   |    +45
     *           |
     *   180------------ 0   X
     *           |
     *    225    |   315
     *          270
     * &lt;/pre&gt;
     * @param gradientX
     * @param gradientY
     * @return
     */
    public GreyscaleImage computeTheta360_0(final GreyscaleImage gradientX,
        final GreyscaleImage gradientY) {

<span class="nc" id="L1386">        GreyscaleImage output = gradientX.createFullRangeIntWithDimensions();</span>

<span class="nc bnc" id="L1388" title="All 2 branches missed.">        for (int i = 0; i &lt; gradientX.getWidth(); i++) {</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">            for (int j = 0; j &lt; gradientX.getHeight(); j++) {</span>

<span class="nc" id="L1391">                double gX = gradientX.getValue(i, j);</span>

<span class="nc" id="L1393">                double gY = gradientY.getValue(i, j);</span>

                // -pi to pi radians
<span class="nc" id="L1396">                double theta = Math.atan2(gY, gX);</span>

                // transform to 0 to 2*pi radians
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                if (theta &lt; 0) {</span>
<span class="nc" id="L1400">                    theta += 2. * Math.PI;</span>
                }

<span class="nc" id="L1403">                int d = (int)Math.round(theta * 180./Math.PI);</span>

<span class="nc" id="L1405">                output.setValue(i, j, d);</span>
            }
        }

<span class="nc" id="L1409">        return output;</span>
    }

    /**
     * compute theta as a polar angle that increases in a clockwise manner
     * and has a range from 0 to 359, inclusive.
     *
     * @param convolvedX
     * @param convolvedY
     * @return
     */
    public GreyscaleImage computeTheta360(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="nc" id="L1423">        GreyscaleImage output = convolvedX.createFullRangeIntWithDimensions();</span>

<span class="nc bnc" id="L1425" title="All 2 branches missed.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="nc" id="L1428">                double gX = convolvedX.getValue(i, j);</span>

<span class="nc" id="L1430">                double gY = convolvedY.getValue(i, j);</span>

<span class="nc" id="L1432">                double thetaR = (2. * Math.PI) - AngleUtil.polarAngleCCW(gX, gY);</span>

<span class="nc" id="L1434">                int thetaG = (int)Math.round(thetaR * 180./Math.PI);</span>

<span class="nc bnc" id="L1436" title="All 2 branches missed.">                if (thetaG &gt; 359) {</span>
<span class="nc" id="L1437">                    thetaG = thetaG - 360;</span>
                }

<span class="nc" id="L1440">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="nc" id="L1445">        return output;</span>
    }

    public GreyscaleImage subtractImages(final GreyscaleImage image,
        final GreyscaleImage subtrImage) {

<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">        if (image.getWidth() != subtrImage.getWidth()) {</span>
<span class="nc" id="L1452">            throw new IllegalArgumentException(&quot;image widths must be the same&quot;);</span>
        }
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">        if (image.getHeight() != subtrImage.getHeight()) {</span>
<span class="nc" id="L1455">            throw new IllegalArgumentException(&quot;image heights must be the same&quot;);</span>
        }

<span class="fc" id="L1458">        GreyscaleImage output = image.createFullRangeIntWithDimensions();</span>

<span class="fc bfc" id="L1460" title="All 2 branches covered.">        for (int i = 0; i &lt; image.getWidth(); i++) {</span>
<span class="fc bfc" id="L1461" title="All 2 branches covered.">            for (int j = 0; j &lt; image.getHeight(); j++) {</span>

<span class="fc" id="L1463">                int diff = image.getValue(i, j) - subtrImage.getValue(i, j);</span>

<span class="fc" id="L1465">                output.setValue(i, j, diff);</span>
            }
        }

<span class="fc" id="L1469">        return output;</span>
    }

    protected int calculateTheta(double gradientX, double gradientY) {

        /*  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45

           when X is 0: if Y &gt; 0, theta is 90
           when Y is 0: if X &gt;= 0, theta is 0
        */

<span class="fc bfc" id="L1484" title="All 4 branches covered.">        if (gradientX == 0 &amp;&amp; (gradientY != 0)) {</span>
<span class="fc" id="L1485">            return 90;</span>
        }

<span class="fc bfc" id="L1488" title="All 2 branches covered.">        if (gradientY == 0) {</span>
<span class="fc" id="L1489">            return 0;</span>
        }

<span class="fc" id="L1492">        double theta = Math.atan(gradientY/gradientX)*180./Math.PI;</span>

<span class="fc" id="L1494">        int angle = (int)theta;</span>

        // +x, +y -&gt; +
        // -x, +y -&gt; -
        // -x, -y -&gt; +
        // +x, -y -&gt; -

<span class="fc bfc" id="L1501" title="All 4 branches covered.">        if (!(gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L1504">                angle *= -1;</span>
            }
<span class="fc bfc" id="L1506" title="All 4 branches covered.">        } else if ((gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1507" title="1 of 2 branches missed.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="nc" id="L1509">                angle *= -1;</span>
            }
<span class="pc bpc" id="L1511" title="1 of 4 branches missed.">        } else if ((gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L1514">                angle *= -1;</span>
            }
<span class="pc bpc" id="L1516" title="2 of 4 branches missed.">        } else if (!(gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1517" title="1 of 2 branches missed.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="nc" id="L1519">                angle *= -1;</span>
            }
        }

<span class="fc" id="L1523">        return angle;</span>
    }

    protected void blur(GreyscaleImage input, float[] kernel) {

<span class="fc" id="L1528">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1530">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L1531">    }</span>
    
    protected void applyKernelTwo1Ds(int[][] input, float[] kernel) {

<span class="fc" id="L1535">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1537">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L1538">    }</span>
    
    public void applyKernelTwo1Ds(float[][] input, float[] kernel) {

<span class="fc" id="L1542">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1544">        applyKernel1D(input, kernel, false);</span>
        
<span class="fc" id="L1546">    }</span>

    protected void blur(GreyscaleImage input, float[] kernel, int minValue, int maxValue) {

<span class="nc" id="L1550">        applyKernel1D(input, kernel, true, minValue, maxValue);</span>

<span class="nc" id="L1552">        applyKernel1D(input, kernel, false, minValue, maxValue);</span>
<span class="nc" id="L1553">    }</span>

    public void blur(GreyscaleImage input, float sigma) {

<span class="nc" id="L1557">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="nc" id="L1559">        blur(input, kernel);</span>
<span class="nc" id="L1560">    }</span>
    
    /**
     * in order to make a smoother &quot;blur&quot; operation, the full gaussian
     * profile down to 0.001 * HWZI is created and convolved with image input
     * at a smaller sigma, recursively, until the resulting sigma equals 
     * the sigma given to the method.
     * gaussian profiles add in quadrature, 
     * sigma_tot^2 = sigma_1^2 + sigma_2^2.
     * 
     * @param input
     * @param sigma should be a quadrature factor of sqrt(2)/2, that is 
     *     sqrt(2)/2, 1, sqrt(1.5), sqrt(2.0), sqrt(2.5), sqrt(3.0), 
     *     sqrt(3.5), sqrt(4.0), sqrt(4.5)...
     *     in other words, the square of sigma should be 0.5 or a positive non zero 
     *     integer or a positive non zero integer plus 0.5.
     */
    public void recursiveBlur(float[][] input, SIGMA sigma) {
        
<span class="fc" id="L1579">        float sigmaF = SIGMA.getValue(sigma);</span>
<span class="fc" id="L1580">        float sigmaFSQ = sigmaF * sigmaF;</span>
<span class="fc" id="L1581">        int sigmaISQ = (int)Math.floor(sigmaF);</span>
<span class="fc" id="L1582">        float remainder = sigmaFSQ - sigmaISQ;</span>
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">        if (!(</span>
<span class="pc bpc" id="L1584" title="5 of 6 branches missed.">            ((sigmaISQ &gt;= 0) &amp;&amp; (Math.abs(remainder - 0.5f) &lt; 0.01)) </span>
            || ((sigmaISQ &gt; 0) &amp;&amp; (remainder &lt; 0.01))
            )) {
<span class="nc" id="L1587">            throw new IllegalArgumentException(&quot;sigma has to be a value that&quot;</span>
                + &quot;is the result of recursive combinations of sqrt(2)/2&quot;);
        }
        
<span class="fc" id="L1591">        float sigma0Sq = (float)Math.sqrt(2.)/2.f;</span>
<span class="fc" id="L1592">        sigma0Sq *= sigma0Sq;</span>
        
<span class="fc" id="L1594">        float currentSigmaSq = sigma0Sq;</span>
        
<span class="fc" id="L1596">        float finalSigmaSq = SIGMA.getValue(sigma);</span>
<span class="fc" id="L1597">        finalSigmaSq *= finalSigmaSq;</span>
        
        //float[] kernel = Gaussian1D.getKernel((float)Math.sqrt(2.)/2.f, 0);
        //for sigma=sqrt(2)/2 kernel
        //   =[6.962646E-5, 0.010333488, 0.20755373, 0.5641896, 
        //     0.20755373, 0.010333488, 6.962646E-5]
        // which is essentially 1, 20, 56, 20, 1
<span class="fc" id="L1604">        final float[] kernel = new float[]{0.010333488f, 0.20755373f, 0.5641896f, </span>
             0.20755373f, 0.010333488f};
        
        do {
<span class="fc" id="L1608">            applyKernel1D(input, kernel, true);</span>
<span class="fc" id="L1609">            applyKernel1D(input, kernel, false);</span>
            
<span class="fc" id="L1611">            currentSigmaSq = currentSigmaSq + sigma0Sq;</span>
            
<span class="pc bpc" id="L1613" title="3 of 4 branches missed.">        } while ((finalSigmaSq &gt; currentSigmaSq) &amp;&amp; Math.abs(finalSigmaSq - currentSigmaSq) &gt; 0.01);</span>
        
<span class="fc" id="L1615">    }</span>

    public void blur(GreyscaleImage input, SIGMA sigma) {

<span class="fc" id="L1619">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1621">        blur(input, kernel);</span>
<span class="fc" id="L1622">    }</span>

    public void blur(GreyscaleImage input, SIGMA sigma, int minValue, int maxValue) {
<span class="nc" id="L1625">        float[] kernel = Gaussian1D.getKernel(sigma);</span>
<span class="nc" id="L1626">        blur(input, kernel, minValue, maxValue);</span>
<span class="nc" id="L1627">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, float sigma) {

<span class="fc" id="L1636">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1638">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1640">        int w = input.getWidth();</span>
<span class="fc" id="L1641">        int h = input.getHeight();</span>
<span class="fc" id="L1642">        Image output = input.copyImage();</span>

<span class="fc bfc" id="L1644" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1645" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1646">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="fc" id="L1648">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="fc" id="L1652">        input.resetTo(output);</span>

<span class="fc bfc" id="L1654" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1655" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1656">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="fc" id="L1658">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="fc" id="L1662">        input.resetTo(output);</span>
<span class="fc" id="L1663">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, float sigma, int minValue, int maxValue) {

<span class="fc" id="L1672">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1674">        blur(input, kernel, minValue, maxValue);</span>
<span class="fc" id="L1675">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, SIGMA sigma, int minValue, int maxValue) {

<span class="fc" id="L1684">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1686">        blur(input, kernel, minValue, maxValue);</span>
<span class="fc" id="L1687">    }</span>
    
    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     */
    public void blur(Image input, float[] kernel, int minValue, int maxValue) {

<span class="fc" id="L1695">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1697">        int w = input.getWidth();</span>
<span class="fc" id="L1698">        int h = input.getHeight();</span>
<span class="fc" id="L1699">        Image output = input.copyImage();</span>

<span class="fc bfc" id="L1701" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1703">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="fc" id="L1705">                int r = (int)Math.round(conv[0]);</span>
<span class="fc" id="L1706">                int g = (int)Math.round(conv[1]);</span>
<span class="fc" id="L1707">                int b = (int)Math.round(conv[2]);</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">                if (r &lt; minValue) {</span>
<span class="nc" id="L1709">                    r = minValue;</span>
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">                } else if (r &gt; maxValue) {</span>
<span class="nc" id="L1711">                    r = maxValue;</span>
                }
<span class="pc bpc" id="L1713" title="1 of 2 branches missed.">                if (g &lt; minValue) {</span>
<span class="nc" id="L1714">                    g = minValue;</span>
<span class="pc bpc" id="L1715" title="1 of 2 branches missed.">                } else if (g &gt; maxValue) {</span>
<span class="nc" id="L1716">                    g = maxValue;</span>
                }
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">                if (b &lt; minValue) {</span>
<span class="nc" id="L1719">                    b = minValue;</span>
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">                } else if (b &gt; maxValue) {</span>
<span class="nc" id="L1721">                    b = maxValue;</span>
                }
<span class="fc" id="L1723">                output.setRGB(i, j, r, g, b);</span>
            }
        }

<span class="fc" id="L1727">        input.resetTo(output);</span>

<span class="fc bfc" id="L1729" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1731">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="fc" id="L1733">                int r = (int)Math.round(conv[0]);</span>
<span class="fc" id="L1734">                int g = (int)Math.round(conv[1]);</span>
<span class="fc" id="L1735">                int b = (int)Math.round(conv[2]);</span>
<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">                if (r &lt; minValue) {</span>
<span class="nc" id="L1737">                    r = minValue;</span>
<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">                } else if (r &gt; maxValue) {</span>
<span class="nc" id="L1739">                    r = maxValue;</span>
                }
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">                if (g &lt; minValue) {</span>
<span class="nc" id="L1742">                    g = minValue;</span>
<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">                } else if (g &gt; maxValue) {</span>
<span class="nc" id="L1744">                    g = maxValue;</span>
                }
<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">                if (b &lt; minValue) {</span>
<span class="nc" id="L1747">                    b = minValue;</span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">                } else if (b &gt; maxValue) {</span>
<span class="nc" id="L1749">                    b = maxValue;</span>
                }
<span class="fc" id="L1751">                output.setRGB(i, j, r, g, b);</span>
            }
        }

<span class="fc" id="L1755">        input.resetTo(output);</span>
<span class="fc" id="L1756">    }</span>

    public void applySecondDerivGaussian(GreyscaleImage input, SIGMA sigma,
        int minValueRange, int maxValueRange) {

<span class="nc" id="L1761">        float[] kernel = Gaussian1DSecondDeriv.getBinomialKernel(sigma);</span>

<span class="nc" id="L1763">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1765">        int w = input.getWidth();</span>
<span class="nc" id="L1766">        int h = input.getHeight();</span>
<span class="nc" id="L1767">        GreyscaleImage output = input.copyImage();</span>

<span class="nc bnc" id="L1769" title="All 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="nc" id="L1772">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);

<span class="nc" id="L1775">                int v = (int)Math.round(conv);</span>

<span class="nc bnc" id="L1777" title="All 2 branches missed.">                if (v &lt; minValueRange) {</span>
<span class="nc" id="L1778">                    v = minValueRange;</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1780">                    v = maxValueRange;</span>
                }

<span class="nc" id="L1783">                output.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L1787">        input.resetTo(output);</span>

<span class="nc bnc" id="L1789" title="All 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="nc" id="L1792">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);

<span class="nc" id="L1795">                int v = (int)Math.round(conv);</span>

<span class="nc bnc" id="L1797" title="All 2 branches missed.">                if (v &lt; minValueRange) {</span>
<span class="nc" id="L1798">                    v = minValueRange;</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1800">                    v = maxValueRange;</span>
                }

<span class="nc" id="L1803">                output.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L1807">        input.resetTo(output);</span>
<span class="nc" id="L1808">    }</span>
    
    public int[] performSecondDerivGaussian(GreyscaleImage input, 
        SIGMA sigma) {

<span class="nc" id="L1813">        float[] kernel = Gaussian1DSecondDeriv.getBinomialKernel(sigma);</span>

<span class="nc" id="L1815">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1817">        int w = input.getWidth();</span>
<span class="nc" id="L1818">        int h = input.getHeight();</span>
        
<span class="nc" id="L1820">        int[] output = new int[w * h];</span>

<span class="nc bnc" id="L1822" title="All 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="nc" id="L1825">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);

<span class="nc" id="L1828">                output[input.getInternalIndex(i, j)] = </span>
<span class="nc" id="L1829">                    (int)Math.round(conv);</span>
            }
        }
        
<span class="nc" id="L1833">        int[] output2 = Arrays.copyOf(output, </span>
            output.length);

<span class="nc bnc" id="L1836" title="All 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="nc" id="L1839">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    output2, w, h, i, j, kernel, false);

<span class="nc" id="L1842">                output[input.getInternalIndex(i, j)] = </span>
<span class="nc" id="L1843">                    (int)Math.round(conv);</span>
            }
        }

<span class="nc" id="L1847">        return output;</span>
    }
    
    public void applyKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1853">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1855">        GreyscaleImage output = input.createWithDimensions();</span>

<span class="fc bfc" id="L1857" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="fc" id="L1859">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1861">                int g = (int)Math.round(conv);</span>
<span class="fc" id="L1862">                output.setValue(i, j, g);</span>
            }
        }

<span class="fc" id="L1866">        input.resetTo(output);</span>
<span class="fc" id="L1867">    }</span>
    
    public void applyKernel1D(int[][] input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1872">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1874">        int w = input.length;</span>
<span class="fc" id="L1875">        int h = input[0].length;</span>
        
<span class="fc" id="L1877">        int[][] output = new int[w][];</span>

<span class="fc bfc" id="L1879" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1880">            output[i] = new int[h];</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1882">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1884">                int g = (int)Math.round(conv);</span>
<span class="fc" id="L1885">                output[i][j] = g;</span>
            }
        }

<span class="fc bfc" id="L1889" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1890">            System.arraycopy(output[i], 0, input[i], 0, h);</span>
        }
<span class="fc" id="L1892">    }</span>
    
    public void applyKernel1D(float[][] input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1897">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1899">        int w = input.length;</span>
<span class="fc" id="L1900">        int h = input[0].length;</span>
        
<span class="fc" id="L1902">        float[][] output = new float[w][];</span>

<span class="fc bfc" id="L1904" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1905">            output[i] = new float[h];</span>
<span class="fc bfc" id="L1906" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1907">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1909">                float g = (float)conv;</span>
<span class="fc" id="L1910">                output[i][j] = g;</span>
            }
        }

<span class="fc bfc" id="L1914" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1915">            System.arraycopy(output[i], 0, input[i], 0, h);</span>
        }
<span class="fc" id="L1917">    }</span>

    public void applyKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX, int minValue, int maxValue) {

<span class="nc" id="L1922">        GreyscaleImage output = convolveWithKernel1D(input, kernel, calcForX, </span>
            minValue, maxValue);

<span class="nc" id="L1925">        input.resetTo(output);</span>
<span class="nc" id="L1926">    }</span>
    
    public GreyscaleImage convolveWithKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX, int minValue, int maxValue) {

<span class="nc" id="L1931">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1933">        GreyscaleImage output = input.createWithDimensions();</span>

<span class="nc bnc" id="L1935" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1937">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="nc" id="L1939">                int g = (int)Math.round(conv);</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                if (g &lt; minValue) {</span>
<span class="nc" id="L1941">                    g = minValue;</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">                } else if (g &gt; maxValue) {</span>
<span class="nc" id="L1943">                    g = maxValue;</span>
                }
<span class="nc" id="L1945">                output.setValue(i, j, g);</span>
            }
        }

<span class="nc" id="L1949">        return output;</span>
    }

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param kernel iD kernel
     */
    protected void blur(Image input, float[] kernel) {

<span class="nc" id="L1959">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1961">        int w = input.getWidth();</span>
<span class="nc" id="L1962">        int h = input.getHeight();</span>
<span class="nc" id="L1963">        Image output = (ImageExt)input.copyImage();</span>

<span class="nc bnc" id="L1965" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1966" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1967">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="nc" id="L1969">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1973">        input.resetTo(output);</span>

<span class="nc bnc" id="L1975" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1977">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="nc" id="L1979">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1983">        input.resetTo(output);</span>
<span class="nc" id="L1984">    }</span>

    public void divideByBlurredSelf(GreyscaleImage input, float sigma) {

<span class="nc" id="L1988">        GreyscaleImage input2 = input.copyImage();</span>

<span class="nc" id="L1990">        blur(input, sigma);</span>

<span class="nc bnc" id="L1992" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1994">                int v = input.getValue(i, j);</span>
<span class="nc" id="L1995">                int vorig = input2.getValue(i, j);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L1997">                    float r = (float)vorig/(float)v;</span>
<span class="nc" id="L1998">                    input.setValue(i, j, (int)(100*r));</span>
                }
            }
        }
<span class="nc" id="L2002">    }</span>

    public GreyscaleImage binImage(GreyscaleImage img, int binFactor) {

<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L2007">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L2010">        int w0 = img.getWidth();</span>
<span class="fc" id="L2011">        int h0 = img.getHeight();</span>

<span class="fc" id="L2013">        int w1 = w0/binFactor;</span>
<span class="fc" id="L2014">        int h1 = h0/binFactor;</span>

<span class="fc" id="L2016">        GreyscaleImage out = new GreyscaleImage(w1, h1, img.getType());</span>
<span class="fc" id="L2017">        out.setXRelativeOffset(Math.round(img.getXRelativeOffset()/binFactor));</span>
<span class="fc" id="L2018">        out.setYRelativeOffset(Math.round(img.getYRelativeOffset()/binFactor));</span>

<span class="fc bfc" id="L2020" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L2022" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L2024">                int vSum = 0;</span>
<span class="fc" id="L2025">                int count = 0;</span>

<span class="fc bfc" id="L2027" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L2028" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L2030" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L2031">                            continue;</span>
                        }
<span class="pc bpc" id="L2033" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L2034">                            continue;</span>
                        }

<span class="fc" id="L2037">                        int v = img.getValue(ii, jj);</span>

<span class="fc" id="L2039">                        vSum += v;</span>
<span class="fc" id="L2040">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L2045">                    float v = (float)vSum/(float)count;</span>
<span class="fc" id="L2046">                    vSum = Math.round(v);</span>
                }

<span class="fc" id="L2049">                out.setValue(i, j, vSum);</span>
            }
        }

<span class="fc" id="L2053">        return out;</span>
    }
    
    public Image binImage(Image img,  int binFactor) {

<span class="pc bpc" id="L2058" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L2059">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L2062">        int w0 = img.getWidth();</span>
<span class="fc" id="L2063">        int h0 = img.getHeight();</span>

<span class="fc" id="L2065">        int w1 = w0/binFactor;</span>
<span class="fc" id="L2066">        int h1 = h0/binFactor;</span>

<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">        Image out = new Image(w1, h1, !img.is64Bit);</span>

<span class="fc" id="L2070">        binImage(img, binFactor, out);</span>

<span class="fc" id="L2072">        return out;</span>
    }

    public ImageExt binImage(ImageExt img,  int binFactor) {

<span class="pc bpc" id="L2077" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L2078">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L2081">        int w0 = img.getWidth();</span>
<span class="fc" id="L2082">        int h0 = img.getHeight();</span>

<span class="fc" id="L2084">        int w1 = w0/binFactor;</span>
<span class="fc" id="L2085">        int h1 = h0/binFactor;</span>

<span class="pc bpc" id="L2087" title="1 of 2 branches missed.">        ImageExt out = new ImageExt(w1, h1, !img.is64Bit);</span>

<span class="fc" id="L2089">        binImage(img, binFactor, out);</span>

<span class="fc" id="L2091">        return out;</span>
    }
    
    private void binImage(Image inputImg,  int binFactor, Image outputImg) {

<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">        if (inputImg == null) {</span>
<span class="nc" id="L2097">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L2100">        int w0 = inputImg.getWidth();</span>
<span class="fc" id="L2101">        int h0 = inputImg.getHeight();</span>

<span class="fc" id="L2103">        int w1 = outputImg.getWidth();</span>
<span class="fc" id="L2104">        int h1 = outputImg.getHeight();</span>

<span class="fc bfc" id="L2106" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L2108" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L2110">                long rSum = 0;</span>
<span class="fc" id="L2111">                long gSum = 0;</span>
<span class="fc" id="L2112">                long bSum = 0;</span>

<span class="fc" id="L2114">                int count = 0;</span>

<span class="fc bfc" id="L2116" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L2117" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L2119" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L2120">                            continue;</span>
                        }
<span class="pc bpc" id="L2122" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L2123">                            continue;</span>
                        }

<span class="fc" id="L2126">                        int rgb = inputImg.getRGB(ii, jj);</span>

<span class="fc" id="L2128">                        int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="fc" id="L2129">                        int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="fc" id="L2130">                        int b = rgb &amp; 0xFF;</span>

<span class="fc" id="L2132">                        rSum += r;</span>
<span class="fc" id="L2133">                        gSum += g;</span>
<span class="fc" id="L2134">                        bSum += b;</span>

<span class="fc" id="L2136">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L2140" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L2141">                    rSum = Math.round((float)rSum/(float)count);</span>
<span class="fc" id="L2142">                    gSum = Math.round((float)gSum/(float)count);</span>
<span class="fc" id="L2143">                    bSum = Math.round((float)bSum/(float)count);</span>
                }

<span class="fc" id="L2146">                outputImg.setRGB(i, j, (int)rSum, (int)gSum, (int)bSum);</span>
            }
        }
<span class="fc" id="L2149">    }</span>
    
    public GreyscaleImage expandBy2UsingBilinearInterp(GreyscaleImage input) {

<span class="nc bnc" id="L2153" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L2154">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="nc" id="L2157">        int w1 = 2 * input.getWidth();</span>
<span class="nc" id="L2158">        int h1 = 2 * input.getHeight();</span>

<span class="nc" id="L2160">        return expandBy2UsingBilinearInterp(input, w1, h1);</span>
    }

    /**
     * expand image to final size by a factor of 2, and use the given output
     * widths and heights which are expected to be either twice the input
     * or twice plus 1.
     * @param input
     * @param outWidth
     * @param outHeight
     * @return
     */
    public GreyscaleImage expandBy2UsingBilinearInterp(GreyscaleImage input,
        int outWidth, int outHeight) {

<span class="pc bpc" id="L2175" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L2176">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="fc" id="L2179">        int w0 = input.getWidth();</span>
<span class="fc" id="L2180">        int h0 = input.getHeight();</span>

<span class="pc bpc" id="L2182" title="3 of 4 branches missed.">        if ((2*w0 != outWidth) &amp;&amp; ((2*w0 + 1) != outWidth)) {</span>
<span class="nc" id="L2183">            throw new IllegalArgumentException(</span>
            &quot;outWidth should be 2 * input.getWidth() or (2 * input.getWidth()) + 1&quot;);
        }
<span class="pc bpc" id="L2186" title="3 of 4 branches missed.">        if ((2*h0 != outHeight) &amp;&amp; ((2*h0 + 1) != outHeight)) {</span>
<span class="nc" id="L2187">            throw new IllegalArgumentException(</span>
            &quot;outHeight should be 2 * input.getHeight() or (2 * input.getHeight()) + 1&quot;);
        }

<span class="fc" id="L2191">        GreyscaleImage out = input.createWithDimensions(outWidth, outHeight);</span>

<span class="fc bfc" id="L2193" title="All 2 branches covered.">        for (int i = 0; i &lt; outWidth; ++i) {</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">            for (int j = 0; j &lt; outHeight; ++j) {</span>
<span class="fc" id="L2195">                int v = upsampleBy2UsingBilinearInterp(input, i, j);</span>
<span class="fc" id="L2196">                out.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L2200">        return out;</span>
    }
    
    public int upsampleBy2UsingBilinearInterp(GreyscaleImage input,
        int x, int y) {
        
<span class="fc" id="L2206">        int w0 = input.getWidth();</span>
<span class="fc" id="L2207">        int h0 = input.getHeight();</span>

<span class="fc bfc" id="L2209" title="All 4 branches covered.">        if (((x &amp; 1) != 1) &amp;&amp; ((y &amp; 1) != 1)) {</span>
<span class="fc" id="L2210">            int x0 = x/2;</span>
<span class="fc" id="L2211">            int y0 = y/2;</span>
<span class="pc bpc" id="L2212" title="2 of 4 branches missed.">            if ((x0 &lt; w0) &amp;&amp; (y0 &lt; h0)) {</span>
<span class="fc" id="L2213">                return input.getValue(x0, y0);</span>
            }
        }

<span class="fc" id="L2217">        float x0 = (float)x/2.f;</span>
<span class="fc" id="L2218">        float y0 = (float)y/2.f;</span>

<span class="fc bfc" id="L2220" title="All 2 branches covered.">        if (x0 &gt; (w0 - 1)) {</span>
<span class="fc" id="L2221">            x0 = w0 - 1;</span>
        }
<span class="fc bfc" id="L2223" title="All 2 branches covered.">        if (y0 &gt; (h0 - 1)) {</span>
<span class="fc" id="L2224">            y0 = h0 - 1;</span>
        }

<span class="fc" id="L2227">        double v2 = biLinearInterpolation(input, x0, y0);</span>

<span class="fc" id="L2229">        return (int)Math.round(v2);</span>
    }
    
    public double upsampleBy2UsingBilinearInterp(double[][] input,
        int x, int y) {
        
<span class="nc" id="L2235">        int w0 = input.length;</span>
<span class="nc" id="L2236">        int h0 = input[0].length;</span>

<span class="nc bnc" id="L2238" title="All 4 branches missed.">        if (((x &amp; 1) != 1) &amp;&amp; ((y &amp; 1) != 1)) {</span>
<span class="nc" id="L2239">            int x0 = x/2;</span>
<span class="nc" id="L2240">            int y0 = y/2;</span>
<span class="nc bnc" id="L2241" title="All 4 branches missed.">            if ((x0 &lt; w0) &amp;&amp; (y0 &lt; h0)) {</span>
<span class="nc" id="L2242">                return input[x0][y0];</span>
            }
        }

<span class="nc" id="L2246">        float x0 = (float)x/2.f;</span>
<span class="nc" id="L2247">        float y0 = (float)y/2.f;</span>

<span class="nc bnc" id="L2249" title="All 2 branches missed.">        if (x0 &gt; (w0 - 1)) {</span>
<span class="nc" id="L2250">            x0 = w0 - 1;</span>
        }
<span class="nc bnc" id="L2252" title="All 2 branches missed.">        if (y0 &gt; (h0 - 1)) {</span>
<span class="nc" id="L2253">            y0 = h0 - 1;</span>
        }

<span class="nc" id="L2256">        double v2 = biLinearInterpolation(input, x0, y0);</span>

<span class="nc" id="L2258">        return v2;</span>
    }
    
    public double upsampleBy2UsingBilinearInterp(Complex[][] input,
        int x, int y, boolean calcForReal) {
        
<span class="nc" id="L2264">        int w0 = input.length;</span>
<span class="nc" id="L2265">        int h0 = input[0].length;</span>

<span class="nc bnc" id="L2267" title="All 4 branches missed.">        if (((x &amp; 1) != 1) &amp;&amp; ((y &amp; 1) != 1)) {</span>
<span class="nc" id="L2268">            int x0 = x/2;</span>
<span class="nc" id="L2269">            int y0 = y/2;</span>
<span class="nc bnc" id="L2270" title="All 4 branches missed.">            if ((x0 &lt; w0) &amp;&amp; (y0 &lt; h0)) {</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">                if (calcForReal) {</span>
<span class="nc" id="L2272">                    return input[x0][y0].re();</span>
                } else {
<span class="nc" id="L2274">                    return input[x0][y0].im();</span>
                }
            }
        }

<span class="nc" id="L2279">        float x0 = (float)x/2.f;</span>
<span class="nc" id="L2280">        float y0 = (float)y/2.f;</span>

<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (x0 &gt; (w0 - 1)) {</span>
<span class="nc" id="L2283">            x0 = w0 - 1;</span>
        }
<span class="nc bnc" id="L2285" title="All 2 branches missed.">        if (y0 &gt; (h0 - 1)) {</span>
<span class="nc" id="L2286">            y0 = h0 - 1;</span>
        }

<span class="nc" id="L2289">        double v2 = biLinearInterpolation(input, x0, y0, calcForReal);</span>

<span class="nc" id="L2291">        return v2;</span>
    }
    
    public double upsampleUsingBilinearInterp(Complex[][] input,
        int x, int y, boolean calcForReal, int factor) {
        
<span class="nc" id="L2297">        int w0 = input.length;</span>
<span class="nc" id="L2298">        int h0 = input[0].length;</span>

<span class="nc bnc" id="L2300" title="All 4 branches missed.">        if (((x &amp; 1) != 1) &amp;&amp; ((y &amp; 1) != 1)) {</span>
<span class="nc" id="L2301">            int x0 = x/factor;</span>
<span class="nc" id="L2302">            int y0 = y/factor;</span>
<span class="nc bnc" id="L2303" title="All 4 branches missed.">            if ((x0 &lt; w0) &amp;&amp; (y0 &lt; h0)) {</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">                if (calcForReal) {</span>
<span class="nc" id="L2305">                    return input[x0][y0].re();</span>
                } else {
<span class="nc" id="L2307">                    return input[x0][y0].im();</span>
                }
            }
        }

<span class="nc" id="L2312">        float x0 = (float)x/(float)factor;</span>
<span class="nc" id="L2313">        float y0 = (float)y/(float)factor;</span>

<span class="nc bnc" id="L2315" title="All 2 branches missed.">        if (x0 &gt; (w0 - 1)) {</span>
<span class="nc" id="L2316">            x0 = w0 - 1;</span>
        }
<span class="nc bnc" id="L2318" title="All 2 branches missed.">        if (y0 &gt; (h0 - 1)) {</span>
<span class="nc" id="L2319">            y0 = h0 - 1;</span>
        }

<span class="nc" id="L2322">        double v2 = biLinearInterpolation(input, x0, y0, calcForReal);</span>

<span class="nc" id="L2324">        return v2;</span>
    }
    
    public GreyscaleImage unbinImage(GreyscaleImage input, int binFactor) {

<span class="nc bnc" id="L2329" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L2330">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="nc" id="L2333">        int w0 = input.getWidth();</span>
<span class="nc" id="L2334">        int h0 = input.getHeight();</span>

<span class="nc" id="L2336">        GreyscaleImage out = input.createWithDimensions(</span>
            binFactor* w0, binFactor * h0);

<span class="nc" id="L2339">        int w1 = out.getWidth();</span>
<span class="nc" id="L2340">        int h1 = out.getHeight();</span>

<span class="nc bnc" id="L2342" title="All 2 branches missed.">        for (int i = 0; i &lt; w0; i++) {</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">            for (int j = 0; j &lt; h0; j++) {</span>

<span class="nc" id="L2345">                int v = input.getValue(i, j);</span>

<span class="nc bnc" id="L2347" title="All 2 branches missed.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="nc" id="L2349">                        out.setValue(ii, jj, v);</span>
                    }
<span class="nc bnc" id="L2351" title="All 2 branches missed.">                    for (int jj = ((j + 1)*binFactor); jj &lt; h1; jj++) {</span>
<span class="nc" id="L2352">                        out.setValue(ii, jj, v);</span>
                    }
                }
<span class="nc bnc" id="L2355" title="All 2 branches missed.">                for (int ii = ((i + 1)*binFactor); ii &lt; w1; ii++) {</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="nc" id="L2357">                        out.setValue(ii, jj, v);</span>
                    }
<span class="nc bnc" id="L2359" title="All 2 branches missed.">                    for (int jj = ((j + 1)*binFactor); jj &lt; h1; jj++) {</span>
<span class="nc" id="L2360">                        out.setValue(ii, jj, v);</span>
                    }
                }
            }
        }

<span class="nc" id="L2366">        return out;</span>
    }

    /**
     * apply 2D FFT transform using the JFFTPack.
     *
     * @param input input image, which should probably be type full range int
     * @param forward if true, apply FFT transform, else inverse FFT transform
     */
    public void apply2DFFT2(GreyscaleImage input, boolean forward) {

<span class="nc" id="L2377">         Complex1D[] ccOut = create2DFFT2WithSwapMajor(input, forward);</span>

<span class="nc bnc" id="L2379" title="All 4 branches missed.">         assert(ccOut.length == input.getHeight());</span>
<span class="nc bnc" id="L2380" title="All 4 branches missed.">         assert(ccOut[0].x.length == input.getWidth());</span>

<span class="nc bnc" id="L2382" title="All 2 branches missed.">         for (int i0 = 0; i0 &lt; ccOut.length; ++i0) {</span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">             for (int i1 = 0; i1 &lt; ccOut[i0].x.length; ++i1) {</span>
<span class="nc" id="L2384">                 double re = ccOut[i0].x[i1];</span>
<span class="nc" id="L2385">                 input.setValue(i1, i0, (int)re);</span>
             }
         }
<span class="nc" id="L2388">    }</span>

    /**
     * apply 2D FFT transform using the efficient iterative power of 2 method
     * that uses the butterfly operation if image dimensions are a power of
     * 2, else uses an alternative.
     *
     * @param input
     * @param forward if true, apply FFT transform, else inverse FFT transform
     */
    public void apply2DFFT(GreyscaleImage input, boolean forward) {

<span class="nc" id="L2400">        int n0 = input.getWidth();</span>
<span class="nc" id="L2401">        int n1 = input.getHeight();</span>

<span class="nc" id="L2403">        int nn0 = 1 &lt;&lt; (int)(Math.ceil(Math.log(n0)/Math.log(2)));</span>
<span class="nc" id="L2404">        int nn1 = 1 &lt;&lt; (int)(Math.ceil(Math.log(n1)/Math.log(2)));</span>

<span class="nc bnc" id="L2406" title="All 4 branches missed.">        if (nn0 &gt; n0 || nn1 &gt; n1) {</span>
<span class="nc" id="L2407">            apply2DFFT2(input, forward);</span>
<span class="nc" id="L2408">            return;</span>
        }

        // initialize matrix of complex numbers as real numbers from image (imaginary are 0's)
<span class="nc" id="L2412">        Complex[][] cc = convertImage(input);</span>

<span class="nc" id="L2414">        Complex[][] ccOut = create2DFFT(cc, forward);</span>

<span class="nc" id="L2416">        input.fill(0);</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="nc" id="L2419">                double re = ccOut[col][row].re();</span>
<span class="nc" id="L2420">                input.setValue(col, row, (int)re);</span>
            }
        }

<span class="nc" id="L2424">    }</span>
    
    public Complex[][] create2DFFT(double[][] input, boolean forward) {

        // performs normalization by default
<span class="nc" id="L2429">        return create2DFFT(input, true, forward);</span>
    }
    
    /**
     * perform fft on input.  
     * @param input
     * @param doNormalize
     * @param forward
     * @return
     */
    public Complex[][] create2DFFT(final double[][] input, boolean doNormalize,
        boolean forward) {
        
<span class="fc" id="L2442">        Complex[][] input2 = new Complex[input.length][];</span>
<span class="fc bfc" id="L2443" title="All 2 branches covered.">        for (int i = 0; i &lt; input.length; ++i) {</span>
<span class="fc" id="L2444">            input2[i] = new Complex[input[0].length];</span>
<span class="fc bfc" id="L2445" title="All 2 branches covered.">            for (int j = 0; j &lt; input[0].length; ++j) {</span>
<span class="fc" id="L2446">                input2[i][j] = new Complex(input[i][j], 0);</span>
            }
        }
        
<span class="fc" id="L2450">        return create2DFFT(input2, doNormalize, forward);</span>
    }

    public Complex[][] create2DFFT(Complex[][] input, boolean forward) {

        // performs normalization by default
<span class="nc" id="L2456">        return create2DFFT(input, true, forward);</span>
    }

    /**
     * runtime complexity: is O(N*lg_2(N)) for N not power of 2,
     * else is 
     * 
     * perform fft on input.
     * @param input
     * @param doNormalize
     * @param forward
     * @return
     */
    public Complex[][] create2DFFT(final Complex[][] input, boolean doNormalize,
        boolean forward) {

<span class="fc" id="L2472">        final int n0 = input.length;</span>
<span class="fc" id="L2473">        final int n1 = input[0].length;</span>
        
<span class="fc" id="L2475">        int nn0 = 1 &lt;&lt; (int)(Math.ceil(Math.log(n0)/Math.log(2)));</span>
<span class="fc" id="L2476">        int nn1 = 1 &lt;&lt; (int)(Math.ceil(Math.log(n1)/Math.log(2)));</span>
        
<span class="fc bfc" id="L2478" title="All 4 branches covered.">        if (nn0 &gt; n0 || nn1 &gt; n1) {</span>
<span class="fc" id="L2479">            Complex1D[] input2 = convertToComplex1D(input);</span>
<span class="fc" id="L2480">            Complex1D[] output = create2DFFT2(input2, doNormalize, forward);</span>
<span class="fc" id="L2481">            Complex[][] output2 = convertToComplex(output);</span>
<span class="fc" id="L2482">            return output2;</span>
        }
            
<span class="fc" id="L2485">        Complex[][] output = copy(input);</span>
        
        // padding is at front of cols and rows
    
<span class="fc" id="L2489">        FFT fft = new FFT();</span>
<span class="fc bfc" id="L2490" title="All 2 branches covered.">        if (!doNormalize) {</span>
<span class="fc" id="L2491">            fft.setToNotNormalize();</span>
        }

        // ----- perform FFT by dimension 0 -----
<span class="fc bfc" id="L2495" title="All 2 branches covered.">        for (int i0 = 0; i0 &lt; nn0; i0++) {</span>
<span class="fc bfc" id="L2496" title="All 2 branches covered.">            if (forward) {</span>
<span class="fc" id="L2497">                output[i0] = fft.fft(output[i0]);</span>
            } else {
<span class="fc" id="L2499">                output[i0] = fft.ifft(output[i0]);</span>
            }
        }
        
        // re-use array for the FFT by dimension 1
<span class="fc" id="L2504">        Complex[] tmp = new Complex[nn0];</span>

        /*
        nn0
         |
        \|/
        [0]  ..........nn1-1
        [1]  ..........nn1-1
        */
       
        // ----- perform the FFT on dimension 1 ------
<span class="fc bfc" id="L2515" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; nn1; ++i1) {</span>

            // store each column in tmp array and perform fft on it then
            // recopy values back into columns
<span class="fc bfc" id="L2519" title="All 2 branches covered.">            for (int i0 = 0; i0 &lt; nn0; ++i0) {</span>
<span class="fc" id="L2520">                tmp[i0] = output[i0][i1];</span>
            }

<span class="fc bfc" id="L2523" title="All 2 branches covered.">            if (forward) {</span>
<span class="fc" id="L2524">                tmp = fft.fft(tmp);</span>
            } else {
<span class="fc" id="L2526">                tmp = fft.ifft(tmp);</span>
            }

<span class="fc bfc" id="L2529" title="All 2 branches covered.">            for (int i0 = 0; i0 &lt; nn0; ++i0) {</span>
<span class="fc" id="L2530">                output[i0][i1] = tmp[i0];</span>
            }
        }
        
<span class="fc" id="L2534">        return output;        </span>
    }

    /**
     * perform a 2-dimension FFT using the JFFTPack library using the input
     * img and return the results as a complex two dimensional array
     * which uses the format a[row][col].
     *
     * @param img
     * @param forward
     * @return
     */
    public Complex1D[] create2DFFT2WithSwapMajor(GreyscaleImage img, boolean forward) {

        // swap major axes for input to FFT 2D algorithm 2
<span class="nc" id="L2549">        Complex1D[] cInput = new Complex1D[img.getWidth()];</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc" id="L2551">            cInput[i] = new Complex1D();</span>
<span class="nc" id="L2552">            cInput[i].x = new double[img.getHeight()];</span>
<span class="nc" id="L2553">            cInput[i].y = new double[img.getHeight()];</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L2555">                cInput[i].x[j] = img.getValue(i, j);</span>
            }
        }

<span class="nc" id="L2559">        Complex1D[] output2 = create2DFFT2(cInput, forward);</span>

<span class="nc" id="L2561">        return output2;</span>
    }

    /**
     * apply 2D FFT transform using the efficient iterative power of 2 method
     * that uses the butterfly operation.
     *
     * @param img
     * @param forward if true, apply FFT transform, else inverse FFT transform
     * @return 2d fft results in format a[row][col]
     */
    public Complex[][] create2DFFTWithSwapMajor(GreyscaleImage img, boolean forward) {

        // normalize by default
<span class="nc" id="L2575">        return create2DFFTWithSwapMajor(img, true, forward);</span>
    }

    /**
     * apply 2D FFT transform .
     *
     * @param input
     * @param doNormalize perform FFT normalization if true
     * @param forward if true, apply FFT transform, else inverse FFT transform
     * @return 2d fft results in format a[row][col]
     */
    public Complex[][] create2DFFTWithSwapMajor(GreyscaleImage input,
        boolean doNormalize, boolean forward) {

        // initialize matrix of complex numbers as real numbers from image (imaginary are 0's)
<span class="fc" id="L2590">        Complex[][] cc = convertImageWithSwapMajor(input);</span>

<span class="fc" id="L2592">        Complex[][] ccFFT = create2DFFT(cc, doNormalize, forward);</span>

<span class="fc" id="L2594">        return ccFFT;</span>
    }

    /**
     * perform a 2-dimension FFT using the JFFTPack library.
     *
     * @param input double array of complex data in format double[nRows][2*nColumns]
     * where the column elements are alternately the complex real number and the
     * complex imaginary number.
     * @param forward
     * @return two dimensional complex array of size Complex[nRows][input.nCols/2)
     */
    public Complex1D[] create2DFFT2(Complex1D[] input, boolean forward) {

        // perform normalization by default
<span class="nc" id="L2609">        return create2DFFT2(input, true, forward);</span>
    }

    /**
     * perform a 2-dimension FFT using the JFFTPack library.
     * 
     * runtime complexity: is O(N*lg_2(N)) for N not power of 2.
     * 
     * @param input double array of complex data in format double[nRows][2*nColumns]
     * where the column elements are alternately the complex real number and the
     * complex imaginary number.
     * @param forward
     * @return two dimensional complex array of size Complex[nRows][input.nCols/2)
     */
    public Complex1D[] create2DFFT2(Complex1D[] input, boolean performNormalization,
        boolean forward) {

<span class="fc" id="L2626">        final int n0 = input.length;</span>
<span class="fc" id="L2627">        final int n1 = input[0].x.length;</span>

<span class="fc" id="L2629">        Complex1D[] output = Arrays.copyOf(input, input.length);</span>

<span class="fc" id="L2631">        ComplexDoubleFFT fft1 = new ComplexDoubleFFT(n1);</span>

<span class="fc" id="L2633">        final double norm1 = 1./Math.sqrt(n1);</span>

        // ----- perform FFT by dimension 0 -----
<span class="fc bfc" id="L2636" title="All 2 branches covered.">        for (int i0 = 0; i0 &lt; n0; i0++) {</span>

<span class="fc bfc" id="L2638" title="All 2 branches covered.">            if (forward) {</span>
<span class="fc" id="L2639">                fft1.ft(output[i0]);</span>
            } else {
<span class="fc" id="L2641">                fft1.bt(output[i0]);</span>
            }

            // normalize the data
<span class="fc bfc" id="L2645" title="All 2 branches covered.">            if (performNormalization) {</span>
<span class="fc" id="L2646">                Complex1D a = output[i0];</span>
<span class="fc bfc" id="L2647" title="All 2 branches covered.">                for (int idx = 0; idx &lt; a.x.length; ++idx) {</span>
<span class="fc" id="L2648">                    a.x[idx] *= norm1;</span>
<span class="fc" id="L2649">                    a.y[idx] *= norm1;</span>
                }
            }
        }
        
        // re-use array for the FFT by dimension 1 (across rows)
<span class="fc" id="L2655">        Complex1D tmp = new Complex1D();</span>
<span class="fc" id="L2656">        tmp.x = new double[n0];</span>
<span class="fc" id="L2657">        tmp.y = new double[n0];</span>

<span class="fc" id="L2659">        ComplexDoubleFFT fft0 = new ComplexDoubleFFT(n0);</span>

<span class="fc bfc" id="L2661" title="All 2 branches covered.">        final double norm0 = performNormalization ? (1./Math.sqrt(n0)) : 1.;</span>
        
        // ----- perform the FFT on dimension 1 ------
<span class="fc bfc" id="L2664" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; n1; ++i1) {</span>

            // store each column in tmp array and perform fft on it then
            // recopy values back into columns
<span class="fc bfc" id="L2668" title="All 2 branches covered.">            for (int i0 = 0; i0 &lt; n0; ++i0) {</span>
<span class="fc" id="L2669">                tmp.x[i0] = output[i0].x[i1];</span>
<span class="fc" id="L2670">                tmp.y[i0] = output[i0].y[i1];</span>
            }

<span class="fc bfc" id="L2673" title="All 2 branches covered.">            if (forward) {</span>
<span class="fc" id="L2674">                fft0.ft(tmp);</span>
            } else {
<span class="fc" id="L2676">                fft0.bt(tmp);</span>
            }

<span class="fc bfc" id="L2679" title="All 2 branches covered.">            for (int i0 = 0; i0 &lt; n0; ++i0) {</span>
<span class="fc" id="L2680">                output[i0].x[i1] = tmp.x[i0] * norm0;</span>
<span class="fc" id="L2681">                output[i0].y[i1] = tmp.y[i0] * norm0;</span>
            }
        }

<span class="fc" id="L2685">        return output;</span>
    }

    public void writeToImageWithSwapMajor(GreyscaleImage img, Complex[][] cc) {

<span class="nc" id="L2690">        img.fill(0);</span>

        // write back to original image
<span class="nc bnc" id="L2693" title="All 2 branches missed.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="nc" id="L2695">                double re = cc[row][col].re();</span>
<span class="nc" id="L2696">                img.setValue(col, row, (int)re);</span>
            }
        }

<span class="nc" id="L2700">    }</span>

    public void writePositiveRealToImage(GreyscaleImage img, Complex[][] cc) {

<span class="nc" id="L2704">        img.fill(0);</span>

        // write back to original image
<span class="nc bnc" id="L2707" title="All 2 branches missed.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="nc" id="L2709">                double re = cc[col][row].re();</span>
<span class="nc" id="L2710">                double a = cc[col][row].abs();</span>
<span class="nc" id="L2711">                double p = cc[col][row].phase();</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">                if (re &gt; 0) {</span>
<span class="nc" id="L2713">                    img.setValue(col, row, (int)re);</span>
                }
            }
        }

<span class="nc" id="L2718">    }</span>

    /**
     * create a complex double array with format a[col][row]
     * @param input
     * @return
     */
    protected Complex[][] convertImage(GreyscaleImage input) {

        // initialize matrix of complex numbers as real numbers from image
<span class="fc" id="L2728">        Complex[][] cc = new Complex[input.getWidth()][];</span>

<span class="fc bfc" id="L2730" title="All 2 branches covered.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="fc" id="L2732">            cc[col] = new Complex[input.getHeight()];</span>

<span class="fc bfc" id="L2734" title="All 2 branches covered.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="fc" id="L2735">                cc[col][row] = new Complex(input.getValue(col, row), 0);</span>
            }
        }

<span class="fc" id="L2739">        return cc;</span>
    }

    /**
     * create an array of size double[nRows][*nCols] where the column elements
     *    are alternately the complex real and complex imaginary numbers
     *    (and the imaginary are 0 for this being real input).
     * @param input
     * @return
     */
    protected double[][] createInterleavedComplexSwapMajor(GreyscaleImage input) {

<span class="nc" id="L2751">        int nCols = input.getWidth();</span>
<span class="nc" id="L2752">        int nRows = input.getHeight();</span>

         // initialize matrix of complex numbers as real numbers from image
<span class="nc" id="L2755">        double[][] d = new double[nRows][];</span>

<span class="nc bnc" id="L2757" title="All 2 branches missed.">        for (int row = 0; row &lt; nRows; row++) {</span>

<span class="nc" id="L2759">            d[row] = new double[2 * nCols];</span>

<span class="nc bnc" id="L2761" title="All 2 branches missed.">            for (int col = 0; col &lt; nCols; ++col) {</span>
<span class="nc" id="L2762">                d[row][2*col] = input.getValue(col, row);</span>
<span class="nc" id="L2763">                d[row][(2*col) + 1] = 0;</span>
            }
        }

<span class="nc" id="L2767">        return d;</span>
    }

    /**
     * create a complex double array with format a[row][col]
     * @param input
     * @return
     */
    protected Complex[][] convertImageWithSwapMajor(GreyscaleImage input) {

<span class="fc" id="L2777">        int nCols = input.getWidth();</span>
<span class="fc" id="L2778">        int nRows = input.getHeight();</span>

        // initialize matrix of complex numbers as real numbers from image
<span class="fc" id="L2781">        Complex[][] cc = new Complex[nRows][];</span>

<span class="fc bfc" id="L2783" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; row++) {</span>

<span class="fc" id="L2785">            cc[row] = new Complex[nCols];</span>

<span class="fc bfc" id="L2787" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; col++) {</span>
<span class="fc" id="L2788">                cc[row][col] = new Complex(input.getValue(col, row), 0);</span>
            }
        }

<span class="fc" id="L2792">        return cc;</span>
    }

    protected Complex[][] convertImage(double[][] input) {

<span class="nc" id="L2797">        int w = input.length;</span>
<span class="nc" id="L2798">        int h = input[0].length;</span>

        // initialize matrix of complex numbers as real numbers from image
<span class="nc" id="L2801">        Complex[][] cc = new Complex[w][];</span>

<span class="nc bnc" id="L2803" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>

<span class="nc" id="L2805">            cc[col] = new Complex[h];</span>

<span class="nc bnc" id="L2807" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>
<span class="nc" id="L2808">                cc[col][row] = new Complex(input[col][row], 0);</span>
            }
        }

<span class="nc" id="L2812">        return cc;</span>
    }

    /**
     * read the image and store the non-zero pixels in a set.  note that negative
     * values will also be stored in the output set.
     * @param img
     * @return
     */
    public Set&lt;PairInt&gt; readNonZeroPixels(GreyscaleImage img) {

<span class="fc" id="L2823">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2825" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L2826" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L2827">                int v = img.getValue(col, row);</span>
<span class="fc bfc" id="L2828" title="All 2 branches covered.">                if (v != 0) {</span>
<span class="fc" id="L2829">                    set.add(new PairInt(col, row));</span>
                }
            }
        }

<span class="fc" id="L2834">        return set;</span>
    }

    /**
     * NOT YET TESTED
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(GreyscaleImage gsImg, float x, float y) {

<span class="fc" id="L2848">        double x1 = Math.floor(x);</span>

<span class="fc" id="L2850">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L2852">        double y1 = Math.floor(y);</span>

<span class="fc" id="L2854">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="fc bfc" id="L2858" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L2860">            v1 = gsImg.getValue((int)x1, (int)y1);</span>

<span class="fc bfc" id="L2862" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2863">                return v1;</span>
            }

<span class="fc" id="L2866">            v2 = gsImg.getValue((int)x1, (int)y2);</span>

        } else {

            // interpolate over row y1
<span class="fc" id="L2871">            v1 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y1) +</span>
<span class="fc" id="L2872">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y1);</span>

<span class="fc bfc" id="L2874" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2875">                return v1;</span>
            }

            // interpolate over row y2
<span class="fc" id="L2879">            v2 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y2) +</span>
<span class="fc" id="L2880">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y2);</span>
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2884">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="fc" id="L2886">        return v;</span>
    }
    
    /**
     * NOT YET TESTED
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(Complex[][] img, float x, float y,
        boolean calcForReal) {

<span class="nc" id="L2901">        double x1 = Math.floor(x);</span>

<span class="nc" id="L2903">        double x2 = Math.ceil(x);</span>

<span class="nc" id="L2905">        double y1 = Math.floor(y);</span>

<span class="nc" id="L2907">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="nc bnc" id="L2911" title="All 2 branches missed.">        if (x1 == x2) {</span>

<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (calcForReal) {</span>
<span class="nc" id="L2914">                v1 = img[(int)x1][(int)y1].re();</span>
            } else {
<span class="nc" id="L2916">                v1 = img[(int)x1][(int)y1].im();</span>
            }

<span class="nc bnc" id="L2919" title="All 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L2920">                return v1;</span>
            }

<span class="nc bnc" id="L2923" title="All 2 branches missed.">            if (calcForReal) {</span>
<span class="nc" id="L2924">                v2 = img[(int)x1][(int)y].re();</span>
            } else {
<span class="nc" id="L2926">                v2 = img[(int)x1][(int)y].im();</span>
            }
        } else {

            double a, b;
<span class="nc bnc" id="L2931" title="All 2 branches missed.">            if (calcForReal) {</span>
<span class="nc" id="L2932">                a = img[(int)x1][(int)y1].re();</span>
<span class="nc" id="L2933">                b = img[(int)x2][(int)y1].re();</span>
            } else {
<span class="nc" id="L2935">                a = img[(int)x1][(int)y1].im();</span>
<span class="nc" id="L2936">                b = img[(int)x2][(int)y1].im();</span>
            }
            
            // interpolate over row y1
<span class="nc" id="L2940">            v1 = ((x2 - x)/(x2 - x1)) * a + ((x - x1)/(x2 - x1)) * b;</span>

<span class="nc bnc" id="L2942" title="All 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L2943">                return v1;</span>
            }

            double c, d;
<span class="nc bnc" id="L2947" title="All 2 branches missed.">            if (calcForReal) {</span>
<span class="nc" id="L2948">                c = img[(int)x1][(int)y2].re();</span>
<span class="nc" id="L2949">                d = img[(int)x2][(int)y2].re();</span>
            } else {
<span class="nc" id="L2951">                c = img[(int)x1][(int)y2].im();</span>
<span class="nc" id="L2952">                d = img[(int)x2][(int)y2].im();</span>
            }
            
            // interpolate over row y2
<span class="nc" id="L2956">            v2 = ((x2 - x)/(x2 - x1)) * c + ((x - x1)/(x2 - x1)) * d;</span>
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="nc" id="L2960">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="nc" id="L2962">        return v;</span>
    }
    
    /**
     * NOT YET TESTED
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(double[][] gsImg, float x, float y) {

<span class="nc" id="L2976">        double x1 = Math.floor(x);</span>

<span class="nc" id="L2978">        double x2 = Math.ceil(x);</span>

<span class="nc" id="L2980">        double y1 = Math.floor(y);</span>

<span class="nc" id="L2982">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="nc bnc" id="L2986" title="All 2 branches missed.">        if (x1 == x2) {</span>

<span class="nc" id="L2988">            v1 = gsImg[(int)x1][(int)y1];</span>

<span class="nc bnc" id="L2990" title="All 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L2991">                return v1;</span>
            }

<span class="nc" id="L2994">            v2 = gsImg[(int)x1][(int)y];</span>

        } else {

            // interpolate over row y1
<span class="nc" id="L2999">            v1 = ((x2 - x)/(x2 - x1)) * gsImg[(int)x1][(int)y1] +</span>
                ((x - x1)/(x2 - x1)) * gsImg[(int)x2][(int)y1];

<span class="nc bnc" id="L3002" title="All 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L3003">                return v1;</span>
            }

            // interpolate over row y2
<span class="nc" id="L3007">            v2 = ((x2 - x)/(x2 - x1)) * gsImg[(int)x1][(int)y2] +</span>
                ((x - x1)/(x2 - x1)) * gsImg[(int)x2][(int)y2];
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="nc" id="L3012">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="nc" id="L3014">        return v;</span>
    }

    /**
    NOT YET TESTED
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     *
     * @param x
     * @param y
     * @return
     */
    public double[] biLinearInterpolation(Image clrImg, float x, float y) {

<span class="fc" id="L3028">        double x1 = Math.floor(x);</span>

<span class="fc" id="L3030">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L3032">        double y1 = Math.floor(y);</span>

<span class="fc" id="L3034">        double y2 = Math.ceil(y);</span>

        double r1, r2, g1, g2, b1, b2;

<span class="fc bfc" id="L3038" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L3040">            r1 = clrImg.getR((int)x1, (int)y1);</span>
<span class="fc" id="L3041">            g1 = clrImg.getG((int)x1, (int)y1);</span>
<span class="fc" id="L3042">            b1 = clrImg.getB((int)x1, (int)y1);</span>

<span class="pc bpc" id="L3044" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="fc" id="L3045">                return new double[]{r1, g1, b1};</span>
            }

<span class="nc" id="L3048">            r2 = clrImg.getR((int)x1, (int)y2);</span>
<span class="nc" id="L3049">            g2 = clrImg.getG((int)x1, (int)y2);</span>
<span class="nc" id="L3050">            b2 = clrImg.getB((int)x1, (int)y2);</span>

        } else {

<span class="fc" id="L3054">            double v1X2Frac = ((x2 - x)/(x2 - x1));</span>
<span class="fc" id="L3055">            double v1X1Frac = ((x - x1)/(x2 - x1));</span>

            // interpolate over row y1
<span class="fc" id="L3058">            r1 = v1X2Frac * clrImg.getR((int)x1, (int)y1) +</span>
<span class="fc" id="L3059">                v1X1Frac * clrImg.getR((int)x2, (int)y1);</span>

<span class="fc" id="L3061">            g1 = v1X2Frac * clrImg.getG((int)x1, (int)y1) +</span>
<span class="fc" id="L3062">                v1X1Frac * clrImg.getG((int)x2, (int)y1);</span>

<span class="fc" id="L3064">            b1 = v1X2Frac * clrImg.getB((int)x1, (int)y1) +</span>
<span class="fc" id="L3065">                v1X1Frac * clrImg.getB((int)x2, (int)y1);</span>

<span class="pc bpc" id="L3067" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L3068">                return new double[]{r1, g1, b1};</span>
            }

            // interpolate over row y2
<span class="fc" id="L3072">            r2 = v1X2Frac * clrImg.getR((int)x1, (int)y2) +</span>
<span class="fc" id="L3073">                v1X1Frac * clrImg.getR((int)x2, (int)y2);</span>

<span class="fc" id="L3075">            g2 = v1X2Frac * clrImg.getG((int)x1, (int)y2) +</span>
<span class="fc" id="L3076">                v1X1Frac * clrImg.getG((int)x2, (int)y2);</span>

<span class="fc" id="L3078">            b2 = v1X2Frac * clrImg.getB((int)x1, (int)y2) +</span>
<span class="fc" id="L3079">                v1X1Frac * clrImg.getB((int)x2, (int)y2);</span>
        }

<span class="fc" id="L3082">        double v1Y2Frac = ((y2 - y)/(y2 - y1));</span>
<span class="fc" id="L3083">        double v1Y1Frac = ((y - y1)/(y2 - y1));</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3086">        double r = v1Y2Frac * r1 + v1Y1Frac * r2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3089">        double g = v1Y2Frac * g1 + v1Y1Frac * g2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3092">        double b = v1Y2Frac * b1 + v1Y1Frac * b2;</span>

<span class="fc" id="L3094">        return new double[]{r, g, b};</span>
    }

    public void applyAdaptiveMeanThresholding(GreyscaleImage img) {

<span class="nc" id="L3099">        applyAdaptiveMeanThresholding(img, 3);</span>
<span class="nc" id="L3100">    }</span>

    public void applyAdaptiveMeanThresholding(GreyscaleImage img,
        int halfDimension) {

<span class="fc" id="L3105">        GreyscaleImage imgM = img.copyImage();</span>

<span class="fc" id="L3107">        applyCenteredMean2(imgM, halfDimension);</span>

<span class="fc" id="L3109">        int c = 7;</span>

<span class="fc" id="L3111">        int foreground = 255;//1;</span>
<span class="fc" id="L3112">        int background = 0;</span>

<span class="fc bfc" id="L3114" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L3115" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L3116">                int v = img.getValue(i, j);</span>
<span class="fc" id="L3117">                int m = imgM.getValue(i, j);</span>
<span class="fc" id="L3118">                int t = m - c;</span>
<span class="fc bfc" id="L3119" title="All 2 branches covered.">                if (v &gt; t) {</span>
<span class="fc" id="L3120">                    img.setValue(i, j, foreground);</span>
                } else {
<span class="fc" id="L3122">                    img.setValue(i, j, background);</span>
                }
            }
        }

<span class="fc" id="L3127">        imgM = null;</span>

        //System.gc();
<span class="fc" id="L3130">    }</span>

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel.  The calculation starts at 0 and the end
     * dimension pixels are averaged using the decreasing number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for dimension = 2 becomes:
     * [11] [12] [12]
     * [11] [12] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels)
     * This can be used as part of adaptive mean thresholding.
     *
     * @param img
     * @param dimension
     */
    public void applyBoxcarMean(GreyscaleImage img, int dimension) {

<span class="pc bpc" id="L3153" title="2 of 4 branches missed.">        if ((img.getWidth() &lt; dimension) || (img.getHeight() &lt; dimension)) {</span>
<span class="nc" id="L3154">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }

        /*
        becomes efficient when dimension &gt; 3

        sum along columns first using dynamic programming:
        sumCol[j=0] = sum_j=0_to_dim of row[i]
        sumCol[j=1] = sumCol[0] - row[j-1] + row[dim + j - 1]
        sumCol[j=2] = sumCol[1] - row[j-1] + row[dim + j - 1]
        */

<span class="fc" id="L3167">        int w = img.getWidth();</span>
<span class="fc" id="L3168">        int h = img.getHeight();</span>

<span class="fc" id="L3170">        int[] mean = new int[img.getNPixels()];</span>

        // sum along rows
<span class="fc bfc" id="L3173" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3174">            int sum0 = 0;</span>
<span class="fc bfc" id="L3175" title="All 2 branches covered.">            for (int j = 0; j &lt; dimension; ++j) {</span>
<span class="fc" id="L3176">                sum0 += img.getValue(i, j);</span>
            }
<span class="fc" id="L3178">            mean[img.getInternalIndex(i, 0)] = sum0;</span>
<span class="fc bfc" id="L3179" title="All 2 branches covered.">            for (int j = 1; j &lt;= (h - dimension); ++j) {</span>
<span class="fc" id="L3180">                int vp = img.getValue(i, j - 1);</span>
<span class="fc" id="L3181">                int vl =  img.getValue(i, dimension + j - 1);</span>
<span class="fc" id="L3182">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3183">                mean[img.getInternalIndex(i, j)] = sum0;</span>
            }
            // last dimension - 1 rows: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L3186" title="All 2 branches covered.">            for (int j = (h - dimension + 1); j &lt; h; ++j) {</span>
<span class="fc" id="L3187">                float count = h - j;</span>
<span class="fc" id="L3188">                float sum = 0;</span>
<span class="fc bfc" id="L3189" title="All 2 branches covered.">                for (int k = j; k &lt; h; ++k) {</span>
<span class="fc" id="L3190">                    sum += img.getValue(i, k);</span>
                }
<span class="fc" id="L3192">                sum /= count;</span>
<span class="fc" id="L3193">                sum *= dimension;</span>
<span class="fc" id="L3194">                mean[img.getInternalIndex(i, j)] = Math.round(sum);</span>
            }
        }

<span class="fc" id="L3198">        int[] mean2 = new int[img.getNPixels()];</span>

        // sum along columns
<span class="fc bfc" id="L3201" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3202">            int sum0 = 0;</span>
<span class="fc bfc" id="L3203" title="All 2 branches covered.">            for (int i = 0; i &lt; dimension; ++i) {</span>
<span class="fc" id="L3204">                sum0 += mean[img.getInternalIndex(i, j)];</span>
            }
<span class="fc" id="L3206">            mean2[img.getInternalIndex(0, j)] = sum0;</span>
<span class="fc bfc" id="L3207" title="All 2 branches covered.">            for (int i = 1; i &lt;= (w - dimension); ++i) {</span>
<span class="fc" id="L3208">                int vp = mean[img.getInternalIndex(i - 1, j)];</span>
<span class="fc" id="L3209">                int vl = mean[img.getInternalIndex(dimension + i - 1, j)];</span>
<span class="fc" id="L3210">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3211">                mean2[img.getInternalIndex(i, j)] = sum0;</span>
            }

            // last dimension - 1 cols: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L3215" title="All 2 branches covered.">            for (int i = (w - dimension + 1); i &lt; w; ++i) {</span>
<span class="fc" id="L3216">                float count = h - i;</span>
<span class="fc" id="L3217">                float sum = 0;</span>
<span class="fc bfc" id="L3218" title="All 2 branches covered.">                for (int k = i; k &lt; w; ++k) {</span>
<span class="fc" id="L3219">                    sum += mean[img.getInternalIndex(k, j)];</span>
                }
<span class="fc" id="L3221">                sum /= count;</span>
<span class="fc" id="L3222">                sum *= dimension;</span>
<span class="fc" id="L3223">                mean2[img.getInternalIndex(i, j)] = Math.round(sum);</span>
            }
        }

        // divide each value by dimension * dimension
<span class="fc" id="L3228">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3229" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3230" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3231">                int v = mean2[img.getInternalIndex(i, j)];</span>
<span class="fc" id="L3232">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3233">                img.setValue(i, j, v);</span>
            }
        }
<span class="fc" id="L3236">    }</span>
    
    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a decreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels) and never more than
     * 4 times O(N_pixels).
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean2(GreyscaleImage img, int halfDimension) {

<span class="fc" id="L3260">        SummedAreaTable sumTable = new SummedAreaTable();</span>
        
<span class="fc" id="L3262">        GreyscaleImage imgS = sumTable.createAbsoluteSummedAreaTable(img);</span>
        
<span class="fc" id="L3264">        imgS = sumTable.applyMeanOfWindowFromSummedAreaTable(imgS, </span>
            2*halfDimension + 1);
        
<span class="fc" id="L3267">        img.resetTo(imgS);</span>
<span class="fc" id="L3268">    }</span>

    public double[][] createUnitStandardDeviation(GreyscaleImage img, int halfDimension) {

<span class="nc" id="L3272">        SummedAreaTable sumTable = new SummedAreaTable();</span>
        
<span class="nc" id="L3274">        GreyscaleImage imgM = sumTable.createAbsoluteSummedAreaTable(img);</span>
<span class="nc" id="L3275">        imgM = sumTable.applyMeanOfWindowFromSummedAreaTable(imgM, </span>
            2*halfDimension + 1);
         
<span class="nc" id="L3278">        int w = img.getWidth();</span>
<span class="nc" id="L3279">        int h = img.getHeight();</span>
<span class="nc" id="L3280">        double[][] out = new double[w][];</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc" id="L3282">            out[i] = new double[h];</span>
<span class="nc bnc" id="L3283" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L3284">                int m = imgM.getValue(i, j);</span>
<span class="nc" id="L3285">                double v = img.getValue(i, j) - m;</span>
<span class="nc bnc" id="L3286" title="All 2 branches missed.">                if (m == 0) {</span>
<span class="nc" id="L3287">                    v = 0;</span>
                } else {
<span class="nc" id="L3289">                    v = v / (Math.sqrt(2)/m);</span>
                }
<span class="nc" id="L3291">                out[i][j] = v;</span>
            }
        }
       
<span class="nc" id="L3295">        return out;</span>
    }
    
    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a decreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels) and never more than
     * 4 times O(N_pixels).
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean2(double[][] img, int halfDimension) {

<span class="fc" id="L3320">        SummedAreaTable sumTable = new SummedAreaTable();</span>
        
<span class="fc" id="L3322">        double[][] imgS = sumTable.createAbsoluteSummedAreaTable(img);</span>
        
<span class="fc" id="L3324">        imgS = sumTable.applyMeanOfWindowFromSummedAreaTable(imgS, </span>
            2*halfDimension + 1);
        
<span class="fc bfc" id="L3327" title="All 2 branches covered.">        for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="fc" id="L3328">            System.arraycopy(imgS[i], 0, img[i], 0, imgS[i].length);</span>
        }
<span class="fc" id="L3330">    }</span>
    
    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a decreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels), but is also dependent upon 
     * halfDimension.  Prefer to use applyCenteredMean2 which is always
     * less than 4 times O(N) in runtime complexity.
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean(GreyscaleImage img, int halfDimension) {

<span class="pc bpc" id="L3355" title="1 of 2 branches missed.">        if ((img.getWidth() &lt; 2*halfDimension) ||</span>
<span class="pc bpc" id="L3356" title="1 of 2 branches missed.">            (img.getHeight() &lt; 2*halfDimension)) {</span>
<span class="nc" id="L3357">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }
        
        /*
        becomes efficient when halfDimension &gt; 1

        sum along columns first using dynamic programming, then rows
        */

<span class="fc" id="L3367">        int dimension = 2*halfDimension + 1;</span>

<span class="fc" id="L3369">        int w = img.getWidth();</span>
<span class="fc" id="L3370">        int h = img.getHeight();</span>

<span class="fc" id="L3372">        int[] mean = new int[img.getNPixels()];</span>

<span class="fc" id="L3374">        int[] imgValues = img.getValues();</span>

        // sum along rows
<span class="fc bfc" id="L3377" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>

            /* pixels before halfDimension
            halfDimension = 2
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3384" title="All 2 branches covered.">            for (int j = 0; j &lt; halfDimension; ++j) {</span>
<span class="fc" id="L3385">                float count = halfDimension - j;</span>
<span class="fc" id="L3386">                float sum = 0;</span>
<span class="fc bfc" id="L3387" title="All 2 branches covered.">                for (int k = j; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3388">                    int pixIdx = img.getIndex(i, k);</span>
<span class="fc" id="L3389">                    sum += imgValues[pixIdx];</span>
                }
<span class="fc" id="L3391">                sum /= count;</span>
<span class="fc" id="L3392">                sum *= dimension;</span>
<span class="fc" id="L3393">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3394">                mean[pixIdx] = Math.round(sum);</span>
            }

            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3403">            int sum0 = 0;</span>
<span class="fc bfc" id="L3404" title="All 2 branches covered.">            for (int j = 0; j &lt;= 2*halfDimension; ++j) {</span>
<span class="fc" id="L3405">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3406">                sum0 += imgValues[pixIdx];</span>
            }
<span class="fc" id="L3408">            int pixIdx = img.getIndex(i, halfDimension);</span>
<span class="fc" id="L3409">            mean[pixIdx] = sum0;</span>
            /*
            halfDimension = 2
            0 1 2 3 4 5 6
              |   *   |
                |   *   |

            */
<span class="fc bfc" id="L3417" title="All 2 branches covered.">            for (int j = halfDimension + 1; j &lt; (h - halfDimension); ++j) {</span>
<span class="fc" id="L3418">                pixIdx = img.getIndex(i, j - halfDimension - 1);</span>
<span class="fc" id="L3419">                int vp = imgValues[pixIdx];</span>
<span class="fc" id="L3420">                pixIdx = img.getIndex(i, j + halfDimension);</span>
<span class="fc" id="L3421">                int vl =  imgValues[pixIdx];</span>
<span class="fc" id="L3422">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3423">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3424">                mean[pixIdx] = sum0;</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2
                &gt;
            */
<span class="fc bfc" id="L3430" title="All 2 branches covered.">            for (int j = (h - halfDimension); j &lt; h; ++j) {</span>
<span class="fc" id="L3431">                float count = h - j + 1;</span>
<span class="fc" id="L3432">                float sum = 0;</span>
<span class="fc bfc" id="L3433" title="All 2 branches covered.">                for (int k = (j - 1); k &lt; h; ++k) {</span>
<span class="fc" id="L3434">                    pixIdx = img.getIndex(i, k);</span>
<span class="fc" id="L3435">                    sum +=  imgValues[pixIdx];</span>
                }
<span class="fc" id="L3437">                sum /= count;</span>
<span class="fc" id="L3438">                sum *= dimension;</span>
<span class="fc" id="L3439">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3440">                mean[pixIdx] = Math.round(sum);</span>
            }
        }

        // sum along columns
<span class="fc bfc" id="L3445" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>

            /* pixels before halfDimension
            halfDimension = 2
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3452" title="All 2 branches covered.">            for (int i = 0; i &lt; halfDimension; ++i) {</span>
<span class="fc" id="L3453">                float count = halfDimension - i;</span>
<span class="fc" id="L3454">                float sum = 0;</span>
<span class="fc bfc" id="L3455" title="All 2 branches covered.">                for (int k = i; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3456">                    int pixIdx = img.getIndex(k, j);</span>
<span class="fc" id="L3457">                    sum += mean[pixIdx];</span>
                }
<span class="fc" id="L3459">                sum /= count;</span>
<span class="fc" id="L3460">                sum *= dimension;</span>
<span class="fc" id="L3461">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3462">                imgValues[pixIdx] =  Math.round(sum);</span>
            }

            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3471">            int sum0 = 0;</span>
<span class="fc bfc" id="L3472" title="All 2 branches covered.">            for (int i = 0; i &lt;= 2*halfDimension; ++i) {</span>
<span class="fc" id="L3473">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3474">                sum0 += mean[pixIdx];</span>
            }
<span class="fc" id="L3476">            int pixIdx = img.getIndex(halfDimension, j);</span>
<span class="fc" id="L3477">            imgValues[pixIdx] = sum0;</span>
            /*
            halfDimension = 2
            0 1 2 3 4 5 6
              |   *   |
                |   *   |

            */
<span class="fc bfc" id="L3485" title="All 2 branches covered.">            for (int i = halfDimension + 1; i &lt; (w - halfDimension); ++i) {</span>
<span class="fc" id="L3486">                pixIdx = img.getIndex(i - halfDimension - 1, j);</span>
<span class="fc" id="L3487">                int vp = mean[pixIdx];</span>
<span class="fc" id="L3488">                pixIdx = img.getIndex(i + halfDimension, j);</span>
<span class="fc" id="L3489">                int vl =  mean[pixIdx];</span>
<span class="fc" id="L3490">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3491">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3492">                imgValues[pixIdx] = sum0;</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2
                &gt;
            */
<span class="fc bfc" id="L3498" title="All 2 branches covered.">            for (int i = (w - halfDimension); i &lt; w; ++i) {</span>
<span class="fc" id="L3499">                float count = w - i + 1;</span>
<span class="fc" id="L3500">                float sum = 0;</span>
<span class="fc bfc" id="L3501" title="All 2 branches covered.">                for (int k = (i - 1); k &lt; w; ++k) {</span>
<span class="fc" id="L3502">                    pixIdx = img.getIndex(k, j);</span>
<span class="fc" id="L3503">                    sum += mean[pixIdx];</span>
                }
<span class="fc" id="L3505">                sum /= count;</span>
<span class="fc" id="L3506">                sum *= dimension;</span>
<span class="fc" id="L3507">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3508">                imgValues[pixIdx] = Math.round(sum);</span>
            }
        }

<span class="fc" id="L3512">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3513" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3514" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3515">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3516">                int v = imgValues[pixIdx];</span>
<span class="fc" id="L3517">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3518">                imgValues[pixIdx] = v;</span>
            }
        }
<span class="fc bfc" id="L3521" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L3522">            img.setValue(i, imgValues[i]);</span>
        }
<span class="fc" id="L3524">    }</span>

    public Set&lt;PairInt&gt; extract2ndDerivPoints(GreyscaleImage img,
        Set&lt;PairInt&gt; filterToPoints, int nApprox) {
        
<span class="nc" id="L3529">        Set&lt;PairInt&gt; set = extract2ndDerivPoints(img, nApprox, true);</span>
        
<span class="nc" id="L3531">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L3533" title="All 2 branches missed.">        for (PairInt p : filterToPoints) {</span>
<span class="nc bnc" id="L3534" title="All 2 branches missed.">            if (set.contains(p)) {</span>
<span class="nc" id="L3535">                output.add(p);</span>
            }
<span class="nc" id="L3537">        }</span>
        
<span class="nc" id="L3539">        return output;</span>
    }

    public Set&lt;PairInt&gt; extract2ndDerivPoints(GreyscaleImage img) {

<span class="nc" id="L3544">        GreyscaleImage gsImg = img.copyImage();</span>

<span class="nc" id="L3546">        applySecondDerivGaussian(gsImg, SIGMA.ONE, 0, 255);</span>

<span class="nc" id="L3548">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(gsImg);</span>
<span class="nc" id="L3549">        int v0 = 0;</span>
<span class="nc" id="L3550">        int c0 = 0;</span>
<span class="nc" id="L3551">        int v1 = 0;</span>
<span class="nc" id="L3552">        int c1 = 0;</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">        for (int i = (valueCounts.getN() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L3554">            int v = valueCounts.getX(i);</span>
<span class="nc" id="L3555">            int c = valueCounts.getY(i);</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">            if (v0 == 0) {</span>
<span class="nc bnc" id="L3557" title="All 2 branches missed.">                if (c &gt; 12) {</span>
<span class="nc" id="L3558">                    v0 = v;</span>
<span class="nc" id="L3559">                    c0 = c;</span>
                }
<span class="nc bnc" id="L3561" title="All 2 branches missed.">            } else if (c &lt; (2.5 * c0)) {</span>
<span class="nc" id="L3562">                v1 = v;</span>
<span class="nc" id="L3563">                c1 = c;</span>
            } else {
                break;
            }
        }

<span class="nc" id="L3569">        Set&lt;PairInt&gt; pixels = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">        for (int i = 0; i &lt; gsImg.getNPixels(); ++i) {</span>
<span class="nc" id="L3571">            int v = gsImg.getValue(i);</span>
<span class="nc" id="L3572">            int x = gsImg.getCol(i);</span>
<span class="nc" id="L3573">            int y = gsImg.getRow(i);</span>
<span class="nc bnc" id="L3574" title="All 2 branches missed.">            if (v &gt;= v1) {</span>
<span class="nc" id="L3575">                pixels.add(new PairInt(x, y));</span>
            }
        }

<span class="nc" id="L3579">        log.info(&quot;before nPoints=&quot; + pixels.size());</span>

<span class="nc" id="L3581">        reduceTo4NeighborCentroids(pixels);</span>

<span class="nc" id="L3583">        log.info(&quot;after nPoints=&quot; + pixels.size());</span>

<span class="nc" id="L3585">        return pixels;</span>
    }

    /**
     * NOT READY FOR USE YET
     * extract the high value points in the second derivative gaussian of
     * img to a number of points less than or equal to maxNPoints and
     * if the variable reduceForNoise is true, then look for patterns
     * of noise and reduce the maximum value extracted from the 2nd deriv
     * points until no noise patterns are seen.
     * @param img
     * @param maxNPoints
     * @param reduceForNoise
     * @return
     */
    public Set&lt;PairInt&gt; extract2ndDerivPoints(GreyscaleImage img, int maxNPoints,
        boolean reduceForNoise) {

<span class="nc" id="L3603">        GreyscaleImage gsImg = img.copyImage();</span>

<span class="nc" id="L3605">        applySecondDerivGaussian(gsImg, SIGMA.ONE, 0, 255);</span>

<span class="nc" id="L3607">        PairIntArray valueCounts = </span>
<span class="nc" id="L3608">            Histogram.createADescendingSortByKeyArray(gsImg);</span>
<span class="nc" id="L3609">        int nTot = 0;</span>
<span class="nc" id="L3610">        int v1 = -1;</span>
<span class="nc bnc" id="L3611" title="All 2 branches missed.">        for (int i = 0; i &lt; valueCounts.getN(); ++i) {</span>
<span class="nc" id="L3612">            int c = valueCounts.getY(i);</span>
<span class="nc" id="L3613">            int nTmp = nTot + c;</span>
<span class="nc bnc" id="L3614" title="All 2 branches missed.">            if (nTmp &lt; maxNPoints) {</span>
<span class="nc" id="L3615">                nTot += c;</span>
<span class="nc" id="L3616">                v1 = valueCounts.getX(i);</span>
            } else {
<span class="nc bnc" id="L3618" title="All 2 branches missed.">                if (v1 == -1) {</span>
<span class="nc" id="L3619">                    v1 = valueCounts.getX(i);</span>
                }
                break;
            }
        }

<span class="nc" id="L3625">        int w = gsImg.getWidth();</span>
<span class="nc" id="L3626">        int h = gsImg.getHeight();</span>

<span class="nc" id="L3628">        Set&lt;PairInt&gt; pixels = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">        for (int i = 0; i &lt; gsImg.getNPixels(); ++i) {</span>
<span class="nc" id="L3630">            int v = gsImg.getValue(i);</span>
<span class="nc bnc" id="L3631" title="All 2 branches missed.">            if (v &gt;= v1) {</span>
<span class="nc" id="L3632">                int x = gsImg.getCol(i);</span>
<span class="nc" id="L3633">                int y = gsImg.getRow(i);</span>

                // avoid points on image boundaries
<span class="nc bnc" id="L3636" title="All 8 branches missed.">                if (x == 0 || y == 0 || (x &gt; (w - 1)) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L3637">                    continue;</span>
                }
<span class="nc" id="L3639">                pixels.add(new PairInt(x, y));</span>
            }
        }

<span class="nc" id="L3643">        log.info(&quot;before nPoints=&quot; + pixels.size());</span>

<span class="nc" id="L3645">        reduceTo4NeighborCentroids(pixels);</span>

<span class="nc" id="L3647">        log.info(&quot;after nPoints=&quot; + pixels.size());</span>

<span class="nc bnc" id="L3649" title="All 2 branches missed.">        if (reduceForNoise) {</span>
            // look for patterns of noise and reduce v1 until not present
        }

<span class="nc" id="L3653">        return pixels;</span>
    }
    
    /**
     * NOT READY FOR USE YET
     * extract the high value points in the second derivative gaussian of
     * img to a number of points less than or equal to maxNPoints and
     * if the variable reduceForNoise is true, then look for patterns
     * of noise and reduce the maximum value extracted from the 2nd deriv
     * points until no noise patterns are seen.
     * @param img
     * @param labels labels for segmented regions for which
     * the maximum number of points are applied to limit the
     * total number returned.
     * @param maxNPoints
     * @param reduceForNoise
     * @return
     */
    public List&lt;Set&lt;PairInt&gt;&gt; extract2ndDerivPoints(
        GreyscaleImage img, int[] labels, int maxNPoints,
        boolean reduceForNoise) {

<span class="nc" id="L3675">        int[] secondDerivs = </span>
<span class="nc" id="L3676">            performSecondDerivGaussian(img, SIGMA.ONE);</span>
<span class="nc bnc" id="L3677" title="All 2 branches missed.">        for (int idx = 0; idx &lt; secondDerivs.length; ++idx) {</span>
<span class="nc bnc" id="L3678" title="All 2 branches missed.">            if (secondDerivs[idx] &lt; 0) {</span>
<span class="nc" id="L3679">                secondDerivs[idx] *= -1;</span>
            }
        }
        
<span class="nc" id="L3683">        TIntObjectMap&lt;TIntSet&gt; labelMap </span>
            = new TIntObjectHashMap&lt;TIntSet&gt;();
<span class="nc bnc" id="L3685" title="All 2 branches missed.">        for (int pixIdx = 0; pixIdx &lt; labels.length; ++pixIdx) {</span>
<span class="nc" id="L3686">            int label = labels[pixIdx];</span>
<span class="nc" id="L3687">            TIntSet set = labelMap.get(label);</span>
<span class="nc bnc" id="L3688" title="All 2 branches missed.">            if (set == null) {</span>
<span class="nc" id="L3689">                set = new TIntHashSet();</span>
<span class="nc" id="L3690">                labelMap.put(label, set);</span>
            }
<span class="nc" id="L3692">            set.add(pixIdx);</span>
        }
        
<span class="nc" id="L3695">        List&lt;Set&lt;PairInt&gt;&gt; output = new ArrayList&lt;Set&lt;PairInt&gt;&gt; ();</span>
        
<span class="nc" id="L3697">        TIntObjectIterator&lt;TIntSet&gt; iter = labelMap.iterator();</span>
        
<span class="nc bnc" id="L3699" title="All 2 branches missed.">        for (int ii = labelMap.size(); ii-- &gt; 0;) {</span>

<span class="nc" id="L3701">            iter.advance();</span>
            
<span class="nc" id="L3703">            int label = iter.key();</span>
            
<span class="nc" id="L3705">            TIntSet indexes = iter.value();</span>
<span class="nc" id="L3706">            PairIntArray valueCounts = </span>
<span class="nc" id="L3707">                Histogram.createADescendingSortByKeyArray(</span>
                indexes, secondDerivs);
                    
<span class="nc" id="L3710">            int nTot = 0;</span>
<span class="nc" id="L3711">            int v1 = -1;</span>
<span class="nc bnc" id="L3712" title="All 2 branches missed.">            for (int i = 0; i &lt; valueCounts.getN(); ++i) {</span>
<span class="nc" id="L3713">                int c = valueCounts.getY(i);</span>
<span class="nc" id="L3714">                int nTmp = nTot + c;</span>
<span class="nc bnc" id="L3715" title="All 2 branches missed.">                if (nTmp &lt; maxNPoints) {</span>
<span class="nc" id="L3716">                    nTot += c;</span>
<span class="nc" id="L3717">                    v1 = valueCounts.getX(i);</span>
                } else {
<span class="nc bnc" id="L3719" title="All 2 branches missed.">                    if (v1 == -1) {</span>
<span class="nc" id="L3720">                        v1 = valueCounts.getX(i);</span>
                    }
                    break;
                }
            }

<span class="nc" id="L3726">            int w = img.getWidth();</span>
<span class="nc" id="L3727">            int h = img.getHeight();</span>

<span class="nc" id="L3729">            Set&lt;PairInt&gt; pixels = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L3730">            TIntIterator iter2 = indexes.iterator();</span>
<span class="nc bnc" id="L3731" title="All 2 branches missed.">            while (iter2.hasNext()) {</span>
                
<span class="nc" id="L3733">                int idx = iter2.next();</span>
                
<span class="nc" id="L3735">                int v = secondDerivs[idx];</span>
                
<span class="nc" id="L3737">                int x = img.getCol(idx);</span>
<span class="nc" id="L3738">                int y = img.getRow(idx);</span>
<span class="nc" id="L3739">                PairInt p = new PairInt(x, y);</span>
                
<span class="nc bnc" id="L3741" title="All 2 branches missed.">                if (v &gt;= v1) {</span>
                    // avoid points on image boundaries
<span class="nc bnc" id="L3743" title="All 8 branches missed.">                    if (x == 0 || y == 0 || (x &gt; (w - 1)) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L3744">                        continue;</span>
                    }
<span class="nc" id="L3746">                    pixels.add(p);</span>
                }
<span class="nc" id="L3748">            }</span>

<span class="nc" id="L3750">            log.info(&quot;before nPoints=&quot; + pixels.size());</span>

<span class="nc" id="L3752">            reduceTo4NeighborCentroids(pixels);</span>

<span class="nc" id="L3754">            log.info(&quot;after nPoints=&quot; + pixels.size());</span>
            
<span class="nc" id="L3756">            output.add(pixels);</span>
<span class="nc" id="L3757">        }</span>

<span class="nc bnc" id="L3759" title="All 2 branches missed.">        if (reduceForNoise) {</span>
            // look for patterns of noise and reduce v1 until not present
        }

<span class="nc" id="L3763">        return output;</span>
    }

    private void reduceTo4NeighborCentroids(Set&lt;PairInt&gt; pixels) {

<span class="nc" id="L3768">        Set&lt;PairInt&gt; processed = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L3770">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>

<span class="nc" id="L3772">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="nc" id="L3774">        int[] dxs = Misc.dx4;</span>
<span class="nc" id="L3775">        int[] dys = Misc.dy4;</span>

<span class="nc" id="L3777">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L3779" title="All 2 branches missed.">        for (PairInt p : pixels) {</span>

<span class="nc bnc" id="L3781" title="All 2 branches missed.">            if (processed.contains(p)) {</span>
<span class="nc" id="L3782">                continue;</span>
            }

<span class="nc" id="L3785">            curveHelper.findNeighbors(p.getX(), p.getY(), pixels, processed,</span>
                dxs, dys, neighbors);

<span class="nc" id="L3788">            processed.add(p);</span>
<span class="nc" id="L3789">            processed.addAll(neighbors);</span>

<span class="nc bnc" id="L3791" title="All 2 branches missed.">            if (neighbors.size() == 0) {</span>
<span class="nc" id="L3792">                output.add(p);</span>
            } else {
<span class="nc" id="L3794">                double[] xyCen = curveHelper.calculateXYCentroids(neighbors);</span>
<span class="nc" id="L3795">                int x = (int)Math.round(xyCen[0]);</span>
<span class="nc" id="L3796">                int y = (int)Math.round(xyCen[1]);</span>
<span class="nc bnc" id="L3797" title="All 4 branches missed.">                assert(Math.abs(x - p.getX()) &lt;= 2);</span>
<span class="nc bnc" id="L3798" title="All 4 branches missed.">                assert(Math.abs(y - p.getY()) &lt;= 2);</span>
<span class="nc" id="L3799">                output.add(new PairInt(x, y));</span>
            }
<span class="nc" id="L3801">        }</span>

<span class="nc" id="L3803">        pixels.clear();</span>
<span class="nc" id="L3804">        pixels.addAll(output);</span>

<span class="nc" id="L3806">    }</span>

    public Complex1D[] convertToComplex1D(Complex[][] input) {
        
<span class="fc" id="L3810">        int n0 = input.length;</span>
<span class="fc" id="L3811">        int n1 = input[0].length;</span>
        
<span class="fc" id="L3813">        Complex1D[] output = new Complex1D[n0];</span>
<span class="fc bfc" id="L3814" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L3815">            output[i] = new Complex1D();</span>
<span class="fc" id="L3816">            output[i].x = new double[n1];</span>
<span class="fc" id="L3817">            output[i].y = new double[n1];</span>
<span class="fc bfc" id="L3818" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L3819">                output[i].x[j] = input[i][j].re();</span>
<span class="fc" id="L3820">                output[i].y[j] = input[i][j].im();</span>
            }
        }
        
<span class="fc" id="L3824">        return output;</span>
    }

    public Complex[][] copy(Complex[][] input) {
        
<span class="fc" id="L3829">        int n0 = input.length;</span>
        
<span class="fc" id="L3831">        Complex[][] output = new Complex[n0][];</span>
<span class="fc bfc" id="L3832" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L3833">            output[i] = Arrays.copyOf(input[i], input[i].length);</span>
        }
        
<span class="fc" id="L3836">        return output;</span>
    }

    public double[][] copy(double[][] input) {
        
<span class="fc" id="L3841">        int n0 = input.length;</span>
        
<span class="fc" id="L3843">        double[][] output = new double[n0][];</span>
<span class="fc bfc" id="L3844" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L3845">            output[i] = Arrays.copyOf(input[i], input[i].length);</span>
        }
        
<span class="fc" id="L3848">        return output;</span>
    }
    
    /**
     * output is column major format
     * @param input
     * @return 
     */
    public double[][] copy(GreyscaleImage input) {
        
<span class="nc" id="L3858">        int n0 = input.getNPixels();</span>
<span class="nc" id="L3859">        int w = input.getWidth();</span>
<span class="nc" id="L3860">        int h = input.getHeight();</span>
        
<span class="nc" id="L3862">        double[][] output = new double[w][h];</span>
<span class="nc bnc" id="L3863" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc" id="L3864">            output[i] = new double[h];</span>
<span class="nc bnc" id="L3865" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L3866">                output[i][j] = input.getValue(i, j);</span>
            }
        }
        
<span class="nc" id="L3870">        return output;</span>
    }
    
    /**
     * output is row major format
     * @param input
     * @return 
     */
    public float[][] copyToRowMajor(GreyscaleImage input) {
        
<span class="fc" id="L3880">        int n0 = input.getNPixels();</span>
<span class="fc" id="L3881">        int h = input.getWidth();</span>
<span class="fc" id="L3882">        int w = input.getHeight();</span>
        
<span class="fc" id="L3884">        float[][] output = new float[w][h];</span>
<span class="fc bfc" id="L3885" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3886">            output[i] = new float[h];</span>
<span class="fc bfc" id="L3887" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3888">                output[i][j] = input.getValue(j, i);</span>
            }
        }
        
<span class="fc" id="L3892">        return output;</span>
    }
    
    public Complex[][] convertToComplex(Complex1D[] input) {
        
<span class="fc" id="L3897">        int n0 = input.length;</span>
<span class="fc" id="L3898">        int n1 = input[0].x.length;</span>
            
<span class="fc" id="L3900">        Complex[][] output = new Complex[n0][];</span>
<span class="fc bfc" id="L3901" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L3902">            output[i] = new Complex[n1];</span>
<span class="fc bfc" id="L3903" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L3904">                output[i][j] = new Complex(input[i].x[j], input[i].y[j]);</span>
            }
        }
        
<span class="fc" id="L3908">        return output;</span>
    }

    /**
     * convolve (x, y) with 1D kernel using sparseValueMap, but user must assert
     * that (x,y) += half kernel size is all contained within the sparseValueMap
     * because no approximations are made when a value is not in the map
     * and the results will not be normalized correctly.
     * 
     * @param sparseValueMap
     * @param x
     * @param y
     * @param kernel
     * @param calcX if true, convolve for x, else for y
     * @return 
     */
    public float convolve1D(Map&lt;PairInt, ? extends Number&gt; sparseValueMap, int x, int y, 
        float[] kernel, boolean calcX) {
        
<span class="nc" id="L3927">        int h = (kernel.length - 1) &gt;&gt; 1;</span>
        
<span class="nc" id="L3929">        float sum = 0;</span>
<span class="nc bnc" id="L3930" title="All 2 branches missed.">        for (int g = 0; g &lt; kernel.length; g++) {</span>
<span class="nc" id="L3931">            float gg = kernel[g];</span>
<span class="nc bnc" id="L3932" title="All 2 branches missed.">            if (gg == 0) {</span>
<span class="nc" id="L3933">                continue;</span>
            }
            int x2, y2;
<span class="nc bnc" id="L3936" title="All 2 branches missed.">            if (calcX) {</span>
<span class="nc" id="L3937">                x2 = x + g - h;</span>
<span class="nc" id="L3938">                y2 = y;</span>
            } else {
<span class="nc" id="L3940">                y2 = y + g - h;</span>
<span class="nc" id="L3941">                x2 = x;</span>
            }
            
<span class="nc" id="L3944">            Number v = sparseValueMap.get(new PairInt(x2, y2));</span>
            
<span class="nc bnc" id="L3946" title="All 2 branches missed.">            if (v == null) {</span>
<span class="nc" id="L3947">                throw new IllegalArgumentException(</span>
                    &quot;x,y += half kernel length is not in map&quot;);
            }
              
<span class="nc" id="L3951">            sum += (gg * v.floatValue());</span>
        }
        
<span class="nc" id="L3954">        return sum;</span>
    }
    
    public TIntObjectMap&lt;TIntSet&gt; unbin(
        TIntObjectMap&lt;TIntSet&gt; binnedMap,
        int binFactor, int binnedWidth, int binnedHeight,
        int resultWidth, int resultHeight) {
        
<span class="nc bnc" id="L3962" title="All 2 branches missed.">        if (binnedMap == null) {</span>
<span class="nc" id="L3963">            throw new IllegalArgumentException(</span>
            &quot;binnedMap cannot be null&quot;);
        }

<span class="nc" id="L3967">        TIntObjectMap&lt;TIntSet&gt; output </span>
            = new TIntObjectHashMap&lt;TIntSet&gt;(
<span class="nc" id="L3969">            binnedMap.size() * binFactor);</span>

<span class="nc" id="L3971">        int w0 = binnedWidth;</span>
<span class="nc" id="L3972">        int h0 = binnedHeight;</span>
        
<span class="nc" id="L3974">        int w1 = resultWidth;</span>
<span class="nc" id="L3975">        int h1 = resultHeight;</span>
        
<span class="nc" id="L3977">        TIntObjectIterator&lt;TIntSet&gt; iter =</span>
<span class="nc" id="L3978">            binnedMap.iterator();</span>
        
<span class="nc bnc" id="L3980" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; binnedMap.size(); ++lIdx) {</span>
            
<span class="nc" id="L3982">            iter.advance();</span>
            
<span class="nc" id="L3984">            TIntSet p0 = iter.value();</span>
<span class="nc" id="L3985">            TIntSet pOut = new TIntHashSet(p0.size() * binFactor);</span>
<span class="nc" id="L3986">            output.put(iter.key(), pOut);</span>
            
<span class="nc" id="L3988">            TIntIterator iter2 = p0.iterator();</span>
<span class="nc bnc" id="L3989" title="All 2 branches missed.">            while (iter2.hasNext()) {</span>
<span class="nc" id="L3990">                int pixIdx = iter2.next();</span>
<span class="nc" id="L3991">                int j = pixIdx/w0;</span>
<span class="nc" id="L3992">                int i = pixIdx - (j * w0);</span>
<span class="nc" id="L3993">                int stop1 = ((i + 1)*binFactor);</span>
<span class="nc bnc" id="L3994" title="All 2 branches missed.">                if (stop1 &gt; (w1 - 1)) {</span>
<span class="nc" id="L3995">                    stop1 = w1;</span>
                }
<span class="nc bnc" id="L3997" title="All 2 branches missed.">                for (int ii = (i*binFactor); ii &lt; stop1; ii++) {</span>
<span class="nc" id="L3998">                    int stop2 = ((j + 1)*binFactor);</span>
<span class="nc bnc" id="L3999" title="All 2 branches missed.">                    if (stop2 &gt; (h1 - 1)) {</span>
<span class="nc" id="L4000">                        stop2 = h1;</span>
                    }
<span class="nc bnc" id="L4002" title="All 2 branches missed.">                    for (int jj = (j*binFactor); jj &lt; stop2; jj++) {</span>
<span class="nc" id="L4003">                        int pixIdx2 = (jj * w1) + ii;</span>
<span class="nc" id="L4004">                        pOut.add(pixIdx2);</span>
                    }
<span class="nc bnc" id="L4006" title="All 2 branches missed.">                    if (j == (h0 - 1)) {</span>
                        // just in case excess unset past binFactor
<span class="nc bnc" id="L4008" title="All 2 branches missed.">                        for (int jj = stop2; jj &lt; h1; jj++) {</span>
<span class="nc" id="L4009">                            int pixIdx2 = (jj * w1) + ii;</span>
<span class="nc" id="L4010">                            pOut.add(pixIdx2);</span>
                        }
                    }
                }
<span class="nc bnc" id="L4014" title="All 2 branches missed.">                if (i == (w0 - 1)) {</span>
                    // just in case excess unset past binFastor
<span class="nc bnc" id="L4016" title="All 2 branches missed.">                    for (int ii = stop1; ii &lt; w1; ii++) {</span>
<span class="nc" id="L4017">                        int stop2 = ((j + 1)*binFactor);</span>
<span class="nc bnc" id="L4018" title="All 2 branches missed.">                        if (stop2 &gt; (h1 - 1)) {</span>
<span class="nc" id="L4019">                            stop2 = h1;</span>
                        }
<span class="nc bnc" id="L4021" title="All 2 branches missed.">                        for (int jj = (j*binFactor); jj &lt; stop2; jj++) {</span>
<span class="nc" id="L4022">                            int pixIdx2 = (jj * w1) + ii;</span>
<span class="nc" id="L4023">                            pOut.add(pixIdx2);</span>
                        }
<span class="nc bnc" id="L4025" title="All 2 branches missed.">                        if (j == (h0 - 1)) {</span>
                            // just in case excess unset
<span class="nc bnc" id="L4027" title="All 2 branches missed.">                            for (int jj = stop2; jj &lt; h1; jj++) {</span>
<span class="nc" id="L4028">                                int pixIdx2 = (jj * w1) + ii;</span>
<span class="nc" id="L4029">                                pOut.add(pixIdx2);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L4034">            }</span>
        }
        
<span class="nc" id="L4037">        return output;</span>
    }
    
    /**
     * create a two-dimensional float array of the img multiplied by
     * factor, but returned in row-major format [row][col].
     * @param img
     * @param factor
     * @return 
     */
    public float[][] multiply(GreyscaleImage img, float factor) {
     
<span class="fc" id="L4049">        int nRows = img.getHeight();</span>
<span class="fc" id="L4050">        int nCols = img.getWidth();</span>
<span class="fc" id="L4051">        float[][] out = new float[nRows][nCols];</span>
<span class="fc bfc" id="L4052" title="All 2 branches covered.">        for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc" id="L4053">            out[j] = new float[nCols];</span>
        }

<span class="fc bfc" id="L4056" title="All 2 branches covered.">        for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc bfc" id="L4057" title="All 2 branches covered.">            for (int i = 0; i &lt; nCols; ++i) {</span>
<span class="fc" id="L4058">                out[j][i] = (float)img.getValue(i, j) * factor;</span>
            }
        }

<span class="fc" id="L4062">        return out;</span>
    }

    public void createFirstDerivKeyPoints(float[][] image, 
        float sigma, TIntList outKeypoints0, TIntList outKeypoints1) {

<span class="nc" id="L4068">        boolean createCurvatureComponents = false;</span>
        
<span class="nc" id="L4070">        StructureTensor tensorComponents = new StructureTensor(image, </span>
            sigma, createCurvatureComponents);
       
<span class="nc" id="L4073">        float hLimit = 0.09f;//0.05f;</span>
        
<span class="nc" id="L4075">        createFirstDerivKeyPoints(tensorComponents, outKeypoints0, </span>
            outKeypoints1, hLimit);
<span class="nc" id="L4077">    }</span>
    
    public void createFirstDerivKeyPoints(
        StructureTensor tensorComponents, TIntList outKeypoints0, 
        TIntList outKeypoints1, float hLimit) {
       
<span class="fc" id="L4083">        TIntList kp0 = new TIntArrayList();</span>
<span class="fc" id="L4084">        TIntList kp1 = new TIntArrayList();</span>

        // square of 1st deriv:
<span class="fc" id="L4087">        float[][] firstDeriv = add(tensorComponents.getDXSquared(), </span>
<span class="fc" id="L4088">            tensorComponents.getDYSquared());</span>

<span class="fc" id="L4090">        peakLocalMax(firstDeriv, 1, 0.1f, kp0, kp1);</span>

<span class="fc" id="L4092">        float[][] detA = tensorComponents.getDeterminant();</span>
<span class="fc" id="L4093">        float[][] traceA = tensorComponents.getTrace();</span>
        
        //float min = MiscMath.findMin(secondDeriv);
        //float max = MiscMath.findMax(secondDeriv);
        //System.out.println(&quot;min=&quot; + min + &quot; max=&quot; + max);
        //System.out.println(&quot;nRows=&quot; + nRows + &quot; nCols=&quot; + nCols);
<span class="fc bfc" id="L4099" title="All 2 branches covered.">        for (int i = 0; i &lt; kp0.size(); ++i) {</span>
<span class="fc" id="L4100">            int x = kp0.get(i);</span>
<span class="fc" id="L4101">            int y = kp1.get(i);</span>
            // harmonic mean, Brown, Szeliski, and Winder (2005),
<span class="fc" id="L4103">            float hMean = (detA[x][y]/traceA[x][y]);</span>
<span class="fc bfc" id="L4104" title="All 2 branches covered.">            if (hMean &gt; hLimit) {</span>
                //System.out.println(String.format(&quot;(%d,%d) detA/tr=%.4f&quot;,
                //    x, y, hMean));
<span class="fc" id="L4107">                outKeypoints0.add(x);</span>
<span class="fc" id="L4108">                outKeypoints1.add(y);</span>
            }
        }
        
        /*{// DEBUG
            float[][] a = copy(firstDeriv);
            MiscMath.applyRescale(a, 0, 255);
            MiscDebug.writeImage(a, &quot;_fitsr_deriv_&quot; 
                + MiscDebug.getCurrentTimeFormatted());
        }*/
        
<span class="fc" id="L4119">    }</span>

    public Set&lt;PairInt&gt; binPoints(Set&lt;PairInt&gt; points, int binFactor) {
    
<span class="nc" id="L4123">        Set&lt;PairInt&gt; out = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L4124" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L4125">            int x = Math.round((float)p.getX()/(float)binFactor);</span>
<span class="nc" id="L4126">            int y = Math.round((float)p.getY()/(float)binFactor);</span>
<span class="nc" id="L4127">            out.add(new PairInt(x, y));</span>
<span class="nc" id="L4128">        }</span>
        
<span class="nc" id="L4130">        return out;</span>
    }

    public static class Colors {
        private final float[] colors;
        public Colors(float[] theColors) {
            colors = theColors;
        }
        public float[] getColors() {
            return colors;
        }
    }
    
    /**
     * opposite to shift zero-frequency component to the center of the spectrum
     * in that it shifts the zero-frequency component to the smallest indexes
     * in the arrays.
     *
     * adapted from
     * https://github.com/numpy/numpy/blob/master/LICENSE.txt
     * which has copyright
     *
     * Copyright (c) 2005-2016, NumPy Developers.
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are
        met:

            * Redistributions of source code must retain the above copyright
               notice, this list of conditions and the following disclaimer.

            * Redistributions in binary form must reproduce the above
               copyright notice, this list of conditions and the following
               disclaimer in the documentation and/or other materials provided
               with the distribution.

            * Neither the name of the NumPy Developers nor the names of any
               contributors may be used to endorse or promote products derived
               from this software without specific prior written permission.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * @param a
     * @return
     */
    public double[][] ifftShift(double[][] a) {

<span class="fc" id="L4187">        double[][] b = new double[a.length][];</span>

        // ---- reorder columns ----
<span class="fc" id="L4190">        int nc = a.length;</span>
<span class="fc" id="L4191">        int p2 = nc - ((nc + 1)/2);</span>
<span class="fc" id="L4192">        List&lt;Integer&gt; range = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L4193" title="All 2 branches covered.">        for (int i = p2; i &lt; nc; ++i) {</span>
<span class="fc" id="L4194">            range.add(Integer.valueOf(i));</span>
        }
<span class="fc bfc" id="L4196" title="All 2 branches covered.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="fc" id="L4197">            range.add(Integer.valueOf(i));</span>
        }
<span class="fc" id="L4199">        int count = 0;</span>
<span class="fc bfc" id="L4200" title="All 2 branches covered.">        for (Integer index : range) {</span>
<span class="fc" id="L4201">            int idx = index.intValue();</span>
<span class="fc" id="L4202">            b[count] = Arrays.copyOf(a[idx], a[idx].length);</span>
<span class="fc" id="L4203">            count++;</span>
<span class="fc" id="L4204">        }</span>

        // ---- reorder rows ------
<span class="fc" id="L4207">        nc = a[0].length;</span>
<span class="fc" id="L4208">        p2 = nc - ((nc + 1)/2);</span>
<span class="fc" id="L4209">        range = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L4210" title="All 2 branches covered.">        for (int i = p2; i &lt; nc; ++i) {</span>
<span class="fc" id="L4211">            range.add(Integer.valueOf(i));</span>
        }
<span class="fc bfc" id="L4213" title="All 2 branches covered.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="fc" id="L4214">            range.add(Integer.valueOf(i));</span>
        }

<span class="fc" id="L4217">        double[][] c = new double[a.length][];</span>
<span class="fc bfc" id="L4218" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="fc" id="L4219">            c[i] = new double[a[0].length];</span>
        }
<span class="fc" id="L4221">        count = 0;</span>
<span class="fc bfc" id="L4222" title="All 2 branches covered.">        for (Integer index : range) {</span>
<span class="fc" id="L4223">            int j = index.intValue();</span>
<span class="fc bfc" id="L4224" title="All 2 branches covered.">            for (int col = 0; col &lt; a.length; ++col) {</span>
<span class="fc" id="L4225">                c[col][count] = b[col][j];</span>
            }
<span class="fc" id="L4227">            count++;</span>
<span class="fc" id="L4228">        }</span>

<span class="fc" id="L4230">        return c;</span>
    }

    /**
     * opposite to shift zero-frequency component to the center of the spectrum
     * in that it shifts the zero-frequency component to the smallest indexes
     * in the arrays.
     *
     * adapted from
     * https://github.com/numpy/numpy/blob/master/LICENSE.txt
     * which has copyright
     *
     * Copyright (c) 2005-2016, NumPy Developers.
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are
        met:

            * Redistributions of source code must retain the above copyright
               notice, this list of conditions and the following disclaimer.

            * Redistributions in binary form must reproduce the above
               copyright notice, this list of conditions and the following
               disclaimer in the documentation and/or other materials provided
               with the distribution.

            * Neither the name of the NumPy Developers nor the names of any
               contributors may be used to endorse or promote products derived
               from this software without specific prior written permission.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * @param a
     * @return
     */
    public Complex[][] ifftShift(Complex[][] a) {

<span class="nc" id="L4277">        Complex[][] b = new Complex[a.length][];</span>

        // ---- reorder dimension 0 ----
<span class="nc" id="L4280">        int n0 = a.length;</span>
<span class="nc" id="L4281">        int p2 = n0 - ((n0 + 1)/2);</span>
<span class="nc" id="L4282">        List&lt;Integer&gt; range = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L4283" title="All 2 branches missed.">        for (int i = p2; i &lt; n0; ++i) {</span>
<span class="nc" id="L4284">            range.add(Integer.valueOf(i));</span>
        }
<span class="nc bnc" id="L4286" title="All 2 branches missed.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="nc" id="L4287">            range.add(Integer.valueOf(i));</span>
        }
<span class="nc" id="L4289">        int count = 0;</span>
<span class="nc bnc" id="L4290" title="All 2 branches missed.">        for (Integer index : range) {</span>
<span class="nc" id="L4291">            int idx = index.intValue();</span>
<span class="nc" id="L4292">            b[count] = Arrays.copyOf(a[idx], a[idx].length);</span>
<span class="nc" id="L4293">            count++;</span>
<span class="nc" id="L4294">        }</span>

        // ---- reorder dimension 1 ------
<span class="nc" id="L4297">        int n1 = a[0].length;</span>
<span class="nc" id="L4298">        p2 = n1 - ((n1 + 1)/2);</span>
<span class="nc" id="L4299">        range = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L4300" title="All 2 branches missed.">        for (int i = p2; i &lt; n1; ++i) {</span>
<span class="nc" id="L4301">            range.add(Integer.valueOf(i));</span>
        }
<span class="nc bnc" id="L4303" title="All 2 branches missed.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="nc" id="L4304">            range.add(Integer.valueOf(i));</span>
        }

<span class="nc" id="L4307">        Complex[][] c = new Complex[a.length][];</span>
<span class="nc bnc" id="L4308" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc" id="L4309">            c[i] = new Complex[a[0].length];</span>
        }
<span class="nc" id="L4311">        count = 0;</span>
<span class="nc bnc" id="L4312" title="All 2 branches missed.">        for (Integer index : range) {</span>
<span class="nc" id="L4313">            int j = index.intValue();</span>
<span class="nc bnc" id="L4314" title="All 2 branches missed.">            for (int col = 0; col &lt; a.length; ++col) {</span>
<span class="nc" id="L4315">                c[col][count] = b[col][j];</span>
            }
<span class="nc" id="L4317">            count++;</span>
<span class="nc" id="L4318">        }</span>

<span class="nc" id="L4320">        return c;</span>
    }
   
    /**
     * 
     * @param input gradient image
     */
    public void apply2LayerFilterOtsu(GreyscaleImage input) {
     
<span class="nc" id="L4329">        int w = input.getWidth();</span>
<span class="nc" id="L4330">        int h = input.getHeight();</span>
        
<span class="nc" id="L4332">        OtsuThresholding ot = new OtsuThresholding();</span>
                           
<span class="nc" id="L4334">        double[][] g = new double[w][];</span>
<span class="nc bnc" id="L4335" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc" id="L4336">            g[i] = new double[h];</span>
<span class="nc bnc" id="L4337" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L4338">                g[i][j] = input.getValue(i, j);</span>
            }
        }
<span class="nc" id="L4341">        int nBins = 256/5;</span>
<span class="nc" id="L4342">        float t = (float)ot.calculateBinaryThreshold2D(g, nBins);</span>
            
<span class="nc" id="L4344">        float tHigh = 0.75f * t;</span>
    
<span class="nc" id="L4346">        float lowToHighFactor = 2.f;</span>
        
<span class="nc" id="L4348">        apply2LayerFilter(input, tHigh, lowToHighFactor);    </span>
<span class="nc" id="L4349">    }</span>
            
    public void apply2LayerFilter(GreyscaleImage input, float highThreshold,
        float lowToHighFactor) {
        
<span class="nc" id="L4354">        int w = input.getWidth();</span>
<span class="nc" id="L4355">        int h = input.getHeight();</span>
        
<span class="nc bnc" id="L4357" title="All 4 branches missed.">        if (w &lt; 3 || h &lt; 3) {</span>
<span class="nc" id="L4358">            throw new IllegalArgumentException(&quot;images should be &gt;= 3x3 in size&quot;);</span>
        }
                
<span class="nc" id="L4361">        float tHigh = highThreshold;</span>
<span class="nc" id="L4362">        float tLow = tHigh/lowToHighFactor;</span>
            
<span class="nc" id="L4364">        int[] dxs = Misc.dx8;</span>
<span class="nc" id="L4365">        int[] dys = Misc.dy8;</span>
        
<span class="nc" id="L4367">        int n = input.getNPixels();</span>
        
<span class="nc" id="L4369">        GreyscaleImage img2 = input.createWithDimensions();</span>
        
<span class="nc bnc" id="L4371" title="All 2 branches missed.">        for (int i = 0; i &lt; img2.getNPixels(); ++i) {</span>
            
<span class="nc" id="L4373">            int v = input.getValue(i);</span>
            
<span class="nc bnc" id="L4375" title="All 2 branches missed.">            if (v &lt; tLow) {</span>
<span class="nc" id="L4376">                continue;</span>
<span class="nc bnc" id="L4377" title="All 2 branches missed.">            } else if (v &gt; tHigh) {</span>
<span class="nc" id="L4378">                img2.setValue(i, v);</span>
<span class="nc" id="L4379">                continue;</span>
            }
            
<span class="nc" id="L4382">            int x = input.getCol(i);</span>
<span class="nc" id="L4383">            int y = input.getRow(i);</span>
            
<span class="nc" id="L4385">            boolean foundHigh = false;</span>
<span class="nc" id="L4386">            boolean foundMid = false;</span>
            
<span class="nc bnc" id="L4388" title="All 2 branches missed.">            for (int k = 0; k &lt; dxs.length; ++k) {                </span>
<span class="nc" id="L4389">                int x2 = x + dxs[k];</span>
<span class="nc" id="L4390">                int y2 = y + dys[k];</span>
<span class="nc bnc" id="L4391" title="All 8 branches missed.">                if ((x2 &lt; 0) || (y2 &lt; 0) || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L4392">                    continue;</span>
                }
<span class="nc" id="L4394">                int v2 = input.getValue(x2, y2);</span>
<span class="nc bnc" id="L4395" title="All 2 branches missed.">                if (v2 &gt; tHigh) {</span>
<span class="nc" id="L4396">                    foundHigh = true;</span>
<span class="nc" id="L4397">                    break;</span>
<span class="nc bnc" id="L4398" title="All 2 branches missed.">                } else if (v2 &gt; tLow) {</span>
<span class="nc" id="L4399">                    foundMid = true;</span>
                }
            }
<span class="nc bnc" id="L4402" title="All 2 branches missed.">            if (foundHigh) {</span>
<span class="nc" id="L4403">                img2.setValue(i, v);</span>
<span class="nc" id="L4404">                continue;</span>
            }
<span class="nc bnc" id="L4406" title="All 2 branches missed.">            if (!foundMid) {</span>
<span class="nc" id="L4407">                continue;</span>
            }
            // search the 5 by 5 region for a &quot;sure edge&quot; pixel
<span class="nc bnc" id="L4410" title="All 2 branches missed.">            for (int dx = -2; dx &lt;= 2; ++dx) {</span>
<span class="nc" id="L4411">                int x2 = x + dx;</span>
<span class="nc bnc" id="L4412" title="All 4 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (w - 1))) {</span>
<span class="nc" id="L4413">                    continue;</span>
                }
<span class="nc bnc" id="L4415" title="All 2 branches missed.">                for (int dy = -2; dy &lt;= 2; ++dy) {</span>
<span class="nc" id="L4416">                    int y2 = y + dy;</span>
<span class="nc bnc" id="L4417" title="All 4 branches missed.">                    if ((y2 &lt; 0) || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L4418">                        continue;</span>
                    }
<span class="nc bnc" id="L4420" title="All 4 branches missed.">                    if (x2 == x &amp;&amp; y2 == y) {</span>
<span class="nc" id="L4421">                        continue;</span>
                    }
<span class="nc" id="L4423">                    int v2 = input.getValue(x2, y2);</span>
<span class="nc bnc" id="L4424" title="All 2 branches missed.">                    if (v2 &gt; tHigh) {</span>
<span class="nc" id="L4425">                        img2.setValue(i, v);</span>
<span class="nc" id="L4426">                        foundHigh = true;</span>
<span class="nc" id="L4427">                        break;</span>
                    }
                }
<span class="nc bnc" id="L4430" title="All 2 branches missed.">                if (foundHigh) {</span>
<span class="nc" id="L4431">                    break;</span>
                }
            }
        }
        
<span class="nc" id="L4436">        input.resetTo(img2);</span>
        
        // apply post thinning corrections?
<span class="nc" id="L4439">    }</span>

    public int[] getAverageRGB(Image img, PairIntArray pArr) {
    
<span class="nc bnc" id="L4443" title="All 2 branches missed.">        if (pArr.getN() == 0) {</span>
<span class="nc" id="L4444">            return null;</span>
        }
        
<span class="nc" id="L4447">        int rSum = 0;</span>
<span class="nc" id="L4448">        int gSum = 0;</span>
<span class="nc" id="L4449">        int bSum = 0;</span>
<span class="nc bnc" id="L4450" title="All 2 branches missed.">        for (int i = 0; i &lt; pArr.getN(); ++i) {</span>
<span class="nc" id="L4451">            int x = pArr.getX(i);</span>
<span class="nc" id="L4452">            int y = pArr.getY(i);</span>
<span class="nc" id="L4453">            rSum += img.getR(x, y);</span>
<span class="nc" id="L4454">            gSum += img.getG(x, y);</span>
<span class="nc" id="L4455">            bSum += img.getB(x, y);</span>
        }
<span class="nc" id="L4457">        rSum /= pArr.getN();</span>
<span class="nc" id="L4458">        gSum /= pArr.getN();</span>
<span class="nc" id="L4459">        bSum /= pArr.getN();</span>
        
<span class="nc" id="L4461">        return new int[]{rSum, gSum, bSum};</span>
    }
    
    public int[] getAverageRGB(Image img, Collection&lt;PairInt&gt; pArr) {
    
<span class="pc bpc" id="L4466" title="1 of 2 branches missed.">        if (pArr.isEmpty()) {</span>
<span class="nc" id="L4467">            return null;</span>
        }
        
<span class="fc" id="L4470">        int rSum = 0;</span>
<span class="fc" id="L4471">        int gSum = 0;</span>
<span class="fc" id="L4472">        int bSum = 0;</span>
<span class="fc bfc" id="L4473" title="All 2 branches covered.">        for (PairInt p : pArr) {</span>
<span class="fc" id="L4474">            int x = p.getX();</span>
<span class="fc" id="L4475">            int y = p.getY();</span>
<span class="fc" id="L4476">            rSum += img.getR(x, y);</span>
<span class="fc" id="L4477">            gSum += img.getG(x, y);</span>
<span class="fc" id="L4478">            bSum += img.getB(x, y);</span>
<span class="fc" id="L4479">        }</span>
<span class="fc" id="L4480">        rSum /= pArr.size();</span>
<span class="fc" id="L4481">        gSum /= pArr.size();</span>
<span class="fc" id="L4482">        bSum /= pArr.size();</span>
        
<span class="fc" id="L4484">        return new int[]{rSum, gSum, bSum};</span>
    }
    
    /**
     * NOTE: needs testing...invoker should trim for image bounds
     * where needed.
     * @param points
     * @param sigma
     */
    public void blur(Set&lt;PairInt&gt; points, SIGMA sigma) {
        
        // gaussian smoothing by sigma
<span class="fc" id="L4496">        float[] kernel = Gaussian1D.getKernel(sigma);</span>
        
<span class="fc" id="L4498">        applyKernel(points, kernel);</span>
<span class="fc" id="L4499">    }</span>
    
    /**
     * NOTE: needs testing...invoker should trim for image bounds
     * where needed.
     * @param points
     * @param sigma
     */
    public void applyKernel(Set&lt;PairInt&gt; points, float[] kernel) {
        
<span class="fc" id="L4509">        int[] minMaxXY = MiscMath.findMinMaxXY(points);</span>
        
<span class="fc" id="L4511">        int xLL = minMaxXY[0] - 10;</span>
<span class="fc bfc" id="L4512" title="All 2 branches covered.">        if (xLL &lt; 0) {</span>
<span class="fc" id="L4513">            xLL = 0;</span>
        }
<span class="fc" id="L4515">        int yLL = minMaxXY[2] - 10;</span>
<span class="fc bfc" id="L4516" title="All 2 branches covered.">        if (yLL &lt; 0) {</span>
<span class="fc" id="L4517">            yLL = 0;</span>
        }
        
<span class="fc" id="L4520">        int xUR = minMaxXY[1] + 10;</span>
<span class="fc" id="L4521">        int yUR = minMaxXY[3] + 10;</span>
        
<span class="fc" id="L4523">        int w = xUR - xLL + 1;</span>
<span class="fc" id="L4524">        int h = yUR - yLL + 1;</span>
        
<span class="fc" id="L4526">        int[][] img = new int[w][];</span>
<span class="fc bfc" id="L4527" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L4528">            img[i] = new int[h];</span>
        }
        
<span class="fc bfc" id="L4531" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L4532">            int x = p.getX() - xLL;</span>
<span class="fc" id="L4533">            int y = p.getY() - yLL;</span>
<span class="fc" id="L4534">            img[x][y] = 126;</span>
<span class="fc" id="L4535">        }</span>
        
<span class="fc" id="L4537">        applyKernelTwo1Ds(img, kernel);</span>
        
<span class="fc" id="L4539">        points.clear();</span>
        
<span class="fc bfc" id="L4541" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L4542" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc bfc" id="L4543" title="All 2 branches covered.">                if (img[i][j] &lt;= 0) {</span>
<span class="fc" id="L4544">                    continue;</span>
                }
<span class="fc" id="L4546">                int x = i + xLL;</span>
<span class="fc" id="L4547">                int y = j + yLL;</span>
<span class="fc" id="L4548">                PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L4549">                points.add(p);</span>
            }
        }
<span class="fc" id="L4552">    }</span>
    
    /**
     * blur the points by sigma and trim any extending beyond image bounds.
     * @param points
     * @param sigma
     * @param imgWidth
     * @param imgHeight 
     */
    public void blurAndTrim(Set&lt;PairInt&gt; points, SIGMA sigma, int imgWidth, 
        int imgHeight) {
        
<span class="fc" id="L4564">        blur(points, sigma);</span>
        
        // trim any points extending beyond image bounds
<span class="fc" id="L4567">        Set&lt;PairInt&gt; rm = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L4568" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="pc bpc" id="L4569" title="2 of 4 branches missed.">            if ((p.getX() &gt; (imgWidth - 1)) || (p.getY() &gt; (imgHeight - 1)) ||</span>
<span class="pc bpc" id="L4570" title="2 of 4 branches missed.">                (p.getX() &lt; 0) || (p.getY() &lt; 0)) {</span>
<span class="nc" id="L4571">                rm.add(p);</span>
            }
<span class="fc" id="L4573">        }</span>
        
<span class="fc" id="L4575">        points.removeAll(rm);</span>
<span class="fc" id="L4576">    }</span>
    
    /**
     * NOTE: modifies input by the blur step.
     * @param contiguousPoints
     * @param sigma
     * @param imgWidth
     * @param imgHeight
     * @return 
     */
    public PairIntArray extractSmoothedOrderedBoundary(
        Set&lt;PairInt&gt; contiguousPoints, SIGMA sigma, int imgWidth, int imgHeight) {
                
<span class="fc" id="L4589">        blurAndTrim(contiguousPoints, sigma, imgWidth, imgHeight);</span>
        
<span class="fc" id="L4591">        PerimeterFinder2 finder = new PerimeterFinder2();</span>
<span class="fc" id="L4592">        PairIntArray ordered = finder.extractOrderedBorder(</span>
            contiguousPoints);
    
<span class="fc" id="L4595">        return ordered;</span>
    }
    
    /**
     * apply a dilate operator of size 3 x 3 to any pixel in image with value
     * greater than 0.
     * Note that if the img is not binary, the result may not be ideal because
     * no attempt has been made to account for existing pixel value when 
     * overwritten during dilation of adjacent pixel.
     * 
     * @param img 
     * @return  
     */
    public GreyscaleImage dilate(GreyscaleImage img) {
<span class="fc" id="L4609">        return dilateOrErode(img, true);</span>
    }
    
    /**
     * apply an erosion operator of size 3 x 3 to any pixel in image with value
     * 0.
     * 
     * @param img 
     * @return  
     */
    public GreyscaleImage erode(GreyscaleImage img) {
<span class="fc" id="L4620">       return dilateOrErode(img, false);</span>
    }
    
    /**
     * 
     * @param img 
     * @return  
     */
    private GreyscaleImage dilateOrErode(GreyscaleImage img, boolean dilate) {
       
<span class="fc" id="L4630">        int w = img.getWidth();</span>
<span class="fc" id="L4631">        int h = img.getHeight();</span>
<span class="fc" id="L4632">        int n = img.getNPixels();</span>
        
<span class="fc" id="L4634">        GreyscaleImage out = img.copyImage();</span>
        
<span class="fc bfc" id="L4636" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; n; ++pixIdx) {</span>
<span class="fc" id="L4637">            int v = img.getValue(pixIdx);</span>
<span class="fc bfc" id="L4638" title="All 4 branches covered.">            if (dilate &amp;&amp; v &lt; 1) {</span>
<span class="fc" id="L4639">                continue;</span>
<span class="fc bfc" id="L4640" title="All 4 branches covered.">            } else if (!dilate &amp;&amp; v != 0) {</span>
<span class="fc" id="L4641">                continue;</span>
            }
<span class="fc" id="L4643">            int x = img.getCol(pixIdx);</span>
<span class="fc" id="L4644">            int y = img.getRow(pixIdx);</span>
<span class="fc bfc" id="L4645" title="All 2 branches covered.">            for (int i = -1; i &lt;= 1; ++i) {</span>
<span class="fc" id="L4646">                int x2 = x + i;</span>
<span class="fc bfc" id="L4647" title="All 4 branches covered.">                if (x2 &lt; 0 || x2 &gt; (w - 1)) {</span>
<span class="fc" id="L4648">                    continue;</span>
                }
<span class="fc bfc" id="L4650" title="All 2 branches covered.">                for (int j = -1; j &lt;= 1; ++j) {</span>
<span class="fc bfc" id="L4651" title="All 4 branches covered.">                    if (i == 0 &amp;&amp; j == 0) {</span>
<span class="fc" id="L4652">                        continue;</span>
                    }
<span class="fc" id="L4654">                    int y2 = y + j;</span>
<span class="fc bfc" id="L4655" title="All 4 branches covered.">                    if (y2 &lt; 0 || y2 &gt; (h - 1)) {</span>
<span class="fc" id="L4656">                        continue;</span>
                    }
                    /*if (x == 0 &amp;&amp; x2 == 0) {
                        continue;
                    }
                    if (y == 0 &amp;&amp; y2 == 0) {
                        continue;
                    }
                    if (x == (w - 1) &amp;&amp; x2 == (w - 1)) {
                        continue;
                    }
                    if (y == (h - 1) &amp;&amp; y2 == (h - 1)) {
                        continue;
                    }*/
                    
<span class="fc" id="L4671">                    out.setValue(x2, y2, v);</span>
                }
            }
        }
        
<span class="fc" id="L4676">        return out;</span>
    }
    
    /**
     * 
     * @param img 
     * @return  
     */
    private Set&lt;PairInt&gt; dilate(Set&lt;PairInt&gt; set, 
        int imageWidth, int imageHeight, boolean dilate) {
       
<span class="nc" id="L4687">        int w = imageWidth;</span>
<span class="nc" id="L4688">        int h = imageHeight;</span>
        
<span class="nc" id="L4690">        Set&lt;PairInt&gt; out = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L4692" title="All 2 branches missed.">        for (PairInt p : set) {</span>
<span class="nc" id="L4693">            int x = p.getX();</span>
<span class="nc" id="L4694">            int y = p.getY();</span>
<span class="nc bnc" id="L4695" title="All 2 branches missed.">            for (int i = -1; i &lt;= 1; ++i) {</span>
<span class="nc" id="L4696">                int x2 = x + i;</span>
<span class="nc bnc" id="L4697" title="All 4 branches missed.">                if (x2 &lt; 0 || x2 &gt; (w - 1)) {</span>
<span class="nc" id="L4698">                    continue;</span>
                }
<span class="nc bnc" id="L4700" title="All 2 branches missed.">                for (int j = -1; j &lt;= 1; ++j) {</span>
<span class="nc bnc" id="L4701" title="All 4 branches missed.">                    if (i == 0 &amp;&amp; j == 0) {</span>
<span class="nc" id="L4702">                        continue;</span>
                    }
<span class="nc" id="L4704">                    int y2 = y + j;</span>
<span class="nc bnc" id="L4705" title="All 4 branches missed.">                    if (y2 &lt; 0 || y2 &gt; (h - 1)) {</span>
<span class="nc" id="L4706">                        continue;</span>
                    }
<span class="nc" id="L4708">                    out.add(new PairInt(x2, y2));</span>
                }
            }
<span class="nc" id="L4711">        }</span>
        
<span class="nc" id="L4713">        return out;</span>
    }
    
    /**
     * apply erode then dilate
     * 
     * @param img
     * @return 
     */
    public GreyscaleImage opening(GreyscaleImage img) {
<span class="nc" id="L4723">        GreyscaleImage erode = erode(img);</span>
<span class="nc" id="L4724">        return dilate(erode);</span>
    }
    
    /**
     * apply dilate then erode
     * 
     * @param img
     * @return 
     */
    public GreyscaleImage closing(GreyscaleImage img) {
<span class="fc" id="L4734">        GreyscaleImage dilate = dilate(img);</span>
<span class="fc" id="L4735">        return erode(dilate);</span>
    }
    
    /**
     * apply morphological thinning.
     * prefer this line thinner over applyThinning()
     * @param img
     */
    public void applyThinning2(GreyscaleImage img) {

<span class="fc" id="L4745">        int n0 = img.getWidth();</span>
<span class="fc" id="L4746">        int n1 = img.getHeight();</span>
        
<span class="fc" id="L4748">        int[][] morphInput = new int[n0][];</span>
<span class="fc bfc" id="L4749" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L4750">            morphInput[i] = new int[n1];</span>
        }
<span class="fc bfc" id="L4752" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc bfc" id="L4753" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc bfc" id="L4754" title="All 2 branches covered.">                if (img.getValue(i, j) &gt; 0) {                    </span>
<span class="fc" id="L4755">                    morphInput[i][j] = 1;</span>
                } else {
<span class="fc" id="L4757">                    morphInput[i][j] = 0;</span>
                }
            }
        }        
        
<span class="fc" id="L4762">        MorphologicalFilter mFilter = new MorphologicalFilter();</span>
<span class="fc" id="L4763">        int[][] skel = mFilter.bwMorphThin(morphInput, Integer.MAX_VALUE);</span>

<span class="fc" id="L4765">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L4767" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc bfc" id="L4768" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L4769">                int m = skel[i][j];</span>
<span class="fc" id="L4770">                int v = img.getValue(i, j) * m;</span>
<span class="fc" id="L4771">                img.setValue(i, j, v);</span>
<span class="fc bfc" id="L4772" title="All 2 branches covered.">                if (v &gt; 0) {</span>
<span class="fc" id="L4773">                    points.add(new PairInt(i, j));</span>
                }
            }
        }
        
<span class="fc" id="L4778">    }</span>

    /**
     * apply 8 hit or miss filters iteratively until convergence to thin the
     * image.  the operation is performed on all pixels with 
     * value &gt; 0.  prefer applyThinning2() to this method.
     * @param img
     */
    public void applyThinning(GreyscaleImage img) {

        //from https://en.wikipedia.org/wiki/Hit-or-miss_transform
        // and thinning

        // x,y pairs are sequential in these
<span class="fc" id="L4792">        int[] c1 = new int[]{0,  0, -1, -1, 0,  -1, 1, -1};</span>
<span class="fc" id="L4793">        int[] d1 = new int[]{-1, 1, 0,   1, 1,  1};</span>
<span class="fc" id="L4794">        int[] c2 = new int[]{-1, 0, 0,   0, -1, -1, 0, -1};</span>
<span class="fc" id="L4795">        int[] d2 = new int[]{0,  1, 1,   1, 1,  0};</span>

        /*
            - - -        - -
              +        + + -
            + + +      + +        
        */
<span class="fc" id="L4802">        PairInt[][] neighborCoordOffsets</span>
<span class="fc" id="L4803">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
            0, 0);
        
<span class="fc" id="L4806">        int w = img.getWidth();</span>
<span class="fc" id="L4807">        int h = img.getHeight();</span>
<span class="fc" id="L4808">        int n = img.getNPixels();</span>
<span class="fc" id="L4809">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L4810">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L4812">        int nEdited = 0;</span>
<span class="fc" id="L4813">        int nIter = 0;</span>
        do {
<span class="fc" id="L4815">            nEdited = 0;</span>
            
            //GreyscaleImage tmp = out.copyImage();
            //tmp.multiply(255.f);
            //MiscDebug.writeImage(tmp, &quot;_editing_&quot; + MiscDebug.getCurrentTimeFormatted());

            // test c1, d1 and it rotated by 90 3 times
            // test c2, d2 and it rotated by 90 3 times
            // need to alternate direction of approach
<span class="fc bfc" id="L4824" title="All 2 branches covered.">            for (int t = 0; t &lt; 2; ++t) {</span>
                int[] tmpC;
                int[] tmpD;
<span class="fc bfc" id="L4827" title="All 2 branches covered.">                if (t == 0) {</span>
<span class="fc" id="L4828">                    tmpC = Arrays.copyOf(c1, c1.length);</span>
<span class="fc" id="L4829">                    tmpD = Arrays.copyOf(d1, d1.length);</span>
                } else {
<span class="fc" id="L4831">                    tmpC = Arrays.copyOf(c2, c2.length);</span>
<span class="fc" id="L4832">                    tmpD = Arrays.copyOf(d2, d2.length);</span>
                }
<span class="fc bfc" id="L4834" title="All 2 branches covered.">                for (int r = 0; r &lt; 4; ++r) {</span>
<span class="fc bfc" id="L4835" title="All 2 branches covered.">                    if (r &gt; 0) {</span>
<span class="fc" id="L4836">                        rotatePairsBy90(tmpC);</span>
<span class="fc" id="L4837">                        rotatePairsBy90(tmpD);</span>
                    }
                    
                    // to try to make it more symmetric, collecting all
                    // nullable pixels and counting the set neighbors,
                    // then revisiting by order of fewest set neighbors 
<span class="fc" id="L4843">                    MinHeapForRT2012 heap = new MinHeapForRT2012(9, n);</span>

<span class="fc bfc" id="L4845" title="All 2 branches covered.">                    for (int x = 1; x &lt; (img.getWidth() - 1); ++x) {</span>
<span class="fc bfc" id="L4846" title="All 2 branches covered.">                        for (int y = 1; y &lt; (img.getHeight() - 1); ++y) {</span>
<span class="fc" id="L4847">                            int v = img.getValue(x, y);</span>
 
<span class="fc bfc" id="L4849" title="All 2 branches covered.">                            if (v == 0) {</span>
<span class="fc" id="L4850">                                continue;</span>
                            }
<span class="fc bfc" id="L4852" title="All 2 branches covered.">                            if (allArePresent(img, x, y, tmpC)</span>
<span class="fc bfc" id="L4853" title="All 2 branches covered.">                                &amp;&amp; allAreNotPresent(img, x, y, tmpD)) {</span>
<span class="pc bpc" id="L4854" title="1 of 2 branches missed.">                                if (!ImageSegmentation.doesDisconnect(img,</span>
                                    neighborCoordOffsets, x, y)) {
                             
                                    // number of neighbors that are not '1s
<span class="fc" id="L4858">                                    int nn = 0;</span>
<span class="fc bfc" id="L4859" title="All 2 branches covered.">                                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L4860">                                        int x2 = x + dxs[k];</span>
<span class="fc" id="L4861">                                        int y2 = y + dys[k];</span>
<span class="pc bpc" id="L4862" title="4 of 8 branches missed.">                                        if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L4863">                                            continue;</span>
                                        }
<span class="pc bpc" id="L4865" title="1 of 2 branches missed.">                                        if (img.getValue(x, y) &gt; 0) {</span>
<span class="fc" id="L4866">                                            nn++;</span>
                                        }
                                    }
                                    
                                    //long key = 8 - nn;
<span class="fc" id="L4871">                                    long key = nn;</span>
<span class="fc" id="L4872">                                    HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L4873">                                    int pixIdx = (y * w) + x;</span>
<span class="fc" id="L4874">                                    node.setData(Integer.valueOf(pixIdx));</span>
<span class="fc" id="L4875">                                    heap.insert(node);</span>
                                }
                            }
                        }
                    }
                    
<span class="fc bfc" id="L4881" title="All 2 branches covered.">                    while (heap.getNumberOfNodes() &gt; 0) {</span>
                        
<span class="fc" id="L4883">                        HeapNode node = heap.extractMin();</span>
                        
<span class="pc bpc" id="L4885" title="3 of 4 branches missed.">                        assert(node != null);</span>

<span class="fc" id="L4887">                        int pixIdx = ((Integer)node.getData()).intValue();</span>
<span class="fc" id="L4888">                        int y = pixIdx/w;</span>
<span class="fc" id="L4889">                        int x = pixIdx - (y * w);</span>
                        
<span class="fc" id="L4891">                        int v = img.getValue(x, y);</span>

<span class="pc bpc" id="L4893" title="1 of 2 branches missed.">                        if (v == 0) {</span>
<span class="nc" id="L4894">                            continue;</span>
                        }
<span class="pc bpc" id="L4896" title="1 of 2 branches missed.">                        if (allArePresent(img, x, y, tmpC)</span>
<span class="pc bpc" id="L4897" title="1 of 2 branches missed.">                            &amp;&amp; allAreNotPresent(img, x, y, tmpD)) {</span>
<span class="pc bpc" id="L4898" title="1 of 2 branches missed.">                            if (!ImageSegmentation.doesDisconnect(img,</span>
                                neighborCoordOffsets, x, y)) {

<span class="fc" id="L4901">                                img.setValue(x, y, 0);</span>
<span class="fc" id="L4902">                                nEdited++;</span>
                            }
                        }
<span class="fc" id="L4905">                    }                    </span>
                }                
            }
<span class="fc" id="L4908">            nIter++;</span>
<span class="fc bfc" id="L4909" title="All 2 branches covered.">        } while (nEdited &gt; 0);                </span>
<span class="fc" id="L4910">    }</span>
    
    /**
     * apply 8 hit or miss filters iteratively until convergence to thin the
     * image.  the operation is performed on all pixels with value &gt; 0.
     */
    public void applyThinning(Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

        //from https://en.wikipedia.org/wiki/Hit-or-miss_transform
        // and thinning

        // x,y pairs are sequential in these
<span class="fc" id="L4922">        int[] c1 = new int[]{0, 0, -1, -1, 0, -1, 1, -1};</span>
<span class="fc" id="L4923">        int[] d1 = new int[]{-1, 1, 0, 1, 1, 1};</span>
<span class="fc" id="L4924">        int[] c2 = new int[]{-1, 0, 0, 0, -1, -1, 0, -1};</span>
<span class="fc" id="L4925">        int[] d2 = new int[]{0, 1, 1, 1, 1, 0};</span>

        /*
            - - -        - -
              +        + + -
            + + +      + +        
        */
<span class="fc" id="L4932">        PairInt[][] neighborCoordOffsets</span>
<span class="fc" id="L4933">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
            0, 0);
        
<span class="fc" id="L4936">        int w = imageWidth;</span>
<span class="fc" id="L4937">        int h = imageHeight;</span>
<span class="fc" id="L4938">        int n = points.size();</span>
<span class="fc" id="L4939">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L4940">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L4942">        int nEdited = 0;</span>
<span class="fc" id="L4943">        int nIter = 0;</span>
        do {
<span class="fc" id="L4945">            nEdited = 0;</span>
            
            //GreyscaleImage tmp = out.copyImage();
            //tmp.multiply(255.f);
            //MiscDebug.writeImage(tmp, &quot;_editing_&quot; + MiscDebug.getCurrentTimeFormatted());

            // test c1, d1 and it rotated by 90 3 times
            // test c2, d2 and it rotated by 90 3 times
            // need to alternate direction of approach
<span class="fc bfc" id="L4954" title="All 2 branches covered.">            for (int t = 0; t &lt; 2; ++t) {</span>
                int[] tmpC;
                int[] tmpD;
<span class="fc bfc" id="L4957" title="All 2 branches covered.">                if (t == 0) {</span>
<span class="fc" id="L4958">                    tmpC = Arrays.copyOf(c1, c1.length);</span>
<span class="fc" id="L4959">                    tmpD = Arrays.copyOf(d1, d1.length);</span>
                } else {
<span class="fc" id="L4961">                    tmpC = Arrays.copyOf(c2, c2.length);</span>
<span class="fc" id="L4962">                    tmpD = Arrays.copyOf(d2, d2.length);</span>
                }
<span class="fc bfc" id="L4964" title="All 2 branches covered.">                for (int r = 0; r &lt; 4; ++r) {</span>
<span class="fc bfc" id="L4965" title="All 2 branches covered.">                    if (r &gt; 0) {</span>
<span class="fc" id="L4966">                        rotatePairsBy90(tmpC);</span>
<span class="fc" id="L4967">                        rotatePairsBy90(tmpD);</span>
                    }
                    
                    // to try to make it more symmetric, collecting all
                    // nullable pixels and counting the set neighbors,
                    // then revisiting by order of fewest set neighbors 
<span class="fc" id="L4973">                    MinHeapForRT2012 heap = new MinHeapForRT2012(9, n);</span>

<span class="fc bfc" id="L4975" title="All 2 branches covered.">                    for (PairInt p : points) {</span>
<span class="fc" id="L4976">                        int x = p.getX();</span>
<span class="fc" id="L4977">                        int y = p.getY();</span>
<span class="fc bfc" id="L4978" title="All 2 branches covered.">                        if (allArePresent(points, x, y, tmpC)</span>
<span class="fc bfc" id="L4979" title="All 2 branches covered.">                            &amp;&amp; allAreNotPresent(points, x, y, tmpD)) {</span>
<span class="fc bfc" id="L4980" title="All 2 branches covered.">                            if (!ImageSegmentation.doesDisconnect(points,</span>
                                neighborCoordOffsets, x, y, imageWidth, 
                                imageHeight)) {
                                
                                // number of neighbors that are not '1s
<span class="fc" id="L4985">                                int nn = 0;</span>
<span class="fc bfc" id="L4986" title="All 2 branches covered.">                                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L4987">                                    int x2 = x + dxs[k];</span>
<span class="fc" id="L4988">                                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L4989" title="4 of 8 branches missed.">                                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L4990">                                        continue;</span>
                                    }
<span class="fc bfc" id="L4992" title="All 2 branches covered.">                                    if (points.contains(new PairInt(x2, y2))) {</span>
<span class="fc" id="L4993">                                        nn++;</span>
                                    }
                                }

                                //long key = 8 - nn;
<span class="fc" id="L4998">                                long key = nn;</span>
<span class="fc" id="L4999">                                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L5000">                                int pixIdx = (y * w) + x;</span>
<span class="fc" id="L5001">                                node.setData(Integer.valueOf(pixIdx));</span>
<span class="fc" id="L5002">                                heap.insert(node);</span>
                            }
                        }
<span class="fc" id="L5005">                    }</span>
                    
<span class="fc bfc" id="L5007" title="All 2 branches covered.">                    while (heap.getNumberOfNodes() &gt; 0) {</span>
                        
<span class="fc" id="L5009">                        HeapNode node = heap.extractMin();</span>
                        
<span class="pc bpc" id="L5011" title="3 of 4 branches missed.">                        assert(node != null);</span>

<span class="fc" id="L5013">                        int pixIdx = ((Integer)node.getData()).intValue();</span>
<span class="fc" id="L5014">                        int y = pixIdx/w;</span>
<span class="fc" id="L5015">                        int x = pixIdx - (y * w);</span>
                       
<span class="pc bpc" id="L5017" title="1 of 2 branches missed.">                        if (allArePresent(points, x, y, tmpC)</span>
<span class="pc bpc" id="L5018" title="1 of 2 branches missed.">                            &amp;&amp; allAreNotPresent(points, x, y, tmpD)) {</span>
<span class="pc bpc" id="L5019" title="1 of 2 branches missed.">                            if (!ImageSegmentation.doesDisconnect(points,</span>
                                neighborCoordOffsets, x, y, imageWidth, 
                                imageHeight)) {
                         
<span class="fc" id="L5023">                                points.remove(new PairInt(x, y));</span>
<span class="fc" id="L5024">                                nEdited++;</span>
                            }
                        }
<span class="fc" id="L5027">                    }                    </span>
                }                
            }
<span class="fc" id="L5030">            nIter++;</span>
<span class="fc bfc" id="L5031" title="All 2 branches covered.">        } while (nEdited &gt; 0);</span>
<span class="fc" id="L5032">    }</span>
    
    /**
     * apply 8 hit or miss filters iteratively until convergence to thin the
     * image.  the operation is performed on all pixels with value &gt; 0.
     */
    public void applyThinning(TIntSet pixIdxs, int imageWidth, int imageHeight) {

        //from https://en.wikipedia.org/wiki/Hit-or-miss_transform
        // and thinning

        // x,y pairs are sequential in these
<span class="fc" id="L5044">        int[] c1 = new int[]{0, 0, -1, -1, 0, -1, 1, -1};</span>
<span class="fc" id="L5045">        int[] d1 = new int[]{-1, 1, 0, 1, 1, 1};</span>
<span class="fc" id="L5046">        int[] c2 = new int[]{-1, 0, 0, 0, -1, -1, 0, -1};</span>
<span class="fc" id="L5047">        int[] d2 = new int[]{0, 1, 1, 1, 1, 0};</span>

        /*
            - - -        - -
              +        + + -
            + + +      + +        
        */
<span class="fc" id="L5054">        PairInt[][] neighborCoordOffsets</span>
<span class="fc" id="L5055">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
            0, 0);

<span class="fc" id="L5058">        int w = imageWidth;</span>
<span class="fc" id="L5059">        int h = imageHeight;</span>
<span class="fc" id="L5060">        int n = pixIdxs.size();</span>
<span class="fc" id="L5061">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L5062">        int[] dys = Misc.dy8;</span>
        
<span class="fc" id="L5064">        int nEdited = 0;</span>
<span class="fc" id="L5065">        int nIter = 0;</span>
        do {
<span class="fc" id="L5067">            nEdited = 0;</span>

            // test c1, d1 and it rotated by 90 3 times
            // test c2, d2 and it rotated by 90 3 times
            // need to alternate direction of approach
<span class="fc bfc" id="L5072" title="All 2 branches covered.">            for (int t = 0; t &lt; 2; ++t) {</span>
                int[] tmpC;
                int[] tmpD;
<span class="fc bfc" id="L5075" title="All 2 branches covered.">                if (t == 0) {</span>
<span class="fc" id="L5076">                    tmpC = Arrays.copyOf(c1, c1.length);</span>
<span class="fc" id="L5077">                    tmpD = Arrays.copyOf(d1, d1.length);</span>
                } else {
<span class="fc" id="L5079">                    tmpC = Arrays.copyOf(c2, c2.length);</span>
<span class="fc" id="L5080">                    tmpD = Arrays.copyOf(d2, d2.length);</span>
                }
<span class="fc bfc" id="L5082" title="All 2 branches covered.">                for (int r = 0; r &lt; 4; ++r) {</span>
<span class="fc bfc" id="L5083" title="All 2 branches covered.">                    if (r &gt; 0) {</span>
<span class="fc" id="L5084">                        rotatePairsBy90(tmpC);</span>
<span class="fc" id="L5085">                        rotatePairsBy90(tmpD);</span>
                    }
                    
                    // to try to make it more symmetric, collecting all
                    // nullable pixels and counting the set neighbors,
                    // then revisiting by order of fewest set neighbors 
<span class="fc" id="L5091">                    MinHeapForRT2012 heap = new MinHeapForRT2012(9, n);</span>

<span class="fc" id="L5093">                    TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L5094" title="All 2 branches covered.">                    while (iter.hasNext()) {</span>
<span class="fc" id="L5095">                        int pixIdx = iter.next();</span>
<span class="fc" id="L5096">                        int y = pixIdx/w;</span>
<span class="fc" id="L5097">                        int x = pixIdx - (y * w);</span>
<span class="fc bfc" id="L5098" title="All 2 branches covered.">                        if (allArePresent(pixIdxs, x, y, tmpC, w, h)</span>
<span class="fc bfc" id="L5099" title="All 2 branches covered.">                            &amp;&amp; allAreNotPresent(pixIdxs, x, y, tmpD, w, h)) {</span>
<span class="fc bfc" id="L5100" title="All 2 branches covered.">                            if (!ImageSegmentation.doesDisconnect(pixIdxs,</span>
                                neighborCoordOffsets, x, y, w, h)) {
                        
                                // number of neighbors that are not '1s
<span class="fc" id="L5104">                                int nn = 0;</span>
<span class="fc bfc" id="L5105" title="All 2 branches covered.">                                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L5106">                                    int x2 = x + dxs[k];</span>
<span class="fc" id="L5107">                                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L5108" title="4 of 8 branches missed.">                                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L5109">                                        continue;</span>
                                    }
<span class="fc" id="L5111">                                    int pixIdx2 = (y2 * w) + x2;</span>
<span class="fc bfc" id="L5112" title="All 2 branches covered.">                                    if (pixIdxs.contains(pixIdx2)) {</span>
<span class="fc" id="L5113">                                        nn++;</span>
                                    }
                                }

                                //long key = 8 - nn;
<span class="fc" id="L5118">                                long key = nn;</span>
<span class="fc" id="L5119">                                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L5120">                                node.setData(Integer.valueOf(pixIdx));</span>
<span class="fc" id="L5121">                                heap.insert(node);</span>
                            }
                        }
<span class="fc" id="L5124">                    }</span>
                    
<span class="fc bfc" id="L5126" title="All 2 branches covered.">                    while (heap.getNumberOfNodes() &gt; 0) {</span>
                        
<span class="fc" id="L5128">                        HeapNode node = heap.extractMin();</span>
                        
<span class="pc bpc" id="L5130" title="3 of 4 branches missed.">                        assert(node != null);</span>

<span class="fc" id="L5132">                        int pixIdx = ((Integer)node.getData()).intValue();</span>
<span class="fc" id="L5133">                        int y = pixIdx/w;</span>
<span class="fc" id="L5134">                        int x = pixIdx - (y * w);</span>
                       
<span class="pc bpc" id="L5136" title="1 of 2 branches missed.">                        if (allArePresent(pixIdxs, x, y, tmpC, w, h)</span>
<span class="pc bpc" id="L5137" title="1 of 2 branches missed.">                            &amp;&amp; allAreNotPresent(pixIdxs, x, y, tmpD, w, h)) {</span>
<span class="pc bpc" id="L5138" title="1 of 2 branches missed.">                            if (!ImageSegmentation.doesDisconnect(pixIdxs,</span>
                                neighborCoordOffsets, x, y, w, h)) {
                         
<span class="fc" id="L5141">                                pixIdxs.remove(pixIdx);</span>
<span class="fc" id="L5142">                                nEdited++;</span>
                            }
                        }
<span class="fc" id="L5145">                    }                    </span>
                }                
            }
<span class="fc" id="L5148">            nIter++;</span>
<span class="fc bfc" id="L5149" title="All 2 branches covered.">        } while (nEdited &gt; 0);</span>
<span class="fc" id="L5150">    }</span>
    
    private void rotatePairsBy90(int[] xy) {
         
        /*
        int cos90 = 0;
        int sin90 = 1;
        scale = 1
        xc = yc = 0
        rotX = - (xc*scale + (((x0-xc)*scale*math.cos(theta))
                 + ((y0-yc)*scale*math.sin(theta)))
               = - (0 + (y0-0))
               = -y0

        rotY = - (yc*scale + ((-(x0-xc)*scale*math.sin(theta))
                 + ((y0-yc)*scale*math.cos(theta)))
               = - (0 + ((-(x0-0)))
               = +x0
        */
        
<span class="fc bfc" id="L5170" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.length; i += 2) {</span>
<span class="fc" id="L5171">            int x = xy[i];</span>
<span class="fc" id="L5172">            int y = xy[i + 1];</span>
<span class="fc" id="L5173">            xy[i] = -y;</span>
<span class="fc" id="L5174">            xy[i + 1] = x;</span>
        }
<span class="fc" id="L5176">    }</span>
    
    private boolean allArePresent(TIntSet pixIdxs, int x, int y, int[] xy,
        int imgWidth, int imgHeight) {
        
<span class="fc bfc" id="L5181" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L5182">            int tx = x + xy[k];</span>
<span class="fc" id="L5183">            int ty = y + xy[k + 1];</span>
<span class="pc bpc" id="L5184" title="2 of 8 branches missed.">            if (tx &lt; 0 || ty &lt; 0 || (tx &gt; (imgWidth - 1)) || (ty &gt; (imgHeight - 1))) {</span>
<span class="fc" id="L5185">                continue;</span>
            }
<span class="fc" id="L5187">            int pixIdx2 = (ty * imgWidth) + tx;</span>
<span class="fc bfc" id="L5188" title="All 2 branches covered.">            if (!pixIdxs.contains(pixIdx2)) {</span>
<span class="fc" id="L5189">                return false;</span>
            }
        }
        
<span class="fc" id="L5193">        return true;</span>
    }
    
    private boolean allArePresent(GreyscaleImage img, int x, int y, int[] xy) {
        
<span class="fc bfc" id="L5198" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L5199">            int tx = x + xy[k];</span>
<span class="fc" id="L5200">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L5201" title="All 2 branches covered.">            if (img.getValue(tx, ty) == 0) {</span>
<span class="fc" id="L5202">                return false;</span>
            }
        }
        
<span class="fc" id="L5206">        return true;</span>
    }
    
    private boolean allArePresent(Set&lt;PairInt&gt; points, int x, int y, int[] xy) {
        
<span class="fc bfc" id="L5211" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L5212">            int tx = x + xy[k];</span>
<span class="fc" id="L5213">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L5214" title="All 2 branches covered.">            if (!points.contains(new PairInt(tx, ty))) {</span>
<span class="fc" id="L5215">                return false;</span>
            }
        }
        
<span class="fc" id="L5219">        return true;</span>
    }
    
    private boolean allAreNotPresent(GreyscaleImage img, int x, int y, int[] xy) {
        
<span class="fc bfc" id="L5224" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L5225">            int tx = x + xy[k];</span>
<span class="fc" id="L5226">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L5227" title="All 2 branches covered.">            if (img.getValue(tx, ty) != 0) {</span>
<span class="fc" id="L5228">                return false;</span>
            }
        }
        
<span class="fc" id="L5232">        return true;</span>
    }
    
    private boolean allAreNotPresent(Set&lt;PairInt&gt; points, int x, int y, int[] xy) {
        
<span class="fc bfc" id="L5237" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L5238">            int tx = x + xy[k];</span>
<span class="fc" id="L5239">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L5240" title="All 2 branches covered.">            if (points.contains(new PairInt(tx, ty))) {</span>
<span class="fc" id="L5241">                return false;</span>
            }
        }
        
<span class="fc" id="L5245">        return true;</span>
    }
    
    private boolean allAreNotPresent(TIntSet pixIdxs, int x, int y, int[] xy,
        int imgWidth, int imgHeight) {
        
<span class="fc bfc" id="L5251" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L5252">            int tx = x + xy[k];</span>
<span class="fc" id="L5253">            int ty = y + xy[k + 1];</span>
<span class="pc bpc" id="L5254" title="2 of 8 branches missed.">            if (tx &lt; 0 || ty &lt; 0 || (tx &gt; (imgWidth - 1)) || (ty &gt; (imgHeight - 1))) {</span>
<span class="fc" id="L5255">                continue;</span>
            }
<span class="fc" id="L5257">            int pixIdx2 = (ty * imgWidth) + tx;</span>
<span class="fc bfc" id="L5258" title="All 2 branches covered.">            if (pixIdxs.contains(pixIdx2)) {</span>
<span class="fc" id="L5259">                return false;</span>
            }
        }
        
<span class="fc" id="L5263">        return true;</span>
    }
    
    /**
     * NOTE: this is not the same as the scale space image
     * or inflection points in the scaleSpace package.
     * It is a very quick look at the position derivatives.
     * 
     * create a two dimensional row-major format array of curvature of the
     * image img.  Note that img is expected to have all values &gt;= 0.
     * Also note that sigma should be equal to or greater than
     * sqrt(2)/2.
     * @param img
     * @param sigma
     * @return 
     */
    public float[][] createCurvatureImage(GreyscaleImage img, float sigma) {
        
        /* curvature:
               dot is the degree of derivative...see ScaleSpaceCurvature
                      X_dot(t,o~) * Y_dot_dot(t,o~) - Y_dot(t,o~) * X_dot_dot(t,o~) 
            k(t,o~) = -------------------------------------------------------------
                                   (X_dot^2(t,o~) + Y_dot^2(t,o~))^1.5
        */
        
<span class="nc" id="L5288">        float max = img.max();</span>
        
<span class="nc bnc" id="L5290" title="All 2 branches missed.">        if (max &lt;= 0) {</span>
<span class="nc" id="L5291">            throw new IllegalArgumentException(&quot;img values must be&quot;</span>
                + &quot; &gt;= 0 and maximum must be &gt; 0&quot;);
        }
        
        // -- switch to row-major ----
<span class="nc" id="L5296">        float[][] image = multiply(img, 1.f/max);</span>
        
<span class="nc bnc" id="L5298" title="All 4 branches missed.">        assert(image.length == img.getHeight());</span>
<span class="nc bnc" id="L5299" title="All 4 branches missed.">        assert(image[0].length == img.getWidth());</span>
        
<span class="nc" id="L5301">        return createCurvatureImage(image, sigma);</span>
    }
    
    /**
     * NOTE: this is not the same as the scale space image
     * or inflection points in the scaleSpace package.
     * It is a very quick look at the position derivatives.
     *
     * create a two dimensional row-major format array of curvature of the
     * image img.  Note that img is expected to have all values &gt;= 0.
     * Also note that sigma should be equal to or greater than
     * sqrt(2)/2.
     * @param image row-major formatted image
     * @param sigma
     * @return 
     */
    public float[][] createCurvatureImage(float[][] image, float sigma) {
        
        /* curvature:
               dot is the degree of derivative...see ScaleSpaceCurvature
                      X_dot(t,o~) * Y_dot_dot(t,o~) - Y_dot(t,o~) * X_dot_dot(t,o~) 
            k(t,o~) = -------------------------------------------------------------
                                   (X_dot^2(t,o~) + Y_dot^2(t,o~))^1.5
        */
        
        // --- create Sobel derivatives (gaussian 1st deriv sqrt(2)/2 = 0.707)----
        
        // switch X and Y sobel operations for row major

<span class="fc" id="L5330">        TwoDFloatArray[] components =</span>
<span class="fc" id="L5331">            createCurvatureComponents(image, sigma);</span>
        
<span class="fc" id="L5333">        float[][] gX = components[0].a;</span>
<span class="fc" id="L5334">        float[][] gY = components[1].a;</span>
<span class="fc" id="L5335">        float[][] gX2 = components[2].a;</span>
<span class="fc" id="L5336">        float[][] gY2 = components[3].a;</span>
        
<span class="fc" id="L5338">        int nRows = gX.length;</span>
<span class="fc" id="L5339">        int nCols = gX[0].length;</span>
        
<span class="fc" id="L5341">        float[][] curvature = copy(gX);</span>
<span class="fc bfc" id="L5342" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L5343" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
                
<span class="fc" id="L5345">                float gX2gX2 = gX2[i][j] * gX2[i][j];</span>
<span class="fc" id="L5346">                float gY2gY2 = gY2[i][j] * gY2[i][j];</span>
<span class="fc bfc" id="L5347" title="All 4 branches covered.">                if (gX2gX2 == 0 &amp;&amp; gY2gY2 == 0) {</span>
<span class="fc" id="L5348">                    curvature[i][j] = Float.MAX_VALUE;</span>
<span class="fc" id="L5349">                    continue;</span>
                }
                //(dx * dy(dy) - dy * dx(dx)) / (dx(dx)*dx(dx) + dy(dy)*dy(dy))
<span class="fc" id="L5352">                curvature[i][j] = (float)(</span>
                    (gX[i][j] * gY2[i][j] - gY[i][j] * gX2[i][j])
<span class="fc" id="L5354">                    / Math.pow((gX2gX2 + gY2gY2), 1.5));</span>
            }
        }
        
<span class="fc" id="L5358">        return curvature;</span>
    }
    
    
    /**
     * create an image segmented by curvature zero-crossings.
     * calculates the curvature in O(N_pixels) but using transcendental
     * operations, and then sets the output to 255 where curvature is
     * greater than 0 and sets output to 0 where curvature is less than 0.
     * the &quot;zeroHandling&quot; parameter determines how curvature exact values
     * of 0 are handled.
     * for zeroHandling = 0, curvature equal to zero sets output to 1;
     * for zeroHandling = 1, curvature equal to zero sets output to 0;
     * for zeroHandling = 2, curvature equal to zero sets output to 255.
     * 
     * This method is used in MedialAxis1.java.
     * 
     * @param image image in row-major format.
     * @param sigma (note, the internal first derivative, first step is
     * sigma=sqrt(2)/2 so this given sigma should be that or larger.
     * @param zeroHandling allowed values are 0, 1, or 2.
     * 0 = set curvature exact zero values to value 1,
     * 1 = set curvature exact zero values to value 0,
     * 2 = set curvature exact zero values to value 255.
     * @return 
     */
    public GreyscaleImage createZeroCrossingsCurvature(float[][] image,
        float sigma, int zeroHandling) {
                
<span class="pc bpc" id="L5387" title="2 of 4 branches missed.">        if ((zeroHandling &lt; 0) || (zeroHandling &gt; 2)) {</span>
<span class="nc" id="L5388">            throw new IllegalArgumentException(&quot;zeroHandling must be &quot;</span>
                + &quot;between 0 and 2, inclusive.&quot;);
        }
        
        // -- switch to row-major until output ----
<span class="fc" id="L5393">        float[][] curvature = createCurvatureImage(image, sigma);</span>
        
<span class="fc" id="L5395">        return createZeroCrossingsCurvatureImage(curvature, zeroHandling);</span>
    }
    
    /**
     * * NOTE: this is not the same as the scale space image
     * or inflection points in the scaleSpace package.
     * It is a very quick look at the position derivative
     * zero crossings.
     *
     * create an image segmented by curvature zero-crossings.
     * calculates the curvature in O(N_pixels) but using transcendental
     * operations, and then sets the output to 255 where curvature is
     * greater than 0 and sets output to 0 where curvature is less than 0.
     * the &quot;zeroHandling&quot; parameter determines how curvature exact values
     * of 0 are handled.
     * for zeroHandling = 0, curvature equal to zero sets output to 1;
     * for zeroHandling = 1, curvature equal to zero sets output to 0;
     * for zeroHandling = 2, curvature equal to zero sets output to 255.
     * 
     * This method is used in MedialAxis1.java.
     * 
     * @param img
     * @param sigma (note, the internal first derivative, first step is
     * sigma=sqrt(2)/2 so this given sigma should be that or larger.
     * @param zeroHandling allowed values are 0, 1, or 2.
     * 0 = set curvature exact zero values to value 1,
     * 1 = set curvature exact zero values to value 0,
     * 2 = set curvature exact zero values to value 255.
     * @return 
     */
    public GreyscaleImage createZeroCrossingsCurvature(GreyscaleImage img,
        float sigma, int zeroHandling) {
                
<span class="nc bnc" id="L5428" title="All 4 branches missed.">        if ((zeroHandling &lt; 0) || (zeroHandling &gt; 2)) {</span>
<span class="nc" id="L5429">            throw new IllegalArgumentException(&quot;zeroHandling must be &quot;</span>
                + &quot;between 0 and 2, inclusive.&quot;);
        }
        
        // -- switch to row-major until output ----
<span class="nc" id="L5434">        float[][] curvature = createCurvatureImage(img, sigma);</span>
        
<span class="nc" id="L5436">        return createZeroCrossingsCurvatureImage(curvature, zeroHandling);</span>
    }
    
    /**
     * create an image segmented by curvature zero-crossings.
     * calculates the curvature in O(N_pixels) but using transcendental
     * operations, and then sets the output to 255 where curvature is
     * greater than 0 and sets output to 0 where curvature is less than 0.
     * the &quot;zeroHandling&quot; parameter determines how curvature exact values
     * of 0 are handled.
     * for zeroHandling = 0, curvature equal to zero sets output to 1;
     * for zeroHandling = 1, curvature equal to zero sets output to 0;
     * for zeroHandling = 2, curvature equal to zero sets output to 255.
     * 
     * This method is used in MedialAxis1.java.
     * 
     * @param curvature
     * @param zeroHandling allowed values are 0, 1, or 2.
     * 0 = set curvature exact zero values to value 0,
     * 1 = set curvature exact zero values to value 1,
     * 2 = set curvature exact zero values to value 255.
     * @return 
     */
    private GreyscaleImage createZeroCrossingsCurvatureImage(float[][] curvature,
        int zeroHandling) {
                
<span class="pc bpc" id="L5462" title="2 of 4 branches missed.">        if ((zeroHandling &lt; 0) || (zeroHandling &gt; 2)) {</span>
<span class="nc" id="L5463">            throw new IllegalArgumentException(&quot;zeroHandling must be &quot;</span>
                + &quot;between 0 and 2, inclusive.&quot;);
        }
        
<span class="fc" id="L5467">        int nRows = curvature.length;</span>
<span class="fc" id="L5468">        int nCols = curvature[0].length;</span>
        
<span class="fc" id="L5470">        GreyscaleImage out = new GreyscaleImage(nCols, nRows);</span>
        
<span class="fc bfc" id="L5472" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L5473" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc" id="L5474">                float v = curvature[i][j];</span>
<span class="fc bfc" id="L5475" title="All 2 branches covered.">                if (v &gt; 0) {</span>
<span class="fc" id="L5476">                    out.setValue(j, i, 255);</span>
<span class="fc bfc" id="L5477" title="All 2 branches covered.">                } else if (v == 0) {</span>
<span class="pc bpc" id="L5478" title="2 of 3 branches missed.">                    switch(zeroHandling) {</span>
                        case 0:
<span class="nc" id="L5480">                            out.setValue(j, i, 0);</span>
<span class="nc" id="L5481">                            break;</span>
                        case 1:
<span class="nc" id="L5483">                            out.setValue(j, i, 1);</span>
<span class="nc" id="L5484">                            break;</span>
                        default:
<span class="fc" id="L5486">                            out.setValue(j, i, 255);</span>
<span class="fc" id="L5487">                            break;</span>
                    }
                } else {
<span class="fc" id="L5490">                    out.setValue(j, i, 0);</span>
                }
            }
        }
        
<span class="fc" id="L5495">        return out;</span>
    }
    
    /**
     * create texture transforms from 
     * &quot;Textured Image Segmentation&quot; by Laws, 1980.
     * 
     * The transforms are combinations of filters based on
     *  L5 level = [1 4 6 4 1]     
             gaussian, binomial for sigma=1 
             B3 spline function, used in ATrous wavelet
        E5 edge  = [-1 -2 0 2 1]   
             1st deriv of gaussian, binomial for sigma=1
        S5 spot =   [-1 0 2 0 -1]  
             -1 times 2nd deriv binomial for sigma=sqrt(2)/2,... LOG
        R5 ripple = [1 -4 6 -4 1]  
              3rd deriv gaussian, ...Gabor
     
     NOTE: bright clumps in R5 R5 look useful for finding vegetation.
        It finds the bounds of the vegetation... places where the 
        the change of the change of the gradient is large (and dense).
        can apply adaptive means to the feature image to find the 
        brightest of these.
        L5 S5 looks useful for finding horizontal lines such as edge segments
        of windows.
    
     * @param img 
       @param state 0=do not process derivatives further,
       1=subtract mean, 2=subtract mean and square to make variance,
       3=make zero mean, unit standard derivative, but multiplied by
       255 to put into integer range for result.
     * @return textureTransforms 
       GreyscaleImage[]{
       L5E5/E5L5, L5S5/S5L5, L5R5/R5L5, E5E5.
       E5S5/S5E5, E5R5/R5E5, S5S5, S5R5/R5S5,
       R5R5}
     */
    public Map&lt;String, GreyscaleImage&gt; createTextureTransforms(
        GreyscaleImage img, int state) {
        
<span class="pc bpc" id="L5535" title="2 of 4 branches missed.">        if (state &lt; 0 || state &gt; 3) {</span>
<span class="nc" id="L5536">            throw new IllegalArgumentException(&quot;state must be between&quot;</span>
                + &quot;0 and 3, inclusive&quot;);
        }
        
        /*
        adapted from a cs lecture on texture filters from uw
        (https://courses.cs.washington.edu/courses/cse455/09wi/Lects/lect12.pdf
        which possibly uses:
        &quot;Statistical Texture Analysis&quot; by Srinivasan and Shobha 2008)
        
        Both contain content from &quot;Textured Image Segmentation&quot; by Laws, 1980.
        
        filters:
            L5 level = [1 4 6 4 1]     
                 gaussian, binomial for sigma=1 
                 B3 spline function, used in ATrous wavelet
            E5 edge  = [-1 -2 0 2 1]   
                 1st deriv of gaussian, binomial for sigma=1
            S5 spot =   [-1 0 2 0 -1]  
                 -1 times 2nd deriv binomial for sigma=sqrt(2)/2; a.k.a. LOG
            R5 ripple = [1 -4 6 -4 1]  
                  3rd deriv gaussian, a.k.a. Gabor
            W5 waves = [-1, 2, 0, -2, -1]

        - the 2D masks are created by multiplying the 1D masks to make a 5x5 matrix
              E5 X L5 = -1 -4 -6 -4 -1
                        -2 -8 -12 -8 -1
                         0  0  0  0   0
                         2  8  12  8  1
                         1  4  6   4  1
        - there are 9 feature vectors one could make.  can see that some compose
          tensors, and different keypoint algorithms.
        
        there are 9 feature vectors one could make.
          created by subtracting the mean neighborhood intensity from pixel
             filter the neighborhood with the 16 5 x 5 masks
             then energy at each pixel is summing abs value of filter output
                across neighbor region and storing result for the center pixel.
          The 9 features made from those 16 combinations of 4 filters are:
              L5L5, L5E5/E5L5, L5S5/S5L5, L5R5/R5L5, E5E5.
              E5S5/S5E5, E5R5/R5E5, S5S5, S5R5/R5S5,
              R5R5
        */
        
<span class="fc" id="L5580">        float[] kernelL5 = new float[]{ 1,  4, 6, 4, 1};</span>
<span class="fc" id="L5581">        float[] kernelE5 = new float[]{-1, -2, 0, 2, 1};</span>
<span class="fc" id="L5582">        float[] kernelS5 = new float[]{-1,  0, 2, 0, -1};</span>
<span class="fc" id="L5583">        float[] kernelR5 = new float[]{ 1, -4, 6, -4, 1};</span>
<span class="fc" id="L5584">        float[][] kernels = new float[4][];</span>
<span class="fc" id="L5585">        kernels[0] = kernelL5;</span>
<span class="fc" id="L5586">        kernels[1] = kernelE5;</span>
<span class="fc" id="L5587">        kernels[2] = kernelS5;</span>
<span class="fc" id="L5588">        kernels[3] = kernelR5;</span>
<span class="fc" id="L5589">        String[] labels = new String[]{&quot;L5&quot;, &quot;E5&quot;, &quot;S5&quot;, &quot;R5&quot;};</span>
                
<span class="fc" id="L5591">        Map&lt;String, GreyscaleImage&gt; transformed = new</span>
            HashMap&lt;String, GreyscaleImage&gt;();

<span class="fc bfc" id="L5594" title="All 2 branches covered.">        for (int dir = 0; dir &lt; 2; ++dir) {</span>
<span class="fc bfc" id="L5595" title="All 2 branches covered.">            for (int l0 = 0; l0 &lt; labels.length; ++l0) {</span>
<span class="fc bfc" id="L5596" title="All 2 branches covered.">                for (int l1 = l0; l1 &lt; labels.length; ++l1) {</span>
<span class="fc bfc" id="L5597" title="All 2 branches covered.">                    int i = (dir == 0) ? l0 : l1;</span>
<span class="fc bfc" id="L5598" title="All 2 branches covered.">                    int j = (dir == 0) ? l1 : l0;</span>
<span class="fc" id="L5599">                    float[] filter1 = kernels[i];</span>
<span class="fc bfc" id="L5600" title="All 4 branches covered.">                    if ((dir == 1) &amp;&amp; (i == j)) {</span>
<span class="fc" id="L5601">                        continue;</span>
                    }
<span class="fc" id="L5603">                    float[] filter2 = kernels[j];</span>
<span class="fc" id="L5604">                    GreyscaleImage img2 = img.copyToFullRangeIntImage();</span>
<span class="fc" id="L5605">                    applyKernel1D(img2, filter1, true);</span>
<span class="fc" id="L5606">                    applyKernel1D(img2, filter2, false);</span>

<span class="fc bfc" id="L5608" title="All 2 branches covered.">                    if (i != j) {</span>
<span class="fc" id="L5609">                        GreyscaleImage img3 = img.copyToFullRangeIntImage();</span>
<span class="fc" id="L5610">                        applyKernel1D(img3, filter2, true);</span>
<span class="fc" id="L5611">                        applyKernel1D(img3, filter1, false);</span>
<span class="fc" id="L5612">                        img2 = divide(img2, img3);</span>
                    }

<span class="fc" id="L5615">                    GreyscaleImage imgM = null;</span>

                    /*
                    0=do not process derivatives further,
                    1=subtract mean, 
                    2=subtract mean and square to make variance,
                    3=make zero mean, unit standard derivative, 
                      but multiplied by 255 to put into integer range for result.
                    */

<span class="pc bpc" id="L5625" title="1 of 2 branches missed.">                    if (state &gt; 0) {</span>
<span class="fc" id="L5626">                        imgM = img2.copyToFullRangeIntImage();</span>
<span class="fc" id="L5627">                        applyCenteredMean2(imgM, 2);</span>
<span class="fc" id="L5628">                        img2 = subtractImages(img2, imgM);</span>
                    }

<span class="pc bpc" id="L5631" title="1 of 2 branches missed.">                    if (state == 3) {</span>
                        // make unit standard deviation image, but mult by 255
                        // for storage in integer.
                        // NOTE: considering change of output to float array for
                        // comparison to databases
<span class="nc bnc" id="L5636" title="All 2 branches missed.">                        for (int ii = 0; ii &lt; img2.getNPixels(); ++ii) {</span>
<span class="nc" id="L5637">                            double m = imgM.getValue(ii);</span>
<span class="nc" id="L5638">                            double v = 255.*img2.getValue(ii)/(Math.sqrt(2)/m);</span>
<span class="nc" id="L5639">                            img2.setValue(ii, (int)Math.round(v));</span>
                        }
<span class="pc bpc" id="L5641" title="1 of 2 branches missed.">                    } else if (state == 2) {</span>
                        // square img2 to result in variance
<span class="fc bfc" id="L5643" title="All 2 branches covered.">                        for (int ii = 0; ii &lt; img2.getNPixels(); ++ii) {</span>
<span class="fc" id="L5644">                            int v = img2.getValue(ii);</span>
<span class="fc" id="L5645">                            v *= v;</span>
<span class="fc" id="L5646">                            img2.setValue(ii, v);</span>
                        }
                    }

<span class="fc" id="L5650">                    String label = labels[i] + labels[j];</span>

<span class="fc" id="L5652">                    transformed.put(label, img2);</span>

                    /*{
                        GreyscaleImage img3 = img2.copyImage();
                        MiscMath.rescale(img3, 0, 255);
                        MiscDebug.writeImage(img3, &quot;_&quot; + labels[i] + labels[j] + &quot;_feature_&quot;);
                        applyAdaptiveMeanThresholding(img3, 2);
                        MiscDebug.writeImage(img3, &quot;_&quot; + labels[i] + labels[j] + &quot;_feature_adap_means_&quot;);
                    }*/
                }
            }
        }
        
<span class="fc" id="L5665">        return transformed;</span>
    }
    
    public void exploreTextures() throws IOException {
        
        /*
        textures in frequency space:
        need to simplify the number of points contributing to the
        frequency domain pattern,
        so will calculate key points as sparse representation.
        */
        
<span class="fc" id="L5677">        int maxDimension = 256;//512;</span>
        
<span class="fc" id="L5679">        String fileName1 = &quot;android_statues_02.jpg&quot;;</span>
<span class="fc" id="L5680">        fileName1 = &quot;merton_college_I_001.jpg&quot;;</span>
<span class="fc" id="L5681">        String filePath1 = ResourceFinder.findFileInTestResources(fileName1);</span>
<span class="fc" id="L5682">        GreyscaleImage img = ImageIOHelper.readImageAsGrayScaleAvgRGB(filePath1);</span>
        
<span class="fc" id="L5684">        long ts = MiscDebug.getCurrentTimeFormatted();</span>

<span class="fc" id="L5686">        int w1 = img.getWidth();</span>
<span class="fc" id="L5687">        int h1 = img.getHeight();</span>

<span class="fc" id="L5689">        int binFactor1 = (int) Math.ceil(Math.max(</span>
            (float) w1 / maxDimension,
            (float) h1 / maxDimension));

<span class="fc" id="L5693">        img = binImage(img, binFactor1);</span>
        
<span class="fc" id="L5695">        float max = img.max();</span>
        
<span class="pc bpc" id="L5697" title="1 of 2 branches missed.">        if (max &lt;= 0) {</span>
<span class="nc" id="L5698">            throw new IllegalArgumentException(&quot;img values must be&quot;</span>
                + &quot; &gt;= 0 and maximum must be &gt; 0&quot;);
        }
        
<span class="fc" id="L5702">        int nRows = img.getHeight();</span>
<span class="fc" id="L5703">        int nCols = img.getWidth();</span>
        
        // axis 0 coordinates
<span class="fc" id="L5706">        TIntList keypoints0 = new TIntArrayList();</span>
        
        // axis 1 coordinates
<span class="fc" id="L5709">        TIntList keypoints1 = new TIntArrayList();</span>
        
        /*ORB orb = new ORB(10000);
        orb.overrideToNotCreateDescriptors();
        orb.overrideToAlsoCreate1stDerivKeypoints();
        //orb.overrideToCreateCurvaturePoints();
        orb.detectAndExtract(img.copyToColorGreyscale());
        keypoints0.addAll(orb.getAllKeyPoints0());
        keypoints1.addAll(orb.getAllKeyPoints1());
        */
        
<span class="fc" id="L5720">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
<span class="fc" id="L5721">        EdgeFilterProducts products = imageSegmentation.createGradient(</span>
<span class="fc" id="L5722">            img.copyToColorGreyscaleExt(), 2, ts);</span>
                
<span class="fc" id="L5724">        GreyscaleImage gradient = products.getGradientXY();</span>
        
<span class="fc" id="L5726">        float sigma = SIGMA.getValue(SIGMA.ZEROPOINTSEVENONE);</span>
        
        // -- switch to row-major ----
<span class="fc" id="L5729">        float[][] image = multiply(img, 1.f/max);</span>
                
        //  strong high density responses in r5r5 for edges of vegetation.
        //  textures such as bricks or roof tiles are present in r5r5
        //  but so are strong edges, so possibly need
        //  to use the gradient edges here to distinguish between
        //  corner and the numerous points that are not good matching
        //  points.
        
        // thresh is usually 0.01f
        //createCurvatureKeyPoints(image, sigma, keypoints0, keypoints1, 
        //   0.001f);
        
<span class="fc" id="L5742">        createR5R5KeyPoints(image, keypoints0, keypoints1);</span>
        //createE5E5KeyPoints(image, keypoints0, keypoints1);
        //createL5E5KeyPoints(image, keypoints0, keypoints1);
        //createS5S5KeyPoints(image, keypoints0, keypoints1);        
        //createFirstDerivKeyPoints(image, sigma, keypoints0, keypoints1);
        
        //Image kpImg = img.copyToColorGreyscale();
<span class="fc" id="L5749">        Image kpImg = gradient.copyToColorGreyscale();</span>
<span class="fc bfc" id="L5750" title="All 2 branches covered.">        for (int i = 0; i &lt; keypoints0.size(); ++i) {</span>
<span class="fc" id="L5751">            int x = keypoints1.get(i);</span>
<span class="fc" id="L5752">            int y = keypoints0.get(i);</span>
<span class="fc" id="L5753">            kpImg.setRGB(x, y, 255, 0, 0);</span>
        }
<span class="fc" id="L5755">        MiscDebug.writeImage(kpImg, &quot;_keypoints_1_&quot;);</span>
        
        /*
        Complex1D[] ccOut = create2DFFT2WithSwapMajor(kpImg, true);

        assert(nRows == ccOut[0].x.length);
        assert(nCols == ccOut.length);
        
        double[][] kpFreqR = new double[nCols][];
        double[][] kpFreqI = new double[nCols][];
        for (int i0 = 0; i0 &lt; ccOut.length; ++i0) {
            kpFreqR[i0] = new double[nRows];
            kpFreqI[i0] = new double[nRows];
            for (int i1 = 0; i1 &lt; nRows; ++i1) {
                kpFreqR[i0][i1] = ccOut[i0].x[i1];
                kpFreqI[i0][i1] = ccOut[i0].y[i1];
            }
        }
        
        TIntList plotRows = new TIntArrayList();
        TIntList plotCols = new TIntArrayList();
        plotRows.add(10);
        plotRows.add(50);
        plotRows.add(100);
        plotRows.add(110);
        
        plotCols.add(10);
        plotCols.add(50);
        plotCols.add(100);
        plotCols.add(150);
        plotCols.add(200);
        plotCols.add(210);
        
        String lbl = &quot;keypoints_freq&quot;;
        
        MiscDebug.plot(kpFreqR, plotCols, plotRows, lbl);
       
        MiscMath.applyRescale(kpFreqR, 0, 255);
        Image kpFreqRImg = img.copyToColorGreyscale();
        for (int i = 0; i &lt; nCols; ++i) {
            for (int j = 0; j &lt; nRows; ++j) {
                kpFreqRImg.setRGB(i, j, (int)Math.round(kpFreqR[i][j]), 0, 0);
            }
        }
        MiscDebug.writeImage(kpFreqRImg, &quot;_keypoints_freq_&quot;);
        */
        
   /*
        // ---- edited _keypoints_1_ image to keep only a characteristic section ---
        String filePath = ResourceFinder.findFileInTestResources(
            &quot;vegetation_peak_texture.png&quot;);
        
        GreyscaleImage imgPattern = ImageIOHelper.readImage(
            filePath).copyToGreyscale();
        
        Complex[][] fftPattern = PhaseCongruencyDetector
            .createLowPassFreqDomainFilter(imgPattern);
       
        PeriodicFFT perfft2 = new PeriodicFFT();
        Complex[][][] perfResults = perfft2.perfft2(img, false);
        Complex[][] fftImage = perfResults[1];
        
        // --- image in the frequency domain convolved with texture patch ----
        Complex[][] freqDomainImageTimesPattern = 
            convolveWithKernel(fftImage, fftPattern);
        
        // ----- transform that to spatial domain ----
        Complex[][] fComplex = create2DFFT(freqDomainImageTimesPattern, false, false);    
        double[][] transformedReal = new double[nCols][];
        for (int i0 = 0; i0 &lt; nCols; ++i0) {
            transformedReal[i0] = new double[nRows];
            for (int i1 = 0; i1 &lt; nRows; ++i1) {
                transformedReal[i0][i1] = fComplex[i1][i0].abs();
            }
        }
        
        MiscMath.applyRescale(transformedReal, 0, 255);
        GreyscaleImage kpFreqR2Img = new GreyscaleImage(nCols, nRows);
        for (int i = 0; i &lt; nCols; ++i) {
            for (int j = 0; j &lt; nRows; ++j) {
                kpFreqR2Img.setValue(i, j, 
                    (int)Math.round(transformedReal[i][j]));
            }
        }
        MiscDebug.writeImage(kpFreqR2Img, &quot;_keypoints_freq2_spatial_&quot;);
    */
<span class="fc" id="L5841">    }</span>
    
    /**
     * 
     * @param image
     * @param sigma
     * @param outputKeypoints0
     * @param outputKeypoints1
     * @param thresholdRel default is 0.01f
     */
    public void createCurvatureKeyPoints(float[][] image, float sigma,
        TIntList outputKeypoints0, TIntList outputKeypoints1,
        float thresholdRel) {
        
<span class="nc" id="L5855">        boolean doCreateCurvatureKeyPoints = true;</span>
        
<span class="nc" id="L5857">        StructureTensor tensorComponents = new StructureTensor(image, </span>
            sigma, doCreateCurvatureKeyPoints);
        
<span class="nc" id="L5860">        createCurvatureKeyPoints(tensorComponents, outputKeypoints0,</span>
            outputKeypoints1, thresholdRel);
<span class="nc" id="L5862">    }</span>
    
    /**
     * 
     * @param tensorComponents
     * @param outputKeypoints0
     * @param outputKeypoints1
     * @param thresholdRel default is 0.01f
     */
    public void createCurvatureKeyPoints(StructureTensor tensorComponents,
        TIntList outputKeypoints0, TIntList outputKeypoints1,
        float thresholdRel) {
        
        // square of 1st deriv:
        //float[][] firstDeriv = add(tensorComponents.getDXSquared(), 
        //    tensorComponents.getDYSquared());
        //float max1stDeriv = MiscMath.findMax(firstDeriv);
        //float f = max1stDeriv / 10;

<span class="nc" id="L5881">        float[][] dx = tensorComponents.getDX();</span>
<span class="nc" id="L5882">        float[][] dx2 = tensorComponents.getDDX();</span>
<span class="nc" id="L5883">        float[][] dy = tensorComponents.getDY();</span>
<span class="nc" id="L5884">        float[][] dy2 = tensorComponents.getDDY();</span>
<span class="nc" id="L5885">        float[][] curvature = copy(dx);</span>
        
<span class="nc" id="L5887">        int nRows = dx.length;</span>
<span class="nc" id="L5888">        int nCols = dx[0].length;</span>
        
<span class="nc bnc" id="L5890" title="All 2 branches missed.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="nc bnc" id="L5891" title="All 2 branches missed.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="nc" id="L5892">                float dx2dx2 = dx2[i][j] * dx2[i][j];</span>
<span class="nc" id="L5893">                float dy2dy2 = dy2[i][j] * dy2[i][j];</span>
<span class="nc bnc" id="L5894" title="All 4 branches missed.">                if (dx2dx2 == 0 &amp;&amp; dy2dy2 == 0) {</span>
<span class="nc" id="L5895">                    curvature[i][j] = Float.MAX_VALUE;</span>
<span class="nc" id="L5896">                    continue;</span>
                }
                //(dx * dy(dy) - dy * dx(dx)) / (dx(dx)*dx(dx) + dy(dy)*dy(dy))^1.5
<span class="nc" id="L5899">                curvature[i][j] = (</span>
                    (dx[i][j] * dy2[i][j] - dy[i][j] * dx2[i][j])
                    / (dx2dx2 + dy2dy2));
                    /// Math.pow((dx2dx2 + dy2dy2), 1.5));
            }
        }

<span class="nc" id="L5906">        peakLocalMax(curvature, 1, thresholdRel, outputKeypoints0, </span>
            outputKeypoints1);
        
        /*{// DEBUG
            float[][] a = copy(curvature);
            System.out.println(&quot;min=&quot; + MiscMath.findMin(a) + &quot; max=&quot; + MiscMath.findMax(a));
            MiscMath.applyAbsoluteValue(a);
            MiscMath.applyRescale(a, 0, 255);
            MiscDebug.writeImage(a, &quot;_curvature_&quot; 
                + MiscDebug.getCurrentTimeFormatted());
        }*/
        
        /*MiscMath.applyRescale(curvature, 0, 255);
        GreyscaleImage kpImg = new GreyscaleImage(nCols, nRows);
        for (int i = 0; i &lt; outputKeypoints0.size(); ++i) {
            int x = outputKeypoints1.get(i);
            int y = outputKeypoints0.get(i);
            kpImg.setValue(x, y, Math.round(curvature[y][x]));
        }
        MiscDebug.writeImage(kpImg, &quot;_curvature_&quot;);
        */
<span class="nc" id="L5927">    }</span>
    
    public void createR5R5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {
        
        //3rd deriv gaussian, a.k.a. Gabor
<span class="fc" id="L5933">        float[] kernel = new float[]{ 1, -4, 6, -4, 1};</span>
        
<span class="fc" id="L5935">        createLawKeyPoints(image, kernel, kernel, outputKeypoints0, </span>
            outputKeypoints1);
<span class="fc" id="L5937">    }</span>
    
    public void createS5S5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {
        
        //-1 times 2nd deriv binomial for sigma=sqrt(2)/2; a.k.a. LOG
<span class="nc" id="L5943">        float[] kernel = new float[]{-1, 0, 2, 0, -1};</span>
        
<span class="nc" id="L5945">        createLawKeyPoints(image, kernel, kernel, outputKeypoints0, </span>
            outputKeypoints1);
<span class="nc" id="L5947">    }</span>
    
    public void createE5E5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {
        
        //1st deriv of gaussian, binomial for sigma=1
<span class="nc" id="L5953">        float[] kernel = new float[]{-1, -2, 0, 2, 1};</span>
        
<span class="nc" id="L5955">        createLawKeyPoints(image, kernel, kernel, outputKeypoints0, </span>
            outputKeypoints1);
<span class="nc" id="L5957">    }</span>
    
    public void createL5E5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {
        
        //1st deriv of gaussian, binomial for sigma=1
<span class="nc" id="L5963">        float[] kernelE5 = new float[]{-1, -2, 0, 2, 1};</span>
        
        // gaussian, binomial for sigma=1; B3 spline used in ATrous wavelet
<span class="nc" id="L5966">        float[] kernelL5 = new float[]{1, 4, 6, 4, 1};</span>
        
<span class="nc" id="L5968">        createLawKeyPoints(image, kernelL5, kernelE5, outputKeypoints0, </span>
            outputKeypoints1);
<span class="nc" id="L5970">    }</span>
    
    private void createLawKeyPoints(float[][] image, float[] kernel1,
        float[] kernel2,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {
        
<span class="fc" id="L5976">        float[][] image2 = copy(image);</span>
        
        // row major, so need to use y operations for x and vice versa
<span class="fc" id="L5979">        applyKernel1D(image2, kernel1, true);</span>
<span class="fc" id="L5980">        applyKernel1D(image2, kernel2, false);</span>
        
        /*if (!Arrays.equals(kernel1, kernel2)) {
            float[][] image3 = copy(image2);
            applyKernel1D(image3, kernel1, false);
            applyKernel1D(image3, kernel2, true);
            image2 = divide(image2, image3);
        }*/
  
        // put float back into integer scale, 0 to 255
<span class="fc" id="L5990">        MiscMath.applyRescale2(image2, 0, 255);</span>
        
<span class="fc" id="L5992">        int nCols = image2.length;</span>
<span class="fc" id="L5993">        int nRows = image2[0].length;</span>
        
<span class="fc" id="L5995">        GreyscaleImage imageM = new GreyscaleImage(nCols, nRows);</span>
<span class="fc bfc" id="L5996" title="All 2 branches covered.">        for (int i = 0; i &lt; nCols; ++i) {</span>
<span class="fc bfc" id="L5997" title="All 2 branches covered.">            for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc" id="L5998">                imageM.setValue(i, j, Math.round(image2[i][j]));</span>
            }
        }
        
<span class="fc" id="L6002">        applyCenteredMean2(imageM, 2);</span>
       
        // subtract mean
<span class="fc bfc" id="L6005" title="All 2 branches covered.">        for (int i = 0; i &lt; nCols; ++i) {</span>
<span class="fc bfc" id="L6006" title="All 2 branches covered.">            for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc" id="L6007">                image2[i][j] -= imageM.getValue(i, j);</span>
            }
        }
                   
        // NOTE: square image2 to result in variance if preferred.
<span class="fc bfc" id="L6012" title="All 2 branches covered.">        for (int i = 0; i &lt; image2.length; ++i) {</span>
<span class="fc bfc" id="L6013" title="All 2 branches covered.">            for (int j = 0; j &lt; image2[i].length; ++j) {</span>
<span class="fc" id="L6014">                float v = image2[i][j];</span>
                //v *= v;
<span class="fc" id="L6016">                image2[i][j] = v;</span>
            }
        }
       
<span class="fc" id="L6020">        GreyscaleImage img2 = imageM.createFullRangeIntWithDimensions();</span>
<span class="fc bfc" id="L6021" title="All 2 branches covered.">        for (int i = 0; i &lt; image2.length; ++i) {</span>
<span class="fc bfc" id="L6022" title="All 2 branches covered.">            for (int j = 0; j &lt; image2[i].length; ++j) {</span>
<span class="fc" id="L6023">                float v = image2[i][j];</span>
<span class="fc" id="L6024">                img2.setValue(i, j, Math.round(v));</span>
            }
        }
            
        // use adaptive means to extract centers
<span class="fc" id="L6029">        applyAdaptiveMeanThresholding(img2, 1);</span>
<span class="fc bfc" id="L6030" title="All 2 branches covered.">        for (int i = 3; i &lt; img2.getWidth(); ++i) {</span>
<span class="fc bfc" id="L6031" title="All 2 branches covered.">            for (int j = 3; j &lt; img2.getHeight(); ++j) {</span>
<span class="fc bfc" id="L6032" title="All 2 branches covered.">                if (img2.getValue(i, j) == 0) {</span>
<span class="fc" id="L6033">                    outputKeypoints0.add(i);</span>
<span class="fc" id="L6034">                    outputKeypoints1.add(j);</span>
                }
            }
        }

        // or, extract many points all over the image:
        //peakLocalMax(image2, 1, 0.01f, outputKeypoints0, 
        //    outputKeypoints1);
<span class="fc" id="L6042">    }</span>
    
    /**
     * return first derivatives from sigma=sqrt(2)/2 and
     * then second derivatives with sigma convolved from the
     * first derivatives.
     * @param image
     * @param sigma
     * @return [d/dx, d/dy, d/dx(dx), d/dy(dy)]
     */
    protected TwoDFloatArray[] createCurvatureComponents(
        float[][] image, float sigma) {

        // --- create Sobel derivatives (gaussian 1st deriv sqrt(2)/2 = 0.707)----
        
        // switch X and Y sobel operations for row major

<span class="fc" id="L6059">        float[][] gX = copy(image);</span>
<span class="fc" id="L6060">        applySobelY(gX);</span>

<span class="fc" id="L6062">        float[][] gY = copy(image);</span>
<span class="fc" id="L6063">        applySobelX(gY);</span>

<span class="fc" id="L6065">        float[] kernel = Gaussian1D.getKernel(sigma);</span>
       
        // for curvature, need d/dy(dy) and d/dx(dx)
        
<span class="fc" id="L6069">        float[][] gX2 = copy(gX);</span>
<span class="fc" id="L6070">        float[][] gY2 = copy(gY);</span>
        
        // row major, so need to use y operations for x and vice versa
<span class="fc" id="L6073">        applyKernel1D(gX2, kernel, false);</span>
<span class="fc" id="L6074">        applyKernel1D(gY2, kernel, true);</span>
        
<span class="fc" id="L6076">        TwoDFloatArray[] components = new TwoDFloatArray[4];</span>
<span class="fc" id="L6077">        components[0] = new TwoDFloatArray(gX);</span>
<span class="fc" id="L6078">        components[1] = new TwoDFloatArray(gY);</span>
<span class="fc" id="L6079">        components[2] = new TwoDFloatArray(gX2);</span>
<span class="fc" id="L6080">        components[3] = new TwoDFloatArray(gY2);</span>
        
<span class="fc" id="L6082">        return components;</span>
    }
    
    public GreyscaleImage divide(GreyscaleImage img1, GreyscaleImage img2) {
        
<span class="pc bpc" id="L6087" title="1 of 2 branches missed.">        if (img1.getNPixels() != img2.getNPixels() || img1.getWidth() != </span>
<span class="pc bpc" id="L6088" title="2 of 4 branches missed.">            img2.getWidth() || img1.getHeight() != img2.getHeight()) {</span>
<span class="nc" id="L6089">            throw new IllegalArgumentException(&quot;img1 and img2 must be same size&quot;);</span>
        }
        
<span class="fc" id="L6092">        int n = img1.getNPixels();</span>
        
<span class="fc" id="L6094">        GreyscaleImage out = img1.copyToFullRangeIntImage();</span>

<span class="fc bfc" id="L6096" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L6097">            int v = out.getValue(i);</span>
<span class="fc" id="L6098">            int v2 = img2.getValue(i);</span>
<span class="fc bfc" id="L6099" title="All 2 branches covered.">            if (v2 &gt; 0) {</span>
<span class="fc" id="L6100">                v /= v2;                </span>
            }
<span class="fc" id="L6102">            out.setValue(i, v);</span>
        }
        
<span class="fc" id="L6105">        return out;</span>
    }
    
    public float[][] copy(float[][] a) {

<span class="fc" id="L6110">        int n1 = a.length;</span>
<span class="fc" id="L6111">        int n2 = a[0].length;</span>

<span class="fc" id="L6113">        float[][] out = new float[n1][n2];</span>
<span class="fc bfc" id="L6114" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L6115">            out[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="fc" id="L6118">        return out;</span>
    }
    
    public double[][] copyToDouble(float[][] a) {

<span class="nc" id="L6123">        int n1 = a.length;</span>
<span class="nc" id="L6124">        int n2 = a[0].length;</span>

<span class="nc" id="L6126">        double[][] out = new double[n1][n2];</span>
<span class="nc bnc" id="L6127" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc" id="L6128">            out[i] = new double[n2];</span>
<span class="nc bnc" id="L6129" title="All 2 branches missed.">            for (int j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L6130">                out[i][j] = a[i][j];</span>
            }
        }

<span class="nc" id="L6134">        return out;</span>
    }

    public float[][] multiply(float[][] a, float[][] b) {

<span class="fc" id="L6139">        float[][] c = copy(a);</span>

<span class="fc bfc" id="L6141" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="fc bfc" id="L6142" title="All 2 branches covered.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="fc" id="L6143">                c[i][j] *= b[i][j];</span>
            }
        }

<span class="fc" id="L6147">        return c;</span>
    }

    public float[][] divide(float[][] a, float[][] b) {

<span class="nc" id="L6152">        float[][] c = copy(a);</span>

<span class="nc bnc" id="L6154" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc bnc" id="L6155" title="All 2 branches missed.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="nc" id="L6156">                float v = b[i][j];</span>
<span class="nc bnc" id="L6157" title="All 2 branches missed.">                if (v == 0) {</span>
<span class="nc" id="L6158">                    c[i][j] = Float.MAX_VALUE;</span>
                } else {
<span class="nc" id="L6160">                    c[i][j] /= v;</span>
                }
            }
        }

<span class="nc" id="L6165">        return c;</span>
    }

    public float[][] add(float[][] a, float[][] b) {

<span class="fc" id="L6170">        float[][] c = copy(a);</span>

<span class="fc bfc" id="L6172" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="fc bfc" id="L6173" title="All 2 branches covered.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="fc" id="L6174">                c[i][j] += b[i][j];</span>
            }
        }

<span class="fc" id="L6178">        return c;</span>
    }

    public float[][] subtract(float[][] a, float[][] b) {

<span class="fc" id="L6183">        float[][] c = copy(a);</span>

<span class="fc bfc" id="L6185" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="fc bfc" id="L6186" title="All 2 branches covered.">            for (int j = 0; j &lt; c[0].length; ++j) {</span>
<span class="fc" id="L6187">                c[i][j] -= b[i][j];</span>
            }
        }

<span class="fc" id="L6191">        return c;</span>
    }
    
    public TIntSet convertPointsToIndexes(Set&lt;PairInt&gt; points, int width) {
<span class="fc" id="L6195">        TIntSet set = new TIntHashSet(points.size());</span>
<span class="fc bfc" id="L6196" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L6197">            int pixIdx = (p.getY() * width) + p.getX();</span>
<span class="fc" id="L6198">            set.add(pixIdx);</span>
<span class="fc" id="L6199">        }</span>
<span class="fc" id="L6200">        return set;</span>
    }
    
    public Set&lt;PairInt&gt; convertIndexesToPoints(TIntSet pixIdxs, int width) {
<span class="fc" id="L6204">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L6205">        TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L6206" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L6207">            int pixIdx = iter.next();</span>
<span class="fc" id="L6208">            int y = pixIdx/width;</span>
<span class="fc" id="L6209">            int x = pixIdx - (pixIdx * width);</span>
<span class="fc" id="L6210">            set.add(new PairInt(x, y));</span>
<span class="fc" id="L6211">        }</span>
<span class="fc" id="L6212">        return set;</span>
    }
    
    /**
     Find peaks in an image as coordinate list 
     Peaks are the local maxima in a region of `2 * min_distance + 1`
     (i.e. peaks are separated by at least `min_distance`).
     If peaks are flat (i.e. multiple adjacent pixels have identical
     intensities), the coordinates of all such pixels are returned.
     If both `threshold_abs` and `threshold_rel` are provided, the maximum
     of the two is chosen as the minimum intensity threshold of peaks.

      adapted from
     https://github.com/scikit-image/scikit-image/blob/92a38515ac7222aab5e606f9de46caf5f503a7bd/skimage/feature/peak.py

     The implementation below is adapted from the scipy implementation which has
     * the following copyright:

     https://github.com/scikit-image/scikit-image/blob/master/LICENSE.txt

    -- begin scipy, skimage copyright ---
    Unless otherwise specified by LICENSE.txt files in individual
    directories, all code is

    Copyright (C) 2011, the scikit-image team
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in
        the documentation and/or other materials provided with the
        distribution.
     3. Neither the name of skimage nor the names of its contributors may be
        used to endorse or promote products derived from this software without
        specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
    -- end scipy, skimage copyright ---

    Note, in some places, scipy functions have been
    replaced with existing functions in this project in this implementation below.


     * @param img
     * @param minDistance
        Minimum number of pixels separating peaks in a region of `2 *
        min_distance + 1` (i.e. peaks are separated by at least
        `min_distance`).
        To find the maximum number of peaks, use `min_distance=1`.
      @param outputKeypoints0 the output row coordinates of keypoints
     * @param outputKeypoints1 the output col coordinates of keypoints
     */
    public void peakLocalMax(float[][] img, int minDistance,
        float thresholdRel,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

<span class="fc" id="L6283">        int excludeBorder = minDistance;</span>
<span class="fc" id="L6284">        int numPeaks = Integer.MAX_VALUE;</span>
        //int numPeaksPerLabel = Integer.MAX_VALUE;

        /*
        The peak local maximum function returns the coordinates of local peaks
        (maxima) in an image. A maximum filter is used for finding local maxima.
        This operation dilates the original image. After comparison of the dilated
        and original image, this function returns the coordinates or a mask of the
        peaks where the dilated image equals the original image.
        */

<span class="fc" id="L6295">        int nRows = img.length;</span>
<span class="fc" id="L6296">        int nCols = img[0].length;</span>

        //# Non maximum filter
<span class="fc" id="L6299">        int size = 2 * minDistance + 1;</span>
<span class="fc" id="L6300">        float[][] imageMax = maximumFilter(img, size);</span>
<span class="pc bpc" id="L6301" title="3 of 4 branches missed.">        assert(nRows == imageMax.length);</span>
<span class="pc bpc" id="L6302" title="3 of 4 branches missed.">        assert(nCols == imageMax[0].length);</span>
        //mask = image == image_max

        //debugPrint(&quot;before shift imageMax=&quot;, imageMax);

        // a fudge to match results of scipy which must store same windows at
        // locations shifted by minDistance or so in x and y from the
        // beginning of the sliding window
<span class="fc" id="L6310">        applyShift(imageMax, minDistance, nRows, nCols);</span>

        /*
        {//DEBUG
            float min = MiscMath.findMin(img);
            float max = MiscMath.findMax(img);
            System.out.println(&quot;min=&quot; + min + &quot; max=&quot; + max);
            float[][] img2 = copy(img);
            MiscMath.applyRescale(img2, 0, 255);
            GreyscaleImage gsImg = new GreyscaleImage(nRows, nCols);
            for (int i = 0; i &lt; nRows; ++i) {
                for (int j = 0; j &lt; nCols; ++j) {
                    int v = Math.round(img2[i][j]);
                    if (v &gt; 255) {
                        v = 255;
                    }
                    gsImg.setValue(i, j, v);
                }
            }
            MiscDebug.writeImage(gsImg, &quot;_CURVATURE_&quot;);
        }*/

        //TODO: should be able to simplify the mask here

        // 1's where same, else 0's
<span class="fc" id="L6335">        int[][] mask = new int[nRows][nCols];</span>
<span class="fc bfc" id="L6336" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L6337">            mask[i] = new int[nCols];</span>
<span class="fc bfc" id="L6338" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc bfc" id="L6339" title="All 2 branches covered.">                if (img[i][j] == imageMax[i][j]) {</span>
<span class="fc" id="L6340">                    mask[i][j] = 1;</span>
                }
            }
        }

        //debugPrint(&quot;0 mask=&quot;, mask);


        // exclude border
<span class="fc bfc" id="L6349" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L6350" title="All 4 branches covered.">            if ((i &lt; excludeBorder) || (i &gt; (nRows - 1 - excludeBorder))){</span>
<span class="fc" id="L6351">                Arrays.fill(mask[i], 0);</span>
            } else {
<span class="fc" id="L6353">                Arrays.fill(mask[i], 0, excludeBorder, 0);</span>
<span class="fc" id="L6354">                Arrays.fill(mask[i], nCols - excludeBorder, nCols, 0);</span>
            }
        }


        // find top peak candidates above a threshold.
        // TODO: should this use mask so excluding borders?
<span class="fc" id="L6361">        float thresholdAbs = MiscMath.findMin(img);</span>
<span class="fc" id="L6362">        float thresholdMax = thresholdRel * MiscMath.findMax(img);</span>
<span class="fc" id="L6363">        thresholdAbs = Math.max(thresholdAbs, thresholdMax);</span>

        // mask &amp;= image &gt; 0.1
<span class="fc bfc" id="L6366" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L6367" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc bfc" id="L6368" title="All 2 branches covered.">                if (imageMax[i][j] &gt; thresholdAbs) {</span>
<span class="fc" id="L6369">                    mask[i][j] &amp;= 1;</span>
                } else {
<span class="fc" id="L6371">                    mask[i][j] = 0;</span>
                }
            }
        }

        /*
        {//DEBUG
            try{
            int min = MiscMath.findMin(mask);
            int max = MiscMath.findMax(mask);
            System.out.println(&quot;min=&quot; + min + &quot; max=&quot; + max);
            float factor = 255.f;
            GreyscaleImage gsImg = new GreyscaleImage(nRows, nCols);
            for (int i = 0; i &lt; nRows; ++i) {
                for (int j = 0; j &lt; nCols; ++j) {
                    int v = Math.round(factor * mask[i][j]);
                    if (v &gt; 255) {
                        v = 255;
                    }
                    gsImg.setValue(i, j, v);
                }
            }
            ImageDisplayer.displayImage(&quot;mask&quot;, gsImg);
            int z = 1;
            } catch(Exception e) {}
        }
        */

        //debugPrint(&quot;mask &amp;= image &gt; &quot; + thresholdAbs, mask);

        // Select highest intensities (num_peaks)
        // expected output is [row index, col index, ...]

        //TODO: should num_peaks be this.nKeypoints?  re-read paper...
<span class="pc bpc" id="L6405" title="1 of 2 branches missed.">        if (numPeaks == Integer.MAX_VALUE) {</span>
            // find non-zero pixels in mask
<span class="fc" id="L6407">            float[] values = new float[nRows * nCols];</span>
<span class="fc" id="L6408">            int[] pixIdxs = new int[values.length];</span>
<span class="fc" id="L6409">            int count = 0;</span>
<span class="fc bfc" id="L6410" title="All 2 branches covered.">            for (int i = 0; i &lt; mask.length; ++i) {</span>
<span class="fc bfc" id="L6411" title="All 2 branches covered.">                for (int j = 0; j &lt; mask[i].length; ++j) {</span>
<span class="fc bfc" id="L6412" title="All 2 branches covered.">                    if (mask[i][j] &gt; 0.f) {</span>
<span class="fc" id="L6413">                        values[count] = img[i][j];</span>
                        //(row * width) + col
<span class="fc" id="L6415">                        pixIdxs[count] = (j * nRows) + i;</span>
<span class="fc" id="L6416">                        count++;</span>
                    }
                }
            }
<span class="fc" id="L6420">            values = Arrays.copyOf(values, count);</span>
<span class="fc" id="L6421">            pixIdxs = Arrays.copyOf(pixIdxs, count);</span>
<span class="fc" id="L6422">            MultiArrayMergeSort.sortByDecr(values, pixIdxs);</span>
<span class="fc bfc" id="L6423" title="All 2 branches covered.">            for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L6424">                int pixIdx = pixIdxs[i];</span>
<span class="fc" id="L6425">                int jj = pixIdx/nRows;</span>
<span class="fc" id="L6426">                int ii = pixIdx - (jj * nRows);</span>
<span class="fc" id="L6427">                outputKeypoints0.add(ii);</span>
<span class="fc" id="L6428">                outputKeypoints1.add(jj);</span>
            }
<span class="fc" id="L6430">        } else {</span>
            //need to sort to keep top numPeaks
<span class="nc" id="L6432">            FixedSizeSortedVector&lt;ORB.Pix&gt; vec = new</span>
                FixedSizeSortedVector&lt;ORB.Pix&gt;(numPeaks, ORB.Pix.class);
<span class="nc bnc" id="L6434" title="All 2 branches missed.">            for (int i = 0; i &lt; mask.length; ++i) {</span>
<span class="nc bnc" id="L6435" title="All 2 branches missed.">                for (int j = 0; j &lt; mask[i].length; ++j) {</span>
<span class="nc bnc" id="L6436" title="All 2 branches missed.">                    if (mask[i][j] &gt; 0.f) {</span>
<span class="nc" id="L6437">                        ORB.Pix pix = new ORB.Pix(i, j, Float.valueOf(img[i][j]));</span>
<span class="nc" id="L6438">                        vec.add(pix);</span>
                    }
                }
            }
<span class="nc bnc" id="L6442" title="All 2 branches missed.">            for (int i = 0; i &lt; vec.getNumberOfItems(); ++i) {</span>
<span class="nc" id="L6443">                ORB.Pix pix = vec.getArray()[i];</span>
<span class="nc" id="L6444">                outputKeypoints0.add(pix.i);</span>
<span class="nc" id="L6445">                outputKeypoints1.add(pix.j);</span>
            }
        }
<span class="fc" id="L6448">    }</span>

    private void applyShift(float[][] imageMax, int minDistance, int nRows,
        int nCols) {

<span class="fc bfc" id="L6453" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L6454">            System.arraycopy(imageMax[i], 0, imageMax[i], minDistance,</span>
                nCols - minDistance);
<span class="fc bfc" id="L6456" title="All 2 branches covered.">            for (int j = 0; j &lt; minDistance; ++j) {</span>
<span class="fc" id="L6457">                imageMax[i][j] = 0;</span>
            }
<span class="fc bfc" id="L6459" title="All 2 branches covered.">            for (int j = (nCols - minDistance); j &lt; nCols; ++j) {</span>
<span class="fc" id="L6460">                imageMax[i][j] = 0;</span>
            }
        }
        //debugPrint(&quot;shift 0 imageMax=&quot;, imageMax);
<span class="fc bfc" id="L6464" title="All 2 branches covered.">        for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc bfc" id="L6465" title="All 2 branches covered.">            for (int i = (nRows - minDistance); i &gt;= minDistance; --i) {</span>
<span class="fc" id="L6466">                imageMax[i][j] = imageMax[i - minDistance][j];</span>
            }
<span class="fc bfc" id="L6468" title="All 2 branches covered.">            for (int i = 0; i &lt; minDistance; ++i) {</span>
<span class="fc" id="L6469">                imageMax[i][j] = 0;</span>
            }
<span class="fc bfc" id="L6471" title="All 2 branches covered.">            for (int i = (nRows - minDistance); i &lt; nRows; ++i) {</span>
<span class="fc" id="L6472">                imageMax[i][j] = 0;</span>
            }
        }
        //debugPrint(&quot;shifted imageMax=&quot;, imageMax);
<span class="fc" id="L6476">    }</span>
    
    /**
     * @author nichole
     * @param img
     * @param size
     * @return
     */
    public float[][] maximumFilter(float[][] img, int size) {

<span class="fc" id="L6486">        int nRows = img.length;</span>
<span class="fc" id="L6487">        int nCols = img[0].length;</span>

        // return_value = out
<span class="fc" id="L6490">        float[][] out = new float[nRows][nCols];</span>
<span class="fc bfc" id="L6491" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L6492">            out[i] = new float[nCols];</span>
        }

        // have adapted median window algorithm for this:
<span class="fc" id="L6496">        StatsInSlidingWindow maxWindow = new StatsInSlidingWindow();</span>
<span class="fc" id="L6497">        maxWindow.calculateMaximum(img, out, size, size);</span>

<span class="fc" id="L6499">        return out;</span>
    }
    
    /**
     * 
     * @param img
     * @param g the kernel to convolve img with at point (x,y).
     * Note that it's assumed the kernel is already normalized to sum 0.
     * @return 
     */
    public Complex[][] convolveWithKernel(final Complex[][] img, 
        Complex[][] g) {
        
<span class="fc" id="L6512">        Complex[][] c = new Complex[img.length][];</span>
        
<span class="fc bfc" id="L6514" title="All 2 branches covered.">        for (int x = 0; x &lt; img.length; ++x) {</span>
<span class="fc" id="L6515">            c[x] = new Complex[img[0].length];</span>
<span class="fc bfc" id="L6516" title="All 2 branches covered.">            for (int y = 0; y &lt; img[0].length; ++y) {</span>
<span class="fc" id="L6517">                ComplexModifiable sum = </span>
<span class="fc" id="L6518">                    convolvePointWithKernel(img, x, y, g);</span>
<span class="fc" id="L6519">                c[x][y] = new Complex(sum.re(), sum.im());</span>
            }
        }
       
<span class="fc" id="L6523">        return c;</span>
    }
    
     /**
     * 
     * @param img
     * @param x
     * @param y
     * @param g the kernel to convolve img with at point (x,y).
     * Note that it's assumed the kernel is already normalized to sum 0.
     * @return sum of convolution at point x,y
     */
    public ComplexModifiable convolvePointWithKernel(final Complex[][] img, int x, 
        int y, Complex[][] g) {
        
<span class="fc" id="L6538">        int n0 = g.length;</span>
<span class="fc" id="L6539">        int n1 = g[0].length;</span>
        
<span class="fc" id="L6541">        int h0 = (n0 &gt;&gt; 1);</span>
<span class="fc" id="L6542">        int h1 = (n1 &gt;&gt; 1);</span>
        
<span class="fc" id="L6544">        int w = img.length;</span>
<span class="fc" id="L6545">        int h = img[0].length;</span>
        
<span class="fc" id="L6547">        ComplexModifiable sum = new ComplexModifiable(0, 0);</span>

<span class="fc bfc" id="L6549" title="All 2 branches covered.">        for (int i = -h0; i &lt; (n0 - h0); i++) {</span>
<span class="fc" id="L6550">            int x2 = x + i;</span>
<span class="fc bfc" id="L6551" title="All 2 branches covered.">            if (x2 &lt; 0) {</span>
               // replicate
<span class="fc" id="L6553">               x2 = -1*x2 - 1;</span>
<span class="pc bpc" id="L6554" title="1 of 2 branches missed.">               if (x2 &gt; (w - 1)) {</span>
<span class="nc" id="L6555">                   x2 = w - 1;</span>
               }
<span class="fc bfc" id="L6557" title="All 2 branches covered.">            } else if (x2 &gt; (w - 1)) {</span>
<span class="fc" id="L6558">                int diff = x2 - w;</span>
<span class="fc" id="L6559">                x2 = w - diff - 1;</span>
<span class="pc bpc" id="L6560" title="1 of 2 branches missed.">                if (x2 &lt; 0) {</span>
<span class="nc" id="L6561">                    x2 = 0;</span>
                }
            }
<span class="fc bfc" id="L6564" title="All 2 branches covered.">            for (int j = -h1; j &lt; (n1 - h1); j++) {</span>
<span class="fc" id="L6565">                int y2 = y + j;</span>
<span class="fc bfc" id="L6566" title="All 4 branches covered.">                if (y2 &lt; 0 || (y2 &gt; (h - 1))) {</span>
<span class="fc" id="L6567">                    continue;</span>
                }
<span class="pc bpc" id="L6569" title="1 of 2 branches missed.">                if (y2 &lt; 0) {</span>
                   // replicate
<span class="nc" id="L6571">                   y2 = -1*y2 - 1;</span>
<span class="nc bnc" id="L6572" title="All 2 branches missed.">                   if (y2 &gt; (h - 1)) {</span>
<span class="nc" id="L6573">                       y2 = h - 1;</span>
                   }
<span class="pc bpc" id="L6575" title="1 of 2 branches missed.">                } else if (y2 &gt; (h - 1)) {</span>
<span class="nc" id="L6576">                    int diff = y2 - h;</span>
<span class="nc" id="L6577">                    y2 = h - diff - 1;</span>
<span class="nc bnc" id="L6578" title="All 2 branches missed.">                    if (y2 &lt; 0) {</span>
<span class="nc" id="L6579">                        y2 = 0;</span>
                    }
                }
            
<span class="fc" id="L6583">                Complex gg = g[i + h0][j + h1];</span>

<span class="fc" id="L6585">                Complex point = img[x2][y2];</span>
                
<span class="fc" id="L6587">                Complex m = point.times(gg);</span>

<span class="fc" id="L6589">                sum.plus(m);                </span>
            }
        }
        
<span class="fc" id="L6593">        return sum;</span>
    } 
    
    public Set&lt;PairInt&gt; createWindowOfPoints(int x, int y, 
        int windowHalfWidth, int imageWidth, int imageHeight) {
        
<span class="fc" id="L6599">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L6601" title="All 2 branches covered.">        for (int i = (x - windowHalfWidth); i &lt;= (x + windowHalfWidth); ++i) {</span>
<span class="pc bpc" id="L6602" title="2 of 4 branches missed.">            if (i &lt; 0 || i &gt; (imageWidth - 1)) {</span>
<span class="nc" id="L6603">                continue;</span>
            }
<span class="fc bfc" id="L6605" title="All 2 branches covered.">            for (int j = (y - windowHalfWidth); j &lt;= (y + windowHalfWidth); ++j) {</span>
<span class="pc bpc" id="L6606" title="1 of 4 branches missed.">                if (j &lt; 0 || j &gt; (imageHeight - 1)) {</span>
<span class="fc" id="L6607">                    continue;</span>
                }
<span class="fc" id="L6609">                points.add(new PairInt(i, j));</span>
            }
        }
        
<span class="fc" id="L6613">        return points;</span>
    }
    
    /**
     * given an input image, creates a decimation pyramid with 
     * median smoothing followed by either integer or bilinear
     * interpolation down-sampling.
     * This method returns images down-sampled by scale sizes that
     * are a factor of 2 from each until image size
     * is smaller than decimationLimit.  Then the
     * method creates discrete scales in between the factors of 2 
     * pyramid, such as 1.25, 1.5, 1.75, then bisecting scales
     * with 3, 5, 12, etc.
     * @param input
     * @param decimationLimit limit to smallest image dimension size returned
     * @return 
     */
    public List&lt;GreyscaleImage&gt; buildPyramid2(GreyscaleImage input,
        int decimationLimit) {
    
<span class="fc" id="L6633">        int nBetween = 3;</span>
        
<span class="fc" id="L6635">        return buildPyramid2(input, decimationLimit, nBetween);</span>
    }
    
    public List&lt;List&lt;GreyscaleImage&gt;&gt; buildColorPyramid(Image img,
        boolean buildLarger) {
        
<span class="fc" id="L6641">        List&lt;List&lt;GreyscaleImage&gt;&gt; pyr = new ArrayList&lt;List&lt;GreyscaleImage&gt;&gt;();</span>
        
<span class="fc" id="L6643">        GreyscaleImage r = img.copyRedToGreyscale();</span>
<span class="fc" id="L6644">        GreyscaleImage g = img.copyGreenToGreyscale();</span>
<span class="fc" id="L6645">        GreyscaleImage b = img.copyBlueToGreyscale();</span>
        List&lt;GreyscaleImage&gt; gsR;
        List&lt;GreyscaleImage&gt; gsG;
        List&lt;GreyscaleImage&gt; gsB;
        
<span class="pc bpc" id="L6650" title="1 of 2 branches missed.">        if (buildLarger) {</span>
            
<span class="fc" id="L6652">            ImageProcessor imageProcessor = new ImageProcessor();</span>
            
<span class="fc" id="L6654">            gsR = imageProcessor.buildPyramid2(r, 32);</span>
<span class="fc" id="L6655">            gsG = imageProcessor.buildPyramid2(g, 32);</span>
<span class="fc" id="L6656">            gsB = imageProcessor.buildPyramid2(b, 32);</span>
            
<span class="fc" id="L6658">        } else {</span>
            
<span class="nc" id="L6660">            MedianTransform mt = new MedianTransform();</span>
            
<span class="nc" id="L6662">            gsR = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L6663">            gsG = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L6664">            gsB = new ArrayList&lt;GreyscaleImage&gt;();</span>
            
<span class="nc" id="L6666">            mt.multiscalePyramidalMedianTransform2(r, gsR, 32);</span>
<span class="nc" id="L6667">            mt.multiscalePyramidalMedianTransform2(g, gsG, 32);</span>
<span class="nc" id="L6668">            mt.multiscalePyramidalMedianTransform2(b, gsB, 32);</span>
        }
        
<span class="pc bpc" id="L6671" title="3 of 4 branches missed.">        assert(gsR.size() == gsG.size());</span>
<span class="pc bpc" id="L6672" title="3 of 4 branches missed.">        assert(gsR.size() == gsB.size());</span>

<span class="fc bfc" id="L6674" title="All 2 branches covered.">        for (int i = 0; i &lt; gsR.size(); ++i) {</span>
<span class="fc" id="L6675">            GreyscaleImage r2 = gsR.get(i);</span>
<span class="fc" id="L6676">            GreyscaleImage g2 = gsG.get(i);</span>
<span class="fc" id="L6677">            GreyscaleImage b2 = gsB.get(i);</span>

<span class="fc" id="L6679">            List&lt;GreyscaleImage&gt; rgb = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="fc" id="L6680">            rgb.add(r2);</span>
<span class="fc" id="L6681">            rgb.add(g2);</span>
<span class="fc" id="L6682">            rgb.add(b2);</span>
            
<span class="fc" id="L6684">            pyr.add(rgb);</span>
        }
        
<span class="fc" id="L6687">        return pyr;</span>
    }
    
    public List&lt;GreyscaleImage&gt; buildPyramid(GreyscaleImage img,
        boolean buildLarger) {
                
<span class="fc" id="L6693">        GreyscaleImage cp = img.copyImage();</span>
        
        List&lt;GreyscaleImage&gt; out;
        
<span class="pc bpc" id="L6697" title="1 of 2 branches missed.">        if (buildLarger) {</span>
            
<span class="fc" id="L6699">            ImageProcessor imageProcessor = new ImageProcessor();</span>
            
<span class="fc" id="L6701">            out = imageProcessor.buildPyramid2(cp, 32);</span>
            
<span class="fc" id="L6703">        } else {</span>
            
<span class="nc" id="L6705">            MedianTransform mt = new MedianTransform();</span>
            
<span class="nc" id="L6707">            out = new ArrayList&lt;GreyscaleImage&gt;();</span>
            
<span class="nc" id="L6709">            mt.multiscalePyramidalMedianTransform2(cp, out, 32);</span>
        }
        
<span class="fc" id="L6712">        return out;</span>
    }
    
    /**
     * given an input image, creates a decimation pyramid with 
     * median smoothing followed by either integer or bilinear
     * interpolation down-sampling.
     * This method returns images down-sampled by scale sizes that
     * are a factor of 2 from each until image size
     * is smaller than decimationLimit.  Then the
     * method creates discrete scales in between the factors of 2 
     * pyramid, such as 1.25, 1.5, 1.75, then bisecting scales
     * with 3, 5, 12, etc.
     * @param input
     * @param decimationLimit limit to smallest image dimension size returned
     * @param nBetween the number of images to create in between the powers
     * of 2.
     * @return 
     */
    public List&lt;GreyscaleImage&gt; buildPyramid2(GreyscaleImage input,
        int decimationLimit, int nBetween) {
        
<span class="fc" id="L6734">        List&lt;GreyscaleImage&gt; output = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="fc" id="L6736">        MedianTransform mt = new MedianTransform();</span>
<span class="fc" id="L6737">        mt.multiscalePyramidalMedianTransform2(input, output, decimationLimit);</span>

<span class="pc bpc" id="L6739" title="1 of 2 branches missed.">        if (output.size() == 1) {</span>
<span class="nc" id="L6740">            return output;</span>
        }

<span class="fc" id="L6743">        List&lt;GreyscaleImage&gt; output2 = new ArrayList&lt;GreyscaleImage&gt;();</span>
        
        // add an image in between each after output[2]
<span class="fc bfc" id="L6746" title="All 2 branches covered.">        for (int i = 0; i &lt; output.size() - 1; ++i) {</span>
<span class="fc" id="L6747">            output2.add(mt.decimateImage(output.get(i), 1.5f, 0, 255));</span>
        }
       
<span class="fc" id="L6750">        output.addAll(output2);</span>
       
<span class="fc" id="L6752">        Collections.sort(output, new DecreasingSizeComparator());</span>

<span class="fc" id="L6754">        return output;</span>
        
        /*
        a gaussian pyramid based upon a kernel of sigma 0.707
        can be built recursively, but the number of iterations
        to reach scale factors larger than 3 is increasingly
        very large number of recursions.
        
        FWHM = 2.35 * sigma
        for recursive gaussian and kernel0 w/ sigma=sqrt(2)/2 = 0.707
                                                     sigma   FWHM
        s1^2 = (sqrt(2)/2)^2 = 0.5                    0.7     1.67
        s2^2 = 0.5 + (sqrt(2)/2)^2 = 1                1       2.35                 
        s3^2 = 1 + (sqrt(2)/2)^2                      1.22    2.9
        s4^2 = 1.5 + (sqrt(2)/2)^2                    1.4     3.3
        s5^2 = 2 + (sqrt(2)/2)^2                      1.58    3.72                      
        s6^2 = 2.5 + (sqrt(2)/2)^2                    1.7     4.07
        s7^2 = 3.0 + (sqrt(2)/2)^2                    1.87    4.4  
        ...
        s17^2 = 8.0 + (sqrt(2)/2)^2                   2.83    6.65  &lt;-- factor of 4 from s1
        
        Alternatively, making a kernel of size sigma&gt;2 needs larger
        kernels too so the O(N) has a large constant factor in front of it.
        
        A hybrid solution would be to use the current
        pyramidal median transform which returns images 
        blurred and downsampled by factors of 2.
        Then add to that, discrete samplings of scale sizes
        that improve the pyramid.
        1   2   4   8   16
        for example, calculate for scale factors 1.25, 1.5, 1.75
        then bisecting the existing pyramidal scales to make
        3, 6, and 12, etc.
        Might consider a version of this method which provides more
        scales at higher factors...
        */
    }

    /**
     * use bilinear interpolation to downsample a two dimensional array.
     * 
     * adapted from pseudocode at
     * http://tech-algorithm.com/articles/bilinear-image-scaling/
    
     * @param pixels
     * @param w2 output length of first dimension of array
     * @param h2 output length of second dimension of array
     * @return 
     */
    public float[][] bilinearDownSampling(float[][] pixels,  
        int w2, int h2) {
        
<span class="fc" id="L6806">        float[][] out = new float[w2][h2];</span>
<span class="fc bfc" id="L6807" title="All 2 branches covered.">        for (int i = 0; i &lt; w2; ++i) {</span>
<span class="fc" id="L6808">            out[i] = new float[h2];  </span>
        }
        
<span class="fc" id="L6811">        int w = pixels.length; </span>
<span class="fc" id="L6812">        int h = pixels[0].length;</span>
        
        int x, y;
        float A, B, C, D, gray;
        
<span class="fc" id="L6817">        float xRatio = (float)w/(float)w2;</span>
<span class="fc" id="L6818">        float yRatio = (float)h/(float)h2;</span>
        float xDiff, yDiff;
<span class="fc" id="L6820">        int offset = 0 ;</span>
<span class="fc bfc" id="L6821" title="All 2 branches covered.">        for (int i = 0; i &lt; w2; i++) {</span>
<span class="fc bfc" id="L6822" title="All 2 branches covered.">            for (int j = 0; j &lt; h2; j++) {</span>
<span class="fc" id="L6823">                x = (int)(xRatio * i);</span>
<span class="fc" id="L6824">                y = (int)(yRatio * j);</span>
<span class="fc" id="L6825">                xDiff = (xRatio * i) - x;</span>
<span class="fc" id="L6826">                yDiff = (yRatio * j) - y;</span>

<span class="fc" id="L6828">                A = pixels[x][y];</span>
<span class="fc" id="L6829">                B = pixels[x][y+1];</span>
<span class="fc" id="L6830">                C = pixels[x+1][y];</span>
<span class="fc" id="L6831">                D = pixels[x+1][y+1];</span>

                // Y = A(1-w)(1-h) + B(w)(1-h) + C(h)(1-w) + Dwh
<span class="fc" id="L6834">                gray = </span>
                    A * (1 - xDiff) * (1 - yDiff) + 
                    C * (xDiff) * (1 - yDiff) +
                    B * (yDiff) * (1 - xDiff) +  
                    D * (xDiff * yDiff);

<span class="fc" id="L6840">                out[i][j] = gray;                                   </span>
            }
        }
        
<span class="fc" id="L6844">        return out;</span>
    }
    
    /**
     * use bilinear interpolation to downsample a two dimensional array.
     * Assumes that valid pixel values are 0 to 255 and clamps if outside range.
     * 
     * adapted from pseudocode at
     * http://tech-algorithm.com/articles/bilinear-image-scaling/
    
     * @param input
     * @param w2 output length of first dimension of array
     * @param h2 output length of second dimension of array
     * @return 
     */
    public GreyscaleImage bilinearDownSampling(GreyscaleImage input,
        int w2, int h2) {
   
<span class="fc" id="L6862">        return bilinearDownSampling(input, w2, h2, 0, 255);</span>
    }
   
    /**
     * use bilinear interpolation to downsample a two dimensional array.
     * 
     * adapted from pseudocode at
     * http://tech-algorithm.com/articles/bilinear-image-scaling/
    
     * @param input
     * @param w2 output length of first dimension of array
     * @param h2 output length of second dimension of array
     * @param minValue value to clamp results to if less than this
     * @param maxValue value to clamp results to if larger than this
     * @return 
     */
    public GreyscaleImage bilinearDownSampling(GreyscaleImage input,
        int w2, int h2, int minValue, int maxValue) {
        
<span class="fc" id="L6881">        GreyscaleImage out = input.createWithDimensions(w2, h2);</span>
        
<span class="fc" id="L6883">        int w = input.getWidth();</span>
<span class="fc" id="L6884">        int h = input.getHeight();</span>
        
        int x, y;
        float A, B, C, D, gray;
        
<span class="fc" id="L6889">        float xRatio = (float)w/(float)w2;</span>
<span class="fc" id="L6890">        float yRatio = (float)h/(float)h2;</span>
        float xDiff, yDiff;
<span class="fc" id="L6892">        int offset = 0 ;</span>
<span class="fc bfc" id="L6893" title="All 2 branches covered.">        for (int i = 0; i &lt; w2; i++) {</span>
<span class="fc bfc" id="L6894" title="All 2 branches covered.">            for (int j = 0; j &lt; h2; j++) {</span>
<span class="fc" id="L6895">                x = (int)(xRatio * i);</span>
<span class="fc" id="L6896">                y = (int)(yRatio * j);</span>
<span class="fc" id="L6897">                xDiff = (xRatio * i) - x;</span>
<span class="fc" id="L6898">                yDiff = (yRatio * j) - y;</span>

<span class="fc" id="L6900">                A = input.getValue(x, y);</span>
<span class="fc" id="L6901">                B = input.getValue(x, y+1);</span>
<span class="fc" id="L6902">                C = input.getValue(x+1, y);</span>
<span class="fc" id="L6903">                D = input.getValue(x+1, y+1);</span>

                // Y = A(1-w)(1-h) + B(w)(1-h) + C(h)(1-w) + Dwh
<span class="fc" id="L6906">                gray = </span>
                    A * (1 - xDiff) * (1 - yDiff) + 
                    C * (xDiff) * (1 - yDiff) +
                    B * (yDiff) * (1 - xDiff) +  
                    D * (xDiff * yDiff);

<span class="fc" id="L6912">                int v = Math.round(gray);</span>
<span class="pc bpc" id="L6913" title="1 of 2 branches missed.">                if (v &lt; minValue) {</span>
<span class="nc" id="L6914">                    v = minValue;</span>
<span class="pc bpc" id="L6915" title="1 of 2 branches missed.">                } else if (v &gt; maxValue) {</span>
<span class="nc" id="L6916">                    v = maxValue;</span>
                }
                
<span class="fc" id="L6919">                out.setValue(i, j, v);                              </span>
            }
        }
        
<span class="fc" id="L6923">        return out;</span>
    }
    
    /**
     * use bilinear interpolation to downsample a two dimensional array.
     * 
     * adapted from pseudocode at
     * http://tech-algorithm.com/articles/bilinear-image-scaling/
    
     * @param input
     * @param w2 output length of first dimension of array
     * @param h2 output length of second dimension of array
     * @param minValue value to clamp results to if less than this
     * @param maxValue value to clamp results to if larger than this
     * @return 
     */
    public Image bilinearDownSampling(Image input,
        int w2, int h2, int minValue, int maxValue) {
        
<span class="nc" id="L6942">        Image out = input.createWithDimensions(w2, h2);</span>
        
<span class="nc" id="L6944">        int w = input.getWidth();</span>
<span class="nc" id="L6945">        int h = input.getHeight();</span>
        
        int x, y, rI, gI, bI;
        float A, B, C, D, red, green, blue;
        
<span class="nc" id="L6950">        float xRatio = (float)w/(float)w2;</span>
<span class="nc" id="L6951">        float yRatio = (float)h/(float)h2;</span>
        float xDiff, yDiff;
<span class="nc" id="L6953">        int offset = 0 ;</span>
<span class="nc bnc" id="L6954" title="All 2 branches missed.">        for (int i = 0; i &lt; w2; i++) {</span>
<span class="nc bnc" id="L6955" title="All 2 branches missed.">            for (int j = 0; j &lt; h2; j++) {</span>
<span class="nc" id="L6956">                x = (int)(xRatio * i);</span>
<span class="nc" id="L6957">                y = (int)(yRatio * j);</span>
<span class="nc" id="L6958">                xDiff = (xRatio * i) - x;</span>
<span class="nc" id="L6959">                yDiff = (yRatio * j) - y;</span>

<span class="nc" id="L6961">                A = input.getR(x, y);</span>
<span class="nc" id="L6962">                B = input.getR(x, y+1);</span>
<span class="nc" id="L6963">                C = input.getR(x+1, y);</span>
<span class="nc" id="L6964">                D = input.getR(x+1, y+1);</span>

                // Y = A(1-w)(1-h) + B(w)(1-h) + C(h)(1-w) + Dwh
<span class="nc" id="L6967">                red = A * (1 - xDiff) * (1 - yDiff) + </span>
                    C * (xDiff) * (1 - yDiff) +
                    B * (yDiff) * (1 - xDiff) +  
                    D * (xDiff * yDiff);

<span class="nc" id="L6972">                rI = Math.round(red);</span>
<span class="nc bnc" id="L6973" title="All 2 branches missed.">                if (rI &lt; minValue) {</span>
<span class="nc" id="L6974">                    rI = minValue;</span>
<span class="nc bnc" id="L6975" title="All 2 branches missed.">                } else if (rI &gt; maxValue) {</span>
<span class="nc" id="L6976">                    rI = maxValue;</span>
                }
                
<span class="nc" id="L6979">                A = input.getG(x, y);</span>
<span class="nc" id="L6980">                B = input.getG(x, y+1);</span>
<span class="nc" id="L6981">                C = input.getG(x+1, y);</span>
<span class="nc" id="L6982">                D = input.getG(x+1, y+1);</span>
<span class="nc" id="L6983">                green = A * (1 - xDiff) * (1 - yDiff) + </span>
                    C * (xDiff) * (1 - yDiff) +
                    B * (yDiff) * (1 - xDiff) +  
                    D * (xDiff * yDiff);
<span class="nc" id="L6987">                gI = Math.round(green);</span>
<span class="nc bnc" id="L6988" title="All 2 branches missed.">                if (gI &lt; minValue) {</span>
<span class="nc" id="L6989">                    gI = minValue;</span>
<span class="nc bnc" id="L6990" title="All 2 branches missed.">                } else if (gI &gt; maxValue) {</span>
<span class="nc" id="L6991">                    gI = maxValue;</span>
                }
                
<span class="nc" id="L6994">                A = input.getB(x, y);</span>
<span class="nc" id="L6995">                B = input.getB(x, y+1);</span>
<span class="nc" id="L6996">                C = input.getB(x+1, y);</span>
<span class="nc" id="L6997">                D = input.getB(x+1, y+1);</span>
<span class="nc" id="L6998">                blue = A * (1 - xDiff) * (1 - yDiff) + </span>
                    C * (xDiff) * (1 - yDiff) +
                    B * (yDiff) * (1 - xDiff) +  
                    D * (xDiff * yDiff);
<span class="nc" id="L7002">                bI = Math.round(blue);</span>
<span class="nc bnc" id="L7003" title="All 2 branches missed.">                if (bI &lt; minValue) {</span>
<span class="nc" id="L7004">                    bI = minValue;</span>
<span class="nc bnc" id="L7005" title="All 2 branches missed.">                } else if (bI &gt; maxValue) {</span>
<span class="nc" id="L7006">                    bI = maxValue;</span>
                }
                
<span class="nc" id="L7009">                out.setRGB(i, j, rI, gI, bI);                              </span>
            }
        }
        
<span class="nc" id="L7013">        return out;</span>
    }
    
    /**
     * comparator that assumes can compare by widths along,
     * unless there is a tie, then it uses height.
     */
    private class DecreasingSizeComparator implements 
        Comparator&lt;GreyscaleImage&gt; {

        @Override
        public int compare(GreyscaleImage o1, 
            GreyscaleImage o2) {
        
            int w1 = o1.getWidth();
            int w2 = o2.getWidth();
            
            if (w1 &gt; w2) {
                return -1;
            } else if (w1 &lt; w2) {
                return 1;
            }
        
            int h1 = o1.getHeight();
            int h2 = o2.getHeight();
            
            if (h1 &gt; h2) {
                return -1;
            } else if (h1 &lt; h2) {
                return 1;
            }
            
            return 0;
        }        
    }
    
    /**
     * convert the image to cie l*a*b* and then use a and b
     * to calculate polar angle around 0 in degrees.
     * If maxV of 360, returns full value image, 
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return 
     */
    public int calculateCIELABTheta(int red, int green, int blue, int maxV) {
        
<span class="fc" id="L7060">        CIEChromaticity cieC = new CIEChromaticity();</span>
       
<span class="fc" id="L7062">        double ts = (double)maxV/(double)359;</span>
        
<span class="fc" id="L7064">        float[] lab = cieC.rgbToCIELAB1931(red, green, blue);</span>
        
<span class="fc" id="L7066">        float v1 = lab[1];</span>
<span class="fc" id="L7067">        float v2 = lab[2];</span>

<span class="fc" id="L7069">        double t = Math.atan2(v2, v1);</span>
<span class="fc" id="L7070">        t *= (180./Math.PI);</span>
<span class="fc bfc" id="L7071" title="All 2 branches covered.">        if (t &lt; 0) {</span>
<span class="fc" id="L7072">            t += 360;</span>
<span class="pc bpc" id="L7073" title="1 of 2 branches missed.">        } else if (t &gt; 359) {</span>
<span class="nc" id="L7074">            t -= 360;</span>
        }
<span class="fc" id="L7076">        t *= ts;</span>
        
<span class="fc" id="L7078">        return (int)t;</span>
    }
    
    /**
     * create sobel gradient images for the given images specified by idxs
     * @param images
     * @param idxs
     * @return 
     */
    public GreyscaleImage[] createSobels(GreyscaleImage[] images, int[] idxs) {
        
<span class="nc" id="L7089">        GreyscaleImage[] sobels = new GreyscaleImage[2];</span>
        
<span class="nc" id="L7091">        int count = 0;</span>
<span class="nc bnc" id="L7092" title="All 2 branches missed.">        for (int idx : idxs) {</span>
<span class="nc" id="L7093">            GreyscaleImage img2 = images[idx];</span>
<span class="nc" id="L7094">            sobels[count] = img2.copyImage();</span>
<span class="nc" id="L7095">            applySobelKernel(sobels[count]);</span>
<span class="nc" id="L7096">            count++;</span>
        }
<span class="nc" id="L7098">        return sobels;</span>
    }
    
    public GreyscaleImage[] createSobelLCForLUV(Image img) {
        
<span class="nc" id="L7103">        GreyscaleImage[] lch = createLCHForLUV(img);</span>
        
<span class="nc" id="L7105">        GreyscaleImage[] sobels = createSobels(lch, new int[]{0, 1});</span>
        
<span class="nc" id="L7107">        return sobels;</span>
    }
    
    /**
     * create 3 images of the LCG color space where LCH is the 
     * luminosity, magnitude, and polar angle of CIE LUV color space.
     * @param img
     * @return 
     */
    public GreyscaleImage[] createLCHForLUV(Image img) {
        
<span class="fc" id="L7118">        int w = img.getWidth();</span>
<span class="fc" id="L7119">        int h = img.getHeight();</span>
<span class="fc" id="L7120">        int n = img.getNPixels();</span>
        
        /*
        range of CIE LUV using default standard illumination of
        D65 daylight is:
        L       0 to 104.5
        u   -86.9 to 183.8
        v  -141.4 to 112.3
        luminosity L*  0 to 104.5
        magnitude, m:  sqrt(2) * 183.8 = 260
        angle,     a:  0 to 359
        */
        
<span class="fc" id="L7133">        float[] factors = new float[]{255.f/104.5f, 255.f/260.f, 255.f/359.f};</span>
        
<span class="fc" id="L7135">        GreyscaleImage[] output = new GreyscaleImage[3];</span>
<span class="fc bfc" id="L7136" title="All 2 branches covered.">        for (int i = 0; i &lt; output.length; ++i) {</span>
<span class="fc" id="L7137">            output[i] = new GreyscaleImage(w, h);</span>
        }
        
<span class="fc" id="L7140">        CIEChromaticity cieC = new CIEChromaticity();</span>
                
        int v;
<span class="fc bfc" id="L7143" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L7144" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
                
<span class="fc" id="L7146">                int r = img.getR(i, j);</span>
<span class="fc" id="L7147">                int g = img.getG(i, j);</span>
<span class="fc" id="L7148">                int b = img.getB(i, j);</span>
                
<span class="fc" id="L7150">                float[] lma = cieC.rgbToPolarCIELUV(r, g, b);</span>
             
<span class="fc bfc" id="L7152" title="All 2 branches covered.">                for (int k = 0; k &lt; output.length; ++k) {</span>
<span class="fc bfc" id="L7153" title="All 4 branches covered.">                    if (k == 2 &amp;&amp; lma[k] &gt; 359.f) {</span>
<span class="fc" id="L7154">                        lma[k] = 360 - lma[k];</span>
                    }
<span class="fc" id="L7156">                    v = Math.round(factors[k] * lma[k]);</span>
<span class="fc bfc" id="L7157" title="All 2 branches covered.">                    if (v &gt; 255) {</span>
<span class="fc" id="L7158">                        v = 255;</span>
<span class="pc bpc" id="L7159" title="1 of 2 branches missed.">                    } else if (v &lt; 0) {</span>
<span class="nc" id="L7160">                        v = 0;</span>
                    }
<span class="fc" id="L7162">                    output[k].setValue(i, j, v);</span>
                }
            }
        }
        
<span class="fc" id="L7167">        return output;</span>
    }
   
    /**
     * convert the image to cie luv and then calculate polar angle of u and v
     * around 0 in degrees (a.k.a. the &quot;H&quot; of LCH color space, but with
     * the 1976 CIE LAB which is LUV).
     * If maxV of 360, returns full value image, 
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return 
     */
    public GreyscaleImage createCIELUVTheta(Image img, int maxV) {
        
<span class="fc" id="L7182">        int w = img.getWidth();</span>
<span class="fc" id="L7183">        int h = img.getHeight();</span>
        
<span class="fc" id="L7185">        GreyscaleImage theta = null;</span>
<span class="pc bpc" id="L7186" title="1 of 2 branches missed.">        if (maxV &lt; 256) {</span>
<span class="fc" id="L7187">            theta = new GreyscaleImage(w, h);</span>
        } else {
<span class="nc" id="L7189">            theta = new GreyscaleImage(w, h, </span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }
        
<span class="fc" id="L7193">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="fc" id="L7195">        double ts = (double)maxV/(double)359;</span>
        
<span class="fc" id="L7197">        int n = img.getNPixels();</span>
        int v;
<span class="fc bfc" id="L7199" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L7200" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
                
<span class="fc" id="L7202">                int r = img.getR(i, j);</span>
<span class="fc" id="L7203">                int g = img.getG(i, j);</span>
<span class="fc" id="L7204">                int b = img.getB(i, j);</span>
                
<span class="fc" id="L7206">                float[] lma = cieC.rgbToPolarCIELUV(r, g, b);</span>
             
<span class="fc" id="L7208">                double t = lma[2];</span>
<span class="fc" id="L7209">                t *= ts;</span>
<span class="fc" id="L7210">                v = (int)t;</span>
                
<span class="fc" id="L7212">                theta.setValue(i, j, v);</span>
            }
        }
        
<span class="fc" id="L7216">        return theta;</span>
    }
    
    /**
     * convert the image to cie lab and then calculate polar angle of u and v
     * around 0 in degrees.
     * If maxV of 360, returns full value image, 
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return 
     */
    public GreyscaleImage createCIELABTheta(Image img, int maxV) {
        
<span class="nc" id="L7230">        int w = img.getWidth();</span>
<span class="nc" id="L7231">        int h = img.getHeight();</span>
        
<span class="nc" id="L7233">        GreyscaleImage theta = null;</span>
<span class="nc bnc" id="L7234" title="All 2 branches missed.">        if (maxV &lt; 256) {</span>
<span class="nc" id="L7235">            theta = new GreyscaleImage(w, h);</span>
        } else {
<span class="nc" id="L7237">            theta = new GreyscaleImage(w, h, </span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }
        
<span class="nc" id="L7241">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="nc" id="L7243">        double ts = (double)maxV/(double)359;</span>
        
<span class="nc" id="L7245">        int n = img.getNPixels();</span>
        int v;
<span class="nc bnc" id="L7247" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L7248" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
                
<span class="nc" id="L7250">                int r = img.getR(i, j);</span>
<span class="nc" id="L7251">                int g = img.getG(i, j);</span>
<span class="nc" id="L7252">                int b = img.getB(i, j);</span>
                
<span class="nc" id="L7254">                float[] lab = cieC.rgbToCIELAB(r, g, b);</span>
             
<span class="nc" id="L7256">                double t = Math.atan2(lab[2], lab[1]);</span>
<span class="nc" id="L7257">                t *= (180. / Math.PI);</span>
<span class="nc bnc" id="L7258" title="All 2 branches missed.">                if (t &lt; 0) {</span>
<span class="nc" id="L7259">                    t += 360;</span>
<span class="nc bnc" id="L7260" title="All 2 branches missed.">                } else if (t &gt; 359) {</span>
<span class="nc" id="L7261">                    t -= 360;</span>
                }

<span class="nc" id="L7264">                t *= ts;</span>
<span class="nc" id="L7265">                v = (int)t;</span>
                
<span class="nc" id="L7267">                theta.setValue(i, j, v);</span>
            }
        }
        
<span class="nc" id="L7271">        return theta;</span>
    }
    
    public TIntObjectMap&lt;VeryLongBitString&gt; createAdjacencyMap(
        TObjectIntMap&lt;PairInt&gt; pointIndexMap, List&lt;Set&lt;PairInt&gt;&gt; labeledPoints,
        int imgWidth, int imgHeight) {

<span class="nc" id="L7278">        int n = labeledPoints.size();</span>

<span class="nc" id="L7280">        TIntObjectMap&lt;VeryLongBitString&gt; output</span>
            = new TIntObjectHashMap&lt;VeryLongBitString&gt;();

<span class="nc" id="L7283">        int[] dxs = Misc.dx4;</span>
<span class="nc" id="L7284">        int[] dys = Misc.dy4;</span>

<span class="nc bnc" id="L7286" title="All 2 branches missed.">        for (int label = 0; label &lt; n; ++label) {</span>
<span class="nc" id="L7287">            Set&lt;PairInt&gt; set = labeledPoints.get(label);</span>
<span class="nc" id="L7288">            VeryLongBitString nbrs = new VeryLongBitString(n);</span>
            
<span class="nc" id="L7290">            boolean aloSet = false;</span>
            
<span class="nc bnc" id="L7292" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L7293">                int x = p.getX();</span>
<span class="nc" id="L7294">                int y = p.getY();</span>
<span class="nc bnc" id="L7295" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L7296">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L7297">                    int y2 = y + dys[k];</span>
<span class="nc bnc" id="L7298" title="All 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= imgWidth || y2 &gt;= imgHeight) {</span>
<span class="nc" id="L7299">                        continue;</span>
                    }
<span class="nc" id="L7301">                    PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L7302" title="All 2 branches missed.">                    if (pointIndexMap.containsKey(p2)) {</span>
<span class="nc" id="L7303">                        int label2 = pointIndexMap.get(p2);</span>
<span class="nc bnc" id="L7304" title="All 2 branches missed.">                        if (label2 != label) {</span>
<span class="nc" id="L7305">                            nbrs.setBit(label2);</span>
<span class="nc" id="L7306">                            aloSet = true;</span>
                        }
                    }
                }
<span class="nc" id="L7310">            }</span>
<span class="nc bnc" id="L7311" title="All 2 branches missed.">            if (aloSet) {</span>
<span class="nc" id="L7312">                output.put(label, nbrs);</span>
            }
        }

<span class="nc" id="L7316">        return output;</span>
    }
    
    public TIntObjectMap&lt;VeryLongBitString&gt; createAdjacencyMap(
        TIntIntMap pointIndexMap, TIntObjectMap&lt;TIntSet&gt; labeledPoints, 
        int imgWidth, int imgHeight) {

<span class="fc" id="L7323">        int n = labeledPoints.size();</span>

<span class="fc" id="L7325">        TIntObjectMap&lt;VeryLongBitString&gt; output</span>
            = new TIntObjectHashMap&lt;VeryLongBitString&gt;();

<span class="fc" id="L7328">        int[] dxs = Misc.dx4;</span>
<span class="fc" id="L7329">        int[] dys = Misc.dy4;</span>
        
<span class="fc" id="L7331">        TIntObjectIterator&lt;TIntSet&gt; iter = labeledPoints.iterator();</span>

<span class="fc bfc" id="L7333" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L7335">            iter.advance();</span>
            
<span class="fc" id="L7337">            int label = iter.key();</span>
<span class="fc" id="L7338">            TIntSet pixIdxs = iter.value();</span>
            
<span class="fc" id="L7340">            VeryLongBitString nbrs = new VeryLongBitString(n);</span>
            
<span class="fc" id="L7342">            boolean aloSet = false;</span>
            
<span class="fc" id="L7344">            TIntIterator iter2 = pixIdxs.iterator();</span>
<span class="fc bfc" id="L7345" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L7346">                int pixIdx = iter2.next();</span>
<span class="fc" id="L7347">                int y = pixIdx/imgWidth;</span>
<span class="fc" id="L7348">                int x = pixIdx - (y * imgWidth);</span>
<span class="fc bfc" id="L7349" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L7350">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L7351">                    int y2 = y + dys[k];</span>
<span class="fc bfc" id="L7352" title="All 8 branches covered.">                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= imgWidth || y2 &gt;= imgHeight) {</span>
<span class="fc" id="L7353">                        continue;</span>
                    }
<span class="fc" id="L7355">                    int pixIdx2 = (y2 * imgWidth) + x2;</span>
<span class="pc bpc" id="L7356" title="1 of 2 branches missed.">                    if (pointIndexMap.containsKey(pixIdx2)) {</span>
<span class="fc" id="L7357">                        int label2 = pointIndexMap.get(pixIdx2);</span>
<span class="fc bfc" id="L7358" title="All 2 branches covered.">                        if (label2 != label) {</span>
<span class="fc" id="L7359">                            nbrs.setBit(label2);</span>
<span class="fc" id="L7360">                            aloSet = true;</span>
                        }
                    }
                }
<span class="fc" id="L7364">            }</span>
<span class="pc bpc" id="L7365" title="1 of 2 branches missed.">            if (aloSet) {</span>
<span class="fc" id="L7366">                output.put(label, nbrs);</span>
            }
        }

<span class="fc" id="L7370">        return output;</span>
    }
    
    public TIntObjectMap&lt;VeryLongBitString&gt; createAdjacencyMap(
        TIntIntMap pointIndexMap, List&lt;TIntSet&gt; labeledPoints, 
        int imgWidth, int imgHeight) {

<span class="fc" id="L7377">        int n = labeledPoints.size();</span>

<span class="fc" id="L7379">        TIntObjectMap&lt;VeryLongBitString&gt; output</span>
            = new TIntObjectHashMap&lt;VeryLongBitString&gt;();

<span class="fc" id="L7382">        int[] dxs = Misc.dx4;</span>
<span class="fc" id="L7383">        int[] dys = Misc.dy4;</span>
        
<span class="fc bfc" id="L7385" title="All 2 branches covered.">        for (int label = 0; label &lt; n; ++label) {</span>
                        
<span class="fc" id="L7387">            TIntSet pixIdxs = labeledPoints.get(label);</span>
            
<span class="fc" id="L7389">            VeryLongBitString nbrs = new VeryLongBitString(n);</span>
            
<span class="fc" id="L7391">            boolean aloSet = false;</span>
            
<span class="fc" id="L7393">            TIntIterator iter2 = pixIdxs.iterator();</span>
<span class="fc bfc" id="L7394" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L7395">                int pixIdx = iter2.next();</span>
<span class="fc" id="L7396">                int y = pixIdx/imgWidth;</span>
<span class="fc" id="L7397">                int x = pixIdx - (y * imgWidth);</span>
<span class="fc bfc" id="L7398" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L7399">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L7400">                    int y2 = y + dys[k];</span>
<span class="fc bfc" id="L7401" title="All 8 branches covered.">                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= imgWidth || y2 &gt;= imgHeight) {</span>
<span class="fc" id="L7402">                        continue;</span>
                    }
<span class="fc" id="L7404">                    int pixIdx2 = (y2 * imgWidth) + x2;</span>
<span class="pc bpc" id="L7405" title="1 of 2 branches missed.">                    if (pointIndexMap.containsKey(pixIdx2)) {</span>
<span class="fc" id="L7406">                        int label2 = pointIndexMap.get(pixIdx2);</span>
<span class="fc bfc" id="L7407" title="All 2 branches covered.">                        if (label2 != label) {</span>
<span class="fc" id="L7408">                            nbrs.setBit(label2);</span>
<span class="fc" id="L7409">                            aloSet = true;</span>
                        }
                    }
                }
<span class="fc" id="L7413">            }</span>
<span class="fc bfc" id="L7414" title="All 2 branches covered.">            if (aloSet) {</span>
<span class="fc" id="L7415">                output.put(label, nbrs);</span>
            }
        }

<span class="fc" id="L7419">        return output;</span>
    }
    
    public TIntObjectMap&lt;VeryLongBitString&gt; createAdjacencyMap(
        int[] labels, List&lt;Set&lt;PairInt&gt;&gt; labeledPoints,
        int width, int height) {

<span class="nc" id="L7426">        int n = labeledPoints.size();</span>

<span class="nc" id="L7428">        TIntObjectMap&lt;VeryLongBitString&gt; output</span>
            = new TIntObjectHashMap&lt;VeryLongBitString&gt;();

<span class="nc" id="L7431">        int[] dxs = Misc.dx4;</span>
<span class="nc" id="L7432">        int[] dys = Misc.dy4;</span>

<span class="nc bnc" id="L7434" title="All 2 branches missed.">        for (int label = 0; label &lt; n; ++label) {</span>
<span class="nc" id="L7435">            Set&lt;PairInt&gt; set = labeledPoints.get(label);</span>
<span class="nc" id="L7436">            VeryLongBitString nbrs = new VeryLongBitString(n);</span>
            
<span class="nc" id="L7438">            boolean aloSet = false;</span>
            
<span class="nc bnc" id="L7440" title="All 2 branches missed.">            for (PairInt p : set) {</span>
<span class="nc" id="L7441">                int x = p.getX();</span>
<span class="nc" id="L7442">                int y = p.getY();</span>
<span class="nc bnc" id="L7443" title="All 2 branches missed.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="nc" id="L7444">                    int x2 = x + dxs[k];</span>
<span class="nc" id="L7445">                    int y2 = y + dys[k];</span>
<span class="nc bnc" id="L7446" title="All 8 branches missed.">                    if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt;= width) || (y2 &gt;= height)) {</span>
<span class="nc" id="L7447">                        continue;</span>
                    }
<span class="nc" id="L7449">                    int pixIdx = (y2 * width) + x2;</span>
<span class="nc" id="L7450">                    int label2 = labels[pixIdx];</span>
<span class="nc bnc" id="L7451" title="All 2 branches missed.">                    if (label2 != label) {</span>
<span class="nc" id="L7452">                        nbrs.setBit(label2);</span>
<span class="nc" id="L7453">                        aloSet = true;</span>
                    }
                }
<span class="nc" id="L7456">            }</span>
<span class="nc bnc" id="L7457" title="All 2 branches missed.">            if (aloSet) {</span>
<span class="nc" id="L7458">                output.put(label, nbrs);</span>
            }
        }

<span class="nc" id="L7462">        return output;</span>
    }
    
    public void applyUnsharpMask(GreyscaleImage img) {
        
        //NOTE: if make a color version of this, should use a color
        // space such as CIE LAB or LUV and operate on the L only to
        // preserve color (or B of HSB).
        
        // NOTE: useful in looking at the general concept of
        //  original, blurred and threshold comparison was code copyrighted by
        //  Romain Guy available here:
        //  http://www.java2s.com/Code/Java/Advanced-Graphics/UnsharpMaskDemo.htm
        //  might need to place the copytight here for derivative of.
        
<span class="nc" id="L7477">        float amount = 0.2f;</span>
<span class="nc" id="L7478">        int radius = 50;</span>
<span class="nc" id="L7479">        float threshold = 0;</span>
        
<span class="nc" id="L7481">        applyUnsharpMask(img, amount, radius, threshold);</span>
        
<span class="nc" id="L7483">    }</span>
    
    /**
     * if a single pixel differs from its neighbors by more than 
     * 2o or 2 sigma, the value gets set to the neighbors
     * @param img 
     */
    public void singlePixelFilter(GreyscaleImage img) {
        
<span class="fc" id="L7492">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L7493">        int[] dys = Misc.dy8;</span>
        
<span class="fc" id="L7495">        int n = img.getNPixels();</span>
<span class="fc" id="L7496">        int w = img.getWidth();</span>
<span class="fc" id="L7497">        int h = img.getHeight();</span>
        
<span class="fc bfc" id="L7499" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L7501">            int x = img.getCol(i);</span>
<span class="fc" id="L7502">            int y = img.getRow(i);</span>
            
            float diff;
<span class="fc" id="L7505">            float avg = 0;</span>
<span class="fc" id="L7506">            int ns = 0;</span>
<span class="fc bfc" id="L7507" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L7508">                int x2 = x + dxs[k];</span>
<span class="fc" id="L7509">                int y2 = y + dys[k];</span>
<span class="fc bfc" id="L7510" title="All 8 branches covered.">                if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="fc" id="L7511">                    continue;</span>
                }
<span class="fc" id="L7513">                avg += img.getValue(x2, y2);</span>
<span class="fc" id="L7514">                ns++;</span>
            }
<span class="fc" id="L7516">            avg /= (float)ns;</span>
<span class="pc bpc" id="L7517" title="1 of 2 branches missed.">            if (ns == 0) {</span>
<span class="nc" id="L7518">                continue;</span>
            }
            
<span class="fc" id="L7521">            float stdv = 0;</span>
<span class="fc bfc" id="L7522" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L7523">                int x2 = x + dxs[k];</span>
<span class="fc" id="L7524">                int y2 = y + dys[k];</span>
<span class="fc bfc" id="L7525" title="All 8 branches covered.">                if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="fc" id="L7526">                    continue;</span>
                }
<span class="fc" id="L7528">                diff = img.getValue(x2, y2) - avg;</span>
<span class="fc" id="L7529">                stdv += (diff * diff);</span>
            }
<span class="fc" id="L7531">            stdv = (float)Math.sqrt(stdv/((float)ns - 1.0f));</span>
        
<span class="fc" id="L7533">            diff = Math.abs(img.getValue(x, y) - avg);</span>
<span class="fc bfc" id="L7534" title="All 2 branches covered.">            if (diff &gt; (2.*stdv)) {</span>
<span class="fc" id="L7535">                img.setValue(x, y, (int)avg);</span>
            }
        }
<span class="fc" id="L7538">    }</span>
    
    public void applyUnsharpMask(GreyscaleImage img, float percentage,
        int radius, float threshold) {
   
<span class="fc" id="L7543">        MedianSmooth ms = new MedianSmooth();</span>
<span class="fc" id="L7544">        GreyscaleImage blurred = ms.calculate(img, 3, 3);</span>
        
<span class="fc bfc" id="L7546" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L7547">            int v = img.getValue(i);</span>
<span class="fc" id="L7548">            int blur = blurred.getValue(i);</span>
            
<span class="fc" id="L7550">            int diff = v - blur;</span>
<span class="pc bpc" id="L7551" title="1 of 2 branches missed.">            if (Math.abs(diff) &gt;= threshold) {</span>
<span class="fc" id="L7552">                v = (int) (percentage * diff + v);</span>
<span class="fc bfc" id="L7553" title="All 2 branches covered.">                if (v &lt; 0) {</span>
<span class="fc" id="L7554">                    v = 0;</span>
<span class="fc bfc" id="L7555" title="All 2 branches covered.">                } else if (v &gt; 255) {</span>
<span class="fc" id="L7556">                    v = 255;</span>
                }
<span class="fc" id="L7558">                img.setValue(i, v);</span>
            }
        }
<span class="fc" id="L7561">    }</span>
    
    /**
     * use an adaptive threshold with window size to add the threshold
     * to the image where binarization would have created a &quot;1&quot;.
     * This enhances shadows and dark edges to an extreme that might not
     * be desirable for all uses.
     * 
     * @param img 
     */
    public void enhanceContrast(GreyscaleImage img, int window) {
       
<span class="fc" id="L7573">        GreyscaleImage inImg = img;</span>
        double[][] outImg;
        
<span class="fc" id="L7576">        int w = inImg.getWidth();</span>
<span class="fc" id="L7577">        int h = inImg.getHeight();</span>
        
<span class="fc" id="L7579">        double[][] sTable = new double[w][];</span>
<span class="fc bfc" id="L7580" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L7581">            sTable[i] = new double[h];</span>
<span class="fc bfc" id="L7582" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L7583">                sTable[i][j] = inImg.getValue(i, j);</span>
            }
        }
        
<span class="fc" id="L7587">        AdaptiveThresholding th =</span>
            new AdaptiveThresholding();
<span class="fc" id="L7589">        outImg = th.createAdaptiveThresholdImage(sTable, window, 0.2);</span>
        
        double v;
<span class="fc bfc" id="L7592" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L7593" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L7594">                double t = outImg[i][j];</span>
<span class="fc" id="L7595">                v = inImg.getValue(i, j);</span>
<span class="fc bfc" id="L7596" title="All 2 branches covered.">                if (v &gt; t) {</span>
                    // adding threshold back to emphasize contrast
                    // instead of binarization:
<span class="fc" id="L7599">                    v += t;                    </span>
                }
<span class="fc" id="L7601">                outImg[i][j] = v;</span>
            }
        }
        
<span class="fc" id="L7605">        MiscMath.applyRescale(outImg, 0, 255);</span>
        
<span class="fc bfc" id="L7607" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L7608" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L7609">                inImg.setValue(i, j, (int)outImg[i][j]);</span>
            }
        }
<span class="fc" id="L7612">    }</span>

    // TODO: implement the methods in 
    // http://www.merl.com/publications/docs/TR2008-030.pdf
    // for an O(n) filter.
    // &quot;Constant Time O(1) Bilateral Filtering&quot; by Porikli
    //public void applyBiLateralFilter(Image img) {
    //}
    
    // and trilateral filter by Tumblin et al. 2003
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImageProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageProcessor.java</span></div><h1>ImageProcessor.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.FixedSizeSortedVector;
import algorithms.bipartite.MinHeapForRT2012;
import algorithms.compGeometry.PerimeterFinder2;
import algorithms.imageProcessing.features.orb.ORB;
import algorithms.util.AngleUtil;
import algorithms.matrix.MatrixUtil;
import algorithms.misc.*;
import algorithms.util.*;
import algorithms.VeryLongBitString;
import algorithms.heapsAndPQs.HeapNode;
import algorithms.sort.MultiArrayMergeSort;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;
import no.uib.cipr.matrix.Matrix;
import thirdparty.ca.uol.aig.fftpack.Complex1D;

/**
 *
 * @author nichole
 */
<span class="fc" id="L41">public class ImageProcessor {</span>

<span class="fc" id="L43">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * use a sobel 
     * (1D Gaussian w/ sigma=0.71 convolution then
     * 1D first deriv gaussian sigma=0.5 convolution)
     * and return gradients in X and y. note the image may contain
     * negative values.
     * @param input
     * @return gX, gY
     */
    public GreyscaleImage[] createSobelGradients(GreyscaleImage input) {

<span class="fc" id="L56">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

<span class="fc" id="L58">        GreyscaleImage gX = input.copyToFullRangeIntImage();</span>
        /*
         1
         2  * [1 0 -1]
         1
        */
<span class="fc" id="L64">        applyKernel1D(gX, new float[]{0.5f, 1.f, 0.5f}, false);</span>
<span class="fc" id="L65">        applyKernel1D(gX, kernel, true);</span>
        
<span class="fc" id="L67">        GreyscaleImage gY = input.copyToFullRangeIntImage();</span>
<span class="fc" id="L68">        applyKernel1D(gY, kernel, false);</span>
<span class="fc" id="L69">        applyKernel1D(gY, new float[]{0.5f, 1.f, 0.5f}, true);</span>

<span class="fc" id="L71">        return new GreyscaleImage[]{gX, gY};</span>
    }
    
    /**
     * apply a 1D first deriv gaussian sigma=0.5 convolution)
     * and return gradients in X and y. note the image may contain
     * negative values.
     * @param input
     * @return
     */
    public GreyscaleImage[] createGradients(GreyscaleImage input) {

        //[1 0 -1]
<span class="nc" id="L84">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

<span class="nc" id="L86">        GreyscaleImage gX = input.copyToFullRangeIntImage();</span>
        
<span class="nc" id="L88">        applyKernel1D(gX, kernel, true);</span>
        
<span class="nc" id="L90">        GreyscaleImage gY = input.copyToFullRangeIntImage();</span>
<span class="nc" id="L91">        applyKernel1D(gY, kernel, false);</span>

<span class="nc" id="L93">        return new GreyscaleImage[]{gX, gY};</span>
    }
    
    /**
     * apply a 1D first deriv gaussian sigma=0.5 convolution)
     * and return gradients in X and y. note the image may contain
     * negative values.
     * @param input
     * @return
     */
    public GreyscaleImage[] createCentralDifferenceGradients(GreyscaleImage input) {

<span class="pc bpc" id="L105" title="2 of 4 branches missed.">        if (input.getWidth() &lt; 3 || input.getHeight() &lt; 3) {</span>
<span class="nc" id="L106">            throw new IllegalStateException(&quot;image dimensions must be at least 3 pixels each&quot;);</span>
        }
        //[1 0 -1]
<span class="fc" id="L109">        GreyscaleImage gX = input.copyToFullRangeIntImage();</span>
        
<span class="fc" id="L111">        GreyscaleImage gY = input.copyToFullRangeIntImage();</span>
        
<span class="fc" id="L113">        int w = input.getWidth();</span>
<span class="fc" id="L114">        int h = input.getHeight();</span>
     
        int v0, v1;
<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {                </span>
<span class="fc bfc" id="L119" title="All 4 branches covered.">                if (i &gt; 0 &amp;&amp; (i + 1) &lt; w) {</span>
                    //gx[i][j] = img[i-1][j] - img[i+1][j]
<span class="fc" id="L121">                    v0 = input.getValue(i - 1, j);</span>
<span class="fc" id="L122">                    v1 = input.getValue(i + 1, j);</span>
<span class="fc" id="L123">                    gX.setValue(i, j, (v1 - v0));</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                } else if (i == 0) {</span>
                    // handle boundaries
<span class="fc" id="L126">                    v0 = input.getValue(0, j);</span>
<span class="fc" id="L127">                    v1 = input.getValue(1, j);</span>
<span class="fc" id="L128">                    gX.setValue(0, j, (v1 - v0));</span>
                } else {
                    // handle boundaries
<span class="fc" id="L131">                    v0 = input.getValue(i - 1, j);</span>
<span class="fc" id="L132">                    v1 = input.getValue(w - 1, j);</span>
<span class="fc" id="L133">                    gX.setValue(i, j, (v1 - v0));</span>
                }
<span class="fc bfc" id="L135" title="All 4 branches covered.">                if (j &gt; 0 &amp;&amp; (j + 1) &lt; h) {</span>
                    //gy[i][j] = img[i][j-1] - img[i][j+1]
<span class="fc" id="L137">                    v0 = input.getValue(i, j - 1);</span>
<span class="fc" id="L138">                    v1 = input.getValue(i, j + 1);</span>
<span class="fc" id="L139">                    gY.setValue(i, j, (v1 - v0));</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                } else if (j == 0) {</span>
                    // handle boundaries
<span class="fc" id="L142">                    v0 = input.getValue(i, 0);</span>
<span class="fc" id="L143">                    v1 = input.getValue(i, 1);</span>
<span class="fc" id="L144">                    gY.setValue(i, j, (v1 - v0));</span>
                } else {
                    // handle boundaries
<span class="fc" id="L147">                    v0 = input.getValue(i, j - 1);</span>
<span class="fc" id="L148">                    v1 = input.getValue(i, h - 1);</span>
<span class="fc" id="L149">                    gY.setValue(i, j, (v1 - v0));</span>
                }
            }
        }
        
<span class="fc" id="L154">        return new GreyscaleImage[]{gX, gY};</span>
    }

    public void applySobelKernel(GreyscaleImage input) {

<span class="fc" id="L159">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

<span class="fc" id="L161">        GreyscaleImage[] gXY = createSobelGradients(input);</span>
       
<span class="fc" id="L163">        GreyscaleImage img2 = combineConvolvedImages(gXY[0], gXY[1]);</span>

<span class="fc" id="L165">        input.resetTo(img2);</span>
<span class="fc" id="L166">    }</span>

    /**
     * given a color image array with first dimension being color index
     * and the second dimension being the image pixel index,
     * apply the kernel [1,0,-1] to each pixel and combine the results
     * as SSD.
     * @param ptImg polar theta image of a color space such as
     * H of LCH that contains values between 0 and 255.
     * @param lowerDiff value in degrees for which a difference in
     * pixels results in a final value of &quot;1&quot;.  For example,
     * 20 degrees.
     */
    public GreyscaleImage createBinary1stDerivForPolarTheta(
        GreyscaleImage ptImg, int lowerDiff) {

<span class="fc" id="L182">        int nPix = ptImg.getNPixels();</span>
<span class="fc" id="L183">        int w = ptImg.getWidth();</span>
<span class="fc" id="L184">        int h = ptImg.getHeight();</span>

<span class="fc" id="L186">        GreyscaleImage out = ptImg.createWithDimensions();</span>

        // kernel is .5, 0, -.5 so looking for difference in pixels on either
        //   side being .lte. lowerDiff
<span class="fc" id="L190">        int[] diffs = new int[4];</span>
        int offset;
        int above;
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (int i = 1; i &lt; w - 1; ++i) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            for (int j = 1; j &lt; h - 1; ++j) {</span>

<span class="fc" id="L196">                diffs[0] = ptImg.getValue(i - 1, j);</span>
<span class="fc" id="L197">                diffs[1] = ptImg.getValue(i + 1, j);</span>
<span class="fc" id="L198">                diffs[2] = ptImg.getValue(i, j - 1);</span>
<span class="fc" id="L199">                diffs[3] = ptImg.getValue(i, j + 1);</span>
<span class="fc" id="L200">                offset = 0;</span>
<span class="fc" id="L201">                above = 0;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                for (int k = 0; k &lt; 2; ++k) {</span>
                    // in case there is wrap around, test adding a phase
                    //   and take the smaller of the results for each diff.
<span class="fc bfc" id="L205" title="All 2 branches covered.">                    if (diffs[offset] &gt; diffs[offset + 1]) {</span>
                        // add a phase to next value if it's closer to current with addition
<span class="fc bfc" id="L207" title="All 2 branches covered.">                        if ((diffs[offset] - diffs[offset + 1]) &gt;</span>
                            (diffs[offset + 1] + 255) - diffs[offset]) {
<span class="fc" id="L209">                            diffs[offset + 1] += 255;</span>
                        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">                    } else if (diffs[offset + 1] &gt; diffs[offset]) {</span>
                        // add a phase to next value if it's closer to current with addition
<span class="fc bfc" id="L213" title="All 2 branches covered.">                        if ((diffs[offset + 1] - diffs[offset]) &gt;</span>
                            (diffs[offset] + 255) - diffs[offset + 1]) {
<span class="fc" id="L215">                            diffs[offset] += 255;</span>
                        }
                    }
<span class="fc" id="L218">                    int d = diffs[offset] - diffs[offset + 1];</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                    if (Math.abs(d) &gt;= lowerDiff) {</span>
<span class="fc" id="L220">                        above = 1;</span>
<span class="fc" id="L221">                        break;</span>
                    }
<span class="fc" id="L223">                    offset += 2;</span>
                }

<span class="fc bfc" id="L226" title="All 2 branches covered.">                if (above == 1) {</span>
<span class="fc" id="L227">                    out.setValue(i, j, 1);</span>
                }
            }
        }

<span class="fc" id="L232">        return out;</span>
    }

    /**
     * create  a float array from the image (the image is not scaled).
     * @param img
     * @return
     */
    public float[] copyToFloat(GreyscaleImage img) {

<span class="fc" id="L242">        float[] a = new float[img.getNPixels()];</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L245">            a[i] = img.getValue(i);</span>
        }

<span class="fc" id="L248">        return a;</span>
    }

    /**
     * create  a int array from the image (the image is not scaled).
     * @param img
     * @return
     */
    public int[] copyToInt(GreyscaleImage img) {

<span class="fc" id="L258">        int[] a = new int[img.getNPixels()];</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L261">            a[i] = img.getValue(i);</span>
        }

<span class="fc" id="L264">        return a;</span>
    }

    /**
     * using the binary results from createBinary1stDerivForPolarTheta
     * and the greyscale results from sobel operator,
     * scale the greyscale result so that the maximum value is 1.f,
     * add both and divide by 2.
     * NOTE: for other uses, may want to make a method which does not
     * scale the greyscale results or uses a different weighting
     * in the addition.
     *
     * @param gsImg
     * @param ptImg
     * @param lowerDiff
     * @return
     */
    public float[] createSobelColorScores(GreyscaleImage gsImg,
        GreyscaleImage ptImg, int lowerDiff) {

<span class="nc" id="L284">        int nPix = gsImg.getNPixels();</span>
<span class="nc" id="L285">        int w = gsImg.getWidth();</span>
<span class="nc" id="L286">        int h = gsImg.getHeight();</span>

<span class="nc bnc" id="L288" title="All 4 branches missed.">        if (ptImg.getWidth() != w || ptImg.getHeight() != h) {</span>
<span class="nc" id="L289">            throw new IllegalArgumentException(&quot;images must be same size&quot;);</span>
        }

<span class="nc" id="L292">        GreyscaleImage ptGrad = createBinary1stDerivForPolarTheta(</span>
            ptImg, lowerDiff);

<span class="nc" id="L295">        float[] out = new float[nPix];</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (int i = 0; i &lt; gsImg.getNPixels(); ++i) {</span>
<span class="nc" id="L297">            out[i] = gsImg.getValue(i);</span>
        }

<span class="nc" id="L300">        out = createSobelConvolution(out, w, h);</span>
<span class="nc" id="L301">        float maxV = MiscMath.findMax(out);</span>
<span class="nc" id="L302">        float factor = 0.5f/maxV;</span>
        int pixIdx;
<span class="nc bnc" id="L304" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L306">                pixIdx = (j * w) + i;</span>

<span class="nc" id="L308">                int v0 = ptGrad.getValue(pixIdx);</span>
<span class="nc" id="L309">                float v = out[pixIdx] * factor;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (v0 == 1) {</span>
<span class="nc" id="L311">                    v += 0.5f;</span>
                }
<span class="nc" id="L313">                out[pixIdx] = v;</span>
            }
        }

<span class="nc" id="L317">        return out;</span>
    }

    /**
     * create a greyscale adaptive threshold gradient with canny algorithm
     * and then a color contrast gradient with &quot;H&quot; of LCH, and 1st deriv with
     * a threshold of 20 degrees for binarization, scale them to
     * 127 and add them.
     * The color binary pixels are scaled to 1/4th the maximum
     * of the greyscale gradient.
     *
     * The results could be improved in various ways, but for now
     * is a quick way to look at completing greyscale intensity
     * gradient contours with the color contrast gradient.
     *
     * @param img
     * @return
     */
    public GreyscaleImage createGradientWithColorAndGreyscale(Image img) {

<span class="nc" id="L337">        int w = img.getWidth();</span>
<span class="nc" id="L338">        int h = img.getHeight();</span>

<span class="nc" id="L340">        GreyscaleImage gsImg = img.copyToGreyscale2();</span>

<span class="nc" id="L342">        CannyEdgeFilterAdaptive canny = new CannyEdgeFilterAdaptive();</span>
<span class="nc" id="L343">        canny.overrideToUseAdaptiveThreshold();</span>
<span class="nc" id="L344">        canny.overrideToNotUseLineThinner();</span>
<span class="nc" id="L345">        canny.applyFilter(gsImg);</span>
<span class="nc" id="L346">        EdgeFilterProducts prod = canny.getFilterProducts();</span>

<span class="nc" id="L348">        float[] gsCanny = copyToFloat(prod.getGradientXY());</span>

<span class="nc" id="L350">        GreyscaleImage scaled = MiscMath.rescaleAndCreateImage(gsCanny, w, h);</span>

        //TODO: could consider using the sobel polar theta in canny edges
        //   as additional cues for strong edges in the 2-layer filter
        //   and then only use that result here.

<span class="nc" id="L356">        GreyscaleImage ptImg = createCIELUVTheta(img, 255);</span>
<span class="nc" id="L357">        GreyscaleImage ptGrad =</span>
            //createBinary2ndDerivForPolarTheta(ptImg, 20);
<span class="nc" id="L359">createBinary1stDerivForPolarTheta(ptImg, 20);</span>

        /*
        ptGrad.multiply(255);
        applyAdaptiveMeanThresholding(ptGrad, 1);
        for (int j = 0; j &lt; ptGrad.getNPixels(); ++j) {
            ptGrad.setValue(j, 255 - ptGrad.getValue(j));
        }*/

<span class="nc" id="L368">        float[] ptGradFloat = copyToFloat(ptGrad);</span>

<span class="nc bnc" id="L370" title="All 2 branches missed.">        for (int j = 0; j &lt; ptGradFloat.length; ++j) {</span>
<span class="nc" id="L371">            ptGradFloat[j] *= 63;</span>
<span class="nc" id="L372">            ptGradFloat[j] += scaled.getValue(j);</span>
        }

<span class="nc" id="L375">        scaled = MiscMath.rescaleAndCreateImage(ptGradFloat, w, h);</span>

<span class="nc" id="L377">        return scaled;</span>
    }

    /**
     * given a color image array with first dimension being color index
     * and the second dimension being the image pixel index,
     * apply the sobel kernel to each pixel and combine the results
     * as SSD.
     * @param colorInput with first dimension being color index
     * and the second dimension being the image pixel index
     * @param imgWidth
     * @return 
     */
    public float[] createSobelConvolution(float[][] colorInput, int imgWidth,
        int imgHeight) {

<span class="nc" id="L393">        int nClrs = colorInput.length;</span>
<span class="nc" id="L394">        int nPix = colorInput[0].length;</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (nPix != (imgWidth * imgHeight)) {</span>
<span class="nc" id="L397">            throw new IllegalArgumentException(&quot;image width X height must equal &quot;</span>
                + &quot; colorInput[0].length&quot;);
        }
        
<span class="nc" id="L401">        Kernel1DHelper kernelHelper = new Kernel1DHelper();</span>
<span class="nc" id="L402">        float[] kernelG = new float[]{0.5f, 1.f, 0.5f};</span>
<span class="nc" id="L403">        float[] kernel = new float[]{0.5f, 0, -0.5f};</span>
                
        // apply kernelG to gX then kernel to gX
        // apply kernel to gY then kernelG
        // then combine both

<span class="nc" id="L409">        float[] outX = createConvolution(colorInput, imgWidth, imgHeight,</span>
            kernelG, false);
<span class="nc" id="L411">        outX = createConvolution(outX, imgWidth, imgHeight,</span>
            kernel, true);
        
<span class="nc" id="L414">        float[] outY = createConvolution(colorInput, imgWidth, imgHeight,</span>
            kernel, true);
<span class="nc" id="L416">        outY = createConvolution(outY, imgWidth, imgHeight,</span>
            kernelG, false);
         
<span class="nc" id="L419">        float[] out = new float[nPix];</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        for (int i = 0; i &lt; nPix; ++i) {</span>
<span class="nc" id="L421">            float v = outX[i] * outX[i] + outY[i] * outY[i];</span>
<span class="nc" id="L422">            v = (float)Math.sqrt(v/2.f);</span>
<span class="nc" id="L423">            out[i] = v;</span>
        }
        
<span class="nc" id="L426">        return out;</span>
    }
    
    private float[] createConvolution(float[][] colorInput, int imgWidth,
        int imgHeight, float[] kernel, boolean calcForX) {

<span class="nc" id="L432">        int nClrs = colorInput.length;</span>
<span class="nc" id="L433">        int nPix = colorInput[0].length;</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (nPix != (imgWidth * imgHeight)) {</span>
<span class="nc" id="L436">            throw new IllegalArgumentException(&quot;image width X height must equal &quot;</span>
                + &quot; colorInput[0].length&quot;);
        }
        
<span class="nc" id="L440">        Kernel1DHelper kernelHelper = new Kernel1DHelper();</span>
        
<span class="nc" id="L442">        float[] out = new float[nPix];</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (int i = 0; i &lt; imgWidth; ++i) {</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            for (int j = 0; j &lt; imgHeight; ++j) {</span>

<span class="nc" id="L447">                double sum = 0;</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">                for (int c = 0; c &lt; nClrs; ++c) {</span>

<span class="nc bnc" id="L451" title="All 2 branches missed.">                    if (calcForX) {</span>
<span class="nc" id="L452">                        sum += kernelHelper.convolvePointWithKernel(</span>
                            colorInput[c], i, j, kernel, true, imgWidth, imgHeight);
                    } else {
<span class="nc" id="L455">                        sum += kernelHelper.convolvePointWithKernel(</span>
                            colorInput[c], i, j, kernel, false, imgWidth, imgHeight);
                    }
                }

<span class="nc" id="L460">                int pixIdx = (j * imgWidth) + i;</span>

<span class="nc" id="L462">                out[pixIdx] = (float)(sum/(float)nClrs);</span>
            }
        }

<span class="nc" id="L466">        return out;</span>
    }
    
    private float[] createConvolution(float[] input, int imgWidth,
        int imgHeight, float[] kernel, boolean calcForX) {

<span class="nc" id="L472">        int nPix = input.length;</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (nPix != (imgWidth * imgHeight)) {</span>
<span class="nc" id="L475">            throw new IllegalArgumentException(&quot;image width X height must equal &quot;</span>
                + &quot; input.length&quot;);
        }
        
<span class="nc" id="L479">        Kernel1DHelper kernelHelper = new Kernel1DHelper();</span>
        
<span class="nc" id="L481">        float[] out = new float[nPix];</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">        for (int i = 0; i &lt; imgWidth; ++i) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            for (int j = 0; j &lt; imgHeight; ++j) {</span>

<span class="nc" id="L486">                float sum = 0;</span>

<span class="nc bnc" id="L488" title="All 2 branches missed.">                if (calcForX) {</span>
<span class="nc" id="L489">                    sum += kernelHelper.convolvePointWithKernel(</span>
                        input, i, j, kernel, true, imgWidth, imgHeight);
                } else {
<span class="nc" id="L492">                    sum += kernelHelper.convolvePointWithKernel(</span>
                        input, i, j, kernel, false, imgWidth, imgHeight);
                }

<span class="nc" id="L496">                int pixIdx = (j * imgWidth) + i;</span>

<span class="nc" id="L498">                out[pixIdx] = sum;</span>
            }
        }

<span class="nc" id="L502">        return out;</span>
    }

    /**
     * given a greyscale image
     * apply the kernel to each pixel and combine the results
     * as SSD.
     * @param greyscaleInput with index being the image pixel index
     */
    public float[] createSobelConvolution(float[] greyscaleInput, int imgWidth,
        int imgHeight) {

<span class="nc" id="L514">        int nPix = greyscaleInput.length;</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (nPix != (imgWidth * imgHeight)) {</span>
<span class="nc" id="L517">            throw new IllegalArgumentException(&quot;image width X height must equal &quot;</span>
                + &quot; colorInput[0].length&quot;);
        }

<span class="nc" id="L521">        Kernel1DHelper kernelHelper = new Kernel1DHelper();</span>
<span class="nc" id="L522">        float[] kernelG = new float[]{0.5f, 1.f, 0.5f};</span>
<span class="nc" id="L523">        float[] kernel = new float[]{0.5f, 0, -0.5f};</span>
         
        // apply kernelG to gX then kernel to gX
        // apply kernel to gY then kernelG
        // then combine both

<span class="nc" id="L529">        float[] outX = createConvolution(greyscaleInput, imgWidth, imgHeight,</span>
            kernelG, false);
<span class="nc" id="L531">        outX = createConvolution(outX, imgWidth, imgHeight,</span>
            kernel, true);
        
<span class="nc" id="L534">        float[] outY = createConvolution(greyscaleInput, imgWidth, imgHeight,</span>
            kernel, true);
<span class="nc" id="L536">        outY = createConvolution(outY, imgWidth, imgHeight,</span>
            kernelG, false);
         
<span class="nc" id="L539">        float[] out = new float[nPix];</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        for (int i = 0; i &lt; nPix; ++i) {</span>
<span class="nc" id="L541">            float v = outX[i] * outX[i] + outY[i] * outY[i];</span>
<span class="nc" id="L542">            v = (float)Math.sqrt(v/2.f);</span>
<span class="nc" id="L543">            out[i] = v;</span>
        }
        
<span class="nc" id="L546">        return out;</span>
    }

    public void applySobelX(float[][] input) {

        //0.5f, 0.0f, -0.5f
<span class="fc" id="L552">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

        /*
         1
         2  * [1 0 -1]
         1
        */
<span class="fc" id="L559">        applyKernel1D(input, new float[]{0.5f, 1.f, 0.5f}, false);</span>
        
<span class="fc" id="L561">        applyKernel1D(input, kernel, true);</span>
<span class="fc" id="L562">    }</span>
    public void applySobelX(double[][] input) {

        //0.5f, 0.0f, -0.5f
<span class="fc" id="L566">        double[] kernel = MiscMath0.convertFloatToDouble(Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive());</span>

        /*
         1
         2  * [1 0 -1]
         1
        */
<span class="fc" id="L573">        applyKernel1D(input, new double[]{0.5, 1., 0.5}, false);</span>

<span class="fc" id="L575">        applyKernel1D(input, kernel, true);</span>
<span class="fc" id="L576">    }</span>

    public void applySobelY(float[][] input) {

        /*
         1
         0  * [1 2 1]
         -1
        */

        //0.5f, 0.0f, -0.5f
<span class="fc" id="L587">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();</span>

<span class="fc" id="L589">        applyKernel1D(input, kernel, false);</span>
        
<span class="fc" id="L591">        applyKernel1D(input, new float[]{0.5f, 1.f, 0.5f}, true);</span>
<span class="fc" id="L592">    }</span>

    public void applySobelY(double[][] input) {

        /*
         1
         0  * [1 2 1]
         -1
        */

        //0.5f, 0.0f, -0.5f
<span class="fc" id="L603">        double[] kernel = MiscMath0.convertFloatToDouble(Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive());</span>

<span class="fc" id="L605">        applyKernel1D(input, kernel, false);</span>

<span class="fc" id="L607">        applyKernel1D(input, new double[]{0.5, 1., 0.5}, true);</span>
<span class="fc" id="L608">    }</span>
    
    /**
     * calculate the 1st deriv gradient of the color image using CIELAB DeltaE 2000
     * and return gX, gY, and gXY with array indices being pixel
     * indexes of the image.
     * @param img
     * @return float[][]{gX, gY, gXY}
     */
    public float[][] calculateGradientUsingDeltaE2000(ImageExt img) {

        //TODO: consider making this sobel by applying the gaussian kernel too
        
<span class="fc" id="L621">        int n = img.getNPixels();</span>

<span class="fc" id="L623">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L625">        int w = img.getWidth();</span>
<span class="fc" id="L626">        int h = img.getHeight();</span>

<span class="fc" id="L628">        float jnd = 2.3f;</span>

        // using 1D 1st deriv kernel -1,0,1, calculating deltaE
        // between the pixels to either side of center pixel

        int x1, y1, x2, y2;

<span class="fc" id="L635">        float[] outX = new float[n];</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>

<span class="fc" id="L638">            x1 = i - 1;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">            if (x1 &lt; 0) {</span>
<span class="fc" id="L640">                x1 = 0;</span>
            }
<span class="fc" id="L642">            x2 = i + 1;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">            if (x2 &gt; (w - 1)) {</span>
<span class="fc" id="L644">                x2 = w - 1;</span>
            }

<span class="fc bfc" id="L647" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="fc" id="L649">                float[] lab1 = img.getCIELAB(x1, j);</span>
<span class="fc" id="L650">                float[] lab2 = img.getCIELAB(x2, j);</span>

<span class="fc" id="L652">                double deltaE = cieC.calcDeltaECIE2000(</span>
                    lab1, lab2);

<span class="fc" id="L655">                outX[img.getInternalIndex(i, j)] = (float)deltaE;</span>
            }
        }

<span class="fc" id="L659">        float[] outY = new float[n];</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>

<span class="fc bfc" id="L662" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="fc" id="L664">                y1 = j - 1;</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                if (y1 &lt; 0) {</span>
<span class="fc" id="L666">                    y1 = 0;</span>
                }
<span class="fc" id="L668">                y2 = j + 1;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (y2 &gt; (h - 1)) {</span>
<span class="fc" id="L670">                    y2 = h - 1;</span>
                }

<span class="fc" id="L673">                float[] lab1 = img.getCIELAB(i, y1);</span>
<span class="fc" id="L674">                float[] lab2 = img.getCIELAB(i, y2);</span>

<span class="fc" id="L676">                double deltaE = cieC.calcDeltaECIE2000(</span>
                    lab1, lab2);

<span class="fc" id="L679">                outY[img.getInternalIndex(i, j)] = (float)deltaE;</span>
            }
        }

        // make a combined array
<span class="fc" id="L684">        float[] outXY = new float[outX.length];</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">        for (int i = 0; i &lt; outX.length; ++i) {</span>
<span class="fc" id="L686">            double gXY = Math.sqrt((outX[i] * outX[i] + outY[i] * outY[i])/2.f);</span>
<span class="fc" id="L687">            outXY[i] = (float)gXY;</span>
        }

<span class="fc" id="L690">        return new float[][]{outX, outY, outXY};</span>
    }

    public GreyscaleImage applyLaplacianKernel(GreyscaleImage input,
        int minValue, int maxValue) {

<span class="fc" id="L696">        IKernel kernel = new Laplacian();</span>
<span class="fc" id="L697">        Kernel kernelXY = kernel.getKernel();</span>

<span class="fc" id="L699">        float norm = kernel.getNormalizationFactor();</span>

<span class="fc" id="L701">        return applyKernel(input, kernelXY, norm, minValue, maxValue);</span>
    }

    public Image combineConvolvedImages(Image imageX, Image imageY) {

<span class="fc" id="L706">        Image img2 = imageX.createWithDimensions();</span>

<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L711">                int rX = imageX.getR(i, j);</span>
<span class="fc" id="L712">                int gX = imageX.getG(i, j);</span>
<span class="fc" id="L713">                int bX = imageX.getB(i, j);</span>

<span class="fc" id="L715">                int rY = imageY.getR(i, j);</span>
<span class="fc" id="L716">                int gY = imageY.getG(i, j);</span>
<span class="fc" id="L717">                int bY = imageY.getB(i, j);</span>

<span class="fc" id="L719">                double r = Math.sqrt((rX*rX + rY*rY)/2.f);</span>
<span class="fc" id="L720">                double g = Math.sqrt((gX*gX + gY*gY)/2.f);</span>
<span class="fc" id="L721">                double b = Math.sqrt((bX*bX + bY*bY)/2.f);</span>

<span class="pc bpc" id="L723" title="1 of 2 branches missed.">                r = (r &gt; 255) ? 255 : r;</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">                g = (g &gt; 255) ? 255 : g;</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">                b = (b &gt; 255) ? 255 : b;</span>

                //int rgb = (int)(((rSum &amp; 0x0ff) &lt;&lt; 16)
                //    | ((gSum &amp; 0x0ff) &lt;&lt; 8) | (bSum &amp; 0x0ff));

<span class="fc" id="L730">                img2.setRGB(i, j, (int)r, (int)g, (int)b);</span>
            }
        }

<span class="fc" id="L734">        return img2;</span>
    }

    /**
     * @param imageX
     * @param imageY
     * @return
     */
    public GreyscaleImage combineConvolvedImages(final GreyscaleImage imageX,
        final GreyscaleImage imageY) {

<span class="fc" id="L745">        GreyscaleImage img2 = imageX.createWithDimensions();</span>

<span class="fc bfc" id="L747" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L750">                int gX = imageX.getValue(i, j);</span>

<span class="fc" id="L752">                int gY = imageY.getValue(i, j);</span>

<span class="fc" id="L754">                double g = Math.sqrt((gX*gX + gY*gY)/2.f);</span>

<span class="pc bpc" id="L756" title="1 of 2 branches missed.">                if (g &gt; 255) {</span>
<span class="nc" id="L757">                    g = 255;</span>
                }

<span class="fc" id="L760">                img2.setValue(i, j, (int)g);</span>
            }
        }

<span class="fc" id="L764">        return img2;</span>
    }

    public int[][] applyKernel(int[][] a, int[][] b) {

<span class="fc" id="L769">        final int na0 = a.length;</span>
<span class="fc" id="L770">        final int na1 = a[0].length;</span>
<span class="fc" id="L771">        final int nb0 = b.length;</span>
<span class="fc" id="L772">        final int nb1 = b[0].length;</span>

<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (nb1 &gt; nb0) {</span>
<span class="nc" id="L775">            throw new IllegalArgumentException(&quot;expecting first argument to be &quot;</span>
            + &quot; data and the 2nd to be the kernel to convolve the data with&quot;);
        }

<span class="fc" id="L779">        int nbmid0 = (nb0 - 1)/2;</span>
<span class="fc" id="L780">        int nbmid1 = (nb1 - 1)/2;</span>

<span class="fc" id="L782">        int[][] output = new int[na0][na1];</span>

<span class="fc bfc" id="L784" title="All 2 branches covered.">        for (int i = 0; i &lt; na0; i++) {</span>

<span class="fc" id="L786">            output[i] = new int[na1];</span>

<span class="fc bfc" id="L788" title="All 2 branches covered.">            for (int j = 0; j &lt; na1; j++) {</span>

<span class="fc" id="L790">                int sum = 0;</span>

<span class="fc bfc" id="L792" title="All 2 branches covered.">                for (int col = 0; col &lt; nb0; col++) {</span>

<span class="fc" id="L794">                    int x = col - nbmid0;</span>

<span class="fc" id="L796">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="fc bfc" id="L799" title="All 2 branches covered.">                    if (imgX &lt; 0) {</span>
<span class="fc" id="L800">                        imgX = -1 * imgX - 1;</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">                    } else if (imgX &gt;= na0) {</span>
<span class="fc" id="L802">                        int diff = imgX - na0;</span>
<span class="fc" id="L803">                        imgX = na0 - diff - 1;</span>
                    }

<span class="fc bfc" id="L806" title="All 2 branches covered.">                    for (int row = 0; row &lt; nb1; row++) {</span>

<span class="fc" id="L808">                        int y = row - nbmid1;</span>

<span class="fc" id="L810">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="fc bfc" id="L813" title="All 2 branches covered.">                        if (imgY &lt; 0) {</span>
<span class="fc" id="L814">                            imgY = -1 * imgY - 1;</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">                        } else if (imgY &gt;= na1) {</span>
<span class="fc" id="L816">                            int diff = imgY - na1;</span>
<span class="fc" id="L817">                            imgY = na1 - diff - 1;</span>
                        }

<span class="fc" id="L820">                        int k = b[col][row];</span>

<span class="fc" id="L822">                        sum += k * a[imgX][imgY];</span>
                    }
                }

<span class="fc" id="L826">                output[i][j] = sum;</span>
            }
        }

<span class="fc" id="L830">        return output;</span>
    }

    /**
     * apply kernel to input. NOTE, that because the image is composed of
     * vectors that should have values between 0 and 255, inclusive, if the
     * kernel application results in a value outside of that range, the value
     * is reset to 0 or 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(float[][] input, Kernel kernel, float normFactor) {

<span class="fc" id="L844">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="fc" id="L846">        int width = input.length;</span>
<span class="fc" id="L847">        int height = input[0].length;</span>

<span class="fc" id="L849">        float[][] output = new float[width][];</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="fc" id="L851">            output[i] = new float[height];</span>
        }

<span class="fc bfc" id="L854" title="All 2 branches covered.">        for (int i = 0; i &lt; width; i++) {</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">            for (int j = 0; j &lt; height; j++) {</span>

<span class="fc" id="L857">                double value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="fc bfc" id="L861" title="All 2 branches covered.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="fc" id="L863">                    int x = col - h;</span>

<span class="fc" id="L865">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="fc bfc" id="L868" title="All 2 branches covered.">                    if (imgX &lt; 0) {</span>
<span class="fc" id="L869">                        imgX = -1 * imgX - 1;</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">                    } else if (imgX &gt;= width) {</span>
<span class="fc" id="L871">                        int diff = imgX - width;</span>
<span class="fc" id="L872">                        imgX = width - diff - 1;</span>
                    }

<span class="fc bfc" id="L875" title="All 2 branches covered.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="fc" id="L877">                        int y = row - h;</span>

<span class="fc" id="L879">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="fc bfc" id="L882" title="All 2 branches covered.">                        if (imgY &lt; 0) {</span>
<span class="fc" id="L883">                            imgY = -1 * imgY - 1;</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                        } else if (imgY &gt;= height) {</span>
<span class="fc" id="L885">                            int diff = imgY - height;</span>
<span class="fc" id="L886">                            imgY = height - diff - 1;</span>
                        }

<span class="fc" id="L889">                        float v = input[imgX][imgY];</span>

<span class="fc" id="L891">                        int k = kernel.getValue(col, row);</span>

<span class="fc" id="L893">                        value += k * v;</span>
                    }
                }

<span class="fc" id="L897">                value *= normFactor;</span>

<span class="fc" id="L899">                output[i][j] = (float)value;</span>
            }
        }

<span class="fc bfc" id="L903" title="All 2 branches covered.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="fc" id="L904">            System.arraycopy(output[i], 0, input[i], 0, height);</span>
        }
<span class="fc" id="L906">    }</span>

    public void applyKernel(double[][] input, double[][] kernel) {

        // using col major notation here, but input can be row major to create same results.
<span class="nc" id="L911">        int h = (kernel.length - 1) &gt;&gt; 1;</span>

<span class="nc" id="L913">        int width = input.length;</span>
<span class="nc" id="L914">        int height = input[0].length;</span>

<span class="nc" id="L916">        double[][] output = new double[width][height];</span>

<span class="nc bnc" id="L918" title="All 2 branches missed.">        for (int i = 0; i &lt; width; i++) {</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">            for (int j = 0; j &lt; height; j++) {</span>

<span class="nc" id="L921">                double value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L925" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.length; col++) {</span>

<span class="nc" id="L927">                    int x = col - h;</span>

<span class="nc" id="L929">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L932" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L933">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                    } else if (imgX &gt;= width) {</span>
<span class="nc" id="L935">                        int diff = imgX - width;</span>
<span class="nc" id="L936">                        imgX = width - diff - 1;</span>
                    }

<span class="nc bnc" id="L939" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel[col].length; row++) {</span>

<span class="nc" id="L941">                        int y = row - h;</span>

<span class="nc" id="L943">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L946" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L947">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">                        } else if (imgY &gt;= height) {</span>
<span class="nc" id="L949">                            int diff = imgY - height;</span>
<span class="nc" id="L950">                            imgY = height - diff - 1;</span>
                        }

<span class="nc" id="L953">                        double v = input[imgX][imgY];</span>

<span class="nc" id="L955">                        double k = kernel[col][row];</span>

<span class="nc" id="L957">                        value += k * v;</span>
                    }
                }
<span class="nc" id="L960">                output[i][j] = value;</span>
            }
        }

<span class="nc bnc" id="L964" title="All 2 branches missed.">        for (int i = 0; i &lt; width; ++i) {</span>
<span class="nc" id="L965">            System.arraycopy(output[i], 0, input[i], 0, height);</span>
        }
<span class="nc" id="L967">    }</span>

    /**
     * apply kernel to input. NOTE, that because the image is composed of vectors
     * that should have values between 0 and 255, inclusive, if the kernel application
     * results in a value outside of that range, the value is reset to 0 or
     * 255.
     * @param input
     * @param kernel
     * @param normFactor
     * @return the convolved image
     */
    protected GreyscaleImage applyKernel(GreyscaleImage input, Kernel kernel, 
        float normFactor, int minValue, int maxValue) {

<span class="fc" id="L982">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="fc" id="L984">        GreyscaleImage output = input.createFullRangeIntWithDimensions();</span>

        //TODO: consider changing normalization to be similar to Kernel1DHelper

<span class="fc bfc" id="L988" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="fc" id="L991">                double value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="fc bfc" id="L995" title="All 2 branches covered.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="fc" id="L997">                    int x = col - h;</span>

<span class="fc" id="L999">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                    if (imgX &lt; 0) {</span>
<span class="fc" id="L1003">                        imgX = -1 * imgX - 1;</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="fc" id="L1005">                        int diff = imgX - input.getWidth();</span>
<span class="fc" id="L1006">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="fc bfc" id="L1009" title="All 2 branches covered.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="fc" id="L1011">                        int y = row - h;</span>

<span class="fc" id="L1013">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                        if (imgY &lt; 0) {</span>
<span class="fc" id="L1017">                            imgY = -1 * imgY - 1;</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="fc" id="L1019">                            int diff = imgY - input.getHeight();</span>
<span class="fc" id="L1020">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="fc" id="L1023">                        int pixel = input.getValue(imgX, imgY);</span>
<span class="fc" id="L1024">                        int k = kernel.getValue(col, row);</span>

<span class="fc" id="L1026">                        value += k * pixel;</span>
                    }
                }
<span class="fc" id="L1029">                value *= normFactor;</span>

<span class="fc" id="L1031">                int v = (int)value;</span>
                
<span class="fc bfc" id="L1033" title="All 2 branches covered.">                if (v &lt; minValue) {</span>
<span class="fc" id="L1034">                    v = minValue;</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">                } else if (v &gt; maxValue) {</span>
<span class="nc" id="L1036">                    v = maxValue;</span>
                }

<span class="fc" id="L1039">                output.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L1043">        return output;</span>
    }

    /**
     * calculate theta from the gradient x and y images.
     * &lt;pre&gt;
     * The results are given as quadrants of values from 0 to 90.
     *
     *     -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45

           when X is 0: if Y &gt; 0, theta is 90
           when Y is 0: if X &gt;= 0, theta is 0
     * &lt;/pre&gt;
     * @param convolvedX
     * @param convolvedY
     * @return
     */
    public GreyscaleImage computeTheta(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="fc" id="L1067">        GreyscaleImage output = convolvedX.createSignedWithDimensions();</span>

<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L1072">                double gX = convolvedX.getValue(i, j);</span>

<span class="fc" id="L1074">                double gY = convolvedY.getValue(i, j);</span>

<span class="fc" id="L1076">                int thetaG = calculateTheta(gX, gY);</span>

<span class="fc" id="L1078">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="fc" id="L1083">        return output;</span>
    }

    /**
     * calculate theta from the gradient x and y images and transform to
     * range 0 to 180.
     * &lt;pre&gt;
     *
     *           90    45          y/x
                -  |  +
          180 -----|----- 0
                +  |  -

     * &lt;/pre&gt;
     *
     * @param gradientX
     * @param gradientY
     * @return
     */
    public GreyscaleImage computeTheta180(final GreyscaleImage gradientX,
        final GreyscaleImage gradientY) {

<span class="fc" id="L1105">        GreyscaleImage output = gradientX.createWithDimensions();</span>

<span class="fc bfc" id="L1107" title="All 2 branches covered.">        for (int i = 0; i &lt; gradientX.getWidth(); i++) {</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">            for (int j = 0; j &lt; gradientX.getHeight(); j++) {</span>

<span class="fc" id="L1110">                double gX = gradientX.getValue(i, j);</span>

<span class="fc" id="L1112">                double gY = gradientY.getValue(i, j);</span>

<span class="fc bfc" id="L1114" title="All 2 branches covered.">                if (gY &lt; 0) {</span>
<span class="fc" id="L1115">                    gX *= -1;</span>
<span class="fc" id="L1116">                    gY *= -1;</span>
                }

<span class="fc" id="L1119">                double radians = Math.atan2(gY, gX);</span>
<span class="pc bnc" id="L1120" title="All 4 branches missed.">                assert(radians &gt;= 0. &amp;&amp; radians &lt;= 2.*Math.PI);</span>
                
<span class="fc" id="L1122">                int theta = (int)(radians * 180./Math.PI);</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                if (theta == 180) {</span>
<span class="fc" id="L1124">                    theta = 0;</span>
                }
<span class="pc bnc" id="L1126" title="All 4 branches missed.">                assert(theta &gt;= 0 &amp;&amp; theta &lt; 180);</span>
                
<span class="fc" id="L1128">                output.setValue(i, j, theta);</span>
            }
        }

<span class="fc" id="L1132">        return output;</span>
    }
    
    /**
     * calculate theta from the gradient x and y images and transform to
     * range 0 to 360.
     * &lt;pre&gt;
     *
     *           90    45          y/x
                -  |  +
          180 -----|----- 0
                +  |  -

     * &lt;/pre&gt;
     *
     * @param convolvedX
     * @param convolvedY
     * @return
     */
    public GreyscaleImage computeTheta360_2(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="fc" id="L1154">        GreyscaleImage output = convolvedX.createFullRangeIntWithDimensions();</span>

<span class="fc bfc" id="L1156" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L1159">                double gX = convolvedX.getValue(i, j);</span>

<span class="fc" id="L1161">                double gY = convolvedY.getValue(i, j);</span>

                // -PI to PI then add PI
<span class="fc" id="L1164">                double radians = Math.atan2(gY, gX) + Math.PI;</span>

<span class="fc" id="L1166">                int theta = (int)(radians * 180./Math.PI);</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">                if (theta == 180) {</span>
<span class="fc" id="L1168">                    theta = 0;</span>
                }

<span class="fc" id="L1171">                output.setValue(i, j, theta);</span>
            }
        }

<span class="fc" id="L1175">        return output;</span>
    }

    /**
     * calculate theta, transforming values from -pi to pi to range 0 to 360.
     * Note that the value of theta for pixel with gradientX or gradientY
     * smaller than the resolution of the data (FWHM of PSF) is actually
     * orthogonal to it's real value, so those need to be interpreted
     * differently.
     * To calculate the minimum resolvable angle, combine the sigmas in
     * quadrature for all stages used to create the gradients.
     * For example, a blur using sigma=1 followed by a gradient using
     * sigma sqrt(1)/2 results in a sigma of
     * sqrt( (1*1) + (sqrt(1)/2)*(sqrt(1)/2) ).  The FWHM of the combined
     * operations is then approx 2.35 * sigma, so that's 3 pixels.
     * The minimum resolvable angle is then math.atan2(1, 3)*180./Math.PI is
     * 18.4 degrees for this example, so any theta within 19 degrees of
     * horizontal or vertical where there is signal in the image, has to be
     * corrected by 90 degrees.
     * Such correction isn't made here to allow the method to be used without
     * such knowledge.
     * &lt;pre&gt;
     *           Y
     *          90
     *     135   |    +45
     *           |
     *   180------------ 0   X
     *           |
     *    225    |   315
     *          270
     * &lt;/pre&gt;
     * @param gradientX
     * @param gradientY
     * @return
     */
    public GreyscaleImage computeTheta360_0(final GreyscaleImage gradientX,
        final GreyscaleImage gradientY) {

<span class="nc" id="L1213">        GreyscaleImage output = gradientX.createFullRangeIntWithDimensions();</span>

<span class="nc bnc" id="L1215" title="All 2 branches missed.">        for (int i = 0; i &lt; gradientX.getWidth(); i++) {</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            for (int j = 0; j &lt; gradientX.getHeight(); j++) {</span>

<span class="nc" id="L1218">                double gX = gradientX.getValue(i, j);</span>

<span class="nc" id="L1220">                double gY = gradientY.getValue(i, j);</span>

                // -pi to pi radians
<span class="nc" id="L1223">                double theta = Math.atan2(gY, gX);</span>

                // transform to 0 to 2*pi radians
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                if (theta &lt; 0) {</span>
<span class="nc" id="L1227">                    theta += 2. * Math.PI;</span>
                }

<span class="nc" id="L1230">                int d = (int)Math.round(theta * 180./Math.PI);</span>

<span class="nc" id="L1232">                output.setValue(i, j, d);</span>
            }
        }

<span class="nc" id="L1236">        return output;</span>
    }

    /**
     * compute theta as a polar angle that increases in a clockwise manner
     * and has a range from 0 to 359, inclusive.
     *
     * @param convolvedX
     * @param convolvedY
     * @return
     */
    public GreyscaleImage computeTheta360(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="nc" id="L1250">        GreyscaleImage output = convolvedX.createFullRangeIntWithDimensions();</span>

<span class="nc bnc" id="L1252" title="All 2 branches missed.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="nc" id="L1255">                double gX = convolvedX.getValue(i, j);</span>

<span class="nc" id="L1257">                double gY = convolvedY.getValue(i, j);</span>

<span class="nc" id="L1259">                double thetaR = (2. * Math.PI) - AngleUtil.polarAngleCCW(gX, gY);</span>

<span class="nc" id="L1261">                int thetaG = (int)Math.round(thetaR * 180./Math.PI);</span>

<span class="nc bnc" id="L1263" title="All 2 branches missed.">                if (thetaG &gt; 359) {</span>
<span class="nc" id="L1264">                    thetaG = thetaG - 360;</span>
                }

<span class="nc" id="L1267">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="nc" id="L1272">        return output;</span>
    }

    public GreyscaleImage subtractImages(final GreyscaleImage image,
        final GreyscaleImage subtrImage) {

<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">        if (image.getWidth() != subtrImage.getWidth()) {</span>
<span class="nc" id="L1279">            throw new IllegalArgumentException(&quot;image widths must be the same&quot;);</span>
        }
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if (image.getHeight() != subtrImage.getHeight()) {</span>
<span class="nc" id="L1282">            throw new IllegalArgumentException(&quot;image heights must be the same&quot;);</span>
        }

<span class="fc" id="L1285">        GreyscaleImage output = image.createFullRangeIntWithDimensions();</span>

<span class="fc bfc" id="L1287" title="All 2 branches covered.">        for (int i = 0; i &lt; image.getWidth(); i++) {</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">            for (int j = 0; j &lt; image.getHeight(); j++) {</span>

<span class="fc" id="L1290">                int diff = image.getValue(i, j) - subtrImage.getValue(i, j);</span>

<span class="fc" id="L1292">                output.setValue(i, j, diff);</span>
            }
        }

<span class="fc" id="L1296">        return output;</span>
    }

    protected int calculateTheta(double gradientX, double gradientY) {

        /*  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45

           when X is 0: if Y &gt; 0, theta is 90
           when Y is 0: if X &gt;= 0, theta is 0
        */

<span class="fc bfc" id="L1311" title="All 4 branches covered.">        if (gradientX == 0 &amp;&amp; (gradientY != 0)) {</span>
<span class="fc" id="L1312">            return 90;</span>
        }

<span class="fc bfc" id="L1315" title="All 2 branches covered.">        if (gradientY == 0) {</span>
<span class="fc" id="L1316">            return 0;</span>
        }

<span class="fc" id="L1319">        double theta = Math.atan(gradientY/gradientX)*180./Math.PI;</span>

<span class="fc" id="L1321">        int angle = (int)theta;</span>

        // +x, +y -&gt; +
        // -x, +y -&gt; -
        // -x, -y -&gt; +
        // +x, -y -&gt; -

<span class="fc bfc" id="L1328" title="All 4 branches covered.">        if (!(gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L1331">                angle *= -1;</span>
            }
<span class="fc bfc" id="L1333" title="All 4 branches covered.">        } else if ((gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="nc" id="L1336">                angle *= -1;</span>
            }
<span class="pc bpc" id="L1338" title="1 of 4 branches missed.">        } else if ((gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L1341">                angle *= -1;</span>
            }
<span class="pc bpc" id="L1343" title="2 of 4 branches missed.">        } else if (!(gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="nc" id="L1346">                angle *= -1;</span>
            }
        }

<span class="fc" id="L1350">        return angle;</span>
    }

    protected void blur(GreyscaleImage input, float[] kernel) {

<span class="fc" id="L1355">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1357">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L1358">    }</span>

    protected void applyKernelTwo1Ds(int[][] input, float[] kernel) {

<span class="fc" id="L1362">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1364">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L1365">    }</span>

    public void applyKernelTwo1Ds(float[][] input, float[] kernel) {

<span class="fc" id="L1369">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1371">        applyKernel1D(input, kernel, false);</span>

<span class="fc" id="L1373">    }</span>

    public void applyKernelTwo1Ds(double[][] input, double[] kernel) {

<span class="fc" id="L1377">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L1379">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L1380">    }</span>

    protected void blur(GreyscaleImage input, float[] kernel, int minValue, int maxValue) {

<span class="nc" id="L1384">        applyKernel1D(input, kernel, true, minValue, maxValue);</span>

<span class="nc" id="L1386">        applyKernel1D(input, kernel, false, minValue, maxValue);</span>
<span class="nc" id="L1387">    }</span>

    public void blur(GreyscaleImage input, float sigma) {

<span class="nc" id="L1391">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="nc" id="L1393">        blur(input, kernel);</span>
<span class="nc" id="L1394">    }</span>

    /**
     * in order to make a smoother &quot;blur&quot; operation, the full gaussian
     * profile down to 0.001 * HWZI is created and convolved with image input
     * at a smaller sigma, recursively, until the resulting sigma equals
     * the sigma given to the method.
     * gaussian profiles add in quadrature,
     * sigma_tot^2 = sigma_1^2 + sigma_2^2.
     *
     * @param input
     * @param sigma should be a quadrature factor of sqrt(2)/2, that is
     *     sqrt(2)/2, 1, sqrt(1.5), sqrt(2.0), sqrt(2.5), sqrt(3.0),
     *     sqrt(3.5), sqrt(4.0), sqrt(4.5)...
     *     in other words, the square of sigma should be 0.5 or a positive non zero
     *     integer or a positive non zero integer plus 0.5.
     */
    public void recursiveBlur(float[][] input, SIGMA sigma) {

<span class="fc" id="L1413">        float sigmaF = SIGMA.getValue(sigma);</span>
<span class="fc" id="L1414">        float sigmaFSQ = sigmaF * sigmaF;</span>
<span class="fc" id="L1415">        int sigmaISQ = (int)Math.floor(sigmaF);</span>
<span class="fc" id="L1416">        float remainder = sigmaFSQ - sigmaISQ;</span>
<span class="pc bpc" id="L1417" title="1 of 2 branches missed.">        if (!(</span>
<span class="pc bpc" id="L1418" title="5 of 6 branches missed.">            ((sigmaISQ &gt;= 0) &amp;&amp; (Math.abs(remainder - 0.5f) &lt; 0.01))</span>
            || ((sigmaISQ &gt; 0) &amp;&amp; (remainder &lt; 0.01))
            )) {
<span class="nc" id="L1421">            throw new IllegalArgumentException(&quot;sigma has to be a value that&quot;</span>
                + &quot;is the result of recursive combinations of sqrt(2)/2&quot;);
        }

<span class="fc" id="L1425">        float sigma0Sq = (float)Math.sqrt(2.)/2.f;</span>
<span class="fc" id="L1426">        sigma0Sq *= sigma0Sq;</span>

<span class="fc" id="L1428">        float currentSigmaSq = sigma0Sq;</span>

<span class="fc" id="L1430">        float finalSigmaSq = SIGMA.getValue(sigma);</span>
<span class="fc" id="L1431">        finalSigmaSq *= finalSigmaSq;</span>

        //float[] kernel = Gaussian1D.getKernel((float)Math.sqrt(2.)/2.f, 0);
        //for sigma=sqrt(2)/2 kernel
        //   =[6.962646E-5, 0.010333488, 0.20755373, 0.5641896,
        //     0.20755373, 0.010333488, 6.962646E-5]
        // which is essentially 1, 20, 56, 20, 1
<span class="fc" id="L1438">        final float[] kernel = new float[]{0.010333488f, 0.20755373f, 0.5641896f,</span>
             0.20755373f, 0.010333488f};

        do {
<span class="fc" id="L1442">            applyKernel1D(input, kernel, true);</span>
<span class="fc" id="L1443">            applyKernel1D(input, kernel, false);</span>

<span class="fc" id="L1445">            currentSigmaSq = currentSigmaSq + sigma0Sq;</span>

<span class="pc bpc" id="L1447" title="3 of 4 branches missed.">        } while ((finalSigmaSq &gt; currentSigmaSq) &amp;&amp; Math.abs(finalSigmaSq - currentSigmaSq) &gt; 0.01);</span>

<span class="fc" id="L1449">    }</span>

    public void blur(GreyscaleImage input, SIGMA sigma) {

<span class="fc" id="L1453">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1455">        blur(input, kernel);</span>
<span class="fc" id="L1456">    }</span>

    public void blur(GreyscaleImage input, SIGMA sigma, int minValue, int maxValue) {
<span class="nc" id="L1459">        float[] kernel = Gaussian1D.getKernel(sigma);</span>
<span class="nc" id="L1460">        blur(input, kernel, minValue, maxValue);</span>
<span class="nc" id="L1461">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, float sigma) {

<span class="fc" id="L1470">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1472">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1474">        int w = input.getWidth();</span>
<span class="fc" id="L1475">        int h = input.getHeight();</span>
<span class="fc" id="L1476">        Image output = input.copyImage();</span>

<span class="fc bfc" id="L1478" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1480">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="fc" id="L1482">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="fc" id="L1486">        input.resetTo(output);</span>

<span class="fc bfc" id="L1488" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1490">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="fc" id="L1492">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="fc" id="L1496">        input.resetTo(output);</span>
<span class="fc" id="L1497">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, float sigma, int minValue, int maxValue) {

<span class="fc" id="L1506">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1508">        blur(input, kernel, minValue, maxValue);</span>
<span class="fc" id="L1509">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, SIGMA sigma, int minValue, int maxValue) {

<span class="fc" id="L1518">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1520">        blur(input, kernel, minValue, maxValue);</span>
<span class="fc" id="L1521">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     */
    public void blur(Image input, float[] kernel, int minValue, int maxValue) {

<span class="fc" id="L1529">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1531">        int w = input.getWidth();</span>
<span class="fc" id="L1532">        int h = input.getHeight();</span>
<span class="fc" id="L1533">        Image output = input.copyImage();</span>

<span class="fc bfc" id="L1535" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1537">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="fc" id="L1539">                int r = (int)Math.round(conv[0]);</span>
<span class="fc" id="L1540">                int g = (int)Math.round(conv[1]);</span>
<span class="fc" id="L1541">                int b = (int)Math.round(conv[2]);</span>
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">                if (r &lt; minValue) {</span>
<span class="nc" id="L1543">                    r = minValue;</span>
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">                } else if (r &gt; maxValue) {</span>
<span class="nc" id="L1545">                    r = maxValue;</span>
                }
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">                if (g &lt; minValue) {</span>
<span class="nc" id="L1548">                    g = minValue;</span>
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">                } else if (g &gt; maxValue) {</span>
<span class="nc" id="L1550">                    g = maxValue;</span>
                }
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">                if (b &lt; minValue) {</span>
<span class="nc" id="L1553">                    b = minValue;</span>
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">                } else if (b &gt; maxValue) {</span>
<span class="nc" id="L1555">                    b = maxValue;</span>
                }
<span class="fc" id="L1557">                output.setRGB(i, j, r, g, b);</span>
            }
        }

<span class="fc" id="L1561">        input.resetTo(output);</span>

<span class="fc bfc" id="L1563" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1565">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="fc" id="L1567">                int r = (int)Math.round(conv[0]);</span>
<span class="fc" id="L1568">                int g = (int)Math.round(conv[1]);</span>
<span class="fc" id="L1569">                int b = (int)Math.round(conv[2]);</span>
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">                if (r &lt; minValue) {</span>
<span class="nc" id="L1571">                    r = minValue;</span>
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">                } else if (r &gt; maxValue) {</span>
<span class="nc" id="L1573">                    r = maxValue;</span>
                }
<span class="pc bpc" id="L1575" title="1 of 2 branches missed.">                if (g &lt; minValue) {</span>
<span class="nc" id="L1576">                    g = minValue;</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">                } else if (g &gt; maxValue) {</span>
<span class="nc" id="L1578">                    g = maxValue;</span>
                }
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">                if (b &lt; minValue) {</span>
<span class="nc" id="L1581">                    b = minValue;</span>
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">                } else if (b &gt; maxValue) {</span>
<span class="nc" id="L1583">                    b = maxValue;</span>
                }
<span class="fc" id="L1585">                output.setRGB(i, j, r, g, b);</span>
            }
        }

<span class="fc" id="L1589">        input.resetTo(output);</span>
<span class="fc" id="L1590">    }</span>

    public void applySecondDerivGaussian(GreyscaleImage input, SIGMA sigma,
        int minValueRange, int maxValueRange) {

<span class="fc" id="L1595">        float[] kernel = Gaussian1DSecondDeriv.getBinomialKernel(sigma);</span>

<span class="fc" id="L1597">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1599">        int w = input.getWidth();</span>
<span class="fc" id="L1600">        int h = input.getHeight();</span>
<span class="fc" id="L1601">        GreyscaleImage output = input.copyImage();</span>

<span class="fc bfc" id="L1603" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1604" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="fc" id="L1606">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);

<span class="fc" id="L1609">                int v = (int)Math.round(conv);</span>

<span class="fc bfc" id="L1611" title="All 2 branches covered.">                if (v &lt; minValueRange) {</span>
<span class="fc" id="L1612">                    v = minValueRange;</span>
<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1614">                    v = maxValueRange;</span>
                }

<span class="fc" id="L1617">                output.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L1621">        input.resetTo(output);</span>

<span class="fc bfc" id="L1623" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="fc" id="L1626">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);

<span class="fc" id="L1629">                int v = (int)Math.round(conv);</span>

<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">                if (v &lt; minValueRange) {</span>
<span class="nc" id="L1632">                    v = minValueRange;</span>
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1634">                    v = maxValueRange;</span>
                }

<span class="fc" id="L1637">                output.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L1641">        input.resetTo(output);</span>
<span class="fc" id="L1642">    }</span>

    public int[] performSecondDerivGaussian(GreyscaleImage input,
        SIGMA sigma) {

<span class="fc" id="L1647">        float[] kernel = Gaussian1DSecondDeriv.getBinomialKernel(sigma);</span>

<span class="fc" id="L1649">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1651">        int w = input.getWidth();</span>
<span class="fc" id="L1652">        int h = input.getHeight();</span>

<span class="fc" id="L1654">        int[] output = new int[w * h];</span>

<span class="fc bfc" id="L1656" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1657" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="fc" id="L1659">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);

<span class="fc" id="L1662">                output[input.getInternalIndex(i, j)] =</span>
<span class="fc" id="L1663">                    (int)Math.round(conv);</span>
            }
        }

<span class="fc" id="L1667">        int[] output2 = Arrays.copyOf(output,</span>
            output.length);

<span class="fc bfc" id="L1670" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1671" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>

<span class="fc" id="L1673">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    output2, w, h, i, j, kernel, false);

<span class="fc" id="L1676">                output[input.getInternalIndex(i, j)] =</span>
<span class="fc" id="L1677">                    (int)Math.round(conv);</span>
            }
        }

<span class="fc" id="L1681">        return output;</span>
    }

    public void applyKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1687">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1689">        GreyscaleImage output = input.createWithDimensions();</span>

<span class="fc bfc" id="L1691" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L1692" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="fc" id="L1693">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1695">                int g = (int)Math.round(conv);</span>
<span class="fc" id="L1696">                output.setValue(i, j, g);</span>
            }
        }

<span class="fc" id="L1700">        input.resetTo(output);</span>
<span class="fc" id="L1701">    }</span>

    public void applyKernel1D(int[][] input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1706">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1708">        int w = input.length;</span>
<span class="fc" id="L1709">        int h = input[0].length;</span>

<span class="fc" id="L1711">        int[][] output = new int[w][];</span>

<span class="fc bfc" id="L1713" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1714">            output[i] = new int[h];</span>
<span class="fc bfc" id="L1715" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L1716">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1718">                int g = (int)Math.round(conv);</span>
<span class="fc" id="L1719">                output[i][j] = g;</span>
            }
        }

<span class="fc bfc" id="L1723" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1724">            System.arraycopy(output[i], 0, input[i], 0, h);</span>
        }
<span class="fc" id="L1726">    }</span>

    /**
     *
     * @param input
     * @param kernel
     * @param calcForX convolve along columns if true, else rows
     */
    public void applyKernel1D(float[][] input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1737">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1739">        int w = input.length;</span>
<span class="fc" id="L1740">        int h = input[0].length;</span>

<span class="fc" id="L1742">        float[][] output = new float[w][];</span>

<span class="fc bfc" id="L1744" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) { // rows</span>
<span class="fc" id="L1745">            output[i] = new float[h];</span>
<span class="fc bfc" id="L1746" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) { // cols</span>
                //if calcX is true: convolution is over the column at the fixed row.
<span class="fc" id="L1748">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1750">                float g = (float)conv;</span>
<span class="fc" id="L1751">                output[i][j] = g;</span>
            }
        }

<span class="fc bfc" id="L1755" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1756">            System.arraycopy(output[i], 0, input[i], 0, h);</span>
        }
<span class="fc" id="L1758">    }</span>

    /**
     *
     * @param input
     * @param kernel
     * @param calcForX convolve along columns if true, else rows
     */
    public void applyKernel1D(double[][] input, double[] kernel, boolean calcForX) {

<span class="fc" id="L1768">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1770">        int w = input.length;</span>
<span class="fc" id="L1771">        int h = input[0].length;</span>

<span class="fc" id="L1773">        double[][] output = new double[w][];</span>

        int i;
        int j;
<span class="fc bfc" id="L1777" title="All 2 branches covered.">        for (i = 0; i &lt; w; i++) { // rows</span>
<span class="fc" id="L1778">            output[i] = new double[h];</span>
<span class="fc bfc" id="L1779" title="All 2 branches covered.">            for (j = 0; j &lt; h; j++) { // cols</span>
                //if calcX is true: convolution is over the column at the fixed row.
<span class="fc" id="L1781">                output[i][j] = kernel1DHelper.convolvePointWithKernel(input, i, j, kernel, calcForX);</span>
            }
        }

<span class="fc bfc" id="L1785" title="All 2 branches covered.">        for (i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L1786">            System.arraycopy(output[i], 0, input[i], 0, h);</span>
        }
<span class="fc" id="L1788">    }</span>

    public void applyKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX, int minValue, int maxValue) {

<span class="fc" id="L1793">        GreyscaleImage output = convolveWithKernel1D(input, kernel, calcForX,</span>
            minValue, maxValue);

<span class="fc" id="L1796">        input.resetTo(output);</span>
<span class="fc" id="L1797">    }</span>

    public GreyscaleImage convolveWithKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX, int minValue, int maxValue) {

<span class="fc" id="L1802">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1804">        GreyscaleImage output = input.createWithDimensions();</span>

<span class="fc bfc" id="L1806" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="fc" id="L1808">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1810">                int g = (int)Math.round(conv);</span>
<span class="pc bpc" id="L1811" title="1 of 2 branches missed.">                if (g &lt; minValue) {</span>
<span class="nc" id="L1812">                    g = minValue;</span>
<span class="fc bfc" id="L1813" title="All 2 branches covered.">                } else if (g &gt; maxValue) {</span>
<span class="fc" id="L1814">                    g = maxValue;</span>
                }
<span class="fc" id="L1816">                output.setValue(i, j, g);</span>
            }
        }

<span class="fc" id="L1820">        return output;</span>
    }

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param kernel iD kernel
     */
    protected void blur(Image input, float[] kernel) {

<span class="nc" id="L1830">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1832">        int w = input.getWidth();</span>
<span class="nc" id="L1833">        int h = input.getHeight();</span>
<span class="nc" id="L1834">        Image output = (ImageExt)input.copyImage();</span>

<span class="nc bnc" id="L1836" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1838">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="nc" id="L1840">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1844">        input.resetTo(output);</span>

<span class="nc bnc" id="L1846" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1848">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="nc" id="L1850">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1854">        input.resetTo(output);</span>
<span class="nc" id="L1855">    }</span>

    public void divideByBlurredSelf(GreyscaleImage input, float sigma) {

<span class="nc" id="L1859">        GreyscaleImage input2 = input.copyImage();</span>

<span class="nc" id="L1861">        blur(input, sigma);</span>

<span class="nc bnc" id="L1863" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1865">                int v = input.getValue(i, j);</span>
<span class="nc" id="L1866">                int vorig = input2.getValue(i, j);</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L1868">                    float r = (float)vorig/(float)v;</span>
<span class="nc" id="L1869">                    input.setValue(i, j, (int)(100*r));</span>
                }
            }
        }
<span class="nc" id="L1873">    }</span>

    public GreyscaleImage binImage(GreyscaleImage img, int binFactor) {

<span class="pc bpc" id="L1877" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1878">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1881">        int w0 = img.getWidth();</span>
<span class="fc" id="L1882">        int h0 = img.getHeight();</span>

<span class="fc" id="L1884">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1885">        int h1 = h0/binFactor;</span>

<span class="fc" id="L1887">        GreyscaleImage out = new GreyscaleImage(w1, h1, img.getType());</span>
<span class="fc" id="L1888">        out.setXRelativeOffset(Math.round(img.getXRelativeOffset()/binFactor));</span>
<span class="fc" id="L1889">        out.setYRelativeOffset(Math.round(img.getYRelativeOffset()/binFactor));</span>

<span class="fc bfc" id="L1891" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1893" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1895">                int vSum = 0;</span>
<span class="fc" id="L1896">                int count = 0;</span>

<span class="fc bfc" id="L1898" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1899" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1901" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1902">                            continue;</span>
                        }
<span class="pc bpc" id="L1904" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1905">                            continue;</span>
                        }

<span class="fc" id="L1908">                        int v = img.getValue(ii, jj);</span>

<span class="fc" id="L1910">                        vSum += v;</span>
<span class="fc" id="L1911">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L1916">                    float v = (float)vSum/(float)count;</span>
<span class="fc" id="L1917">                    vSum = Math.round(v);</span>
                }

<span class="fc" id="L1920">                out.setValue(i, j, vSum);</span>
            }
        }

<span class="fc" id="L1924">        return out;</span>
    }

    public Image binImage(Image img,  int binFactor) {

<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1930">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1933">        int w0 = img.getWidth();</span>
<span class="fc" id="L1934">        int h0 = img.getHeight();</span>

<span class="fc" id="L1936">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1937">        int h1 = h0/binFactor;</span>

<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">        Image out = new Image(w1, h1, !img.is64Bit);</span>

<span class="fc" id="L1941">        binImage(img, binFactor, out);</span>

<span class="fc" id="L1943">        return out;</span>
    }

    public ImageExt binImage(ImageExt img,  int binFactor) {

<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1949">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1952">        int w0 = img.getWidth();</span>
<span class="fc" id="L1953">        int h0 = img.getHeight();</span>

<span class="fc" id="L1955">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1956">        int h1 = h0/binFactor;</span>

<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">        ImageExt out = new ImageExt(w1, h1, !img.is64Bit);</span>

<span class="fc" id="L1960">        binImage(img, binFactor, out);</span>

<span class="fc" id="L1962">        return out;</span>
    }

    private void binImage(Image inputImg,  int binFactor, Image outputImg) {

<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">        if (inputImg == null) {</span>
<span class="nc" id="L1968">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1971">        int w0 = inputImg.getWidth();</span>
<span class="fc" id="L1972">        int h0 = inputImg.getHeight();</span>

<span class="fc" id="L1974">        int w1 = outputImg.getWidth();</span>
<span class="fc" id="L1975">        int h1 = outputImg.getHeight();</span>

<span class="fc bfc" id="L1977" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1979" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1981">                long rSum = 0;</span>
<span class="fc" id="L1982">                long gSum = 0;</span>
<span class="fc" id="L1983">                long bSum = 0;</span>

<span class="fc" id="L1985">                int count = 0;</span>

<span class="fc bfc" id="L1987" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1990" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1991">                            continue;</span>
                        }
<span class="pc bpc" id="L1993" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1994">                            continue;</span>
                        }

<span class="fc" id="L1997">                        int rgb = inputImg.getRGB(ii, jj);</span>

<span class="fc" id="L1999">                        int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="fc" id="L2000">                        int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="fc" id="L2001">                        int b = rgb &amp; 0xFF;</span>

<span class="fc" id="L2003">                        rSum += r;</span>
<span class="fc" id="L2004">                        gSum += g;</span>
<span class="fc" id="L2005">                        bSum += b;</span>

<span class="fc" id="L2007">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L2012">                    rSum = Math.round((float)rSum/(float)count);</span>
<span class="fc" id="L2013">                    gSum = Math.round((float)gSum/(float)count);</span>
<span class="fc" id="L2014">                    bSum = Math.round((float)bSum/(float)count);</span>
                }

<span class="fc" id="L2017">                outputImg.setRGB(i, j, (int)rSum, (int)gSum, (int)bSum);</span>
            }
        }
<span class="fc" id="L2020">    }</span>

    /**
     * expand image to final size using the given output
     * widths and heights.
     * @param input
     * @param outWidth
     * @param outHeight
     * @param minValue minimum value to clamp results to
     * @param maxValue maximum value to clamp results to
     * @return
     */
    public GreyscaleImage upsampleUsingBilinear(GreyscaleImage input,
        int outWidth, int outHeight, int minValue, int maxValue) {

<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L2036">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="fc" id="L2039">        int w0 = input.getWidth();</span>
<span class="fc" id="L2040">        int h0 = input.getHeight();</span>
<span class="fc" id="L2041">        int w2 = outWidth;</span>
<span class="fc" id="L2042">        int h2 = outHeight;</span>

<span class="pc bpc" id="L2044" title="2 of 4 branches missed.">        if (w2 &lt; w0 || h2 &lt; h0) {</span>
<span class="nc" id="L2045">            throw new IllegalArgumentException(&quot;output dimensions cannot be&quot;</span>
                + &quot; less than input dimensions for upsample&quot;);
        }

        /*
        example, 1D:
        output scale = 3.333

         0  1  2  3  4  5  6  7  8  9 10 11 12 13 14
                |         |        |

          |  |  |
         0  1  2  3  4  5  6  7

        can solve using 2 different patterns:
        (1) integer upscale to Math.ceil(factor) == 4 in example
            then downsample to the final output size for easier math.
        or,
        (2) most pixels are integer copies of the current replicated pixel
        from the input, but the pixels which are integer muliples of the
        factor are composed of replicated current and next pixel
        as a fraction of sums to be computed for each.

        the first would be easier to maintain, but the later would be more
        efficient.

        will implement (2)
        */

<span class="fc" id="L2074">        GreyscaleImage output = null;</span>
<span class="pc bpc" id="L2075" title="2 of 4 branches missed.">        if (minValue &gt;= 0 &amp;&amp; maxValue &lt;= 255) {</span>
<span class="nc" id="L2076">            output = input.createWithDimensions(w2, h2);</span>
        } else {
<span class="fc" id="L2078">            output = new GreyscaleImage(w2, h2,</span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }

<span class="fc" id="L2082">        float xFactor = (float)w2/(float)w0;</span>
<span class="fc" id="L2083">        float yFactor = (float)h2/(float)h0;</span>

        // init vars
<span class="fc" id="L2086">        int i2 = 0;</span>
<span class="fc" id="L2087">        int i2End = 0;</span>

<span class="fc bfc" id="L2089" title="All 2 branches covered.">        for (int i0 = 0; i0 &lt; w0; ++i0) {</span>

<span class="fc bfc" id="L2091" title="All 2 branches covered.">            if (i0 &gt; 0) {</span>
<span class="fc" id="L2092">                i2 = i2End + 1;</span>
            }
<span class="fc" id="L2094">            i2End = (int)Math.floor(i2 + xFactor);</span>

            /* example, factor = 3.3
             0 : 2, 3 is combination
             4 : 6, 7 is combination
             7 : 9
            */

<span class="fc" id="L2102">            float fractionX = (xFactor * (i0 + 1.f)) - i2End;</span>
<span class="fc bfc" id="L2103" title="All 2 branches covered.">            if (fractionX &lt; 0) {</span>
<span class="fc" id="L2104">                fractionX += 1.f;</span>
            }

<span class="fc bfc" id="L2107" title="All 2 branches covered.">            int _i2End = (i2End &lt; w2) ? i2End : w2;</span>
            
            //System.out.format(
            //    &quot;i2=%s i2End=%d,%d  frcX=%.3f\n&quot;, 
            //    i2, i2End, _i2End, fractionX);
            
            // init vars
<span class="fc" id="L2114">            int j2 = 0;</span>
<span class="fc" id="L2115">            int j2End = 0;</span>

<span class="fc bfc" id="L2117" title="All 2 branches covered.">            for (int j0 = 0; j0 &lt; h0; ++j0) {</span>

                // replication of integer pixels in this range:
<span class="fc bfc" id="L2120" title="All 2 branches covered.">                if (j0 &gt; 0) {</span>
<span class="fc" id="L2121">                    j2 = j2End + 1;</span>
                }
<span class="fc" id="L2123">                j2End = (int)Math.floor(j2 + yFactor);</span>

<span class="fc bfc" id="L2125" title="All 2 branches covered.">                int _j2End = (j2End &lt; h2) ? j2End : h2;</span>
                
<span class="fc" id="L2127">                float fractionY = (yFactor * (j0 + 1.f)) - j2End;</span>
<span class="fc bfc" id="L2128" title="All 2 branches covered.">                if (fractionY &lt; 0) {</span>
<span class="fc" id="L2129">                    fractionY += 1.f;</span>
                }
                
                //System.out.format(
                //    &quot;  j2=%s j2End=%d,%d  frcY=%.3f\n&quot;, 
                //    j2, j2End, _j2End, fractionY);
                
<span class="fc" id="L2136">                int v = input.getValue(i0, j0);</span>
<span class="pc bpc" id="L2137" title="2 of 4 branches missed.">                v = (v &lt; minValue) ? minValue : ((v &gt; maxValue) ? maxValue : v);</span>

<span class="fc bfc" id="L2139" title="All 2 branches covered.">                for (int ii = i2; ii &lt; _i2End; ++ii) {</span>
<span class="fc bfc" id="L2140" title="All 2 branches covered.">                    for (int jj = j2; jj &lt; _j2End; ++jj) {</span>
                
                        //System.out.format(
                        //&quot;    set(%d,%d)=%d\n&quot;, ii, jj, v);
                
<span class="fc" id="L2145">                        output.setValue(ii, jj, v);</span>
                    }
                }

                // example, factor = 2.5
                //   i2 = 0, i2End = 2, (i1+1) * xFactor=2.5  -&gt; fractional
                //           so pixel i2End gets contributions from i1=0 and i1=2
                //   i2 = 3, i2End = 5, (i1+1) * xFactor=5 -&gt; integer, so skip

                // --- handle the pixels which get fractional contributions
                //     from 2 input pixels
<span class="fc" id="L2156">                float vI2End = 0;</span>
<span class="pc bpc" id="L2157" title="1 of 4 branches missed.">                if (fractionX &gt; 0 &amp;&amp; (i2End &lt; w2)) {</span>
<span class="fc" id="L2158">                    vI2End = (fractionX * (float)v);</span>
<span class="pc bpc" id="L2159" title="1 of 2 branches missed.">                    if ((i0 + 1) &lt; w0) {</span>
<span class="fc" id="L2160">                        vI2End += ((1.f - fractionX) * </span>
<span class="fc" id="L2161">                            (float)input.getValue(i0 + 1, j0));</span>
                    }
<span class="fc" id="L2163">                    int vI2 = Math.round(vI2End);</span>
<span class="pc bpc" id="L2164" title="1 of 2 branches missed.">                    vI2 = (vI2 &lt; minValue) ? minValue :</span>
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">                        ((vI2 &gt; maxValue) ? maxValue : vI2);</span>
                    
<span class="fc bfc" id="L2167" title="All 2 branches covered.">                    for (int jj = j2; jj &lt; _j2End; ++jj) {</span>
                        
                        //System.out.format(
                        //&quot;     *set(%d,%d)=%d\n&quot;, i2End, jj, vI2);
                        
<span class="fc" id="L2172">                        output.setValue(i2End, jj, vI2);</span>
                    }
                    
                }

                // last pixel is either a fractional sum of 2 input pixels or
                //  is start of next interval
                
<span class="fc" id="L2180">                float vJ2End = 0;</span>
<span class="pc bpc" id="L2181" title="1 of 4 branches missed.">                if (fractionY &gt; 0 &amp;&amp; (j2End &lt; h2)) {</span>
<span class="fc" id="L2182">                    vJ2End = (fractionY * v);</span>
<span class="pc bpc" id="L2183" title="1 of 2 branches missed.">                    if ((j0 + 1) &lt; h0) {</span>
<span class="fc" id="L2184">                        vJ2End += ((1.f - fractionY) * input.getValue(i0, j0 + 1));</span>
                    }
<span class="fc" id="L2186">                    int vJ2 = Math.round(vJ2End);</span>
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">                    vJ2 = (vJ2 &lt; minValue) ? minValue :</span>
<span class="pc bpc" id="L2188" title="1 of 2 branches missed.">                        ((vJ2 &gt; maxValue) ? maxValue : vJ2);</span>
                    
                    //System.out.format(
                    //&quot;     **set(%d,%d)=%d\n&quot;, i2, j2End, vJ2);
                    
<span class="fc bfc" id="L2193" title="All 2 branches covered.">                    for (int iii = i2; iii &lt; _i2End; ++iii) {</span>
                        
                        //System.out.format(
                        // &quot;     *set(%d,%d)=%d\n&quot;, iii, j2End, vJ2);
                        
<span class="fc" id="L2198">                        output.setValue(iii, j2End, vJ2);</span>
                    }                    
                }
                
<span class="fc bfc" id="L2202" title="All 4 branches covered.">                if (vI2End &gt; 0 &amp;&amp; vJ2End &gt; 0) {</span>
                    
<span class="fc" id="L2204">                    int avg = Math.round((vI2End + vJ2End)/2.f);</span>
                    
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">                    avg = (avg &lt; minValue) ? minValue :</span>
<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">                        ((avg &gt; maxValue) ? maxValue : avg);</span>
                    
                    //System.out.format(&quot;     **set(%d,%d)=%d\n&quot;, i2End, j2End, avg);
                    
<span class="fc" id="L2211">                    output.setValue(i2End, j2End, avg);</span>
                }

<span class="fc bfc" id="L2214" title="All 2 branches covered.">                if (fractionY == 0.f) {</span>
                    // subtract so next j2 starts at this value
<span class="fc" id="L2216">                    j2End--;</span>
                }
            }

<span class="fc bfc" id="L2220" title="All 2 branches covered.">            if (fractionX == 0.f) {</span>
                // subtract so next i2 starts at this value
<span class="fc" id="L2222">                i2End--;</span>
            }
        }

<span class="fc" id="L2226">        return output;</span>
    }

    public GreyscaleImage unbinImage(GreyscaleImage input, int binFactor) {

<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L2232">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="fc" id="L2235">        int w0 = input.getWidth();</span>
<span class="fc" id="L2236">        int h0 = input.getHeight();</span>

<span class="fc" id="L2238">        GreyscaleImage out = input.createWithDimensions(</span>
            binFactor* w0, binFactor * h0);

<span class="fc" id="L2241">        int w1 = out.getWidth();</span>
<span class="fc" id="L2242">        int h1 = out.getHeight();</span>

<span class="fc bfc" id="L2244" title="All 2 branches covered.">        for (int i = 0; i &lt; w0; i++) {</span>
<span class="fc bfc" id="L2245" title="All 2 branches covered.">            for (int j = 0; j &lt; h0; j++) {</span>

<span class="fc" id="L2247">                int v = input.getValue(i, j);</span>

<span class="fc bfc" id="L2249" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L2250" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="fc" id="L2251">                        out.setValue(ii, jj, v);</span>
                    }
<span class="fc bfc" id="L2253" title="All 2 branches covered.">                    for (int jj = ((j + 1)*binFactor); jj &lt; h1; jj++) {</span>
<span class="fc" id="L2254">                        out.setValue(ii, jj, v);</span>
                    }
                }
<span class="fc bfc" id="L2257" title="All 2 branches covered.">                for (int ii = ((i + 1)*binFactor); ii &lt; w1; ii++) {</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="fc" id="L2259">                        out.setValue(ii, jj, v);</span>
                    }
<span class="fc bfc" id="L2261" title="All 2 branches covered.">                    for (int jj = ((j + 1)*binFactor); jj &lt; h1; jj++) {</span>
<span class="fc" id="L2262">                        out.setValue(ii, jj, v);</span>
                    }
                }
            }
        }

<span class="fc" id="L2268">        return out;</span>
    }
    
    /**
     * apply 2D FFT transform using the JFFTPack.
     *
     * @param input input image, which should probably be type full range int
     * @param forward if true, apply FFT transform, else inverse FFT transform
     */
    public void apply2DFFT2(GreyscaleImage input, boolean forward) {

<span class="nc" id="L2279">         Complex1D[] ccOut = create2DFFT2WithSwapMajor(input, forward);</span>

<span class="nc bnc" id="L2281" title="All 2 branches missed.">         assert(ccOut.length == input.getHeight());</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">         assert(ccOut[0].x.length == input.getWidth());</span>

<span class="nc bnc" id="L2284" title="All 2 branches missed.">         for (int i0 = 0; i0 &lt; ccOut.length; ++i0) {</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">             for (int i1 = 0; i1 &lt; ccOut[i0].x.length; ++i1) {</span>
<span class="nc" id="L2286">                 double re = ccOut[i0].x[i1];</span>
<span class="nc" id="L2287">                 input.setValue(i1, i0, (int)re);</span>
             }
         }
<span class="nc" id="L2290">    }</span>

     /**
     * apply 2D FFT transform using the efficient iterative power of 2 method
     * that uses the butterfly operation if image dimensions are a power of
     * 2, else uses an alternative.
     *
     * @param input
     * @param forward if true, apply FFT transform, else inverse FFT transform
     */
    public void apply2DFFT(GreyscaleImage input, boolean forward) {

<span class="nc" id="L2302">        int n0 = input.getWidth();</span>
<span class="nc" id="L2303">        int n1 = input.getHeight();</span>

<span class="nc" id="L2305">        int nn0 = 1 &lt;&lt; (int)(Math.ceil(Math.log(n0)/Math.log(2)));</span>
<span class="nc" id="L2306">        int nn1 = 1 &lt;&lt; (int)(Math.ceil(Math.log(n1)/Math.log(2)));</span>

<span class="nc bnc" id="L2308" title="All 4 branches missed.">        if (nn0 &gt; n0 || nn1 &gt; n1) {</span>
<span class="nc" id="L2309">            apply2DFFT2(input, forward);</span>
<span class="nc" id="L2310">            return;</span>
        }
        
<span class="nc" id="L2313">        FFTUtil fftUtil = new FFTUtil();</span>

        // initialize matrix of complex numbers as real numbers from image (imaginary are 0's)
<span class="nc" id="L2316">        Complex[][] cc = copyToComplex2D(input);</span>

<span class="nc" id="L2318">        Complex[][] ccOut = fftUtil.create2DFFT(cc, forward);</span>

<span class="nc" id="L2320">        input.fill(0);</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="nc" id="L2323">                double re = ccOut[col][row].re();</span>
<span class="nc" id="L2324">                input.setValue(col, row, (int)re);</span>
            }
        }

<span class="nc" id="L2328">    }</span>

    /**
     * perform a 2-dimension FFT using the JFFTPack library using the input
     * img and return the results as a complex two dimensional array
     * which uses the format a[row][col].
     *
     * @param img
     * @param forward
     * @return
     */
    public Complex1D[] create2DFFT2WithSwapMajor(GreyscaleImage img, boolean forward) {

        // swap major axes for input to FFT 2D algorithm 2
<span class="nc" id="L2342">        Complex1D[] cInput = new Complex1D[img.getWidth()];</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc" id="L2344">            cInput[i] = new Complex1D();</span>
<span class="nc" id="L2345">            cInput[i].x = new double[img.getHeight()];</span>
<span class="nc" id="L2346">            cInput[i].y = new double[img.getHeight()];</span>
<span class="nc bnc" id="L2347" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L2348">                cInput[i].x[j] = img.getValue(i, j);</span>
            }
        }
        
<span class="nc" id="L2352">        FFTUtil fftUtil = new FFTUtil();</span>

<span class="nc" id="L2354">        Complex1D[] output2 = fftUtil.create2DFFT2(cInput, forward);</span>

<span class="nc" id="L2356">        return output2;</span>
    }

     /**
     * apply 2D FFT transform using the efficient iterative power of 2 method
     * that uses the butterfly operation.
     *
     * @param img
     * @param forward if true, apply FFT transform, else inverse FFT transform
     * @return 2d fft results in format a[row][col]
     */
    public Complex[][] create2DFFTWithSwapMajor(GreyscaleImage img, boolean forward) {

        // normalize by default
<span class="fc" id="L2370">        return create2DFFTWithSwapMajor(img, true, forward);</span>
    }

    /**
     * apply 2D FFT transform .
     *
     * @param input
     * @param doNormalize perform FFT normalization if true
     * @param forward if true, apply FFT transform, else inverse FFT transform
     * @return 2d fft results in format a[row][col]
     */
    public Complex[][] create2DFFTWithSwapMajor(GreyscaleImage input,
        boolean doNormalize, boolean forward) {

        // initialize matrix of complex numbers as real numbers from image (imaginary are 0's)
<span class="fc" id="L2385">        Complex[][] cc = copyToComplexWithSwapMajor(input);</span>

<span class="fc" id="L2387">        FFTUtil fftUtil = new FFTUtil();</span>
        
<span class="fc" id="L2389">        Complex[][] ccFFT = fftUtil.create2DFFT(cc, doNormalize, forward);</span>

<span class="fc" id="L2391">        return ccFFT;</span>
    }

    public void writeToImageWithSwapMajor(GreyscaleImage img, Complex[][] cc) {

<span class="fc" id="L2396">        img.fill(0);</span>

        // write back to original image
<span class="fc bfc" id="L2399" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L2400" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L2401">                double re = cc[row][col].re();</span>
<span class="fc" id="L2402">                img.setValue(col, row, (int)re);</span>
            }
        }

<span class="fc" id="L2406">    }</span>

    public void writePositiveRealToImage(GreyscaleImage img, Complex[][] cc) {

<span class="nc" id="L2410">        img.fill(0);</span>

        // write back to original image
<span class="nc bnc" id="L2413" title="All 2 branches missed.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="nc bnc" id="L2414" title="All 2 branches missed.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="nc" id="L2415">                double re = cc[col][row].re();</span>
<span class="nc" id="L2416">                double a = cc[col][row].abs();</span>
<span class="nc" id="L2417">                double p = cc[col][row].phase();</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">                if (re &gt; 0) {</span>
<span class="nc" id="L2419">                    img.setValue(col, row, (int)re);</span>
                }
            }
        }

<span class="nc" id="L2424">    }</span>

    /**
     * create a complex double array with format a[col][row]
     * @param input
     * @return
     */
    protected Complex[][] copyToComplex2D(GreyscaleImage input) {

        // initialize matrix of complex numbers as real numbers from image
<span class="fc" id="L2434">        Complex[][] cc = new Complex[input.getWidth()][];</span>

<span class="fc bfc" id="L2436" title="All 2 branches covered.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="fc" id="L2438">            cc[col] = new Complex[input.getHeight()];</span>

<span class="fc bfc" id="L2440" title="All 2 branches covered.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="fc" id="L2441">                cc[col][row] = new Complex(input.getValue(col, row), 0);</span>
            }
        }

<span class="fc" id="L2445">        return cc;</span>
    }

    /**
     * create a complex double array with format a[row][col]
     * @param input
     * @return
     */
    protected Complex[][] copyToComplexWithSwapMajor(GreyscaleImage input) {

<span class="fc" id="L2455">        int nCols = input.getWidth();</span>
<span class="fc" id="L2456">        int nRows = input.getHeight();</span>

        // initialize matrix of complex numbers as real numbers from image
<span class="fc" id="L2459">        Complex[][] cc = new Complex[nRows][];</span>

<span class="fc bfc" id="L2461" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; row++) {</span>

<span class="fc" id="L2463">            cc[row] = new Complex[nCols];</span>

<span class="fc bfc" id="L2465" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; col++) {</span>
<span class="fc" id="L2466">                cc[row][col] = new Complex(input.getValue(col, row), 0);</span>
            }
        }

<span class="fc" id="L2470">        return cc;</span>
    }

    protected Complex[][] copyToComplex2D(double[][] input) {

<span class="nc" id="L2475">        int w = input.length;</span>
<span class="nc" id="L2476">        int h = input[0].length;</span>

        // initialize matrix of complex numbers as real numbers from image
<span class="nc" id="L2479">        Complex[][] cc = new Complex[w][];</span>

<span class="nc bnc" id="L2481" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>

<span class="nc" id="L2483">            cc[col] = new Complex[h];</span>

<span class="nc bnc" id="L2485" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>
<span class="nc" id="L2486">                cc[col][row] = new Complex(input[col][row], 0);</span>
            }
        }

<span class="nc" id="L2490">        return cc;</span>
    }

    /**
     * read the image and store the non-zero pixels in a set.  note that negative
     * values will also be stored in the output set.
     * @param img
     * @return
     */
    public Set&lt;PairInt&gt; readNonZeroPixels(GreyscaleImage img) {

<span class="fc" id="L2501">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2503" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L2504" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L2505">                int v = img.getValue(col, row);</span>
<span class="fc bfc" id="L2506" title="All 2 branches covered.">                if (v != 0) {</span>
<span class="fc" id="L2507">                    set.add(new PairInt(col, row));</span>
                }
            }
        }

<span class="fc" id="L2512">        return set;</span>
    }

    /**
     * NOT YET TESTED
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(GreyscaleImage gsImg, float x, float y) {

<span class="fc" id="L2526">        double x1 = Math.floor(x);</span>

<span class="fc" id="L2528">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L2530">        double y1 = Math.floor(y);</span>

<span class="fc" id="L2532">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="fc bfc" id="L2536" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L2538">            v1 = gsImg.getValue((int)x1, (int)y1);</span>

<span class="fc bfc" id="L2540" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2541">                return v1;</span>
            }

<span class="fc" id="L2544">            v2 = gsImg.getValue((int)x1, (int)y2);</span>

        } else {

            // interpolate over row y1
<span class="fc" id="L2549">            v1 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y1) +</span>
<span class="fc" id="L2550">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y1);</span>

<span class="fc bfc" id="L2552" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2553">                return v1;</span>
            }

            // interpolate over row y2
<span class="fc" id="L2557">            v2 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y2) +</span>
<span class="fc" id="L2558">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y2);</span>
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2562">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="fc" id="L2564">        return v;</span>
    }

    /**
     * NOT YET TESTED.  this assumes x and y should be interpreted as integers that
     * will be indexes for gsImg.
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(double[][] gsImg, double x, double y) {

<span class="fc" id="L2579">        double x1 = Math.floor(x);</span>

<span class="fc" id="L2581">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L2583">        double y1 = Math.floor(y);</span>

<span class="fc" id="L2585">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="fc bfc" id="L2589" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L2591">            v1 = gsImg[(int)x1][(int)y1];</span>

<span class="fc bfc" id="L2593" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2594">                return v1;</span>
            }

<span class="fc" id="L2597">            v2 = gsImg[(int)x1][(int)y];</span>

        } else {

            // interpolate over row y1
<span class="fc" id="L2602">            v1 = ((x2 - x)/(x2 - x1)) * gsImg[(int)x1][(int)y1] +</span>
                ((x - x1)/(x2 - x1)) * gsImg[(int)x2][(int)y1];

<span class="fc bfc" id="L2605" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2606">                return v1;</span>
            }

            // interpolate over row y2
<span class="fc" id="L2610">            v2 = ((x2 - x)/(x2 - x1)) * gsImg[(int)x1][(int)y2] +</span>
                ((x - x1)/(x2 - x1)) * gsImg[(int)x2][(int)y2];
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2615">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="fc" id="L2617">        return v;</span>
    }
    
    /**
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     *
     * @param clrImg
     * @param x
     * @param y
     * @param outRGB r, g, b interpolated values.
     * @param auxArr1 auxiliary array of length 2 to use internally.  contents
     *    are written over and do not hold results for this method.
     * @param auxArr2 auxiliary array of size 2X2 to use internally.  contents
     *    are written over and do not hold results for this method.
     * @param auxArr3 auxiliary array of length 2 to use internally.  contents
     *    are written over and do not hold results for this method.
     */
    public void biLinearInterpolation(Image clrImg, double x, double y, double[] outRGB,
        double[] auxArr1, double[][] auxArr2, double[] auxArr3) {
        
<span class="fc" id="L2638">        int x1 = (int)Math.floor(x);</span>
<span class="fc" id="L2639">        int x2 = (int)Math.ceil(x);</span>
<span class="fc" id="L2640">        int y1 = (int)Math.floor(y);</span>
<span class="fc" id="L2641">        int y2 = (int)Math.ceil(y);</span>
        
<span class="pc bpc" id="L2643" title="1 of 4 branches missed.">        if ((x1 == x2) || (y1 == y2)) {</span>
<span class="fc" id="L2644">            biLinearInterpolation(clrImg, (float)x, (float)y, outRGB);</span>
<span class="fc" id="L2645">            return;</span>
        }
                
<span class="pc bnc" id="L2648" title="All 2 branches missed.">        assert(x2 != x1);</span>
<span class="pc bnc" id="L2649" title="All 2 branches missed.">        assert(y2 != y1);</span>

        double d;
<span class="fc" id="L2652">        auxArr1[0] = x2 - x;</span>
<span class="fc" id="L2653">        auxArr1[1] = x - x1;</span>
<span class="fc" id="L2654">        auxArr3[0] = y2 - y;</span>
<span class="fc" id="L2655">        auxArr3[1] = y - y1;</span>
<span class="fc" id="L2656">        d = 1./((x2-x1)*(y2-y1));</span>
                        
<span class="fc" id="L2658">        auxArr2[0][0] = clrImg.getR(x1, y1);</span>
<span class="fc" id="L2659">        auxArr2[0][1] = clrImg.getR(x1, y2);</span>
<span class="fc" id="L2660">        auxArr2[1][0] = clrImg.getR(x2, y1);</span>
<span class="fc" id="L2661">        auxArr2[1][1] = clrImg.getR(x2, y2);</span>
<span class="fc" id="L2662">        outRGB[0] = MatrixUtil.innerProduct(</span>
<span class="fc" id="L2663">            MatrixUtil.multiplyRowVectorByMatrix(auxArr1, auxArr2), auxArr3);</span>
<span class="fc" id="L2664">        outRGB[0] *= d;</span>
        
<span class="fc" id="L2666">        auxArr2[0][0] = clrImg.getG(x1, y1);</span>
<span class="fc" id="L2667">        auxArr2[0][1] = clrImg.getG(x1, y2);</span>
<span class="fc" id="L2668">        auxArr2[1][0] = clrImg.getG(x2, y1);</span>
<span class="fc" id="L2669">        auxArr2[1][1] = clrImg.getG(x2, y2);</span>
<span class="fc" id="L2670">        outRGB[1] = MatrixUtil.innerProduct(</span>
<span class="fc" id="L2671">            MatrixUtil.multiplyRowVectorByMatrix(auxArr1, auxArr2), auxArr3);</span>
<span class="fc" id="L2672">        outRGB[1] *= d;</span>
        
<span class="fc" id="L2674">        auxArr2[0][0] = clrImg.getB(x1, y1);</span>
<span class="fc" id="L2675">        auxArr2[0][1] = clrImg.getB(x1, y2);</span>
<span class="fc" id="L2676">        auxArr2[1][0] = clrImg.getB(x2, y1);</span>
<span class="fc" id="L2677">        auxArr2[1][1] = clrImg.getB(x2, y2);</span>
<span class="fc" id="L2678">        outRGB[2] = MatrixUtil.innerProduct(</span>
<span class="fc" id="L2679">            MatrixUtil.multiplyRowVectorByMatrix(auxArr1, auxArr2), auxArr3);</span>
<span class="fc" id="L2680">        outRGB[2] *= d;</span>
<span class="fc" id="L2681">    }</span>
    
    /**
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     *
     * @param x
     * @param y
     * @return
     */
    public double[] biLinearInterpolation(Image clrImg, float x, float y) {
<span class="fc" id="L2692">        double[] rgb = new double[3];</span>
<span class="fc" id="L2693">        biLinearInterpolation(clrImg, x, y, rgb);</span>
<span class="fc" id="L2694">        return rgb;</span>
    }

    /**
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     *
     * @param x
     * @param y
     * @param outRGB
     */
    public void biLinearInterpolation(Image clrImg, float x, float y, double[] outRGB) {

<span class="fc" id="L2707">        double x1 = Math.floor(x);</span>

<span class="fc" id="L2709">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L2711">        double y1 = Math.floor(y);</span>

<span class="fc" id="L2713">        double y2 = Math.ceil(y);</span>

        double r1, r2, g1, g2, b1, b2;

<span class="fc bfc" id="L2717" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L2719">            r1 = clrImg.getR((int)x1, (int)y1);</span>
<span class="fc" id="L2720">            g1 = clrImg.getG((int)x1, (int)y1);</span>
<span class="fc" id="L2721">            b1 = clrImg.getB((int)x1, (int)y1);</span>

<span class="pc bpc" id="L2723" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="fc" id="L2724">                outRGB[0] = r1;</span>
<span class="fc" id="L2725">                outRGB[1] = g1;</span>
<span class="fc" id="L2726">                outRGB[2] = b1;</span>
<span class="fc" id="L2727">                return;</span>
            }

<span class="nc" id="L2730">            r2 = clrImg.getR((int)x1, (int)y2);</span>
<span class="nc" id="L2731">            g2 = clrImg.getG((int)x1, (int)y2);</span>
<span class="nc" id="L2732">            b2 = clrImg.getB((int)x1, (int)y2);</span>

        } else {

<span class="fc" id="L2736">            double v1X2Frac = ((x2 - x)/(x2 - x1));</span>
<span class="fc" id="L2737">            double v1X1Frac = ((x - x1)/(x2 - x1));</span>

            // interpolate over row y1
<span class="fc" id="L2740">            r1 = v1X2Frac * clrImg.getR((int)x1, (int)y1) +</span>
<span class="fc" id="L2741">                v1X1Frac * clrImg.getR((int)x2, (int)y1);</span>

<span class="fc" id="L2743">            g1 = v1X2Frac * clrImg.getG((int)x1, (int)y1) +</span>
<span class="fc" id="L2744">                v1X1Frac * clrImg.getG((int)x2, (int)y1);</span>

<span class="fc" id="L2746">            b1 = v1X2Frac * clrImg.getB((int)x1, (int)y1) +</span>
<span class="fc" id="L2747">                v1X1Frac * clrImg.getB((int)x2, (int)y1);</span>

<span class="pc bpc" id="L2749" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L2750">                outRGB[0] = r1;</span>
<span class="nc" id="L2751">                outRGB[1] = g1;</span>
<span class="nc" id="L2752">                outRGB[2] = b1;</span>
<span class="nc" id="L2753">                return;</span>
            }

            // interpolate over row y2
<span class="fc" id="L2757">            r2 = v1X2Frac * clrImg.getR((int)x1, (int)y2) +</span>
<span class="fc" id="L2758">                v1X1Frac * clrImg.getR((int)x2, (int)y2);</span>

<span class="fc" id="L2760">            g2 = v1X2Frac * clrImg.getG((int)x1, (int)y2) +</span>
<span class="fc" id="L2761">                v1X1Frac * clrImg.getG((int)x2, (int)y2);</span>

<span class="fc" id="L2763">            b2 = v1X2Frac * clrImg.getB((int)x1, (int)y2) +</span>
<span class="fc" id="L2764">                v1X1Frac * clrImg.getB((int)x2, (int)y2);</span>
        }

<span class="fc" id="L2767">        double v1Y2Frac = ((y2 - y)/(y2 - y1));</span>
<span class="fc" id="L2768">        double v1Y1Frac = ((y - y1)/(y2 - y1));</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2771">        double r = v1Y2Frac * r1 + v1Y1Frac * r2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2774">        double g = v1Y2Frac * g1 + v1Y1Frac * g2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2777">        double b = v1Y2Frac * b1 + v1Y1Frac * b2;</span>

<span class="fc" id="L2779">        outRGB[0] = r;</span>
<span class="fc" id="L2780">        outRGB[1] = g;</span>
<span class="fc" id="L2781">        outRGB[2] = b;</span>
<span class="fc" id="L2782">    }</span>

    public void applyAdaptiveMeanThresholding(GreyscaleImage img) {

<span class="nc" id="L2786">        applyAdaptiveMeanThresholding(img, 3);</span>
<span class="nc" id="L2787">    }</span>

    public void applyAdaptiveMeanThresholding(GreyscaleImage img,
        int halfDimension) {

<span class="fc" id="L2792">        GreyscaleImage imgM = img.copyImage();</span>

<span class="fc" id="L2794">        applyCenteredMean2(imgM, halfDimension);</span>

<span class="fc" id="L2796">        int c = 7;</span>

<span class="fc" id="L2798">        int foreground = 255;//1;</span>
<span class="fc" id="L2799">        int background = 0;</span>

<span class="fc bfc" id="L2801" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L2802" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L2803">                int v = img.getValue(i, j);</span>
<span class="fc" id="L2804">                int m = imgM.getValue(i, j);</span>
<span class="fc" id="L2805">                int t = m - c;</span>
<span class="fc bfc" id="L2806" title="All 2 branches covered.">                if (v &gt; t) {</span>
<span class="fc" id="L2807">                    img.setValue(i, j, foreground);</span>
                } else {
<span class="fc" id="L2809">                    img.setValue(i, j, background);</span>
                }
            }
        }

<span class="fc" id="L2814">        imgM = null;</span>

        //System.gc();
<span class="fc" id="L2817">    }</span>

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel.  The calculation starts at 0 and the end
     * dimension pixels are averaged using the decreasing number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for dimension = 2 becomes:
     * [11] [12] [12]
     * [11] [12] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels)
     * This can be used as part of adaptive mean thresholding.
     *
     * @param img
     * @param dimension
     */
    public void applyBoxcarMean(GreyscaleImage img, int dimension) {

<span class="pc bpc" id="L2840" title="2 of 4 branches missed.">        if ((img.getWidth() &lt; dimension) || (img.getHeight() &lt; dimension)) {</span>
<span class="nc" id="L2841">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }

        /*
        becomes efficient when dimension &gt; 3

        sum along columns first using dynamic programming:
        sumCol[j=0] = sum_j=0_to_dim of row[i]
        sumCol[j=1] = sumCol[0] - row[j-1] + row[dim + j - 1]
        sumCol[j=2] = sumCol[1] - row[j-1] + row[dim + j - 1]
        */

<span class="fc" id="L2854">        int w = img.getWidth();</span>
<span class="fc" id="L2855">        int h = img.getHeight();</span>

<span class="fc" id="L2857">        int[] mean = new int[img.getNPixels()];</span>

        // sum along rows
<span class="fc bfc" id="L2860" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L2861">            int sum0 = 0;</span>
<span class="fc bfc" id="L2862" title="All 2 branches covered.">            for (int j = 0; j &lt; dimension; ++j) {</span>
<span class="fc" id="L2863">                sum0 += img.getValue(i, j);</span>
            }
<span class="fc" id="L2865">            mean[img.getInternalIndex(i, 0)] = sum0;</span>
<span class="fc bfc" id="L2866" title="All 2 branches covered.">            for (int j = 1; j &lt;= (h - dimension); ++j) {</span>
<span class="fc" id="L2867">                int vp = img.getValue(i, j - 1);</span>
<span class="fc" id="L2868">                int vl =  img.getValue(i, dimension + j - 1);</span>
<span class="fc" id="L2869">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L2870">                mean[img.getInternalIndex(i, j)] = sum0;</span>
            }
            // last dimension - 1 rows: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L2873" title="All 2 branches covered.">            for (int j = (h - dimension + 1); j &lt; h; ++j) {</span>
<span class="fc" id="L2874">                float count = h - j;</span>
<span class="fc" id="L2875">                float sum = 0;</span>
<span class="fc bfc" id="L2876" title="All 2 branches covered.">                for (int k = j; k &lt; h; ++k) {</span>
<span class="fc" id="L2877">                    sum += img.getValue(i, k);</span>
                }
<span class="fc" id="L2879">                sum /= count;</span>
<span class="fc" id="L2880">                sum *= dimension;</span>
<span class="fc" id="L2881">                mean[img.getInternalIndex(i, j)] = Math.round(sum);</span>
            }
        }

<span class="fc" id="L2885">        int[] mean2 = new int[img.getNPixels()];</span>

        // sum along columns
<span class="fc bfc" id="L2888" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L2889">            int sum0 = 0;</span>
<span class="fc bfc" id="L2890" title="All 2 branches covered.">            for (int i = 0; i &lt; dimension; ++i) {</span>
<span class="fc" id="L2891">                sum0 += mean[img.getInternalIndex(i, j)];</span>
            }
<span class="fc" id="L2893">            mean2[img.getInternalIndex(0, j)] = sum0;</span>
<span class="fc bfc" id="L2894" title="All 2 branches covered.">            for (int i = 1; i &lt;= (w - dimension); ++i) {</span>
<span class="fc" id="L2895">                int vp = mean[img.getInternalIndex(i - 1, j)];</span>
<span class="fc" id="L2896">                int vl = mean[img.getInternalIndex(dimension + i - 1, j)];</span>
<span class="fc" id="L2897">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L2898">                mean2[img.getInternalIndex(i, j)] = sum0;</span>
            }

            // last dimension - 1 cols: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L2902" title="All 2 branches covered.">            for (int i = (w - dimension + 1); i &lt; w; ++i) {</span>
<span class="fc" id="L2903">                float count = h - i;</span>
<span class="fc" id="L2904">                float sum = 0;</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">                for (int k = i; k &lt; w; ++k) {</span>
<span class="fc" id="L2906">                    sum += mean[img.getInternalIndex(k, j)];</span>
                }
<span class="fc" id="L2908">                sum /= count;</span>
<span class="fc" id="L2909">                sum *= dimension;</span>
<span class="fc" id="L2910">                mean2[img.getInternalIndex(i, j)] = Math.round(sum);</span>
            }
        }

        // divide each value by dimension * dimension
<span class="fc" id="L2915">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L2916" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L2917" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L2918">                int v = mean2[img.getInternalIndex(i, j)];</span>
<span class="fc" id="L2919">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L2920">                img.setValue(i, j, v);</span>
            }
        }
<span class="fc" id="L2923">    }</span>

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a decreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels) and never more than
     * 4 times O(N_pixels).
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean2(GreyscaleImage img, int halfDimension) {

<span class="fc" id="L2947">        SummedAreaTable sumTable = new SummedAreaTable();</span>

<span class="fc" id="L2949">        GreyscaleImage imgS = sumTable.createAbsoluteSummedAreaTable(img);</span>

<span class="fc" id="L2951">        imgS = sumTable.applyMeanOfWindowFromSummedAreaTable(imgS,</span>
            2*halfDimension + 1);

<span class="fc" id="L2954">        img.resetTo(imgS);</span>
<span class="fc" id="L2955">    }</span>

    public double[][] createUnitStandardDeviation(GreyscaleImage img, int halfDimension) {

<span class="nc" id="L2959">        SummedAreaTable sumTable = new SummedAreaTable();</span>

<span class="nc" id="L2961">        GreyscaleImage imgM = sumTable.createAbsoluteSummedAreaTable(img);</span>
<span class="nc" id="L2962">        imgM = sumTable.applyMeanOfWindowFromSummedAreaTable(imgM,</span>
            2*halfDimension + 1);

<span class="nc" id="L2965">        int w = img.getWidth();</span>
<span class="nc" id="L2966">        int h = img.getHeight();</span>
<span class="nc" id="L2967">        double[][] out = new double[w][];</span>
<span class="nc bnc" id="L2968" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc" id="L2969">            out[i] = new double[h];</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L2971">                int m = imgM.getValue(i, j);</span>
<span class="nc" id="L2972">                double v = img.getValue(i, j) - m;</span>
<span class="nc bnc" id="L2973" title="All 2 branches missed.">                if (m == 0) {</span>
<span class="nc" id="L2974">                    v = 0;</span>
                } else {
<span class="nc" id="L2976">                    v = v / (Math.sqrt(2)/m);</span>
                }
<span class="nc" id="L2978">                out[i][j] = v;</span>
            }
        }

<span class="nc" id="L2982">        return out;</span>
    }

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a decreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels) and never more than
     * 4 times O(N_pixels).
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean2(double[][] img, int halfDimension) {

<span class="fc" id="L3007">        SummedAreaTable sumTable = new SummedAreaTable();</span>

<span class="fc" id="L3009">        double[][] imgS = sumTable.createAbsoluteSummedAreaTable(img);</span>

<span class="fc" id="L3011">        imgS = sumTable.applyMeanOfWindowFromSummedAreaTable(imgS,</span>
            2*halfDimension + 1);

<span class="fc bfc" id="L3014" title="All 2 branches covered.">        for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="fc" id="L3015">            System.arraycopy(imgS[i], 0, img[i], 0, imgS[i].length);</span>
        }
<span class="fc" id="L3017">    }</span>

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a decreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels), but is also dependent upon
     * halfDimension.  Prefer to use applyCenteredMean2 which is always
     * less than 4 times O(N) in runtime complexity.
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean(GreyscaleImage img, int halfDimension) {

<span class="pc bpc" id="L3042" title="1 of 2 branches missed.">        if ((img.getWidth() &lt; 2*halfDimension) ||</span>
<span class="pc bpc" id="L3043" title="1 of 2 branches missed.">            (img.getHeight() &lt; 2*halfDimension)) {</span>
<span class="nc" id="L3044">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }

        /*
        becomes efficient when halfDimension &gt; 1

        sum along columns first using dynamic programming, then rows
        */

<span class="fc" id="L3054">        int dimension = 2*halfDimension + 1;</span>

<span class="fc" id="L3056">        int w = img.getWidth();</span>
<span class="fc" id="L3057">        int h = img.getHeight();</span>

<span class="fc" id="L3059">        int[] mean = new int[img.getNPixels()];</span>

<span class="fc" id="L3061">        int[] imgValues = img.getValues();</span>

        // sum along rows
<span class="fc bfc" id="L3064" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>

            /* pixels before halfDimension
            halfDimension = 2
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3071" title="All 2 branches covered.">            for (int j = 0; j &lt; halfDimension; ++j) {</span>
<span class="fc" id="L3072">                float count = halfDimension - j;</span>
<span class="fc" id="L3073">                float sum = 0;</span>
<span class="fc bfc" id="L3074" title="All 2 branches covered.">                for (int k = j; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3075">                    int pixIdx = img.getIndex(i, k);</span>
<span class="fc" id="L3076">                    sum += imgValues[pixIdx];</span>
                }
<span class="fc" id="L3078">                sum /= count;</span>
<span class="fc" id="L3079">                sum *= dimension;</span>
<span class="fc" id="L3080">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3081">                mean[pixIdx] = Math.round(sum);</span>
            }

            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3090">            int sum0 = 0;</span>
<span class="fc bfc" id="L3091" title="All 2 branches covered.">            for (int j = 0; j &lt;= 2*halfDimension; ++j) {</span>
<span class="fc" id="L3092">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3093">                sum0 += imgValues[pixIdx];</span>
            }
<span class="fc" id="L3095">            int pixIdx = img.getIndex(i, halfDimension);</span>
<span class="fc" id="L3096">            mean[pixIdx] = sum0;</span>
            /*
            halfDimension = 2
            0 1 2 3 4 5 6
              |   *   |
                |   *   |

            */
<span class="fc bfc" id="L3104" title="All 2 branches covered.">            for (int j = halfDimension + 1; j &lt; (h - halfDimension); ++j) {</span>
<span class="fc" id="L3105">                pixIdx = img.getIndex(i, j - halfDimension - 1);</span>
<span class="fc" id="L3106">                int vp = imgValues[pixIdx];</span>
<span class="fc" id="L3107">                pixIdx = img.getIndex(i, j + halfDimension);</span>
<span class="fc" id="L3108">                int vl =  imgValues[pixIdx];</span>
<span class="fc" id="L3109">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3110">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3111">                mean[pixIdx] = sum0;</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2
                &gt;
            */
<span class="fc bfc" id="L3117" title="All 2 branches covered.">            for (int j = (h - halfDimension); j &lt; h; ++j) {</span>
<span class="fc" id="L3118">                float count = h - j + 1;</span>
<span class="fc" id="L3119">                float sum = 0;</span>
<span class="fc bfc" id="L3120" title="All 2 branches covered.">                for (int k = (j - 1); k &lt; h; ++k) {</span>
<span class="fc" id="L3121">                    pixIdx = img.getIndex(i, k);</span>
<span class="fc" id="L3122">                    sum +=  imgValues[pixIdx];</span>
                }
<span class="fc" id="L3124">                sum /= count;</span>
<span class="fc" id="L3125">                sum *= dimension;</span>
<span class="fc" id="L3126">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3127">                mean[pixIdx] = Math.round(sum);</span>
            }
        }

        // sum along columns
<span class="fc bfc" id="L3132" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>

            /* pixels before halfDimension
            halfDimension = 2
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3139" title="All 2 branches covered.">            for (int i = 0; i &lt; halfDimension; ++i) {</span>
<span class="fc" id="L3140">                float count = halfDimension - i;</span>
<span class="fc" id="L3141">                float sum = 0;</span>
<span class="fc bfc" id="L3142" title="All 2 branches covered.">                for (int k = i; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3143">                    int pixIdx = img.getIndex(k, j);</span>
<span class="fc" id="L3144">                    sum += mean[pixIdx];</span>
                }
<span class="fc" id="L3146">                sum /= count;</span>
<span class="fc" id="L3147">                sum *= dimension;</span>
<span class="fc" id="L3148">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3149">                imgValues[pixIdx] =  Math.round(sum);</span>
            }

            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3158">            int sum0 = 0;</span>
<span class="fc bfc" id="L3159" title="All 2 branches covered.">            for (int i = 0; i &lt;= 2*halfDimension; ++i) {</span>
<span class="fc" id="L3160">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3161">                sum0 += mean[pixIdx];</span>
            }
<span class="fc" id="L3163">            int pixIdx = img.getIndex(halfDimension, j);</span>
<span class="fc" id="L3164">            imgValues[pixIdx] = sum0;</span>
            /*
            halfDimension = 2
            0 1 2 3 4 5 6
              |   *   |
                |   *   |

            */
<span class="fc bfc" id="L3172" title="All 2 branches covered.">            for (int i = halfDimension + 1; i &lt; (w - halfDimension); ++i) {</span>
<span class="fc" id="L3173">                pixIdx = img.getIndex(i - halfDimension - 1, j);</span>
<span class="fc" id="L3174">                int vp = mean[pixIdx];</span>
<span class="fc" id="L3175">                pixIdx = img.getIndex(i + halfDimension, j);</span>
<span class="fc" id="L3176">                int vl =  mean[pixIdx];</span>
<span class="fc" id="L3177">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3178">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3179">                imgValues[pixIdx] = sum0;</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2
                &gt;
            */
<span class="fc bfc" id="L3185" title="All 2 branches covered.">            for (int i = (w - halfDimension); i &lt; w; ++i) {</span>
<span class="fc" id="L3186">                float count = w - i + 1;</span>
<span class="fc" id="L3187">                float sum = 0;</span>
<span class="fc bfc" id="L3188" title="All 2 branches covered.">                for (int k = (i - 1); k &lt; w; ++k) {</span>
<span class="fc" id="L3189">                    pixIdx = img.getIndex(k, j);</span>
<span class="fc" id="L3190">                    sum += mean[pixIdx];</span>
                }
<span class="fc" id="L3192">                sum /= count;</span>
<span class="fc" id="L3193">                sum *= dimension;</span>
<span class="fc" id="L3194">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3195">                imgValues[pixIdx] = Math.round(sum);</span>
            }
        }

<span class="fc" id="L3199">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3200" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3201" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3202">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3203">                int v = imgValues[pixIdx];</span>
<span class="fc" id="L3204">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3205">                imgValues[pixIdx] = v;</span>
            }
        }
<span class="fc bfc" id="L3208" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L3209">            img.setValue(i, imgValues[i]);</span>
        }
<span class="fc" id="L3211">    }</span>

    public Complex[][] copy(Complex[][] input) {

<span class="nc" id="L3215">        int n0 = input.length;</span>

<span class="nc" id="L3217">        Complex[][] output = new Complex[n0][];</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="nc" id="L3219">            output[i] = Arrays.copyOf(input[i], input[i].length);</span>
        }

<span class="nc" id="L3222">        return output;</span>
    }

    public double[][] copy(double[][] input) {

<span class="fc" id="L3227">        int n0 = input.length;</span>

<span class="fc" id="L3229">        double[][] output = new double[n0][];</span>
<span class="fc bfc" id="L3230" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L3231">            output[i] = Arrays.copyOf(input[i], input[i].length);</span>
        }

<span class="fc" id="L3234">        return output;</span>
    }

    /**
     * output is column major format
     * @param input
     * @return
     */
    public double[][] copy(GreyscaleImage input) {

<span class="fc" id="L3244">        int n0 = input.getNPixels();</span>
<span class="fc" id="L3245">        int w = input.getWidth();</span>
<span class="fc" id="L3246">        int h = input.getHeight();</span>

<span class="fc" id="L3248">        double[][] output = new double[w][h];</span>
<span class="fc bfc" id="L3249" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3250">            output[i] = new double[h];</span>
<span class="fc bfc" id="L3251" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3252">                output[i][j] = input.getValue(i, j);</span>
            }
        }

<span class="fc" id="L3256">        return output;</span>
    }
    
    /**
     * output is row major format
     * @param m
     * @return
     */
    public double[][] copyToDouble2D(Matrix m) {

<span class="nc" id="L3266">        double[][] output = new double[m.numRows()][];</span>
<span class="nc bnc" id="L3267" title="All 2 branches missed.">        for (int i = 0; i &lt; m.numRows(); ++i) {</span>
<span class="nc" id="L3268">            output[i] = new double[m.numColumns()];</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">            for (int j = 0; j &lt; m.numColumns(); ++j) {</span>
<span class="nc" id="L3270">                output[i][j] = m.get(i, j);</span>
            }
        }

<span class="nc" id="L3274">        return output;</span>
    }

    /**
     * @param input
     * @return
     */
    public float[][] copyToFloat2D(GreyscaleImage input) {

<span class="fc" id="L3283">        int w = input.getWidth();</span>
<span class="fc" id="L3284">        int h = input.getHeight();</span>
        
<span class="fc" id="L3286">        float[][] output = new float[w][];</span>
<span class="fc bfc" id="L3287" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3288">            output[i] = new float[h];</span>
<span class="fc bfc" id="L3289" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3290">                output[i][j] = input.getValue(i, j);</span>
            }
        }

<span class="fc" id="L3294">        return output;</span>
    }
    
    /**
     * @param input
     * @return
     */
    public int[][] copyToInt2D(GreyscaleImage input) {

<span class="fc" id="L3303">        int w = input.getWidth();</span>
<span class="fc" id="L3304">        int h = input.getHeight();</span>
        
<span class="fc" id="L3306">        int[][] output = new int[w][];</span>
<span class="fc bfc" id="L3307" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3308">            output[i] = new int[h];</span>
<span class="fc bfc" id="L3309" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3310">                output[i][j] = input.getValue(i, j);</span>
            }
        }

<span class="fc" id="L3314">        return output;</span>
    }

    /**
     * output is row major format
     * @param input
     * @return
     */
    public float[][] copyToRowMajor(GreyscaleImage input) {

<span class="fc" id="L3324">        int n0 = input.getNPixels();</span>
<span class="fc" id="L3325">        int h = input.getWidth();</span>
<span class="fc" id="L3326">        int w = input.getHeight();</span>

<span class="fc" id="L3328">        float[][] output = new float[w][h];</span>
<span class="fc bfc" id="L3329" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3330">            output[i] = new float[h];</span>
<span class="fc bfc" id="L3331" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3332">                output[i][j] = input.getValue(j, i);</span>
            }
        }

<span class="fc" id="L3336">        return output;</span>
    }

    /**
     * create a two-dimensional float array of the img multiplied by
     * factor, but returned in row-major format [row][col].
     * @param img
     * @param factor
     * @return
     */
    public float[][] multiply(GreyscaleImage img, float factor) {

<span class="fc" id="L3348">        int nRows = img.getHeight();</span>
<span class="fc" id="L3349">        int nCols = img.getWidth();</span>
<span class="fc" id="L3350">        float[][] out = new float[nRows][nCols];</span>
<span class="fc bfc" id="L3351" title="All 2 branches covered.">        for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc" id="L3352">            out[j] = new float[nCols];</span>
        }

<span class="fc bfc" id="L3355" title="All 2 branches covered.">        for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc bfc" id="L3356" title="All 2 branches covered.">            for (int i = 0; i &lt; nCols; ++i) {</span>
<span class="fc" id="L3357">                out[j][i] = (float)img.getValue(i, j) * factor;</span>
            }
        }

<span class="fc" id="L3361">        return out;</span>
    }

    /**
     *
     * @param image 2 dimensional array of data, assumed row-major format
     * @param sigma
     * @param outKeypoints0
     * @param outKeypoints1
     */
    public void createFirstDerivKeyPoints(float[][] image,
        float sigma, TIntList outKeypoints0, TIntList outKeypoints1) {

<span class="nc" id="L3374">        boolean createCurvatureComponents = false;</span>

<span class="nc" id="L3376">        StructureTensor tensorComponents = new StructureTensor(image,</span>
            sigma, createCurvatureComponents);

<span class="nc" id="L3379">        float hLimit = 0.09f;//0.05f;</span>

<span class="nc" id="L3381">        createFirstDerivKeyPoints(tensorComponents, outKeypoints0,</span>
            outKeypoints1, hLimit);
<span class="nc" id="L3383">    }</span>

    public void createFirstDerivKeyPoints(
        StructureTensor tensorComponents, TIntList outKeypoints0,
        TIntList outKeypoints1, float hLimit) {

<span class="fc" id="L3389">        TIntList kp0 = new TIntArrayList();</span>
<span class="fc" id="L3390">        TIntList kp1 = new TIntArrayList();</span>

        // square of 1st deriv:
<span class="fc" id="L3393">        float[][] firstDeriv = </span>
<span class="fc" id="L3394">            MatrixUtil.add(tensorComponents.getDXSquared(),</span>
<span class="fc" id="L3395">                tensorComponents.getDYSquared());</span>

<span class="fc" id="L3397">        peakLocalMax(firstDeriv, 1, 0.1f, true, kp0, kp1);</span>

<span class="fc" id="L3399">        float[][] detA = tensorComponents.getDeterminant();</span>
<span class="fc" id="L3400">        float[][] traceA = tensorComponents.getTrace();</span>

        //float min = MiscMath.findMin(secondDeriv);
        //float max = MiscMath.findMax(secondDeriv);
        //System.out.println(&quot;min=&quot; + min + &quot; max=&quot; + max);
        //System.out.println(&quot;nRows=&quot; + nRows + &quot; nCols=&quot; + nCols);
<span class="fc bfc" id="L3406" title="All 2 branches covered.">        for (int i = 0; i &lt; kp0.size(); ++i) {</span>
<span class="fc" id="L3407">            int x = kp0.get(i);</span>
<span class="fc" id="L3408">            int y = kp1.get(i);</span>
            // harmonic mean, Brown, Szeliski, and Winder (2005),
<span class="fc" id="L3410">            float hMean = (detA[x][y]/traceA[x][y]);</span>
<span class="pc bpc" id="L3411" title="1 of 2 branches missed.">            if (hMean &gt; hLimit) {</span>
                //System.out.println(String.format(&quot;(%d,%d) detA/tr=%.4f&quot;,
                //    x, y, hMean));
<span class="nc" id="L3414">                outKeypoints0.add(x);</span>
<span class="nc" id="L3415">                outKeypoints1.add(y);</span>
            }
        }

        /*{// DEBUG
            float[][] a = copy(firstDeriv);
            MiscMath.applyRescale(a, 0, 255);
            MiscDebug.writeImage(a, &quot;_fitsr_deriv_&quot;
                + MiscDebug.getCurrentTimeFormatted());
        }*/

<span class="fc" id="L3426">    }</span>

    public Set&lt;PairInt&gt; binPoints(Set&lt;PairInt&gt; points, int binFactor) {

<span class="nc" id="L3430">        Set&lt;PairInt&gt; out = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3431" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L3432">            int x = Math.round((float)p.getX()/(float)binFactor);</span>
<span class="nc" id="L3433">            int y = Math.round((float)p.getY()/(float)binFactor);</span>
<span class="nc" id="L3434">            out.add(new PairInt(x, y));</span>
<span class="nc" id="L3435">        }</span>

<span class="nc" id="L3437">        return out;</span>
    }

    /**
     * downsample the image to size w2,h2 with the given clamp values.
     * Note that the interpolation is currently a bilinear filter,
     * but in the future, a more accurate algorithm may be present.
     * possibly a windowed sinc pre-filter).
     * @param input
     * @param w2 the width of the output image
     * @param h2 the height of the output image
     * @param minValue minimum value to clamp results to
     * @param maxValue maximum value to clamp results to
     * @return
     */
    public GreyscaleImage downSample(GreyscaleImage input,
        int w2, int h2, int minValue, int maxValue) {

        // uses bilinear interpolation over pixels of input
        // contributing to down sampled output

<span class="fc" id="L3458">        GreyscaleImage output = null;</span>
<span class="pc bpc" id="L3459" title="2 of 4 branches missed.">        if (minValue &gt;= 0 &amp;&amp; maxValue &lt;= 255) {</span>
<span class="fc" id="L3460">            output = input.createWithDimensions(w2, h2);</span>
        } else {
<span class="nc" id="L3462">            output = new GreyscaleImage(w2, h2,</span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }

<span class="fc" id="L3466">        int w0 = input.getWidth();</span>
<span class="fc" id="L3467">        int h0 = input.getHeight();</span>

<span class="fc" id="L3469">        float rW = (float)w0/(float)w2;</span>
<span class="fc" id="L3470">        float rH = (float)h0/(float)h2;</span>

<span class="fc" id="L3472">        int cX = Math.round(rW);</span>
<span class="fc" id="L3473">        int cY = Math.round(rH);</span>

        //System.out.println(&quot;rX=&quot; + rW + &quot; rY=&quot; + rH);

<span class="fc bfc" id="L3477" title="All 2 branches covered.">        for (int i = 0; i &lt; w2; ++i) {</span>

<span class="fc" id="L3479">            float i2f = rW * i;</span>

<span class="fc bfc" id="L3481" title="All 2 branches covered.">            for (int j = 0; j &lt; h2; ++j) {</span>

<span class="fc" id="L3483">                double sum = 0;</span>
<span class="fc" id="L3484">                int np = 0;</span>

                // integrate the points in input for offsets up to cX
<span class="fc bfc" id="L3487" title="All 2 branches covered.">                for (float ii = i2f; ii &lt; (i2f + cX); ++ii) {</span>
<span class="pc bpc" id="L3488" title="2 of 4 branches missed.">                    if (ii &lt; 0 || Math.ceil(ii) &gt;= w0) {</span>
<span class="nc" id="L3489">                        continue;</span>
                    }

<span class="fc" id="L3492">                    float j2f = rH * j;</span>

                    // integrate the points in input for offsets up to cY
<span class="fc bfc" id="L3495" title="All 2 branches covered.">                    for (float jj = j2f; jj &lt; (j2f + cY); ++jj) {</span>
<span class="pc bpc" id="L3496" title="2 of 4 branches missed.">                        if (jj &lt; 0 || Math.ceil(jj) &gt;= h0) {</span>
<span class="nc" id="L3497">                            continue;</span>
                        }

<span class="fc" id="L3500">                        double v = biLinearInterpolation(input, ii, jj);</span>

<span class="fc" id="L3502">                        sum += v;</span>

<span class="fc" id="L3504">                        np++;</span>
                    }
                }

<span class="pc bpc" id="L3508" title="1 of 2 branches missed.">                int v2 = (np &gt; 0) ? (int)Math.round(sum/(float)np) : 0;</span>

<span class="pc bpc" id="L3510" title="1 of 2 branches missed.">                if (v2 &lt; 0) {</span>
<span class="nc" id="L3511">                    v2 = 0;</span>
<span class="pc bpc" id="L3512" title="1 of 2 branches missed.">                } else if (v2 &gt; 255) {</span>
<span class="nc" id="L3513">                    v2 = 255;</span>
                }

                //System.out.format(&quot;(%d,%d) v==&gt;%d\n&quot;, i, j, v2);

<span class="fc" id="L3518">                output.setValue(i, j, v2);</span>
            }
        }

<span class="fc" id="L3522">        return output;</span>
    }

    public int countNonZeroes(GreyscaleImage in) {
<span class="fc" id="L3526">        int n = 0;</span>
<span class="fc bfc" id="L3527" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; in.getNPixels(); ++pixIdx) {</span>
<span class="fc bfc" id="L3528" title="All 2 branches covered.">            if (in.getValue(pixIdx) &gt; 0) {</span>
<span class="fc" id="L3529">                n++;</span>
            }
        }
<span class="fc" id="L3532">        return n;</span>
    }

    public static class Colors {
        private final float[] colors;
        public Colors(float[] theColors) {
            colors = theColors;
        }
        public float[] getColors() {
            return colors;
        }
    }

    /**
     * opposite to shift zero-frequency component to the center of the spectrum
     * in that it shifts the zero-frequency component to the smallest indexes
     * in the arrays.
     *
     * adapted from
     * https://github.com/numpy/numpy/blob/master/LICENSE.txt
     * which has copyright
     *
     * Copyright (c) 2005-2016, NumPy Developers.
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are
        met:

            * Redistributions of source code must retain the above copyright
               notice, this list of conditions and the following disclaimer.

            * Redistributions in binary form must reproduce the above
               copyright notice, this list of conditions and the following
               disclaimer in the documentation and/or other materials provided
               with the distribution.

            * Neither the name of the NumPy Developers nor the names of any
               contributors may be used to endorse or promote products derived
               from this software without specific prior written permission.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * @param a
     * @return
     */
    public double[][] ifftShift(double[][] a) {

<span class="fc" id="L3589">        double[][] b = new double[a.length][];</span>

        // ---- reorder columns ----
<span class="fc" id="L3592">        int nc = a.length;</span>
<span class="fc" id="L3593">        int p2 = nc - ((nc + 1)/2);</span>
<span class="fc" id="L3594">        List&lt;Integer&gt; range = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L3595" title="All 2 branches covered.">        for (int i = p2; i &lt; nc; ++i) {</span>
<span class="fc" id="L3596">            range.add(Integer.valueOf(i));</span>
        }
<span class="fc bfc" id="L3598" title="All 2 branches covered.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="fc" id="L3599">            range.add(Integer.valueOf(i));</span>
        }
<span class="fc" id="L3601">        int count = 0;</span>
<span class="fc bfc" id="L3602" title="All 2 branches covered.">        for (Integer index : range) {</span>
<span class="fc" id="L3603">            int idx = index.intValue();</span>
<span class="fc" id="L3604">            b[count] = Arrays.copyOf(a[idx], a[idx].length);</span>
<span class="fc" id="L3605">            count++;</span>
<span class="fc" id="L3606">        }</span>

        // ---- reorder rows ------
<span class="fc" id="L3609">        nc = a[0].length;</span>
<span class="fc" id="L3610">        p2 = nc - ((nc + 1)/2);</span>
<span class="fc" id="L3611">        range = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L3612" title="All 2 branches covered.">        for (int i = p2; i &lt; nc; ++i) {</span>
<span class="fc" id="L3613">            range.add(Integer.valueOf(i));</span>
        }
<span class="fc bfc" id="L3615" title="All 2 branches covered.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="fc" id="L3616">            range.add(Integer.valueOf(i));</span>
        }

<span class="fc" id="L3619">        double[][] c = new double[a.length][];</span>
<span class="fc bfc" id="L3620" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="fc" id="L3621">            c[i] = new double[a[0].length];</span>
        }
<span class="fc" id="L3623">        count = 0;</span>
<span class="fc bfc" id="L3624" title="All 2 branches covered.">        for (Integer index : range) {</span>
<span class="fc" id="L3625">            int j = index.intValue();</span>
<span class="fc bfc" id="L3626" title="All 2 branches covered.">            for (int col = 0; col &lt; a.length; ++col) {</span>
<span class="fc" id="L3627">                c[col][count] = b[col][j];</span>
            }
<span class="fc" id="L3629">            count++;</span>
<span class="fc" id="L3630">        }</span>

<span class="fc" id="L3632">        return c;</span>
    }

    /**
     * opposite to shift zero-frequency component to the center of the spectrum
     * in that it shifts the zero-frequency component to the smallest indexes
     * in the arrays.
     *
     * adapted from
     * https://github.com/numpy/numpy/blob/master/LICENSE.txt
     * which has copyright
     *
     * Copyright (c) 2005-2016, NumPy Developers.
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are
        met:

            * Redistributions of source code must retain the above copyright
               notice, this list of conditions and the following disclaimer.

            * Redistributions in binary form must reproduce the above
               copyright notice, this list of conditions and the following
               disclaimer in the documentation and/or other materials provided
               with the distribution.

            * Neither the name of the NumPy Developers nor the names of any
               contributors may be used to endorse or promote products derived
               from this software without specific prior written permission.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * @param a
     * @return
     */
    public Complex[][] ifftShift(Complex[][] a) {

<span class="nc" id="L3679">        Complex[][] b = new Complex[a.length][];</span>

        // ---- reorder dimension 0 ----
<span class="nc" id="L3682">        int n0 = a.length;</span>
<span class="nc" id="L3683">        int p2 = n0 - ((n0 + 1)/2);</span>
<span class="nc" id="L3684">        List&lt;Integer&gt; range = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L3685" title="All 2 branches missed.">        for (int i = p2; i &lt; n0; ++i) {</span>
<span class="nc" id="L3686">            range.add(Integer.valueOf(i));</span>
        }
<span class="nc bnc" id="L3688" title="All 2 branches missed.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="nc" id="L3689">            range.add(Integer.valueOf(i));</span>
        }
<span class="nc" id="L3691">        int count = 0;</span>
<span class="nc bnc" id="L3692" title="All 2 branches missed.">        for (Integer index : range) {</span>
<span class="nc" id="L3693">            int idx = index.intValue();</span>
<span class="nc" id="L3694">            b[count] = Arrays.copyOf(a[idx], a[idx].length);</span>
<span class="nc" id="L3695">            count++;</span>
<span class="nc" id="L3696">        }</span>

        // ---- reorder dimension 1 ------
<span class="nc" id="L3699">        int n1 = a[0].length;</span>
<span class="nc" id="L3700">        p2 = n1 - ((n1 + 1)/2);</span>
<span class="nc" id="L3701">        range = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L3702" title="All 2 branches missed.">        for (int i = p2; i &lt; n1; ++i) {</span>
<span class="nc" id="L3703">            range.add(Integer.valueOf(i));</span>
        }
<span class="nc bnc" id="L3705" title="All 2 branches missed.">        for (int i = 0; i &lt; p2; ++i) {</span>
<span class="nc" id="L3706">            range.add(Integer.valueOf(i));</span>
        }

<span class="nc" id="L3709">        Complex[][] c = new Complex[a.length][];</span>
<span class="nc bnc" id="L3710" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc" id="L3711">            c[i] = new Complex[a[0].length];</span>
        }
<span class="nc" id="L3713">        count = 0;</span>
<span class="nc bnc" id="L3714" title="All 2 branches missed.">        for (Integer index : range) {</span>
<span class="nc" id="L3715">            int j = index.intValue();</span>
<span class="nc bnc" id="L3716" title="All 2 branches missed.">            for (int col = 0; col &lt; a.length; ++col) {</span>
<span class="nc" id="L3717">                c[col][count] = b[col][j];</span>
            }
<span class="nc" id="L3719">            count++;</span>
<span class="nc" id="L3720">        }</span>

<span class="nc" id="L3722">        return c;</span>
    }

    public int[] getAverageRGB(Image img, PairIntArray pArr) {

<span class="nc bnc" id="L3727" title="All 2 branches missed.">        if (pArr.getN() == 0) {</span>
<span class="nc" id="L3728">            return null;</span>
        }

<span class="nc" id="L3731">        int rSum = 0;</span>
<span class="nc" id="L3732">        int gSum = 0;</span>
<span class="nc" id="L3733">        int bSum = 0;</span>
<span class="nc bnc" id="L3734" title="All 2 branches missed.">        for (int i = 0; i &lt; pArr.getN(); ++i) {</span>
<span class="nc" id="L3735">            int x = pArr.getX(i);</span>
<span class="nc" id="L3736">            int y = pArr.getY(i);</span>
<span class="nc" id="L3737">            rSum += img.getR(x, y);</span>
<span class="nc" id="L3738">            gSum += img.getG(x, y);</span>
<span class="nc" id="L3739">            bSum += img.getB(x, y);</span>
        }
<span class="nc" id="L3741">        rSum /= pArr.getN();</span>
<span class="nc" id="L3742">        gSum /= pArr.getN();</span>
<span class="nc" id="L3743">        bSum /= pArr.getN();</span>

<span class="nc" id="L3745">        return new int[]{rSum, gSum, bSum};</span>
    }

    public int[] getAverageRGB(GreyscaleImage rImg, GreyscaleImage gImg,
        GreyscaleImage bImg, Collection&lt;PairInt&gt; points) {

<span class="nc bnc" id="L3751" title="All 2 branches missed.">        if (points.isEmpty()) {</span>
<span class="nc" id="L3752">            return null;</span>
        }

<span class="nc" id="L3755">        int rSum = 0;</span>
<span class="nc" id="L3756">        int gSum = 0;</span>
<span class="nc" id="L3757">        int bSum = 0;</span>
<span class="nc bnc" id="L3758" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L3759">            int x = p.getX();</span>
<span class="nc" id="L3760">            int y = p.getY();</span>
<span class="nc" id="L3761">            rSum += rImg.getValue(x, y);</span>
<span class="nc" id="L3762">            gSum += gImg.getValue(x, y);</span>
<span class="nc" id="L3763">            bSum += bImg.getValue(x, y);</span>
<span class="nc" id="L3764">        }</span>
<span class="nc" id="L3765">        rSum /= points.size();</span>
<span class="nc" id="L3766">        gSum /= points.size();</span>
<span class="nc" id="L3767">        bSum /= points.size();</span>

<span class="nc" id="L3769">        return new int[]{rSum, gSum, bSum};</span>
    }
    
    public int[] getAverageRGB(Image img, Collection&lt;PairInt&gt; pArr) {

<span class="pc bpc" id="L3774" title="1 of 2 branches missed.">        if (pArr.isEmpty()) {</span>
<span class="nc" id="L3775">            return null;</span>
        }

<span class="fc" id="L3778">        int rSum = 0;</span>
<span class="fc" id="L3779">        int gSum = 0;</span>
<span class="fc" id="L3780">        int bSum = 0;</span>
<span class="fc bfc" id="L3781" title="All 2 branches covered.">        for (PairInt p : pArr) {</span>
<span class="fc" id="L3782">            int x = p.getX();</span>
<span class="fc" id="L3783">            int y = p.getY();</span>
<span class="fc" id="L3784">            rSum += img.getR(x, y);</span>
<span class="fc" id="L3785">            gSum += img.getG(x, y);</span>
<span class="fc" id="L3786">            bSum += img.getB(x, y);</span>
<span class="fc" id="L3787">        }</span>
<span class="fc" id="L3788">        rSum /= pArr.size();</span>
<span class="fc" id="L3789">        gSum /= pArr.size();</span>
<span class="fc" id="L3790">        bSum /= pArr.size();</span>

<span class="fc" id="L3792">        return new int[]{rSum, gSum, bSum};</span>
    }

    public int[] getAverageRGB(Image img) {

<span class="fc" id="L3797">        int rSum = 0;</span>
<span class="fc" id="L3798">        int gSum = 0;</span>
<span class="fc" id="L3799">        int bSum = 0;</span>
<span class="fc bfc" id="L3800" title="All 2 branches covered.">        for (int p = 0; p &lt; img.nPixels; ++p) {</span>
<span class="fc" id="L3801">            rSum += img.getR(p);</span>
<span class="fc" id="L3802">            gSum += img.getG(p);</span>
<span class="fc" id="L3803">            bSum += img.getB(p);</span>
        }
<span class="fc" id="L3805">        rSum /= img.nPixels;</span>
<span class="fc" id="L3806">        gSum /= img.nPixels;</span>
<span class="fc" id="L3807">        bSum /= img.nPixels;</span>

<span class="fc" id="L3809">        return new int[]{rSum, gSum, bSum};</span>
    }

    /**
     * NOTE: needs testing...invoker should trim for image bounds
     * where needed.
     * @param points
     * @param sigma
     */
    public void blur(Set&lt;PairInt&gt; points, SIGMA sigma) {

        // gaussian smoothing by sigma
<span class="fc" id="L3821">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L3823">        applyKernel(points, kernel);</span>
<span class="fc" id="L3824">    }</span>

    /**
     * NOTE: needs testing...invoker should trim for image bounds
     * where needed.
     * @param points
     * @param kernel
     */
    public void applyKernel(Set&lt;PairInt&gt; points, float[] kernel) {

<span class="fc" id="L3834">        int[] minMaxXY = MiscMath.findMinMaxXY(points);</span>

<span class="fc" id="L3836">        int xLL = minMaxXY[0] - 10;</span>
<span class="fc bfc" id="L3837" title="All 2 branches covered.">        if (xLL &lt; 0) {</span>
<span class="fc" id="L3838">            xLL = 0;</span>
        }
<span class="fc" id="L3840">        int yLL = minMaxXY[2] - 10;</span>
<span class="fc bfc" id="L3841" title="All 2 branches covered.">        if (yLL &lt; 0) {</span>
<span class="fc" id="L3842">            yLL = 0;</span>
        }

<span class="fc" id="L3845">        int xUR = minMaxXY[1] + 10;</span>
<span class="fc" id="L3846">        int yUR = minMaxXY[3] + 10;</span>

<span class="fc" id="L3848">        int w = xUR - xLL + 1;</span>
<span class="fc" id="L3849">        int h = yUR - yLL + 1;</span>

<span class="fc" id="L3851">        int[][] img = new int[w][];</span>
<span class="fc bfc" id="L3852" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3853">            img[i] = new int[h];</span>
        }

<span class="fc bfc" id="L3856" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L3857">            int x = p.getX() - xLL;</span>
<span class="fc" id="L3858">            int y = p.getY() - yLL;</span>
<span class="fc" id="L3859">            img[x][y] = 126;</span>
<span class="fc" id="L3860">        }</span>

<span class="fc" id="L3862">        applyKernelTwo1Ds(img, kernel);</span>

<span class="fc" id="L3864">        points.clear();</span>

<span class="fc bfc" id="L3866" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3867" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc bfc" id="L3868" title="All 2 branches covered.">                if (img[i][j] &lt;= 0) {</span>
<span class="fc" id="L3869">                    continue;</span>
                }
<span class="fc" id="L3871">                int x = i + xLL;</span>
<span class="fc" id="L3872">                int y = j + yLL;</span>
<span class="fc" id="L3873">                PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L3874">                points.add(p);</span>
            }
        }
<span class="fc" id="L3877">    }</span>

    /**
     * blur the points by sigma and trim any extending beyond image bounds.
     * @param points
     * @param sigma
     * @param imgWidth
     * @param imgHeight
     */
    public void blurAndTrim(Set&lt;PairInt&gt; points, SIGMA sigma, int imgWidth,
        int imgHeight) {

<span class="fc" id="L3889">        blur(points, sigma);</span>

        // trim any points extending beyond image bounds
<span class="fc" id="L3892">        Set&lt;PairInt&gt; rm = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L3893" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="pc bpc" id="L3894" title="2 of 4 branches missed.">            if ((p.getX() &gt; (imgWidth - 1)) || (p.getY() &gt; (imgHeight - 1)) ||</span>
<span class="pc bpc" id="L3895" title="2 of 4 branches missed.">                (p.getX() &lt; 0) || (p.getY() &lt; 0)) {</span>
<span class="nc" id="L3896">                rm.add(p);</span>
            }
<span class="fc" id="L3898">        }</span>

<span class="fc" id="L3900">        points.removeAll(rm);</span>
<span class="fc" id="L3901">    }</span>

    /**
     * NOTE: modifies input by the blur step.
     * @param contiguousPoints
     * @param sigma
     * @param imgWidth
     * @param imgHeight
     * @return
     */
    public PairIntArray extractSmoothedOrderedBoundary(
        Set&lt;PairInt&gt; contiguousPoints, SIGMA sigma, int imgWidth, int imgHeight) {

<span class="fc" id="L3914">        blurAndTrim(contiguousPoints, sigma, imgWidth, imgHeight);</span>

<span class="fc" id="L3916">        PerimeterFinder2 finder = new PerimeterFinder2();</span>
<span class="fc" id="L3917">        PairIntArray ordered = finder.extractOrderedBorder(</span>
            contiguousPoints);

<span class="fc" id="L3920">        return ordered;</span>
    }

    /**
     * apply a dilate operator of size 3 x 3 to any pixel in image with value
     * greater than 0.
     * Note that if the img is not binary, the result may not be ideal because
     * no attempt has been made to account for existing pixel value when
     * overwritten during dilation of adjacent pixel.
     *
     * @param img
     * @return
     */
    public GreyscaleImage dilate(GreyscaleImage img) {
<span class="fc" id="L3934">        return dilateOrErode(img, true);</span>
    }

    /**
     * apply an erosion operator of size 3 x 3 to any pixel in image with value
     * 0.
     *
     * @param img
     * @return
     */
    public GreyscaleImage erode(GreyscaleImage img) {
<span class="fc" id="L3945">       return dilateOrErode(img, false);</span>
    }

    /**
     *
     * @param img
     * @return
     */
    private GreyscaleImage dilateOrErode(GreyscaleImage img, boolean dilate) {

<span class="fc" id="L3955">        int w = img.getWidth();</span>
<span class="fc" id="L3956">        int h = img.getHeight();</span>
<span class="fc" id="L3957">        int n = img.getNPixels();</span>

<span class="fc" id="L3959">        GreyscaleImage out = img.copyImage();</span>

<span class="fc bfc" id="L3961" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; n; ++pixIdx) {</span>
<span class="fc" id="L3962">            int v = img.getValue(pixIdx);</span>
<span class="fc bfc" id="L3963" title="All 4 branches covered.">            if (dilate &amp;&amp; v &lt; 1) {</span>
<span class="fc" id="L3964">                continue;</span>
<span class="fc bfc" id="L3965" title="All 4 branches covered.">            } else if (!dilate &amp;&amp; v != 0) {</span>
<span class="fc" id="L3966">                continue;</span>
            }
<span class="fc" id="L3968">            int x = img.getCol(pixIdx);</span>
<span class="fc" id="L3969">            int y = img.getRow(pixIdx);</span>
<span class="fc bfc" id="L3970" title="All 2 branches covered.">            for (int i = -1; i &lt;= 1; ++i) {</span>
<span class="fc" id="L3971">                int x2 = x + i;</span>
<span class="fc bfc" id="L3972" title="All 4 branches covered.">                if (x2 &lt; 0 || x2 &gt; (w - 1)) {</span>
<span class="fc" id="L3973">                    continue;</span>
                }
<span class="fc bfc" id="L3975" title="All 2 branches covered.">                for (int j = -1; j &lt;= 1; ++j) {</span>
<span class="fc bfc" id="L3976" title="All 4 branches covered.">                    if (i == 0 &amp;&amp; j == 0) {</span>
<span class="fc" id="L3977">                        continue;</span>
                    }
<span class="fc" id="L3979">                    int y2 = y + j;</span>
<span class="fc bfc" id="L3980" title="All 4 branches covered.">                    if (y2 &lt; 0 || y2 &gt; (h - 1)) {</span>
<span class="fc" id="L3981">                        continue;</span>
                    }
                    /*if (x == 0 &amp;&amp; x2 == 0) {
                        continue;
                    }
                    if (y == 0 &amp;&amp; y2 == 0) {
                        continue;
                    }
                    if (x == (w - 1) &amp;&amp; x2 == (w - 1)) {
                        continue;
                    }
                    if (y == (h - 1) &amp;&amp; y2 == (h - 1)) {
                        continue;
                    }*/

<span class="fc" id="L3996">                    out.setValue(x2, y2, v);</span>
                }
            }
        }

<span class="fc" id="L4001">        return out;</span>
    }

    private Set&lt;PairInt&gt; dilate(Set&lt;PairInt&gt; set,
        int imageWidth, int imageHeight, boolean dilate) {

<span class="nc" id="L4007">        int w = imageWidth;</span>
<span class="nc" id="L4008">        int h = imageHeight;</span>

<span class="nc" id="L4010">        Set&lt;PairInt&gt; out = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L4012" title="All 2 branches missed.">        for (PairInt p : set) {</span>
<span class="nc" id="L4013">            int x = p.getX();</span>
<span class="nc" id="L4014">            int y = p.getY();</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">            for (int i = -1; i &lt;= 1; ++i) {</span>
<span class="nc" id="L4016">                int x2 = x + i;</span>
<span class="nc bnc" id="L4017" title="All 4 branches missed.">                if (x2 &lt; 0 || x2 &gt; (w - 1)) {</span>
<span class="nc" id="L4018">                    continue;</span>
                }
<span class="nc bnc" id="L4020" title="All 2 branches missed.">                for (int j = -1; j &lt;= 1; ++j) {</span>
<span class="nc bnc" id="L4021" title="All 4 branches missed.">                    if (i == 0 &amp;&amp; j == 0) {</span>
<span class="nc" id="L4022">                        continue;</span>
                    }
<span class="nc" id="L4024">                    int y2 = y + j;</span>
<span class="nc bnc" id="L4025" title="All 4 branches missed.">                    if (y2 &lt; 0 || y2 &gt; (h - 1)) {</span>
<span class="nc" id="L4026">                        continue;</span>
                    }
<span class="nc" id="L4028">                    out.add(new PairInt(x2, y2));</span>
                }
            }
<span class="nc" id="L4031">        }</span>

<span class="nc" id="L4033">        return out;</span>
    }

    /**
     * apply erode then dilate
     *
     * @param img
     * @return
     */
    public GreyscaleImage opening(GreyscaleImage img) {
<span class="nc" id="L4043">        GreyscaleImage erode = erode(img);</span>
<span class="nc" id="L4044">        return dilate(erode);</span>
    }

    /**
     * apply dilate then erode
     *
     * @param img
     * @return
     */
    public GreyscaleImage closing(GreyscaleImage img) {
<span class="fc" id="L4054">        GreyscaleImage dilate = dilate(img);</span>
<span class="fc" id="L4055">        return erode(dilate);</span>
    }

    /**
     * apply morphological thinning.
     * prefer this line thinner over applyThinning()
     * @param img
     * @return number of points &gt; 0 after thinning
     */
    public int applyThinning2(GreyscaleImage img) {

<span class="fc" id="L4066">        int n0 = img.getWidth();</span>
<span class="fc" id="L4067">        int n1 = img.getHeight();</span>

<span class="fc" id="L4069">        int[][] morphInput = new int[n0][];</span>
<span class="fc bfc" id="L4070" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L4071">            morphInput[i] = new int[n1];</span>
        }
<span class="fc bfc" id="L4073" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc bfc" id="L4074" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc bfc" id="L4075" title="All 2 branches covered.">                if (img.getValue(i, j) &gt; 0) {</span>
<span class="fc" id="L4076">                    morphInput[i][j] = 1;</span>
                } else {
<span class="fc" id="L4078">                    morphInput[i][j] = 0;</span>
                }
            }
        }

<span class="fc" id="L4083">        MorphologicalFilter mFilter = new MorphologicalFilter();</span>
<span class="fc" id="L4084">        int[][] skel = mFilter.bwMorphThin(morphInput, Integer.MAX_VALUE);</span>

<span class="fc" id="L4086">        int n1s = 0;</span>

<span class="fc bfc" id="L4088" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc bfc" id="L4089" title="All 2 branches covered.">            for (int j = 0; j &lt; n1; ++j) {</span>
<span class="fc" id="L4090">                int m = skel[i][j];</span>
<span class="fc" id="L4091">                int v = img.getValue(i, j) * m;</span>
<span class="fc" id="L4092">                img.setValue(i, j, v);</span>
<span class="fc bfc" id="L4093" title="All 2 branches covered.">                if (v &gt; 0) {</span>
<span class="fc" id="L4094">                    n1s++;</span>
                }
            }
        }

<span class="fc" id="L4099">        return n1s;</span>
    }

    /**
     * apply 8 hit or miss filters iteratively until convergence to thin the
     * image.  the operation is performed on all pixels with
     * value &gt; 0.  prefer applyThinning2() to this method.
     * @param img
     */
    public void applyThinning(GreyscaleImage img) {

        //from https://en.wikipedia.org/wiki/Hit-or-miss_transform
        // and thinning

        // x,y pairs are sequential in these
<span class="fc" id="L4114">        int[] c1 = new int[]{0,  0, -1, -1, 0,  -1, 1, -1};</span>
<span class="fc" id="L4115">        int[] d1 = new int[]{-1, 1, 0,   1, 1,  1};</span>
<span class="fc" id="L4116">        int[] c2 = new int[]{-1, 0, 0,   0, -1, -1, 0, -1};</span>
<span class="fc" id="L4117">        int[] d2 = new int[]{0,  1, 1,   1, 1,  0};</span>

<span class="fc" id="L4119">        int maxValue = img.getMax();</span>
<span class="fc" id="L4120">        int nBits = 1 + (int)Math.ceil(Math.log(maxValue)/Math.log(2));</span>
<span class="pc bpc" id="L4121" title="1 of 2 branches missed.">        if (nBits &gt; 31) {</span>
<span class="nc" id="L4122">            nBits = 31;</span>
        }
        
        /*
            - - -        - -
              +        + + -
            + + +      + +
        */
<span class="fc" id="L4130">        PairInt[][] neighborCoordOffsets</span>
<span class="fc" id="L4131">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(0, 0);</span>

<span class="fc" id="L4133">        int w = img.getWidth();</span>
<span class="fc" id="L4134">        int h = img.getHeight();</span>
<span class="fc" id="L4135">        int n = img.getNPixels();</span>
<span class="fc" id="L4136">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L4137">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L4139">        int nEdited = 0;</span>
<span class="fc" id="L4140">        int nIter = 0;</span>
        do {
<span class="fc" id="L4142">            nEdited = 0;</span>

            //GreyscaleImage tmp = out.copyImage();
            //tmp.multiply(255.f);
            //MiscDebug.writeImage(tmp, &quot;_editing_&quot; + MiscDebug.getCurrentTimeFormatted());

            // test c1, d1 and it rotated by 90 3 times
            // test c2, d2 and it rotated by 90 3 times
            // need to alternate direction of approach
<span class="fc bfc" id="L4151" title="All 2 branches covered.">            for (int t = 0; t &lt; 2; ++t) {</span>
                int[] tmpC;
                int[] tmpD;
<span class="fc bfc" id="L4154" title="All 2 branches covered.">                if (t == 0) {</span>
<span class="fc" id="L4155">                    tmpC = Arrays.copyOf(c1, c1.length);</span>
<span class="fc" id="L4156">                    tmpD = Arrays.copyOf(d1, d1.length);</span>
                } else {
<span class="fc" id="L4158">                    tmpC = Arrays.copyOf(c2, c2.length);</span>
<span class="fc" id="L4159">                    tmpD = Arrays.copyOf(d2, d2.length);</span>
                }
<span class="fc bfc" id="L4161" title="All 2 branches covered.">                for (int r = 0; r &lt; 4; ++r) {</span>
<span class="fc bfc" id="L4162" title="All 2 branches covered.">                    if (r &gt; 0) {</span>
<span class="fc" id="L4163">                        rotatePairsBy90(tmpC);</span>
<span class="fc" id="L4164">                        rotatePairsBy90(tmpD);</span>
                    }

                    // to try to make it more symmetric, collecting all
                    // nullable pixels and counting the set neighbors,
                    // then revisiting by order of fewest set neighbors
<span class="fc" id="L4170">                    MinHeapForRT2012 heap = new MinHeapForRT2012(9, n, nBits);</span>

<span class="fc bfc" id="L4172" title="All 2 branches covered.">                    for (int x = 1; x &lt; (img.getWidth() - 1); ++x) {</span>
<span class="fc bfc" id="L4173" title="All 2 branches covered.">                        for (int y = 1; y &lt; (img.getHeight() - 1); ++y) {</span>
<span class="fc" id="L4174">                            int v = img.getValue(x, y);</span>

<span class="fc bfc" id="L4176" title="All 2 branches covered.">                            if (v == 0) {</span>
<span class="fc" id="L4177">                                continue;</span>
                            }
<span class="fc bfc" id="L4179" title="All 2 branches covered.">                            if (allArePresent(img, x, y, tmpC)</span>
<span class="fc bfc" id="L4180" title="All 2 branches covered.">                                &amp;&amp; allAreNotPresent(img, x, y, tmpD)) {</span>
<span class="pc bpc" id="L4181" title="1 of 2 branches missed.">                                if (!ImageSegmentation.doesDisconnect(img,</span>
                                    neighborCoordOffsets, x, y)) {

                                    // number of neighbors that are not '1s
<span class="fc" id="L4185">                                    int nn = 0;</span>
<span class="fc bfc" id="L4186" title="All 2 branches covered.">                                    for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L4187">                                        int x2 = x + dxs[k];</span>
<span class="fc" id="L4188">                                        int y2 = y + dys[k];</span>
<span class="pc bpc" id="L4189" title="4 of 8 branches missed.">                                        if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L4190">                                            continue;</span>
                                        }
<span class="pc bpc" id="L4192" title="1 of 2 branches missed.">                                        if (img.getValue(x, y) &gt; 0) {</span>
<span class="fc" id="L4193">                                            nn++;</span>
                                        }
                                    }

                                    //long key = 8 - nn;
<span class="fc" id="L4198">                                    long key = nn;</span>
<span class="fc" id="L4199">                                    HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L4200">                                    int pixIdx = (y * w) + x;</span>
<span class="fc" id="L4201">                                    node.setData(Integer.valueOf(pixIdx));</span>
<span class="fc" id="L4202">                                    heap.insert(node);</span>
                                }
                            }
                        }
                    }

<span class="fc bfc" id="L4208" title="All 2 branches covered.">                    while (heap.getNumberOfNodes() &gt; 0) {</span>

<span class="fc" id="L4210">                        HeapNode node = heap.extractMin();</span>

<span class="pc bnc" id="L4212" title="All 2 branches missed.">                        assert(node != null);</span>

<span class="fc" id="L4214">                        int pixIdx = ((Integer)node.getData()).intValue();</span>
<span class="fc" id="L4215">                        int y = pixIdx/w;</span>
<span class="fc" id="L4216">                        int x = pixIdx - (y * w);</span>

<span class="fc" id="L4218">                        int v = img.getValue(x, y);</span>

<span class="pc bpc" id="L4220" title="1 of 2 branches missed.">                        if (v == 0) {</span>
<span class="nc" id="L4221">                            continue;</span>
                        }
<span class="pc bpc" id="L4223" title="1 of 2 branches missed.">                        if (allArePresent(img, x, y, tmpC)</span>
<span class="pc bpc" id="L4224" title="1 of 2 branches missed.">                            &amp;&amp; allAreNotPresent(img, x, y, tmpD)) {</span>
<span class="pc bpc" id="L4225" title="1 of 2 branches missed.">                            if (!ImageSegmentation.doesDisconnect(img,</span>
                                neighborCoordOffsets, x, y)) {

<span class="fc" id="L4228">                                img.setValue(x, y, 0);</span>
<span class="fc" id="L4229">                                nEdited++;</span>
                            }
                        }
<span class="fc" id="L4232">                    }</span>
                }
            }
<span class="fc" id="L4235">            nIter++;</span>
<span class="fc bfc" id="L4236" title="All 2 branches covered.">        } while (nEdited &gt; 0);</span>
<span class="fc" id="L4237">    }</span>

    /**
     * apply 8 hit or miss filters iteratively until convergence to thin the
     * image.  the operation is performed on all pixels with value &gt; 0.
     */
    public void applyThinning(Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

        //from https://en.wikipedia.org/wiki/Hit-or-miss_transform
        // and thinning

        // x,y pairs are sequential in these
<span class="fc" id="L4249">        int[] c1 = new int[]{0, 0, -1, -1, 0, -1, 1, -1};</span>
<span class="fc" id="L4250">        int[] d1 = new int[]{-1, 1, 0, 1, 1, 1};</span>
<span class="fc" id="L4251">        int[] c2 = new int[]{-1, 0, 0, 0, -1, -1, 0, -1};</span>
<span class="fc" id="L4252">        int[] d2 = new int[]{0, 1, 1, 1, 1, 0};</span>

<span class="fc" id="L4254">        int maxValue = Math.max(imageWidth, imageHeight);</span>
<span class="fc" id="L4255">        int nBits = 1 + (int)Math.ceil(Math.log(maxValue)/Math.log(2));</span>
<span class="pc bpc" id="L4256" title="1 of 2 branches missed.">        if (nBits &gt; 31) {</span>
<span class="nc" id="L4257">            nBits = 31;</span>
        }
        
        /*
            - - -        - -
              +        + + -
            + + +      + +
        */
<span class="fc" id="L4265">        PairInt[][] neighborCoordOffsets</span>
<span class="fc" id="L4266">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
            0, 0);

<span class="fc" id="L4269">        int w = imageWidth;</span>
<span class="fc" id="L4270">        int h = imageHeight;</span>
<span class="fc" id="L4271">        int n = points.size();</span>
<span class="fc" id="L4272">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L4273">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L4275">        int nEdited = 0;</span>
<span class="fc" id="L4276">        int nIter = 0;</span>
        do {
<span class="fc" id="L4278">            nEdited = 0;</span>

            //GreyscaleImage tmp = out.copyImage();
            //tmp.multiply(255.f);
            //MiscDebug.writeImage(tmp, &quot;_editing_&quot; + MiscDebug.getCurrentTimeFormatted());

            // test c1, d1 and it rotated by 90 3 times
            // test c2, d2 and it rotated by 90 3 times
            // need to alternate direction of approach
<span class="fc bfc" id="L4287" title="All 2 branches covered.">            for (int t = 0; t &lt; 2; ++t) {</span>
                int[] tmpC;
                int[] tmpD;
<span class="fc bfc" id="L4290" title="All 2 branches covered.">                if (t == 0) {</span>
<span class="fc" id="L4291">                    tmpC = Arrays.copyOf(c1, c1.length);</span>
<span class="fc" id="L4292">                    tmpD = Arrays.copyOf(d1, d1.length);</span>
                } else {
<span class="fc" id="L4294">                    tmpC = Arrays.copyOf(c2, c2.length);</span>
<span class="fc" id="L4295">                    tmpD = Arrays.copyOf(d2, d2.length);</span>
                }
<span class="fc bfc" id="L4297" title="All 2 branches covered.">                for (int r = 0; r &lt; 4; ++r) {</span>
<span class="fc bfc" id="L4298" title="All 2 branches covered.">                    if (r &gt; 0) {</span>
<span class="fc" id="L4299">                        rotatePairsBy90(tmpC);</span>
<span class="fc" id="L4300">                        rotatePairsBy90(tmpD);</span>
                    }

                    // to try to make it more symmetric, collecting all
                    // nullable pixels and counting the set neighbors,
                    // then revisiting by order of fewest set neighbors
<span class="fc" id="L4306">                    MinHeapForRT2012 heap = new MinHeapForRT2012(9, n, nBits);</span>

<span class="fc bfc" id="L4308" title="All 2 branches covered.">                    for (PairInt p : points) {</span>
<span class="fc" id="L4309">                        int x = p.getX();</span>
<span class="fc" id="L4310">                        int y = p.getY();</span>
<span class="fc bfc" id="L4311" title="All 2 branches covered.">                        if (allArePresent(points, x, y, tmpC)</span>
<span class="fc bfc" id="L4312" title="All 2 branches covered.">                            &amp;&amp; allAreNotPresent(points, x, y, tmpD)) {</span>
<span class="fc bfc" id="L4313" title="All 2 branches covered.">                            if (!ImageSegmentation.doesDisconnect(points,</span>
                                neighborCoordOffsets, x, y, imageWidth,
                                imageHeight)) {

                                // number of neighbors that are not '1s
<span class="fc" id="L4318">                                int nn = 0;</span>
<span class="fc bfc" id="L4319" title="All 2 branches covered.">                                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L4320">                                    int x2 = x + dxs[k];</span>
<span class="fc" id="L4321">                                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L4322" title="4 of 8 branches missed.">                                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L4323">                                        continue;</span>
                                    }
<span class="fc bfc" id="L4325" title="All 2 branches covered.">                                    if (points.contains(new PairInt(x2, y2))) {</span>
<span class="fc" id="L4326">                                        nn++;</span>
                                    }
                                }

                                //long key = 8 - nn;
<span class="fc" id="L4331">                                long key = nn;</span>
<span class="fc" id="L4332">                                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L4333">                                int pixIdx = (y * w) + x;</span>
<span class="fc" id="L4334">                                node.setData(Integer.valueOf(pixIdx));</span>
<span class="fc" id="L4335">                                heap.insert(node);</span>
                            }
                        }
<span class="fc" id="L4338">                    }</span>

<span class="fc bfc" id="L4340" title="All 2 branches covered.">                    while (heap.getNumberOfNodes() &gt; 0) {</span>

<span class="fc" id="L4342">                        HeapNode node = heap.extractMin();</span>

<span class="pc bnc" id="L4344" title="All 2 branches missed.">                        assert(node != null);</span>

<span class="fc" id="L4346">                        int pixIdx = ((Integer)node.getData()).intValue();</span>
<span class="fc" id="L4347">                        int y = pixIdx/w;</span>
<span class="fc" id="L4348">                        int x = pixIdx - (y * w);</span>

<span class="pc bpc" id="L4350" title="1 of 2 branches missed.">                        if (allArePresent(points, x, y, tmpC)</span>
<span class="pc bpc" id="L4351" title="1 of 2 branches missed.">                            &amp;&amp; allAreNotPresent(points, x, y, tmpD)) {</span>
<span class="pc bpc" id="L4352" title="1 of 2 branches missed.">                            if (!ImageSegmentation.doesDisconnect(points,</span>
                                neighborCoordOffsets, x, y, imageWidth,
                                imageHeight)) {

<span class="fc" id="L4356">                                points.remove(new PairInt(x, y));</span>
<span class="fc" id="L4357">                                nEdited++;</span>
                            }
                        }
<span class="fc" id="L4360">                    }</span>
                }
            }
<span class="fc" id="L4363">            nIter++;</span>
<span class="fc bfc" id="L4364" title="All 2 branches covered.">        } while (nEdited &gt; 0);</span>
<span class="fc" id="L4365">    }</span>

    /**
     * apply 8 hit or miss filters iteratively until convergence to thin the
     * image.  the operation is performed on all pixels with value &gt; 0.
     */
    public void applyThinning(TIntSet pixIdxs, int imageWidth, int imageHeight) {

        //from https://en.wikipedia.org/wiki/Hit-or-miss_transform
        // and thinning

        // x,y pairs are sequential in these
<span class="fc" id="L4377">        int[] c1 = new int[]{0, 0, -1, -1, 0, -1, 1, -1};</span>
<span class="fc" id="L4378">        int[] d1 = new int[]{-1, 1, 0, 1, 1, 1};</span>
<span class="fc" id="L4379">        int[] c2 = new int[]{-1, 0, 0, 0, -1, -1, 0, -1};</span>
<span class="fc" id="L4380">        int[] d2 = new int[]{0, 1, 1, 1, 1, 0};</span>

<span class="fc" id="L4382">        int maxValue = Math.max(imageWidth, imageHeight);</span>
<span class="fc" id="L4383">        int nBits = 1 + (int)Math.ceil(Math.log(maxValue)/Math.log(2));</span>
<span class="pc bpc" id="L4384" title="1 of 2 branches missed.">        if (nBits &gt; 31) {</span>
<span class="nc" id="L4385">            nBits = 31;</span>
        }
        
        /*
            - - -        - -
              +        + + -
            + + +      + +
        */
<span class="fc" id="L4393">        PairInt[][] neighborCoordOffsets</span>
<span class="fc" id="L4394">            = AbstractLineThinner.createCoordinatePointsForEightNeighbors(</span>
            0, 0);

<span class="fc" id="L4397">        int w = imageWidth;</span>
<span class="fc" id="L4398">        int h = imageHeight;</span>
<span class="fc" id="L4399">        int n = pixIdxs.size();</span>
<span class="fc" id="L4400">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L4401">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L4403">        int nEdited = 0;</span>
<span class="fc" id="L4404">        int nIter = 0;</span>
        do {
<span class="fc" id="L4406">            nEdited = 0;</span>

            // test c1, d1 and it rotated by 90 3 times
            // test c2, d2 and it rotated by 90 3 times
            // need to alternate direction of approach
<span class="fc bfc" id="L4411" title="All 2 branches covered.">            for (int t = 0; t &lt; 2; ++t) {</span>
                int[] tmpC;
                int[] tmpD;
<span class="fc bfc" id="L4414" title="All 2 branches covered.">                if (t == 0) {</span>
<span class="fc" id="L4415">                    tmpC = Arrays.copyOf(c1, c1.length);</span>
<span class="fc" id="L4416">                    tmpD = Arrays.copyOf(d1, d1.length);</span>
                } else {
<span class="fc" id="L4418">                    tmpC = Arrays.copyOf(c2, c2.length);</span>
<span class="fc" id="L4419">                    tmpD = Arrays.copyOf(d2, d2.length);</span>
                }
<span class="fc bfc" id="L4421" title="All 2 branches covered.">                for (int r = 0; r &lt; 4; ++r) {</span>
<span class="fc bfc" id="L4422" title="All 2 branches covered.">                    if (r &gt; 0) {</span>
<span class="fc" id="L4423">                        rotatePairsBy90(tmpC);</span>
<span class="fc" id="L4424">                        rotatePairsBy90(tmpD);</span>
                    }

                    // to try to make it more symmetric, collecting all
                    // nullable pixels and counting the set neighbors,
                    // then revisiting by order of fewest set neighbors
<span class="fc" id="L4430">                    MinHeapForRT2012 heap = new MinHeapForRT2012(9, n, nBits);</span>

<span class="fc" id="L4432">                    TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L4433" title="All 2 branches covered.">                    while (iter.hasNext()) {</span>
<span class="fc" id="L4434">                        int pixIdx = iter.next();</span>
<span class="fc" id="L4435">                        int y = pixIdx/w;</span>
<span class="fc" id="L4436">                        int x = pixIdx - (y * w);</span>
<span class="fc bfc" id="L4437" title="All 2 branches covered.">                        if (allArePresent(pixIdxs, x, y, tmpC, w, h)</span>
<span class="fc bfc" id="L4438" title="All 2 branches covered.">                            &amp;&amp; allAreNotPresent(pixIdxs, x, y, tmpD, w, h)) {</span>
<span class="fc bfc" id="L4439" title="All 2 branches covered.">                            if (!ImageSegmentation.doesDisconnect(pixIdxs,</span>
                                neighborCoordOffsets, x, y, w, h)) {

                                // number of neighbors that are not '1s
<span class="fc" id="L4443">                                int nn = 0;</span>
<span class="fc bfc" id="L4444" title="All 2 branches covered.">                                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L4445">                                    int x2 = x + dxs[k];</span>
<span class="fc" id="L4446">                                    int y2 = y + dys[k];</span>
<span class="pc bpc" id="L4447" title="4 of 8 branches missed.">                                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="nc" id="L4448">                                        continue;</span>
                                    }
<span class="fc" id="L4450">                                    int pixIdx2 = (y2 * w) + x2;</span>
<span class="fc bfc" id="L4451" title="All 2 branches covered.">                                    if (pixIdxs.contains(pixIdx2)) {</span>
<span class="fc" id="L4452">                                        nn++;</span>
                                    }
                                }

                                //long key = 8 - nn;
<span class="fc" id="L4457">                                long key = nn;</span>
<span class="fc" id="L4458">                                HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L4459">                                node.setData(Integer.valueOf(pixIdx));</span>
<span class="fc" id="L4460">                                heap.insert(node);</span>
                            }
                        }
<span class="fc" id="L4463">                    }</span>

<span class="fc bfc" id="L4465" title="All 2 branches covered.">                    while (heap.getNumberOfNodes() &gt; 0) {</span>

<span class="fc" id="L4467">                        HeapNode node = heap.extractMin();</span>

<span class="pc bnc" id="L4469" title="All 2 branches missed.">                        assert(node != null);</span>

<span class="fc" id="L4471">                        int pixIdx = ((Integer)node.getData()).intValue();</span>
<span class="fc" id="L4472">                        int y = pixIdx/w;</span>
<span class="fc" id="L4473">                        int x = pixIdx - (y * w);</span>

<span class="pc bpc" id="L4475" title="1 of 2 branches missed.">                        if (allArePresent(pixIdxs, x, y, tmpC, w, h)</span>
<span class="pc bpc" id="L4476" title="1 of 2 branches missed.">                            &amp;&amp; allAreNotPresent(pixIdxs, x, y, tmpD, w, h)) {</span>
<span class="pc bpc" id="L4477" title="1 of 2 branches missed.">                            if (!ImageSegmentation.doesDisconnect(pixIdxs,</span>
                                neighborCoordOffsets, x, y, w, h)) {

<span class="fc" id="L4480">                                pixIdxs.remove(pixIdx);</span>
<span class="fc" id="L4481">                                nEdited++;</span>
                            }
                        }
<span class="fc" id="L4484">                    }</span>
                }
            }
<span class="fc" id="L4487">            nIter++;</span>
<span class="fc bfc" id="L4488" title="All 2 branches covered.">        } while (nEdited &gt; 0);</span>
<span class="fc" id="L4489">    }</span>

    private void rotatePairsBy90(int[] xy) {

        /*
        int cos90 = 0;
        int sin90 = 1;
        scale = 1
        xc = yc = 0
        rotX = - (xc*scale + (((x0-xc)*scale*math.cos(theta))
                 + ((y0-yc)*scale*math.sin(theta)))
               = - (0 + (y0-0))
               = -y0

        rotY = - (yc*scale + ((-(x0-xc)*scale*math.sin(theta))
                 + ((y0-yc)*scale*math.cos(theta)))
               = - (0 + ((-(x0-0)))
               = +x0
        */

<span class="fc bfc" id="L4509" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.length; i += 2) {</span>
<span class="fc" id="L4510">            int x = xy[i];</span>
<span class="fc" id="L4511">            int y = xy[i + 1];</span>
<span class="fc" id="L4512">            xy[i] = -y;</span>
<span class="fc" id="L4513">            xy[i + 1] = x;</span>
        }
<span class="fc" id="L4515">    }</span>

    private boolean allArePresent(TIntSet pixIdxs, int x, int y, int[] xy,
        int imgWidth, int imgHeight) {

<span class="fc bfc" id="L4520" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L4521">            int tx = x + xy[k];</span>
<span class="fc" id="L4522">            int ty = y + xy[k + 1];</span>
<span class="pc bpc" id="L4523" title="2 of 8 branches missed.">            if (tx &lt; 0 || ty &lt; 0 || (tx &gt; (imgWidth - 1)) || (ty &gt; (imgHeight - 1))) {</span>
<span class="fc" id="L4524">                continue;</span>
            }
<span class="fc" id="L4526">            int pixIdx2 = (ty * imgWidth) + tx;</span>
<span class="fc bfc" id="L4527" title="All 2 branches covered.">            if (!pixIdxs.contains(pixIdx2)) {</span>
<span class="fc" id="L4528">                return false;</span>
            }
        }

<span class="fc" id="L4532">        return true;</span>
    }

    private boolean allArePresent(GreyscaleImage img, int x, int y, int[] xy) {

<span class="fc bfc" id="L4537" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L4538">            int tx = x + xy[k];</span>
<span class="fc" id="L4539">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L4540" title="All 2 branches covered.">            if (img.getValue(tx, ty) == 0) {</span>
<span class="fc" id="L4541">                return false;</span>
            }
        }

<span class="fc" id="L4545">        return true;</span>
    }

    private boolean allArePresent(Set&lt;PairInt&gt; points, int x, int y, int[] xy) {

<span class="fc bfc" id="L4550" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L4551">            int tx = x + xy[k];</span>
<span class="fc" id="L4552">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L4553" title="All 2 branches covered.">            if (!points.contains(new PairInt(tx, ty))) {</span>
<span class="fc" id="L4554">                return false;</span>
            }
        }

<span class="fc" id="L4558">        return true;</span>
    }

    private boolean allAreNotPresent(GreyscaleImage img, int x, int y, int[] xy) {

<span class="fc bfc" id="L4563" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L4564">            int tx = x + xy[k];</span>
<span class="fc" id="L4565">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L4566" title="All 2 branches covered.">            if (img.getValue(tx, ty) != 0) {</span>
<span class="fc" id="L4567">                return false;</span>
            }
        }

<span class="fc" id="L4571">        return true;</span>
    }

    private boolean allAreNotPresent(Set&lt;PairInt&gt; points, int x, int y, int[] xy) {

<span class="fc bfc" id="L4576" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L4577">            int tx = x + xy[k];</span>
<span class="fc" id="L4578">            int ty = y + xy[k + 1];</span>
<span class="fc bfc" id="L4579" title="All 2 branches covered.">            if (points.contains(new PairInt(tx, ty))) {</span>
<span class="fc" id="L4580">                return false;</span>
            }
        }

<span class="fc" id="L4584">        return true;</span>
    }

    private boolean allAreNotPresent(TIntSet pixIdxs, int x, int y, int[] xy,
        int imgWidth, int imgHeight) {

<span class="fc bfc" id="L4590" title="All 2 branches covered.">        for (int k = 0; k &lt; xy.length; k += 2) {</span>
<span class="fc" id="L4591">            int tx = x + xy[k];</span>
<span class="fc" id="L4592">            int ty = y + xy[k + 1];</span>
<span class="pc bpc" id="L4593" title="2 of 8 branches missed.">            if (tx &lt; 0 || ty &lt; 0 || (tx &gt; (imgWidth - 1)) || (ty &gt; (imgHeight - 1))) {</span>
<span class="fc" id="L4594">                continue;</span>
            }
<span class="fc" id="L4596">            int pixIdx2 = (ty * imgWidth) + tx;</span>
<span class="fc bfc" id="L4597" title="All 2 branches covered.">            if (pixIdxs.contains(pixIdx2)) {</span>
<span class="fc" id="L4598">                return false;</span>
            }
        }

<span class="fc" id="L4602">        return true;</span>
    }

    /**
     * NOTE: this is not the same as the scale space image
     * or inflection points in the scaleSpace package.
     * It is a very quick look at the position derivatives.
     *
     * create a two dimensional row-major format array of curvature of the
     * image img.  Note that img is expected to have all values &gt;= 0.
     * Also note that sigma should be equal to or greater than
     * sqrt(2)/2.
     * @param img
     * @param sigma
     * @return
     */
    public float[][] createCurvatureImage(GreyscaleImage img, float sigma) {

        /* curvature:
               dot is the degree of derivative...see ScaleSpaceCurvature
                      X_dot(t,o~) * Y_dot_dot(t,o~) - Y_dot(t,o~) * X_dot_dot(t,o~)
            k(t,o~) = -------------------------------------------------------------
                                   (X_dot^2(t,o~) + Y_dot^2(t,o~))^1.5
        */

<span class="nc" id="L4627">        float max = img.max();</span>

<span class="nc bnc" id="L4629" title="All 2 branches missed.">        if (max &lt;= 0) {</span>
<span class="nc" id="L4630">            throw new IllegalArgumentException(&quot;img values must be&quot;</span>
                + &quot; &gt;= 0 and maximum must be &gt; 0&quot;);
        }

        // -- switch to row-major ----
<span class="nc" id="L4635">        float[][] image = multiply(img, 1.f/max);</span>

<span class="nc bnc" id="L4637" title="All 2 branches missed.">        assert(image.length == img.getHeight());</span>
<span class="nc bnc" id="L4638" title="All 2 branches missed.">        assert(image[0].length == img.getWidth());</span>

<span class="nc" id="L4640">        return createCurvatureImage(image, sigma);</span>
    }

    /**
     * NOTE: this is not the same as the scale space image
     * or inflection points in the scaleSpace package.
     * It is a very quick look at the position derivatives.
     *
     * create a two dimensional row-major format array of curvature of the
     * image img.  Note that img is expected to have all values &gt;= 0.
     * Also note that sigma should be equal to or greater than
     * sqrt(2)/2.
     * @param image row-major formatted image
     * @param sigma
     * @return
     */
    public float[][] createCurvatureImage(float[][] image, float sigma) {

        /* curvature:
               dot is the degree of derivative...see ScaleSpaceCurvature
                      X_dot(t,o~) * Y_dot_dot(t,o~) - Y_dot(t,o~) * X_dot_dot(t,o~)
            k(t,o~) = -------------------------------------------------------------
                                   (X_dot^2(t,o~) + Y_dot^2(t,o~))^1.5
        */

        // --- create 1st derivatives (gaussian 1st deriv sqrt(2)/2 = 0.707)----

        // switch X and Y 1st deriv operations for row major

<span class="fc" id="L4669">        TwoDFloatArray[] components =</span>
<span class="fc" id="L4670">            createCurvatureComponents(image, sigma);</span>

<span class="fc" id="L4672">        float[][] gX = components[0].a;</span>
<span class="fc" id="L4673">        float[][] gY = components[1].a;</span>
<span class="fc" id="L4674">        float[][] gX2 = components[2].a;</span>
<span class="fc" id="L4675">        float[][] gY2 = components[3].a;</span>

<span class="fc" id="L4677">        int nRows = gX.length;</span>
<span class="fc" id="L4678">        int nCols = gX[0].length;</span>

<span class="fc" id="L4680">        float[][] curvature = copy(gX);</span>
<span class="fc bfc" id="L4681" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L4682" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>

<span class="fc" id="L4684">                float gX2gX2 = gX2[i][j] * gX2[i][j];</span>
<span class="fc" id="L4685">                float gY2gY2 = gY2[i][j] * gY2[i][j];</span>
<span class="pc bpc" id="L4686" title="1 of 4 branches missed.">                if (gX2gX2 == 0 &amp;&amp; gY2gY2 == 0) {</span>
<span class="fc" id="L4687">                    curvature[i][j] = Float.MAX_VALUE;</span>
<span class="fc" id="L4688">                    continue;</span>
                }
                //(dx * dy(dy) - dy * dx(dx)) / (dx(dx)*dx(dx) + dy(dy)*dy(dy))
<span class="fc" id="L4691">                curvature[i][j] = (float)(</span>
                    (gX[i][j] * gY2[i][j] - gY[i][j] * gX2[i][j])
<span class="fc" id="L4693">                    / Math.pow((gX2gX2 + gY2gY2), 1.5));</span>
            }
        }

<span class="fc" id="L4697">        return curvature;</span>
    }


    /**
     * create an image segmented by curvature zero-crossings.
     * calculates the curvature in O(N_pixels) but using transcendental
     * operations, and then sets the output to 255 where curvature is
     * greater than 0 and sets output to 0 where curvature is less than 0.
     * the &quot;zeroHandling&quot; parameter determines how curvature exact values
     * of 0 are handled.
     * for zeroHandling = 0, curvature equal to zero sets output to 1;
     * for zeroHandling = 1, curvature equal to zero sets output to 0;
     * for zeroHandling = 2, curvature equal to zero sets output to 255.
     *
     * This method is used in MedialAxis1.java.
     *
     * @param image image in row-major format.
     * @param sigma (note, the internal first derivative, first step is
     * sigma=sqrt(2)/2 so this given sigma should be that or larger.
     * @param zeroHandling allowed values are 0, 1, or 2.
     * 0 = set curvature exact zero values to value 1,
     * 1 = set curvature exact zero values to value 0,
     * 2 = set curvature exact zero values to value 255.
     * @return
     */
    public GreyscaleImage createZeroCrossingsCurvature(float[][] image,
        float sigma, int zeroHandling) {

<span class="pc bpc" id="L4726" title="2 of 4 branches missed.">        if ((zeroHandling &lt; 0) || (zeroHandling &gt; 2)) {</span>
<span class="nc" id="L4727">            throw new IllegalArgumentException(&quot;zeroHandling must be &quot;</span>
                + &quot;between 0 and 2, inclusive.&quot;);
        }

        // -- switch to row-major until output ----
<span class="fc" id="L4732">        float[][] curvature = createCurvatureImage(image, sigma);</span>

<span class="fc" id="L4734">        return createZeroCrossingsCurvatureImage(curvature, zeroHandling);</span>
    }

    /**
     * * NOTE: this is not the same as the scale space image
     * or inflection points in the scaleSpace package.
     * It is a very quick look at the position derivative
     * zero crossings.
     *
     * create an image segmented by curvature zero-crossings.
     * calculates the curvature in O(N_pixels) but using transcendental
     * operations, and then sets the output to 255 where curvature is
     * greater than 0 and sets output to 0 where curvature is less than 0.
     * the &quot;zeroHandling&quot; parameter determines how curvature exact values
     * of 0 are handled.
     * for zeroHandling = 0, curvature equal to zero sets output to 1;
     * for zeroHandling = 1, curvature equal to zero sets output to 0;
     * for zeroHandling = 2, curvature equal to zero sets output to 255.
     *
     * This method is used in MedialAxis1.java.
     *
     * @param img
     * @param sigma (note, the internal first derivative, first step is
     * sigma=sqrt(2)/2 so this given sigma should be that or larger.
     * @param zeroHandling allowed values are 0, 1, or 2.
     * 0 = set curvature exact zero values to value 1,
     * 1 = set curvature exact zero values to value 0,
     * 2 = set curvature exact zero values to value 255.
     * @return
     */
    public GreyscaleImage createZeroCrossingsCurvature(GreyscaleImage img,
        float sigma, int zeroHandling) {

<span class="nc bnc" id="L4767" title="All 4 branches missed.">        if ((zeroHandling &lt; 0) || (zeroHandling &gt; 2)) {</span>
<span class="nc" id="L4768">            throw new IllegalArgumentException(&quot;zeroHandling must be &quot;</span>
                + &quot;between 0 and 2, inclusive.&quot;);
        }

        // -- switch to row-major until output ----
<span class="nc" id="L4773">        float[][] curvature = createCurvatureImage(img, sigma);</span>

<span class="nc" id="L4775">        return createZeroCrossingsCurvatureImage(curvature, zeroHandling);</span>
    }

    /**
     * create an image segmented by curvature zero-crossings.
     * calculates the curvature in O(N_pixels) but using transcendental
     * operations, and then sets the output to 255 where curvature is
     * greater than 0 and sets output to 0 where curvature is less than 0.
     * the &quot;zeroHandling&quot; parameter determines how curvature exact values
     * of 0 are handled.
     * for zeroHandling = 0, curvature equal to zero sets output to 1;
     * for zeroHandling = 1, curvature equal to zero sets output to 0;
     * for zeroHandling = 2, curvature equal to zero sets output to 255.
     *
     * This method is used in MedialAxis1.java.
     *
     * @param curvature
     * @param zeroHandling allowed values are 0, 1, or 2.
     * 0 = set curvature exact zero values to value 0,
     * 1 = set curvature exact zero values to value 1,
     * 2 = set curvature exact zero values to value 255.
     * @return
     */
    private GreyscaleImage createZeroCrossingsCurvatureImage(float[][] curvature,
        int zeroHandling) {

<span class="pc bpc" id="L4801" title="2 of 4 branches missed.">        if ((zeroHandling &lt; 0) || (zeroHandling &gt; 2)) {</span>
<span class="nc" id="L4802">            throw new IllegalArgumentException(&quot;zeroHandling must be &quot;</span>
                + &quot;between 0 and 2, inclusive.&quot;);
        }

<span class="fc" id="L4806">        int nRows = curvature.length;</span>
<span class="fc" id="L4807">        int nCols = curvature[0].length;</span>

<span class="fc" id="L4809">        GreyscaleImage out = new GreyscaleImage(nCols, nRows);</span>

<span class="fc bfc" id="L4811" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L4812" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc" id="L4813">                float v = curvature[i][j];</span>
<span class="fc bfc" id="L4814" title="All 2 branches covered.">                if (v &gt; 0) {</span>
<span class="fc" id="L4815">                    out.setValue(j, i, 255);</span>
<span class="fc bfc" id="L4816" title="All 2 branches covered.">                } else if (v == 0) {</span>
<span class="pc bpc" id="L4817" title="2 of 3 branches missed.">                    switch(zeroHandling) {</span>
                        case 0:
<span class="nc" id="L4819">                            out.setValue(j, i, 0);</span>
<span class="nc" id="L4820">                            break;</span>
                        case 1:
<span class="nc" id="L4822">                            out.setValue(j, i, 1);</span>
<span class="nc" id="L4823">                            break;</span>
                        default:
<span class="fc" id="L4825">                            out.setValue(j, i, 255);</span>
<span class="fc" id="L4826">                            break;</span>
                    }
                } else {
<span class="fc" id="L4829">                    out.setValue(j, i, 0);</span>
                }
            }
        }

<span class="fc" id="L4834">        return out;</span>
    }

    /**
     * create texture transforms from
     * &quot;Textured Image Segmentation&quot; by Laws, 1980.
     *
     * The transforms are combinations of filters based on
     *  L5 level = [1 4 6 4 1]
             gaussian, binomial for sigma=1
             B3 spline function, used in ATrous wavelet
        E5 edge  = [-1 -2 0 2 1]
             1st deriv of gaussian, binomial for sigma=1
        S5 spot =   [-1 0 2 0 -1]
             -1 times 2nd deriv binomial for sigma=sqrt(2)/2,... LOG
        R5 ripple = [1 -4 6 -4 1]
              3rd deriv gaussian, ...Gabor

     NOTE: bright clumps in R5 R5 look useful for finding vegetation.
        It finds the bounds of the vegetation... places where the
        the change of the change of the gradient is large (and dense).
        can apply adaptive means to the feature image to find the
        brightest of these.
        L5 S5 looks useful for finding horizontal lines such as edge segments
        of windows.

     * @param img
       @param state 0=do not process derivatives further,
       1=subtract mean, 2=subtract mean and square to make variance,
       3=make zero mean, unit standard derivative, but multiplied by
       255 to put into integer range for result.
     * @return textureTransforms
       GreyscaleImage[]{
       L5E5/E5L5, L5S5/S5L5, L5R5/R5L5, E5E5.
       E5S5/S5E5, E5R5/R5E5, S5S5, S5R5/R5S5,
       R5R5}
     */
    public Map&lt;String, GreyscaleImage&gt; createTextureTransforms(
        GreyscaleImage img, int state) {

<span class="pc bpc" id="L4874" title="2 of 4 branches missed.">        if (state &lt; 0 || state &gt; 3) {</span>
<span class="nc" id="L4875">            throw new IllegalArgumentException(&quot;state must be between&quot;</span>
                + &quot;0 and 3, inclusive&quot;);
        }

        /*
        adapted from a cs lecture on texture filters from uw
        (https://courses.cs.washington.edu/courses/cse455/09wi/Lects/lect12.pdf
        which possibly uses:
        &quot;Statistical Texture Analysis&quot; by Srinivasan and Shobha 2008)

        Both contain content from &quot;Textured Image Segmentation&quot; by Laws, 1980.

        filters:
            L5 level = [1 4 6 4 1]
                 gaussian, binomial for sigma=1
                 B3 spline function, used in ATrous wavelet
            E5 edge  = [-1 -2 0 2 1]
                 1st deriv of gaussian, binomial for sigma=1
            S5 spot =   [-1 0 2 0 -1]
                 -1 times 2nd deriv binomial for sigma=sqrt(2)/2; a.k.a. LOG
            R5 ripple = [1 -4 6 -4 1]
                  3rd deriv gaussian, a.k.a. Gabor
            W5 waves = [-1, 2, 0, -2, -1]

        - the 2D masks are created by multiplying the 1D masks to make a 5x5 matrix
              E5 X L5 = -1 -4 -6 -4 -1
                        -2 -8 -12 -8 -1
                         0  0  0  0   0
                         2  8  12  8  1
                         1  4  6   4  1
        - there are 9 feature vectors one could make.  can see that some compose
          tensors, and different keypoint algorithms.

        there are 9 feature vectors one could make.
          created by subtracting the mean neighborhood intensity from pixel
             filter the neighborhood with the 16 5 x 5 masks
             then energy at each pixel is summing abs value of filter output
                across neighbor region and storing result for the center pixel.
          The 9 features made from those 16 combinations of 4 filters are:
              L5L5, L5E5/E5L5, L5S5/S5L5, L5R5/R5L5, E5E5.
              E5S5/S5E5, E5R5/R5E5, S5S5, S5R5/R5S5,
              R5R5
        */

<span class="fc" id="L4919">        float[] kernelL5 = new float[]{ 1,  4, 6, 4, 1};</span>
<span class="fc" id="L4920">        float[] kernelE5 = new float[]{-1, -2, 0, 2, 1};</span>
<span class="fc" id="L4921">        float[] kernelS5 = new float[]{-1,  0, 2, 0, -1};</span>
<span class="fc" id="L4922">        float[] kernelR5 = new float[]{ 1, -4, 6, -4, 1};</span>
<span class="fc" id="L4923">        float[][] kernels = new float[4][];</span>
<span class="fc" id="L4924">        kernels[0] = kernelL5;</span>
<span class="fc" id="L4925">        kernels[1] = kernelE5;</span>
<span class="fc" id="L4926">        kernels[2] = kernelS5;</span>
<span class="fc" id="L4927">        kernels[3] = kernelR5;</span>
<span class="fc" id="L4928">        String[] labels = new String[]{&quot;L5&quot;, &quot;E5&quot;, &quot;S5&quot;, &quot;R5&quot;};</span>

<span class="fc" id="L4930">        Map&lt;String, GreyscaleImage&gt; transformed = new</span>
            HashMap&lt;String, GreyscaleImage&gt;();

<span class="fc bfc" id="L4933" title="All 2 branches covered.">        for (int dir = 0; dir &lt; 2; ++dir) {</span>
<span class="fc bfc" id="L4934" title="All 2 branches covered.">            for (int l0 = 0; l0 &lt; labels.length; ++l0) {</span>
<span class="fc bfc" id="L4935" title="All 2 branches covered.">                for (int l1 = l0; l1 &lt; labels.length; ++l1) {</span>
<span class="fc bfc" id="L4936" title="All 2 branches covered.">                    int i = (dir == 0) ? l0 : l1;</span>
<span class="fc bfc" id="L4937" title="All 2 branches covered.">                    int j = (dir == 0) ? l1 : l0;</span>
<span class="fc" id="L4938">                    float[] filter1 = kernels[i];</span>
<span class="fc bfc" id="L4939" title="All 4 branches covered.">                    if ((dir == 1) &amp;&amp; (i == j)) {</span>
<span class="fc" id="L4940">                        continue;</span>
                    }
<span class="fc" id="L4942">                    float[] filter2 = kernels[j];</span>
<span class="fc" id="L4943">                    GreyscaleImage img2 = img.copyToFullRangeIntImage();</span>
<span class="fc" id="L4944">                    applyKernel1D(img2, filter1, true);</span>
<span class="fc" id="L4945">                    applyKernel1D(img2, filter2, false);</span>

<span class="fc bfc" id="L4947" title="All 2 branches covered.">                    if (i != j) {</span>
<span class="fc" id="L4948">                        GreyscaleImage img3 = img.copyToFullRangeIntImage();</span>
<span class="fc" id="L4949">                        applyKernel1D(img3, filter2, true);</span>
<span class="fc" id="L4950">                        applyKernel1D(img3, filter1, false);</span>
<span class="fc" id="L4951">                        img2 = divide(img2, img3);</span>
                    }

<span class="fc" id="L4954">                    GreyscaleImage imgM = null;</span>

                    /*
                    0=do not process derivatives further,
                    1=subtract mean,
                    2=subtract mean and square to make variance,
                    3=make zero mean, unit standard derivative,
                      but multiplied by 255 to put into integer range for result.
                    */

<span class="pc bpc" id="L4964" title="1 of 2 branches missed.">                    if (state &gt; 0) {</span>
<span class="fc" id="L4965">                        imgM = img2.copyToFullRangeIntImage();</span>
<span class="fc" id="L4966">                        applyCenteredMean2(imgM, 2);</span>
<span class="fc" id="L4967">                        img2 = subtractImages(img2, imgM);</span>
                    }

<span class="pc bpc" id="L4970" title="1 of 2 branches missed.">                    if (state == 3) {</span>
                        // make unit standard deviation image, but mult by 255
                        // for storage in integer.
                        // NOTE: considering change of output to float array for
                        // comparison to databases
<span class="nc bnc" id="L4975" title="All 2 branches missed.">                        for (int ii = 0; ii &lt; img2.getNPixels(); ++ii) {</span>
<span class="nc" id="L4976">                            double m = imgM.getValue(ii);</span>
<span class="nc" id="L4977">                            double v = 255.*img2.getValue(ii)/(Math.sqrt(2)/m);</span>
<span class="nc" id="L4978">                            img2.setValue(ii, (int)Math.round(v));</span>
                        }
<span class="pc bpc" id="L4980" title="1 of 2 branches missed.">                    } else if (state == 2) {</span>
                        // square img2 to result in variance
<span class="fc bfc" id="L4982" title="All 2 branches covered.">                        for (int ii = 0; ii &lt; img2.getNPixels(); ++ii) {</span>
<span class="fc" id="L4983">                            int v = img2.getValue(ii);</span>
<span class="fc" id="L4984">                            v *= v;</span>
<span class="fc" id="L4985">                            img2.setValue(ii, v);</span>
                        }
                    }

<span class="fc" id="L4989">                    String label = labels[i] + labels[j];</span>

<span class="fc" id="L4991">                    transformed.put(label, img2);</span>

                    /*{
                        GreyscaleImage img3 = img2.copyImage();
                        MiscMath.rescale(img3, 0, 255);
                        MiscDebug.writeImage(img3, &quot;_&quot; + labels[i] + labels[j] + &quot;_feature_&quot;);
                        applyAdaptiveMeanThresholding(img3, 2);
                        MiscDebug.writeImage(img3, &quot;_&quot; + labels[i] + labels[j] + &quot;_feature_adap_means_&quot;);
                    }*/
                }
            }
        }

<span class="fc" id="L5004">        return transformed;</span>
    }

    public void exploreTextures() throws IOException {

        /*
        textures in frequency space:
        need to simplify the number of points contributing to the
        frequency domain pattern,
        so will calculate key points as sparse representation.
        */

<span class="fc" id="L5016">        int maxDimension = 256;//512;</span>

<span class="fc" id="L5018">        String fileName1 = &quot;android_statues_02.jpg&quot;;</span>
<span class="fc" id="L5019">        fileName1 = &quot;merton_college_I_001.jpg&quot;;</span>
<span class="fc" id="L5020">        String filePath1 = ResourceFinder.findFileInTestResources(fileName1);</span>
<span class="fc" id="L5021">        GreyscaleImage img = ImageIOHelper.readImageAsGrayScaleAvgRGB(filePath1);</span>

<span class="fc" id="L5023">        long ts = MiscDebug.getCurrentTimeFormatted();</span>

<span class="fc" id="L5025">        int w1 = img.getWidth();</span>
<span class="fc" id="L5026">        int h1 = img.getHeight();</span>

<span class="fc" id="L5028">        int binFactor1 = (int) Math.ceil(Math.max(</span>
            (float) w1 / maxDimension,
            (float) h1 / maxDimension));

<span class="fc" id="L5032">        img = binImage(img, binFactor1);</span>

<span class="fc" id="L5034">        float max = img.max();</span>

<span class="pc bpc" id="L5036" title="1 of 2 branches missed.">        if (max &lt;= 0) {</span>
<span class="nc" id="L5037">            throw new IllegalArgumentException(&quot;img values must be&quot;</span>
                + &quot; &gt;= 0 and maximum must be &gt; 0&quot;);
        }
        
<span class="fc" id="L5041">        blur(img, SIGMA.ONE);</span>

<span class="fc" id="L5043">        int nRows = img.getHeight();</span>
<span class="fc" id="L5044">        int nCols = img.getWidth();</span>

        // axis 0 coordinates
<span class="fc" id="L5047">        TIntList keypoints0 = new TIntArrayList();</span>

        // axis 1 coordinates
<span class="fc" id="L5050">        TIntList keypoints1 = new TIntArrayList();</span>

        /*ORB orb = new ORB(10000);
        orb.overrideToNotCreateDescriptors();
        orb.overrideToAlsoCreate1stDerivKeypoints();
        //orb.overrideToCreateCurvaturePoints();
        orb.detectAndExtract(img.copyToColorGreyscale());
        keypoints0.addAll(orb.getAllKeyPoints0());
        keypoints1.addAll(orb.getAllKeyPoints1());
        */

<span class="fc" id="L5061">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
<span class="fc" id="L5062">        EdgeFilterProducts products = imageSegmentation.createGradient(</span>
<span class="fc" id="L5063">            img.copyToColorGreyscaleExt(), 2, ts);</span>

<span class="fc" id="L5065">        GreyscaleImage gradient = products.getGradientXY();</span>

<span class="fc" id="L5067">        float sigma = SIGMA.getValue(SIGMA.ZEROPOINTSEVENONE);</span>

        // -- switch to row-major ----
<span class="fc" id="L5070">        float[][] image = multiply(img, 1.f/max);</span>

        //  strong high density responses in r5r5 for edges of vegetation.
        //  textures such as bricks or roof tiles are present in r5r5
        //  but so are strong edges, so possibly need
        //  to use the gradient edges here to distinguish between
        //  corner and the numerous points that are not good matching
        //  points.

        // thresh is usually 0.01f
        //createCurvatureKeyPoints(image, sigma, keypoints0, keypoints1,
        //   0.001f);

<span class="fc" id="L5083">        createR5R5KeyPoints(image, keypoints0, keypoints1);</span>
        //createE5E5KeyPoints(image, keypoints0, keypoints1);
        //createL5E5KeyPoints(image, keypoints0, keypoints1);
        //createS5S5KeyPoints(image, keypoints0, keypoints1);
        //createFirstDerivKeyPoints(image, sigma, keypoints0, keypoints1);

        //Image kpImg = img.copyToColorGreyscale();
<span class="fc" id="L5090">        Image kpImg = gradient.copyToColorGreyscale();</span>
<span class="fc bfc" id="L5091" title="All 2 branches covered.">        for (int i = 0; i &lt; keypoints0.size(); ++i) {</span>
<span class="fc" id="L5092">            int x = keypoints1.get(i);</span>
<span class="fc" id="L5093">            int y = keypoints0.get(i);</span>
<span class="fc" id="L5094">            kpImg.setRGB(x, y, 255, 0, 0);</span>
        }
<span class="fc" id="L5096">        MiscDebug.writeImage(kpImg, &quot;_keypoints_1_&quot;);</span>

        /*
        Complex1D[] ccOut = create2DFFT2WithSwapMajor(kpImg, true);

        assert(nRows == ccOut[0].x.length);
        assert(nCols == ccOut.length);

        double[][] kpFreqR = new double[nCols][];
        double[][] kpFreqI = new double[nCols][];
        for (int i0 = 0; i0 &lt; ccOut.length; ++i0) {
            kpFreqR[i0] = new double[nRows];
            kpFreqI[i0] = new double[nRows];
            for (int i1 = 0; i1 &lt; nRows; ++i1) {
                kpFreqR[i0][i1] = ccOut[i0].x[i1];
                kpFreqI[i0][i1] = ccOut[i0].y[i1];
            }
        }

        TIntList plotRows = new TIntArrayList();
        TIntList plotCols = new TIntArrayList();
        plotRows.add(10);
        plotRows.add(50);
        plotRows.add(100);
        plotRows.add(110);

        plotCols.add(10);
        plotCols.add(50);
        plotCols.add(100);
        plotCols.add(150);
        plotCols.add(200);
        plotCols.add(210);

        String lbl = &quot;keypoints_freq&quot;;

        MiscDebug.plot(kpFreqR, plotCols, plotRows, lbl);

        MiscMath.applyRescale(kpFreqR, 0, 255);
        Image kpFreqRImg = img.copyToColorGreyscale();
        for (int i = 0; i &lt; nCols; ++i) {
            for (int j = 0; j &lt; nRows; ++j) {
                kpFreqRImg.setRGB(i, j, (int)Math.round(kpFreqR[i][j]), 0, 0);
            }
        }
        MiscDebug.writeImage(kpFreqRImg, &quot;_keypoints_freq_&quot;);
        */

   /*
        // ---- edited _keypoints_1_ image to keep only a characteristic section ---
        String filePath = ResourceFinder.findFileInTestResources(
            &quot;vegetation_peak_texture.png&quot;);

        GreyscaleImage imgPattern = ImageIOHelper.readImage(
            filePath).copyToGreyscale();

        Complex[][] fftPattern = PhaseCongruencyDetector
            .createLowPassFreqDomainFilter(imgPattern);

        PeriodicFFT perfft2 = new PeriodicFFT();
        Complex[][][] perfResults = perfft2.perfft2(img, false);
        Complex[][] fftImage = perfResults[1];

        // --- image in the frequency domain convolved with texture patch ----
        Complex[][] freqDomainImageTimesPattern =
            convolveWithKernel(fftImage, fftPattern);

        // ----- transform that to spatial domain ----
        Complex[][] fComplex = create2DFFT(freqDomainImageTimesPattern, false, false);
        double[][] transformedReal = new double[nCols][];
        for (int i0 = 0; i0 &lt; nCols; ++i0) {
            transformedReal[i0] = new double[nRows];
            for (int i1 = 0; i1 &lt; nRows; ++i1) {
                transformedReal[i0][i1] = fComplex[i1][i0].abs();
            }
        }

        MiscMath.applyRescale(transformedReal, 0, 255);
        GreyscaleImage kpFreqR2Img = new GreyscaleImage(nCols, nRows);
        for (int i = 0; i &lt; nCols; ++i) {
            for (int j = 0; j &lt; nRows; ++j) {
                kpFreqR2Img.setValue(i, j,
                    (int)Math.round(transformedReal[i][j]));
            }
        }
        MiscDebug.writeImage(kpFreqR2Img, &quot;_keypoints_freq2_spatial_&quot;);
    */
<span class="fc" id="L5182">    }</span>

    /**
     *
     * @param image
     * @param sigma
     * @param outputKeypoints0
     * @param outputKeypoints1
     * @param thresholdRel default is 0.01f
     */
    public void createCurvatureKeyPoints(float[][] image, float sigma,
        TIntList outputKeypoints0, TIntList outputKeypoints1,
        float thresholdRel) {

<span class="nc" id="L5196">        boolean doCreateCurvatureKeyPoints = true;</span>

<span class="nc" id="L5198">        StructureTensor tensorComponents = new StructureTensor(image,</span>
            sigma, doCreateCurvatureKeyPoints);

<span class="nc" id="L5201">        createCurvatureKeyPoints(tensorComponents, outputKeypoints0,</span>
            outputKeypoints1, thresholdRel);
<span class="nc" id="L5203">    }</span>

    /**
     *
     * @param tensorComponents
     * @param outputKeypoints0
     * @param outputKeypoints1
     * @param thresholdRel default is 0.01f
     */
    public void createCurvatureKeyPoints(StructureTensor tensorComponents,
        TIntList outputKeypoints0, TIntList outputKeypoints1,
        float thresholdRel) {

        // square of 1st deriv:
        //float[][] firstDeriv = add(tensorComponents.getDXSquared(),
        //    tensorComponents.getDYSquared());
        //float max1stDeriv = MiscMath.findMax(firstDeriv);
        //float f = max1stDeriv / 10;

<span class="nc" id="L5222">        float[][] dx = tensorComponents.getDX();</span>
<span class="nc" id="L5223">        float[][] dx2 = tensorComponents.getDDX();</span>
<span class="nc" id="L5224">        float[][] dy = tensorComponents.getDY();</span>
<span class="nc" id="L5225">        float[][] dy2 = tensorComponents.getDDY();</span>
<span class="nc" id="L5226">        float[][] curvature = copy(dx);</span>

<span class="nc" id="L5228">        int nRows = dx.length;</span>
<span class="nc" id="L5229">        int nCols = dx[0].length;</span>

<span class="nc bnc" id="L5231" title="All 2 branches missed.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="nc bnc" id="L5232" title="All 2 branches missed.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="nc" id="L5233">                float dx2dx2 = dx2[i][j] * dx2[i][j];</span>
<span class="nc" id="L5234">                float dy2dy2 = dy2[i][j] * dy2[i][j];</span>
<span class="nc bnc" id="L5235" title="All 4 branches missed.">                if (dx2dx2 == 0 &amp;&amp; dy2dy2 == 0) {</span>
<span class="nc" id="L5236">                    curvature[i][j] = Float.MAX_VALUE;</span>
<span class="nc" id="L5237">                    continue;</span>
                }
                //(dx * dy(dy) - dy * dx(dx)) / (dx(dx)*dx(dx) + dy(dy)*dy(dy))^1.5
<span class="nc" id="L5240">                curvature[i][j] = (</span>
                    (dx[i][j] * dy2[i][j] - dy[i][j] * dx2[i][j])
                    / (dx2dx2 + dy2dy2));
                    /// Math.pow((dx2dx2 + dy2dy2), 1.5));
            }
        }

<span class="nc" id="L5247">        peakLocalMax(curvature, 1, thresholdRel, true,</span>
            outputKeypoints0,
            outputKeypoints1);

        /*{// DEBUG
            float[][] a = copy(curvature);
            System.out.println(&quot;min=&quot; + MiscMath.findMin(a) + &quot; max=&quot; + MiscMath.findMax(a));
            MiscMath.applyAbsoluteValue(a);
            MiscMath.applyRescale(a, 0, 255);
            MiscDebug.writeImage(a, &quot;_curvature_&quot;
                + MiscDebug.getCurrentTimeFormatted());
        }*/

        /*MiscMath.applyRescale(curvature, 0, 255);
        GreyscaleImage kpImg = new GreyscaleImage(nCols, nRows);
        for (int i = 0; i &lt; outputKeypoints0.size(); ++i) {
            int x = outputKeypoints1.get(i);
            int y = outputKeypoints0.get(i);
            kpImg.setValue(x, y, Math.round(curvature[y][x]));
        }
        MiscDebug.writeImage(kpImg, &quot;_curvature_&quot;);
        */
<span class="nc" id="L5269">    }</span>

    public void createR5R5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

        //3rd deriv gaussian, a.k.a. Gabor
<span class="fc" id="L5275">        float[] kernel = new float[]{ 1, -4, 6, -4, 1};</span>

<span class="fc" id="L5277">        createLawKeyPoints(image, kernel, kernel, outputKeypoints0,</span>
            outputKeypoints1);
<span class="fc" id="L5279">    }</span>

    public void createS5S5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

        //-1 times 2nd deriv binomial for sigma=sqrt(2)/2; a.k.a. LOG
<span class="nc" id="L5285">        float[] kernel = new float[]{-1, 0, 2, 0, -1};</span>

<span class="nc" id="L5287">        createLawKeyPoints(image, kernel, kernel, outputKeypoints0,</span>
            outputKeypoints1);
<span class="nc" id="L5289">    }</span>

    public void createE5E5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

        //1st deriv of gaussian, binomial for sigma=1
<span class="nc" id="L5295">        float[] kernel = new float[]{-1, -2, 0, 2, 1};</span>

<span class="nc" id="L5297">        createLawKeyPoints(image, kernel, kernel, outputKeypoints0,</span>
            outputKeypoints1);
<span class="nc" id="L5299">    }</span>

    public void createL5E5KeyPoints(float[][] image,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

        //1st deriv of gaussian, binomial for sigma=1
<span class="nc" id="L5305">        float[] kernelE5 = new float[]{-1, -2, 0, 2, 1};</span>

        // gaussian, binomial for sigma=1; B3 spline used in ATrous wavelet
<span class="nc" id="L5308">        float[] kernelL5 = new float[]{1, 4, 6, 4, 1};</span>

<span class="nc" id="L5310">        createLawKeyPoints(image, kernelL5, kernelE5, outputKeypoints0,</span>
            outputKeypoints1);
<span class="nc" id="L5312">    }</span>

    private void createLawKeyPoints(float[][] image, float[] kernel1,
        float[] kernel2,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {

<span class="fc" id="L5318">        float[][] image2 = copy(image);</span>

        // row major, so need to use y operations for x and vice versa
<span class="fc" id="L5321">        applyKernel1D(image2, kernel1, true);</span>
<span class="fc" id="L5322">        applyKernel1D(image2, kernel2, false);</span>

        /*if (!Arrays.equals(kernel1, kernel2)) {
            float[][] image3 = copy(image2);
            applyKernel1D(image3, kernel1, false);
            applyKernel1D(image3, kernel2, true);
            image2 = divide(image2, image3);
        }*/

        // put float back into integer scale, 0 to 255
<span class="fc" id="L5332">        MiscMath.applyRescale2(image2, 0, 255);</span>

<span class="fc" id="L5334">        int nCols = image2.length;</span>
<span class="fc" id="L5335">        int nRows = image2[0].length;</span>

<span class="fc" id="L5337">        GreyscaleImage imageM = new GreyscaleImage(nCols, nRows);</span>
<span class="fc bfc" id="L5338" title="All 2 branches covered.">        for (int i = 0; i &lt; nCols; ++i) {</span>
<span class="fc bfc" id="L5339" title="All 2 branches covered.">            for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc" id="L5340">                imageM.setValue(i, j, Math.round(image2[i][j]));</span>
            }
        }

<span class="fc" id="L5344">        applyCenteredMean2(imageM, 2);</span>

        // subtract mean
<span class="fc bfc" id="L5347" title="All 2 branches covered.">        for (int i = 0; i &lt; nCols; ++i) {</span>
<span class="fc bfc" id="L5348" title="All 2 branches covered.">            for (int j = 0; j &lt; nRows; ++j) {</span>
<span class="fc" id="L5349">                image2[i][j] -= imageM.getValue(i, j);</span>
            }
        }

        // NOTE: square image2 to result in variance if preferred.
<span class="fc bfc" id="L5354" title="All 2 branches covered.">        for (int i = 0; i &lt; image2.length; ++i) {</span>
<span class="fc bfc" id="L5355" title="All 2 branches covered.">            for (int j = 0; j &lt; image2[i].length; ++j) {</span>
<span class="fc" id="L5356">                float v = image2[i][j];</span>
                //v *= v;
<span class="fc" id="L5358">                image2[i][j] = v;</span>
            }
        }

<span class="fc" id="L5362">        GreyscaleImage img2 = imageM.createFullRangeIntWithDimensions();</span>
<span class="fc bfc" id="L5363" title="All 2 branches covered.">        for (int i = 0; i &lt; image2.length; ++i) {</span>
<span class="fc bfc" id="L5364" title="All 2 branches covered.">            for (int j = 0; j &lt; image2[i].length; ++j) {</span>
<span class="fc" id="L5365">                float v = image2[i][j];</span>
<span class="fc" id="L5366">                img2.setValue(i, j, Math.round(v));</span>
            }
        }

        // use adaptive means to extract centers
<span class="fc" id="L5371">        applyAdaptiveMeanThresholding(img2, 1);</span>
<span class="fc bfc" id="L5372" title="All 2 branches covered.">        for (int i = 3; i &lt; img2.getWidth(); ++i) {</span>
<span class="fc bfc" id="L5373" title="All 2 branches covered.">            for (int j = 3; j &lt; img2.getHeight(); ++j) {</span>
<span class="fc bfc" id="L5374" title="All 2 branches covered.">                if (img2.getValue(i, j) == 0) {</span>
<span class="fc" id="L5375">                    outputKeypoints0.add(i);</span>
<span class="fc" id="L5376">                    outputKeypoints1.add(j);</span>
                }
            }
        }

        // or, extract many points all over the image:
        //peakLocalMax(image2, 1, 0.01f, outputKeypoints0,
        //    outputKeypoints1);
<span class="fc" id="L5384">    }</span>

    /**
     * return first derivatives from sigma=sqrt(2)/2 and
     * then second derivatives with sigma convolved from the
     * first derivatives.
     * @param image
     * @param sigma
     * @return [d/dx, d/dy, d/dx(dx), d/dy(dy)]
     */
    protected TwoDFloatArray[] createCurvatureComponents(
        float[][] image, float sigma) {

        // --- create 1st derivatives (gaussian 1st deriv sqrt(2)/2 = 0.707)----

        // switch X and Y 1st deriv operations for row major

<span class="fc" id="L5401">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernelSigmaZeroPointFive();        </span>
        
<span class="fc" id="L5403">        float[][] gX = copy(image);</span>
<span class="fc" id="L5404">        applyKernel1D(gX, kernel, true);</span>

<span class="fc" id="L5406">        float[][] gY = copy(image);</span>
<span class="fc" id="L5407">        applyKernel1D(gY, kernel, false);</span>

        // for curvature, need d/dy(dy) and d/dx(dx)

<span class="fc" id="L5411">        float[][] gX2 = copy(gX);</span>
<span class="fc" id="L5412">        float[][] gY2 = copy(gY);</span>

        // row major, so need to use y operations for x and vice versa
<span class="fc" id="L5415">        applyKernel1D(gX2, kernel, false);</span>
<span class="fc" id="L5416">        applyKernel1D(gY2, kernel, true);</span>

<span class="fc" id="L5418">        TwoDFloatArray[] components = new TwoDFloatArray[4];</span>
<span class="fc" id="L5419">        components[0] = new TwoDFloatArray(gX);</span>
<span class="fc" id="L5420">        components[1] = new TwoDFloatArray(gY);</span>
<span class="fc" id="L5421">        components[2] = new TwoDFloatArray(gX2);</span>
<span class="fc" id="L5422">        components[3] = new TwoDFloatArray(gY2);</span>

<span class="fc" id="L5424">        return components;</span>
    }

    public GreyscaleImage divide(GreyscaleImage img1, GreyscaleImage img2) {

<span class="pc bpc" id="L5429" title="1 of 2 branches missed.">        if (img1.getNPixels() != img2.getNPixels() || img1.getWidth() !=</span>
<span class="pc bpc" id="L5430" title="2 of 4 branches missed.">            img2.getWidth() || img1.getHeight() != img2.getHeight()) {</span>
<span class="nc" id="L5431">            throw new IllegalArgumentException(&quot;img1 and img2 must be same size&quot;);</span>
        }

<span class="fc" id="L5434">        int n = img1.getNPixels();</span>

<span class="fc" id="L5436">        GreyscaleImage out = img1.copyToFullRangeIntImage();</span>

<span class="fc bfc" id="L5438" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L5439">            int v = out.getValue(i);</span>
<span class="fc" id="L5440">            int v2 = img2.getValue(i);</span>
<span class="fc bfc" id="L5441" title="All 2 branches covered.">            if (v2 &gt; 0) {</span>
<span class="fc" id="L5442">                v /= v2;</span>
            }
<span class="fc" id="L5444">            out.setValue(i, v);</span>
        }

<span class="fc" id="L5447">        return out;</span>
    }

    public float[][] copy(float[][] a) {

<span class="fc" id="L5452">        int n1 = a.length;</span>
<span class="fc" id="L5453">        int n2 = a[0].length;</span>

<span class="fc" id="L5455">        float[][] out = new float[n1][n2];</span>
<span class="fc bfc" id="L5456" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="fc" id="L5457">            out[i] = Arrays.copyOf(a[i], a[i].length);</span>
        }

<span class="fc" id="L5460">        return out;</span>
    }

    public double[][] copyToDouble(float[][] a) {

<span class="nc" id="L5465">        int n1 = a.length;</span>
<span class="nc" id="L5466">        int n2 = a[0].length;</span>

<span class="nc" id="L5468">        double[][] out = new double[n1][n2];</span>
<span class="nc bnc" id="L5469" title="All 2 branches missed.">        for (int i = 0; i &lt; n1; ++i) {</span>
<span class="nc" id="L5470">            out[i] = new double[n2];</span>
<span class="nc bnc" id="L5471" title="All 2 branches missed.">            for (int j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L5472">                out[i][j] = a[i][j];</span>
            }
        }

<span class="nc" id="L5476">        return out;</span>
    }

    /**
     * calculate Harris Corner responses for each pixel in the image then use
     * local maximum thresholding with a minimum separation between maxima, to find the peaks.
     *
     * @param img
     * @return image pairs in row major format. For example:
     *   keypoint[0] = int[]{row_i0, col_i0};
     *   keypoint[1] = int[]{row_i1, col_i1};
     *   ...
     */
    public int[][] calcHarrisCorners(double[][] img) {
<span class="fc" id="L5490">        int minDist = 1;</span>
<span class="fc" id="L5491">        float thresholdRel = 0.1f;</span>
<span class="fc" id="L5492">        boolean ignore0sInThresh = true;</span>
<span class="fc" id="L5493">        return calcHarrisCorners(img, minDist, thresholdRel, ignore0sInThresh);</span>
    }

    /**
     * calculate the Harris Corners with local max threshholding and return a stacked array of pairs
     * of (row, col) for each corner.
     * @param img
     * @param minDist
     * @param thresholdRel
     * @param ignore0sInThresh
     * @return
     */
    public static int[][] calcHarrisCorners(double[][] img, int minDist, float thresholdRel,
                                            boolean ignore0sInThresh) {

<span class="fc" id="L5508">        float sigmaBlur = 1;</span>
<span class="fc" id="L5509">        StructureTensorD tensorComponents = new</span>
                StructureTensorD(img, sigmaBlur, false);

<span class="fc" id="L5512">        double[][] detA = tensorComponents.getDeterminant();</span>

<span class="fc" id="L5514">        double[][] traceA = tensorComponents.getTrace();</span>

<span class="fc" id="L5516">        double[][] hr = ORB.cornerHarris(img);</span>

        //System.out.printf(&quot;harris response=\n%s\n&quot;, FormatArray.toString(hr, &quot;%.1f&quot;));

<span class="fc" id="L5520">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        // keypoints0 are the row numbers
<span class="fc" id="L5522">        TIntList keypoints0 = new TIntArrayList();</span>
        // keypoints1 are the column numbers
<span class="fc" id="L5524">        TIntList keypoints1 = new TIntArrayList();</span>

<span class="fc" id="L5526">        imageProcessor.peakLocalMax(MatrixUtil.convertToFloat(hr),</span>
                minDist, thresholdRel,
                ignore0sInThresh, keypoints0, keypoints1);

<span class="fc" id="L5530">        int[][] keypoints = new int[keypoints0.size()][];</span>
<span class="fc bfc" id="L5531" title="All 2 branches covered.">        for (int i = 0; i &lt; keypoints0.size(); ++i) {</span>
<span class="fc" id="L5532">            keypoints[i] = new int[]{keypoints0.get(i), keypoints1.get(i)};</span>
        }

<span class="fc" id="L5535">        return keypoints;</span>
    }
    
    public TIntSet convertPointsToIndexes(Set&lt;PairInt&gt; points, int width) {
<span class="fc" id="L5539">        TIntSet set = new TIntHashSet(points.size());</span>
<span class="fc bfc" id="L5540" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L5541">            int pixIdx = (p.getY() * width) + p.getX();</span>
<span class="fc" id="L5542">            set.add(pixIdx);</span>
<span class="fc" id="L5543">        }</span>
<span class="fc" id="L5544">        return set;</span>
    }

    public Set&lt;PairInt&gt; convertIndexesToPoints(TIntSet pixIdxs, int width) {
<span class="fc" id="L5548">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L5549">        int[] xyout = new int[2];      </span>
<span class="fc" id="L5550">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L5551">        TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L5552" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L5553">            int pixIdx = iter.next();</span>
<span class="fc" id="L5554">            ph.toPixelCoords(pixIdx, width, xyout);</span>
<span class="fc" id="L5555">            int y = xyout[1];</span>
<span class="fc" id="L5556">            int x = xyout[0];</span>
<span class="fc" id="L5557">            set.add(new PairInt(x, y));</span>
<span class="fc" id="L5558">        }</span>
<span class="fc" id="L5559">        return set;</span>
    }

    /**
     Find peaks in an image as coordinate list
     Peaks are the local maxima in a region of `2 * min_distance + 1`
     (i.e. peaks are separated by at least `min_distance`).
     If peaks are flat (i.e. multiple adjacent pixels have identical
     intensities), the coordinates of all such pixels are returned.
     If both `threshold_abs` and `threshold_rel` are provided, the maximum
     of the two is chosen as the minimum intensity threshold of peaks.

      adapted from
     https://github.com/scikit-image/scikit-image/blob/92a38515ac7222aab5e606f9de46caf5f503a7bd/skimage/feature/peak.py

     The implementation below is adapted from the scipy implementation which has
     * the following copyright:

     https://github.com/scikit-image/scikit-image/blob/master/LICENSE.txt

    -- begin scipy, skimage copyright ---
    Unless otherwise specified by LICENSE.txt files in individual
    directories, all code is

    Copyright (C) 2011, the scikit-image team
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in
        the documentation and/or other materials provided with the
        distribution.
     3. Neither the name of skimage nor the names of its contributors may be
        used to endorse or promote products derived from this software without
        specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
    -- end scipy, skimage copyright ---

    Note, in some places, scipy functions have been
    replaced with existing functions in this project in this implementation below.

    NOTE also that the method has been adapted to include a flag to treat 0's as
    masked out numbers and have made changes to handle negative numbers in the 
    image. Previously, the scipy method ignored all negative numbers so images
    of only negative previously returned no peaks.
    
    @param img output image 
    @param minDistance
        Minimum number of pixels separating peaks in a region of `2 *
        min_distance + 1` (i.e. peaks are separated by at least
        `min_distance`).
        To find the maximum number of peaks, use `min_distance=1`.
     * @param thresholdRel a positive real number that becomes a factor to
     * apply to the maximum value.
     * @param ignore0sInThreshold if true, method handles negative numbers,
     * else expects only the non-negative numbers should be used.
      @param outputKeypoints0 the output row coordinates of keypoints
     * @param outputKeypoints1 the output col coordinates of keypoints
     */
    public void peakLocalMax(float[][] img, int minDistance,
        float thresholdRel, boolean ignore0sInThreshold,
        TIntList outputKeypoints0, TIntList outputKeypoints1) {
        
<span class="fc" id="L5638">        int excludeBorder = minDistance;</span>
<span class="fc" id="L5639">        int numPeaks = Integer.MAX_VALUE;</span>
        //int numPeaksPerLabel = Integer.MAX_VALUE;

<span class="fc" id="L5642">        float sentinel = -10.f * Float.MIN_VALUE;</span>
        
        /*
        The peak local maximum function returns the coordinates of local peaks
        (maxima) in an image. A maximum filter is used for finding local maxima.
        This operation dilates the original image. After comparison of the dilated
        and original image, this function returns the coordinates or a mask of the
        peaks where the dilated image equals the original image.
        */

<span class="fc" id="L5652">        int nRows = img.length;</span>
<span class="fc" id="L5653">        int nCols = img[0].length;</span>
        
        // if &quot;ignore zeroes&quot; is set, need to make those negative numbers
        // so that the maximum filter won't find those as maximum if all
        // significant pixels are the nonzeroes and are negative numbers.
<span class="fc" id="L5658">        float[][] origImg = null;</span>
<span class="pc bpc" id="L5659" title="1 of 2 branches missed.">        if (ignore0sInThreshold) {</span>
<span class="fc" id="L5660">            origImg = copy(img);</span>
<span class="fc bfc" id="L5661" title="All 2 branches covered.">            for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="fc bfc" id="L5662" title="All 2 branches covered.">                for (int j = 0; j &lt; img[0].length; ++j) {</span>
<span class="fc bfc" id="L5663" title="All 2 branches covered.">                    if (img[i][j] == 0.f) {</span>
<span class="fc" id="L5664">                        img[i][j] = sentinel;</span>
                    }
                }
            }
        }

        //# Non maximum filter
<span class="fc" id="L5671">        int size = 2 * minDistance + 1;</span>
<span class="fc" id="L5672">        float[][] imageMax = maximumFilter(img, size);</span>
<span class="pc bnc" id="L5673" title="All 2 branches missed.">        assert(nRows == imageMax.length);</span>
<span class="pc bnc" id="L5674" title="All 2 branches missed.">        assert(nCols == imageMax[0].length);</span>
        //mask = image == image_max
        
        //debugPrint(&quot;before shift imageMax=&quot;, imageMax);

        // a fudge to match results of scipy which must store same windows at
        // locations shifted by minDistance or so in x and y from the
        // beginning of the sliding window
<span class="fc" id="L5682">        applyShift(imageMax, minDistance, nRows, nCols);</span>

<span class="pc bpc" id="L5684" title="1 of 2 branches missed.">        if (ignore0sInThreshold) {</span>
<span class="fc bfc" id="L5685" title="All 2 branches covered.">            for (int i = 0; i &lt; imageMax.length; ++i) {</span>
<span class="fc bfc" id="L5686" title="All 2 branches covered.">                for (int j = 0; j &lt; imageMax[0].length; ++j) {</span>
<span class="fc bfc" id="L5687" title="All 2 branches covered.">                    if (img[i][j] == sentinel) {</span>
<span class="fc" id="L5688">                        imageMax[i][j] = sentinel;</span>
                    }
                }
            }
        }
        
        // 1's where same, else 0's
<span class="fc" id="L5695">        int[][] mask = new int[nRows][nCols];</span>
<span class="fc bfc" id="L5696" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L5697">            mask[i] = new int[nCols];</span>
<span class="fc bfc" id="L5698" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc bfc" id="L5699" title="All 2 branches covered.">                if (img[i][j] == imageMax[i][j]) {</span>
<span class="fc" id="L5700">                    mask[i][j] = 1;</span>
                }
            }
        }

        //debugPrint(&quot;0 mask=&quot;, mask);

        // exclude border
<span class="fc bfc" id="L5708" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L5709" title="All 4 branches covered.">            if ((i &lt; excludeBorder) || (i &gt; (nRows - 1 - excludeBorder))){</span>
<span class="fc" id="L5710">                Arrays.fill(mask[i], 0);</span>
            } else {
<span class="fc" id="L5712">                Arrays.fill(mask[i], 0, excludeBorder, 0);</span>
<span class="fc" id="L5713">                Arrays.fill(mask[i], nCols - excludeBorder, nCols, 0);</span>
            }
        }

        // find top peak candidates above a threshold.
        // TODO: should this use mask so excluding borders?
<span class="fc" id="L5719">        float thresholdAbs = MiscMath.findMin(img);</span>
        
        // for the ORB images such as harris corner response images,
        // the zeroes are where there are no values sometimes, so
        // if user has set flag ignore0sInThreshold, ignore them
        // in determining the max
        float thresholdMax;
<span class="pc bpc" id="L5726" title="1 of 2 branches missed.">        if (ignore0sInThreshold) {</span>
<span class="fc" id="L5727">            thresholdMax = sentinel;</span>
<span class="fc bfc" id="L5728" title="All 2 branches covered.">            for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="fc bfc" id="L5729" title="All 2 branches covered.">                for (int j = 0; j &lt; img[0].length; ++j) {</span>
<span class="fc" id="L5730">                    float v = img[i][j];</span>
<span class="fc bfc" id="L5731" title="All 2 branches covered.">                    if (v &gt; thresholdMax) {</span>
<span class="fc" id="L5732">                        thresholdMax = v;</span>
                    }
                }
            }
           
<span class="fc bfc" id="L5737" title="All 2 branches covered.">            if (thresholdMax &lt;= 0.f) {</span>
<span class="fc" id="L5738">                float delta = thresholdMax * thresholdRel;</span>
<span class="fc" id="L5739">                thresholdMax += delta; </span>
<span class="fc" id="L5740">            } else {</span>
<span class="fc" id="L5741">                thresholdMax *= thresholdRel;</span>
            }
        } else {
<span class="nc" id="L5744">            float mx = MiscMath.findMax(img);</span>
<span class="nc bnc" id="L5745" title="All 2 branches missed.">            if (mx &lt;= 0.f) {</span>
<span class="nc" id="L5746">                float delta = mx * thresholdRel;</span>
<span class="nc" id="L5747">                thresholdMax = mx + delta;</span>
<span class="nc" id="L5748">            } else {</span>
<span class="nc" id="L5749">                thresholdMax = thresholdRel * mx;</span>
            }
        }
        
<span class="pc bpc" id="L5753" title="1 of 2 branches missed.">        if (ignore0sInThreshold) {</span>
<span class="pc bpc" id="L5754" title="1 of 2 branches missed.">            if (thresholdAbs == 0.0f) {</span>
<span class="nc" id="L5755">                thresholdAbs = thresholdMax;</span>
            } else {
<span class="fc" id="L5757">                thresholdAbs = Math.max(thresholdAbs, thresholdMax);</span>
            }
        } else {
<span class="nc" id="L5760">            thresholdAbs = Math.max(thresholdAbs, thresholdMax);</span>
        }
        
        // mask &amp;= image &gt; 0.1
<span class="fc bfc" id="L5764" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc bfc" id="L5765" title="All 2 branches covered.">            for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc" id="L5766">                float v = imageMax[i][j];</span>
<span class="fc bfc" id="L5767" title="All 2 branches covered.">                if (v &gt;= thresholdAbs) {</span>
<span class="fc" id="L5768">                    mask[i][j] &amp;= 1;</span>
                } else {
<span class="fc" id="L5770">                    mask[i][j] = 0;</span>
                }
            }
        }

        //debugPrint(&quot;mask &amp;= image &gt; &quot; + thresholdAbs, mask);

        // Select highest intensities (num_peaks)
        // expected output is [row index, col index, ...]

        //TODO: should num_peaks be this.nKeypoints?  re-read paper...
<span class="pc bpc" id="L5781" title="1 of 2 branches missed.">        if (numPeaks == Integer.MAX_VALUE) {</span>
            // find non-zero pixels in mask
<span class="fc" id="L5783">            float[] values = new float[nRows * nCols];</span>
<span class="fc" id="L5784">            int[] pixIdxs = new int[values.length];</span>
<span class="fc" id="L5785">            int count = 0;</span>
<span class="fc bfc" id="L5786" title="All 2 branches covered.">            for (int i = 0; i &lt; mask.length; ++i) {</span>
<span class="fc bfc" id="L5787" title="All 2 branches covered.">                for (int j = 0; j &lt; mask[i].length; ++j) {</span>
<span class="fc bfc" id="L5788" title="All 2 branches covered.">                    if (mask[i][j] &gt; 0.f) {</span>
<span class="fc" id="L5789">                        values[count] = img[i][j];</span>
                        //(row * width) + col
<span class="fc" id="L5791">                        pixIdxs[count] = (j * nRows) + i;</span>
<span class="fc" id="L5792">                        count++;</span>
                    }
                }
            }
<span class="fc" id="L5796">            values = Arrays.copyOf(values, count);</span>
<span class="fc" id="L5797">            pixIdxs = Arrays.copyOf(pixIdxs, count);</span>
<span class="fc" id="L5798">            MultiArrayMergeSort.sortByDecr(values, pixIdxs);</span>
<span class="fc bfc" id="L5799" title="All 2 branches covered.">            for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L5800">                int pixIdx = pixIdxs[i];</span>
<span class="fc" id="L5801">                int jj = pixIdx/nRows;</span>
<span class="fc" id="L5802">                int ii = pixIdx - (jj * nRows);</span>
<span class="fc" id="L5803">                outputKeypoints0.add(ii);</span>
<span class="fc" id="L5804">                outputKeypoints1.add(jj);</span>
            }
<span class="fc" id="L5806">        } else {</span>
            //need to sort to keep top numPeaks
<span class="nc" id="L5808">            FixedSizeSortedVector&lt;ORB.Pix&gt; vec = new</span>
                FixedSizeSortedVector&lt;ORB.Pix&gt;(numPeaks, ORB.Pix.class);
<span class="nc bnc" id="L5810" title="All 2 branches missed.">            for (int i = 0; i &lt; mask.length; ++i) {</span>
<span class="nc bnc" id="L5811" title="All 2 branches missed.">                for (int j = 0; j &lt; mask[i].length; ++j) {</span>
<span class="nc bnc" id="L5812" title="All 2 branches missed.">                    if (mask[i][j] &gt; 0.f) {</span>
<span class="nc" id="L5813">                        ORB.Pix pix = new ORB.Pix(i, j, Float.valueOf(img[i][j]));</span>
<span class="nc" id="L5814">                        vec.add(pix);</span>
                    }
                }
            }
<span class="nc bnc" id="L5818" title="All 2 branches missed.">            for (int i = 0; i &lt; vec.getNumberOfItems(); ++i) {</span>
<span class="nc" id="L5819">                ORB.Pix pix = vec.getArray()[i];</span>
<span class="nc" id="L5820">                outputKeypoints0.add(pix.i);</span>
<span class="nc" id="L5821">                outputKeypoints1.add(pix.j);</span>
            }
        }
        
<span class="pc bpc" id="L5825" title="1 of 2 branches missed.">        if (ignore0sInThreshold) {</span>
<span class="fc bfc" id="L5826" title="All 2 branches covered.">            for (int i = 0; i &lt; img.length; ++i) {</span>
<span class="fc bfc" id="L5827" title="All 2 branches covered.">                for (int j = 0; j &lt; img[0].length; ++j) {</span>
<span class="pc bpc" id="L5828" title="1 of 4 branches missed.">                    if (img[i][j] == sentinel &amp;&amp; origImg[i][j] == 0.f) {</span>
<span class="fc" id="L5829">                        img[i][j] = 0.0f;</span>
                    }
                }
            }
        }
        
<span class="fc" id="L5835">    }</span>

    private void applyShift(float[][] imageMax, int minDistance, int nRows,
        int nCols) {

<span class="fc bfc" id="L5840" title="All 2 branches covered.">        for (int i = 0; i &lt; nRows; ++i) {</span>
<span class="fc" id="L5841">            System.arraycopy(imageMax[i], 0, imageMax[i], minDistance,</span>
                nCols - minDistance);
<span class="fc bfc" id="L5843" title="All 2 branches covered.">            for (int j = 0; j &lt; minDistance; ++j) {</span>
<span class="fc" id="L5844">                imageMax[i][j] = 0;</span>
            }
<span class="fc bfc" id="L5846" title="All 2 branches covered.">            for (int j = (nCols - minDistance); j &lt; nCols; ++j) {</span>
<span class="fc" id="L5847">                imageMax[i][j] = 0;</span>
            }
        }
        //debugPrint(&quot;shift 0 imageMax=&quot;, imageMax);
<span class="fc bfc" id="L5851" title="All 2 branches covered.">        for (int j = 0; j &lt; nCols; ++j) {</span>
<span class="fc bfc" id="L5852" title="All 2 branches covered.">            for (int i = (nRows - minDistance); i &gt;= minDistance; --i) {</span>
<span class="fc" id="L5853">                imageMax[i][j] = imageMax[i - minDistance][j];</span>
            }
<span class="fc bfc" id="L5855" title="All 2 branches covered.">            for (int i = 0; i &lt; minDistance; ++i) {</span>
<span class="fc" id="L5856">                imageMax[i][j] = 0;</span>
            }
<span class="fc bfc" id="L5858" title="All 2 branches covered.">            for (int i = (nRows - minDistance); i &lt; nRows; ++i) {</span>
<span class="fc" id="L5859">                imageMax[i][j] = 0;</span>
            }
        }
        //debugPrint(&quot;shifted imageMax=&quot;, imageMax);
<span class="fc" id="L5863">    }</span>

    /**
     * @author nichole
     * @param img
     * @param size
     * @return
     */
    public float[][] maximumFilter(float[][] img, int size) {
<span class="fc" id="L5872">        return Filters.maximumFilter(img, size);</span>
    }

    /**
     *
     * @param img
     * @param g the kernel to convolve img with at point (x,y).
     * Note that it's assumed the kernel is already normalized to sum 0.
     * @return
     */
    public Complex[][] convolveWithKernel(final Complex[][] img,
        Complex[][] g) {

<span class="nc" id="L5885">        Complex[][] c = new Complex[img.length][];</span>

<span class="nc bnc" id="L5887" title="All 2 branches missed.">        for (int x = 0; x &lt; img.length; ++x) {</span>
<span class="nc" id="L5888">            c[x] = new Complex[img[0].length];</span>
<span class="nc bnc" id="L5889" title="All 2 branches missed.">            for (int y = 0; y &lt; img[0].length; ++y) {</span>
<span class="nc" id="L5890">                ComplexModifiable sum =</span>
<span class="nc" id="L5891">                    convolvePointWithKernel(img, x, y, g);</span>
<span class="nc" id="L5892">                c[x][y] = new Complex(sum.re(), sum.im());</span>
            }
        }

<span class="nc" id="L5896">        return c;</span>
    }

     /**
     *
     * @param img
     * @param x
     * @param y
     * @param g the kernel to convolve img with at point (x,y).
     * Note that it's assumed the kernel is already normalized to sum 0.
     * @return sum of convolution at point x,y
     */
    public ComplexModifiable convolvePointWithKernel(final Complex[][] img, int x,
        int y, Complex[][] g) {

<span class="nc" id="L5911">        int n0 = g.length;</span>
<span class="nc" id="L5912">        int n1 = g[0].length;</span>

<span class="nc" id="L5914">        int h0 = (n0 &gt;&gt; 1);</span>
<span class="nc" id="L5915">        int h1 = (n1 &gt;&gt; 1);</span>

<span class="nc" id="L5917">        int w = img.length;</span>
<span class="nc" id="L5918">        int h = img[0].length;</span>

<span class="nc" id="L5920">        ComplexModifiable sum = new ComplexModifiable(0, 0);</span>

<span class="nc bnc" id="L5922" title="All 2 branches missed.">        for (int i = -h0; i &lt; (n0 - h0); i++) {</span>
<span class="nc" id="L5923">            int x2 = x + i;</span>
<span class="nc bnc" id="L5924" title="All 2 branches missed.">            if (x2 &lt; 0) {</span>
               // replicate
<span class="nc" id="L5926">               x2 = -1*x2 - 1;</span>
<span class="nc bnc" id="L5927" title="All 2 branches missed.">               if (x2 &gt; (w - 1)) {</span>
<span class="nc" id="L5928">                   x2 = w - 1;</span>
               }
<span class="nc bnc" id="L5930" title="All 2 branches missed.">            } else if (x2 &gt; (w - 1)) {</span>
<span class="nc" id="L5931">                int diff = x2 - w;</span>
<span class="nc" id="L5932">                x2 = w - diff - 1;</span>
<span class="nc bnc" id="L5933" title="All 2 branches missed.">                if (x2 &lt; 0) {</span>
<span class="nc" id="L5934">                    x2 = 0;</span>
                }
            }
<span class="nc bnc" id="L5937" title="All 2 branches missed.">            for (int j = -h1; j &lt; (n1 - h1); j++) {</span>
<span class="nc" id="L5938">                int y2 = y + j;</span>
<span class="nc bnc" id="L5939" title="All 4 branches missed.">                if (y2 &lt; 0 || (y2 &gt; (h - 1))) {</span>
<span class="nc" id="L5940">                    continue;</span>
                }
<span class="nc bnc" id="L5942" title="All 2 branches missed.">                if (y2 &lt; 0) {</span>
                   // replicate
<span class="nc" id="L5944">                   y2 = -1*y2 - 1;</span>
<span class="nc bnc" id="L5945" title="All 2 branches missed.">                   if (y2 &gt; (h - 1)) {</span>
<span class="nc" id="L5946">                       y2 = h - 1;</span>
                   }
<span class="nc bnc" id="L5948" title="All 2 branches missed.">                } else if (y2 &gt; (h - 1)) {</span>
<span class="nc" id="L5949">                    int diff = y2 - h;</span>
<span class="nc" id="L5950">                    y2 = h - diff - 1;</span>
<span class="nc bnc" id="L5951" title="All 2 branches missed.">                    if (y2 &lt; 0) {</span>
<span class="nc" id="L5952">                        y2 = 0;</span>
                    }
                }

<span class="nc" id="L5956">                Complex gg = g[i + h0][j + h1];</span>

<span class="nc" id="L5958">                Complex point = img[x2][y2];</span>

<span class="nc" id="L5960">                Complex m = point.times(gg);</span>

<span class="nc" id="L5962">                sum.plus(m);</span>
            }
        }

<span class="nc" id="L5966">        return sum;</span>
    }

    public Set&lt;PairInt&gt; createWindowOfPoints(int x, int y,
        int windowHalfWidth, int imageWidth, int imageHeight) {

<span class="nc" id="L5972">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L5974" title="All 2 branches missed.">        for (int i = (x - windowHalfWidth); i &lt;= (x + windowHalfWidth); ++i) {</span>
<span class="nc bnc" id="L5975" title="All 4 branches missed.">            if (i &lt; 0 || i &gt; (imageWidth - 1)) {</span>
<span class="nc" id="L5976">                continue;</span>
            }
<span class="nc bnc" id="L5978" title="All 2 branches missed.">            for (int j = (y - windowHalfWidth); j &lt;= (y + windowHalfWidth); ++j) {</span>
<span class="nc bnc" id="L5979" title="All 4 branches missed.">                if (j &lt; 0 || j &gt; (imageHeight - 1)) {</span>
<span class="nc" id="L5980">                    continue;</span>
                }
<span class="nc" id="L5982">                points.add(new PairInt(i, j));</span>
            }
        }

<span class="nc" id="L5986">        return points;</span>
    }

    public List&lt;List&lt;GreyscaleImage&gt;&gt; buildColorPyramid(Image img,
        boolean buildLarger) {

<span class="fc" id="L5992">        List&lt;List&lt;GreyscaleImage&gt;&gt; pyr = new ArrayList&lt;List&lt;GreyscaleImage&gt;&gt;();</span>

<span class="fc" id="L5994">        GreyscaleImage r = img.copyRedToGreyscale();</span>
<span class="fc" id="L5995">        GreyscaleImage g = img.copyGreenToGreyscale();</span>
<span class="fc" id="L5996">        GreyscaleImage b = img.copyBlueToGreyscale();</span>
        List&lt;GreyscaleImage&gt; gsR;
        List&lt;GreyscaleImage&gt; gsG;
        List&lt;GreyscaleImage&gt; gsB;

<span class="pc bpc" id="L6001" title="1 of 2 branches missed.">        if (buildLarger) {</span>

<span class="fc" id="L6003">            gsR = buildPyramid2(r, 32);</span>
<span class="fc" id="L6004">            gsG = buildPyramid2(g, 32);</span>
<span class="fc" id="L6005">            gsB = buildPyramid2(b, 32);</span>

        } else {

<span class="nc" id="L6009">            MedianTransform mt = new MedianTransform();</span>

<span class="nc" id="L6011">            gsR = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L6012">            gsG = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="nc" id="L6013">            gsB = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="nc" id="L6015">            mt.multiscalePyramidalMedianTransform2(r, gsR, 32);</span>
<span class="nc" id="L6016">            mt.multiscalePyramidalMedianTransform2(g, gsG, 32);</span>
<span class="nc" id="L6017">            mt.multiscalePyramidalMedianTransform2(b, gsB, 32);</span>
        }

<span class="pc bnc" id="L6020" title="All 2 branches missed.">        assert(gsR.size() == gsG.size());</span>
<span class="pc bnc" id="L6021" title="All 2 branches missed.">        assert(gsR.size() == gsB.size());</span>

<span class="fc bfc" id="L6023" title="All 2 branches covered.">        for (int i = 0; i &lt; gsR.size(); ++i) {</span>
<span class="fc" id="L6024">            GreyscaleImage r2 = gsR.get(i);</span>
<span class="fc" id="L6025">            GreyscaleImage g2 = gsG.get(i);</span>
<span class="fc" id="L6026">            GreyscaleImage b2 = gsB.get(i);</span>

<span class="fc" id="L6028">            List&lt;GreyscaleImage&gt; rgb = new ArrayList&lt;GreyscaleImage&gt;();</span>
<span class="fc" id="L6029">            rgb.add(r2);</span>
<span class="fc" id="L6030">            rgb.add(g2);</span>
<span class="fc" id="L6031">            rgb.add(b2);</span>

<span class="fc" id="L6033">            pyr.add(rgb);</span>
        }

<span class="fc" id="L6036">        return pyr;</span>
    }

    public List&lt;GreyscaleImage&gt; buildPyramid(GreyscaleImage img,
        boolean buildLarger) {

<span class="fc" id="L6042">        GreyscaleImage cp = img.copyImage();</span>

        List&lt;GreyscaleImage&gt; out;

<span class="pc bpc" id="L6046" title="1 of 2 branches missed.">        if (buildLarger) {</span>

<span class="fc" id="L6048">            out = buildPyramid2(cp, 32);</span>

        } else {

<span class="nc" id="L6052">            MedianTransform mt = new MedianTransform();</span>

<span class="nc" id="L6054">            out = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="nc" id="L6056">            mt.multiscalePyramidalMedianTransform2(cp, out, 32);</span>
        }

<span class="fc" id="L6059">        return out;</span>
    }

    /**
     * given an input image, creates a decimation pyramid with
     * median smoothing followed by either integer or bilinear
     * interpolation down-sampling.
     * This method returns images down-sampled by scale sizes that
     * are a factor of 2 from each until image size
     * is smaller than decimationLimit.  Then the
     * method creates discrete scales in between the factors of 2
     * pyramid, such as 1.25, 1.5, 1.75, then bisecting scales
     * with 3, 5, 12, etc.
     * @param input
     * @param decimationLimit limit to smallest image dimension size returned
     * @return
     */
    public List&lt;GreyscaleImage&gt; buildPyramid2(GreyscaleImage input,
        int decimationLimit) {

<span class="fc" id="L6079">        List&lt;GreyscaleImage&gt; output = new ArrayList&lt;GreyscaleImage&gt;();</span>

<span class="fc" id="L6081">        MedianTransform mt = new MedianTransform();</span>
<span class="fc" id="L6082">        mt.multiscalePyramidalMedianTransform2(input, output, decimationLimit);</span>

<span class="fc bfc" id="L6084" title="All 2 branches covered.">        if (output.size() == 1) {</span>
<span class="fc" id="L6085">            return output;</span>
        }
        
<span class="fc" id="L6088">        float factor = 1.2f;//1.5f;</span>

<span class="fc" id="L6090">        List&lt;GreyscaleImage&gt; output2 = new ArrayList&lt;GreyscaleImage&gt;();</span>

        // add an image in between each after output[2]
<span class="fc bfc" id="L6093" title="All 2 branches covered.">        for (int i = 0; i &lt; output.size() - 1; ++i) {</span>
<span class="fc" id="L6094">            output2.add(mt.decimateImage(output.get(i), factor, 0, 255));</span>
        }

<span class="fc" id="L6097">        output.addAll(output2);</span>

<span class="fc" id="L6099">        Collections.sort(output, new DecreasingSizeComparator());</span>

<span class="fc" id="L6101">        return output;</span>

        /*
        a gaussian pyramid based upon a kernel of sigma 0.707
        can be built recursively, but the number of iterations
        to reach scale factors larger than 3 is increasingly
        very large number of recursions.

        FWHM = 2.35 * sigma
        for recursive gaussian and kernel0 w/ sigma=sqrt(2)/2 = 0.707
                                                     sigma   FWHM
        s1^2 = (sqrt(2)/2)^2 = 0.5                    0.7     1.67
        s2^2 = 0.5 + (sqrt(2)/2)^2 = 1                1       2.35
        s3^2 = 1 + (sqrt(2)/2)^2                      1.22    2.9
        s4^2 = 1.5 + (sqrt(2)/2)^2                    1.4     3.3
        s5^2 = 2 + (sqrt(2)/2)^2                      1.58    3.72
        s6^2 = 2.5 + (sqrt(2)/2)^2                    1.7     4.07
        s7^2 = 3.0 + (sqrt(2)/2)^2                    1.87    4.4
        ...
        s17^2 = 8.0 + (sqrt(2)/2)^2                   2.83    6.65  &lt;-- factor of 4 from s1

        Alternatively, making a kernel of size sigma&gt;2 needs larger
        kernels too so the O(N) has a large constant factor in front of it.

        A hybrid solution would be to use the current
        pyramidal median transform which returns images
        blurred and downsampled by factors of 2.
        Then add to that, discrete samplings of scale sizes
        that improve the pyramid.
        1   2   4   8   16
        for example, calculate for scale factors 1.25, 1.5, 1.75
        then bisecting the existing pyramidal scales to make
        3, 6, and 12, etc.
        Might consider a version of this method which provides more
        scales at higher factors...
        */
    }

    /**
     * comparator that assumes can compare by widths along,
     * unless there is a tie, then it uses height.
     */
    private class DecreasingSizeComparator implements
        Comparator&lt;GreyscaleImage&gt; {

        @Override
        public int compare(GreyscaleImage o1,
            GreyscaleImage o2) {

            int w1 = o1.getWidth();
            int w2 = o2.getWidth();

            if (w1 &gt; w2) {
                return -1;
            } else if (w1 &lt; w2) {
                return 1;
            }

            int h1 = o1.getHeight();
            int h2 = o2.getHeight();

            if (h1 &gt; h2) {
                return -1;
            } else if (h1 &lt; h2) {
                return 1;
            }

            return 0;
        }
    }

    /**
     * convert the image to cie l*a*b* and then use a and b
     * to calculate polar angle around 0 in degrees.
     * If maxV of 360, returns full value image,
     * else if is 255, scales the values to max value of 255, etc.
     * @return
     */
    public int calculateCIELABTheta(int red, int green, int blue, int maxV) {

<span class="nc" id="L6181">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L6183">        double ts = (double)maxV/(double)359;</span>

<span class="nc" id="L6185">        float[] lab = cieC.rgbToCIELAB1931(red, green, blue);</span>

<span class="nc" id="L6187">        float v1 = lab[1];</span>
<span class="nc" id="L6188">        float v2 = lab[2];</span>

<span class="nc" id="L6190">        double t = Math.atan2(v2, v1);</span>
<span class="nc" id="L6191">        t *= (180./Math.PI);</span>
<span class="nc bnc" id="L6192" title="All 2 branches missed.">        if (t &lt; 0) {</span>
<span class="nc" id="L6193">            t += 360;</span>
<span class="nc bnc" id="L6194" title="All 2 branches missed.">        } else if (t &gt; 359) {</span>
<span class="nc" id="L6195">            t -= 360;</span>
        }
<span class="nc" id="L6197">        t *= ts;</span>

<span class="nc" id="L6199">        return (int)t;</span>
    }

    /**
     * create sobel gradient images for the given images specified by idxs
     * @param images
     * @param idxs
     * @return
     */
    public GreyscaleImage[] createSobels(GreyscaleImage[] images, int[] idxs) {

<span class="nc" id="L6210">        GreyscaleImage[] sobels = new GreyscaleImage[2];</span>

<span class="nc" id="L6212">        int count = 0;</span>
<span class="nc bnc" id="L6213" title="All 2 branches missed.">        for (int idx : idxs) {</span>
<span class="nc" id="L6214">            GreyscaleImage img2 = images[idx];</span>
<span class="nc" id="L6215">            sobels[count] = img2.copyImage();</span>
<span class="nc" id="L6216">            applySobelKernel(sobels[count]);</span>
<span class="nc" id="L6217">            count++;</span>
        }
<span class="nc" id="L6219">        return sobels;</span>
    }

    public GreyscaleImage[] createSobelLCForLUV(Image img) {

<span class="nc" id="L6224">        GreyscaleImage[] lch = createLCHForLUV(img);</span>

<span class="nc" id="L6226">        GreyscaleImage[] sobels = createSobels(lch, new int[]{0, 1});</span>

<span class="nc" id="L6228">        return sobels;</span>
    }

    /**
     * create 3 images of LCH where L, C, and H are the
     * luminosity, magnitude, and polar angle of CIE LUV color space, respectively.
     * @param img
     * @return
     */
    public GreyscaleImage[] createLCHForLUV(Image img) {

<span class="fc" id="L6239">        int w = img.getWidth();</span>
<span class="fc" id="L6240">        int h = img.getHeight();</span>
<span class="fc" id="L6241">        int n = img.getNPixels();</span>

        /*
        range of CIE LUV using default standard illumination of
        D65 daylight is:
        L       0 to 104.5
        u   -86.9 to 183.8
        v  -141.4 to 112.3
        luminosity L*  0 to 104.5
        magnitude, m:  sqrt(2) * 183.8 = 260
        angle,     a:  0 to 359
        */

<span class="fc" id="L6254">        float[] factors = new float[]{255.f/104.5f, 255.f/260.f, 255.f/359.f};</span>

<span class="fc" id="L6256">        GreyscaleImage[] output = new GreyscaleImage[3];</span>
<span class="fc bfc" id="L6257" title="All 2 branches covered.">        for (int i = 0; i &lt; output.length; ++i) {</span>
<span class="fc" id="L6258">            output[i] = new GreyscaleImage(w, h);</span>
        }

<span class="fc" id="L6261">        CIEChromaticity cieC = new CIEChromaticity();</span>

        int v;
<span class="fc bfc" id="L6264" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L6265" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L6267">                int r = img.getR(i, j);</span>
<span class="fc" id="L6268">                int g = img.getG(i, j);</span>
<span class="fc" id="L6269">                int b = img.getB(i, j);</span>

<span class="fc" id="L6271">                float[] lma = cieC.rgbToPolarCIELUV(r, g, b);</span>

<span class="fc bfc" id="L6273" title="All 2 branches covered.">                for (int k = 0; k &lt; output.length; ++k) {</span>
<span class="fc bfc" id="L6274" title="All 4 branches covered.">                    if (k == 2 &amp;&amp; lma[k] &gt; 359.f) {</span>
<span class="fc" id="L6275">                        lma[k] = 360 - lma[k];</span>
                    }
<span class="fc" id="L6277">                    v = Math.round(factors[k] * lma[k]);</span>
<span class="fc bfc" id="L6278" title="All 2 branches covered.">                    if (v &gt; 255) {</span>
<span class="fc" id="L6279">                        v = 255;</span>
<span class="pc bpc" id="L6280" title="1 of 2 branches missed.">                    } else if (v &lt; 0) {</span>
<span class="nc" id="L6281">                        v = 0;</span>
                    }
<span class="fc" id="L6283">                    output[k].setValue(i, j, v);</span>
                }
            }
        }

<span class="fc" id="L6288">        return output;</span>
    }

    /**
     * convert the image to cie luv and then calculate polar angle of u and v
     * around 0 in degrees (a.k.a. the &quot;H&quot; of LCH color space, but with
     * the 1976 CIE LAB which is LUV).
     * If maxV of 360, returns full value image,
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return
     */
    public GreyscaleImage createCIELUVTheta(Image img, int maxV) {

<span class="fc" id="L6303">        int w = img.getWidth();</span>
<span class="fc" id="L6304">        int h = img.getHeight();</span>

<span class="fc" id="L6306">        GreyscaleImage theta = null;</span>
<span class="pc bpc" id="L6307" title="1 of 2 branches missed.">        if (maxV &lt; 256) {</span>
<span class="fc" id="L6308">            theta = new GreyscaleImage(w, h);</span>
        } else {
<span class="nc" id="L6310">            theta = new GreyscaleImage(w, h,</span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }

<span class="fc" id="L6314">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L6316">        double ts = (double)maxV/(double)359;</span>

<span class="fc" id="L6318">        int n = img.getNPixels();</span>
        int v;
<span class="fc bfc" id="L6320" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L6321" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L6323">                int r = img.getR(i, j);</span>
<span class="fc" id="L6324">                int g = img.getG(i, j);</span>
<span class="fc" id="L6325">                int b = img.getB(i, j);</span>

<span class="fc" id="L6327">                float[] lma = cieC.rgbToPolarCIELUV(r, g, b);</span>

<span class="fc" id="L6329">                double t = lma[2];</span>
<span class="fc" id="L6330">                t *= ts;</span>
<span class="fc" id="L6331">                v = (int)t;</span>

<span class="fc" id="L6333">                theta.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L6337">        return theta;</span>
    }
    
    /**
     * convert the image to cie luv and then calculate polar angle of u and v
     * around 0 in degrees (a.k.a. the &quot;H&quot; of LCH color space, but with
     * the 1976 CIE LAB which is LUV).
     * If maxV of 360, returns full value image,
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return
     */
    public GreyscaleImage createCIELUVThetaBilinear(Image img, int maxV) {

<span class="nc" id="L6352">        int w = img.getWidth();</span>
<span class="nc" id="L6353">        int h = img.getHeight();</span>

<span class="nc" id="L6355">        GreyscaleImage theta = null;</span>
<span class="nc bnc" id="L6356" title="All 2 branches missed.">        if (maxV &lt; 256) {</span>
<span class="nc" id="L6357">            theta = new GreyscaleImage(w, h);</span>
        } else {
<span class="nc" id="L6359">            theta = new GreyscaleImage(w, h,</span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }

<span class="nc" id="L6363">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L6365">        double ts = (double)maxV/(double)359;</span>
        
<span class="nc" id="L6367">        int n = img.getNPixels();</span>
        int v;
<span class="nc bnc" id="L6369" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L6370" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="nc" id="L6372">                int r = img.getR(i, j);</span>
<span class="nc" id="L6373">                int g = img.getG(i, j);</span>
<span class="nc" id="L6374">                int b = img.getB(i, j);</span>

<span class="nc" id="L6376">                float[] lma = cieC.rgbToPolarCIELUV(r, g, b);</span>

<span class="nc" id="L6378">                double t = lma[2];</span>
<span class="nc" id="L6379">                t *= ts;</span>
<span class="nc" id="L6380">                v = (int)t;</span>

<span class="nc" id="L6382">                theta.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L6386">        return theta;</span>
    }
    
    /**
     * uses standard illuminant &quot;wide range lightness&quot;.
     * Wide-range Lightness data were generated by Fairchild et al., 
     * who conducted two different experiments to scale lightness above and 
     * below diffuse white (CIE * L = 100 ). 
     * In the Scaling Lightness Experiment 1 (SL1) they used a luminance
       range from 156 to 2 3692cd m with 2 842 Y cd m n = 
     (Yn represents the luminance of reference white) 
     * whereas in the Scaling Lightness Experiment 2 (SL2) the
      luminance range was extended from 0 to 2 7432cd m with 2 997 Y cd m n = . 
     The SL2 data set was used to drive the adapted lightness ( z J ) 
     formula of the proposed color space (see later) while the SL1 data set was 
     used as a test data set. Each of the sets includes 19 samples. 

     * https://www.osapublishing.org/DirectPDFAccess/B810E9AE-C7C9-E594-C72DC7FBE1424F0A_368272/oe-25-13-15131.pdf?da=1&amp;id=368272&amp;seq=0&amp;mobile=no
     * 
     * SL2 Training D65/2 (x,y,z)=968.08 997 883.51 
     * L_a=199 
     * C=0.69. N_C=1, F=1 
     * 
     * convert the image to cie luv and then calculate polar angle of u and v
     * around 0 in degrees (a.k.a. the &quot;H&quot; of LCH color space, but with
     * the 1976 CIE LAB which is LUV).
     * If maxV of 360, returns full value image,
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return
     */
    public GreyscaleImage createCIELUVTheta_WideRangeLightness(Image img, int maxV) {

<span class="fc" id="L6420">        int w = img.getWidth();</span>
<span class="fc" id="L6421">        int h = img.getHeight();</span>

<span class="fc" id="L6423">        GreyscaleImage theta = null;</span>
<span class="pc bpc" id="L6424" title="1 of 2 branches missed.">        if (maxV &lt; 256) {</span>
<span class="fc" id="L6425">            theta = new GreyscaleImage(w, h);</span>
        } else {
<span class="nc" id="L6427">            theta = new GreyscaleImage(w, h,</span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }

<span class="fc" id="L6431">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="fc" id="L6433">        double ts = (double)maxV/(double)359;</span>

<span class="fc" id="L6435">        float xd = 96.808f;</span>
<span class="fc" id="L6436">        float yd = 99.7f;</span>
<span class="fc" id="L6437">        float zd = 88.351f;</span>
<span class="fc" id="L6438">        int n = img.getNPixels();</span>
        int v;
<span class="fc bfc" id="L6440" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L6441" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="fc" id="L6443">                int r = img.getR(i, j);</span>
<span class="fc" id="L6444">                int g = img.getG(i, j);</span>
<span class="fc" id="L6445">                int b = img.getB(i, j);</span>

<span class="fc" id="L6447">                float[] lma = cieC.rgbToPolarCIELUV(r, g, b, xd, yd, zd);</span>

<span class="fc" id="L6449">                double t = lma[2];</span>
<span class="fc" id="L6450">                t *= ts;</span>
<span class="fc" id="L6451">                v = (int)t;</span>

<span class="fc" id="L6453">                theta.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L6457">        return theta;</span>
    }

    /**
     * convert the image to cie lab and then calculate polar angle of u and v
     * around 0 in degrees.
     * If maxV of 360, returns full value image,
     * else if is 255, scales the values to max value of 255, etc.
     * @param img
     * @param maxV
     * @return
     */
    public GreyscaleImage createCIELABTheta(Image img, int maxV) {

<span class="nc" id="L6471">        int w = img.getWidth();</span>
<span class="nc" id="L6472">        int h = img.getHeight();</span>

<span class="nc" id="L6474">        GreyscaleImage theta = null;</span>
<span class="nc bnc" id="L6475" title="All 2 branches missed.">        if (maxV &lt; 256) {</span>
<span class="nc" id="L6476">            theta = new GreyscaleImage(w, h);</span>
        } else {
<span class="nc" id="L6478">            theta = new GreyscaleImage(w, h,</span>
                GreyscaleImage.Type.Bits32FullRangeInt);
        }

<span class="nc" id="L6482">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L6484">        double ts = (double)maxV/(double)359;</span>

<span class="nc" id="L6486">        int n = img.getNPixels();</span>
        int v;
<span class="nc bnc" id="L6488" title="All 2 branches missed.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc bnc" id="L6489" title="All 2 branches missed.">            for (int j = 0; j &lt; h; ++j) {</span>

<span class="nc" id="L6491">                int r = img.getR(i, j);</span>
<span class="nc" id="L6492">                int g = img.getG(i, j);</span>
<span class="nc" id="L6493">                int b = img.getB(i, j);</span>

<span class="nc" id="L6495">                float[] lab = cieC.rgbToCIELAB(r, g, b);</span>

<span class="nc" id="L6497">                double t = Math.atan2(lab[2], lab[1]);</span>
<span class="nc" id="L6498">                t *= (180. / Math.PI);</span>
<span class="nc bnc" id="L6499" title="All 2 branches missed.">                if (t &lt; 0) {</span>
<span class="nc" id="L6500">                    t += 360;</span>
<span class="nc bnc" id="L6501" title="All 2 branches missed.">                } else if (t &gt; 359) {</span>
<span class="nc" id="L6502">                    t -= 360;</span>
                }

<span class="nc" id="L6505">                t *= ts;</span>
<span class="nc" id="L6506">                v = (int)t;</span>

<span class="nc" id="L6508">                theta.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L6512">        return theta;</span>
    }

    /**
     * 
     * @param pointIndexMap map with key=pixelIndex, value=label.
     * @param labeledPoints list of point sets that are the edges of blobs.  NOTE
     * that the indexes of the list are the labels and they are the same labels
     * as present in pointIndexMap.  NOTE that pointIndexMap can have more 
     * points than are present in labeledPoints, but the one context that this
     * method was created for has same points in both data structures.
     * @param imgWidth
     * @param imgHeight
     * @return a map with key=label, value = bitstring marking the neighboring labels.
     */
    public TIntObjectMap&lt;VeryLongBitString&gt; createAdjacencyMap(
        TIntIntMap pointIndexMap, List&lt;TIntSet&gt; labeledPoints,
        int imgWidth, int imgHeight) {

<span class="fc" id="L6531">        int n = labeledPoints.size();</span>

<span class="fc" id="L6533">        TIntObjectMap&lt;VeryLongBitString&gt; output</span>
            = new TIntObjectHashMap&lt;VeryLongBitString&gt;();

<span class="fc" id="L6536">        int[] dxs = Misc.dx4;</span>
<span class="fc" id="L6537">        int[] dys = Misc.dy4;</span>

        // making an adjacency list for the labels
<span class="fc bfc" id="L6540" title="All 2 branches covered.">        for (int label = 0; label &lt; n; ++label) {</span>

<span class="fc" id="L6542">            TIntSet pixIdxs = labeledPoints.get(label);</span>

<span class="fc" id="L6544">            VeryLongBitString nbrs = new VeryLongBitString(n);</span>
            
<span class="fc" id="L6546">            TIntIterator iter2 = pixIdxs.iterator();</span>
<span class="fc bfc" id="L6547" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L6548">                int pixIdx = iter2.next();</span>
<span class="fc" id="L6549">                int y = pixIdx/imgWidth;</span>
<span class="fc" id="L6550">                int x = pixIdx - (y * imgWidth);</span>
<span class="fc bfc" id="L6551" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L6552">                    int x2 = x + dxs[k];</span>
<span class="fc" id="L6553">                    int y2 = y + dys[k];</span>
<span class="fc bfc" id="L6554" title="All 8 branches covered.">                    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= imgWidth || y2 &gt;= imgHeight) {</span>
<span class="fc" id="L6555">                        continue;</span>
                    }
<span class="fc" id="L6557">                    int pixIdx2 = (y2 * imgWidth) + x2;</span>
<span class="pc bpc" id="L6558" title="1 of 2 branches missed.">                    if (pointIndexMap.containsKey(pixIdx2)) {</span>
<span class="fc" id="L6559">                        int label2 = pointIndexMap.get(pixIdx2);</span>
<span class="fc bfc" id="L6560" title="All 2 branches covered.">                        if (label2 != label) {</span>
<span class="fc" id="L6561">                            nbrs.setBit(label2);</span>
                        }
                    }
                }
<span class="fc" id="L6565">            }</span>
<span class="fc" id="L6566">            output.put(label, nbrs);</span>
        }
        
<span class="pc bnc" id="L6569" title="All 2 branches missed.">        assert(output.size() == labeledPoints.size());</span>

<span class="fc" id="L6571">        return output;</span>
    }

    public void applyUnsharpMask(GreyscaleImage img) {

        //NOTE: if make a color version of this, should use a color
        // space such as CIE LAB or LUV and operate on the L only to
        // preserve color (or B of HSB).

        // NOTE: useful in looking at the general concept of
        //  original, blurred and threshold comparison was code copyrighted by
        //  Romain Guy available here:
        //  http://www.java2s.com/Code/Java/Advanced-Graphics/UnsharpMaskDemo.htm
        //  might need to place the copytight here for derivative of.

<span class="nc" id="L6586">        float amount = 0.2f;</span>
<span class="nc" id="L6587">        int radius = 50;</span>
<span class="nc" id="L6588">        float threshold = 0;</span>

<span class="nc" id="L6590">        applyUnsharpMask(img, amount, radius, threshold);</span>

<span class="nc" id="L6592">    }</span>

    /**
     * if a single pixel differs from its neighbors by more than
     * 2o or 2 sigma, the value gets set to the neighbors
     * @param img
     */
    public void singlePixelFilter(GreyscaleImage img) {

<span class="fc" id="L6601">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L6602">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L6604">        int n = img.getNPixels();</span>
<span class="fc" id="L6605">        int w = img.getWidth();</span>
<span class="fc" id="L6606">        int h = img.getHeight();</span>

<span class="fc bfc" id="L6608" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

<span class="fc" id="L6610">            int x = img.getCol(i);</span>
<span class="fc" id="L6611">            int y = img.getRow(i);</span>

            float diff;
<span class="fc" id="L6614">            float avg = 0;</span>
<span class="fc" id="L6615">            int ns = 0;</span>
<span class="fc bfc" id="L6616" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L6617">                int x2 = x + dxs[k];</span>
<span class="fc" id="L6618">                int y2 = y + dys[k];</span>
<span class="fc bfc" id="L6619" title="All 8 branches covered.">                if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="fc" id="L6620">                    continue;</span>
                }
<span class="fc" id="L6622">                avg += img.getValue(x2, y2);</span>
<span class="fc" id="L6623">                ns++;</span>
            }
<span class="fc" id="L6625">            avg /= (float)ns;</span>
<span class="pc bpc" id="L6626" title="1 of 2 branches missed.">            if (ns == 0) {</span>
<span class="nc" id="L6627">                continue;</span>
            }

<span class="fc" id="L6630">            float stdv = 0;</span>
<span class="fc bfc" id="L6631" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L6632">                int x2 = x + dxs[k];</span>
<span class="fc" id="L6633">                int y2 = y + dys[k];</span>
<span class="fc bfc" id="L6634" title="All 8 branches covered.">                if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= w || y2 &gt;= h) {</span>
<span class="fc" id="L6635">                    continue;</span>
                }
<span class="fc" id="L6637">                diff = img.getValue(x2, y2) - avg;</span>
<span class="fc" id="L6638">                stdv += (diff * diff);</span>
            }
<span class="fc" id="L6640">            stdv = (float)Math.sqrt(stdv/((float)ns - 1.0f));</span>

<span class="fc" id="L6642">            diff = Math.abs(img.getValue(x, y) - avg);</span>
<span class="fc bfc" id="L6643" title="All 2 branches covered.">            if (diff &gt; (2.*stdv)) {</span>
<span class="fc" id="L6644">                img.setValue(x, y, (int)avg);</span>
            }
        }
<span class="fc" id="L6647">    }</span>

    public void applyUnsharpMask(GreyscaleImage img, float percentage,
        int radius, float threshold) {

<span class="fc" id="L6652">        MedianSmooth ms = new MedianSmooth();</span>
<span class="fc" id="L6653">        GreyscaleImage blurred = ms.calculate(img, 3, 3);</span>

<span class="fc bfc" id="L6655" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L6656">            int v = img.getValue(i);</span>
<span class="fc" id="L6657">            int blur = blurred.getValue(i);</span>

<span class="fc" id="L6659">            int diff = v - blur;</span>
<span class="pc bpc" id="L6660" title="1 of 2 branches missed.">            if (Math.abs(diff) &gt;= threshold) {</span>
<span class="fc" id="L6661">                v = (int) (percentage * diff + v);</span>
<span class="fc bfc" id="L6662" title="All 2 branches covered.">                if (v &lt; 0) {</span>
<span class="fc" id="L6663">                    v = 0;</span>
<span class="fc bfc" id="L6664" title="All 2 branches covered.">                } else if (v &gt; 255) {</span>
<span class="fc" id="L6665">                    v = 255;</span>
                }
<span class="fc" id="L6667">                img.setValue(i, v);</span>
            }
        }
<span class="fc" id="L6670">    }</span>

    /**
     * use an adaptive threshold with window size to add the threshold
     * to the image where binarization would have created a &quot;1&quot;.
     * This enhances shadows and dark edges to an extreme that might not
     * be desirable for all uses.
     *
     * @param img
     */
    public void enhanceContrast(GreyscaleImage img, int window) {

<span class="fc" id="L6682">        GreyscaleImage inImg = img;</span>
        double[][] outImg;

<span class="fc" id="L6685">        int w = inImg.getWidth();</span>
<span class="fc" id="L6686">        int h = inImg.getHeight();</span>

<span class="fc" id="L6688">        double[][] sTable = new double[w][];</span>
<span class="fc bfc" id="L6689" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L6690">            sTable[i] = new double[h];</span>
<span class="fc bfc" id="L6691" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L6692">                sTable[i][j] = inImg.getValue(i, j);</span>
            }
        }

<span class="fc" id="L6696">        AdaptiveThresholding th =</span>
            new AdaptiveThresholding();
<span class="fc" id="L6698">        outImg = th.createAdaptiveThresholdImage(sTable, window, 0.2);</span>

        double v;
<span class="fc bfc" id="L6701" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L6702" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L6703">                double t = outImg[i][j];</span>
<span class="fc" id="L6704">                v = inImg.getValue(i, j);</span>
<span class="fc bfc" id="L6705" title="All 2 branches covered.">                if (v &gt; t) {</span>
                    // adding threshold back to emphasize contrast
                    // instead of binarization:
<span class="fc" id="L6708">                    v += t;</span>
                }
<span class="fc" id="L6710">                outImg[i][j] = v;</span>
            }
        }

<span class="fc" id="L6714">        MiscMath.applyRescale(outImg, 0, 255);</span>

<span class="fc bfc" id="L6716" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L6717" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L6718">                inImg.setValue(i, j, (int)outImg[i][j]);</span>
            }
        }
<span class="fc" id="L6721">    }</span>

    /**
     * a utility method for polar theta images that have had their range
     * scaled from 0 to 255.  This method copies the image and applies
     * the valueShift amount to each pixel value and if result is larger than
     * 255, subtracts 255 to wrap around to 0 again in the polar coordinates.
     * NOTE: the algorithms that use this to compensate for the discontinuity
     * from 255 to 0 can probably be changed to use a difference in angles.
     * @param polarImage
     * @param valueShift
     * @return 
     */
    public GreyscaleImage copyAndShiftPolarAngleImage(GreyscaleImage polarImage, int valueShift) {

<span class="fc" id="L6736">        GreyscaleImage shiftedImg = polarImage.createWithDimensions();</span>
<span class="fc bfc" id="L6737" title="All 2 branches covered.">        for (int i = 0; i &lt; polarImage.getNPixels(); ++i) {</span>
<span class="fc" id="L6738">            int v = polarImage.getValue(i);</span>
<span class="fc" id="L6739">            v += valueShift;</span>
<span class="pc bpc" id="L6740" title="1 of 2 branches missed.">            if (v &lt; 0) {</span>
<span class="nc" id="L6741">                v += 255;</span>
<span class="fc bfc" id="L6742" title="All 2 branches covered.">            } else if (v &gt; 255) {</span>
<span class="fc" id="L6743">                v -= 255;</span>
            }
<span class="fc" id="L6745">            shiftedImg.setValue(i, v);</span>
        }

<span class="fc" id="L6748">        return shiftedImg;</span>
    }
    
    // TODO: implement the methods in
    // http://www.merl.com/publications/docs/TR2008-030.pdf
    // for an O(n) filter.
    // &quot;Constant Time O(1) Bilateral Filtering&quot; by Porikli
    //public void applyBiLateralFilter(Image img) {
    //}

    // and trilateral filter by Tumblin et al. 2003

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
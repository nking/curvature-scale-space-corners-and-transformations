<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageProcessor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageProcessor.java</span></div><h1>ImageProcessor.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonAndPointPlotter;
import algorithms.util.PairInt;
import algorithms.misc.Complex;
import algorithms.misc.Histogram;
import algorithms.misc.Misc;
import algorithms.util.ResourceFinder;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public class ImageProcessor {</span>

<span class="fc" id="L28">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * &lt;pre&gt;
     * [1, 0, -1]
     * this is the n=2 binomial filter for a Gaussian first derivative,
       that is sigma = sqrt(2)/2 = 0.707
       &lt;/pre&gt;
     * @param input
     */
    public void applySobelKernel(Image input) {

<span class="fc" id="L40">        IKernel kernel = new SobelX();</span>
<span class="fc" id="L41">        Kernel kernelX = kernel.getKernel();</span>

<span class="fc" id="L43">        float normX = kernel.getNormalizationFactor();</span>

<span class="fc" id="L45">        kernel = new SobelY();</span>
<span class="fc" id="L46">        Kernel kernelY = kernel.getKernel();</span>

<span class="fc" id="L48">        float normY = kernel.getNormalizationFactor();</span>

<span class="fc" id="L50">        applyKernels(input, kernelX, kernelY, normX, normY);</span>
<span class="fc" id="L51">    }</span>


    public void applySobelKernel(GreyscaleImage input) {

<span class="nc" id="L56">        IKernel kernel = new SobelX();</span>
<span class="nc" id="L57">        Kernel kernelX = kernel.getKernel();</span>

<span class="nc" id="L59">        float normX = kernel.getNormalizationFactor();</span>

<span class="nc" id="L61">        kernel = new SobelY();</span>
<span class="nc" id="L62">        Kernel kernelY = kernel.getKernel();</span>

<span class="nc" id="L64">        float normY = kernel.getNormalizationFactor();</span>

<span class="nc" id="L66">        applyKernels(input, kernelX, kernelY, normX, normY);</span>
<span class="nc" id="L67">    }</span>

    public void applyLaplacianKernel(GreyscaleImage input) {

<span class="nc" id="L71">        IKernel kernel = new Laplacian();</span>
<span class="nc" id="L72">        Kernel kernelXY = kernel.getKernel();</span>

<span class="nc" id="L74">        float norm = kernel.getNormalizationFactor();</span>

<span class="nc" id="L76">        applyKernel(input, kernelXY, norm);</span>
<span class="nc" id="L77">    }</span>

    /**
     * apply the kernels to the input.  Note that the current image format
     * only accepts value between 0 and 255, inclusive.
     * @param input
     * @param kernelX
     * @param kernelY
     * @param normFactorX
     * @param normFactorY 
     */
    protected void applyKernels(Image input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="fc" id="L97">        Image imgX = input.copyImage();</span>

<span class="fc" id="L99">        Image imgY = input.copyImage();</span>

<span class="fc" id="L101">        applyKernel(imgX, kernelX, normFactorX);</span>

<span class="fc" id="L103">        applyKernel(imgY, kernelY, normFactorY);</span>

<span class="fc" id="L105">        Image img2 = combineConvolvedImages(imgX, imgY);</span>

<span class="fc" id="L107">        input.resetTo(img2);</span>
<span class="fc" id="L108">    }</span>

    protected void applyKernels(GreyscaleImage input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L119">        GreyscaleImage imgX = input.copyImage();</span>

<span class="nc" id="L121">        GreyscaleImage imgY = input.copyImage();</span>

<span class="nc" id="L123">        applyKernel(imgX, kernelX, normFactorX);</span>

<span class="nc" id="L125">        applyKernel(imgY, kernelY, normFactorY);</span>

<span class="nc" id="L127">        GreyscaleImage img2 = combineConvolvedImages(imgX, imgY);</span>

<span class="nc" id="L129">        input.resetTo(img2);</span>
<span class="nc" id="L130">    }</span>

    public Image combineConvolvedImages(Image imageX, Image imageY) {

<span class="fc" id="L134">        Image img2 = new Image(imageX.getWidth(), imageX.getHeight());</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L139">                int rX = imageX.getR(i, j);</span>
<span class="fc" id="L140">                int gX = imageX.getG(i, j);</span>
<span class="fc" id="L141">                int bX = imageX.getB(i, j);</span>

<span class="fc" id="L143">                int rY = imageY.getR(i, j);</span>
<span class="fc" id="L144">                int gY = imageY.getG(i, j);</span>
<span class="fc" id="L145">                int bY = imageY.getB(i, j);</span>

<span class="fc" id="L147">                double r = Math.sqrt(rX*rX + rY*rY);</span>
<span class="fc" id="L148">                double g = Math.sqrt(gX*gX + gY*gY);</span>
<span class="fc" id="L149">                double b = Math.sqrt(bX*bX + bY*bY);</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">                r = (r &gt; 255) ? 255 : r;</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">                g = (g &gt; 255) ? 255 : g;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">                b = (b &gt; 255) ? 255 : b;</span>

                //int rgb = (int)(((rSum &amp; 0x0ff) &lt;&lt; 16)
                //    | ((gSum &amp; 0x0ff) &lt;&lt; 8) | (bSum &amp; 0x0ff));

<span class="fc" id="L158">                img2.setRGB(i, j, (int)r, (int)g, (int)b);</span>
            }
        }

<span class="fc" id="L162">        return img2;</span>
    }

    /**
     * process only the green channel and set red and blue to zero
     * @param imageX
     * @param imageY
     * @return
     */
    public GreyscaleImage combineConvolvedImages(final GreyscaleImage imageX,
        final GreyscaleImage imageY) {

<span class="fc" id="L174">        GreyscaleImage img2 = imageX.createWithDimensions();</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L179">                int gX = imageX.getValue(i, j);</span>

<span class="fc" id="L181">                int gY = imageY.getValue(i, j);</span>

                //double g = Math.sqrt(0.5*(gX*gX + gY*gY));

                //g = (g &gt; 255) ? 255 : g;

<span class="fc" id="L187">                double g = Math.sqrt(gX*gX + gY*gY);</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">                if (g &gt; 255) {</span>
<span class="fc" id="L190">                    g = 255;</span>
                }

                //int rgb = (int)(((rSum &amp; 0x0ff) &lt;&lt; 16)
                //    | ((gSum &amp; 0x0ff) &lt;&lt; 8) | (bSum &amp; 0x0ff));

<span class="fc" id="L196">                img2.setValue(i, j, (int)g);</span>
            }
        }

<span class="fc" id="L200">        return img2;</span>
    }

    /**
     * apply kernel to input. NOTE, that because the image is composed of
     * vectors that should have values between 0 and 255, inclusive, if the
     * kernel application results in a value outside of that range, the value
     * is reset to 0 or 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(Image input, Kernel kernel, float normFactor) {

<span class="fc" id="L214">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="fc" id="L216">        Image output = new Image(input.getWidth(), input.getHeight());</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="fc" id="L221">                long rValue = 0;</span>
<span class="fc" id="L222">                long gValue = 0;</span>
<span class="fc" id="L223">                long bValue = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="fc bfc" id="L227" title="All 2 branches covered.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="fc" id="L229">                    int x = col - h;</span>

<span class="fc" id="L231">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="fc bfc" id="L234" title="All 2 branches covered.">                    if (imgX &lt; 0) {</span>
<span class="fc" id="L235">                        imgX = -1 * imgX - 1;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="fc" id="L237">                        int diff = imgX - input.getWidth();</span>
<span class="fc" id="L238">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="fc bfc" id="L241" title="All 2 branches covered.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="fc" id="L243">                        int y = row - h;</span>

<span class="fc" id="L245">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="fc bfc" id="L248" title="All 2 branches covered.">                        if (imgY &lt; 0) {</span>
<span class="fc" id="L249">                            imgY = -1 * imgY - 1;</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="fc" id="L251">                            int diff = imgY - input.getHeight();</span>
<span class="fc" id="L252">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="fc" id="L255">                        int rPixel = input.getR(imgX, imgY);</span>
<span class="fc" id="L256">                        int gPixel = input.getG(imgX, imgY);</span>
<span class="fc" id="L257">                        int bPixel = input.getB(imgX, imgY);</span>

<span class="fc" id="L259">                        int k = kernel.getValue(col, row);</span>

<span class="fc" id="L261">                        rValue += k * rPixel;</span>
<span class="fc" id="L262">                        gValue += k * gPixel;</span>
<span class="fc" id="L263">                        bValue += k * bPixel;</span>
                    }
                }

<span class="fc" id="L267">                rValue *= normFactor;</span>
<span class="fc" id="L268">                gValue *= normFactor;</span>
<span class="fc" id="L269">                bValue *= normFactor;</span>

                /*
                if ((rValue &gt; 255) || (rValue &lt; 0)) {
                    throw new IllegalStateException(&quot;rValue is &quot; + rValue);
                }
                if ((gValue &gt; 255) || (gValue &lt; 0)) {
                    throw new IllegalStateException(&quot;gValue is &quot; + gValue);
                }
                if ((bValue &gt; 255) || (bValue &lt; 0)) {
                    throw new IllegalStateException(&quot;bValue is &quot; + bValue);
                }*/

<span class="fc bfc" id="L282" title="All 2 branches covered.">                if (rValue &lt; 0) {</span>
<span class="fc" id="L283">                    rValue = 0;</span>
                }
<span class="fc bfc" id="L285" title="All 2 branches covered.">                if (rValue &gt; 255) {</span>
<span class="fc" id="L286">                    rValue = 255;</span>
                }
<span class="fc bfc" id="L288" title="All 2 branches covered.">                if (gValue &lt; 0) {</span>
<span class="fc" id="L289">                    gValue = 0;</span>
                }
<span class="fc bfc" id="L291" title="All 2 branches covered.">                if (gValue &gt; 255) {</span>
<span class="fc" id="L292">                    gValue = 255;</span>
                }
<span class="fc bfc" id="L294" title="All 2 branches covered.">                if (bValue &lt; 0) {</span>
<span class="fc" id="L295">                    bValue = 0;</span>
                }
<span class="fc bfc" id="L297" title="All 2 branches covered.">                if (bValue &gt; 255) {</span>
<span class="fc" id="L298">                    bValue = 255;</span>
                }

<span class="fc" id="L301">                output.setRGB(i, j, (int)rValue, (int)gValue, (int)bValue);</span>
            }
        }

<span class="fc" id="L305">        input.resetTo(output);</span>
<span class="fc" id="L306">    }</span>

    /**
     * apply kernel to input. NOTE, that because the image is composed of vectors
     * that should have values between 0 and 255, inclusive, if the kernel application
     * results in a value outside of that range, the value is reset to 0 or
     * 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(GreyscaleImage input, Kernel kernel, float normFactor) {

<span class="nc" id="L319">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="nc" id="L321">        GreyscaleImage output = input.createWithDimensions();</span>

        //TODO: consider changing normalization to be similar to Kernel1DHelper

<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="nc" id="L328">                long value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L332" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="nc" id="L334">                    int x = col - h;</span>

<span class="nc" id="L336">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L339" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L340">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="nc" id="L342">                        int diff = imgX - input.getWidth();</span>
<span class="nc" id="L343">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="nc bnc" id="L346" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="nc" id="L348">                        int y = row - h;</span>

<span class="nc" id="L350">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L353" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L354">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="nc" id="L356">                            int diff = imgY - input.getHeight();</span>
<span class="nc" id="L357">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="nc" id="L360">                        int pixel = input.getValue(imgX, imgY);</span>
<span class="nc" id="L361">                        int k = kernel.getValue(col, row);</span>

<span class="nc" id="L363">                        value += k * pixel;</span>
                    }
                }

<span class="nc" id="L367">                value *= normFactor;</span>

<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (value &lt; 0) {</span>
<span class="nc" id="L370">                    value = 0;</span>
                }
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (value &gt; 255) {</span>
<span class="nc" id="L373">                    value = 255;</span>
                }
<span class="nc" id="L375">                output.setValue(i, j, (int)value);</span>
            }
        }

<span class="nc" id="L379">        input.resetTo(output);</span>
<span class="nc" id="L380">    }</span>

    public GreyscaleImage computeTheta(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="fc" id="L385">        GreyscaleImage output = convolvedX.createSignedWithDimensions();</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L390">                double gX = convolvedX.getValue(i, j);</span>

<span class="fc" id="L392">                double gY = convolvedY.getValue(i, j);</span>

<span class="fc" id="L394">                int thetaG = calculateTheta(gX, gY);</span>

<span class="fc" id="L396">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="fc" id="L401">        return output;</span>
    }
    
    public GreyscaleImage computeTheta360_0(final GreyscaleImage gradientX,
        final GreyscaleImage gradientY) {

<span class="fc" id="L407">        GreyscaleImage output = gradientX.createSignedWithDimensions();</span>

<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (int i = 0; i &lt; gradientX.getWidth(); i++) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">            for (int j = 0; j &lt; gradientX.getHeight(); j++) {</span>

<span class="fc" id="L412">                double gX = gradientX.getValue(i, j);</span>

<span class="fc" id="L414">                double gY = gradientY.getValue(i, j);</span>

                // -pi to pi radians
<span class="fc" id="L417">                double theta = Math.atan2(gY, gX);</span>
                
                // transform to 0 to 2*pi radians
<span class="fc bfc" id="L420" title="All 2 branches covered.">                if (theta &lt; 0) {</span>
<span class="fc" id="L421">                    theta += 2. * Math.PI;</span>
                }

<span class="fc" id="L424">                int d = (int)Math.round(theta * 180./Math.PI);</span>
                
<span class="fc" id="L426">                output.setValue(i, j, d);</span>
            }
        }

<span class="fc" id="L430">        return output;</span>
    }

    /**
     * compute theta as a polar angle that increases in a clockwise manner
     * and has a range from 0 to 359, inclusive.
     *
     * @param convolvedX
     * @param convolvedY
     * @return
     */
    public GreyscaleImage computeTheta360(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="nc" id="L444">        GreyscaleImage output = convolvedX.createFullRangeIntWithDimensions();</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="nc" id="L449">                double gX = convolvedX.getValue(i, j);</span>

<span class="nc" id="L451">                double gY = convolvedY.getValue(i, j);</span>

<span class="nc" id="L453">                double thetaR = (2. * Math.PI) - AngleUtil.polarAngleCCW(gX, gY);</span>

<span class="nc" id="L455">                int thetaG = (int)Math.round(thetaR * 180./Math.PI);</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (thetaG &gt; 359) {</span>
<span class="nc" id="L458">                    thetaG = thetaG - 360;</span>
                }

<span class="nc" id="L461">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="nc" id="L466">        return output;</span>
    }

    public GreyscaleImage subtractImages(final GreyscaleImage image,
        final GreyscaleImage subtrImage) {

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (image.getWidth() != subtrImage.getWidth()) {</span>
<span class="nc" id="L473">            throw new IllegalArgumentException(&quot;image widths must be the same&quot;);</span>
        }
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (image.getHeight() != subtrImage.getHeight()) {</span>
<span class="nc" id="L476">            throw new IllegalArgumentException(&quot;image heights must be the same&quot;);</span>
        }

<span class="fc" id="L479">        GreyscaleImage output = image.createSignedWithDimensions();</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">        for (int i = 0; i &lt; image.getWidth(); i++) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">            for (int j = 0; j &lt; image.getHeight(); j++) {</span>

<span class="fc" id="L484">                int diff = image.getValue(i, j) - subtrImage.getValue(i, j);</span>

<span class="fc" id="L486">                output.setValue(i, j, diff);</span>
            }
        }

<span class="fc" id="L490">        return output;</span>
    }

    protected int calculateTheta(double gradientX, double gradientY) {

        /*  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45

           when X is 0: if Y &gt; 0, theta is 90
           when Y is 0: if X &gt;= 0, theta is 0
        */

<span class="fc bfc" id="L505" title="All 4 branches covered.">        if (gradientX == 0 &amp;&amp; (gradientY != 0)) {</span>
<span class="fc" id="L506">            return 90;</span>
        }

<span class="fc bfc" id="L509" title="All 2 branches covered.">        if (gradientY == 0) {</span>
<span class="fc" id="L510">            return 0;</span>
        }

<span class="fc" id="L513">        double div = gradientY/gradientX;</span>

<span class="fc" id="L515">        double theta = Math.atan(div)*180./Math.PI;</span>

<span class="fc" id="L517">        int angle = (int)theta;</span>

        // +x, +y -&gt; +
        // -x, +y -&gt; -
        // -x, -y -&gt; +
        // +x, -y -&gt; -

<span class="fc bfc" id="L524" title="All 4 branches covered.">        if (!(gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L527">                angle *= -1;</span>
            }
<span class="fc bfc" id="L529" title="All 4 branches covered.">        } else if ((gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="fc" id="L532">                angle *= -1;</span>
            }
<span class="pc bpc" id="L534" title="1 of 4 branches missed.">        } else if ((gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L537">                angle *= -1;</span>
            }
<span class="pc bpc" id="L539" title="2 of 4 branches missed.">        } else if (!(gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="fc" id="L542">                angle *= -1;</span>
            }
        }

<span class="fc" id="L546">        return angle;</span>
    }

    /**
     * images bounded by zero's have to be shrunk to the columns and rows
     * of the first non-zeroes in order to keep the lines that should be
     * attached to the image edges from eroding completely.
     * Note, this expects image has values only non-negative numbers.
     * @param input
     * @return
     */
    public int[] shrinkImageToFirstNonZeros(final GreyscaleImage input) {

<span class="fc" id="L559">        int w = input.getWidth();</span>
<span class="fc" id="L560">        int h = input.getHeight();</span>

<span class="fc" id="L562">        int xNZFirst = -1;</span>
<span class="fc" id="L563">        int xNZLast = -1;</span>
<span class="fc" id="L564">        int yNZFirst = -1;</span>
<span class="fc" id="L565">        int yNZLast = -1;</span>

<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L569">                int pixValue = input.getValue(i, j);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                if (pixValue &gt; 0) {</span>
<span class="fc" id="L571">                    xNZFirst = i;</span>
<span class="fc" id="L572">                    break;</span>
                }
            }
<span class="fc bfc" id="L575" title="All 2 branches covered.">            if (xNZFirst &gt; -1) {</span>
<span class="fc" id="L576">                break;</span>
            }
        }
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">            for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L581">                int pixValue = input.getValue(i, j);</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                if (pixValue &gt; 0) {</span>
<span class="fc" id="L583">                    yNZFirst = j;</span>
<span class="fc" id="L584">                    break;</span>
                }
            }
<span class="fc bfc" id="L587" title="All 2 branches covered.">            if (yNZFirst &gt; -1) {</span>
<span class="fc" id="L588">                break;</span>
            }
        }

<span class="pc bpc" id="L592" title="1 of 2 branches missed.">        for (int i = (w - 1); i &gt; -1; i--) {</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            for (int j = (h - 1); j &gt; -1; j--) {</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (input.getValue(i, j) &gt; 0) {</span>
<span class="fc" id="L595">                    xNZLast = i;</span>
<span class="fc" id="L596">                    break;</span>
                }
            }
<span class="fc bfc" id="L599" title="All 2 branches covered.">            if (xNZLast &gt; -1) {</span>
<span class="fc" id="L600">                break;</span>
            }
        }

<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        for (int j = (h - 1); j &gt; -1; j--) {</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">            for (int i = (w - 1); i &gt; -1; i--) {</span>
<span class="fc" id="L606">                int pixValue = input.getValue(i, j);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                if (pixValue &gt; 0) {</span>
<span class="fc" id="L608">                    yNZLast = j;</span>
<span class="fc" id="L609">                    break;</span>
                }
            }
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (yNZLast &gt; -1) {</span>
<span class="fc" id="L613">                break;</span>
            }
        }

<span class="pc bpc" id="L617" title="1 of 8 branches missed.">        if ((xNZFirst &gt; 0) || (xNZLast &lt; (w - 1)) || (yNZFirst &gt; 0) ||</span>
            (yNZLast &lt; (h - 1))) {

            //add a 2 pix border
<span class="fc" id="L621">            xNZFirst -= 2;</span>
<span class="fc" id="L622">            yNZFirst -= 2;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            if (xNZFirst &lt; 0) {</span>
<span class="fc" id="L624">                xNZFirst = 0;</span>
            }
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (yNZFirst &lt; 0) {</span>
<span class="fc" id="L627">                yNZFirst = 0;</span>
            }
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">            if (xNZLast == -1) {</span>
<span class="nc" id="L630">                xNZLast = input.getWidth() - 1;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">            } else if (xNZLast &lt; (input.getWidth() - 2)) {</span>
                // add a 1 pix border
<span class="fc" id="L633">                xNZLast += 2;</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            } else if (xNZLast &lt; (input.getWidth() - 1)) {</span>
                // add a 1 pix border
<span class="fc" id="L636">                xNZLast++;</span>
            }
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">            if (yNZLast == -1) {</span>
<span class="nc" id="L639">                yNZLast = input.getHeight() - 1;</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">            } else if (yNZLast &lt; (input.getHeight() - 2)) {</span>
                // add a 1 pix border
<span class="fc" id="L642">                yNZLast += 2;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">            } else if (yNZLast &lt; (input.getHeight() - 1)) {</span>
                // add a 1 pix border
<span class="fc" id="L645">                yNZLast++;</span>
            }

<span class="fc" id="L648">            int xLen = xNZLast - xNZFirst + 1;</span>

<span class="fc" id="L650">            int yLen = yNZLast - yNZFirst + 1;</span>

<span class="fc" id="L652">            GreyscaleImage output = new GreyscaleImage(xLen, yLen, input.getType());</span>
<span class="fc" id="L653">            output.setXRelativeOffset(xNZFirst);</span>
<span class="fc" id="L654">            output.setYRelativeOffset(yNZFirst);</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">            for (int i = xNZFirst; i &lt;= xNZLast; i++) {</span>

<span class="fc" id="L658">                int iIdx = i - xNZFirst;</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">                for (int j = yNZFirst; j &lt;= yNZLast; j++) {</span>

<span class="fc" id="L662">                    int jIdx = j - yNZFirst;</span>

<span class="fc" id="L664">                    output.setValue(iIdx, jIdx, input.getValue(i, j));</span>
                }
            }

<span class="fc" id="L668">            input.resetTo(output);</span>

<span class="fc" id="L670">            return new int[]{xNZFirst, yNZFirst};</span>
        }

<span class="fc" id="L673">        return new int[]{0, 0};</span>
    }

    public void shrinkImage(final GreyscaleImage input,
        int[] offsetsAndDimensions) {

<span class="nc" id="L679">        int w2 = offsetsAndDimensions[2];</span>
<span class="nc" id="L680">        int h2 = offsetsAndDimensions[3];</span>

<span class="nc" id="L682">        int offset1X = offsetsAndDimensions[0];</span>
<span class="nc" id="L683">        int offset1Y = offsetsAndDimensions[1];</span>

<span class="nc" id="L685">        GreyscaleImage output = new GreyscaleImage(w2, h2, input.getType());</span>
<span class="nc" id="L686">        output.setXRelativeOffset(offset1X);</span>
<span class="nc" id="L687">        output.setYRelativeOffset(offset1Y);</span>

<span class="nc" id="L689">        int x = 0;</span>

<span class="nc" id="L691">        int endCol = (offset1X + w2);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (endCol &gt; input.getWidth()) {</span>
<span class="nc" id="L693">            endCol = input.getWidth();</span>
        }
<span class="nc" id="L695">        int endRow =  (offset1Y + h2);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (endRow &gt; input.getHeight()) {</span>
<span class="nc" id="L697">            endRow = input.getHeight();</span>
        }

<span class="nc bnc" id="L700" title="All 2 branches missed.">        for (int col = offset1X; col &lt; endCol; col++) {</span>

<span class="nc" id="L702">            int y = 0;</span>

<span class="nc bnc" id="L704" title="All 2 branches missed.">            for (int row = offset1Y; row &lt; endRow; row++) {</span>

<span class="nc" id="L706">                int v = input.getValue(col, row);</span>

<span class="nc" id="L708">                output.setValue(x, y, v);</span>

<span class="nc" id="L710">                y++;</span>
            }

<span class="nc" id="L713">            x++;</span>
        }

<span class="nc" id="L716">        input.resetTo(output);</span>
<span class="nc" id="L717">    }</span>

    /**
     * change coordinates of the input as if they were cropped to the given
     * offset and dimensions.
     * @param input
     * @param offsetsAndDimensions int[]{xOffset, yOffset, finalWidth, finalHeight}
     */
    public void shrinkImage(final Set&lt;PairInt&gt; input,
        int[] offsetsAndDimensions) {

        /*
          -------        ____
          |     |  ==&gt;  |    |
          |     |       |____|
          -------
        */
        //xOffset, yOffset, width, height
        // subtract xOffset from x in input and yOffset from y in input

        //TODO: remove points out of bounds of final image

<span class="nc bnc" id="L739" title="All 2 branches missed.">        for (PairInt p : input) {</span>
<span class="nc" id="L740">            p.setX(p.getX() - offsetsAndDimensions[0]);</span>
<span class="nc" id="L741">            p.setY(p.getY() - offsetsAndDimensions[1]);</span>
<span class="nc" id="L742">        }</span>

<span class="nc" id="L744">    }</span>

    /**
     * change coordinates of the input as if they were cropped to the given
     * offset and dimensions.
     * @param input
     * @param offsetsAndDimensions int[]{xOffset, yOffset, finalWidth, finalHeight}
     */
    public void shrinkImage(final PairIntArray input,
        int[] offsetsAndDimensions) {

        /*
          -------        ____
          |     |  ==&gt;  |    |
          |     |       |____|
          -------
        */
        //xOffset, yOffset, width, height
        // subtract xOffset from x in input and yOffset from y in input

        //TODO: remove points out of bounds of final image

<span class="nc bnc" id="L766" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getN(); ++i) {</span>
<span class="nc" id="L767">            int x = input.getX(i) - offsetsAndDimensions[0];</span>
<span class="nc" id="L768">            int y = input.getY(i) - offsetsAndDimensions[1];</span>
<span class="nc" id="L769">            input.set(i, x, y);</span>
        }

<span class="nc" id="L772">    }</span>

    public void convertToBinaryImage(GreyscaleImage input) {
<span class="nc bnc" id="L775" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="nc" id="L777">                int v = input.getValue(col, row);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L779">                    input.setValue(col, row, 1);</span>
                }
            }
        }
<span class="nc" id="L783">    }</span>

    /**
     * NOT READY FOR USE YET.
     *
     * @param theta
     * @return
     * @throws java.io.IOException
     * @throws java.security.NoSuchAlgorithmException
     */
    public GreyscaleImage createRoughSkyMask(GreyscaleImage theta) throws
        IOException, NoSuchAlgorithmException {

<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (theta == null) {</span>
<span class="nc" id="L797">            throw new IllegalArgumentException(&quot;theta cannot be null&quot;);</span>
        }

<span class="nc" id="L800">        theta = theta.copyImage();</span>

<span class="nc" id="L802">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
<span class="nc" id="L803">        imageSegmentation.applyUsingKMPP(theta, 2);</span>

<span class="nc" id="L805">        subtractMinimum(theta);</span>

<span class="nc" id="L807">        convertToBinaryImage(theta);</span>

<span class="nc" id="L809">        removeSpurs(theta);</span>

<span class="nc" id="L811">        throw new UnsupportedOperationException(&quot;not ready for use yet&quot;);</span>
        //return theta;
    }

    public void subtractMinimum(GreyscaleImage input) {

<span class="nc" id="L817">        int min = input.getMin();</span>
        
<span class="nc bnc" id="L819" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc bnc" id="L821" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="nc" id="L823">                int v = input.getValue(col, row);</span>

<span class="nc" id="L825">                int f = v - min;</span>

<span class="nc" id="L827">                input.setValue(col, row, f);</span>
            }
        }
<span class="nc" id="L830">    }</span>

    /**
     * multiply these images, that is pixel by pixel multiplication.
     * input2 is assumed to be 0 or 1
     * @param input1
     * @param input2 the mask of 0's and 1's to apply to input1
     */
    public void multiplyBinary(Image input1, GreyscaleImage input2)  {

<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (input1 == null) {</span>
<span class="nc" id="L841">            throw new IllegalArgumentException(&quot;input1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L843" title="All 2 branches missed.">        if (input2 == null) {</span>
<span class="nc" id="L844">            throw new IllegalArgumentException(&quot;input2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (input1.getWidth() != input2.getWidth()) {</span>
<span class="nc" id="L847">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same widths&quot;);
        }
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (input1.getHeight()!= input2.getHeight()) {</span>
<span class="nc" id="L851">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same heights&quot;);
        }

<span class="nc bnc" id="L855" title="All 2 branches missed.">        for (int col = 0; col &lt; input1.getWidth(); col++) {</span>

<span class="nc bnc" id="L857" title="All 2 branches missed.">            for (int row = 0; row &lt; input1.getHeight(); row++) {</span>

<span class="nc" id="L859">                int m = input2.getValue(col, row);</span>

<span class="nc bnc" id="L861" title="All 2 branches missed.">                if (m == 0) {</span>

<span class="nc" id="L863">                    input1.setRGB(col, row, 0, 0, 0);</span>
                }
            }
        }
<span class="nc" id="L867">    }</span>

    /**
     * compare each pixel and set output to 0 if both inputs are 0, else set
     * output to 1.
     * @param input1
     * @param input2
     * @return
     */
    public GreyscaleImage binaryOr(GreyscaleImage input1, GreyscaleImage input2)  {

<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (input1 == null) {</span>
<span class="nc" id="L879">            throw new IllegalArgumentException(&quot;input1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L881" title="All 2 branches missed.">        if (input2 == null) {</span>
<span class="nc" id="L882">            throw new IllegalArgumentException(&quot;input2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (input1.getWidth() != input2.getWidth()) {</span>
<span class="nc" id="L885">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same widths&quot;);
        }
<span class="nc bnc" id="L888" title="All 2 branches missed.">        if (input1.getHeight()!= input2.getHeight()) {</span>
<span class="nc" id="L889">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same heights&quot;);
        }

<span class="nc" id="L893">        GreyscaleImage output = input1.createWithDimensions();</span>

<span class="nc bnc" id="L895" title="All 2 branches missed.">        for (int col = 0; col &lt; input1.getWidth(); col++) {</span>

<span class="nc bnc" id="L897" title="All 2 branches missed.">            for (int row = 0; row &lt; input1.getHeight(); row++) {</span>

<span class="nc" id="L899">                int v1 = input1.getValue(col, row);</span>

<span class="nc" id="L901">                int v2 = input2.getValue(col, row);</span>

<span class="nc bnc" id="L903" title="All 4 branches missed.">                if ((v1 != 0) || (v2 != 0)) {</span>
<span class="nc" id="L904">                    output.setValue(col, row, 1);</span>
                }
            }
        }

<span class="nc" id="L909">        return output;</span>
    }

    protected void blur(GreyscaleImage input, float[] kernel) {

<span class="fc" id="L914">        applyKernel1D(input, kernel, true);</span>

<span class="fc" id="L916">        applyKernel1D(input, kernel, false);</span>
<span class="fc" id="L917">    }</span>

    public void blur(GreyscaleImage input, float sigma) {

<span class="fc" id="L921">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L923">        blur(input, kernel);</span>
<span class="fc" id="L924">    }</span>

    public void blur(GreyscaleImage input, SIGMA sigma) {

<span class="fc" id="L928">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L930">        blur(input, kernel);</span>
<span class="fc" id="L931">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, float sigma) {

<span class="fc" id="L940">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L942">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L944">        int w = input.getWidth();</span>
<span class="fc" id="L945">        int h = input.getHeight();</span>
<span class="fc" id="L946">        Image output = input.copyImage();</span>

<span class="fc bfc" id="L948" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L950">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="fc" id="L952">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="fc" id="L956">        input.resetTo(output);</span>

<span class="fc bfc" id="L958" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L960">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="fc" id="L962">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="fc" id="L966">        input.resetTo(output);</span>
<span class="fc" id="L967">    }</span>
    
    public void applyFirstDerivGaussian(GreyscaleImage input, SIGMA sigma,
        int minValueRange, int maxValueRange) {

<span class="nc" id="L972">        float[] kernel = Gaussian1DFirstDeriv.getBinomialKernel(sigma);</span>

<span class="nc" id="L974">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L976">        int w = input.getWidth();</span>
<span class="nc" id="L977">        int h = input.getHeight();</span>
<span class="nc" id="L978">        GreyscaleImage output = input.copyImage();</span>

<span class="nc bnc" id="L980" title="All 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
                
<span class="nc" id="L983">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
                
<span class="nc" id="L986">                int v = (int)Math.round(conv);</span>
                
<span class="nc bnc" id="L988" title="All 2 branches missed.">                if (v &lt; minValueRange) {</span>
<span class="nc" id="L989">                    v = minValueRange;</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L991">                    v = maxValueRange;</span>
                }
                
<span class="nc" id="L994">                output.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L998">        input.resetTo(output);</span>

<span class="nc bnc" id="L1000" title="All 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            for (int j = 0; j &lt; h; j++) {</span>
                
<span class="nc" id="L1003">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
                
<span class="nc" id="L1006">                int v = (int)Math.round(conv);</span>
                
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                if (v &lt; minValueRange) {</span>
<span class="nc" id="L1009">                    v = minValueRange;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1011">                    v = maxValueRange;</span>
                }
                
<span class="nc" id="L1014">                output.setValue(i, j, v);</span>
            }
        }

<span class="nc" id="L1018">        input.resetTo(output);</span>
<span class="nc" id="L1019">    }</span>
    
    public void applySecondDerivGaussian(GreyscaleImage input, SIGMA sigma,
        int minValueRange, int maxValueRange) {

<span class="fc" id="L1024">        float[] kernel = Gaussian1DSecondDeriv.getBinomialKernel(sigma);</span>

<span class="fc" id="L1026">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1028">        int w = input.getWidth();</span>
<span class="fc" id="L1029">        int h = input.getHeight();</span>
<span class="fc" id="L1030">        GreyscaleImage output = input.copyImage();</span>

<span class="fc bfc" id="L1032" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
                
<span class="fc" id="L1035">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
                
<span class="fc" id="L1038">                int v = (int)Math.round(conv);</span>
                
<span class="fc bfc" id="L1040" title="All 2 branches covered.">                if (v &lt; minValueRange) {</span>
<span class="fc" id="L1041">                    v = minValueRange;</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1043">                    v = maxValueRange;</span>
                }
                
<span class="fc" id="L1046">                output.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L1050">        input.resetTo(output);</span>

<span class="fc bfc" id="L1052" title="All 2 branches covered.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L1053" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
                
<span class="fc" id="L1055">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
                
<span class="fc" id="L1058">                int v = (int)Math.round(conv);</span>
                
<span class="fc bfc" id="L1060" title="All 2 branches covered.">                if (v &lt; minValueRange) {</span>
<span class="fc" id="L1061">                    v = minValueRange;</span>
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">                } else if (v &gt; maxValueRange) {</span>
<span class="nc" id="L1063">                    v = maxValueRange;</span>
                }
                
<span class="fc" id="L1066">                output.setValue(i, j, v);</span>
            }
        }

<span class="fc" id="L1070">        input.resetTo(output);</span>
<span class="fc" id="L1071">    }</span>

    public void applyKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX) {

<span class="fc" id="L1076">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="fc" id="L1078">        GreyscaleImage output = input.createWithDimensions();</span>

<span class="fc bfc" id="L1080" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="fc" id="L1082">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="fc" id="L1084">                int g = (int)Math.round(conv);</span>
<span class="fc" id="L1085">                output.setValue(i, j, g);</span>
            }
        }

<span class="fc" id="L1089">        input.resetTo(output);</span>
<span class="fc" id="L1090">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param kernel iD kernel
     */
    protected void blur(Image input, float[] kernel) {

<span class="nc" id="L1099">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1101">        int w = input.getWidth();</span>
<span class="nc" id="L1102">        int h = input.getHeight();</span>
<span class="nc" id="L1103">        Image output = (ImageExt)input.copyImage();</span>

<span class="nc bnc" id="L1105" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1107">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="nc" id="L1109">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1113">        input.resetTo(output);</span>

<span class="nc bnc" id="L1115" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1117">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="nc" id="L1119">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1123">        input.resetTo(output);</span>
<span class="nc" id="L1124">    }</span>

    public void divideByBlurredSelf(GreyscaleImage input, float sigma) {

<span class="nc" id="L1128">        GreyscaleImage input2 = input.copyImage();</span>

<span class="nc" id="L1130">        blur(input, sigma);</span>

<span class="nc bnc" id="L1132" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1134">                int v = input.getValue(i, j);</span>
<span class="nc" id="L1135">                int vorig = input2.getValue(i, j);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L1137">                    float r = (float)vorig/(float)v;</span>
<span class="nc" id="L1138">                    input.setValue(i, j, (int)(100*r));</span>
                }
            }
        }
<span class="nc" id="L1142">    }</span>

    /**
     * make a binary mask with the given zeroCoords as a group of starter points
     * for the mask and also set to '0' any points within zeroCoords' bounds.
     *
     * @param theta
     * @param zeroCoords
     * @return
     */
    public GreyscaleImage createMask(GreyscaleImage theta, PairIntArray zeroCoords) {

<span class="nc" id="L1154">        GreyscaleImage out = theta.createWithDimensions();</span>

<span class="nc" id="L1156">        out.fill(1);</span>

<span class="nc bnc" id="L1158" title="All 2 branches missed.">        for (int pIdx = 0; pIdx &lt; zeroCoords.getN(); pIdx++) {</span>

<span class="nc" id="L1160">            int x = zeroCoords.getX(pIdx);</span>
<span class="nc" id="L1161">            int y = zeroCoords.getY(pIdx);</span>
<span class="nc" id="L1162">            out.setValue(x, y, 0);</span>
        }

<span class="nc" id="L1165">        return out;</span>
    }

    /**
     * make a binary mask with the given zeroCoords as a group of starter points
     * for the mask and also set to '0' any points within zeroCoords' bounds.
     *
     * @param theta
     * @param nonzeroCoords
     * @return
     */
    public GreyscaleImage createInvMask(GreyscaleImage theta,
        PairIntArray nonzeroCoords) {

<span class="nc" id="L1179">        GreyscaleImage out = theta.createWithDimensions();</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">        for (int pIdx = 0; pIdx &lt; nonzeroCoords.getN(); pIdx++) {</span>

<span class="nc" id="L1183">            int x = nonzeroCoords.getX(pIdx);</span>
<span class="nc" id="L1184">            int y = nonzeroCoords.getY(pIdx);</span>
<span class="nc" id="L1185">            out.setValue(x, y, 1);</span>
        }

<span class="nc" id="L1188">        return out;</span>
    }

    /**
     * this is meant to operate on an image with only 0's and 1's
     * @param input
     */
    public void removeSpurs(GreyscaleImage input) {

<span class="fc" id="L1197">        int width = input.getWidth();</span>
<span class="fc" id="L1198">        int height = input.getHeight();</span>

<span class="fc" id="L1200">        int nIterMax = 1000;</span>
<span class="fc" id="L1201">        int nIter = 0;</span>
<span class="fc" id="L1202">        int numRemoved = 1;</span>

<span class="pc bpc" id="L1204" title="1 of 4 branches missed.">        while ((nIter &lt; nIterMax) &amp;&amp; (numRemoved &gt; 0)) {</span>

<span class="fc" id="L1206">            numRemoved = 0;</span>

<span class="fc bfc" id="L1208" title="All 2 branches covered.">            for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="fc bfc" id="L1210" title="All 4 branches covered.">                if ((col &lt; 2) || (col &gt; (width - 3))) {</span>
<span class="fc" id="L1211">                    continue;</span>
                }

<span class="fc bfc" id="L1214" title="All 2 branches covered.">                for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="fc bfc" id="L1216" title="All 4 branches covered.">                    if ((row &lt; 2) || (row &gt; (height - 3))) {</span>
<span class="fc" id="L1217">                       continue;</span>
                    }

<span class="fc" id="L1220">                    int v = input.getValue(col, row);</span>

<span class="fc bfc" id="L1222" title="All 2 branches covered.">                    if (v == 0) {</span>
<span class="fc" id="L1223">                        continue;</span>
                    }

                    // looking for pixels having only one neighbor who subsequently
                    // has only 1 or 2 neighbors
                    // as long as neither are connected to image boundaries

<span class="fc" id="L1230">                    int neighborIdx = getIndexIfOnlyOneNeighbor(input, col, row);</span>

<span class="fc bfc" id="L1232" title="All 2 branches covered.">                    if (neighborIdx &gt; -1) {</span>
<span class="fc" id="L1233">                        int neighborX = input.getCol(neighborIdx);</span>
<span class="fc" id="L1234">                        int neighborY = input.getRow(neighborIdx);</span>

<span class="fc" id="L1236">                        int nn = count8RegionNeighbors(input, neighborX, neighborY);</span>

<span class="fc bfc" id="L1238" title="All 2 branches covered.">                        if (nn &lt;= 2) {</span>
<span class="fc" id="L1239">                            input.setValue(col, row, 0);</span>
<span class="fc" id="L1240">                            numRemoved++;</span>
                        }
<span class="fc" id="L1242">                    } else {</span>
<span class="fc" id="L1243">                        int n = count8RegionNeighbors(input, col, row);</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">                        if (n == 0) {</span>
<span class="fc" id="L1245">                            input.setValue(col, row, 0);</span>
<span class="fc" id="L1246">                            numRemoved++;</span>
                        }
                    }
                }
            }

<span class="fc" id="L1252">            log.fine(&quot;numRemoved=&quot; + numRemoved + &quot; nIter=&quot; + nIter);</span>

<span class="fc" id="L1254">            nIter++;</span>
        }

<span class="fc" id="L1257">    }</span>

    public void removeSpurs(Set&lt;PairInt&gt; points, int width, int height) {

<span class="nc" id="L1261">        int nIterMax = 1000;</span>
<span class="nc" id="L1262">        int nIter = 0;</span>
<span class="nc" id="L1263">        int numRemoved = 1;</span>

<span class="nc bnc" id="L1265" title="All 4 branches missed.">        while ((nIter &lt; nIterMax) &amp;&amp; (numRemoved &gt; 0)) {</span>

<span class="nc" id="L1267">            numRemoved = 0;</span>

<span class="nc" id="L1269">            Set&lt;PairInt&gt; rm = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1271" title="All 2 branches missed.">            for (PairInt p : points) {</span>

                // looking for pixels having only one neighbor who subsequently
                // has only 1 or 2 neighbors
                // as long as neither are connected to image boundaries

<span class="nc" id="L1277">                PairInt neighbor = getIndexIfOnlyOneNeighbor(points, p,</span>
                    width, height);

<span class="nc bnc" id="L1280" title="All 2 branches missed.">                if (neighbor != null) {</span>

<span class="nc" id="L1282">                    int nn = count8RegionNeighbors(points, neighbor, width,</span>
                        height);

<span class="nc bnc" id="L1285" title="All 2 branches missed.">                    if (nn &lt;= 2) {</span>
<span class="nc" id="L1286">                        rm.add(p);</span>
<span class="nc" id="L1287">                        numRemoved++;</span>
                    }
<span class="nc" id="L1289">                } else {</span>
<span class="nc" id="L1290">                    int n = count8RegionNeighbors(points, p, width, height);</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                    if (n == 0) {</span>
<span class="nc" id="L1292">                        rm.add(p);</span>
<span class="nc" id="L1293">                        numRemoved++;</span>
                    }
                }
<span class="nc" id="L1296">            }</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">            for (PairInt p : rm) {</span>
<span class="nc" id="L1299">                points.remove(p);</span>
<span class="nc" id="L1300">            }</span>

<span class="nc" id="L1302">            log.fine(&quot;numRemoved=&quot; + numRemoved + &quot; nIter=&quot; + nIter);</span>

<span class="nc" id="L1304">            nIter++;</span>
<span class="nc" id="L1305">        }</span>

<span class="nc" id="L1307">    }</span>

    protected int count8RegionNeighbors(GreyscaleImage input, int x, int y) {

<span class="fc" id="L1311">        int width = input.getWidth();</span>
<span class="fc" id="L1312">        int height = input.getHeight();</span>

<span class="fc" id="L1314">        int count = 0;</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="pc bpc" id="L1316" title="2 of 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1317">                continue;</span>
            }
<span class="fc bfc" id="L1319" title="All 2 branches covered.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="pc bpc" id="L1320" title="2 of 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1321">                    continue;</span>
                }
<span class="fc bfc" id="L1323" title="All 4 branches covered.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="fc" id="L1324">                    continue;</span>
                }
<span class="fc" id="L1326">                int v = input.getValue(c, r);</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">                if (v &gt; 0) {</span>
<span class="fc" id="L1328">                    count++;</span>
                }
            }
        }

<span class="fc" id="L1333">        return count;</span>
    }

    protected int count8RegionNeighbors(Set&lt;PairInt&gt; points, PairInt point,
        int width, int height) {

<span class="nc" id="L1339">        int x = point.getX();</span>
<span class="nc" id="L1340">        int y = point.getY();</span>

<span class="nc" id="L1342">        int count = 0;</span>

<span class="nc bnc" id="L1344" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L1345" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1346">                continue;</span>
            }
<span class="nc bnc" id="L1348" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L1349" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1350">                    continue;</span>
                }
<span class="nc bnc" id="L1352" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L1353">                    continue;</span>
                }
<span class="nc" id="L1355">                PairInt tmp = new PairInt(c, r);</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">                if (points.contains(tmp)) {</span>
<span class="nc" id="L1357">                    count++;</span>
                }
            }
        }

<span class="nc" id="L1362">        return count;</span>
    }

    protected int getIndexIfOnlyOneNeighbor(GreyscaleImage input, int x, int y) {

<span class="fc" id="L1367">        int width = input.getWidth();</span>
<span class="fc" id="L1368">        int height = input.getHeight();</span>

<span class="fc" id="L1370">        int count = 0;</span>
<span class="fc" id="L1371">        int xNeighbor = -1;</span>
<span class="fc" id="L1372">        int yNeighbor = -1;</span>

<span class="fc bfc" id="L1374" title="All 2 branches covered.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="pc bpc" id="L1375" title="2 of 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1376">                continue;</span>
            }
<span class="fc bfc" id="L1378" title="All 2 branches covered.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="pc bpc" id="L1379" title="2 of 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1380">                    continue;</span>
                }
<span class="fc bfc" id="L1382" title="All 4 branches covered.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="fc" id="L1383">                    continue;</span>
                }
<span class="fc" id="L1385">                int v = input.getValue(c, r);</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">                if (v &gt; 0) {</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">                    if (count &gt; 0) {</span>
<span class="fc" id="L1388">                        return -1;</span>
                    }
<span class="fc" id="L1390">                    xNeighbor = c;</span>
<span class="fc" id="L1391">                    yNeighbor = r;</span>
<span class="fc" id="L1392">                    count++;</span>
                }
            }
        }

<span class="fc bfc" id="L1397" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L1398">            return -1;</span>
        }

<span class="fc" id="L1401">        int index = input.getIndex(xNeighbor, yNeighbor);</span>

<span class="fc" id="L1403">        return index;</span>
    }

    protected PairInt getIndexIfOnlyOneNeighbor(Set&lt;PairInt&gt; points,
        PairInt point, int width, int height) {

<span class="nc" id="L1409">        int x = point.getX();</span>
<span class="nc" id="L1410">        int y = point.getY();</span>

<span class="nc" id="L1412">        int count = 0;</span>
<span class="nc" id="L1413">        PairInt neighbor = null;</span>

<span class="nc bnc" id="L1415" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L1416" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1417">                continue;</span>
            }
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L1420" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1421">                    continue;</span>
                }
<span class="nc bnc" id="L1423" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L1424">                    continue;</span>
                }
<span class="nc" id="L1426">                PairInt tmp = new PairInt(c, r);</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                if (points.contains(tmp)) {</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                    if (count &gt; 0) {</span>
<span class="nc" id="L1429">                        return null;</span>
                    }
<span class="nc" id="L1431">                    neighbor = tmp;</span>
<span class="nc" id="L1432">                    count++;</span>
                }
            }
        }

<span class="nc bnc" id="L1437" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1438">            return null;</span>
        }

<span class="nc" id="L1441">        return neighbor;</span>
    }

    /**
     * returns avg r, avg g, avg b
     * @param points
     * @param theta
     * @param originalImage
     * @param addAlongX
     * @param addAmount
     * @return
     */
    private int[] getAvgMinMaxColor(PairIntArray points, GreyscaleImage theta,
        Image originalImage, boolean addAlongX, int addAmount) {

<span class="nc" id="L1456">        int xOffset = theta.getXRelativeOffset();</span>
<span class="nc" id="L1457">        int yOffset = theta.getYRelativeOffset();</span>

<span class="nc" id="L1459">        double rSum = 0;</span>
<span class="nc" id="L1460">        double gSum = 0;</span>
<span class="nc" id="L1461">        double bSum = 0;</span>

<span class="nc" id="L1463">        int count = 0;</span>

<span class="nc bnc" id="L1465" title="All 2 branches missed.">        for (int pIdx = 0; pIdx &lt; points.getN(); pIdx++) {</span>

<span class="nc" id="L1467">            int x = points.getX(pIdx);</span>
<span class="nc" id="L1468">            int y = points.getY(pIdx);</span>

<span class="nc" id="L1470">            int ox = x + xOffset;</span>
<span class="nc" id="L1471">            int oy = y + yOffset;</span>

            //TODO: this may need corrections for other orientations
<span class="nc bnc" id="L1474" title="All 2 branches missed.">            if (addAlongX) {</span>
<span class="nc" id="L1475">                ox += addAmount;</span>
            } else {
<span class="nc" id="L1477">                oy += addAmount;</span>
            }

<span class="nc bnc" id="L1480" title="All 4 branches missed.">            if ((ox &lt; 0) || (ox &gt; (originalImage.getWidth() - 1))) {</span>
<span class="nc" id="L1481">                continue;</span>
            }
<span class="nc bnc" id="L1483" title="All 4 branches missed.">            if ((oy &lt; 0) || (oy &gt; (originalImage.getHeight() - 1))) {</span>
<span class="nc" id="L1484">                continue;</span>
            }

<span class="nc" id="L1487">            int rgb = originalImage.getRGB(ox, oy);</span>
<span class="nc" id="L1488">            int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L1489">            int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L1490">            int b = rgb &amp; 0xFF;</span>

<span class="nc" id="L1492">            rSum += r;</span>
<span class="nc" id="L1493">            gSum += g;</span>
<span class="nc" id="L1494">            bSum += b;</span>

<span class="nc" id="L1496">            count++;</span>
        }

<span class="nc bnc" id="L1499" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1500">            return new int[]{0, 0, 0};</span>
        }

<span class="nc" id="L1503">        rSum /= (double)count;</span>
<span class="nc" id="L1504">        gSum /= (double)count;</span>
<span class="nc" id="L1505">        bSum /= (double)count;</span>

<span class="nc" id="L1507">        return new int[]{(int)Math.round(rSum), (int)Math.round(gSum),</span>
<span class="nc" id="L1508">            (int)Math.round(bSum)};</span>
    }

    public void applyInvert255(GreyscaleImage img) {
        // assumption that pixels lie in range 0 to 255

<span class="nc bnc" id="L1514" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L1516">                int v = img.getValue(i, j);</span>
<span class="nc" id="L1517">                int vInv = 255 - v;</span>
<span class="nc" id="L1518">                img.setValue(i, j, vInv);</span>
            }
        }
<span class="nc" id="L1521">    }</span>

    public void applyInvert255(Image img) {
        // assumption that pixels lie in range 0 to 255

<span class="nc bnc" id="L1526" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L1528">                img.setRGB(i, j,</span>
<span class="nc" id="L1529">                    255 - img.getR(i, j),</span>
<span class="nc" id="L1530">                    255 - img.getG(i, j),</span>
<span class="nc" id="L1531">                    255 - img.getB(i, j));</span>
            }
        }
<span class="nc" id="L1534">    }</span>

    public GreyscaleImage binImageToKeepZeros(GreyscaleImage img,
        int binFactor) {

<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1540">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1543">        int w0 = img.getWidth();</span>
<span class="fc" id="L1544">        int h0 = img.getHeight();</span>

<span class="fc" id="L1546">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1547">        int h1 = h0/binFactor;</span>

<span class="fc" id="L1549">        GreyscaleImage out = new GreyscaleImage(w1, h1, img.getType());</span>
<span class="fc" id="L1550">        out.setXRelativeOffset(Math.round(img.getXRelativeOffset()/binFactor));</span>
<span class="fc" id="L1551">        out.setYRelativeOffset(Math.round(img.getYRelativeOffset()/binFactor));</span>

<span class="fc bfc" id="L1553" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1555" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1557">                int vSum = 0;</span>
<span class="fc" id="L1558">                int count = 0;</span>
<span class="fc" id="L1559">                boolean isZero = false;</span>

                // if there's a zero in the binFactor x binFactor block,
                // v is set to 0

<span class="fc bfc" id="L1564" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1565" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1567" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1568">                            continue;</span>
                        }
<span class="pc bpc" id="L1570" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1571">                            continue;</span>
                        }

<span class="fc" id="L1574">                        int v = img.getValue(ii, jj);</span>

<span class="fc bfc" id="L1576" title="All 2 branches covered.">                        if (v == 0) {</span>
<span class="fc" id="L1577">                            isZero = true;</span>
<span class="fc" id="L1578">                            vSum = 0;</span>
<span class="fc" id="L1579">                            break;</span>
                        }

<span class="fc" id="L1582">                        vSum += v;</span>
<span class="fc" id="L1583">                        count++;</span>
                    }
<span class="fc bfc" id="L1585" title="All 2 branches covered.">                    if (isZero) {</span>
<span class="fc" id="L1586">                        break;</span>
                    }
                }

<span class="fc bfc" id="L1590" title="All 2 branches covered.">                if (vSum &gt; 0) {</span>
<span class="fc" id="L1591">                    float v = (float)vSum/(float)count;</span>
<span class="fc" id="L1592">                    vSum = Math.round(v);</span>
                }

<span class="fc" id="L1595">                out.setValue(i, j, vSum);</span>
            }
        }

<span class="fc" id="L1599">        return out;</span>
    }

    public GreyscaleImage binImage(GreyscaleImage img, int binFactor) {

<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1605">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1608">        int w0 = img.getWidth();</span>
<span class="fc" id="L1609">        int h0 = img.getHeight();</span>

<span class="fc" id="L1611">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1612">        int h1 = h0/binFactor;</span>

<span class="fc" id="L1614">        GreyscaleImage out = new GreyscaleImage(w1, h1, img.getType());</span>
<span class="fc" id="L1615">        out.setXRelativeOffset(Math.round(img.getXRelativeOffset()/binFactor));</span>
<span class="fc" id="L1616">        out.setYRelativeOffset(Math.round(img.getYRelativeOffset()/binFactor));</span>

<span class="fc bfc" id="L1618" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1620" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1622">                int vSum = 0;</span>
<span class="fc" id="L1623">                int count = 0;</span>

<span class="fc bfc" id="L1625" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1626" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1628" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1629">                            continue;</span>
                        }
<span class="pc bpc" id="L1631" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1632">                            continue;</span>
                        }

<span class="fc" id="L1635">                        int v = img.getValue(ii, jj);</span>

<span class="fc" id="L1637">                        vSum += v;</span>
<span class="fc" id="L1638">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L1643">                    float v = (float)vSum/(float)count;</span>
<span class="fc" id="L1644">                    vSum = Math.round(v);</span>
                }

<span class="fc" id="L1647">                out.setValue(i, j, vSum);</span>
            }
        }

<span class="fc" id="L1651">        return out;</span>
    }

    public Image binImage(Image img,  int binFactor) {

<span class="pc bpc" id="L1656" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1657">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1660">        int w0 = img.getWidth();</span>
<span class="fc" id="L1661">        int h0 = img.getHeight();</span>

<span class="fc" id="L1663">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1664">        int h1 = h0/binFactor;</span>

<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">        Image out = new Image(w1, h1, !img.is64Bit);</span>

<span class="fc" id="L1668">        binImage(img, binFactor, out);</span>

<span class="fc" id="L1670">        return out;</span>
    }

    public ImageExt binImage(ImageExt img,  int binFactor) {

<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1676">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1679">        int w0 = img.getWidth();</span>
<span class="fc" id="L1680">        int h0 = img.getHeight();</span>

<span class="fc" id="L1682">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1683">        int h1 = h0/binFactor;</span>

<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">        ImageExt out = new ImageExt(w1, h1, !img.is64Bit);</span>

<span class="fc" id="L1687">        binImage(img, binFactor, out);</span>

<span class="fc" id="L1689">        return out;</span>
    }

    private void binImage(Image inputImg,  int binFactor, Image outputImg) {

<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">        if (inputImg == null) {</span>
<span class="nc" id="L1695">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1698">        int w0 = inputImg.getWidth();</span>
<span class="fc" id="L1699">        int h0 = inputImg.getHeight();</span>

<span class="fc" id="L1701">        int w1 = outputImg.getWidth();</span>
<span class="fc" id="L1702">        int h1 = outputImg.getHeight();</span>

<span class="fc bfc" id="L1704" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1706" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1708">                long rSum = 0;</span>
<span class="fc" id="L1709">                long gSum = 0;</span>
<span class="fc" id="L1710">                long bSum = 0;</span>

<span class="fc" id="L1712">                int count = 0;</span>

<span class="fc bfc" id="L1714" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1715" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1717" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1718">                            continue;</span>
                        }
<span class="pc bpc" id="L1720" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1721">                            continue;</span>
                        }

<span class="fc" id="L1724">                        int rgb = inputImg.getRGB(ii, jj);</span>

<span class="fc" id="L1726">                        int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="fc" id="L1727">                        int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="fc" id="L1728">                        int b = rgb &amp; 0xFF;</span>

<span class="fc" id="L1730">                        rSum += r;</span>
<span class="fc" id="L1731">                        gSum += g;</span>
<span class="fc" id="L1732">                        bSum += b;</span>

<span class="fc" id="L1734">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L1739">                    rSum = Math.round((float)rSum/(float)count);</span>
<span class="fc" id="L1740">                    gSum = Math.round((float)gSum/(float)count);</span>
<span class="fc" id="L1741">                    bSum = Math.round((float)bSum/(float)count);</span>
                }

<span class="fc" id="L1744">                outputImg.setRGB(i, j, (int)rSum, (int)gSum, (int)bSum);</span>
            }
        }
<span class="fc" id="L1747">    }</span>

    public GreyscaleImage unbinMask(GreyscaleImage mask, int binFactor,
        GreyscaleImage originalTheta) {

<span class="pc bpc" id="L1752" title="1 of 2 branches missed.">        if (mask == null) {</span>
<span class="nc" id="L1753">            throw new IllegalArgumentException(&quot;mask cannot be null&quot;);</span>
        }

<span class="pc bpc" id="L1756" title="1 of 2 branches missed.">        if (originalTheta == null) {</span>
<span class="nc" id="L1757">            throw new IllegalArgumentException(&quot;originalTheta cannot be null&quot;);</span>
        }

<span class="fc" id="L1760">        GreyscaleImage out = originalTheta.createWithDimensions();</span>

<span class="fc" id="L1762">        int w0 = mask.getWidth();</span>
<span class="fc" id="L1763">        int h0 = mask.getHeight();</span>

<span class="fc" id="L1765">        int w1 = out.getWidth();</span>
<span class="fc" id="L1766">        int h1 = out.getHeight();</span>

<span class="fc bfc" id="L1768" title="All 2 branches covered.">        for (int i = 0; i &lt; w0; i++) {</span>
<span class="fc bfc" id="L1769" title="All 2 branches covered.">            for (int j = 0; j &lt; h0; j++) {</span>

<span class="fc" id="L1771">                int v = mask.getValue(i, j);</span>

<span class="fc bfc" id="L1773" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1774" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="fc" id="L1775">                        out.setValue(ii, jj, v);</span>
                    }
                }
            }
        }

<span class="fc bfc" id="L1781" title="All 2 branches covered.">        if ((originalTheta.getWidth() &amp; 1) == 1) {</span>
            // copy next to last column into last column
<span class="fc" id="L1783">            int i = originalTheta.getWidth() - 2;</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>
<span class="fc" id="L1785">                int v = out.getValue(i, j);</span>
<span class="fc" id="L1786">                out.setValue(i + 1, j, v);</span>
            }
        }
<span class="fc bfc" id="L1789" title="All 2 branches covered.">        if ((originalTheta.getHeight() &amp; 1) == 1) {</span>
            // copy next to last row into last row
<span class="fc" id="L1791">            int j = originalTheta.getHeight() - 2;</span>
<span class="fc bfc" id="L1792" title="All 2 branches covered.">            for (int i = 0; i &lt; w1; i++) {</span>
<span class="fc" id="L1793">                int v = out.getValue(i, j);</span>
<span class="fc" id="L1794">                out.setValue(i, j + 1, v);</span>
            }
        }

        // TODO: consider correction for oversampling at location of skyline
        // using originalTheta

<span class="fc" id="L1801">        return out;</span>
    }
    
    
    public GreyscaleImage expandBy2UsingBilinearInterp(GreyscaleImage input) {

<span class="nc bnc" id="L1807" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1808">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="nc" id="L1811">        int w1 = 2 * input.getWidth();</span>
<span class="nc" id="L1812">        int h1 = 2 * input.getHeight();</span>
        
<span class="nc" id="L1814">        return expandBy2UsingBilinearInterp(input, w1, h1);</span>
    }
            
    /**
     * expand image to final size by a factor of 2, and use the given output
     * widths and heights which are expected to be either twice the input
     * or twice plus 1.
     * @param input
     * @param outWidth
     * @param outHeight
     * @return 
     */
    public GreyscaleImage expandBy2UsingBilinearInterp(GreyscaleImage input,
        int outWidth, int outHeight) {

<span class="pc bpc" id="L1829" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1830">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="fc" id="L1833">        int w0 = input.getWidth();</span>
<span class="fc" id="L1834">        int h0 = input.getHeight();</span>
        
<span class="pc bpc" id="L1836" title="3 of 4 branches missed.">        if ((2*w0 != outWidth) &amp;&amp; ((2*w0 + 1) != outWidth)) {</span>
<span class="nc" id="L1837">            throw new IllegalArgumentException(</span>
            &quot;outWidth should be 2 * input.getWidth() or (2 * input.getWidth()) + 1&quot;);
        }
<span class="pc bpc" id="L1840" title="3 of 4 branches missed.">        if ((2*h0 != outHeight) &amp;&amp; ((2*h0 + 1) != outHeight)) {</span>
<span class="nc" id="L1841">            throw new IllegalArgumentException(</span>
            &quot;outHeight should be 2 * input.getHeight() or (2 * input.getHeight()) + 1&quot;);
        }

<span class="fc" id="L1845">        GreyscaleImage out = input.createWithDimensions(outWidth, outHeight);</span>

<span class="fc bfc" id="L1847" title="All 2 branches covered.">        for (int i = 0; i &lt; outWidth; ++i) {</span>
<span class="fc bfc" id="L1848" title="All 2 branches covered.">            for (int j = 0; j &lt; outHeight; ++j) {</span>
                
<span class="fc bfc" id="L1850" title="All 4 branches covered.">                if (((i &amp; 1) != 1) &amp;&amp; ((j &amp; 1) != 1)) {</span>
<span class="fc" id="L1851">                    int x0 = i/2;</span>
<span class="fc" id="L1852">                    int y0 = j/2;</span>
<span class="pc bpc" id="L1853" title="2 of 4 branches missed.">                    if ((x0 &lt; w0) &amp;&amp; (y0 &lt; h0)) {</span>
<span class="fc" id="L1854">                        out.setValue(i, j, input.getValue(x0, y0));</span>
<span class="fc" id="L1855">                        continue;</span>
                    }
                }

<span class="fc" id="L1859">                float x0 = (float)i/2.f;</span>
<span class="fc" id="L1860">                float y0 = (float)j/2.f;</span>
                
<span class="fc bfc" id="L1862" title="All 2 branches covered.">                if (x0 &gt; (w0 - 1)) {</span>
<span class="fc" id="L1863">                    x0 = w0 - 1;</span>
                }
<span class="fc bfc" id="L1865" title="All 2 branches covered.">                if (y0 &gt; (h0 - 1)) {</span>
<span class="fc" id="L1866">                    y0 = h0 - 1;</span>
                }
                
<span class="fc" id="L1869">                double v2 = biLinearInterpolation(input, x0, y0);</span>
                
<span class="fc" id="L1871">                out.setValue(i, j, (int)Math.round(v2));</span>
            }
        }

<span class="fc" id="L1875">        return out;</span>
    }
    
    public GreyscaleImage unbinImage(GreyscaleImage input, int binFactor) {

<span class="nc bnc" id="L1880" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1881">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }

<span class="nc" id="L1884">        int w0 = input.getWidth();</span>
<span class="nc" id="L1885">        int h0 = input.getHeight();</span>

<span class="nc" id="L1887">        GreyscaleImage out = input.createWithDimensions(2 * w0, 2 * h0);</span>

<span class="nc" id="L1889">        int w1 = out.getWidth();</span>
<span class="nc" id="L1890">        int h1 = out.getHeight();</span>

<span class="nc bnc" id="L1892" title="All 2 branches missed.">        for (int i = 0; i &lt; w0; i++) {</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">            for (int j = 0; j &lt; h0; j++) {</span>

<span class="nc" id="L1895">                int v = input.getValue(i, j);</span>

<span class="nc bnc" id="L1897" title="All 2 branches missed.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="nc" id="L1899">                        out.setValue(ii, jj, v);</span>
                    }
                }
            }
        }

<span class="nc bnc" id="L1905" title="All 2 branches missed.">        if ((input.getWidth() &amp; 1) == 1) {</span>
            // copy next to last column into last column
<span class="nc" id="L1907">            int i = input.getWidth() - 2;</span>
<span class="nc bnc" id="L1908" title="All 2 branches missed.">            for (int j = 0; j &lt; h1; j++) {</span>
<span class="nc" id="L1909">                int v = out.getValue(i, j);</span>
<span class="nc" id="L1910">                out.setValue(i + 1, j, v);</span>
            }
        }
<span class="nc bnc" id="L1913" title="All 2 branches missed.">        if ((input.getHeight() &amp; 1) == 1) {</span>
            // copy next to last row into last row
<span class="nc" id="L1915">            int j = input.getHeight() - 2;</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">            for (int i = 0; i &lt; w1; i++) {</span>
<span class="nc" id="L1917">                int v = out.getValue(i, j);</span>
<span class="nc" id="L1918">                out.setValue(i, j + 1, v);</span>
            }
        }

<span class="nc" id="L1922">        return out;</span>
    }

    public List&lt;PairIntArray&gt; unbinZeroPointLists(List&lt;PairIntArray&gt; zeroPointLists,
        int binFactor) {

<span class="nc bnc" id="L1928" title="All 2 branches missed.">        if (zeroPointLists == null) {</span>
<span class="nc" id="L1929">            throw new IllegalArgumentException(&quot;mask cannot be null&quot;);</span>
        }

<span class="nc" id="L1932">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>

<span class="nc bnc" id="L1934" title="All 2 branches missed.">        for (PairIntArray zeroPointList : zeroPointLists) {</span>

<span class="nc" id="L1936">            PairIntArray transformed = new PairIntArray(zeroPointList.getN() *</span>
                binFactor);

<span class="nc bnc" id="L1939" title="All 2 branches missed.">            for (int i = 0; i &lt; zeroPointList.getN(); i++) {</span>

<span class="nc" id="L1941">                int x = zeroPointList.getX(i);</span>
<span class="nc" id="L1942">                int y = zeroPointList.getY(i);</span>

<span class="nc bnc" id="L1944" title="All 2 branches missed.">                for (int ii = (x*binFactor); ii &lt; ((x + 1)*binFactor); ii++) {</span>
<span class="nc bnc" id="L1945" title="All 2 branches missed.">                    for (int jj = (y*binFactor); jj &lt; ((y + 1)*binFactor); jj++) {</span>

<span class="nc" id="L1947">                        transformed.add(ii, jj);</span>
                    }
                }
            }

<span class="nc" id="L1952">            output.add(transformed);</span>

<span class="nc" id="L1954">        }</span>

<span class="nc" id="L1956">        return output;</span>
    }

    public Set&lt;PairInt&gt; unbinZeroPointLists(Set&lt;PairInt&gt; zeroPoints,
        int binFactor) {

<span class="pc bpc" id="L1962" title="1 of 2 branches missed.">        if (zeroPoints == null) {</span>
<span class="nc" id="L1963">            throw new IllegalArgumentException(&quot;zeroPoints cannot be null&quot;);</span>
        }

<span class="fc" id="L1966">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L1968" title="All 2 branches covered.">        for (PairInt zeroPoint : zeroPoints) {</span>

<span class="fc" id="L1970">            int x = zeroPoint.getX();</span>
<span class="fc" id="L1971">            int y = zeroPoint.getY();</span>

<span class="fc bfc" id="L1973" title="All 2 branches covered.">            for (int ii = (x*binFactor); ii &lt; ((x + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1974" title="All 2 branches covered.">                for (int jj = (y*binFactor); jj &lt; ((y + 1)*binFactor); jj++) {</span>

<span class="fc" id="L1976">                    PairInt p = new PairInt(ii, jj);</span>

<span class="fc" id="L1978">                    output.add(p);</span>
                }
            }
<span class="fc" id="L1981">        }</span>

<span class="fc" id="L1983">        return output;</span>
    }

    public void printImageColorContrastStats(Image image, int rgbSkyAvg,
        int plotNumber) throws IOException {

        /*
        http://dilnxsrv.king.ac.uk/papers/wses2001.pdf
           Y   | 16  |   | 0.256  0.504  0.098 | |R|
           U = | 128 | + |-0.148 -0.291  0.439 | |G|
           V   | 128 |   | 0.439 -0.368 -0.072 | |B|
        */
<span class="fc" id="L1995">        double[][] m = new double[3][];</span>
<span class="fc" id="L1996">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="fc" id="L1997">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="fc" id="L1998">        m[2] = new double[]{0.439, -0.368, -0.072};</span>

<span class="fc" id="L2000">        int rSky = (rgbSkyAvg &gt;&gt; 16) &amp; 0xFF;</span>
<span class="fc" id="L2001">        int gSky = (rgbSkyAvg &gt;&gt; 8) &amp; 0xFF;</span>
<span class="fc" id="L2002">        int bSky = rgbSkyAvg &amp; 0xFF;</span>
<span class="fc" id="L2003">        double[] yuvSky = MatrixUtil.multiply(m, new double[]{rSky, gSky, bSky});</span>

<span class="fc" id="L2005">        double t313 = Math.pow(3, (1./3.));</span>

<span class="fc" id="L2007">        int w = image.getWidth();</span>
<span class="fc" id="L2008">        int h = image.getHeight();</span>
<span class="fc" id="L2009">        int slice = 1;//10;</span>

<span class="fc" id="L2011">        PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();</span>

<span class="fc bfc" id="L2013" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; i++) {</span>

<span class="fc" id="L2015">            int startCol = -1;</span>
<span class="fc" id="L2016">            int stopCol = -1;</span>
<span class="fc" id="L2017">            int startRow = -1;</span>
<span class="fc" id="L2018">            int stopRow = -1;</span>
<span class="fc" id="L2019">            boolean plotAlongRows = true;</span>
<span class="fc" id="L2020">            String labelSuffix = null;</span>

<span class="fc bfc" id="L2022" title="All 6 branches covered.">            switch(i) {</span>
                case 0:
                    //horizontal at low y
<span class="fc" id="L2025">                    startCol = 0;</span>
<span class="fc" id="L2026">                    stopCol = w - 1;</span>
<span class="fc" id="L2027">                    startRow = slice;</span>
<span class="fc" id="L2028">                    stopRow = startRow + slice;</span>
<span class="fc" id="L2029">                    plotAlongRows = false;</span>
<span class="fc" id="L2030">                    labelSuffix = &quot;horizontal stripe at low y&quot;;</span>
<span class="fc" id="L2031">                    break;</span>
                case 1:
                    //horizontal at mid y
<span class="fc" id="L2034">                    startCol = 0;</span>
<span class="fc" id="L2035">                    stopCol = w - 1;</span>
<span class="fc" id="L2036">                    startRow = (h - slice)/2 ;</span>
<span class="fc" id="L2037">                    stopRow = startRow + slice;</span>
<span class="fc" id="L2038">                    plotAlongRows = false;</span>
<span class="fc" id="L2039">                    labelSuffix = &quot;horizontal stripe at mid y&quot;;</span>
<span class="fc" id="L2040">                    break;</span>
                case 2:
                    //horizontal at high y
<span class="fc" id="L2043">                    startCol = 0;</span>
<span class="fc" id="L2044">                    stopCol = w - 1;</span>
<span class="fc" id="L2045">                    startRow = (h - 2*slice) - 1;</span>
<span class="fc" id="L2046">                    stopRow = startRow + slice;</span>
<span class="fc" id="L2047">                    plotAlongRows = false;</span>
<span class="fc" id="L2048">                    labelSuffix = &quot;horizontal stripe at high y&quot;;</span>
<span class="fc" id="L2049">                    break;</span>
                case 3:
                    //vertical at low x
<span class="fc" id="L2052">                    startCol = slice;</span>
<span class="fc" id="L2053">                    stopCol = startCol + slice;</span>
<span class="fc" id="L2054">                    startRow = 0;</span>
<span class="fc" id="L2055">                    stopRow = h - 1;</span>
<span class="fc" id="L2056">                    plotAlongRows = true;</span>
<span class="fc" id="L2057">                    labelSuffix = &quot;vertical stripe at low x&quot;;</span>
<span class="fc" id="L2058">                    break;</span>
                case 4:
                    //vertical at mid x
<span class="fc" id="L2061">                    startCol = (w - slice)/2;</span>
<span class="fc" id="L2062">                    stopCol = startCol + slice;</span>
<span class="fc" id="L2063">                    startRow = 0;</span>
<span class="fc" id="L2064">                    stopRow = h - 1;</span>
<span class="fc" id="L2065">                    plotAlongRows = true;</span>
<span class="fc" id="L2066">                    labelSuffix = &quot;vertical stripe at mid x&quot;;</span>
<span class="fc" id="L2067">                    break;</span>
                default:
                    //vertical at high x
<span class="fc" id="L2070">                    startCol = (w - 2*slice) - 1;</span>
<span class="fc" id="L2071">                    stopCol = startCol + slice;</span>
<span class="fc" id="L2072">                    startRow = 0;</span>
<span class="fc" id="L2073">                    stopRow = h - 1;</span>
<span class="fc" id="L2074">                    plotAlongRows = true;</span>
<span class="fc" id="L2075">                    labelSuffix = &quot;vertical stripe at high x&quot;;</span>
                    break;
            }

            // contrast as y
            // hue
            // blue
            // red
<span class="fc" id="L2083">            float[] contrast = null;</span>
<span class="fc" id="L2084">            float[] hue = null;</span>
<span class="fc" id="L2085">            float[] red = null;</span>
<span class="fc" id="L2086">            float[] blue = null;</span>
<span class="fc" id="L2087">            float[] white = null;</span>
<span class="fc" id="L2088">            float[] axis = null;</span>

<span class="fc bfc" id="L2090" title="All 2 branches covered.">            if (!plotAlongRows) {</span>

                // plot along columns

<span class="fc" id="L2094">                contrast = new float[w];</span>
<span class="fc" id="L2095">                hue = new float[w];</span>
<span class="fc" id="L2096">                red = new float[w];</span>
<span class="fc" id="L2097">                blue = new float[w];</span>
<span class="fc" id="L2098">                white = new float[w];</span>
<span class="fc" id="L2099">                axis = new float[w];</span>

<span class="fc bfc" id="L2101" title="All 2 branches covered.">                for (int col = startCol; col &lt;= stopCol; col++) {</span>

<span class="fc" id="L2103">                    int row = startRow;</span>

<span class="fc" id="L2105">                    int r = image.getR(col, row);</span>
<span class="fc" id="L2106">                    int g = image.getG(col, row);</span>
<span class="fc" id="L2107">                    int b = image.getB(col, row);</span>
<span class="fc" id="L2108">                    double[] rgb = new double[]{r, g, b};</span>

<span class="fc" id="L2110">                    double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="fc" id="L2111">                    yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>
<span class="fc" id="L2112">                    double hueValue = Math.atan2(t313 * (g - b), ((2 * r) - g - b));</span>

<span class="fc" id="L2114">                    double contrastValue = (yuvSky[0] - yuv[0])/yuv[0];</span>

<span class="fc" id="L2116">                    double whiteValue = (r + g + b)/3.;</span>

<span class="fc" id="L2118">                    contrast[col] = (float)contrastValue;</span>
<span class="fc" id="L2119">                    hue[col] = (float)hueValue;</span>
<span class="fc" id="L2120">                    blue[col] = (float)b;</span>
<span class="fc" id="L2121">                    red[col] = (float)r;</span>
<span class="fc" id="L2122">                    white[col] = (float)whiteValue;</span>

<span class="fc" id="L2124">                    axis[col] = col;</span>
                }

            } else {
                // plot along rows
<span class="fc" id="L2129">                contrast = new float[h];</span>
<span class="fc" id="L2130">                hue = new float[h];</span>
<span class="fc" id="L2131">                red = new float[h];</span>
<span class="fc" id="L2132">                blue = new float[h];</span>
<span class="fc" id="L2133">                white = new float[h];</span>
<span class="fc" id="L2134">                axis = new float[h];</span>

<span class="fc bfc" id="L2136" title="All 2 branches covered.">                for (int row = startRow; row &lt;= stopRow; row++) {</span>

<span class="fc" id="L2138">                    int col = startCol;</span>

<span class="fc" id="L2140">                    int r = image.getR(col, row);</span>
<span class="fc" id="L2141">                    int g = image.getG(col, row);</span>
<span class="fc" id="L2142">                    int b = image.getB(col, row);</span>
<span class="fc" id="L2143">                    double[] rgb = new double[]{r, g, b};</span>

<span class="fc" id="L2145">                    double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="fc" id="L2146">                    yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>
<span class="fc" id="L2147">                    double hueValue = Math.atan2(t313 * (g - b), ((2 * r) - g - b));</span>

<span class="fc" id="L2149">                    double contrastValue = (yuvSky[0] - yuv[0])/yuv[0];</span>

<span class="fc" id="L2151">                    double whiteValue = (r + g + b)/3.;</span>

<span class="fc" id="L2153">                    contrast[row] = (float)contrastValue;</span>
<span class="fc" id="L2154">                    hue[row] = (float)hueValue;</span>
<span class="fc" id="L2155">                    blue[row] = (float)b;</span>
<span class="fc" id="L2156">                    red[row] = (float)r;</span>
<span class="fc" id="L2157">                    white[row] = (float)whiteValue;</span>

<span class="fc" id="L2159">                    axis[row] = row;</span>
                }

            }

<span class="fc" id="L2164">            float xmn = MiscMath.findMin(axis);</span>
<span class="fc" id="L2165">            float xmx = MiscMath.findMax(axis);</span>

<span class="fc" id="L2167">            float ymn = MiscMath.findMin(contrast);</span>
<span class="fc" id="L2168">            float ymx = 1.1f * MiscMath.findMax(contrast);</span>
<span class="fc" id="L2169">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, contrast, null, null, null, null,
                &quot;contrast &quot; + labelSuffix);

<span class="fc" id="L2173">            ymn = MiscMath.findMin(hue);</span>
<span class="fc" id="L2174">            ymx = 1.1f * MiscMath.findMax(hue);</span>
<span class="fc" id="L2175">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, hue, null, null, null, null, &quot;hue &quot; + labelSuffix);

<span class="fc" id="L2178">            ymn = MiscMath.findMin(blue);</span>
<span class="fc" id="L2179">            ymx = 1.1f * MiscMath.findMax(blue);</span>
<span class="fc" id="L2180">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, blue, null, null, null, null, &quot;blue &quot; + labelSuffix);

<span class="fc" id="L2183">            ymn = MiscMath.findMin(red);</span>
<span class="fc" id="L2184">            ymx = 1.1f * MiscMath.findMax(red);</span>
<span class="fc" id="L2185">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, red, null, null, null, null, &quot;red &quot; + labelSuffix);

<span class="fc" id="L2188">            ymn = MiscMath.findMin(white);</span>
<span class="fc" id="L2189">            ymx = 1.1f * MiscMath.findMax(white);</span>
<span class="fc" id="L2190">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, white, null, null, null, null, &quot;white &quot; + labelSuffix);

<span class="fc" id="L2193">            plotter.writeFile(plotNumber);</span>
        }
<span class="fc" id="L2195">    }</span>

    public double[] calculateYRGB(PairIntArray points, Image originalColorImage,
        int xOffset, int yOffset, boolean addAlongX, int addAmount) {

<span class="fc" id="L2200">        double[][] m = new double[3][];</span>
<span class="fc" id="L2201">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="fc" id="L2202">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="fc" id="L2203">        m[2] = new double[]{0.439, -0.368, -0.072};</span>

<span class="fc" id="L2205">        double avgY = 0;</span>
<span class="fc" id="L2206">        double avgR = 0;</span>
<span class="fc" id="L2207">        double avgG = 0;</span>
<span class="fc" id="L2208">        double avgB = 0;</span>

<span class="fc bfc" id="L2210" title="All 2 branches covered.">        for (int i = 0; i &lt; points.getN(); i++) {</span>

<span class="fc" id="L2212">            int x = points.getX(i);</span>
<span class="fc" id="L2213">            int y = points.getY(i);</span>

<span class="fc" id="L2215">            int ox = x + xOffset;</span>
<span class="fc" id="L2216">            int oy = y + yOffset;</span>

<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">            if (addAlongX) {</span>
<span class="fc" id="L2219">                ox += addAmount;</span>
            } else {
<span class="nc" id="L2221">                oy += addAmount;</span>
            }
<span class="pc bpc" id="L2223" title="2 of 4 branches missed.">            if ((ox &lt; 0) || (ox &gt; (originalColorImage.getWidth() - 1))) {</span>
<span class="nc" id="L2224">                continue;</span>
            }
<span class="pc bpc" id="L2226" title="2 of 4 branches missed.">            if ((oy &lt; 0) || (oy &gt; (originalColorImage.getHeight() - 1))) {</span>
<span class="nc" id="L2227">                continue;</span>
            }

<span class="fc" id="L2230">            int r = originalColorImage.getR(x, y);</span>
<span class="fc" id="L2231">            int g = originalColorImage.getG(x, y);</span>
<span class="fc" id="L2232">            int b = originalColorImage.getB(x, y);</span>
<span class="fc" id="L2233">            double[] rgb = new double[]{r, g, b};</span>
<span class="fc" id="L2234">            double[] yuv = MatrixUtil.multiply(m, rgb);</span>

<span class="fc" id="L2236">            avgY += yuv[0];</span>

<span class="fc" id="L2238">            avgR += r;</span>
<span class="fc" id="L2239">            avgG += g;</span>
<span class="fc" id="L2240">            avgB += b;</span>
        }

<span class="fc" id="L2243">        avgY /= (double)points.getN();</span>
<span class="fc" id="L2244">        avgR /= (double)points.getN();</span>
<span class="fc" id="L2245">        avgG /= (double)points.getN();</span>
<span class="fc" id="L2246">        avgB /= (double)points.getN();</span>

<span class="fc" id="L2248">        return new double[]{avgY, avgR, avgG, avgB};</span>
    }

    public GreyscaleImage padUpToPowerOfTwo(GreyscaleImage input) {

<span class="fc" id="L2253">        int w0 = input.getWidth();</span>
<span class="fc" id="L2254">        int h0 = input.getHeight();</span>

<span class="fc" id="L2256">        int w = 1 &lt;&lt; (int)(Math.ceil(Math.log(w0)/Math.log(2)));</span>
<span class="fc" id="L2257">        int h = 1 &lt;&lt; (int)(Math.ceil(Math.log(h0)/Math.log(2)));</span>

<span class="fc" id="L2259">        int xOffset = w - w0;</span>
<span class="fc" id="L2260">        int yOffset = h - h0;</span>

<span class="pc bpc" id="L2262" title="3 of 4 branches missed.">        if (xOffset == 0 &amp;&amp; yOffset == 0) {</span>
<span class="nc" id="L2263">            return input;</span>
        }

<span class="fc" id="L2266">        int xOffsetOrig = input.getXRelativeOffset();</span>
<span class="fc" id="L2267">        int yOffsetOrig = input.getYRelativeOffset();</span>

<span class="fc" id="L2269">        GreyscaleImage output = new GreyscaleImage(w, h, input.getType());</span>
<span class="fc" id="L2270">        output.setXRelativeOffset(xOffset + xOffsetOrig);</span>
<span class="fc" id="L2271">        output.setYRelativeOffset(yOffset + yOffsetOrig);</span>

<span class="fc bfc" id="L2273" title="All 2 branches covered.">        for (int i = 0; i &lt; w0; ++i) {</span>
<span class="fc bfc" id="L2274" title="All 2 branches covered.">            for (int j = 0; j &lt; h0; ++j) {</span>
<span class="fc" id="L2275">                int v = input.getValue(i, j);</span>
<span class="fc" id="L2276">                output.setValue(i + xOffset, j + yOffset, v);</span>
            }
        }

<span class="fc" id="L2280">        return output;</span>
    }

    /**
     *
     * @param input
     * @param forward if true, apply FFT transform, else inverse FFT transform
     */
    public void apply2DFFT(GreyscaleImage input, boolean forward) {

<span class="fc" id="L2290">        int xOffsetOrig = input.getXRelativeOffset();</span>
<span class="fc" id="L2291">        int yOffsetOrig = input.getYRelativeOffset();</span>

        //TODO remove the other power of 2 padding method
<span class="fc" id="L2294">        GreyscaleImage tmp = padUpToPowerOfTwo(input);</span>

        // initialize matrix of complex numbers as real numbers from image
<span class="fc" id="L2297">        Complex[][] cc = convertImage(tmp);</span>

<span class="fc" id="L2299">        Complex[][] ccOut = apply2DFFT(cc, forward);</span>

<span class="fc" id="L2301">        writeToImage(tmp, ccOut);</span>

<span class="pc bpc" id="L2303" title="1 of 2 branches missed.">        if (tmp.getNPixels() &gt; input.getNPixels()) {</span>

<span class="fc" id="L2305">            int xOffset = tmp.getXRelativeOffset();</span>
<span class="fc" id="L2306">            int yOffset = tmp.getYRelativeOffset();</span>

            // padding is at front of cols and rows
<span class="fc" id="L2309">            int x = 0;</span>
<span class="fc bfc" id="L2310" title="All 2 branches covered.">            for (int col = xOffset; col &lt; tmp.getWidth(); col++) {</span>
<span class="fc" id="L2311">                int y = 0;</span>
<span class="fc bfc" id="L2312" title="All 2 branches covered.">                for (int row = yOffset; row &lt; tmp.getHeight(); row++) {</span>
<span class="fc" id="L2313">                    int v = tmp.getValue(col, row);</span>
<span class="fc" id="L2314">                    input.setValue(x, y, v);</span>
<span class="fc" id="L2315">                    y++;</span>
                }
<span class="fc" id="L2317">                x++;</span>
             }
<span class="fc" id="L2319">            input.setXRelativeOffset(xOffsetOrig);</span>
<span class="fc" id="L2320">            input.setYRelativeOffset(yOffsetOrig);</span>
        }
<span class="fc" id="L2322">    }</span>

    protected Complex[][] apply2DFFT(Complex[][] cc, boolean forward) {

        // perform FFT by column
<span class="fc bfc" id="L2327" title="All 2 branches covered.">        for (int col = 0; col &lt; cc.length; col++) {</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">            if (forward) {</span>
<span class="fc" id="L2329">                cc[col] = FFT.fft(cc[col]);</span>
            } else {
<span class="fc" id="L2331">                cc[col] = FFT.ifft(cc[col]);</span>
            }
        }


        //transpose the matrix
<span class="fc" id="L2337">        cc = MatrixUtil.transpose(cc);</span>

        // perform FFT by column (originally rows)
<span class="fc bfc" id="L2340" title="All 2 branches covered.">        for (int col = 0; col &lt; cc.length; col++) {</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">            if (forward) {</span>
<span class="fc" id="L2342">                cc[col] = FFT.fft(cc[col]);</span>
            } else {
<span class="fc" id="L2344">                cc[col] = FFT.ifft(cc[col]);</span>
            }
        }

        //transpose the matrix
<span class="fc" id="L2349">        cc = MatrixUtil.transpose(cc);</span>


<span class="fc" id="L2352">        return cc;</span>
    }

    public void writeToImage(GreyscaleImage img, Complex[][] cc) {

<span class="fc" id="L2357">        img.fill(0);</span>

        // write back to original image
<span class="fc bfc" id="L2360" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L2361" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L2362">                double re = cc[col][row].re();</span>
<span class="fc" id="L2363">                double a = cc[col][row].abs();</span>
<span class="fc" id="L2364">                double p = cc[col][row].phase();</span>
<span class="fc" id="L2365">                img.setValue(col, row, (int)re);</span>
            }
        }

<span class="fc" id="L2369">    }</span>

    public void writePositiveRealToImage(GreyscaleImage img, Complex[][] cc) {

<span class="fc" id="L2373">        img.fill(0);</span>

        // write back to original image
<span class="fc bfc" id="L2376" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L2377" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L2378">                double re = cc[col][row].re();</span>
<span class="fc" id="L2379">                double a = cc[col][row].abs();</span>
<span class="fc" id="L2380">                double p = cc[col][row].phase();</span>
<span class="fc bfc" id="L2381" title="All 2 branches covered.">                if (re &gt; 0) {</span>
<span class="fc" id="L2382">                    img.setValue(col, row, (int)re);</span>
                }
            }
        }

<span class="fc" id="L2387">    }</span>

    protected Complex[][] convertImage(GreyscaleImage input) {

        // initialize matrix of complex numbers as real numbers from image
<span class="fc" id="L2392">        Complex[][] cc = new Complex[input.getWidth()][];</span>

<span class="fc bfc" id="L2394" title="All 2 branches covered.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="fc" id="L2396">            cc[col] = new Complex[input.getHeight()];</span>

<span class="fc bfc" id="L2398" title="All 2 branches covered.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="fc" id="L2399">                cc[col][row] = new Complex(input.getValue(col, row), 0);</span>
            }
        }

<span class="fc" id="L2403">        return cc;</span>
    }

    /**
     * NOT READY FOR USE YET
     *
     * @param input
     */
    public void applyDeconvolution(GreyscaleImage input) throws IOException {

        //TODO NOT READY FOR USE YET...

<span class="fc" id="L2415">        applyWienerFilter(input);</span>

<span class="fc" id="L2417">    }</span>

    /**
     * NOT READY FOR USE YET
     *
     * @param input
     */
    public void applyWienerFilter(GreyscaleImage input) throws IOException {

        //TODO NOT READY FOR USE YET...

<span class="fc" id="L2428">        CannyEdgeFilter cef = new CannyEdgeFilter();</span>

        // note, this is not scaled for total sum = 1 yet
<span class="fc" id="L2431">        GreyscaleImage psf = cef.createGradientPSFForTesting();</span>
<span class="fc" id="L2432">        double sum = 0;</span>
<span class="fc bfc" id="L2433" title="All 2 branches covered.">        for (int col = 0; col &lt; psf.getWidth(); col++) {</span>
<span class="fc bfc" id="L2434" title="All 2 branches covered.">            for (int row = 0; row &lt; psf.getHeight(); row++) {</span>
<span class="fc" id="L2435">                int v = psf.getValue(col, row);</span>
<span class="fc" id="L2436">                sum += v;</span>
            }
        }
<span class="fc" id="L2439">        psf = padToNearestPowerOf2Dimensions(psf);</span>
<span class="fc" id="L2440">        Complex[][] psfNorm = new Complex[psf.getWidth()][];</span>
<span class="fc bfc" id="L2441" title="All 2 branches covered.">        for (int col = 0; col &lt; psf.getWidth(); col++) {</span>
<span class="fc" id="L2442">            psfNorm[col] = new Complex[psf.getHeight()];</span>
<span class="fc bfc" id="L2443" title="All 2 branches covered.">            for (int row = 0; row &lt; psf.getHeight(); row++) {</span>
<span class="fc" id="L2444">                int v = psf.getValue(col, row);</span>
<span class="fc" id="L2445">                double vn = v / sum;</span>
<span class="fc" id="L2446">                psfNorm[col][row] = new Complex(vn, 0);</span>
            }
        }
<span class="fc" id="L2449">        psfNorm = apply2DFFT(psfNorm, true);</span>

        // filter out low values?
<span class="fc bfc" id="L2452" title="All 2 branches covered.">        for (int i = 0; i &lt; psfNorm.length; i++) {</span>
<span class="fc bfc" id="L2453" title="All 2 branches covered.">            for (int j = 0; j &lt; psfNorm[0].length; j++) {</span>
<span class="fc" id="L2454">                double r = psfNorm[i][j].re();</span>
<span class="fc bfc" id="L2455" title="All 2 branches covered.">                if (r &lt; 0.1) {</span>
<span class="fc" id="L2456">                    psfNorm[i][j] = new Complex(0, 0);</span>
                }
            }
        }

<span class="fc" id="L2461">        GreyscaleImage img0 = padToNearestPowerOf2Dimensions(input);</span>

<span class="fc" id="L2463">        ImageDisplayer.displayImage(&quot;before deconv&quot;, img0);</span>

<span class="fc" id="L2465">        Complex[][] imgCC = convertImage(img0);</span>

<span class="fc" id="L2467">        Complex[][] imgFFT = apply2DFFT(imgCC, true);</span>

        /*
        complex division:
           a times reciprocal of b

        reciprocal:
            double scale = re*re + im*im;
            r = Complex(re / scale, -im / scale);

        times:
            real = a.re * b.re - a.im * b.im;
            imag = a.re * b.im + a.im * b.re;
        */

<span class="fc" id="L2482">        Complex[][] ccDeconv = new Complex[imgFFT.length][];</span>
<span class="fc" id="L2483">        int pXH =  psfNorm.length &gt;&gt; 1;</span>
<span class="fc" id="L2484">        int pYH =  psfNorm[0].length &gt;&gt; 1;</span>
<span class="fc bfc" id="L2485" title="All 2 branches covered.">        for (int col = 0; col &lt; imgFFT.length; col++) {</span>

<span class="fc" id="L2487">            ccDeconv[col] = new Complex[imgFFT[0].length];</span>

<span class="fc bfc" id="L2489" title="All 2 branches covered.">            for (int row = 0; row &lt; imgFFT[0].length; row++) {</span>

<span class="fc" id="L2491">                Complex v = imgFFT[col][row];</span>

                // for convolution, each element of kernel and neighboring
                // pixel (including center pixel) were multiplied and result
                // is given to center pixel.

                // for deconvolution, the sums of the division are calculated

<span class="fc" id="L2499">                Complex pixSum = new Complex(v.re(), v.im());</span>

<span class="fc bfc" id="L2501" title="All 2 branches covered.">                for (int pXIdx = 0; pXIdx &lt; psfNorm.length; pXIdx++) {</span>
<span class="fc" id="L2502">                    int pixXIdx = col + (pXIdx - pXH);</span>

                    // correct for out of bounds of image
<span class="fc bfc" id="L2505" title="All 2 branches covered.">                    if (pixXIdx &lt; 0) {</span>
                        // replicate
<span class="fc" id="L2507">                        pixXIdx = -1*pixXIdx - 1;</span>
<span class="pc bpc" id="L2508" title="1 of 2 branches missed.">                        if (pixXIdx &gt; (img0.getWidth() - 1)) {</span>
<span class="nc" id="L2509">                            pixXIdx = img0.getWidth() - 1;</span>
                        }
<span class="fc bfc" id="L2511" title="All 2 branches covered.">                    } else if (pixXIdx &gt;= img0.getWidth()) {</span>
<span class="fc" id="L2512">                        int diff = pixXIdx - img0.getWidth();</span>
<span class="fc" id="L2513">                        pixXIdx = img0.getWidth() - diff - 1;</span>
<span class="pc bpc" id="L2514" title="1 of 2 branches missed.">                        if (pixXIdx &lt; 0) {</span>
<span class="nc" id="L2515">                            pixXIdx = 0;</span>
                        }
                    }

<span class="fc bfc" id="L2519" title="All 2 branches covered.">                    for (int pYIdx = 0; pYIdx &lt; psfNorm.length; pYIdx++) {</span>

<span class="fc bfc" id="L2521" title="All 2 branches covered.">                        if (psfNorm[pXIdx][pYIdx].abs() == 0) {</span>
<span class="fc" id="L2522">                            continue;</span>
                        }

<span class="fc" id="L2525">                        int pixYIdx = row + (pYIdx - pYH);</span>

                        // correct for out of bounds of image
<span class="fc bfc" id="L2528" title="All 2 branches covered.">                        if (pixYIdx &lt; 0) {</span>
                            // replicate
<span class="fc" id="L2530">                            pixYIdx = -1*pixYIdx - 1;</span>
<span class="pc bpc" id="L2531" title="1 of 2 branches missed.">                            if (pixYIdx &gt; (img0.getHeight() - 1)) {</span>
<span class="nc" id="L2532">                                pixYIdx = img0.getHeight() - 1;</span>
                            }
<span class="fc bfc" id="L2534" title="All 2 branches covered.">                        } else if (pixYIdx &gt;= img0.getHeight()) {</span>
<span class="fc" id="L2535">                            int diff = pixYIdx - img0.getHeight();</span>
<span class="fc" id="L2536">                            pixYIdx = img0.getHeight() - diff - 1;</span>
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">                            if (pixYIdx &lt; 0) {</span>
<span class="nc" id="L2538">                                pixYIdx = 0;</span>
                            }
                        }

<span class="fc" id="L2542">                        Complex vk = imgFFT[pixXIdx][pixYIdx];</span>

<span class="pc bpc" id="L2544" title="1 of 2 branches missed.">                        if (vk.abs() == 0) {</span>
<span class="nc" id="L2545">                            continue;</span>
                        }

<span class="fc" id="L2548">                        Complex kRecip = psfNorm[pXIdx][pYIdx].reciprocal();</span>

<span class="fc" id="L2550">                        Complex vDivPSF = vk.times(kRecip);</span>

<span class="fc" id="L2552">                        pixSum = pixSum.plus(vDivPSF);</span>
                    }
                }


<span class="fc" id="L2557">                ccDeconv[col][row] = pixSum;</span>
            }
        }

<span class="fc" id="L2561">        GreyscaleImage img2 = img0.createFullRangeIntWithDimensions();</span>

<span class="fc" id="L2563">        writePositiveRealToImage(img2, ccDeconv);</span>

<span class="fc" id="L2565">        ImageDisplayer.displayImage(&quot;FFT(img0)/FFT(PSF)&quot;, img2);</span>


<span class="fc" id="L2568">        Complex[][] inverse = apply2DFFT(ccDeconv, false);</span>

<span class="fc" id="L2570">        GreyscaleImage img4 = img0.createFullRangeIntWithDimensions();</span>

<span class="fc" id="L2572">        writePositiveRealToImage(img4, inverse);</span>

<span class="fc" id="L2574">        ImageDisplayer.displayImage(&quot;ifft of FFT(img0)/FFT(PSF)&quot;, img4);</span>


<span class="fc bfc" id="L2577" title="All 2 branches covered.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="fc bfc" id="L2578" title="All 2 branches covered.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="fc" id="L2579">                double f = inverse[i][j].re();</span>
<span class="fc" id="L2580">                int v = input.getValue(i, j);</span>
<span class="fc bfc" id="L2581" title="All 4 branches covered.">                if (v &gt; 0 &amp;&amp; f &gt; 0) {</span>
                    // apply it to the original image?  f*v or v or f?
<span class="fc" id="L2583">                    input.setValue(i, j, v);</span>
                } else {
<span class="fc" id="L2585">                    input.setValue(i, j, 0);</span>
                }
            }
        }
<span class="fc" id="L2589">    }</span>

    public GreyscaleImage padToNearestPowerOf2Dimensions(GreyscaleImage img) {

<span class="fc" id="L2593">        int w = img.getWidth();</span>
<span class="fc" id="L2594">        int h = img.getHeight();</span>

<span class="fc" id="L2596">        boolean xIsPowerOf2 = MiscMath.isAPowerOf2(w);</span>
<span class="fc" id="L2597">        boolean yIsPowerOf2 = MiscMath.isAPowerOf2(h);</span>
<span class="pc bpc" id="L2598" title="1 of 4 branches missed.">        if (xIsPowerOf2 &amp;&amp; yIsPowerOf2) {</span>
<span class="fc" id="L2599">            return img;</span>
        }

<span class="fc" id="L2602">        int w2 = w;</span>
<span class="fc" id="L2603">        int h2 = h;</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">        if (!xIsPowerOf2) {</span>
<span class="fc" id="L2605">            double p2X = Math.ceil(Math.log(w)/Math.log(2));</span>
<span class="fc" id="L2606">            w2 = (1 &lt;&lt; (int)p2X);</span>
        }
<span class="pc bpc" id="L2608" title="1 of 2 branches missed.">        if (!yIsPowerOf2) {</span>
<span class="fc" id="L2609">            double p2Y = Math.ceil(Math.log(h)/Math.log(2));</span>
<span class="fc" id="L2610">            h2 = (1 &lt;&lt; (int)p2Y);</span>
        }

<span class="fc" id="L2613">        GreyscaleImage img2 = new GreyscaleImage(w2, h2, img.getType());</span>

<span class="fc bfc" id="L2615" title="All 2 branches covered.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="fc bfc" id="L2616" title="All 2 branches covered.">            for (int row = 0; row &lt; h; row++) {</span>
<span class="fc" id="L2617">                int v = img.getValue(col, row);</span>
<span class="fc" id="L2618">                img2.setValue(col, row, v);</span>
            }
<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">            if (h2 &gt; h) {</span>
<span class="fc bfc" id="L2621" title="All 2 branches covered.">                for (int row = h; row &lt; h2; row++) {</span>
<span class="fc" id="L2622">                    img2.setValue(col, row, 0);</span>
                }
            }
        }

<span class="pc bpc" id="L2627" title="1 of 2 branches missed.">        if (!xIsPowerOf2) {</span>
<span class="fc bfc" id="L2628" title="All 2 branches covered.">            for (int col = w; col &lt; w2; col++) {</span>
<span class="fc bfc" id="L2629" title="All 2 branches covered.">                for (int row = 0; row &lt; h2; row++) {</span>
<span class="fc" id="L2630">                    img2.setValue(col, row, 0);</span>
                }
            }
        }

<span class="fc" id="L2635">        return img2;</span>
    }

    /**
     * read the image and store the non-zero pixels in a set.  note that negative
     * values will also be stored in the output set.
     * @param img
     * @return
     */
    public Set&lt;PairInt&gt; readNonZeroPixels(GreyscaleImage img) {

<span class="fc" id="L2646">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2648" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L2649" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L2650">                int v = img.getValue(col, row);</span>
<span class="fc bfc" id="L2651" title="All 2 branches covered.">                if (v != 0) {</span>
<span class="fc" id="L2652">                    set.add(new PairInt(col, row));</span>
                }
            }
        }

<span class="fc" id="L2657">        return set;</span>
    }

    public void writeAsBinaryToImage(GreyscaleImage img, Set&lt;PairInt&gt;
        nonZeroPoints) {

<span class="fc" id="L2663">        img.fill(0);</span>

<span class="fc bfc" id="L2665" title="All 2 branches covered.">        for (PairInt p : nonZeroPoints) {</span>
<span class="fc" id="L2666">            int x = p.getX();</span>
<span class="fc" id="L2667">            int y = p.getY();</span>
<span class="fc" id="L2668">            img.setValue(x, y, 1);</span>
<span class="fc" id="L2669">        }</span>

<span class="fc" id="L2671">    }</span>

    /**
     * find contiguous zeros in image and if the number of pixels in a groups
     * is less than contiguousZerosLimit, fill in the pixels with the
     * value of the neighboring pixels.
     * NOTE: this is set to use the 4-neighbor region, but can be set to use
     * 8-neighbors if needed.
     */
    public void fillInPixels(GreyscaleImage img, final int valueToFill,
        final int contiguousZerosLimit) {

<span class="nc" id="L2683">        DFSContiguousValueFinder finder = new DFSContiguousValueFinder(img);</span>
<span class="nc" id="L2684">        finder.setMinimumNumberInCluster(1);</span>
<span class="nc" id="L2685">        finder.findGroups(valueToFill);</span>

<span class="nc" id="L2687">        int nGroups = finder.getNumberOfGroups();</span>

<span class="nc bnc" id="L2689" title="All 2 branches missed.">        for (int i = 0; i &lt; nGroups; ++i) {</span>

<span class="nc" id="L2691">            int n = finder.getNumberofGroupMembers(i);</span>

<span class="nc bnc" id="L2693" title="All 2 branches missed.">            if (n &lt;= contiguousZerosLimit) {</span>

<span class="nc" id="L2695">                PairIntArray group = finder.getXY(i);</span>

                // find the adjacent non-zero pixels to these
<span class="nc" id="L2698">                Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">                for (int j = 0; j &lt; group.getN(); ++j)  {</span>
<span class="nc" id="L2700">                    getNeighborsNotThisValue(img, group.getX(j), group.getY(j),</span>
                        valueToFill, neighbors);
                }

                // get thier average intensities
<span class="nc" id="L2705">                double avgV = 0;</span>
<span class="nc bnc" id="L2706" title="All 2 branches missed.">                for (PairInt p : neighbors) {</span>
<span class="nc" id="L2707">                    int v = img.getValue(p.getX(), p.getY());</span>
<span class="nc" id="L2708">                    avgV += v;</span>
<span class="nc" id="L2709">                }</span>
<span class="nc" id="L2710">                avgV /= (double)neighbors.size();</span>
<span class="nc" id="L2711">                int vRepl = Math.round((float)avgV);</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">                for (int j = 0; j &lt; group.getN(); ++j)  {</span>
<span class="nc" id="L2713">                    int x = group.getX(j);</span>
<span class="nc" id="L2714">                    int y = group.getY(j);</span>
<span class="nc" id="L2715">                    img.setValue(x, y, vRepl);</span>
                }
            }
        }

<span class="nc" id="L2720">    }</span>

    public void getNeighborsNotThisValue(GreyscaleImage input, int x, int y,
        final int value, Set&lt;PairInt&gt; outputNeighbors) {

<span class="nc" id="L2725">        int width = input.getWidth();</span>
<span class="nc" id="L2726">        int height = input.getHeight();</span>

<span class="nc bnc" id="L2728" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L2729" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L2730">                continue;</span>
            }
<span class="nc bnc" id="L2732" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L2733" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L2734">                    continue;</span>
                }
<span class="nc bnc" id="L2736" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L2737">                    continue;</span>
                }
<span class="nc" id="L2739">                int v = input.getValue(c, r);</span>
<span class="nc bnc" id="L2740" title="All 2 branches missed.">                if (v != value) {</span>
<span class="nc" id="L2741">                    PairInt p = new PairInt(c, r);</span>
<span class="nc" id="L2742">                    outputNeighbors.add(p);</span>
                }
            }
        }
<span class="nc" id="L2746">    }</span>

    /**
     * NOT YET TESTED
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(GreyscaleImage gsImg, float x, float y) {

<span class="fc" id="L2759">        double x1 = Math.floor(x);</span>

<span class="fc" id="L2761">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L2763">        double y1 = Math.floor(y);</span>

<span class="fc" id="L2765">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="fc bfc" id="L2769" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L2771">            v1 = gsImg.getValue((int)x1, (int)y1);</span>

<span class="fc bfc" id="L2773" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2774">                return v1;</span>
            }

<span class="fc" id="L2777">            v2 = gsImg.getValue((int)x1, (int)y2);</span>

        } else {

            // interpolate over row y1
<span class="fc" id="L2782">            v1 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y1) +</span>
<span class="fc" id="L2783">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y1);</span>

<span class="fc bfc" id="L2785" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L2786">                return v1;</span>
            }

            // interpolate over row y2
<span class="fc" id="L2790">            v2 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y2) +</span>
<span class="fc" id="L2791">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y2);</span>
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2795">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="fc" id="L2797">        return v;</span>
    }

    /**
    NOT YET TESTED
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     *
     * @param x
     * @param y
     * @return
     */
    public double[] biLinearInterpolation(Image clrImg, float x, float y) {

<span class="fc" id="L2811">        double x1 = Math.floor(x);</span>

<span class="fc" id="L2813">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L2815">        double y1 = Math.floor(y);</span>

<span class="fc" id="L2817">        double y2 = Math.ceil(y);</span>

        double r1, r2, g1, g2, b1, b2;

<span class="fc bfc" id="L2821" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L2823">            r1 = clrImg.getR((int)x1, (int)y1);</span>
<span class="fc" id="L2824">            g1 = clrImg.getG((int)x1, (int)y1);</span>
<span class="fc" id="L2825">            b1 = clrImg.getB((int)x1, (int)y1);</span>

<span class="pc bpc" id="L2827" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="fc" id="L2828">                return new double[]{r1, g1, b1};</span>
            }

<span class="nc" id="L2831">            r2 = clrImg.getR((int)x1, (int)y2);</span>
<span class="nc" id="L2832">            g2 = clrImg.getG((int)x1, (int)y2);</span>
<span class="nc" id="L2833">            b2 = clrImg.getB((int)x1, (int)y2);</span>

        } else {

<span class="fc" id="L2837">            double v1X2Frac = ((x2 - x)/(x2 - x1));</span>
<span class="fc" id="L2838">            double v1X1Frac = ((x - x1)/(x2 - x1));</span>

            // interpolate over row y1
<span class="fc" id="L2841">            r1 = v1X2Frac * clrImg.getR((int)x1, (int)y1) +</span>
<span class="fc" id="L2842">                v1X1Frac * clrImg.getR((int)x2, (int)y1);</span>

<span class="fc" id="L2844">            g1 = v1X2Frac * clrImg.getG((int)x1, (int)y1) +</span>
<span class="fc" id="L2845">                v1X1Frac * clrImg.getG((int)x2, (int)y1);</span>

<span class="fc" id="L2847">            b1 = v1X2Frac * clrImg.getB((int)x1, (int)y1) +</span>
<span class="fc" id="L2848">                v1X1Frac * clrImg.getB((int)x2, (int)y1);</span>

<span class="pc bpc" id="L2850" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L2851">                return new double[]{r1, g1, b1};</span>
            }

            // interpolate over row y2
<span class="fc" id="L2855">            r2 = v1X2Frac * clrImg.getR((int)x1, (int)y2) +</span>
<span class="fc" id="L2856">                v1X1Frac * clrImg.getR((int)x2, (int)y2);</span>

<span class="fc" id="L2858">            g2 = v1X2Frac * clrImg.getG((int)x1, (int)y2) +</span>
<span class="fc" id="L2859">                v1X1Frac * clrImg.getG((int)x2, (int)y2);</span>

<span class="fc" id="L2861">            b2 = v1X2Frac * clrImg.getB((int)x1, (int)y2) +</span>
<span class="fc" id="L2862">                v1X1Frac * clrImg.getB((int)x2, (int)y2);</span>
        }

<span class="fc" id="L2865">        double v1Y2Frac = ((y2 - y)/(y2 - y1));</span>
<span class="fc" id="L2866">        double v1Y1Frac = ((y - y1)/(y2 - y1));</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2869">        double r = v1Y2Frac * r1 + v1Y1Frac * r2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2872">        double g = v1Y2Frac * g1 + v1Y1Frac * g2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L2875">        double b = v1Y2Frac * b1 + v1Y1Frac * b2;</span>

<span class="fc" id="L2877">        return new double[]{r, g, b};</span>
    }

    public void applyAdaptiveMeanThresholding(GreyscaleImage img) {

<span class="nc" id="L2882">        applyAdaptiveMeanThresholding(img, 3);</span>
<span class="nc" id="L2883">    }</span>

    public void applyAdaptiveMeanThresholding(GreyscaleImage img,
        int halfDimension) {

<span class="fc" id="L2888">        GreyscaleImage imgM = img.copyImage();</span>

        /*
        7 x 7 averaging
        */
<span class="fc" id="L2893">        applyCenteredMean(imgM, halfDimension);</span>

<span class="fc" id="L2895">        int c = 7;</span>

<span class="fc" id="L2897">        int foreground = 255;//1;</span>
<span class="fc" id="L2898">        int background = 0;</span>

<span class="fc bfc" id="L2900" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="fc bfc" id="L2901" title="All 2 branches covered.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="fc" id="L2902">                int v = img.getValue(i, j);</span>
<span class="fc" id="L2903">                int m = imgM.getValue(i, j);</span>
<span class="fc" id="L2904">                int t = m - c;</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">                if (v &gt; t) {</span>
<span class="fc" id="L2906">                    img.setValue(i, j, foreground);</span>
                } else {
<span class="fc" id="L2908">                    img.setValue(i, j, background);</span>
                }
            }
        }

<span class="fc" id="L2913">        imgM = null;</span>

<span class="fc" id="L2915">        System.gc();</span>
<span class="fc" id="L2916">    }</span>

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel.  The calculation starts at 0 and the end
     * dimension pixels are averaged using the decreasing number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for dimension = 2 becomes:
     * [11] [12] [12]
     * [11] [12] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels)
     * This can be used as part of adaptive mean thresholding.
     * 
     * @param img
     * @param dimension
     */
    public void applyBoxcarMean(GreyscaleImage img, int dimension) {

<span class="pc bpc" id="L2939" title="2 of 4 branches missed.">        if ((img.getWidth() &lt; dimension) || (img.getHeight() &lt; dimension)) {</span>
<span class="nc" id="L2940">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }

        /*
        becomes efficient when dimension &gt; 3

        sum along columns first using dynamic programming:
        sumCol[j=0] = sum_j=0_to_dim of row[i]
        sumCol[j=1] = sumCol[0] - row[j-1] + row[dim + j - 1]
        sumCol[j=2] = sumCol[1] - row[j-1] + row[dim + j - 1]
        */

<span class="fc" id="L2953">        int w = img.getWidth();</span>
<span class="fc" id="L2954">        int h = img.getHeight();</span>

<span class="fc" id="L2956">        int[] mean = new int[img.getNPixels()];</span>
        
        // sum along rows
<span class="fc bfc" id="L2959" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L2960">            int sum0 = 0;</span>
<span class="fc bfc" id="L2961" title="All 2 branches covered.">            for (int j = 0; j &lt; dimension; ++j) {</span>
<span class="fc" id="L2962">                sum0 += img.getValue(i, j);</span>
            }
<span class="fc" id="L2964">            mean[img.getInternalIndex(i, 0)] = sum0;</span>
<span class="fc bfc" id="L2965" title="All 2 branches covered.">            for (int j = 1; j &lt;= (h - dimension); ++j) {</span>
<span class="fc" id="L2966">                int vp = img.getValue(i, j - 1);</span>
<span class="fc" id="L2967">                int vl =  img.getValue(i, dimension + j - 1);</span>
<span class="fc" id="L2968">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L2969">                mean[img.getInternalIndex(i, j)] = sum0;</span>
            }
            // last dimension - 1 rows: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L2972" title="All 2 branches covered.">            for (int j = (h - dimension + 1); j &lt; h; ++j) {</span>
<span class="fc" id="L2973">                float count = h - j;</span>
<span class="fc" id="L2974">                float sum = 0;</span>
<span class="fc bfc" id="L2975" title="All 2 branches covered.">                for (int k = j; k &lt; h; ++k) {</span>
<span class="fc" id="L2976">                    sum += img.getValue(i, k);</span>
                }
<span class="fc" id="L2978">                sum /= count;</span>
<span class="fc" id="L2979">                sum *= dimension;</span>
<span class="fc" id="L2980">                mean[img.getInternalIndex(i, j)] = Math.round(sum);</span>
            }
        }

<span class="fc" id="L2984">        int[] mean2 = new int[img.getNPixels()];</span>
      
        // sum along columns
<span class="fc bfc" id="L2987" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L2988">            int sum0 = 0;</span>
<span class="fc bfc" id="L2989" title="All 2 branches covered.">            for (int i = 0; i &lt; dimension; ++i) {</span>
<span class="fc" id="L2990">                sum0 += mean[img.getInternalIndex(i, j)];</span>
            }
<span class="fc" id="L2992">            mean2[img.getInternalIndex(0, j)] = sum0;</span>
<span class="fc bfc" id="L2993" title="All 2 branches covered.">            for (int i = 1; i &lt;= (w - dimension); ++i) {</span>
<span class="fc" id="L2994">                int vp = mean[img.getInternalIndex(i - 1, j)];</span>
<span class="fc" id="L2995">                int vl = mean[img.getInternalIndex(dimension + i - 1, j)];</span>
<span class="fc" id="L2996">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L2997">                mean2[img.getInternalIndex(i, j)] = sum0;</span>
            }

            // last dimension - 1 cols: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L3001" title="All 2 branches covered.">            for (int i = (w - dimension + 1); i &lt; w; ++i) {</span>
<span class="fc" id="L3002">                float count = h - i;</span>
<span class="fc" id="L3003">                float sum = 0;</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">                for (int k = i; k &lt; w; ++k) {</span>
<span class="fc" id="L3005">                    sum += mean[img.getInternalIndex(k, j)];</span>
                }
<span class="fc" id="L3007">                sum /= count;</span>
<span class="fc" id="L3008">                sum *= dimension;</span>
<span class="fc" id="L3009">                mean2[img.getInternalIndex(i, j)] = Math.round(sum);</span>
            }
        }

        // divide each value by dimension * dimension
<span class="fc" id="L3014">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3015" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3016" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3017">                int v = mean2[img.getInternalIndex(i, j)];</span>
<span class="fc" id="L3018">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3019">                img.setValue(i, j, v);</span>
            }
        }
<span class="fc" id="L3022">    }</span>

    /**
     * create an image of the mean of the surrounding dimension x dimension
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a descreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]
     * [10] [12] [12]
     *
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels)
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean(GreyscaleImage img, int halfDimension) {

<span class="pc bpc" id="L3045" title="1 of 2 branches missed.">        if ((img.getWidth() &lt; 2*halfDimension) ||</span>
<span class="pc bpc" id="L3046" title="1 of 2 branches missed.">            (img.getHeight() &lt; 2*halfDimension)) {</span>
<span class="nc" id="L3047">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }

        /*
        becomes efficient when halfDimension &gt; 1

        sum along columns first using dynamic programming, then rows
        */

<span class="fc" id="L3057">        int dimension = 2*halfDimension + 1;</span>

<span class="fc" id="L3059">        int w = img.getWidth();</span>
<span class="fc" id="L3060">        int h = img.getHeight();</span>

<span class="fc" id="L3062">        int[] mean = new int[img.getNPixels()];</span>
        
<span class="fc" id="L3064">        int[] imgValues = img.getValues();</span>
        
        // sum along rows
<span class="fc bfc" id="L3067" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>

            /* pixels before halfDimension
            halfDimension = 2
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3074" title="All 2 branches covered.">            for (int j = 0; j &lt; halfDimension; ++j) {</span>
<span class="fc" id="L3075">                float count = halfDimension - j;</span>
<span class="fc" id="L3076">                float sum = 0;</span>
<span class="fc bfc" id="L3077" title="All 2 branches covered.">                for (int k = j; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3078">                    int pixIdx = img.getIndex(i, k);</span>
<span class="fc" id="L3079">                    sum += imgValues[pixIdx];</span>
                }
<span class="fc" id="L3081">                sum /= count;</span>
<span class="fc" id="L3082">                sum *= dimension;</span>
<span class="fc" id="L3083">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3084">                mean[pixIdx] = Math.round(sum);</span>
            }

            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3093">            int sum0 = 0;</span>
<span class="fc bfc" id="L3094" title="All 2 branches covered.">            for (int j = 0; j &lt;= 2*halfDimension; ++j) {</span>
<span class="fc" id="L3095">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3096">                sum0 += imgValues[pixIdx];</span>
            }
<span class="fc" id="L3098">            int pixIdx = img.getIndex(i, halfDimension);</span>
<span class="fc" id="L3099">            mean[pixIdx] = sum0;</span>
            /*
            halfDimension = 2
            0 1 2 3 4 5 6
              |   *   |
                |   *   |

            */
<span class="fc bfc" id="L3107" title="All 2 branches covered.">            for (int j = halfDimension + 1; j &lt; (h - halfDimension); ++j) {</span>
<span class="fc" id="L3108">                pixIdx = img.getIndex(i, j - halfDimension - 1);</span>
<span class="fc" id="L3109">                int vp = imgValues[pixIdx];</span>
<span class="fc" id="L3110">                pixIdx = img.getIndex(i, j + halfDimension);</span>
<span class="fc" id="L3111">                int vl =  imgValues[pixIdx];</span>
<span class="fc" id="L3112">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3113">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3114">                mean[pixIdx] = sum0;</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2
                &gt;
            */
<span class="fc bfc" id="L3120" title="All 2 branches covered.">            for (int j = (h - halfDimension); j &lt; h; ++j) {</span>
<span class="fc" id="L3121">                float count = h - j + 1;</span>
<span class="fc" id="L3122">                float sum = 0;</span>
<span class="fc bfc" id="L3123" title="All 2 branches covered.">                for (int k = (j - 1); k &lt; h; ++k) {</span>
<span class="fc" id="L3124">                    pixIdx = img.getIndex(i, k);</span>
<span class="fc" id="L3125">                    sum +=  imgValues[pixIdx];</span>
                }
<span class="fc" id="L3127">                sum /= count;</span>
<span class="fc" id="L3128">                sum *= dimension;</span>
<span class="fc" id="L3129">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3130">                mean[pixIdx] = Math.round(sum);</span>
            }
        }

        // sum along columns
<span class="fc bfc" id="L3135" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>

            /* pixels before halfDimension
            halfDimension = 2
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3142" title="All 2 branches covered.">            for (int i = 0; i &lt; halfDimension; ++i) {</span>
<span class="fc" id="L3143">                float count = halfDimension - i;</span>
<span class="fc" id="L3144">                float sum = 0;</span>
<span class="fc bfc" id="L3145" title="All 2 branches covered.">                for (int k = i; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3146">                    int pixIdx = img.getIndex(k, j);</span>
<span class="fc" id="L3147">                    sum += mean[pixIdx];                    </span>
                }
<span class="fc" id="L3149">                sum /= count;</span>
<span class="fc" id="L3150">                sum *= dimension;</span>
<span class="fc" id="L3151">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3152">                imgValues[pixIdx] =  Math.round(sum);</span>
            }

            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3161">            int sum0 = 0;</span>
<span class="fc bfc" id="L3162" title="All 2 branches covered.">            for (int i = 0; i &lt;= 2*halfDimension; ++i) {</span>
<span class="fc" id="L3163">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3164">                sum0 += mean[pixIdx]; </span>
            }
<span class="fc" id="L3166">            int pixIdx = img.getIndex(halfDimension, j);</span>
<span class="fc" id="L3167">            imgValues[pixIdx] = sum0;</span>
            /*
            halfDimension = 2
            0 1 2 3 4 5 6
              |   *   |
                |   *   |

            */
<span class="fc bfc" id="L3175" title="All 2 branches covered.">            for (int i = halfDimension + 1; i &lt; (w - halfDimension); ++i) {</span>
<span class="fc" id="L3176">                pixIdx = img.getIndex(i - halfDimension - 1, j);</span>
<span class="fc" id="L3177">                int vp = mean[pixIdx];</span>
<span class="fc" id="L3178">                pixIdx = img.getIndex(i + halfDimension, j);</span>
<span class="fc" id="L3179">                int vl =  mean[pixIdx];</span>
<span class="fc" id="L3180">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3181">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3182">                imgValues[pixIdx] = sum0;</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2
                &gt;
            */
<span class="fc bfc" id="L3188" title="All 2 branches covered.">            for (int i = (w - halfDimension); i &lt; w; ++i) {</span>
<span class="fc" id="L3189">                float count = w - i + 1;</span>
<span class="fc" id="L3190">                float sum = 0;</span>
<span class="fc bfc" id="L3191" title="All 2 branches covered.">                for (int k = (i - 1); k &lt; w; ++k) {</span>
<span class="fc" id="L3192">                    pixIdx = img.getIndex(k, j);</span>
<span class="fc" id="L3193">                    sum += mean[pixIdx];</span>
                }
<span class="fc" id="L3195">                sum /= count;</span>
<span class="fc" id="L3196">                sum *= dimension;</span>
<span class="fc" id="L3197">                pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3198">                imgValues[pixIdx] = Math.round(sum);</span>
            }
        }

        // divide each value by dimension * dimension
<span class="fc" id="L3203">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3204" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3205" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3206">                int pixIdx = img.getIndex(i, j);</span>
<span class="fc" id="L3207">                int v = imgValues[pixIdx];</span>
<span class="fc" id="L3208">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3209">                imgValues[pixIdx] = v;</span>
            }
        }
<span class="fc bfc" id="L3212" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L3213">            img.setValue(i, imgValues[i]);</span>
        }
<span class="fc" id="L3215">    }</span>

    public GreyscaleImage createSmallImage(int bufferSize, Set&lt;PairInt&gt; points, 
        int pointValue) {
        
        //minMaxXY int[]{xMin, xMax, yMin, yMax}
<span class="nc" id="L3221">        int[] minMaxXY = MiscMath.findMinMaxXY(points);</span>
        
<span class="nc" id="L3223">        int xOffset = minMaxXY[0] - bufferSize;</span>
<span class="nc" id="L3224">        int yOffset = minMaxXY[2] - bufferSize;</span>
        
<span class="nc" id="L3226">        int width = (minMaxXY[1] - minMaxXY[0]) + (2 * bufferSize);</span>
<span class="nc" id="L3227">        int height = (minMaxXY[3] - minMaxXY[2]) + (2 * bufferSize);</span>
        
<span class="nc" id="L3229">        GreyscaleImage img = new GreyscaleImage(width, height);</span>
<span class="nc" id="L3230">        img.setXRelativeOffset(xOffset);</span>
<span class="nc" id="L3231">        img.setYRelativeOffset(yOffset);</span>
<span class="nc bnc" id="L3232" title="All 2 branches missed.">        for (PairInt p : points) {</span>
<span class="nc" id="L3233">            int x = p.getX() - xOffset;</span>
<span class="nc" id="L3234">            int y = p.getY() - yOffset;</span>
<span class="nc" id="L3235">            img.setValue(x, y, pointValue);</span>
<span class="nc" id="L3236">        }</span>
        
<span class="nc" id="L3238">        return img;</span>
    }
    
    public Set&lt;PairInt&gt; extract2ndDerivPoints(GreyscaleImage img) {
        
<span class="nc" id="L3243">        GreyscaleImage gsImg = img.copyImage();</span>
        
<span class="nc" id="L3245">        applySecondDerivGaussian(gsImg, SIGMA.ONE, 0, 255);</span>

<span class="nc" id="L3247">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(gsImg);</span>
<span class="nc" id="L3248">        int v0 = 0;</span>
<span class="nc" id="L3249">        int c0 = 0;</span>
<span class="nc" id="L3250">        int v1 = 0;</span>
<span class="nc" id="L3251">        int c1 = 0;</span>
<span class="nc bnc" id="L3252" title="All 2 branches missed.">        for (int i = (valueCounts.getN() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L3253">            int v = valueCounts.getX(i);</span>
<span class="nc" id="L3254">            int c = valueCounts.getY(i);</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">            if (v0 == 0) {</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">                if (c &gt; 12) {</span>
<span class="nc" id="L3257">                    v0 = v;</span>
<span class="nc" id="L3258">                    c0 = c;</span>
                }
<span class="nc bnc" id="L3260" title="All 2 branches missed.">            } else if (c &lt; (2.5 * c0)) {</span>
<span class="nc" id="L3261">                v1 = v;</span>
<span class="nc" id="L3262">                c1 = c;</span>
            } else {
                break;
            }
        }

<span class="nc" id="L3268">        Set&lt;PairInt&gt; pixels = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">        for (int i = 0; i &lt; gsImg.getNPixels(); ++i) {</span>
<span class="nc" id="L3270">            int v = gsImg.getValue(i);</span>
<span class="nc" id="L3271">            int x = gsImg.getCol(i);</span>
<span class="nc" id="L3272">            int y = gsImg.getRow(i);</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">            if (v &gt;= v1) {</span>
<span class="nc" id="L3274">                pixels.add(new PairInt(x, y));</span>
            }
        }
        
<span class="nc" id="L3278">        log.info(&quot;before nPoints=&quot; + pixels.size());</span>
        
<span class="nc" id="L3280">        reduceTo4NeighborCentroids(pixels);</span>
        
<span class="nc" id="L3282">        log.info(&quot;after nPoints=&quot; + pixels.size());</span>
        
<span class="nc" id="L3284">        return pixels;</span>
    }
    
    /**
     * NOT READY FOR USE YET
     * extract the high value points in the second derivative gaussian of
     * img to a number of points less than or equal to maxNPoints and
     * if the variable reduceForNoise is true, then look for patterns
     * of noise and reduce the maximum value extracted from the 2nd deriv 
     * points until no noise patterns are seen.
     * @param img
     * @param maxNPoints
     * @param reduceForNoise
     * @return 
     */
    public Set&lt;PairInt&gt; extract2ndDerivPoints(GreyscaleImage img, int maxNPoints,
        boolean reduceForNoise) {
        
<span class="fc" id="L3302">        GreyscaleImage gsImg = img.copyImage();</span>
        
<span class="fc" id="L3304">        applySecondDerivGaussian(gsImg, SIGMA.ONE, 0, 255);</span>
        
<span class="fc" id="L3306">        PairIntArray valueCounts = Histogram.createADescendingSortbyFrequencyArray(gsImg);</span>
<span class="fc" id="L3307">        int nTot = 0;</span>
<span class="fc" id="L3308">        int v1 = 0;</span>
<span class="pc bpc" id="L3309" title="1 of 2 branches missed.">        for (int i = (valueCounts.getN() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L3310">            int c = valueCounts.getY(i);</span>
<span class="fc" id="L3311">            int nTmp = nTot + c;</span>
<span class="fc bfc" id="L3312" title="All 2 branches covered.">            if (nTmp &lt; maxNPoints) {</span>
<span class="fc" id="L3313">                nTot += c;</span>
<span class="fc" id="L3314">                v1 = valueCounts.getX(i);</span>
            } else {
                break;
            }
        }

<span class="fc" id="L3320">        Set&lt;PairInt&gt; pixels = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L3321" title="All 2 branches covered.">        for (int i = 0; i &lt; gsImg.getNPixels(); ++i) {</span>
<span class="fc" id="L3322">            int v = gsImg.getValue(i);</span>
<span class="fc bfc" id="L3323" title="All 2 branches covered.">            if (v &gt;= v1) {</span>
<span class="fc" id="L3324">                int x = gsImg.getCol(i);</span>
<span class="fc" id="L3325">                int y = gsImg.getRow(i);</span>
<span class="fc" id="L3326">                pixels.add(new PairInt(x, y));</span>
            }
        }
        
<span class="fc" id="L3330">        log.info(&quot;before nPoints=&quot; + pixels.size());</span>
        
<span class="fc" id="L3332">        reduceTo4NeighborCentroids(pixels);</span>
        
<span class="fc" id="L3334">        log.info(&quot;after nPoints=&quot; + pixels.size());</span>
        
<span class="pc bpc" id="L3336" title="1 of 2 branches missed.">        if (reduceForNoise) {</span>
            // look for patterns of noise and reduce v1 until not present
        }
        
<span class="fc" id="L3340">        return pixels;</span>
    }

    private void reduceTo4NeighborCentroids(Set&lt;PairInt&gt; pixels) {
        
<span class="fc" id="L3345">        Set&lt;PairInt&gt; processed = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L3347">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L3349">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L3351">        int[] dxs = Misc.dx4;</span>
<span class="fc" id="L3352">        int[] dys = Misc.dy4;</span>
        
<span class="fc" id="L3354">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L3356" title="All 2 branches covered.">        for (PairInt p : pixels) {</span>
            
<span class="fc bfc" id="L3358" title="All 2 branches covered.">            if (processed.contains(p)) {</span>
<span class="fc" id="L3359">                continue;</span>
            }
            
<span class="fc" id="L3362">            curveHelper.findNeighbors(p.getX(), p.getY(), pixels, processed, </span>
                dxs, dys, neighbors);
            
<span class="fc" id="L3365">            processed.add(p);</span>
<span class="fc" id="L3366">            processed.addAll(neighbors);</span>
            
<span class="fc bfc" id="L3368" title="All 2 branches covered.">            if (neighbors.size() == 0) {</span>
<span class="fc" id="L3369">                output.add(p);</span>
            } else {
<span class="fc" id="L3371">                double[] xyCen = curveHelper.calculateXYCentroids(neighbors);</span>
<span class="fc" id="L3372">                int x = (int)Math.round(xyCen[0]);</span>
<span class="fc" id="L3373">                int y = (int)Math.round(xyCen[1]);</span>
<span class="pc bpc" id="L3374" title="3 of 4 branches missed.">                assert(Math.abs(x - p.getX()) &lt;= 2);</span>
<span class="pc bpc" id="L3375" title="3 of 4 branches missed.">                assert(Math.abs(y - p.getY()) &lt;= 2);</span>
<span class="fc" id="L3376">                output.add(new PairInt(x, y));</span>
            }
<span class="fc" id="L3378">        }</span>
        
<span class="fc" id="L3380">        pixels.clear();</span>
<span class="fc" id="L3381">        pixels.addAll(output);</span>
        
<span class="fc" id="L3383">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
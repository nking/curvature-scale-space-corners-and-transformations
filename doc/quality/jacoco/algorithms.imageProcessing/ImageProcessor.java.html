<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageProcessor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ImageProcessor.java</span></div><h1>ImageProcessor.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.clustering.KMeansPlusPlus;
import algorithms.compGeometry.clustering.KMeansPlusPlusFloat;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonAndPointPlotter;
import algorithms.util.PairInt;
import algorithms.misc.Complex;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.MiscDebug;
import algorithms.util.Errors;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="fc" id="L34">public class ImageProcessor {</span>

<span class="fc" id="L36">    protected Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * &lt;pre&gt;
     * [1, 0, -1]
     * this is the n=2 binomial filter for a Gaussian first derivative,
       that is sigma = sqrt(2)/2 = 0.707
       &lt;/pre&gt;
     * @param input 
     */
    public void applySobelKernel(Image input) {

<span class="nc" id="L48">        IKernel kernel = new SobelX();</span>
<span class="nc" id="L49">        Kernel kernelX = kernel.getKernel();</span>

<span class="nc" id="L51">        float normX = kernel.getNormalizationFactor();</span>

<span class="nc" id="L53">        kernel = new SobelY();</span>
<span class="nc" id="L54">        Kernel kernelY = kernel.getKernel();</span>

<span class="nc" id="L56">        float normY = kernel.getNormalizationFactor();</span>

<span class="nc" id="L58">        applyKernels(input, kernelX, kernelY, normX, normY);</span>
<span class="nc" id="L59">    }</span>


    public void applySobelKernel(GreyscaleImage input) {

<span class="nc" id="L64">        IKernel kernel = new SobelX();</span>
<span class="nc" id="L65">        Kernel kernelX = kernel.getKernel();</span>

<span class="nc" id="L67">        float normX = kernel.getNormalizationFactor();</span>

<span class="nc" id="L69">        kernel = new SobelY();</span>
<span class="nc" id="L70">        Kernel kernelY = kernel.getKernel();</span>

<span class="nc" id="L72">        float normY = kernel.getNormalizationFactor();</span>

<span class="nc" id="L74">        applyKernels(input, kernelX, kernelY, normX, normY);</span>
<span class="nc" id="L75">    }</span>

    public void applyLaplacianKernel(GreyscaleImage input) {

<span class="nc" id="L79">        IKernel kernel = new Laplacian();</span>
<span class="nc" id="L80">        Kernel kernelXY = kernel.getKernel();</span>

<span class="nc" id="L82">        float norm = kernel.getNormalizationFactor();</span>

<span class="nc" id="L84">        applyKernel(input, kernelXY, norm);</span>
<span class="nc" id="L85">    }</span>

    protected void applyKernels(Image input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L96">        Image imgX = input.copyImage();</span>

<span class="nc" id="L98">        Image imgY = input.copyImage();</span>

<span class="nc" id="L100">        applyKernel(imgX, kernelX, normFactorX);</span>

<span class="nc" id="L102">        applyKernel(imgY, kernelY, normFactorY);</span>

<span class="nc" id="L104">        Image img2 = combineConvolvedImages(imgX, imgY);</span>

<span class="nc" id="L106">        input.resetTo(img2);</span>
<span class="nc" id="L107">    }</span>

    protected void applyKernels(GreyscaleImage input, Kernel kernelX, Kernel kernelY,
        float normFactorX, float normFactorY) {

        /*
        assumes that kernelX is applied to a copy of the img
        and kernelY is applied to a separate copy of the img and
        then they are added in quadrature for the final result.
        */

<span class="nc" id="L118">        GreyscaleImage imgX = input.copyImage();</span>

<span class="nc" id="L120">        GreyscaleImage imgY = input.copyImage();</span>

<span class="nc" id="L122">        applyKernel(imgX, kernelX, normFactorX);</span>

<span class="nc" id="L124">        applyKernel(imgY, kernelY, normFactorY);</span>

<span class="nc" id="L126">        GreyscaleImage img2 = combineConvolvedImages(imgX, imgY);</span>

<span class="nc" id="L128">        input.resetTo(img2);</span>
<span class="nc" id="L129">    }</span>

    public Image combineConvolvedImages(Image imageX, Image imageY) {

<span class="fc" id="L133">        Image img2 = new Image(imageX.getWidth(), imageX.getHeight());</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L138">                int rX = imageX.getR(i, j);</span>
<span class="fc" id="L139">                int gX = imageX.getG(i, j);</span>
<span class="fc" id="L140">                int bX = imageX.getB(i, j);</span>

<span class="fc" id="L142">                int rY = imageY.getR(i, j);</span>
<span class="fc" id="L143">                int gY = imageY.getG(i, j);</span>
<span class="fc" id="L144">                int bY = imageY.getB(i, j);</span>

<span class="fc" id="L146">                double r = Math.sqrt(rX*rX + rY*rY);</span>
<span class="fc" id="L147">                double g = Math.sqrt(gX*gX + gY*gY);</span>
<span class="fc" id="L148">                double b = Math.sqrt(bX*bX + bY*bY);</span>

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                r = (r &gt; 255) ? 255 : r;</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">                g = (g &gt; 255) ? 255 : g;</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">                b = (b &gt; 255) ? 255 : b;</span>

                //int rgb = (int)(((rSum &amp; 0x0ff) &lt;&lt; 16)
                //    | ((gSum &amp; 0x0ff) &lt;&lt; 8) | (bSum &amp; 0x0ff));

<span class="fc" id="L157">                img2.setRGB(i, j, (int)r, (int)g, (int)b);</span>
            }
        }

<span class="fc" id="L161">        return img2;</span>
    }

    /**
     * process only the green channel and set red and blue to zero
     * @param imageX
     * @param imageY
     * @return
     */
    public GreyscaleImage combineConvolvedImages(final GreyscaleImage imageX,
        final GreyscaleImage imageY) {

<span class="fc" id="L173">        GreyscaleImage img2 = imageX.createWithDimensions();</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">        for (int i = 0; i &lt; imageX.getWidth(); i++) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            for (int j = 0; j &lt; imageX.getHeight(); j++) {</span>

<span class="fc" id="L178">                int gX = imageX.getValue(i, j);</span>

<span class="fc" id="L180">                int gY = imageY.getValue(i, j);</span>

                //double g = Math.sqrt(0.5*(gX*gX + gY*gY));

                //g = (g &gt; 255) ? 255 : g;

<span class="fc" id="L186">                double g = Math.sqrt(gX*gX + gY*gY);</span>

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (g &gt; 255) {</span>
<span class="nc" id="L189">                    g = 255;</span>
                }

                //int rgb = (int)(((rSum &amp; 0x0ff) &lt;&lt; 16)
                //    | ((gSum &amp; 0x0ff) &lt;&lt; 8) | (bSum &amp; 0x0ff));

<span class="fc" id="L195">                img2.setValue(i, j, (int)g);</span>
            }
        }

<span class="fc" id="L199">        return img2;</span>
    }

    /**
     * apply kernel to input. NOTE, that because the image is composed of
     * vectors that should have values between 0 and 255, inclusive, if the
     * kernel application results in a value outside of that range, the value
     * is reset to 0 or 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(Image input, Kernel kernel, float normFactor) {

<span class="nc" id="L213">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="nc" id="L215">        Image output = new Image(input.getWidth(), input.getHeight());</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="nc" id="L220">                long rValue = 0;</span>
<span class="nc" id="L221">                long gValue = 0;</span>
<span class="nc" id="L222">                long bValue = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L226" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="nc" id="L228">                    int x = col - h;</span>

<span class="nc" id="L230">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L234">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="nc" id="L236">                        int diff = imgX - input.getWidth();</span>
<span class="nc" id="L237">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="nc bnc" id="L240" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="nc" id="L242">                        int y = row - h;</span>

<span class="nc" id="L244">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L247" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L248">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="nc" id="L250">                            int diff = imgY - input.getHeight();</span>
<span class="nc" id="L251">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="nc" id="L254">                        int rPixel = input.getR(imgX, imgY);</span>
<span class="nc" id="L255">                        int gPixel = input.getG(imgX, imgY);</span>
<span class="nc" id="L256">                        int bPixel = input.getB(imgX, imgY);</span>

<span class="nc" id="L258">                        int k = kernel.getValue(col, row);</span>

<span class="nc" id="L260">                        rValue += k * rPixel;</span>
<span class="nc" id="L261">                        gValue += k * gPixel;</span>
<span class="nc" id="L262">                        bValue += k * bPixel;</span>
                    }
                }

<span class="nc" id="L266">                rValue *= normFactor;</span>
<span class="nc" id="L267">                gValue *= normFactor;</span>
<span class="nc" id="L268">                bValue *= normFactor;</span>

                /*
                if ((rValue &gt; 255) || (rValue &lt; 0)) {
                    throw new IllegalStateException(&quot;rValue is &quot; + rValue);
                }
                if ((gValue &gt; 255) || (gValue &lt; 0)) {
                    throw new IllegalStateException(&quot;gValue is &quot; + gValue);
                }
                if ((bValue &gt; 255) || (bValue &lt; 0)) {
                    throw new IllegalStateException(&quot;bValue is &quot; + bValue);
                }*/

<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (rValue &lt; 0) {</span>
<span class="nc" id="L282">                    rValue = 0;</span>
                }
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (rValue &gt; 255) {</span>
<span class="nc" id="L285">                    rValue = 255;</span>
                }
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (gValue &lt; 0) {</span>
<span class="nc" id="L288">                    gValue = 0;</span>
                }
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (gValue &gt; 255) {</span>
<span class="nc" id="L291">                    gValue = 255;</span>
                }
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if (bValue &lt; 0) {</span>
<span class="nc" id="L294">                    bValue = 0;</span>
                }
<span class="nc bnc" id="L296" title="All 2 branches missed.">                if (bValue &gt; 255) {</span>
<span class="nc" id="L297">                    bValue = 255;</span>
                }

<span class="nc" id="L300">                output.setRGB(i, j, (int)rValue, (int)gValue, (int)bValue);</span>
            }
        }

<span class="nc" id="L304">        input.resetTo(output);</span>
<span class="nc" id="L305">    }</span>

    /**
     * apply kernel to input. NOTE, that because the image is composed of vectors
     * that should have values between 0 and 255, inclusive, if the kernel application
     * results in a value outside of that range, the value is reset to 0 or
     * 255.
     * @param input
     * @param kernel
     * @param normFactor
     */
    protected void applyKernel(GreyscaleImage input, Kernel kernel, float normFactor) {

<span class="nc" id="L318">        int h = (kernel.getWidth() - 1) &gt;&gt; 1;</span>

<span class="nc" id="L320">        GreyscaleImage output = input.createWithDimensions();</span>

        //TODO: consider changing normalization to be similar to Kernel1DHelper

<span class="nc bnc" id="L324" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>

<span class="nc" id="L327">                long value = 0;</span>

                // apply the kernel to pixels centered in (i, j)

<span class="nc bnc" id="L331" title="All 2 branches missed.">                for (int col = 0; col &lt; kernel.getWidth(); col++) {</span>

<span class="nc" id="L333">                    int x = col - h;</span>

<span class="nc" id="L335">                    int imgX = i + x;</span>

                    // edge corrections.  use replication
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    if (imgX &lt; 0) {</span>
<span class="nc" id="L339">                        imgX = -1 * imgX - 1;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                    } else if (imgX &gt;= input.getWidth()) {</span>
<span class="nc" id="L341">                        int diff = imgX - input.getWidth();</span>
<span class="nc" id="L342">                        imgX = input.getWidth() - diff - 1;</span>
                    }

<span class="nc bnc" id="L345" title="All 2 branches missed.">                    for (int row = 0; row &lt; kernel.getHeight(); row++) {</span>

<span class="nc" id="L347">                        int y = row - h;</span>

<span class="nc" id="L349">                        int imgY = j + y;</span>

                        // edge corrections.  use replication
<span class="nc bnc" id="L352" title="All 2 branches missed.">                        if (imgY &lt; 0) {</span>
<span class="nc" id="L353">                            imgY = -1 * imgY - 1;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                        } else if (imgY &gt;= input.getHeight()) {</span>
<span class="nc" id="L355">                            int diff = imgY - input.getHeight();</span>
<span class="nc" id="L356">                            imgY = input.getHeight() - diff - 1;</span>
                        }

<span class="nc" id="L359">                        int pixel = input.getValue(imgX, imgY);</span>
<span class="nc" id="L360">                        int k = kernel.getValue(col, row);</span>

<span class="nc" id="L362">                        value += k * pixel;</span>
                    }
                }

<span class="nc" id="L366">                value *= normFactor;</span>

<span class="nc bnc" id="L368" title="All 2 branches missed.">                if (value &lt; 0) {</span>
<span class="nc" id="L369">                    value = 0;</span>
                }
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (value &gt; 255) {</span>
<span class="nc" id="L372">                    value = 255;</span>
                }
<span class="nc" id="L374">                output.setValue(i, j, (int)value);</span>
            }
        }

<span class="nc" id="L378">        input.resetTo(output);</span>
<span class="nc" id="L379">    }</span>

    public Image computeTheta(Image convolvedX, Image convolvedY) {

<span class="fc" id="L383">        Image output = new Image(convolvedX.getWidth(), convolvedX.getHeight());</span>

<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L388">                double rX = convolvedX.getR(i, j);</span>
<span class="fc" id="L389">                double gX = convolvedX.getG(i, j);</span>
<span class="fc" id="L390">                double bX = convolvedX.getB(i, j);</span>

<span class="fc" id="L392">                double rY = convolvedY.getR(i, j);</span>
<span class="fc" id="L393">                double gY = convolvedY.getG(i, j);</span>
<span class="fc" id="L394">                double bY = convolvedY.getB(i, j);</span>

<span class="fc" id="L396">                int thetaR = calculateTheta(rX, rY);</span>
<span class="fc" id="L397">                int thetaG = calculateTheta(gX, gY);</span>
<span class="fc" id="L398">                int thetaB = calculateTheta(bX, bY);</span>

<span class="fc" id="L400">                output.setRGB(i, j, thetaR, thetaG, thetaB);</span>
            }
        }

<span class="fc" id="L404">        return output;</span>
    }

    public GreyscaleImage computeTheta(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="fc" id="L410">        GreyscaleImage output = convolvedX.createWithDimensions();</span>

<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="fc" id="L415">                double gX = convolvedX.getValue(i, j);</span>

<span class="fc" id="L417">                double gY = convolvedY.getValue(i, j);</span>

<span class="fc" id="L419">                int thetaG = calculateTheta(gX, gY);</span>

<span class="fc" id="L421">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="fc" id="L426">        return output;</span>
    }

    /**
     * compute theta as a polar angle that increases in a clockwise manner
     * and has a range from 0 to 359, inclusive.
     *
     * @param convolvedX
     * @param convolvedY
     * @return
     */
    public GreyscaleImage computeTheta360(final GreyscaleImage convolvedX,
        final GreyscaleImage convolvedY) {

<span class="nc" id="L440">        GreyscaleImage output = convolvedX.createWithDimensions();</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">        for (int i = 0; i &lt; convolvedX.getWidth(); i++) {</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            for (int j = 0; j &lt; convolvedX.getHeight(); j++) {</span>

<span class="nc" id="L445">                double gX = convolvedX.getValue(i, j);</span>

<span class="nc" id="L447">                double gY = convolvedY.getValue(i, j);</span>

<span class="nc" id="L449">                double thetaR = (2. * Math.PI) - AngleUtil.polarAngleCCW(gX, gY);</span>

<span class="nc" id="L451">                int thetaG = (int)Math.round(thetaR * 180./Math.PI);</span>

<span class="nc bnc" id="L453" title="All 2 branches missed.">                if (thetaG &gt; 359) {</span>
<span class="nc" id="L454">                    thetaG = thetaG - 360;</span>
                }

<span class="nc" id="L457">                output.setValue(i, j, thetaG);</span>

            }
        }

<span class="nc" id="L462">        return output;</span>
    }

    public GreyscaleImage subtractImages(final GreyscaleImage image,
        final GreyscaleImage subtrImage) {

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (image.getWidth() != subtrImage.getWidth()) {</span>
<span class="nc" id="L469">            throw new IllegalArgumentException(&quot;image widths must be the same&quot;);</span>
        }
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (image.getHeight() != subtrImage.getHeight()) {</span>
<span class="nc" id="L472">            throw new IllegalArgumentException(&quot;image heights must be the same&quot;);</span>
        }

<span class="fc" id="L475">        GreyscaleImage output = image.createWithDimensions();</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (int i = 0; i &lt; image.getWidth(); i++) {</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">            for (int j = 0; j &lt; image.getHeight(); j++) {</span>

<span class="fc" id="L480">                int diff = image.getValue(i, j) - subtrImage.getValue(i, j);</span>

<span class="fc" id="L482">                output.setValue(i, j, diff);</span>
            }
        }

<span class="fc" id="L486">        return output;</span>
    }

    protected int calculateTheta(double gradientX, double gradientY) {

        /*  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45

           when X is 0: if Y &gt; 0, theta is 90
           when Y is 0: if X &gt;= 0, theta is 0
        */

<span class="fc bfc" id="L501" title="All 4 branches covered.">        if (gradientX == 0 &amp;&amp; (gradientY != 0)) {</span>
<span class="fc" id="L502">            return 90;</span>
        }

<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (gradientY == 0) {</span>
<span class="fc" id="L506">            return 0;</span>
        }

<span class="fc" id="L509">        double div = gradientY/gradientX;</span>

<span class="fc" id="L511">        double theta = Math.atan(div)*180./Math.PI;</span>

<span class="fc" id="L513">        int angle = (int)theta;</span>

        // +x, +y -&gt; +
        // -x, +y -&gt; -
        // -x, -y -&gt; +
        // +x, -y -&gt; -

<span class="fc bfc" id="L520" title="All 4 branches covered.">        if (!(gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L523">                angle *= -1;</span>
            }
<span class="fc bfc" id="L525" title="All 4 branches covered.">        } else if ((gradientX &lt; 0) &amp;&amp; !(gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="nc" id="L528">                angle *= -1;</span>
            }
<span class="pc bpc" id="L530" title="1 of 4 branches missed.">        } else if ((gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">            if (angle &lt; 0) {</span>
                // make it positive if negative
<span class="nc" id="L533">                angle *= -1;</span>
            }
<span class="pc bpc" id="L535" title="2 of 4 branches missed.">        } else if (!(gradientX &lt; 0) &amp;&amp; (gradientY &lt; 0)) {</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">            if (!(angle &lt; 0)) {</span>
                // make it negative if it's not
<span class="nc" id="L538">                angle *= -1;</span>
            }
        }

<span class="fc" id="L542">        return angle;</span>
    }

    /**
     * images bounded by zero's have to be shrunk to the columns and rows
     * of the first non-zeroes in order to keep the lines that should be
     * attached to the image edges from eroding completely.
     *
     * @param input
     * @return
     */
    public int[] shrinkImageToFirstNonZeros(final GreyscaleImage input) {

<span class="fc" id="L555">        int w = input.getWidth();</span>
<span class="fc" id="L556">        int h = input.getHeight();</span>

<span class="fc" id="L558">        int xNZFirst = -1;</span>
<span class="fc" id="L559">        int xNZLast = -1;</span>
<span class="fc" id="L560">        int yNZFirst = -1;</span>
<span class="fc" id="L561">        int yNZLast = -1;</span>

<span class="pc bpc" id="L563" title="1 of 2 branches missed.">        for (int i = 0; i &lt; w; i++) {</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            for (int j = 0; j &lt; h; j++) {</span>
<span class="fc" id="L565">                int pixValue = input.getValue(i, j);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                if (pixValue &gt; 0) {</span>
<span class="fc" id="L567">                    xNZFirst = i;</span>
<span class="fc" id="L568">                    break;</span>
                }
            }
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if (xNZFirst &gt; -1) {</span>
<span class="fc" id="L572">                break;</span>
            }
        }
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        for (int j = 0; j &lt; h; j++) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            for (int i = 0; i &lt; w; i++) {</span>
<span class="fc" id="L577">                int pixValue = input.getValue(i, j);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (pixValue &gt; 0) {</span>
<span class="fc" id="L579">                    yNZFirst = j;</span>
<span class="fc" id="L580">                    break;</span>
                }
            }
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (yNZFirst &gt; -1) {</span>
<span class="fc" id="L584">                break;</span>
            }
        }

<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        for (int i = (w - 1); i &gt; -1; i--) {</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">            for (int j = (h - 1); j &gt; -1; j--) {</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                if (input.getValue(i, j) &gt; 0) {</span>
<span class="fc" id="L591">                    xNZLast = i;</span>
<span class="fc" id="L592">                    break;</span>
                }
            }
<span class="fc bfc" id="L595" title="All 2 branches covered.">            if (xNZLast &gt; -1) {</span>
<span class="fc" id="L596">                break;</span>
            }
        }

<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        for (int j = (h - 1); j &gt; -1; j--) {</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            for (int i = (w - 1); i &gt; -1; i--) {</span>
<span class="fc" id="L602">                int pixValue = input.getValue(i, j);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">                if (pixValue &gt; 0) {</span>
<span class="fc" id="L604">                    yNZLast = j;</span>
<span class="fc" id="L605">                    break;</span>
                }
            }
<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (yNZLast &gt; -1) {</span>
<span class="fc" id="L609">                break;</span>
            }
        }

<span class="pc bpc" id="L613" title="7 of 8 branches missed.">        if ((xNZFirst &gt; 0) || (xNZLast &lt; (w - 1)) || (yNZFirst &gt; 0) ||</span>
            (yNZLast &lt; (h - 1))) {

            //add a 2 pix border
<span class="fc" id="L617">            xNZFirst -= 2;</span>
<span class="fc" id="L618">            yNZFirst -= 2;</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            if (xNZFirst &lt; 0) {</span>
<span class="fc" id="L620">                xNZFirst = 0;</span>
            }
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">            if (yNZFirst &lt; 0) {</span>
<span class="fc" id="L623">                yNZFirst = 0;</span>
            }
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">            if (xNZLast == -1) {</span>
<span class="nc" id="L626">                xNZLast = input.getWidth() - 1;</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">            } else if (xNZLast &lt; (input.getWidth() - 2)) {</span>
                // add a 1 pix border
<span class="nc" id="L629">                xNZLast += 2;</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">            } else if (xNZLast &lt; (input.getWidth() - 1)) {</span>
                // add a 1 pix border
<span class="fc" id="L632">                xNZLast++;</span>
            }
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">            if (yNZLast == -1) {</span>
<span class="nc" id="L635">                yNZLast = input.getHeight() - 1;</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">            } else if (yNZLast &lt; (input.getHeight() - 2)) {</span>
                // add a 1 pix border
<span class="nc" id="L638">                yNZLast += 2;</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">            } else if (yNZLast &lt; (input.getHeight() - 1)) {</span>
                // add a 1 pix border
<span class="fc" id="L641">                yNZLast++;</span>
            }

<span class="fc" id="L644">            int xLen = xNZLast - xNZFirst + 1;</span>

<span class="fc" id="L646">            int yLen = yNZLast - yNZFirst + 1;</span>

<span class="fc" id="L648">            GreyscaleImage output = new GreyscaleImage(xLen, yLen);</span>
<span class="fc" id="L649">            output.setXRelativeOffset(xNZFirst);</span>
<span class="fc" id="L650">            output.setYRelativeOffset(yNZFirst);</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">            for (int i = xNZFirst; i &lt;= xNZLast; i++) {</span>

<span class="fc" id="L654">                int iIdx = i - xNZFirst;</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">                for (int j = yNZFirst; j &lt;= yNZLast; j++) {</span>

<span class="fc" id="L658">                    int jIdx = j - yNZFirst;</span>

<span class="fc" id="L660">                    output.setValue(iIdx, jIdx, input.getValue(i, j));</span>
                }
            }

<span class="fc" id="L664">            input.resetTo(output);</span>

<span class="fc" id="L666">            return new int[]{xNZFirst, yNZFirst};</span>
        }

<span class="nc" id="L669">        return new int[]{0, 0};</span>
    }

    public void shrinkImage(final GreyscaleImage input,
        int[] offsetsAndDimensions) {

<span class="nc" id="L675">        int w2 = offsetsAndDimensions[2];</span>
<span class="nc" id="L676">        int h2 = offsetsAndDimensions[3];</span>

<span class="nc" id="L678">        int offset1X = offsetsAndDimensions[0];</span>
<span class="nc" id="L679">        int offset1Y = offsetsAndDimensions[1];</span>

<span class="nc" id="L681">        GreyscaleImage output = new GreyscaleImage(w2, h2);</span>
<span class="nc" id="L682">        output.setXRelativeOffset(offset1X);</span>
<span class="nc" id="L683">        output.setYRelativeOffset(offset1Y);</span>

<span class="nc" id="L685">        int x = 0;</span>

<span class="nc" id="L687">        int endCol = (offset1X + w2);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (endCol &gt; input.getWidth()) {</span>
<span class="nc" id="L689">            endCol = input.getWidth();</span>
        }
<span class="nc" id="L691">        int endRow =  (offset1Y + h2);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (endRow &gt; input.getHeight()) {</span>
<span class="nc" id="L693">            endRow = input.getHeight();</span>
        }

<span class="nc bnc" id="L696" title="All 2 branches missed.">        for (int col = offset1X; col &lt; endCol; col++) {</span>

<span class="nc" id="L698">            int y = 0;</span>

<span class="nc bnc" id="L700" title="All 2 branches missed.">            for (int row = offset1Y; row &lt; endRow; row++) {</span>

<span class="nc" id="L702">                int v = input.getValue(col, row);</span>

<span class="nc" id="L704">                output.setValue(x, y, v);</span>

<span class="nc" id="L706">                y++;</span>
            }

<span class="nc" id="L709">            x++;</span>
        }

<span class="nc" id="L712">        input.resetTo(output);</span>
<span class="nc" id="L713">    }</span>

    /**
     * change coordinates of the input as if they were cropped to the given
     * offset and dimensions.
     * @param input
     * @param offsetsAndDimensions int[]{xOffset, yOffset, finalWidth, finalHeight}
     */
    public void shrinkImage(final Set&lt;PairInt&gt; input,
        int[] offsetsAndDimensions) {

        /*
          -------        ____
          |     |  ==&gt;  |    |
          |     |       |____|
          -------
        */
        //xOffset, yOffset, width, height
        // subtract xOffset from x in input and yOffset from y in input

        //TODO: remove points out of bounds of final image

<span class="nc bnc" id="L735" title="All 2 branches missed.">        for (PairInt p : input) {</span>
<span class="nc" id="L736">            p.setX(p.getX() - offsetsAndDimensions[0]);</span>
<span class="nc" id="L737">            p.setY(p.getY() - offsetsAndDimensions[1]);</span>
<span class="nc" id="L738">        }</span>

<span class="nc" id="L740">    }</span>

    /**
     * change coordinates of the input as if they were cropped to the given
     * offset and dimensions.
     * @param input
     * @param offsetsAndDimensions int[]{xOffset, yOffset, finalWidth, finalHeight}
     */
    public void shrinkImage(final PairIntArray input,
        int[] offsetsAndDimensions) {

        /*
          -------        ____
          |     |  ==&gt;  |    |
          |     |       |____|
          -------
        */
        //xOffset, yOffset, width, height
        // subtract xOffset from x in input and yOffset from y in input

        //TODO: remove points out of bounds of final image

<span class="nc bnc" id="L762" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getN(); ++i) {</span>
<span class="nc" id="L763">            int x = input.getX(i) - offsetsAndDimensions[0];</span>
<span class="nc" id="L764">            int y = input.getY(i) - offsetsAndDimensions[1];</span>
<span class="nc" id="L765">            input.set(i, x, y);</span>
        }

<span class="nc" id="L768">    }</span>

    /**
     * applies KMeansPlusPlus algorithm to the values in input to create
     * kBands segmented image (operates on input).
     * @param input
     * @param kBands
     * @throws IOException
     * @throws NoSuchAlgorithmException 
     */
    public void applyImageSegmentation(GreyscaleImage input, int kBands)
        throws IOException, NoSuchAlgorithmException {

<span class="nc" id="L781">        KMeansPlusPlus instance = new KMeansPlusPlus();</span>
<span class="nc" id="L782">        instance.computeMeans(kBands, input);</span>

<span class="nc" id="L784">        int[] binCenters = instance.getCenters();</span>

<span class="nc bnc" id="L786" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc bnc" id="L788" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="nc" id="L790">                int v = input.getValue(col, row);</span>

<span class="nc bnc" id="L792" title="All 2 branches missed.">                for (int i = 0; i &lt; binCenters.length; i++) {</span>

<span class="nc" id="L794">                    int vc = binCenters[i];</span>

<span class="nc bnc" id="L796" title="All 2 branches missed.">                    int bisectorBelow = ((i - 1) &gt; -1) ?</span>
                        ((binCenters[i - 1] + vc) / 2) : 0;

<span class="nc bnc" id="L799" title="All 2 branches missed.">                    int bisectorAbove = ((i + 1) &gt; (binCenters.length - 1)) ?</span>
                        255 : ((binCenters[i + 1] + vc) / 2);

<span class="nc bnc" id="L802" title="All 4 branches missed.">                    if ((v &gt;= bisectorBelow) &amp;&amp; (v &lt;= bisectorAbove)) {</span>

<span class="nc" id="L804">                        input.setValue(col, row, vc);</span>

<span class="nc" id="L806">                        break;</span>
                    }
                }
            }
        }
<span class="nc" id="L811">    }</span>

    public void convertToBinaryImage(GreyscaleImage input) {
<span class="nc bnc" id="L814" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="nc" id="L816">                int v = input.getValue(col, row);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L818">                    input.setValue(col, row, 1);</span>
                }
            }
        }
<span class="nc" id="L822">    }</span>

    /**
     * NOT READY FOR USE YET.
     *
     * @param theta
     * @return
     * @throws java.io.IOException
     * @throws java.security.NoSuchAlgorithmException
     */
    public GreyscaleImage createRoughSkyMask(GreyscaleImage theta) throws
        IOException, NoSuchAlgorithmException {

<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (theta == null) {</span>
<span class="nc" id="L836">            throw new IllegalArgumentException(&quot;theta cannot be null&quot;);</span>
        }

<span class="nc" id="L839">        theta = theta.copyImage();</span>

<span class="nc" id="L841">        applyImageSegmentation(theta, 2);</span>

<span class="nc" id="L843">        subtractMinimum(theta);</span>

<span class="nc" id="L845">        convertToBinaryImage(theta);</span>

<span class="nc" id="L847">        removeSpurs(theta);</span>

<span class="nc" id="L849">        throw new UnsupportedOperationException(&quot;not ready for use yet&quot;);</span>
        //return theta;
    }

    public void multiply(GreyscaleImage input, float m) {

<span class="nc bnc" id="L855" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc bnc" id="L857" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="nc" id="L859">                int v = input.getValue(col, row);</span>

<span class="nc" id="L861">                int f = (int)(m * v);</span>

<span class="nc" id="L863">                input.setValue(col, row, f);</span>
            }
        }
<span class="nc" id="L866">    }</span>

    public void subtractMinimum(GreyscaleImage input) {

<span class="nc" id="L870">        int min = MiscMath.findMin(input.getValues());</span>

<span class="nc bnc" id="L872" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc bnc" id="L874" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="nc" id="L876">                int v = input.getValue(col, row);</span>

<span class="nc" id="L878">                int f = v - min;</span>

<span class="nc" id="L880">                input.setValue(col, row, f);</span>
            }
        }
<span class="nc" id="L883">    }</span>

    /**
     * multiply these images, that is pixel by pixel multiplication.
     * No corrections are made for integer overflow.
     * @param input1
     * @param input2
     * @return
     */
    public GreyscaleImage multiply(GreyscaleImage input1, GreyscaleImage input2)  {

<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (input1 == null) {</span>
<span class="nc" id="L895">            throw new IllegalArgumentException(&quot;input1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L897" title="All 2 branches missed.">        if (input2 == null) {</span>
<span class="nc" id="L898">            throw new IllegalArgumentException(&quot;input2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (input1.getWidth() != input2.getWidth()) {</span>
<span class="nc" id="L901">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same widths&quot;);
        }
<span class="nc bnc" id="L904" title="All 2 branches missed.">        if (input1.getHeight()!= input2.getHeight()) {</span>
<span class="nc" id="L905">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same heights&quot;);
        }

<span class="nc" id="L909">        GreyscaleImage output = input1.createWithDimensions();</span>

<span class="nc bnc" id="L911" title="All 2 branches missed.">        for (int col = 0; col &lt; input1.getWidth(); col++) {</span>

<span class="nc bnc" id="L913" title="All 2 branches missed.">            for (int row = 0; row &lt; input1.getHeight(); row++) {</span>

<span class="nc" id="L915">                int v = input1.getValue(col, row) * input2.getValue(col, row);</span>

<span class="nc" id="L917">                output.setValue(col, row, v);</span>
            }
        }

<span class="nc" id="L921">        return output;</span>
    }

    /**
     * multiply these images, that is pixel by pixel multiplication.
     * input2 is assumed to be 0 or 1
     * @param input1
     * @param input2 the mask of 0's and 1's to apply to input1
     * @return
     */
    public void multiplyBinary(Image input1, GreyscaleImage input2)  {

<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (input1 == null) {</span>
<span class="nc" id="L934">            throw new IllegalArgumentException(&quot;input1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (input2 == null) {</span>
<span class="nc" id="L937">            throw new IllegalArgumentException(&quot;input2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (input1.getWidth() != input2.getWidth()) {</span>
<span class="nc" id="L940">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same widths&quot;);
        }
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (input1.getHeight()!= input2.getHeight()) {</span>
<span class="nc" id="L944">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same heights&quot;);
        }

<span class="nc bnc" id="L948" title="All 2 branches missed.">        for (int col = 0; col &lt; input1.getWidth(); col++) {</span>

<span class="nc bnc" id="L950" title="All 2 branches missed.">            for (int row = 0; row &lt; input1.getHeight(); row++) {</span>

<span class="nc" id="L952">                int m = input2.getValue(col, row);</span>

<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (m == 0) {</span>

<span class="nc" id="L956">                    input1.setRGB(col, row, 0, 0, 0);</span>
                }
            }
        }
<span class="nc" id="L960">    }</span>

    /**
     * compare each pixel and set output to 0 if both inputs are 0, else set
     * output to 1.
     * @param input1
     * @param input2
     * @return
     */
    public GreyscaleImage binaryOr(GreyscaleImage input1, GreyscaleImage input2)  {

<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (input1 == null) {</span>
<span class="nc" id="L972">            throw new IllegalArgumentException(&quot;input1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L974" title="All 2 branches missed.">        if (input2 == null) {</span>
<span class="nc" id="L975">            throw new IllegalArgumentException(&quot;input2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (input1.getWidth() != input2.getWidth()) {</span>
<span class="nc" id="L978">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same widths&quot;);
        }
<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (input1.getHeight()!= input2.getHeight()) {</span>
<span class="nc" id="L982">            throw new IllegalArgumentException(</span>
            &quot;input1 and input2 must have same heights&quot;);
        }

<span class="nc" id="L986">        GreyscaleImage output = input1.createWithDimensions();</span>

<span class="nc bnc" id="L988" title="All 2 branches missed.">        for (int col = 0; col &lt; input1.getWidth(); col++) {</span>

<span class="nc bnc" id="L990" title="All 2 branches missed.">            for (int row = 0; row &lt; input1.getHeight(); row++) {</span>

<span class="nc" id="L992">                int v1 = input1.getValue(col, row);</span>

<span class="nc" id="L994">                int v2 = input2.getValue(col, row);</span>

<span class="nc bnc" id="L996" title="All 4 branches missed.">                if ((v1 != 0) || (v2 != 0)) {</span>
<span class="nc" id="L997">                    output.setValue(col, row, 1);</span>
                }
            }
        }

<span class="nc" id="L1002">        return output;</span>
    }

    protected void blur(GreyscaleImage input, float[] kernel) {

<span class="nc" id="L1007">        applyKernel1D(input, kernel, true);</span>

<span class="nc" id="L1009">        applyKernel1D(input, kernel, false);</span>
<span class="nc" id="L1010">    }</span>

    public void blur(GreyscaleImage input, float sigma) {

<span class="nc" id="L1014">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="nc" id="L1016">        blur(input, kernel);</span>
<span class="nc" id="L1017">    }</span>

    public void blur(GreyscaleImage input, SIGMA sigma) {

<span class="nc" id="L1021">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="nc" id="L1023">        blur(input, kernel);</span>
<span class="nc" id="L1024">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param sigma
     */
    public void blur(Image input, float sigma) {

<span class="nc" id="L1033">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="nc" id="L1035">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1037">        int w = input.getWidth();</span>
<span class="nc" id="L1038">        int h = input.getHeight();</span>
<span class="nc" id="L1039">        Image output = (ImageExt)input.copyImage();</span>

<span class="nc bnc" id="L1041" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1043">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="nc" id="L1045">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1049">        input.resetTo(output);</span>

<span class="nc bnc" id="L1051" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1053">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="nc" id="L1055">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1059">        input.resetTo(output);</span>
<span class="nc" id="L1060">    }</span>

    public void applyKernel1D(GreyscaleImage input, float[] kernel,
        boolean calcForX) {

<span class="nc" id="L1065">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1067">        GreyscaleImage output = input.createWithDimensions();</span>

<span class="nc bnc" id="L1069" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1071">                double conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, calcForX);
<span class="nc" id="L1073">                int g = (int)Math.round(conv);</span>
<span class="nc" id="L1074">                output.setValue(i, j, g);</span>
            }
        }

<span class="nc" id="L1078">        input.resetTo(output);</span>
<span class="nc" id="L1079">    }</span>

    /**
     * blur the r, g, b vectors of image input by sigma.
     * @param input
     * @param kernel iD kernel
     */
    protected void blur(Image input, float[] kernel) {

<span class="nc" id="L1088">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>

<span class="nc" id="L1090">        int w = input.getWidth();</span>
<span class="nc" id="L1091">        int h = input.getHeight();</span>
<span class="nc" id="L1092">        Image output = (ImageExt)input.copyImage();</span>

<span class="nc bnc" id="L1094" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1096">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, true);
<span class="nc" id="L1098">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1102">        input.resetTo(output);</span>

<span class="nc bnc" id="L1104" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1106">                double[] conv = kernel1DHelper.convolvePointWithKernel(</span>
                    input, i, j, kernel, false);
<span class="nc" id="L1108">                output.setRGB(i, j, (int)conv[0], (int)conv[1], (int)conv[2]);</span>
            }
        }

<span class="nc" id="L1112">        input.resetTo(output);</span>
<span class="nc" id="L1113">    }</span>

    public void divideByBlurredSelf(GreyscaleImage input, float sigma) {

<span class="nc" id="L1117">        GreyscaleImage input2 = input.copyImage();</span>

<span class="nc" id="L1119">        blur(input, sigma);</span>

<span class="nc bnc" id="L1121" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L1123">                int v = input.getValue(i, j);</span>
<span class="nc" id="L1124">                int vorig = input2.getValue(i, j);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                if (v != 0) {</span>
<span class="nc" id="L1126">                    float r = (float)vorig/(float)v;</span>
<span class="nc" id="L1127">                    input.setValue(i, j, (int)(100*r));</span>
                }
            }
        }
<span class="nc" id="L1131">    }</span>

    /**
     * make a binary mask with the given zeroCoords as a group of starter points
     * for the mask and also set to '0' any points within zeroCoords' bounds.
     *
     * @param theta
     * @param zeroCoords
     * @return
     */
    public GreyscaleImage createMask(GreyscaleImage theta, PairIntArray zeroCoords) {

<span class="nc" id="L1143">        GreyscaleImage out = theta.createWithDimensions();</span>

<span class="nc" id="L1145">        out.fill(1);</span>

<span class="nc bnc" id="L1147" title="All 2 branches missed.">        for (int pIdx = 0; pIdx &lt; zeroCoords.getN(); pIdx++) {</span>

<span class="nc" id="L1149">            int x = zeroCoords.getX(pIdx);</span>
<span class="nc" id="L1150">            int y = zeroCoords.getY(pIdx);</span>
<span class="nc" id="L1151">            out.setValue(x, y, 0);</span>
        }

<span class="nc" id="L1154">        return out;</span>
    }

    /**
     * make a binary mask with the given zeroCoords as a group of starter points
     * for the mask and also set to '0' any points within zeroCoords' bounds.
     *
     * @param theta
     * @param nonzeroCoords
     * @return
     */
    public GreyscaleImage createInvMask(GreyscaleImage theta,
        PairIntArray nonzeroCoords) {

<span class="nc" id="L1168">        GreyscaleImage out = theta.createWithDimensions();</span>

<span class="nc bnc" id="L1170" title="All 2 branches missed.">        for (int pIdx = 0; pIdx &lt; nonzeroCoords.getN(); pIdx++) {</span>

<span class="nc" id="L1172">            int x = nonzeroCoords.getX(pIdx);</span>
<span class="nc" id="L1173">            int y = nonzeroCoords.getY(pIdx);</span>
<span class="nc" id="L1174">            out.setValue(x, y, 1);</span>
        }

<span class="nc" id="L1177">        return out;</span>
    }

    /**
     * this is meant to operate on an image with only 0's and 1's
     * @param input
     */
    public void removeSpurs(GreyscaleImage input) {

<span class="nc" id="L1186">        int width = input.getWidth();</span>
<span class="nc" id="L1187">        int height = input.getHeight();</span>

<span class="nc" id="L1189">        int nIterMax = 1000;</span>
<span class="nc" id="L1190">        int nIter = 0;</span>
<span class="nc" id="L1191">        int numRemoved = 1;</span>

<span class="nc bnc" id="L1193" title="All 4 branches missed.">        while ((nIter &lt; nIterMax) &amp;&amp; (numRemoved &gt; 0)) {</span>

<span class="nc" id="L1195">            numRemoved = 0;</span>

<span class="nc bnc" id="L1197" title="All 2 branches missed.">            for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc bnc" id="L1199" title="All 4 branches missed.">                if ((col &lt; 2) || (col &gt; (width - 3))) {</span>
<span class="nc" id="L1200">                    continue;</span>
                }

<span class="nc bnc" id="L1203" title="All 2 branches missed.">                for (int row = 0; row &lt; input.getHeight(); row++) {</span>

<span class="nc bnc" id="L1205" title="All 4 branches missed.">                    if ((row &lt; 2) || (row &gt; (height - 3))) {</span>
<span class="nc" id="L1206">                       continue;</span>
                    }

<span class="nc" id="L1209">                    int v = input.getValue(col, row);</span>

<span class="nc bnc" id="L1211" title="All 2 branches missed.">                    if (v == 0) {</span>
<span class="nc" id="L1212">                        continue;</span>
                    }

                    // looking for pixels having only one neighbor who subsequently
                    // has only 1 or 2 neighbors
                    // as long as neither are connected to image boundaries

<span class="nc" id="L1219">                    int neighborIdx = getIndexIfOnlyOneNeighbor(input, col, row);</span>

<span class="nc bnc" id="L1221" title="All 2 branches missed.">                    if (neighborIdx &gt; -1) {</span>
<span class="nc" id="L1222">                        int neighborX = input.getCol(neighborIdx);</span>
<span class="nc" id="L1223">                        int neighborY = input.getRow(neighborIdx);</span>

<span class="nc" id="L1225">                        int nn = count8RegionNeighbors(input, neighborX, neighborY);</span>

<span class="nc bnc" id="L1227" title="All 2 branches missed.">                        if (nn &lt;= 2) {</span>
<span class="nc" id="L1228">                            input.setValue(col, row, 0);</span>
<span class="nc" id="L1229">                            numRemoved++;</span>
                        }
<span class="nc" id="L1231">                    } else {</span>
<span class="nc" id="L1232">                        int n = count8RegionNeighbors(input, col, row);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                        if (n == 0) {</span>
<span class="nc" id="L1234">                            input.setValue(col, row, 0);</span>
<span class="nc" id="L1235">                            numRemoved++;</span>
                        }
                    }
                }
            }

<span class="nc" id="L1241">            log.fine(&quot;numRemoved=&quot; + numRemoved + &quot; nIter=&quot; + nIter);</span>

<span class="nc" id="L1243">            nIter++;</span>
        }

<span class="nc bnc" id="L1246" title="All 2 branches missed.">        if (nIter  &gt; 30) {</span>
            try {
<span class="nc" id="L1248">                multiply(input, 255);</span>
<span class="nc" id="L1249">                ImageDisplayer.displayImage(&quot;segmented for sky&quot;, input);</span>
<span class="nc" id="L1250">                int z = 1;</span>
<span class="nc" id="L1251">            } catch (IOException ex) {</span>
<span class="nc" id="L1252">                Logger.getLogger(ImageProcessor.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L1253">            }</span>
        }
<span class="nc" id="L1255">    }</span>

    public void removeSpurs(Set&lt;PairInt&gt; points, int width, int height) {

<span class="nc" id="L1259">        int nIterMax = 1000;</span>
<span class="nc" id="L1260">        int nIter = 0;</span>
<span class="nc" id="L1261">        int numRemoved = 1;</span>

<span class="nc bnc" id="L1263" title="All 4 branches missed.">        while ((nIter &lt; nIterMax) &amp;&amp; (numRemoved &gt; 0)) {</span>

<span class="nc" id="L1265">            numRemoved = 0;</span>

<span class="nc" id="L1267">            Set&lt;PairInt&gt; rm = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1269" title="All 2 branches missed.">            for (PairInt p : points) {</span>

                // looking for pixels having only one neighbor who subsequently
                // has only 1 or 2 neighbors
                // as long as neither are connected to image boundaries

<span class="nc" id="L1275">                PairInt neighbor = getIndexIfOnlyOneNeighbor(points, p,</span>
                    width, height);

<span class="nc bnc" id="L1278" title="All 2 branches missed.">                if (neighbor != null) {</span>

<span class="nc" id="L1280">                    int nn = count8RegionNeighbors(points, neighbor, width,</span>
                        height);

<span class="nc bnc" id="L1283" title="All 2 branches missed.">                    if (nn &lt;= 2) {</span>
<span class="nc" id="L1284">                        rm.add(p);</span>
<span class="nc" id="L1285">                        numRemoved++;</span>
                    }
<span class="nc" id="L1287">                } else {</span>
<span class="nc" id="L1288">                    int n = count8RegionNeighbors(points, p, width, height);</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                    if (n == 0) {</span>
<span class="nc" id="L1290">                        rm.add(p);</span>
<span class="nc" id="L1291">                        numRemoved++;</span>
                    }
                }
<span class="nc" id="L1294">            }</span>

<span class="nc bnc" id="L1296" title="All 2 branches missed.">            for (PairInt p : rm) {</span>
<span class="nc" id="L1297">                points.remove(p);</span>
<span class="nc" id="L1298">            }</span>

<span class="nc" id="L1300">            log.fine(&quot;numRemoved=&quot; + numRemoved + &quot; nIter=&quot; + nIter);</span>

<span class="nc" id="L1302">            nIter++;</span>
<span class="nc" id="L1303">        }</span>

<span class="nc" id="L1305">    }</span>

    protected int count8RegionNeighbors(GreyscaleImage input, int x, int y) {

<span class="nc" id="L1309">        int width = input.getWidth();</span>
<span class="nc" id="L1310">        int height = input.getHeight();</span>

<span class="nc" id="L1312">        int count = 0;</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L1314" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1315">                continue;</span>
            }
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L1318" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1319">                    continue;</span>
                }
<span class="nc bnc" id="L1321" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L1322">                    continue;</span>
                }
<span class="nc" id="L1324">                int v = input.getValue(c, r);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">                if (v &gt; 0) {</span>
<span class="nc" id="L1326">                    count++;</span>
                }
            }
        }

<span class="nc" id="L1331">        return count;</span>
    }

    protected int count8RegionNeighbors(Set&lt;PairInt&gt; points, PairInt point,
        int width, int height) {

<span class="nc" id="L1337">        int x = point.getX();</span>
<span class="nc" id="L1338">        int y = point.getY();</span>

<span class="nc" id="L1340">        int count = 0;</span>

<span class="nc bnc" id="L1342" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L1343" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1344">                continue;</span>
            }
<span class="nc bnc" id="L1346" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L1347" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1348">                    continue;</span>
                }
<span class="nc bnc" id="L1350" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L1351">                    continue;</span>
                }
<span class="nc" id="L1353">                PairInt tmp = new PairInt(c, r);</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">                if (points.contains(tmp)) {</span>
<span class="nc" id="L1355">                    count++;</span>
                }
            }
        }

<span class="nc" id="L1360">        return count;</span>
    }

    protected int getIndexIfOnlyOneNeighbor(GreyscaleImage input, int x, int y) {

<span class="nc" id="L1365">        int width = input.getWidth();</span>
<span class="nc" id="L1366">        int height = input.getHeight();</span>

<span class="nc" id="L1368">        int count = 0;</span>
<span class="nc" id="L1369">        int xNeighbor = -1;</span>
<span class="nc" id="L1370">        int yNeighbor = -1;</span>

<span class="nc bnc" id="L1372" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L1373" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1374">                continue;</span>
            }
<span class="nc bnc" id="L1376" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L1377" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1378">                    continue;</span>
                }
<span class="nc bnc" id="L1380" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L1381">                    continue;</span>
                }
<span class="nc" id="L1383">                int v = input.getValue(c, r);</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                if (v &gt; 0) {</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                    if (count &gt; 0) {</span>
<span class="nc" id="L1386">                        return -1;</span>
                    }
<span class="nc" id="L1388">                    xNeighbor = c;</span>
<span class="nc" id="L1389">                    yNeighbor = r;</span>
<span class="nc" id="L1390">                    count++;</span>
                }
            }
        }

<span class="nc bnc" id="L1395" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1396">            return -1;</span>
        }

<span class="nc" id="L1399">        int index = input.getIndex(xNeighbor, yNeighbor);</span>

<span class="nc" id="L1401">        return index;</span>
    }

    protected PairInt getIndexIfOnlyOneNeighbor(Set&lt;PairInt&gt; points,
        PairInt point, int width, int height) {

<span class="nc" id="L1407">        int x = point.getX();</span>
<span class="nc" id="L1408">        int y = point.getY();</span>

<span class="nc" id="L1410">        int count = 0;</span>
<span class="nc" id="L1411">        PairInt neighbor = null;</span>

<span class="nc bnc" id="L1413" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L1414" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L1415">                continue;</span>
            }
<span class="nc bnc" id="L1417" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L1418" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L1419">                    continue;</span>
                }
<span class="nc bnc" id="L1421" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L1422">                    continue;</span>
                }
<span class="nc" id="L1424">                PairInt tmp = new PairInt(c, r);</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                if (points.contains(tmp)) {</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">                    if (count &gt; 0) {</span>
<span class="nc" id="L1427">                        return null;</span>
                    }
<span class="nc" id="L1429">                    neighbor = tmp;</span>
<span class="nc" id="L1430">                    count++;</span>
                }
            }
        }

<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1436">            return null;</span>
        }

<span class="nc" id="L1439">        return neighbor;</span>
    }

    /**
     * returns avg r, avg g, avg b
     * @param points
     * @param theta
     * @param originalImage
     * @param addAlongX
     * @param addAmount
     * @return
     */
    private int[] getAvgMinMaxColor(PairIntArray points, GreyscaleImage theta,
        Image originalImage, boolean addAlongX, int addAmount) {

<span class="nc" id="L1454">        int xOffset = theta.getXRelativeOffset();</span>
<span class="nc" id="L1455">        int yOffset = theta.getYRelativeOffset();</span>

<span class="nc" id="L1457">        double rSum = 0;</span>
<span class="nc" id="L1458">        double gSum = 0;</span>
<span class="nc" id="L1459">        double bSum = 0;</span>

<span class="nc" id="L1461">        int count = 0;</span>

<span class="nc bnc" id="L1463" title="All 2 branches missed.">        for (int pIdx = 0; pIdx &lt; points.getN(); pIdx++) {</span>

<span class="nc" id="L1465">            int x = points.getX(pIdx);</span>
<span class="nc" id="L1466">            int y = points.getY(pIdx);</span>

<span class="nc" id="L1468">            int ox = x + xOffset;</span>
<span class="nc" id="L1469">            int oy = y + yOffset;</span>

            //TODO: this may need corrections for other orientations
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            if (addAlongX) {</span>
<span class="nc" id="L1473">                ox += addAmount;</span>
            } else {
<span class="nc" id="L1475">                oy += addAmount;</span>
            }

<span class="nc bnc" id="L1478" title="All 4 branches missed.">            if ((ox &lt; 0) || (ox &gt; (originalImage.getWidth() - 1))) {</span>
<span class="nc" id="L1479">                continue;</span>
            }
<span class="nc bnc" id="L1481" title="All 4 branches missed.">            if ((oy &lt; 0) || (oy &gt; (originalImage.getHeight() - 1))) {</span>
<span class="nc" id="L1482">                continue;</span>
            }

<span class="nc" id="L1485">            int rgb = originalImage.getRGB(ox, oy);</span>
<span class="nc" id="L1486">            int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L1487">            int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L1488">            int b = rgb &amp; 0xFF;</span>

<span class="nc" id="L1490">            rSum += r;</span>
<span class="nc" id="L1491">            gSum += g;</span>
<span class="nc" id="L1492">            bSum += b;</span>

<span class="nc" id="L1494">            count++;</span>
        }

<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1498">            return new int[]{0, 0, 0};</span>
        }

<span class="nc" id="L1501">        rSum /= (double)count;</span>
<span class="nc" id="L1502">        gSum /= (double)count;</span>
<span class="nc" id="L1503">        bSum /= (double)count;</span>

<span class="nc" id="L1505">        return new int[]{(int)Math.round(rSum), (int)Math.round(gSum),</span>
<span class="nc" id="L1506">            (int)Math.round(bSum)};</span>
    }

    public void applyInvert255(GreyscaleImage img) {
        // assumption that pixels lie in range 0 to 255
        
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L1514">                int v = img.getValue(i, j);</span>
<span class="nc" id="L1515">                int vInv = 255 - v;</span>
<span class="nc" id="L1516">                img.setValue(i, j, vInv);</span>
            }
        }
<span class="nc" id="L1519">    }</span>
    
    public void applyInvert255(Image img) {
        // assumption that pixels lie in range 0 to 255
        
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L1526">                img.setRGB(i, j,</span>
<span class="nc" id="L1527">                    255 - img.getR(i, j),</span>
<span class="nc" id="L1528">                    255 - img.getG(i, j),</span>
<span class="nc" id="L1529">                    255 - img.getB(i, j));</span>
            }
        }
<span class="nc" id="L1532">    }</span>
    
    public GreyscaleImage binImageToKeepZeros(GreyscaleImage img,
        int binFactor) {

<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1538">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1541">        int w0 = img.getWidth();</span>
<span class="fc" id="L1542">        int h0 = img.getHeight();</span>

<span class="fc" id="L1544">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1545">        int h1 = h0/binFactor;</span>

<span class="fc" id="L1547">        GreyscaleImage out = new GreyscaleImage(w1, h1);</span>
<span class="fc" id="L1548">        out.setXRelativeOffset(Math.round(img.getXRelativeOffset()/binFactor));</span>
<span class="fc" id="L1549">        out.setYRelativeOffset(Math.round(img.getYRelativeOffset()/binFactor));</span>

<span class="fc bfc" id="L1551" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1553" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1555">                int vSum = 0;</span>
<span class="fc" id="L1556">                int count = 0;</span>
<span class="fc" id="L1557">                boolean isZero = false;</span>

                // if there's a zero in the binFactor x binFactor block,
                // v is set to 0

<span class="fc bfc" id="L1562" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1563" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1565" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1566">                            continue;</span>
                        }
<span class="pc bpc" id="L1568" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1569">                            continue;</span>
                        }

<span class="fc" id="L1572">                        int v = img.getValue(ii, jj);</span>

<span class="fc bfc" id="L1574" title="All 2 branches covered.">                        if (v == 0) {</span>
<span class="fc" id="L1575">                            isZero = true;</span>
<span class="fc" id="L1576">                            vSum = 0;</span>
<span class="fc" id="L1577">                            break;</span>
                        }

<span class="fc" id="L1580">                        vSum += v;</span>
<span class="fc" id="L1581">                        count++;</span>
                    }
<span class="fc bfc" id="L1583" title="All 2 branches covered.">                    if (isZero) {</span>
<span class="fc" id="L1584">                        break;</span>
                    }
                }

<span class="fc bfc" id="L1588" title="All 2 branches covered.">                if (vSum &gt; 0) {</span>
<span class="fc" id="L1589">                    float v = (float)vSum/(float)count;</span>
<span class="fc" id="L1590">                    vSum = Math.round(v);</span>
                }

<span class="fc" id="L1593">                out.setValue(i, j, vSum);</span>
            }
        }

<span class="fc" id="L1597">        return out;</span>
    }

    public GreyscaleImage binImage(GreyscaleImage img, int binFactor) {

<span class="nc bnc" id="L1602" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1603">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="nc" id="L1606">        int w0 = img.getWidth();</span>
<span class="nc" id="L1607">        int h0 = img.getHeight();</span>

<span class="nc" id="L1609">        int w1 = w0/binFactor;</span>
<span class="nc" id="L1610">        int h1 = h0/binFactor;</span>

<span class="nc" id="L1612">        GreyscaleImage out = new GreyscaleImage(w1, h1);</span>
<span class="nc" id="L1613">        out.setXRelativeOffset(Math.round(img.getXRelativeOffset()/binFactor));</span>
<span class="nc" id="L1614">        out.setYRelativeOffset(Math.round(img.getYRelativeOffset()/binFactor));</span>

<span class="nc bnc" id="L1616" title="All 2 branches missed.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="nc bnc" id="L1618" title="All 2 branches missed.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="nc" id="L1620">                int vSum = 0;</span>
<span class="nc" id="L1621">                int count = 0;</span>

<span class="nc bnc" id="L1623" title="All 2 branches missed.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="nc bnc" id="L1626" title="All 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1627">                            continue;</span>
                        }
<span class="nc bnc" id="L1629" title="All 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1630">                            continue;</span>
                        }

<span class="nc" id="L1633">                        int v = img.getValue(ii, jj);</span>

<span class="nc" id="L1635">                        vSum += v;</span>
<span class="nc" id="L1636">                        count++;</span>
                    }
                }

<span class="nc bnc" id="L1640" title="All 2 branches missed.">                if (count &gt; 0) {</span>
<span class="nc" id="L1641">                    float v = (float)vSum/(float)count;</span>
<span class="nc" id="L1642">                    vSum = Math.round(v);</span>
                }

<span class="nc" id="L1645">                out.setValue(i, j, vSum);</span>
            }
        }

<span class="nc" id="L1649">        return out;</span>
    }

    public Image binImage(Image img,  int binFactor) {

<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1655">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1658">        int w0 = img.getWidth();</span>
<span class="fc" id="L1659">        int h0 = img.getHeight();</span>

<span class="fc" id="L1661">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1662">        int h1 = h0/binFactor;</span>

<span class="fc" id="L1664">        Image out = new Image(w1, h1);</span>

<span class="fc" id="L1666">        binImage(img, binFactor, out);</span>

<span class="fc" id="L1668">        return out;</span>
    }

    public ImageExt binImage(ImageExt img,  int binFactor) {

<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L1674">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1677">        int w0 = img.getWidth();</span>
<span class="fc" id="L1678">        int h0 = img.getHeight();</span>

<span class="fc" id="L1680">        int w1 = w0/binFactor;</span>
<span class="fc" id="L1681">        int h1 = h0/binFactor;</span>

<span class="fc" id="L1683">        ImageExt out = new ImageExt(w1, h1);</span>

<span class="fc" id="L1685">        binImage(img, binFactor, out);</span>

<span class="fc" id="L1687">        return out;</span>
    }

    private void binImage(Image inputImg,  int binFactor, Image outputImg) {

<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">        if (inputImg == null) {</span>
<span class="nc" id="L1693">            throw new IllegalArgumentException(&quot;img cannot be null&quot;);</span>
        }

<span class="fc" id="L1696">        int w0 = inputImg.getWidth();</span>
<span class="fc" id="L1697">        int h0 = inputImg.getHeight();</span>

<span class="fc" id="L1699">        int w1 = outputImg.getWidth();</span>
<span class="fc" id="L1700">        int h1 = outputImg.getHeight();</span>

<span class="fc bfc" id="L1702" title="All 2 branches covered.">        for (int i = 0; i &lt; w1; i++) {</span>

<span class="fc bfc" id="L1704" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>

<span class="fc" id="L1706">                long rSum = 0;</span>
<span class="fc" id="L1707">                long gSum = 0;</span>
<span class="fc" id="L1708">                long bSum = 0;</span>

<span class="fc" id="L1710">                int count = 0;</span>

<span class="fc bfc" id="L1712" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>

<span class="pc bpc" id="L1715" title="2 of 4 branches missed.">                        if ((ii &lt; 0) || (ii &gt; (w0 - 1))) {</span>
<span class="nc" id="L1716">                            continue;</span>
                        }
<span class="pc bpc" id="L1718" title="2 of 4 branches missed.">                        if ((jj &lt; 0) || (jj &gt; (h0 - 1))) {</span>
<span class="nc" id="L1719">                            continue;</span>
                        }

<span class="fc" id="L1722">                        int rgb = inputImg.getRGB(ii, jj);</span>

<span class="fc" id="L1724">                        int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="fc" id="L1725">                        int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="fc" id="L1726">                        int b = rgb &amp; 0xFF;</span>

<span class="fc" id="L1728">                        rSum += r;</span>
<span class="fc" id="L1729">                        gSum += g;</span>
<span class="fc" id="L1730">                        bSum += b;</span>

<span class="fc" id="L1732">                        count++;</span>
                    }
                }

<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">                if (count &gt; 0) {</span>
<span class="fc" id="L1737">                    rSum = Math.round((float)rSum/(float)count);</span>
<span class="fc" id="L1738">                    gSum = Math.round((float)gSum/(float)count);</span>
<span class="fc" id="L1739">                    bSum = Math.round((float)bSum/(float)count);</span>
                }

<span class="fc" id="L1742">                outputImg.setRGB(i, j, (int)rSum, (int)gSum, (int)bSum);</span>
            }
        }
<span class="fc" id="L1745">    }</span>

    public GreyscaleImage unbinMask(GreyscaleImage mask, int binFactor,
        GreyscaleImage originalTheta) {

<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">        if (mask == null) {</span>
<span class="nc" id="L1751">            throw new IllegalArgumentException(&quot;mask cannot be null&quot;);</span>
        }

<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if (originalTheta == null) {</span>
<span class="nc" id="L1755">            throw new IllegalArgumentException(&quot;originalTheta cannot be null&quot;);</span>
        }

<span class="fc" id="L1758">        GreyscaleImage out = originalTheta.createWithDimensions();</span>

<span class="fc" id="L1760">        int w0 = mask.getWidth();</span>
<span class="fc" id="L1761">        int h0 = mask.getHeight();</span>

<span class="fc" id="L1763">        int w1 = out.getWidth();</span>
<span class="fc" id="L1764">        int h1 = out.getHeight();</span>

<span class="fc bfc" id="L1766" title="All 2 branches covered.">        for (int i = 0; i &lt; w0; i++) {</span>
<span class="fc bfc" id="L1767" title="All 2 branches covered.">            for (int j = 0; j &lt; h0; j++) {</span>

<span class="fc" id="L1769">                int v = mask.getValue(i, j);</span>

<span class="fc bfc" id="L1771" title="All 2 branches covered.">                for (int ii = (i*binFactor); ii &lt; ((i + 1)*binFactor); ii++) {</span>
<span class="fc bfc" id="L1772" title="All 2 branches covered.">                    for (int jj = (j*binFactor); jj &lt; ((j + 1)*binFactor); jj++) {</span>
<span class="fc" id="L1773">                        out.setValue(ii, jj, v);</span>
                    }
                }
            }
        }

<span class="fc bfc" id="L1779" title="All 2 branches covered.">        if ((originalTheta.getWidth() &amp; 1) == 1) {</span>
            // copy next to last column into last column
<span class="fc" id="L1781">            int i = originalTheta.getWidth() - 2;</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">            for (int j = 0; j &lt; h1; j++) {</span>
<span class="fc" id="L1783">                int v = out.getValue(i, j);</span>
<span class="fc" id="L1784">                out.setValue(i + 1, j, v);</span>
            }
        }
<span class="fc bfc" id="L1787" title="All 2 branches covered.">        if ((originalTheta.getHeight() &amp; 1) == 1) {</span>
            // copy next to last row into last row
<span class="fc" id="L1789">            int j = originalTheta.getHeight() - 2;</span>
<span class="fc bfc" id="L1790" title="All 2 branches covered.">            for (int i = 0; i &lt; w1; i++) {</span>
<span class="fc" id="L1791">                int v = out.getValue(i, j);</span>
<span class="fc" id="L1792">                out.setValue(i, j + 1, v);</span>
            }
        }

        // TODO: consider correction for oversampling at location of skyline
        // using originalTheta

<span class="fc" id="L1799">        return out;</span>
    }

    public List&lt;PairIntArray&gt; unbinZeroPointLists(List&lt;PairIntArray&gt; zeroPointLists,
        int binFactor) {

<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (zeroPointLists == null) {</span>
<span class="nc" id="L1806">            throw new IllegalArgumentException(&quot;mask cannot be null&quot;);</span>
        }

<span class="nc" id="L1809">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>

<span class="nc bnc" id="L1811" title="All 2 branches missed.">        for (PairIntArray zeroPointList : zeroPointLists) {</span>

<span class="nc" id="L1813">            PairIntArray transformed = new PairIntArray(zeroPointList.getN() *</span>
                binFactor);

<span class="nc bnc" id="L1816" title="All 2 branches missed.">            for (int i = 0; i &lt; zeroPointList.getN(); i++) {</span>

<span class="nc" id="L1818">                int x = zeroPointList.getX(i);</span>
<span class="nc" id="L1819">                int y = zeroPointList.getY(i);</span>

<span class="nc bnc" id="L1821" title="All 2 branches missed.">                for (int ii = (x*binFactor); ii &lt; ((x + 1)*binFactor); ii++) {</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">                    for (int jj = (y*binFactor); jj &lt; ((y + 1)*binFactor); jj++) {</span>

<span class="nc" id="L1824">                        transformed.add(ii, jj);</span>
                    }
                }
            }

<span class="nc" id="L1829">            output.add(transformed);</span>

<span class="nc" id="L1831">        }</span>

<span class="nc" id="L1833">        return output;</span>
    }

    public Set&lt;PairInt&gt; unbinZeroPointLists(Set&lt;PairInt&gt; zeroPoints,
        int binFactor) {

<span class="nc bnc" id="L1839" title="All 2 branches missed.">        if (zeroPoints == null) {</span>
<span class="nc" id="L1840">            throw new IllegalArgumentException(&quot;zeroPoints cannot be null&quot;);</span>
        }

<span class="nc" id="L1843">        Set&lt;PairInt&gt; output = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1845" title="All 2 branches missed.">        for (PairInt zeroPoint : zeroPoints) {</span>

<span class="nc" id="L1847">            int x = zeroPoint.getX();</span>
<span class="nc" id="L1848">            int y = zeroPoint.getY();</span>

<span class="nc bnc" id="L1850" title="All 2 branches missed.">            for (int ii = (x*binFactor); ii &lt; ((x + 1)*binFactor); ii++) {</span>
<span class="nc bnc" id="L1851" title="All 2 branches missed.">                for (int jj = (y*binFactor); jj &lt; ((y + 1)*binFactor); jj++) {</span>

<span class="nc" id="L1853">                    PairInt p = new PairInt(ii, jj);</span>

<span class="nc" id="L1855">                    output.add(p);</span>
                }
            }
<span class="nc" id="L1858">        }</span>

<span class="nc" id="L1860">        return output;</span>
    }

    public void printImageColorContrastStats(Image image, int rgbSkyAvg,
        int plotNumber) throws IOException {

        /*
        http://dilnxsrv.king.ac.uk/papers/wses2001.pdf
           Y   | 16  |   | 0.256  0.504  0.098 | |R|
           U = | 128 | + |-0.148 -0.291  0.439 | |G|
           V   | 128 |   | 0.439 -0.368 -0.072 | |B|
        */
<span class="nc" id="L1872">        double[][] m = new double[3][];</span>
<span class="nc" id="L1873">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="nc" id="L1874">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="nc" id="L1875">        m[2] = new double[]{0.439, -0.368, -0.072};</span>

<span class="nc" id="L1877">        int rSky = (rgbSkyAvg &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L1878">        int gSky = (rgbSkyAvg &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L1879">        int bSky = rgbSkyAvg &amp; 0xFF;</span>
<span class="nc" id="L1880">        double[] yuvSky = MatrixUtil.multiply(m, new double[]{rSky, gSky, bSky});</span>

<span class="nc" id="L1882">        double t313 = Math.pow(3, (1./3.));</span>

<span class="nc" id="L1884">        int w = image.getWidth();</span>
<span class="nc" id="L1885">        int h = image.getHeight();</span>
<span class="nc" id="L1886">        int slice = 1;//10;</span>

<span class="nc" id="L1888">        PolygonAndPointPlotter plotter = new PolygonAndPointPlotter();</span>

<span class="nc bnc" id="L1890" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; i++) {</span>

<span class="nc" id="L1892">            int startCol = -1;</span>
<span class="nc" id="L1893">            int stopCol = -1;</span>
<span class="nc" id="L1894">            int startRow = -1;</span>
<span class="nc" id="L1895">            int stopRow = -1;</span>
<span class="nc" id="L1896">            boolean plotAlongRows = true;</span>
<span class="nc" id="L1897">            String labelSuffix = null;</span>

<span class="nc bnc" id="L1899" title="All 6 branches missed.">            switch(i) {</span>
                case 0:
                    //horizontal at low y
<span class="nc" id="L1902">                    startCol = 0;</span>
<span class="nc" id="L1903">                    stopCol = w - 1;</span>
<span class="nc" id="L1904">                    startRow = slice;</span>
<span class="nc" id="L1905">                    stopRow = startRow + slice;</span>
<span class="nc" id="L1906">                    plotAlongRows = false;</span>
<span class="nc" id="L1907">                    labelSuffix = &quot;horizontal stripe at low y&quot;;</span>
<span class="nc" id="L1908">                    break;</span>
                case 1:
                    //horizontal at mid y
<span class="nc" id="L1911">                    startCol = 0;</span>
<span class="nc" id="L1912">                    stopCol = w - 1;</span>
<span class="nc" id="L1913">                    startRow = (h - slice)/2 ;</span>
<span class="nc" id="L1914">                    stopRow = startRow + slice;</span>
<span class="nc" id="L1915">                    plotAlongRows = false;</span>
<span class="nc" id="L1916">                    labelSuffix = &quot;horizontal stripe at mid y&quot;;</span>
<span class="nc" id="L1917">                    break;</span>
                case 2:
                    //horizontal at high y
<span class="nc" id="L1920">                    startCol = 0;</span>
<span class="nc" id="L1921">                    stopCol = w - 1;</span>
<span class="nc" id="L1922">                    startRow = (h - 2*slice) - 1;</span>
<span class="nc" id="L1923">                    stopRow = startRow + slice;</span>
<span class="nc" id="L1924">                    plotAlongRows = false;</span>
<span class="nc" id="L1925">                    labelSuffix = &quot;horizontal stripe at high y&quot;;</span>
<span class="nc" id="L1926">                    break;</span>
                case 3:
                    //vertical at low x
<span class="nc" id="L1929">                    startCol = slice;</span>
<span class="nc" id="L1930">                    stopCol = startCol + slice;</span>
<span class="nc" id="L1931">                    startRow = 0;</span>
<span class="nc" id="L1932">                    stopRow = h - 1;</span>
<span class="nc" id="L1933">                    plotAlongRows = true;</span>
<span class="nc" id="L1934">                    labelSuffix = &quot;vertical stripe at low x&quot;;</span>
<span class="nc" id="L1935">                    break;</span>
                case 4:
                    //vertical at mid x
<span class="nc" id="L1938">                    startCol = (w - slice)/2;</span>
<span class="nc" id="L1939">                    stopCol = startCol + slice;</span>
<span class="nc" id="L1940">                    startRow = 0;</span>
<span class="nc" id="L1941">                    stopRow = h - 1;</span>
<span class="nc" id="L1942">                    plotAlongRows = true;</span>
<span class="nc" id="L1943">                    labelSuffix = &quot;vertical stripe at mid x&quot;;</span>
<span class="nc" id="L1944">                    break;</span>
                default:
                    //vertical at high x
<span class="nc" id="L1947">                    startCol = (w - 2*slice) - 1;</span>
<span class="nc" id="L1948">                    stopCol = startCol + slice;</span>
<span class="nc" id="L1949">                    startRow = 0;</span>
<span class="nc" id="L1950">                    stopRow = h - 1;</span>
<span class="nc" id="L1951">                    plotAlongRows = true;</span>
<span class="nc" id="L1952">                    labelSuffix = &quot;vertical stripe at high x&quot;;</span>
                    break;
            }

            // contrast as y
            // hue
            // blue
            // red
<span class="nc" id="L1960">            float[] contrast = null;</span>
<span class="nc" id="L1961">            float[] hue = null;</span>
<span class="nc" id="L1962">            float[] red = null;</span>
<span class="nc" id="L1963">            float[] blue = null;</span>
<span class="nc" id="L1964">            float[] white = null;</span>
<span class="nc" id="L1965">            float[] axis = null;</span>

<span class="nc bnc" id="L1967" title="All 2 branches missed.">            if (!plotAlongRows) {</span>

                // plot along columns

<span class="nc" id="L1971">                contrast = new float[w];</span>
<span class="nc" id="L1972">                hue = new float[w];</span>
<span class="nc" id="L1973">                red = new float[w];</span>
<span class="nc" id="L1974">                blue = new float[w];</span>
<span class="nc" id="L1975">                white = new float[w];</span>
<span class="nc" id="L1976">                axis = new float[w];</span>

<span class="nc bnc" id="L1978" title="All 2 branches missed.">                for (int col = startCol; col &lt;= stopCol; col++) {</span>

<span class="nc" id="L1980">                    int row = startRow;</span>

<span class="nc" id="L1982">                    int r = image.getR(col, row);</span>
<span class="nc" id="L1983">                    int g = image.getG(col, row);</span>
<span class="nc" id="L1984">                    int b = image.getB(col, row);</span>
<span class="nc" id="L1985">                    double[] rgb = new double[]{r, g, b};</span>

<span class="nc" id="L1987">                    double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="nc" id="L1988">                    yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>
<span class="nc" id="L1989">                    double hueValue = Math.atan2(t313 * (g - b), ((2 * r) - g - b));</span>

<span class="nc" id="L1991">                    double contrastValue = (yuvSky[0] - yuv[0])/yuv[0];</span>

<span class="nc" id="L1993">                    double whiteValue = (r + g + b)/3.;</span>

<span class="nc" id="L1995">                    contrast[col] = (float)contrastValue;</span>
<span class="nc" id="L1996">                    hue[col] = (float)hueValue;</span>
<span class="nc" id="L1997">                    blue[col] = (float)b;</span>
<span class="nc" id="L1998">                    red[col] = (float)r;</span>
<span class="nc" id="L1999">                    white[col] = (float)whiteValue;</span>

<span class="nc" id="L2001">                    axis[col] = col;</span>
                }

            } else {
                // plot along rows
<span class="nc" id="L2006">                contrast = new float[h];</span>
<span class="nc" id="L2007">                hue = new float[h];</span>
<span class="nc" id="L2008">                red = new float[h];</span>
<span class="nc" id="L2009">                blue = new float[h];</span>
<span class="nc" id="L2010">                white = new float[h];</span>
<span class="nc" id="L2011">                axis = new float[h];</span>

<span class="nc bnc" id="L2013" title="All 2 branches missed.">                for (int row = startRow; row &lt;= stopRow; row++) {</span>

<span class="nc" id="L2015">                    int col = startCol;</span>

<span class="nc" id="L2017">                    int r = image.getR(col, row);</span>
<span class="nc" id="L2018">                    int g = image.getG(col, row);</span>
<span class="nc" id="L2019">                    int b = image.getB(col, row);</span>
<span class="nc" id="L2020">                    double[] rgb = new double[]{r, g, b};</span>

<span class="nc" id="L2022">                    double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="nc" id="L2023">                    yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>
<span class="nc" id="L2024">                    double hueValue = Math.atan2(t313 * (g - b), ((2 * r) - g - b));</span>

<span class="nc" id="L2026">                    double contrastValue = (yuvSky[0] - yuv[0])/yuv[0];</span>

<span class="nc" id="L2028">                    double whiteValue = (r + g + b)/3.;</span>

<span class="nc" id="L2030">                    contrast[row] = (float)contrastValue;</span>
<span class="nc" id="L2031">                    hue[row] = (float)hueValue;</span>
<span class="nc" id="L2032">                    blue[row] = (float)b;</span>
<span class="nc" id="L2033">                    red[row] = (float)r;</span>
<span class="nc" id="L2034">                    white[row] = (float)whiteValue;</span>

<span class="nc" id="L2036">                    axis[row] = row;</span>
                }

            }

<span class="nc" id="L2041">            float xmn = MiscMath.findMin(axis);</span>
<span class="nc" id="L2042">            float xmx = MiscMath.findMax(axis);</span>

<span class="nc" id="L2044">            float ymn = MiscMath.findMin(contrast);</span>
<span class="nc" id="L2045">            float ymx = 1.1f * MiscMath.findMax(contrast);</span>
<span class="nc" id="L2046">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, contrast, null, null, null, null,
                &quot;contrast &quot; + labelSuffix);

<span class="nc" id="L2050">            ymn = MiscMath.findMin(hue);</span>
<span class="nc" id="L2051">            ymx = 1.1f * MiscMath.findMax(hue);</span>
<span class="nc" id="L2052">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, hue, null, null, null, null, &quot;hue &quot; + labelSuffix);

<span class="nc" id="L2055">            ymn = MiscMath.findMin(blue);</span>
<span class="nc" id="L2056">            ymx = 1.1f * MiscMath.findMax(blue);</span>
<span class="nc" id="L2057">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, blue, null, null, null, null, &quot;blue &quot; + labelSuffix);

<span class="nc" id="L2060">            ymn = MiscMath.findMin(red);</span>
<span class="nc" id="L2061">            ymx = 1.1f * MiscMath.findMax(red);</span>
<span class="nc" id="L2062">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, red, null, null, null, null, &quot;red &quot; + labelSuffix);

<span class="nc" id="L2065">            ymn = MiscMath.findMin(white);</span>
<span class="nc" id="L2066">            ymx = 1.1f * MiscMath.findMax(white);</span>
<span class="nc" id="L2067">            plotter.addPlot(xmn, xmx, ymn, ymx,</span>
                axis, white, null, null, null, null, &quot;white &quot; + labelSuffix);

<span class="nc" id="L2070">            plotter.writeFile(plotNumber);</span>
        }
<span class="nc" id="L2072">    }</span>

    public double[] calculateYRGB(PairIntArray points, Image originalColorImage,
        int xOffset, int yOffset, boolean addAlongX, int addAmount) {

<span class="nc" id="L2077">        double[][] m = new double[3][];</span>
<span class="nc" id="L2078">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="nc" id="L2079">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="nc" id="L2080">        m[2] = new double[]{0.439, -0.368, -0.072};</span>

<span class="nc" id="L2082">        double avgY = 0;</span>
<span class="nc" id="L2083">        double avgR = 0;</span>
<span class="nc" id="L2084">        double avgG = 0;</span>
<span class="nc" id="L2085">        double avgB = 0;</span>

<span class="nc bnc" id="L2087" title="All 2 branches missed.">        for (int i = 0; i &lt; points.getN(); i++) {</span>

<span class="nc" id="L2089">            int x = points.getX(i);</span>
<span class="nc" id="L2090">            int y = points.getY(i);</span>

<span class="nc" id="L2092">            int ox = x + xOffset;</span>
<span class="nc" id="L2093">            int oy = y + yOffset;</span>

<span class="nc bnc" id="L2095" title="All 2 branches missed.">            if (addAlongX) {</span>
<span class="nc" id="L2096">                ox += addAmount;</span>
            } else {
<span class="nc" id="L2098">                oy += addAmount;</span>
            }
<span class="nc bnc" id="L2100" title="All 4 branches missed.">            if ((ox &lt; 0) || (ox &gt; (originalColorImage.getWidth() - 1))) {</span>
<span class="nc" id="L2101">                continue;</span>
            }
<span class="nc bnc" id="L2103" title="All 4 branches missed.">            if ((oy &lt; 0) || (oy &gt; (originalColorImage.getHeight() - 1))) {</span>
<span class="nc" id="L2104">                continue;</span>
            }

<span class="nc" id="L2107">            int r = originalColorImage.getR(x, y);</span>
<span class="nc" id="L2108">            int g = originalColorImage.getG(x, y);</span>
<span class="nc" id="L2109">            int b = originalColorImage.getB(x, y);</span>
<span class="nc" id="L2110">            double[] rgb = new double[]{r, g, b};</span>
<span class="nc" id="L2111">            double[] yuv = MatrixUtil.multiply(m, rgb);</span>

<span class="nc" id="L2113">            avgY += yuv[0];</span>

<span class="nc" id="L2115">            avgR += r;</span>
<span class="nc" id="L2116">            avgG += g;</span>
<span class="nc" id="L2117">            avgB += b;</span>
        }

<span class="nc" id="L2120">        avgY /= (double)points.getN();</span>
<span class="nc" id="L2121">        avgR /= (double)points.getN();</span>
<span class="nc" id="L2122">        avgG /= (double)points.getN();</span>
<span class="nc" id="L2123">        avgB /= (double)points.getN();</span>

<span class="nc" id="L2125">        return new double[]{avgY, avgR, avgG, avgB};</span>
    }
    
    public GreyscaleImage padUpToPowerOfTwo(GreyscaleImage input) {
        
<span class="nc" id="L2130">        int w0 = input.getWidth();</span>
<span class="nc" id="L2131">        int h0 = input.getHeight();</span>
        
<span class="nc" id="L2133">        int w = 1 &lt;&lt; (int)(Math.ceil(Math.log(w0)/Math.log(2)));</span>
<span class="nc" id="L2134">        int h = 1 &lt;&lt; (int)(Math.ceil(Math.log(h0)/Math.log(2)));</span>

<span class="nc" id="L2136">        int xOffset = w - w0;</span>
<span class="nc" id="L2137">        int yOffset = h - h0;</span>
        
<span class="nc bnc" id="L2139" title="All 4 branches missed.">        if (xOffset == 0 &amp;&amp; yOffset == 0) {</span>
<span class="nc" id="L2140">            return input;</span>
        }
        
<span class="nc" id="L2143">        int xOffsetOrig = input.getXRelativeOffset();</span>
<span class="nc" id="L2144">        int yOffsetOrig = input.getYRelativeOffset();</span>
        
<span class="nc" id="L2146">        GreyscaleImage output = new GreyscaleImage(w, h);</span>
<span class="nc" id="L2147">        output.setXRelativeOffset(xOffset + xOffsetOrig);</span>
<span class="nc" id="L2148">        output.setYRelativeOffset(yOffset + yOffsetOrig);</span>
      
<span class="nc bnc" id="L2150" title="All 2 branches missed.">        for (int i = 0; i &lt; w0; ++i) {</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">            for (int j = 0; j &lt; h0; ++j) {</span>
<span class="nc" id="L2152">                int v = input.getValue(i, j);</span>
<span class="nc" id="L2153">                output.setValue(i + xOffset, j + yOffset, v);</span>
            }
        }
        
<span class="nc" id="L2157">        return output;</span>
    }

    /**
     *
     * @param input
     * @param forward if true, apply FFT transform, else inverse FFT transform
     */
    public void apply2DFFT(GreyscaleImage input, boolean forward) {

<span class="nc" id="L2167">        int xOffsetOrig = input.getXRelativeOffset();</span>
<span class="nc" id="L2168">        int yOffsetOrig = input.getYRelativeOffset();</span>
            
        //TODO remove the other power of 2 padding method
<span class="nc" id="L2171">        GreyscaleImage tmp = padUpToPowerOfTwo(input);</span>

        // initialize matrix of complex numbers as real numbers from image
<span class="nc" id="L2174">        Complex[][] cc = convertImage(tmp);</span>

<span class="nc" id="L2176">        Complex[][] ccOut = apply2DFFT(cc, forward);</span>

<span class="nc" id="L2178">        writeToImage(tmp, ccOut);</span>
        
<span class="nc bnc" id="L2180" title="All 2 branches missed.">        if (tmp.getNPixels() &gt; input.getNPixels()) {</span>
                        
<span class="nc" id="L2182">            int xOffset = tmp.getXRelativeOffset();</span>
<span class="nc" id="L2183">            int yOffset = tmp.getYRelativeOffset();</span>
            
            // padding is at front of cols and rows
<span class="nc" id="L2186">            int x = 0;</span>
<span class="nc bnc" id="L2187" title="All 2 branches missed.">            for (int col = xOffset; col &lt; tmp.getWidth(); col++) {</span>
<span class="nc" id="L2188">                int y = 0;</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                for (int row = yOffset; row &lt; tmp.getHeight(); row++) {</span>
<span class="nc" id="L2190">                    int v = tmp.getValue(col, row);</span>
<span class="nc" id="L2191">                    input.setValue(x, y, v);</span>
<span class="nc" id="L2192">                    y++;</span>
                }
<span class="nc" id="L2194">                x++;</span>
             }
<span class="nc" id="L2196">            input.setXRelativeOffset(xOffsetOrig);</span>
<span class="nc" id="L2197">            input.setYRelativeOffset(yOffsetOrig);</span>
        }
<span class="nc" id="L2199">    }</span>

    protected Complex[][] apply2DFFT(Complex[][] cc, boolean forward) {

        // perform FFT by column
<span class="nc bnc" id="L2204" title="All 2 branches missed.">        for (int col = 0; col &lt; cc.length; col++) {</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">            if (forward) {</span>
<span class="nc" id="L2206">                cc[col] = FFT.fft(cc[col]);</span>
            } else {
<span class="nc" id="L2208">                cc[col] = FFT.ifft(cc[col]);</span>
            }
        }


        //transpose the matrix
<span class="nc" id="L2214">        cc = MatrixUtil.transpose(cc);</span>

        // perform FFT by column (originally rows)
<span class="nc bnc" id="L2217" title="All 2 branches missed.">        for (int col = 0; col &lt; cc.length; col++) {</span>
<span class="nc bnc" id="L2218" title="All 2 branches missed.">            if (forward) {</span>
<span class="nc" id="L2219">                cc[col] = FFT.fft(cc[col]);</span>
            } else {
<span class="nc" id="L2221">                cc[col] = FFT.ifft(cc[col]);</span>
            }
        }

        //transpose the matrix
<span class="nc" id="L2226">        cc = MatrixUtil.transpose(cc);</span>


<span class="nc" id="L2229">        return cc;</span>
    }

    /**
     *
     * @param cc
     */
    public void writeToImage(GreyscaleImage img, Complex[][] cc) {

<span class="nc" id="L2238">        img.fill(0);</span>

        // write back to original image
<span class="nc bnc" id="L2241" title="All 2 branches missed.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="nc" id="L2243">                double re = cc[col][row].re();</span>
<span class="nc" id="L2244">                double a = cc[col][row].abs();</span>
<span class="nc" id="L2245">                double p = cc[col][row].phase();</span>
<span class="nc" id="L2246">                img.setValue(col, row, (int)re);</span>
            }
        }

<span class="nc" id="L2250">    }</span>

    public void writePositiveRealToImage(GreyscaleImage img, Complex[][] cc) {

<span class="nc" id="L2254">        img.fill(0);</span>

        // write back to original image
<span class="nc bnc" id="L2257" title="All 2 branches missed.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="nc" id="L2259">                double re = cc[col][row].re();</span>
<span class="nc" id="L2260">                double a = cc[col][row].abs();</span>
<span class="nc" id="L2261">                double p = cc[col][row].phase();</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">                if (re &gt; 0) {</span>
<span class="nc" id="L2263">                    img.setValue(col, row, (int)re);</span>
                }
            }
        }

<span class="nc" id="L2268">    }</span>

    /**
     * write a 2-D complex array from the image
     *
     * @param input
     */
    protected Complex[][] convertImage(GreyscaleImage input) {

        // initialize matrix of complex numbers as real numbers from image
<span class="nc" id="L2278">        Complex[][] cc = new Complex[input.getWidth()][];</span>

<span class="nc bnc" id="L2280" title="All 2 branches missed.">        for (int col = 0; col &lt; input.getWidth(); col++) {</span>

<span class="nc" id="L2282">            cc[col] = new Complex[input.getHeight()];</span>

<span class="nc bnc" id="L2284" title="All 2 branches missed.">            for (int row = 0; row &lt; input.getHeight(); row++) {</span>
<span class="nc" id="L2285">                cc[col][row] = new Complex(input.getValue(col, row), 0);</span>
            }
        }

<span class="nc" id="L2289">        return cc;</span>
    }

    /**
     * NOT READY FOR USE YET
     *
     * @param input
     */
    public void applyDeconvolution(GreyscaleImage input) throws IOException {

        //TODO NOT READY FOR USE YET...

<span class="nc" id="L2301">        applyWienerFilter(input);</span>

<span class="nc" id="L2303">    }</span>

    /**
     * NOT READY FOR USE YET
     *
     * @param input
     */
    public void applyWienerFilter(GreyscaleImage input) throws IOException {

        //TODO NOT READY FOR USE YET...

<span class="nc" id="L2314">        CannyEdgeFilter cef = new CannyEdgeFilter();</span>

        // note, this is not scaled for total sum = 1 yet
<span class="nc" id="L2317">        GreyscaleImage psf = cef.createGradientPSFForTesting();</span>
<span class="nc" id="L2318">        double sum = 0;</span>
<span class="nc bnc" id="L2319" title="All 2 branches missed.">        for (int col = 0; col &lt; psf.getWidth(); col++) {</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">            for (int row = 0; row &lt; psf.getHeight(); row++) {</span>
<span class="nc" id="L2321">                int v = psf.getValue(col, row);</span>
<span class="nc" id="L2322">                sum += v;</span>
            }
        }
<span class="nc" id="L2325">        psf = padToNearestPowerOf2Dimensions(psf);</span>
<span class="nc" id="L2326">        Complex[][] psfNorm = new Complex[psf.getWidth()][];</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">        for (int col = 0; col &lt; psf.getWidth(); col++) {</span>
<span class="nc" id="L2328">            psfNorm[col] = new Complex[psf.getHeight()];</span>
<span class="nc bnc" id="L2329" title="All 2 branches missed.">            for (int row = 0; row &lt; psf.getHeight(); row++) {</span>
<span class="nc" id="L2330">                int v = psf.getValue(col, row);</span>
<span class="nc" id="L2331">                double vn = v / sum;</span>
<span class="nc" id="L2332">                psfNorm[col][row] = new Complex(vn, 0);</span>
            }
        }
<span class="nc" id="L2335">        psfNorm = apply2DFFT(psfNorm, true);</span>

        // filter out low values?
<span class="nc bnc" id="L2338" title="All 2 branches missed.">        for (int i = 0; i &lt; psfNorm.length; i++) {</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">            for (int j = 0; j &lt; psfNorm[0].length; j++) {</span>
<span class="nc" id="L2340">                double r = psfNorm[i][j].re();</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">                if (r &lt; 0.1) {</span>
<span class="nc" id="L2342">                    psfNorm[i][j] = new Complex(0, 0);</span>
                }
            }
        }

<span class="nc" id="L2347">        GreyscaleImage img0 = padToNearestPowerOf2Dimensions(input);</span>

<span class="nc" id="L2349">        ImageDisplayer.displayImage(&quot;before deconv&quot;, img0);</span>

<span class="nc" id="L2351">        Complex[][] imgCC = convertImage(img0);</span>

<span class="nc" id="L2353">        Complex[][] imgFFT = apply2DFFT(imgCC, true);</span>

        /*
        complex division:
           a times reciprocal of b

        reciprocal:
            double scale = re*re + im*im;
            r = Complex(re / scale, -im / scale);

        times:
            real = a.re * b.re - a.im * b.im;
            imag = a.re * b.im + a.im * b.re;
        */

<span class="nc" id="L2368">        Complex[][] ccDeconv = new Complex[imgFFT.length][];</span>
<span class="nc" id="L2369">        int pXH =  psfNorm.length &gt;&gt; 1;</span>
<span class="nc" id="L2370">        int pYH =  psfNorm[0].length &gt;&gt; 1;</span>
<span class="nc bnc" id="L2371" title="All 2 branches missed.">        for (int col = 0; col &lt; imgFFT.length; col++) {</span>

<span class="nc" id="L2373">            ccDeconv[col] = new Complex[imgFFT[0].length];</span>

<span class="nc bnc" id="L2375" title="All 2 branches missed.">            for (int row = 0; row &lt; imgFFT[0].length; row++) {</span>

<span class="nc" id="L2377">                Complex v = imgFFT[col][row];</span>

                // for convolution, each element of kernel and neighboring
                // pixel (including center pixel) were multiplied and result
                // is given to center pixel.

                // for deconvolution, the sums of the division are calculated

<span class="nc" id="L2385">                Complex pixSum = new Complex(v.re(), v.im());</span>

<span class="nc bnc" id="L2387" title="All 2 branches missed.">                for (int pXIdx = 0; pXIdx &lt; psfNorm.length; pXIdx++) {</span>
<span class="nc" id="L2388">                    int pixXIdx = col + (pXIdx - pXH);</span>

                    // correct for out of bounds of image
<span class="nc bnc" id="L2391" title="All 2 branches missed.">                    if (pixXIdx &lt; 0) {</span>
                        // replicate
<span class="nc" id="L2393">                        pixXIdx = -1*pixXIdx - 1;</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">                        if (pixXIdx &gt; (img0.getWidth() - 1)) {</span>
<span class="nc" id="L2395">                            pixXIdx = img0.getWidth() - 1;</span>
                        }
<span class="nc bnc" id="L2397" title="All 2 branches missed.">                    } else if (pixXIdx &gt;= img0.getWidth()) {</span>
<span class="nc" id="L2398">                        int diff = pixXIdx - img0.getWidth();</span>
<span class="nc" id="L2399">                        pixXIdx = img0.getWidth() - diff - 1;</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">                        if (pixXIdx &lt; 0) {</span>
<span class="nc" id="L2401">                            pixXIdx = 0;</span>
                        }
                    }

<span class="nc bnc" id="L2405" title="All 2 branches missed.">                    for (int pYIdx = 0; pYIdx &lt; psfNorm.length; pYIdx++) {</span>

<span class="nc bnc" id="L2407" title="All 2 branches missed.">                        if (psfNorm[pXIdx][pYIdx].abs() == 0) {</span>
<span class="nc" id="L2408">                            continue;</span>
                        }

<span class="nc" id="L2411">                        int pixYIdx = row + (pYIdx - pYH);</span>

                        // correct for out of bounds of image
<span class="nc bnc" id="L2414" title="All 2 branches missed.">                        if (pixYIdx &lt; 0) {</span>
                            // replicate
<span class="nc" id="L2416">                            pixYIdx = -1*pixYIdx - 1;</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">                            if (pixYIdx &gt; (img0.getHeight() - 1)) {</span>
<span class="nc" id="L2418">                                pixYIdx = img0.getHeight() - 1;</span>
                            }
<span class="nc bnc" id="L2420" title="All 2 branches missed.">                        } else if (pixYIdx &gt;= img0.getHeight()) {</span>
<span class="nc" id="L2421">                            int diff = pixYIdx - img0.getHeight();</span>
<span class="nc" id="L2422">                            pixYIdx = img0.getHeight() - diff - 1;</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">                            if (pixYIdx &lt; 0) {</span>
<span class="nc" id="L2424">                                pixYIdx = 0;</span>
                            }
                        }

<span class="nc" id="L2428">                        Complex vk = imgFFT[pixXIdx][pixYIdx];</span>

<span class="nc bnc" id="L2430" title="All 2 branches missed.">                        if (vk.abs() == 0) {</span>
<span class="nc" id="L2431">                            continue;</span>
                        }

<span class="nc" id="L2434">                        Complex kRecip = psfNorm[pXIdx][pYIdx].reciprocal();</span>

<span class="nc" id="L2436">                        Complex vDivPSF = vk.times(kRecip);</span>

<span class="nc" id="L2438">                        pixSum = pixSum.plus(vDivPSF);</span>
                    }
                }


<span class="nc" id="L2443">                ccDeconv[col][row] = pixSum;</span>
            }
        }

<span class="nc" id="L2447">        GreyscaleImage img2 = img0.createWithDimensions();</span>

<span class="nc" id="L2449">        writePositiveRealToImage(img2, ccDeconv);</span>

<span class="nc" id="L2451">        ImageDisplayer.displayImage(&quot;FFT(img0)/FFT(PSF)&quot;, img2);</span>


<span class="nc" id="L2454">        Complex[][] inverse = apply2DFFT(ccDeconv, false);</span>

<span class="nc" id="L2456">        GreyscaleImage img4 = img0.createWithDimensions();</span>

<span class="nc" id="L2458">        writePositiveRealToImage(img4, inverse);</span>

<span class="nc" id="L2460">        ImageDisplayer.displayImage(&quot;ifft of FFT(img0)/FFT(PSF)&quot;, img4);</span>


<span class="nc bnc" id="L2463" title="All 2 branches missed.">        for (int i = 0; i &lt; input.getWidth(); i++) {</span>
<span class="nc bnc" id="L2464" title="All 2 branches missed.">            for (int j = 0; j &lt; input.getHeight(); j++) {</span>
<span class="nc" id="L2465">                double f = inverse[i][j].re();</span>
<span class="nc" id="L2466">                int v = input.getValue(i, j);</span>
<span class="nc bnc" id="L2467" title="All 4 branches missed.">                if (v &gt; 0 &amp;&amp; f &gt; 0) {</span>
                    // apply it to the original image?  f*v or v or f?
<span class="nc" id="L2469">                    input.setValue(i, j, v);</span>
                } else {
<span class="nc" id="L2471">                    input.setValue(i, j, 0);</span>
                }
            }
        }
<span class="nc" id="L2475">    }</span>

    public GreyscaleImage padToNearestPowerOf2Dimensions(GreyscaleImage img) {

<span class="nc" id="L2479">        int w = img.getWidth();</span>
<span class="nc" id="L2480">        int h = img.getHeight();</span>

<span class="nc" id="L2482">        boolean xIsPowerOf2 = MiscMath.isAPowerOf2(w);</span>
<span class="nc" id="L2483">        boolean yIsPowerOf2 = MiscMath.isAPowerOf2(h);</span>
<span class="nc bnc" id="L2484" title="All 4 branches missed.">        if (xIsPowerOf2 &amp;&amp; yIsPowerOf2) {</span>
<span class="nc" id="L2485">            return img;</span>
        }

<span class="nc" id="L2488">        int w2 = w;</span>
<span class="nc" id="L2489">        int h2 = h;</span>
<span class="nc bnc" id="L2490" title="All 2 branches missed.">        if (!xIsPowerOf2) {</span>
<span class="nc" id="L2491">            double p2X = Math.ceil(Math.log(w)/Math.log(2));</span>
<span class="nc" id="L2492">            w2 = (1 &lt;&lt; (int)p2X);</span>
        }
<span class="nc bnc" id="L2494" title="All 2 branches missed.">        if (!yIsPowerOf2) {</span>
<span class="nc" id="L2495">            double p2Y = Math.ceil(Math.log(h)/Math.log(2));</span>
<span class="nc" id="L2496">            h2 = (1 &lt;&lt; (int)p2Y);</span>
        }

<span class="nc" id="L2499">        GreyscaleImage img2 = new GreyscaleImage(w2, h2);</span>

<span class="nc bnc" id="L2501" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>
<span class="nc" id="L2503">                int v = img.getValue(col, row);</span>
<span class="nc" id="L2504">                img2.setValue(col, row, v);</span>
            }
<span class="nc bnc" id="L2506" title="All 2 branches missed.">            if (h2 &gt; h) {</span>
<span class="nc bnc" id="L2507" title="All 2 branches missed.">                for (int row = h; row &lt; h2; row++) {</span>
<span class="nc" id="L2508">                    img2.setValue(col, row, 0);</span>
                }
            }
        }

<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (!xIsPowerOf2) {</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">            for (int col = w; col &lt; w2; col++) {</span>
<span class="nc bnc" id="L2515" title="All 2 branches missed.">                for (int row = 0; row &lt; h2; row++) {</span>
<span class="nc" id="L2516">                    img2.setValue(col, row, 0);</span>
                }
            }
        }

<span class="nc" id="L2521">        return img2;</span>
    }
    
    /**
     * create an image segmented by color...useful for experimenting with corners
     * due to color differences rather than original intensity differences.
     * The default provided here uses 8 color segmentation.
     * @param input
     * @return
     */
    public GreyscaleImage createGreyscaleFromColorSegmentation(ImageExt input) {

<span class="nc" id="L2533">        int kColors = 8;</span>

<span class="nc" id="L2535">        return createGreyscaleFromColorSegmentation(input, kColors);</span>
    }
    
    /**
     * create an image segmented by color...useful for experimenting with corners
     * due to color differences rather than original intensity differences.
     * The default provided here uses 8 color segmentation.
     * @param input
     * @return
     */
    public GreyscaleImage createGreyscaleFromColorSegmentationKMPP(ImageExt 
        input) {

<span class="nc" id="L2548">        int kColors = 8;</span>

<span class="nc" id="L2550">        return createGreyscaleFromColorSegmentationKMPP(input, kColors);</span>
    }

    /**
     * create an image segmented by color...useful for experimenting with corners
     * due to color differences rather than original intensity differences.
     * Internally, is using a blur of '1' on the image before segmentation.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @return
     */
    public GreyscaleImage createGreyscaleFromColorSegmentation(ImageExt input,
        int kColors) {

<span class="nc" id="L2565">        boolean useBlur = true;</span>

<span class="nc" id="L2567">        return createGreyscaleFromColorSegmentation(input, kColors, useBlur);</span>
    }
    
    /**
     * create an image segmented by color...useful for experimenting with corners
     * due to color differences rather than original intensity differences.
     * Internally, is using a blur of '1' on the image before segmentation.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @return
     */
    public GreyscaleImage createGreyscaleFromColorSegmentationKMPP(ImageExt input,
        int kColors) {

<span class="nc" id="L2582">        boolean useBlur = true;</span>

<span class="nc" id="L2584">        return createGreyscaleFromColorSegmentationKMPP(input, kColors, useBlur);</span>
    }

    /**
     * create an image segmented by color...useful for experimenting with corners
     * due to color differences rather than original intensity differences.
     * Internally, is using a blur of '1' on the image before segmentation.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur
     * @return
     */
    public GreyscaleImage createGreyscaleFromColorSegmentation(ImageExt input,
        int kColors, boolean useBlur) {

<span class="nc bnc" id="L2600" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L2601">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L2603" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L2604">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        GreyscaleImage img;

        int minNeighborLimit;

<span class="nc bnc" id="L2611" title="All 2 branches missed.">        if (useBlur) {</span>

<span class="nc" id="L2613">            Image input2 = input.copyImage();</span>

<span class="nc" id="L2615">            blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="nc" id="L2617">            img = convertToCIEXYPolarTheta(input2, kColors);</span>

<span class="nc" id="L2619">            minNeighborLimit = 6;</span>

<span class="nc" id="L2621">        } else {</span>

<span class="nc" id="L2623">            img = convertToCIEXYPolarTheta(input, kColors);</span>

<span class="nc" id="L2625">            minNeighborLimit = 5;</span>
        }

<span class="nc" id="L2628">        int w = img.getWidth();</span>
<span class="nc" id="L2629">        int h = img.getHeight();</span>

        // ----replace pixel, if 7 or more neighbors have same color -----
<span class="nc" id="L2632">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="nc" id="L2633">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="nc" id="L2635">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L2637">        int nChanged = 1;</span>
<span class="nc" id="L2638">        int nIterMax = 100;</span>
<span class="nc" id="L2639">        int nIter = 0;</span>

<span class="nc bnc" id="L2641" title="All 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="nc" id="L2643">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="nc" id="L2645">            nChanged = 0;</span>

<span class="nc bnc" id="L2647" title="All 2 branches missed.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L2648" title="All 2 branches missed.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L2650">                    freqMap.clear();</span>

<span class="nc" id="L2652">                    Integer maxCountValue = null;</span>
<span class="nc" id="L2653">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L2655" title="All 2 branches missed.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="nc" id="L2656">                        int x = dxs[nIdx] + col;</span>
<span class="nc" id="L2657">                        int y = dys[nIdx] + row;</span>

<span class="nc bnc" id="L2659" title="All 8 branches missed.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L2660">                            break;</span>
                        }

<span class="nc" id="L2663">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="nc" id="L2665">                        Integer c = freqMap.get(v);</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L2667">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="nc" id="L2669">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="nc" id="L2671">                        freqMap.put(v, c);</span>

<span class="nc bnc" id="L2673" title="All 2 branches missed.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="nc" id="L2674">                            maxCount = c.intValue();</span>
<span class="nc" id="L2675">                            maxCountValue = v;</span>
                        }
                    }

<span class="nc bnc" id="L2679" title="All 2 branches missed.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="nc bnc" id="L2680" title="All 2 branches missed.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="nc" id="L2682">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="nc" id="L2683">                        nChanged++;</span>
                    }
                }
            }

<span class="nc" id="L2688">            nIter++;</span>
        }

        // rescale the image
<span class="nc" id="L2692">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L2693">        hEq.applyFilter();</span>

<span class="nc" id="L2695">        return img;</span>
    }

    /**
     * create an image segmented by color...useful for experimenting with corners
     * due to color differences rather than original intensity differences.
     * Internally, is using a blur of '1' on the image before segmentation.
     * @param input
     * @param kColors the number of colors to bin the image by.  max allowed value
     * is 253.
     * @param useBlur
     * @return
     */
    public GreyscaleImage createGreyscaleFromColorSegmentationKMPP(ImageExt input,
        int kColors, boolean useBlur) {

<span class="nc bnc" id="L2711" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L2712">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L2714" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L2715">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        GreyscaleImage img;

        int minNeighborLimit;

<span class="nc bnc" id="L2722" title="All 2 branches missed.">        if (useBlur) {</span>

<span class="nc" id="L2724">            Image input2 = input.copyImage();</span>

<span class="nc" id="L2726">            blur(input2, 1/*(float)Math.sqrt(2)/2.f*/);</span>

<span class="nc" id="L2728">            img = convertToCIEXYPolarThetaKMPP(input2, kColors);</span>

<span class="nc" id="L2730">            minNeighborLimit = 6;</span>

<span class="nc" id="L2732">        } else {</span>

<span class="nc" id="L2734">            img = convertToCIEXYPolarThetaKMPP(input, kColors);</span>

<span class="nc" id="L2736">            minNeighborLimit = 5;</span>
        }

<span class="nc" id="L2739">        int w = img.getWidth();</span>
<span class="nc" id="L2740">        int h = img.getHeight();</span>

        // ----replace pixel, if 7 or more neighbors have same color -----
<span class="nc" id="L2743">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="nc" id="L2744">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="nc" id="L2746">        Map&lt;Integer, Integer&gt; freqMap = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L2748">        int nChanged = 1;</span>
<span class="nc" id="L2749">        int nIterMax = 100;</span>
<span class="nc" id="L2750">        int nIter = 0;</span>

<span class="nc bnc" id="L2752" title="All 6 branches missed.">        while (!useBlur &amp;&amp; (nIter &lt; nIterMax) &amp;&amp; (nChanged &gt; 0)) {</span>

<span class="nc" id="L2754">            log.fine(&quot;nIter=&quot; + nIter + &quot; nChanged=&quot; + nChanged);</span>

<span class="nc" id="L2756">            nChanged = 0;</span>

<span class="nc bnc" id="L2758" title="All 2 branches missed.">            for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">                for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L2761">                    freqMap.clear();</span>

<span class="nc" id="L2763">                    Integer maxCountValue = null;</span>
<span class="nc" id="L2764">                    int maxCount = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L2766" title="All 2 branches missed.">                    for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="nc" id="L2767">                        int x = dxs[nIdx] + col;</span>
<span class="nc" id="L2768">                        int y = dys[nIdx] + row;</span>

<span class="nc bnc" id="L2770" title="All 8 branches missed.">                        if ((x &lt; 0) || (x &gt; (w - 1)) || (y &lt; 0) || (y &gt; (h - 1))) {</span>
<span class="nc" id="L2771">                            break;</span>
                        }

<span class="nc" id="L2774">                        Integer v = Integer.valueOf(img.getValue(x, y));</span>

<span class="nc" id="L2776">                        Integer c = freqMap.get(v);</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L2778">                            c = Integer.valueOf(1);</span>
                        } else {
<span class="nc" id="L2780">                            c = Integer.valueOf(c.intValue() + 1);</span>
                        }
<span class="nc" id="L2782">                        freqMap.put(v, c);</span>

<span class="nc bnc" id="L2784" title="All 2 branches missed.">                        if (c.intValue() &gt; maxCount) {</span>
<span class="nc" id="L2785">                            maxCount = c.intValue();</span>
<span class="nc" id="L2786">                            maxCountValue = v;</span>
                        }
                    }

<span class="nc bnc" id="L2790" title="All 2 branches missed.">                    if ((maxCount &gt;= minNeighborLimit) &amp;&amp;</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">                        (img.getValue(col, row) != maxCountValue.intValue())) {</span>

<span class="nc" id="L2793">                        img.setValue(col, row, maxCountValue.intValue());</span>
<span class="nc" id="L2794">                        nChanged++;</span>
                    }
                }
            }

<span class="nc" id="L2799">            nIter++;</span>
        }

        // rescale the image
<span class="nc" id="L2803">        HistogramEqualization hEq = new HistogramEqualization(img);</span>
<span class="nc" id="L2804">        hEq.applyFilter();</span>

<span class="nc" id="L2806">        return img;</span>
    }
    
    /**
     * convert the color image into an image scaled into values 0 to 255
     * by the polar theta angle in CIE XY color space.  The colors are
     * divided into 254 bins plus black and white.
     *
     * runtime complexity is O(N) + O(N*lg_2(N))
     *
     * @param input
     * @return
     */
    public GreyscaleImage convertToCIEXYPolarTheta(Image input) {

<span class="nc" id="L2821">        return convertToCIEXYPolarTheta(input, 254);</span>
    }

    /**
     * convert the color image into an image scaled into values 0 to 255
     * by the polar theta angle in CIE XY color space.  The colors are divided
     * into kColors number of bins.
     *
     * runtime complexity is O(N) + O(N*lg_2(N))
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage convertToCIEXYPolarTheta(Image input, int kColors) {

<span class="nc bnc" id="L2838" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L2839">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L2841" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L2842">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="nc" id="L2852">        int w = input.getWidth();</span>
<span class="nc" id="L2853">        int h = input.getHeight();</span>

<span class="nc" id="L2855">        float[] tmpColorBuffer = new float[2];</span>

<span class="nc" id="L2857">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="nc" id="L2859">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="nc" id="L2861">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L2863">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="nc" id="L2864">        int thetaCount = 0;</span>

<span class="nc bnc" id="L2866" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L2869">                PairInt p = new PairInt(col, row);</span>

<span class="nc" id="L2871">                int r = input.getR(col, row);</span>
<span class="nc" id="L2872">                int g = input.getG(col, row);</span>
<span class="nc" id="L2873">                int b = input.getB(col, row);</span>

<span class="nc bnc" id="L2875" title="All 6 branches missed.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="nc" id="L2876">                    continue;</span>
<span class="nc bnc" id="L2877" title="All 6 branches missed.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="nc" id="L2878">                    output.setValue(col, row, 255);</span>
<span class="nc" id="L2879">                    continue;</span>
                }

<span class="nc" id="L2882">                float[] cieXY = tmpColorBuffer;</span>
<span class="nc" id="L2883">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="nc bnc" id="L2885" title="All 2 branches missed.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="nc" id="L2886">                    output.setValue(col, row, 255);</span>
                } else {

<span class="nc" id="L2889">                    double theta = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="nc" id="L2891">                    thetaValues[thetaCount] = (float)theta;</span>

<span class="nc" id="L2893">                    pixThetaMap.put(p, Float.valueOf((float)theta));</span>

<span class="nc" id="L2895">                    thetaCount++;</span>
                }
            }
        }

<span class="nc" id="L2900">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="nc" id="L2902">        createAndApplyHistMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="nc" id="L2904">        return output;</span>
    }

    /**
     * convert the color image into an image scaled into values 0 to 255
     * by the polar theta angle in CIE XY color space.  The colors are divided
     * into kColors number of bins.
     *
     * runtime complexity is O(N) + O(N*lg_2(N))
     *
     * @param input
     * @param kColors the number of color bins to use for the image segmentation.
     * The minimum allowed value is 2 and the maximum allowed value is 253.
     * @return
     */
    public GreyscaleImage convertToCIEXYPolarThetaKMPP(Image input, int kColors) {

<span class="nc bnc" id="L2921" title="All 2 branches missed.">        if (kColors &gt; 253) {</span>
<span class="nc" id="L2922">            throw new IllegalArgumentException(&quot;kColors must be &lt;= 253&quot;);</span>
        }
<span class="nc bnc" id="L2924" title="All 2 branches missed.">        if (kColors &lt; 2) {</span>
<span class="nc" id="L2925">            throw new IllegalArgumentException(&quot;kColors must be &gt;= 2&quot;);</span>
        }

        /*
        TODO: needs some improvements in color mapping.
           -- for regions that are very spotty, might consider using the
              intensity image to help define the region and take the highest
              number density color in that region and assign it to all.
        */

<span class="nc" id="L2935">        int w = input.getWidth();</span>
<span class="nc" id="L2936">        int h = input.getHeight();</span>

<span class="nc" id="L2938">        float[] tmpColorBuffer = new float[2];</span>

<span class="nc" id="L2940">        GreyscaleImage output = new GreyscaleImage(w, h);</span>

<span class="nc" id="L2942">        Map&lt;PairInt, Float&gt; pixThetaMap = new HashMap&lt;PairInt, Float&gt;();</span>

<span class="nc" id="L2944">        CIEChromaticity cieC = new CIEChromaticity();</span>

<span class="nc" id="L2946">        float[] thetaValues = new float[input.getNPixels()];</span>
<span class="nc" id="L2947">        int thetaCount = 0;</span>

<span class="nc bnc" id="L2949" title="All 2 branches missed.">        for (int col = 0; col &lt; w; col++) {</span>
<span class="nc bnc" id="L2950" title="All 2 branches missed.">            for (int row = 0; row &lt; h; row++) {</span>

<span class="nc" id="L2952">                PairInt p = new PairInt(col, row);</span>

<span class="nc" id="L2954">                int r = input.getR(col, row);</span>
<span class="nc" id="L2955">                int g = input.getG(col, row);</span>
<span class="nc" id="L2956">                int b = input.getB(col, row);</span>

<span class="nc bnc" id="L2958" title="All 6 branches missed.">                if ((r &lt; 25) &amp;&amp; (g &lt; 25) &amp;&amp; (b &lt; 25)) {</span>
<span class="nc" id="L2959">                    continue;</span>
<span class="nc bnc" id="L2960" title="All 6 branches missed.">                } else if ((r &gt; 230) &amp;&amp; (g &gt; 230) &amp;&amp; (b &gt; 230)) {//might need to use 195 as lower limit</span>
<span class="nc" id="L2961">                    output.setValue(col, row, 255);</span>
<span class="nc" id="L2962">                    continue;</span>
                }

<span class="nc" id="L2965">                float[] cieXY = tmpColorBuffer;</span>
<span class="nc" id="L2966">                cieC.rgbToXYChromaticity(r, g, b, cieXY);</span>

<span class="nc bnc" id="L2968" title="All 2 branches missed.">                if (cieC.isWhite(cieXY[0], cieXY[1])) {</span>
<span class="nc" id="L2969">                    output.setValue(col, row, 255);</span>
                } else {

<span class="nc" id="L2972">                    double theta = cieC.calculateXYTheta(cieXY[0], cieXY[1]);</span>

<span class="nc" id="L2974">                    thetaValues[thetaCount] = (float)theta;</span>

<span class="nc" id="L2976">                    pixThetaMap.put(p, Float.valueOf((float)theta));</span>

<span class="nc" id="L2978">                    thetaCount++;</span>
                }
            }
        }

<span class="nc" id="L2983">        thetaValues = Arrays.copyOf(thetaValues, thetaCount);</span>

<span class="nc" id="L2985">        createAndApplyKMPPMapping(output, pixThetaMap, thetaValues, kColors);</span>

<span class="nc" id="L2987">        return output;</span>
    }

    /**
     * read the image and store the non-zero pixels in a set.  note that negative
     * values will also be stored in the output set.
     * @param img
     * @return
     */
    public Set&lt;PairInt&gt; readNonZeroPixels(GreyscaleImage img) {

<span class="fc" id="L2998">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L3000" title="All 2 branches covered.">        for (int col = 0; col &lt; img.getWidth(); col++) {</span>
<span class="fc bfc" id="L3001" title="All 2 branches covered.">            for (int row = 0; row &lt; img.getHeight(); row++) {</span>
<span class="fc" id="L3002">                int v = img.getValue(col, row);</span>
<span class="fc bfc" id="L3003" title="All 2 branches covered.">                if (v != 0) {</span>
<span class="fc" id="L3004">                    set.add(new PairInt(col, row));</span>
                }
            }
        }

<span class="fc" id="L3009">        return set;</span>
    }

    public void writeAsBinaryToImage(GreyscaleImage img, Set&lt;PairInt&gt;
        nonZeroPoints) {

<span class="fc" id="L3015">        img.fill(0);</span>

<span class="fc bfc" id="L3017" title="All 2 branches covered.">        for (PairInt p : nonZeroPoints) {</span>
<span class="fc" id="L3018">            int x = p.getX();</span>
<span class="fc" id="L3019">            int y = p.getY();</span>
<span class="fc" id="L3020">            img.setValue(x, y, 1);</span>
<span class="fc" id="L3021">        }</span>

<span class="fc" id="L3023">    }</span>

    /**
     * find contiguous zeros in image and if the number of pixels in a groups
     * is less than contiguousZerosLimit, fill in the pixels with the
     * value of the neighboring pixels.
     * NOTE: this is set to use the 4-neighbor region, but can be set to use
     * 8-neighbors if needed.
     */
    public void fillInPixels(GreyscaleImage img, final int valueToFill,
        final int contiguousZerosLimit) {

<span class="nc" id="L3035">        DFSContiguousValueFinder finder = new DFSContiguousValueFinder(img);</span>
<span class="nc" id="L3036">        finder.setMinimumNumberInCluster(1);</span>
<span class="nc" id="L3037">        finder.findGroups(valueToFill);</span>

<span class="nc" id="L3039">        int nGroups = finder.getNumberOfGroups();</span>

<span class="nc bnc" id="L3041" title="All 2 branches missed.">        for (int i = 0; i &lt; nGroups; ++i) {</span>

<span class="nc" id="L3043">            int n = finder.getNumberofGroupMembers(i);</span>

<span class="nc bnc" id="L3045" title="All 2 branches missed.">            if (n &lt;= contiguousZerosLimit) {</span>

<span class="nc" id="L3047">                PairIntArray group = finder.getXY(i);</span>

                // find the adjacent non-zero pixels to these
<span class="nc" id="L3050">                Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">                for (int j = 0; j &lt; group.getN(); ++j)  {</span>
<span class="nc" id="L3052">                    getNeighborsNotThisValue(img, group.getX(j), group.getY(j),</span>
                        valueToFill, neighbors);
                }

                // get thier average intensities
<span class="nc" id="L3057">                double avgV = 0;</span>
<span class="nc bnc" id="L3058" title="All 2 branches missed.">                for (PairInt p : neighbors) {</span>
<span class="nc" id="L3059">                    int v = img.getValue(p.getX(), p.getY());</span>
<span class="nc" id="L3060">                    avgV += v;</span>
<span class="nc" id="L3061">                }</span>
<span class="nc" id="L3062">                avgV /= (double)neighbors.size();</span>
<span class="nc" id="L3063">                int vRepl = Math.round((float)avgV);</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">                for (int j = 0; j &lt; group.getN(); ++j)  {</span>
<span class="nc" id="L3065">                    int x = group.getX(j);</span>
<span class="nc" id="L3066">                    int y = group.getY(j);</span>
<span class="nc" id="L3067">                    img.setValue(x, y, vRepl);</span>
                }
            }
        }

<span class="nc" id="L3072">    }</span>

    public void getNeighborsNotThisValue(GreyscaleImage input, int x, int y,
        final int value, Set&lt;PairInt&gt; outputNeighbors) {

<span class="nc" id="L3077">        int width = input.getWidth();</span>
<span class="nc" id="L3078">        int height = input.getHeight();</span>

<span class="nc bnc" id="L3080" title="All 2 branches missed.">        for (int c = (x - 1); c &lt;= (x + 1); c++) {</span>
<span class="nc bnc" id="L3081" title="All 4 branches missed.">            if ((c &lt; 0) || (c &gt; (width - 1))) {</span>
<span class="nc" id="L3082">                continue;</span>
            }
<span class="nc bnc" id="L3084" title="All 2 branches missed.">            for (int r = (y - 1); r &lt;= (y + 1); r++) {</span>
<span class="nc bnc" id="L3085" title="All 4 branches missed.">                if ((r &lt; 0) || (r &gt; (height - 1))) {</span>
<span class="nc" id="L3086">                    continue;</span>
                }
<span class="nc bnc" id="L3088" title="All 4 branches missed.">                if ((c == x) &amp;&amp; (r == y)) {</span>
<span class="nc" id="L3089">                    continue;</span>
                }
<span class="nc" id="L3091">                int v = input.getValue(c, r);</span>
<span class="nc bnc" id="L3092" title="All 2 branches missed.">                if (v != value) {</span>
<span class="nc" id="L3093">                    PairInt p = new PairInt(c, r);</span>
<span class="nc" id="L3094">                    outputNeighbors.add(p);</span>
                }
            }
        }
<span class="nc" id="L3098">    }</span>

    /**
     * NOT YET TESTED
     *
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     * @param x
     * @param y
     * @return
     */
    public double biLinearInterpolation(GreyscaleImage gsImg, float x, float y) {

<span class="fc" id="L3111">        double x1 = Math.floor(x);</span>

<span class="fc" id="L3113">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L3115">        double y1 = Math.floor(y);</span>

<span class="fc" id="L3117">        double y2 = Math.ceil(y);</span>

        double v1, v2;

<span class="fc bfc" id="L3121" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L3123">            v1 = gsImg.getValue((int)x1, (int)y1);</span>

<span class="pc bpc" id="L3125" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="fc" id="L3126">                return v1;</span>
            }

<span class="nc" id="L3129">            v2 = gsImg.getValue((int)x1, (int)y2);</span>

        } else {

            // interpolate over row y1
<span class="fc" id="L3134">            v1 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y1) +</span>
<span class="fc" id="L3135">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y1);</span>

<span class="fc bfc" id="L3137" title="All 2 branches covered.">            if (y1 == y2) {</span>
<span class="fc" id="L3138">                return v1;</span>
            }

            // interpolate over row y2
<span class="fc" id="L3142">            v2 = ((x2 - x)/(x2 - x1)) * gsImg.getValue((int)x1, (int)y2) +</span>
<span class="fc" id="L3143">                ((x - x1)/(x2 - x1)) * gsImg.getValue((int)x2, (int)y2);</span>
        }

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3147">        double v = ((y2 - y)/(y2 - y1)) * v1 + ((y - y1)/(y2 - y1)) * v2;</span>

<span class="fc" id="L3149">        return v;</span>
    }

    /**
    NOT YET TESTED
     http://en.wikipedia.org/wiki/Bilinear_interpolation
     http://en.wikipedia.org/wiki/Bilinear_interpolation#/media/File:Bilinear_interpolation_visualisation.svg
     *
     * @param x
     * @param y
     * @return
     */
    public double[] biLinearInterpolation(Image clrImg, float x, float y) {

<span class="fc" id="L3163">        double x1 = Math.floor(x);</span>

<span class="fc" id="L3165">        double x2 = Math.ceil(x);</span>

<span class="fc" id="L3167">        double y1 = Math.floor(y);</span>

<span class="fc" id="L3169">        double y2 = Math.ceil(y);</span>

        double r1, r2, g1, g2, b1, b2;

<span class="fc bfc" id="L3173" title="All 2 branches covered.">        if (x1 == x2) {</span>

<span class="fc" id="L3175">            r1 = clrImg.getR((int)x1, (int)y1);</span>
<span class="fc" id="L3176">            g1 = clrImg.getG((int)x1, (int)y1);</span>
<span class="fc" id="L3177">            b1 = clrImg.getB((int)x1, (int)y1);</span>

<span class="pc bpc" id="L3179" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="fc" id="L3180">                return new double[]{r1, g1, b1};</span>
            }

<span class="nc" id="L3183">            r2 = clrImg.getR((int)x1, (int)y2);</span>
<span class="nc" id="L3184">            g2 = clrImg.getG((int)x1, (int)y2);</span>
<span class="nc" id="L3185">            b2 = clrImg.getB((int)x1, (int)y2);</span>

        } else {

<span class="fc" id="L3189">            double v1X2Frac = ((x2 - x)/(x2 - x1));</span>
<span class="fc" id="L3190">            double v1X1Frac = ((x - x1)/(x2 - x1));</span>

            // interpolate over row y1
<span class="fc" id="L3193">            r1 = v1X2Frac * clrImg.getR((int)x1, (int)y1) +</span>
<span class="fc" id="L3194">                v1X1Frac * clrImg.getR((int)x2, (int)y1);</span>

<span class="fc" id="L3196">            g1 = v1X2Frac * clrImg.getG((int)x1, (int)y1) +</span>
<span class="fc" id="L3197">                v1X1Frac * clrImg.getG((int)x2, (int)y1);</span>

<span class="fc" id="L3199">            b1 = v1X2Frac * clrImg.getB((int)x1, (int)y1) +</span>
<span class="fc" id="L3200">                v1X1Frac * clrImg.getB((int)x2, (int)y1);</span>

<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L3203">                return new double[]{r1, g1, b1};</span>
            }

            // interpolate over row y2
<span class="fc" id="L3207">            r2 = v1X2Frac * clrImg.getR((int)x1, (int)y2) +</span>
<span class="fc" id="L3208">                v1X1Frac * clrImg.getR((int)x2, (int)y2);</span>

<span class="fc" id="L3210">            g2 = v1X2Frac * clrImg.getG((int)x1, (int)y2) +</span>
<span class="fc" id="L3211">                v1X1Frac * clrImg.getG((int)x2, (int)y2);</span>

<span class="fc" id="L3213">            b2 = v1X2Frac * clrImg.getB((int)x1, (int)y2) +</span>
<span class="fc" id="L3214">                v1X1Frac * clrImg.getB((int)x2, (int)y2);</span>
        }

<span class="fc" id="L3217">        double v1Y2Frac = ((y2 - y)/(y2 - y1));</span>
<span class="fc" id="L3218">        double v1Y1Frac = ((y - y1)/(y2 - y1));</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3221">        double r = v1Y2Frac * r1 + v1Y1Frac * r2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3224">        double g = v1Y2Frac * g1 + v1Y1Frac * g2;</span>

        // interpolate the fraction of v1 and v2 over rows
<span class="fc" id="L3227">        double b = v1Y2Frac * b1 + v1Y1Frac * b2;</span>

<span class="fc" id="L3229">        return new double[]{r, g, b};</span>
    }

    private void createAndApplyHistMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

<span class="nc" id="L3236">        float minValue = MiscMath.findMin(thetaValues);</span>
<span class="nc" id="L3237">        float maxValue = MiscMath.findMax(thetaValues);</span>

<span class="nc" id="L3239">        log.fine(&quot;minTheta=&quot; + (minValue * 180./Math.PI) +</span>
            &quot; maxTheta=&quot; + (maxValue * 180./Math.PI));

<span class="nc" id="L3242">        int nReserved = 254 - kColors;</span>

<span class="nc" id="L3244">        HistogramHolder hist = Histogram.createSimpleHistogram(minValue,</span>
            maxValue, (256 - nReserved - 1), thetaValues,
<span class="nc" id="L3246">            Errors.populateYErrorsBySqrt(thetaValues));</span>

        try {
<span class="nc" id="L3249">            hist.plotHistogram(&quot;cie XY theta histogram&quot;, &quot;cieXY_hist_&quot; </span>
<span class="nc" id="L3250">                + MiscDebug.getCurrentTimeFormatted());</span>
<span class="nc" id="L3251">        } catch (Exception e) {}</span>

<span class="nc" id="L3253">        int nonZeroCount = 0;</span>
<span class="nc bnc" id="L3254" title="All 2 branches missed.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="nc" id="L3255">            int c = hist.getYHist()[i];</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L3257">                nonZeroCount++;</span>
            }
        }

<span class="nc" id="L3261">        float[] startBins = new float[nonZeroCount];</span>

<span class="nc" id="L3263">        float halfBinWidth = (hist.getXHist()[1] - hist.getXHist()[0])/2.f;</span>

<span class="nc" id="L3265">        nonZeroCount = 0;</span>
<span class="nc bnc" id="L3266" title="All 2 branches missed.">        for (int i = 0; i &lt; hist.getXHist().length; i++) {</span>
<span class="nc" id="L3267">            int c = hist.getYHist()[i];</span>
<span class="nc bnc" id="L3268" title="All 2 branches missed.">            if (c &gt; 0) {</span>
<span class="nc" id="L3269">                startBins[nonZeroCount] = hist.getXHist()[i] - halfBinWidth;</span>
<span class="nc" id="L3270">                nonZeroCount++;</span>
            }
        }

<span class="nc" id="L3274">        Iterator&lt;Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

        // O(N * lg_2(N))
<span class="nc bnc" id="L3277" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L3279">            Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="nc" id="L3281">            PairInt p = entry.getKey();</span>

<span class="nc" id="L3283">            float theta = entry.getValue().floatValue();</span>

<span class="nc" id="L3285">            int idx = Arrays.binarySearch(startBins, theta);</span>

            // if it's negative, (-(insertion point) - 1)
<span class="nc bnc" id="L3288" title="All 2 branches missed.">            if (idx &lt; 0) {</span>
                // idx = -*idx2 - 1
<span class="nc" id="L3290">                idx = -1*(idx + 1);</span>
            }

<span class="nc" id="L3293">            int mappedValue = 255 - startBins.length + idx;</span>

<span class="nc" id="L3295">            output.setValue(p.getX(), p.getY(), mappedValue);</span>
<span class="nc" id="L3296">        }</span>
<span class="nc" id="L3297">    }</span>

    private void createAndApplyKMPPMapping(GreyscaleImage output,
        Map&lt;PairInt, Float&gt; pixThetaMap, float[] thetaValues,
        final int kColors) {

        //TODO: assert kColors.  The invoker is reserving 2 bands for 
        // B &amp; W, so nBins should probably be (kColors - 2)...
        // correct this for the invoker when testing
<span class="nc" id="L3306">        int nBins = kColors;</span>
        
<span class="nc" id="L3308">        KMeansPlusPlusFloat kmpp = new KMeansPlusPlusFloat();</span>
<span class="nc" id="L3309">        kmpp.computeMeans(nBins, thetaValues);</span>
        
<span class="nc" id="L3311">        float minValue = kmpp.getMinValue();</span>
<span class="nc" id="L3312">        float maxValue = kmpp.getMaxValue();</span>

<span class="nc" id="L3314">        float[] binCenters = kmpp.getCenters();</span>
        
<span class="nc" id="L3316">        Iterator&lt;Entry&lt;PairInt, Float&gt; &gt; iter = pixThetaMap.entrySet().iterator();</span>

<span class="nc bnc" id="L3318" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L3320">            Entry&lt;PairInt, Float&gt; entry = iter.next();</span>

<span class="nc" id="L3322">            PairInt p = entry.getKey();</span>

<span class="nc" id="L3324">            float theta = entry.getValue().floatValue();</span>

<span class="nc bnc" id="L3326" title="All 2 branches missed.">            for (int i = 0; i &lt; binCenters.length; i++) {</span>

<span class="nc" id="L3328">                float vc = binCenters[i];</span>

<span class="nc bnc" id="L3330" title="All 2 branches missed.">                float bisectorBelow = ((i - 1) &gt; -1) ?</span>
                    ((binCenters[i - 1] + vc) / 2) : minValue;

<span class="nc bnc" id="L3333" title="All 2 branches missed.">                float bisectorAbove = ((i + 1) &gt; (binCenters.length - 1)) ?</span>
                    maxValue : ((binCenters[i + 1] + vc) / 2);

<span class="nc bnc" id="L3336" title="All 4 branches missed.">                if ((theta &gt;= bisectorBelow) &amp;&amp; (theta &lt;= bisectorAbove)) {</span>

                    //TODO: check this
<span class="nc" id="L3339">                    int mappedValue = 255 - nBins + i;</span>
                    
<span class="nc" id="L3341">                    output.setValue(p.getX(), p.getY(), mappedValue);</span>

<span class="nc" id="L3343">                    break;</span>
                }
            }
            
            /* 
            // if binCenters is ordered, use binary search for faster results
            int idx = Arrays.binarySearch(startBins, theta);

            // if it's negative, (-(insertion point) - 1)
            if (idx &lt; 0) {
                // idx = -*idx2 - 1
                idx = -1*(idx + 1);
            }
            int mappedValue = 255 - startBins.length + idx;

            output.setValue(p.getX(), p.getY(), mappedValue);
            */
<span class="nc" id="L3360">        }</span>
<span class="nc" id="L3361">    }</span>
    public void applyAdaptiveMeanThresholding(GreyscaleImage img) {
        
<span class="nc" id="L3364">        applyAdaptiveMeanThresholding(img, 3);</span>
<span class="nc" id="L3365">    }</span>
    
    public void applyAdaptiveMeanThresholding(GreyscaleImage img, 
        int halfDimension) {
        
<span class="nc" id="L3370">        GreyscaleImage imgM = img.copyImage();</span>

        /*
        7 x 7 averaging
        */
<span class="nc" id="L3375">        applyCenteredMean(imgM, halfDimension);</span>

<span class="nc" id="L3377">        int c = 7;</span>

<span class="nc" id="L3379">        int foreground = 255;//1;</span>
<span class="nc" id="L3380">        int background = 0;</span>

<span class="nc bnc" id="L3382" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getWidth(); ++i) {</span>
<span class="nc bnc" id="L3383" title="All 2 branches missed.">            for (int j = 0; j &lt; img.getHeight(); ++j) {</span>
<span class="nc" id="L3384">                int v = img.getValue(i, j);</span>
<span class="nc" id="L3385">                int m = imgM.getValue(i, j);</span>
<span class="nc" id="L3386">                int t = m - c;</span>
<span class="nc bnc" id="L3387" title="All 2 branches missed.">                if (v &gt; t) {</span>
<span class="nc" id="L3388">                    img.setValue(i, j, foreground);</span>
                } else {
<span class="nc" id="L3390">                    img.setValue(i, j, background);</span>
                }
            }
        }
<span class="nc" id="L3394">    }</span>
    
    /**
     * create an image of the mean of the surrounding dimension x dimension 
     * pixels for each pixel.  The calculation starts at 0 and the end
     * dimension pixels are averaged using the decreasing number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]     
     * [10] [12] [12]
     * 
     * for dimension = 2 becomes:
     * [11] [12] [12]
     * [11] [12] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels)
     * This can be used as part of adaptive mean thresholding.
     * @param img
     * @param dimension
     */
    public void applyBoxcarMean(GreyscaleImage img, int dimension) {
        
<span class="pc bpc" id="L3416" title="2 of 4 branches missed.">        if ((img.getWidth() &lt; dimension) || (img.getHeight() &lt; dimension)) {</span>
<span class="nc" id="L3417">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }
        
        /*
        becomes efficient when dimension &gt; 3
        
        sum along columns first using dynamic programming:
        sumCol[j=0] = sum_j=0_to_dim of row[i]
        sumCol[j=1] = sumCol[0] - row[j-1] + row[dim + j - 1]
        sumCol[j=2] = sumCol[1] - row[j-1] + row[dim + j - 1]
        */
        
<span class="fc" id="L3430">        int w = img.getWidth();</span>
<span class="fc" id="L3431">        int h = img.getHeight();</span>
        
<span class="fc" id="L3433">        GreyscaleImage mean = img.createWithDimensions();</span>
        
        // sum along rows
<span class="fc bfc" id="L3436" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc" id="L3437">            int sum0 = 0;</span>
<span class="fc bfc" id="L3438" title="All 2 branches covered.">            for (int j = 0; j &lt; dimension; ++j) {</span>
<span class="fc" id="L3439">                sum0 += img.getValue(i, j);</span>
            }
<span class="fc" id="L3441">            mean.setValue(i, 0, sum0);</span>
<span class="fc bfc" id="L3442" title="All 2 branches covered.">            for (int j = 1; j &lt;= (h - dimension); ++j) {                </span>
<span class="fc" id="L3443">                int vp = img.getValue(i, j - 1);</span>
<span class="fc" id="L3444">                int vl =  img.getValue(i, dimension + j - 1);</span>
<span class="fc" id="L3445">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3446">                mean.setValue(i, j, sum0);</span>
            }
            // last dimension - 1 rows: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L3449" title="All 2 branches covered.">            for (int j = (h - dimension + 1); j &lt; h; ++j) {</span>
<span class="fc" id="L3450">                float count = h - j;</span>
<span class="fc" id="L3451">                float sum = 0;</span>
<span class="fc bfc" id="L3452" title="All 2 branches covered.">                for (int k = j; k &lt; h; ++k) {</span>
<span class="fc" id="L3453">                    sum += img.getValue(i, k);</span>
                }
<span class="fc" id="L3455">                sum /= count;</span>
<span class="fc" id="L3456">                sum *= dimension;</span>
<span class="fc" id="L3457">                mean.setValue(i, j, Math.round(sum));</span>
            }
        }
        
        // sum along columns
<span class="fc bfc" id="L3462" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3463">            int sum0 = 0;</span>
<span class="fc bfc" id="L3464" title="All 2 branches covered.">            for (int i = 0; i &lt; dimension; ++i) {</span>
<span class="fc" id="L3465">                sum0 += mean.getValue(i, j);</span>
            }
<span class="fc" id="L3467">            img.setValue(0, j, sum0);</span>
<span class="fc bfc" id="L3468" title="All 2 branches covered.">            for (int i = 1; i &lt;= (w - dimension); ++i) {</span>
<span class="fc" id="L3469">                int vp = mean.getValue(i - 1, j);</span>
<span class="fc" id="L3470">                int vl = mean.getValue(dimension + i - 1, j);</span>
<span class="fc" id="L3471">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3472">                img.setValue(i, j, sum0);</span>
            }
            
            // last dimension - 1 cols: sum along them, divide by count then mult by dimension
<span class="fc bfc" id="L3476" title="All 2 branches covered.">            for (int i = (w - dimension + 1); i &lt; w; ++i) {</span>
<span class="fc" id="L3477">                float count = h - i;</span>
<span class="fc" id="L3478">                float sum = 0;</span>
<span class="fc bfc" id="L3479" title="All 2 branches covered.">                for (int k = i; k &lt; w; ++k) {</span>
<span class="fc" id="L3480">                    sum += mean.getValue(k, j);</span>
                }
<span class="fc" id="L3482">                sum /= count;</span>
<span class="fc" id="L3483">                sum *= dimension;</span>
<span class="fc" id="L3484">                img.setValue(i, j, Math.round(sum));</span>
            }            
        }

        // divide each value by dimension * dimension
<span class="fc" id="L3489">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3490" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3491" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3492">                int v = img.getValue(i, j);</span>
<span class="fc" id="L3493">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3494">                img.setValue(i, j, v);</span>
            }
        } 
<span class="fc" id="L3497">    }</span>
    
    /**
     * create an image of the mean of the surrounding dimension x dimension 
     * pixels for each pixel centered on each pixel.  For the starting
     * and ending (dimension/2) pixels, the average uses a descreasing
     * number of pixels.
     * &lt;pre&gt;
     * for example, image:
     * [10] [12] [12]     
     * [10] [12] [12]
     * 
     * for halfDimension = 1 becomes:
     * [11] [11] [12]
     * [11] [11] [12]
     * &lt;/pre&gt;
     * runtime complexity is O(N_pixels)
     * @param img
     * @param halfDimension the pixel center + and - this value in x and y
     * are averaged
     */
    public void applyCenteredMean(GreyscaleImage img, int halfDimension) {
        
<span class="pc bpc" id="L3520" title="1 of 2 branches missed.">        if ((img.getWidth() &lt; 2*halfDimension) || </span>
<span class="pc bpc" id="L3521" title="1 of 2 branches missed.">            (img.getHeight() &lt; 2*halfDimension)) {</span>
<span class="nc" id="L3522">            throw new IllegalArgumentException(&quot;dimension is larger than image&quot;</span>
                + &quot; dimensions.  method not yet handling that.&quot;);
        }
        
        /*
        becomes efficient when halfDimension &gt; 1
        
        sum along columns first using dynamic programming, then rows
        */
        
<span class="fc" id="L3532">        int dimension = 2*halfDimension + 1;</span>
        
<span class="fc" id="L3534">        int w = img.getWidth();</span>
<span class="fc" id="L3535">        int h = img.getHeight();</span>
        
<span class="fc" id="L3537">        GreyscaleImage mean = img.createWithDimensions();</span>
        
        // sum along rows
<span class="fc bfc" id="L3540" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
            
            /* pixels before halfDimension
            halfDimension = 2            
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3547" title="All 2 branches covered.">            for (int j = 0; j &lt; halfDimension; ++j) {</span>
<span class="fc" id="L3548">                float count = halfDimension - j;</span>
<span class="fc" id="L3549">                float sum = 0;</span>
<span class="fc bfc" id="L3550" title="All 2 branches covered.">                for (int k = j; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3551">                    sum += img.getValue(i, k);</span>
                }
<span class="fc" id="L3553">                sum /= count;</span>
<span class="fc" id="L3554">                sum *= dimension;</span>
<span class="fc" id="L3555">                mean.setValue(i, j, Math.round(sum));</span>
            }
            
            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2            
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3564">            int sum0 = 0;</span>
<span class="fc bfc" id="L3565" title="All 2 branches covered.">            for (int j = 0; j &lt;= 2*halfDimension; ++j) {</span>
<span class="fc" id="L3566">                sum0 += img.getValue(i, j);</span>
            }
<span class="fc" id="L3568">            mean.setValue(i, halfDimension, sum0);</span>
            /*
            halfDimension = 2            
            0 1 2 3 4 5 6
              |   *   | 
                |   *   |
                    
            */
<span class="fc bfc" id="L3576" title="All 2 branches covered.">            for (int j = halfDimension + 1; j &lt; (h - halfDimension); ++j) {                </span>
<span class="fc" id="L3577">                int vp = img.getValue(i, j - halfDimension - 1);</span>
<span class="fc" id="L3578">                int vl =  img.getValue(i, j + halfDimension);</span>
<span class="fc" id="L3579">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3580">                mean.setValue(i, j, sum0);</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2 
                &gt;
            */
<span class="fc bfc" id="L3586" title="All 2 branches covered.">            for (int j = (h - halfDimension); j &lt; h; ++j) {</span>
<span class="fc" id="L3587">                float count = h - j + 1;</span>
<span class="fc" id="L3588">                float sum = 0;</span>
<span class="fc bfc" id="L3589" title="All 2 branches covered.">                for (int k = (j - 1); k &lt; h; ++k) {</span>
<span class="fc" id="L3590">                    sum += img.getValue(i, k);</span>
                }
<span class="fc" id="L3592">                sum /= count;</span>
<span class="fc" id="L3593">                sum *= dimension;</span>
<span class="fc" id="L3594">                mean.setValue(i, j, Math.round(sum));</span>
            }
        }
        
        // sum along columns
<span class="fc bfc" id="L3599" title="All 2 branches covered.">        for (int j = 0; j &lt; h; ++j) {</span>
          
            /* pixels before halfDimension
            halfDimension = 2            
            0 1 2 3 4 5 6
                &lt;
            */
<span class="fc bfc" id="L3606" title="All 2 branches covered.">            for (int i = 0; i &lt; halfDimension; ++i) {</span>
<span class="fc" id="L3607">                float count = halfDimension - i;</span>
<span class="fc" id="L3608">                float sum = 0;</span>
<span class="fc bfc" id="L3609" title="All 2 branches covered.">                for (int k = i; k &lt; halfDimension; ++k) {</span>
<span class="fc" id="L3610">                    sum += mean.getValue(k, j);</span>
                }
<span class="fc" id="L3612">                sum /= count;</span>
<span class="fc" id="L3613">                sum *= dimension;</span>
<span class="fc" id="L3614">                img.setValue(i, j, Math.round(sum));</span>
            }
            
            /* pixels between halfDimension and j-halfDimension
            halfDimension = 2            
            0 1 2 3 4 5
            |   *   |  sum from idx - halfDimension to idx + halfDimension, incl
            but store in idx
            */
<span class="fc" id="L3623">            int sum0 = 0;</span>
<span class="fc bfc" id="L3624" title="All 2 branches covered.">            for (int i = 0; i &lt;= 2*halfDimension; ++i) {</span>
<span class="fc" id="L3625">                sum0 += mean.getValue(i, j);</span>
            }
<span class="fc" id="L3627">            img.setValue(halfDimension, j, sum0);</span>
            /*
            halfDimension = 2            
            0 1 2 3 4 5 6
              |   *   | 
                |   *   |
                    
            */
<span class="fc bfc" id="L3635" title="All 2 branches covered.">            for (int i = halfDimension + 1; i &lt; (w - halfDimension); ++i) {                </span>
<span class="fc" id="L3636">                int vp = mean.getValue(i - halfDimension - 1, j);</span>
<span class="fc" id="L3637">                int vl =  mean.getValue(i + halfDimension, j);</span>
<span class="fc" id="L3638">                sum0 = sum0 - vp + vl;</span>
<span class="fc" id="L3639">                img.setValue(i, j, sum0);</span>
            }
            /* last halfDimension pixels
            0 1 2 3   n=4, halfDimension = 2 
                &gt;
            */
<span class="fc bfc" id="L3645" title="All 2 branches covered.">            for (int i = (w - halfDimension); i &lt; w; ++i) {</span>
<span class="fc" id="L3646">                float count = w - i + 1;</span>
<span class="fc" id="L3647">                float sum = 0;</span>
<span class="fc bfc" id="L3648" title="All 2 branches covered.">                for (int k = (i - 1); k &lt; w; ++k) {</span>
<span class="fc" id="L3649">                    sum += mean.getValue(k, j);</span>
                }
<span class="fc" id="L3651">                sum /= count;</span>
<span class="fc" id="L3652">                sum *= dimension;</span>
<span class="fc" id="L3653">                img.setValue(i, j, Math.round(sum));</span>
            }
        }
        
        // divide each value by dimension * dimension
<span class="fc" id="L3658">        float dsq = dimension * dimension;</span>
<span class="fc bfc" id="L3659" title="All 2 branches covered.">        for (int i = 0; i &lt; w; ++i) {</span>
<span class="fc bfc" id="L3660" title="All 2 branches covered.">            for (int j = 0; j &lt; h; ++j) {</span>
<span class="fc" id="L3661">                int v = img.getValue(i, j);</span>
<span class="fc" id="L3662">                v = Math.round((float)v/dsq);</span>
<span class="fc" id="L3663">                img.setValue(i, j, v);</span>
            }
        } 
<span class="fc" id="L3666">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
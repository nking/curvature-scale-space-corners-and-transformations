<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MatchedPointsTransformationCalculator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">MatchedPointsTransformationCalculator.java</span></div><h1>MatchedPointsTransformationCalculator.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.imageProcessing.util.AngleUtil;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;

/**
 *
 * @author nichole
 */
<span class="fc" id="L19">public class MatchedPointsTransformationCalculator {</span>

<span class="fc" id="L21">    protected transient Logger log = Logger.getLogger(</span>
<span class="fc" id="L22">        MatchedPointsTransformationCalculator.class.getName());</span>

<span class="fc" id="L24">    private boolean debug = false;</span>

    public void useDebugMode() {
<span class="fc" id="L27">        debug = true;</span>
<span class="fc" id="L28">    }</span>

    /**
     * coordinate transformations from image 1 to image 2 are calculated from
     * matching lists of x, y coordinates, and given &quot;scale&quot; as a starting
     * parameter.  Scale is determined roughly from the contour matcher,
     * so can be used to get a rough first solution.
     * Note, the rotation, when applied, will result in a clockwise
      * direction (which is in the -z direction using right hand rule).
     *&lt;pre&gt;
     * positive Y is up
       positive X is right
       positive theta starts from Y=0, X&gt;=0 and proceeds CW
             +Y 270
                 |
                 |
          180--------- 0   +X
                 |
                 |
                 90
                 -Y
     * &lt;/pre&gt;
     * @param scale
     * @param matchedXY1
     * @param matchedXY2
     * @param centroidX1
     * @param centroidY1
     * @return 
     */
    public TransformationParameters calulateEuclideanGivenScale(
        double scale, PairIntArray matchedXY1, PairIntArray matchedXY2,
        double centroidX1, double centroidY1) {

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (matchedXY1 == null) {</span>
<span class="nc" id="L62">            throw new IllegalArgumentException(&quot;matchedXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (matchedXY2 == null) {</span>
<span class="nc" id="L65">            throw new IllegalArgumentException(&quot;matchedXY2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (matchedXY1.getN() != matchedXY2.getN()) {</span>
<span class="nc" id="L68">            throw new IllegalArgumentException(</span>
                &quot;matchedXY1 and matchedXY2 must have same number of points&quot;);
        }
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (matchedXY1.getN() &lt; 2) {</span>
<span class="fc" id="L72">            return null;</span>
        }

<span class="fc" id="L75">        log.info(&quot;start solution for &quot; + matchedXY1.getN() + &quot; points&quot;);</span>

        /*
        solve for rotation.

        Take the same 2 pairs int both images and get the difference in their
        angles:
            tan(theta) = y / x

        For example:
            theta of pair in image1:
                theta = math.atan( (y1-y0)/(x1-x0) )
                      = 0.7853981633974483 radians
                      = 45 degrees

            theta of pair in image2:
                theta = math.atan( (yt1-yt0)/(xt1-xt0) )
                      = 0.3490522203358645
                      = 20.0

            rotation = theta_image1 - theta_image2 = 25 degrees
        */

        /*
        discard outside avg +- stdev
        */

<span class="fc" id="L102">        AngleUtil angleUtil = new AngleUtil();</span>

<span class="fc" id="L104">        double[] thetas = new double[matchedXY1.getN()];</span>
<span class="fc" id="L105">        double[] scales = new double[matchedXY1.getN()];</span>
<span class="fc" id="L106">        double thetaSum = 0;</span>
<span class="fc" id="L107">        double scaleSum = 0;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedXY1.getN(); i++) {</span>
<span class="fc" id="L109">            int x0im1 = matchedXY1.getX(i);</span>
<span class="fc" id="L110">            int y0im1 = matchedXY1.getY(i);</span>
<span class="fc" id="L111">            int x0im2 = matchedXY2.getX(i);</span>
<span class="fc" id="L112">            int y0im2 = matchedXY2.getY(i);</span>
            int x1im1, y1im1, x1im2, y1im2;
<span class="fc bfc" id="L114" title="All 2 branches covered.">            if ((i + 1) == matchedXY1.getN()) {</span>
<span class="fc" id="L115">                x1im1 = matchedXY1.getX(0);</span>
<span class="fc" id="L116">                y1im1 = matchedXY1.getY(0);</span>
<span class="fc" id="L117">                x1im2 = matchedXY2.getX(0);</span>
<span class="fc" id="L118">                y1im2 = matchedXY2.getY(0);</span>
            } else {
<span class="fc" id="L120">                x1im1 = matchedXY1.getX(i + 1);</span>
<span class="fc" id="L121">                y1im1 = matchedXY1.getY(i + 1);</span>
<span class="fc" id="L122">                x1im2 = matchedXY2.getX(i + 1);</span>
<span class="fc" id="L123">                y1im2 = matchedXY2.getY(i + 1);</span>
            }
<span class="fc" id="L125">            double diffX1 = (x1im1 - x0im1);</span>
<span class="fc" id="L126">            double diffY1 = (y1im1 - y0im1);</span>

<span class="fc" id="L128">            double diffX2 = (x1im2 - x0im2);</span>
<span class="fc" id="L129">            double diffY2 = (y1im2 - y0im2);</span>

<span class="fc" id="L131">            double t = angleUtil.subtract(diffX1, diffY1, diffX2, diffY2);</span>

<span class="fc" id="L133">            t *= -1;</span>
            
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (t &lt; 0) {</span>
<span class="fc" id="L136">                t = 2 * Math.PI + t;</span>
            }
            
<span class="fc" id="L139">            thetas[i] = t;</span>

<span class="fc" id="L141">            thetaSum += thetas[i];</span>

<span class="fc" id="L143">            double lenim1 = Math.sqrt(Math.pow(diffX1, 2)</span>
<span class="fc" id="L144">                + Math.pow(diffY1, 2));</span>
<span class="fc" id="L145">            double lenim2 = Math.sqrt(Math.pow(diffX2, 2)</span>
<span class="fc" id="L146">                + Math.pow(diffY2, 2));</span>
<span class="fc" id="L147">            scales[i] = lenim2/lenim1;</span>
<span class="fc" id="L148">            scaleSum += scales[i];</span>
        }

<span class="fc" id="L151">        double avgScale = scaleSum / (double)matchedXY1.getN();</span>
<span class="fc" id="L152">        double avgTheta = thetaSum / (double)matchedXY1.getN();</span>
<span class="fc" id="L153">        double stDevThetaSum = 0;</span>
<span class="fc" id="L154">        double stDevScaleSum = 0;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedXY1.getN(); i++) {</span>
<span class="fc" id="L156">            stDevThetaSum += Math.pow(thetas[i] - avgTheta, 2);</span>
<span class="fc" id="L157">            stDevScaleSum += Math.pow(scales[i] - avgScale, 2);</span>
        }
<span class="fc" id="L159">        double stDevTheta= Math.sqrt(stDevThetaSum/(matchedXY1.getN() - 1));</span>
<span class="fc" id="L160">        double stDevScale= Math.sqrt(stDevScaleSum/(matchedXY1.getN() - 1));</span>

<span class="fc" id="L162">        double rotSum = 0;</span>
<span class="fc" id="L163">        double rCount = 0;</span>
<span class="fc" id="L164">        scaleSum = 0;</span>
<span class="fc" id="L165">        double sCount = 0;</span>

<span class="fc" id="L167">        List&lt;Integer&gt; rm = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedXY1.getN(); i++) {</span>
<span class="fc" id="L169">            double dss = Math.abs(scales[i] - avgScale);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (dss &gt; 1.5*stDevScale) {</span>
<span class="fc" id="L171">                rm.add(Integer.valueOf(i));</span>
<span class="fc" id="L172">                continue;</span>
            }
<span class="fc" id="L174">            double dtt = Math.abs(thetas[i] - avgTheta);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (dtt &gt; 1.5*stDevTheta) {</span>
<span class="fc" id="L176">                rm.add(Integer.valueOf(i));</span>
<span class="fc" id="L177">                continue;</span>
            }

<span class="fc" id="L180">log.info(&quot;scl=&quot; + scales[i] + &quot; stDevScale=&quot; + stDevScale</span>
+ &quot; abs(scale-avg)=&quot; + dss);

<span class="fc" id="L183">            scaleSum += scales[i];</span>
<span class="fc" id="L184">            sCount++;</span>

<span class="fc" id="L186">log.info(&quot;rot=&quot; + thetas[i] + &quot; stDevTheta=&quot; + stDevTheta</span>
+ &quot; abs(theta-avg)=&quot; + dtt);

<span class="fc" id="L189">            rotSum += thetas[i];</span>
<span class="fc" id="L190">            rCount++;</span>
        }

<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (!rm.isEmpty()) {</span>

<span class="fc" id="L195">            PairIntArray xy1 = new PairIntArray();</span>
<span class="fc" id="L196">            PairIntArray xy2 = new PairIntArray();</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">            for (int i = 0; i &lt; matchedXY1.getN(); i++) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (rm.contains(Integer.valueOf(i))) {</span>
<span class="fc" id="L200">                    continue;</span>
                }
<span class="fc" id="L202">                xy1.add(matchedXY1.getX(i), matchedXY1.getY(i));</span>
<span class="fc" id="L203">                xy2.add(matchedXY2.getX(i), matchedXY2.getY(i));</span>
            }

<span class="fc" id="L206">            return calulateEuclideanGivenScale(scale, xy1,</span>
                xy2, centroidX1, centroidY1);
        }

<span class="fc" id="L210">        double theRotation = rotSum/rCount;</span>
<span class="fc" id="L211">        double theScale = scaleSum/sCount;</span>

<span class="fc" id="L213">        log.info(&quot;given scale=&quot; + scale + &quot; found scale=&quot; + theScale);</span>
<span class="fc" id="L214">        log.info(&quot;rotation = &quot; + theRotation);</span>

<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (Math.abs(theScale - scale) &gt; scale*0.1) {</span>
<span class="fc" id="L217">            log.warning(&quot;the differences in estimated scale and given scale are&quot;</span>
                + &quot; large.  this can happen if the given scale value was &quot;
                + &quot; determined from contour matching.&quot;
                + &quot; the estimate here uses pairs of points which may&quot;
                + &quot; be close to one another.  choosing the scale given to &quot;
                + &quot; the method and continuing.&quot;);
        }

<span class="fc" id="L225">        theScale = scale;</span>

        /*
        estimate translation:

        transX = xt0 - 
            (xc*scale + (((x0-xc)*scale*math.cos(theta))
            + ((y0-yc)*scale*math.sin(theta)))

        transY = yt0 - 
            (yc*scale + ((-(x0-xc)*scale*math.sin(theta))
            + ((y0-yc)*scale*math.cos(theta)))
        */
<span class="fc" id="L238">        double mc = Math.cos(theRotation);</span>
<span class="fc" id="L239">        double ms = Math.sin(theRotation);</span>
<span class="fc" id="L240">        double transXSum = 0;</span>
<span class="fc" id="L241">        double transYSum = 0;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedXY1.getN(); i++) {</span>
<span class="fc" id="L243">            int xim1 = matchedXY1.getX(i);</span>
<span class="fc" id="L244">            int yim1 = matchedXY1.getY(i);</span>
<span class="fc" id="L245">            int xim2 = matchedXY2.getX(i);</span>
<span class="fc" id="L246">            int yim2 = matchedXY2.getY(i);</span>

<span class="fc" id="L248">            double trX1 = centroidX1*scale + ((xim1 - centroidX1) * scale*mc)</span>
                + ((yim1 - centroidY1) *scale*ms);

<span class="fc" id="L251">            double trY1 = centroidY1*scale + (-(xim1 - centroidX1) * scale*ms)</span>
                + ((yim1 - centroidY1) * scale*mc);

<span class="fc" id="L254">            double transX = xim2 - trX1;</span>

<span class="fc" id="L256">            double transY = yim2 - trY1;</span>

<span class="fc" id="L258">            transXSum += transX;</span>
<span class="fc" id="L259">            transYSum += transY;</span>
        }
<span class="fc" id="L261">        double theTranslationX = transXSum/(double)matchedXY1.getN();</span>
<span class="fc" id="L262">        double theTranslationY = transYSum/(double)matchedXY1.getN();</span>

<span class="fc" id="L264">        TransformationParameters params = new TransformationParameters();</span>
<span class="fc" id="L265">        params.setRotationInRadians((float)theRotation);</span>
<span class="fc" id="L266">        params.setScale((float)theScale);</span>
<span class="fc" id="L267">        params.setTranslationX((float)theTranslationX);</span>
<span class="fc" id="L268">        params.setTranslationY((float)theTranslationY);</span>
<span class="fc" id="L269">        params.setOriginX((float)centroidX1);</span>
<span class="fc" id="L270">        params.setOriginY((float)centroidY1);</span>

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L273">            log.info(&quot;params: &quot; + params.toString());</span>
        }

<span class="fc" id="L276">        return params;</span>
    }

     /**
     * coordinate transformations from pair 1 to pair 2 are calculated.
     *
     * positive Y is up
       positive X is right
       positive theta starts from Y=0, X&gt;=0 and proceeds CW
                270
                 |
                 |
          180--------- 0   +X
                 |
                 |
                 90
                 -Y
     * &lt;/pre&gt;
     * @param centroidX1
     * @param centroidY1
     * @return
     */
    public TransformationParameters calulateEuclidean(
        final int set1X1, final int set1Y1,
        final int set1X2, final int set1Y2,
        final int set2X1, final int set2Y1,
        final int set2X2, final int set2Y2,
        final double centroidX1, final double centroidY1) {

        /*
        solve for rotation.

        Take the same 2 pairs int both images and get the difference in their
        angles:
            tan(theta) = y / x

        For example:
            theta of pair in image1:
                theta = math.atan( (y1-y0)/(x1-x0) )
                      = 0.7853981633974483 radians
                      = 45 degrees

            theta of pair in image2:
                theta = math.atan( (yt1-yt0)/(xt1-xt0) )
                      = 0.3490522203358645
                      = 20.0

            rotation = theta_image1 - theta_image2 = 25 degrees
        */

<span class="fc" id="L326">        AngleUtil angleUtil = new AngleUtil();</span>

<span class="fc" id="L328">        double dx1 = set1X1 - set1X2;</span>
<span class="fc" id="L329">        double dy1 = set1Y1 - set1Y2;</span>

<span class="fc" id="L331">        double dx2 = set2X1 - set2X2;</span>
<span class="fc" id="L332">        double dy2 = set2Y1 - set2Y2;</span>

<span class="fc" id="L334">        double theta = angleUtil.subtract(dx1, dy1, dx2, dy2);</span>
        
<span class="fc" id="L336">        theta *= -1;</span>
            
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (theta &lt; 0) {</span>
<span class="fc" id="L339">            theta = 2 * Math.PI + theta;</span>
        }

<span class="fc" id="L342">        double sep1 = Math.sqrt((dx1*dx1) + (dy1*dy1));</span>

<span class="fc" id="L344">        double sep2 = Math.sqrt((dx2*dx2) + (dy2*dy2));</span>

<span class="fc" id="L346">        double scale = sep2/sep1;</span>

        /*
        estimate translation:

        xr_0 = xc*scale + (((x0-xc)*scale*math.cos(theta)) - ((y0-yc)*scale*math.sin(theta)))

        xt_0 = xr_0 + transX = x1

        yr_0 = yc*scale + (((x0-xc)*scale*math.sin(theta)) + ((y0-yc)*scale*math.cos(theta)))

        yt_0 = yr_0 + transY = y1
        */
<span class="fc" id="L359">        double mc = Math.cos(theta);</span>
<span class="fc" id="L360">        double ms = Math.sin(theta);</span>

<span class="fc" id="L362">        double tr1X1 = centroidX1*scale + ((set1X1 - centroidX1) * scale*mc)</span>
            + ((set1Y1 - centroidY1) *scale*ms);

<span class="fc" id="L365">        double tr1Y1 = centroidY1*scale + (-(set1X1 - centroidX1) *scale*ms)</span>
            + ((set1Y1 - centroidY1) *scale*mc);

<span class="fc" id="L368">        double tr1X2 = centroidX1*scale + ((set1X2 - centroidX1) * scale*mc)</span>
            + ((set1Y2 - centroidY1) *scale*ms);

<span class="fc" id="L371">        double tr1Y2 = centroidY1*scale + (-(set1X2 - centroidX1) *scale*ms)</span>
            + ((set1Y2 - centroidY1) *scale*mc);

<span class="fc" id="L374">        double transX1 = (set2X1 - tr1X1);</span>
<span class="fc" id="L375">        double transX2 = (set2X2 - tr1X2);</span>
<span class="fc" id="L376">        double transY1 = (set2Y1 - tr1Y1);</span>
<span class="fc" id="L377">        double transY2 = (set2Y2 - tr1Y2);</span>

<span class="fc" id="L379">        double transX = 0.5 * (transX1 + transX2);</span>

<span class="fc" id="L381">        double transY = 0.5 * (transY1 + transY2);</span>

<span class="fc" id="L383">        TransformationParameters params = new TransformationParameters();</span>
<span class="fc" id="L384">        params.setRotationInRadians((float)theta);</span>
<span class="fc" id="L385">        params.setScale((float)scale);</span>
<span class="fc" id="L386">        params.setTranslationX((float)transX);</span>
<span class="fc" id="L387">        params.setTranslationY((float)transY);</span>
<span class="fc" id="L388">        params.setOriginX((float)centroidX1);</span>
<span class="fc" id="L389">        params.setOriginY((float)centroidY1);</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L392">            log.info(&quot;params: &quot; + params.toString());</span>
        }

<span class="fc" id="L395">        return params;</span>
    }

    /**
     * coordinate transformations from pair 1 to pair 2 are calculated from
     * the widest pairings of the given matched points.  Two solutions are
     * returned for the invoker to evaluate, the first is from using the average
     * solution from pairs of points after removing outliers, the second
     * is from only the highest weighted pairing.
     *
     * positive Y is up
       positive X is right
       positive theta starts from Y=0, X&gt;=0 and proceeds CW
                270
                 |
                 |
          180--------- 0   +X
                 |
                 |
                 90
                 -Y
     * &lt;/pre&gt;
     * @param matchedXY1
     * @param matchedXY2
     * @param weights
     * @param centroidX1
     * @param centroidY1
     * @param outputScaleRotTransXYStDev output standard deviation of
     * the scale, rotation, and translations in X and Y. If null, calculations
     * are not performed for standard deviation from mean.
     * @return
     */
    public TransformationParameters calulateEuclidean(
        PairIntArray matchedXY1, PairIntArray matchedXY2, float[] weights,
        final double centroidX1, final double centroidY1,
        float[] outputScaleRotTransXYStDev) {
        
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (matchedXY1 == null) {</span>
<span class="nc" id="L433">            throw new IllegalArgumentException(&quot;matchedXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (matchedXY2 == null) {</span>
<span class="nc" id="L436">            throw new IllegalArgumentException(&quot;matchedXY2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">        if (weights == null) {</span>
<span class="nc" id="L439">            throw new IllegalArgumentException(&quot;weights cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (matchedXY1.getN() != matchedXY2.getN()) {</span>
<span class="nc" id="L442">            throw new IllegalArgumentException(</span>
            &quot;matchedXY1 must be the same length as matchedXY2&quot;);
        }
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (matchedXY1.getN() != weights.length) {</span>
<span class="nc" id="L446">            throw new IllegalArgumentException(</span>
            &quot;weights must be the same length as matchedXY1&quot;);
        }
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (matchedXY1.getN() &lt; 2) {</span>
<span class="nc" id="L450">            throw new IllegalArgumentException(</span>
            &quot;matchedXY1 must have at least 2 points&quot;);
        }
<span class="pc bpc" id="L453" title="2 of 4 branches missed.">        if ((outputScaleRotTransXYStDev != null) &amp;&amp; (outputScaleRotTransXYStDev.length &lt; 4)) {</span>
<span class="nc" id="L454">            throw new IllegalArgumentException(</span>
            &quot;outputScaleRotTransXYStDev has to be at least 4 in length if not null&quot;);
        }
       
        /*
        solve for rotation.

        Take the same 2 pairs int both images and get the difference in their
        angles:
            tan(theta) = y / x

        For example:
            theta of pair in image1:
                theta = math.atan( (y1-y0)/(x1-x0) )
                      = 0.7853981633974483 radians
                      = 45 degrees

            theta of pair in image2:
                theta = math.atan( (yt1-yt0)/(xt1-xt0) )
                      = 0.3490522203358645
                      = 20.0

            rotation = theta_image1 - theta_image2 = 25 degrees
        */
            
        /*
        choosing pairs of points by optimal pairing for maximum distance.
        since hungarian algorithm is set for min cost,
            using 1/distance, and when i1==i2, using max value.
        */
<span class="fc" id="L484">        float[][] invDist = new float[matchedXY1.getN()][matchedXY1.getN()];</span>

<span class="fc bfc" id="L486" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; matchedXY1.getN(); ++i1) {</span>
<span class="fc" id="L487">            int x1 = matchedXY1.getX(i1);</span>
<span class="fc" id="L488">            int y1 = matchedXY1.getY(i1);</span>
<span class="fc" id="L489">            invDist[i1] = new float[matchedXY1.getN()];</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">            for (int i2 = 0; i2 &lt; matchedXY1.getN(); ++i2) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (i1 == i2) {</span>
<span class="fc" id="L492">                    invDist[i1][i2] = Float.MAX_VALUE;</span>
<span class="fc" id="L493">                    continue;</span>
                }
<span class="fc" id="L495">                int x2 = matchedXY1.getX(i2);</span>
<span class="fc" id="L496">                int y2 = matchedXY1.getY(i2);</span>
<span class="fc" id="L497">                int diffX = x1 - x2;</span>
<span class="fc" id="L498">                int diffY = y1 - y2;</span>
<span class="fc" id="L499">                double dist = Math.sqrt(diffX*diffX + diffY*diffY);</span>
<span class="fc" id="L500">                invDist[i1][i2] = (float)(1./dist);</span>
            }
        }

<span class="fc" id="L504">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="fc" id="L505">        int[][] match = b.computeAssignments(invDist);</span>
        
<span class="fc" id="L507">        Set&lt;PairInt&gt; pairIndexes = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (int i = 0; i &lt; match.length; i++) {</span>

<span class="fc" id="L510">            int idx1 = match[i][0];</span>
<span class="fc" id="L511">            int idx2 = match[i][1];</span>
<span class="pc bpc" id="L512" title="2 of 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L513">                continue;</span>
            }
            
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (idx2 &lt; idx1) {</span>
<span class="fc" id="L517">                int swap = idx1;</span>
<span class="fc" id="L518">                idx1 = idx2;</span>
<span class="fc" id="L519">                idx2 = swap;</span>
            }
            
<span class="fc" id="L522">            pairIndexes.add(new PairInt(idx1, idx2));</span>
        }

<span class="fc" id="L525">        AngleUtil angleUtil = new AngleUtil();</span>

<span class="fc" id="L527">        float totW = 0;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (PairInt pairIndex : pairIndexes) {</span>
<span class="fc" id="L529">            int idx1 = pairIndex.getX();</span>
<span class="fc" id="L530">            int idx2 = pairIndex.getY();            </span>
<span class="fc" id="L531">            float pairWeight = (weights[idx1] + weights[idx2]);</span>
<span class="fc" id="L532">            totW += pairWeight;</span>
<span class="fc" id="L533">        }</span>
<span class="fc" id="L534">        Map&lt;PairInt, Float&gt; pairWeights = new HashMap&lt;PairInt, Float&gt;();</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (PairInt pairIndex : pairIndexes) {</span>
<span class="fc" id="L536">            int idx1 = pairIndex.getX();</span>
<span class="fc" id="L537">            int idx2 = pairIndex.getY();            </span>
<span class="fc" id="L538">            float pairWeight = (weights[idx1] + weights[idx2])/totW;</span>
<span class="fc" id="L539">            pairWeights.put(pairIndex, Float.valueOf(pairWeight));</span>
<span class="fc" id="L540">        }</span>
        
<span class="fc" id="L542">        List&lt;Double&gt; thetas = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L543">        List&lt;Float&gt; thetasWeights = new ArrayList&lt;Float&gt;();</span>
        
<span class="fc" id="L545">        double scaleAvg = 0;</span>
<span class="fc" id="L546">        double transXAvg = 0;</span>
<span class="fc" id="L547">        double transYAvg = 0;</span>
        
<span class="fc" id="L549">        List&lt;Float&gt; scales = new ArrayList&lt;Float&gt;();</span>
<span class="fc" id="L550">        List&lt;Float&gt; transXs = new ArrayList&lt;Float&gt;();</span>
<span class="fc" id="L551">        List&lt;Float&gt; transYs = new ArrayList&lt;Float&gt;();</span>
                
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (PairInt pairIndex : pairIndexes) {</span>

<span class="fc" id="L555">            int idx1 = pairIndex.getX();</span>
<span class="fc" id="L556">            int idx2 = pairIndex.getY();</span>

<span class="fc" id="L558">            int set1X1 = matchedXY1.getX(idx1);</span>
<span class="fc" id="L559">            int set1Y1 = matchedXY1.getY(idx1);</span>
<span class="fc" id="L560">            int set1X2 = matchedXY1.getX(idx2);</span>
<span class="fc" id="L561">            int set1Y2 = matchedXY1.getY(idx2);</span>

<span class="fc" id="L563">            int set2X1 = matchedXY2.getX(idx1);</span>
<span class="fc" id="L564">            int set2Y1 = matchedXY2.getY(idx1);</span>
<span class="fc" id="L565">            int set2X2 = matchedXY2.getX(idx2);</span>
<span class="fc" id="L566">            int set2Y2 = matchedXY2.getY(idx2);</span>

<span class="fc" id="L568">            double dx1 = set1X1 - set1X2;</span>
<span class="fc" id="L569">            double dy1 = set1Y1 - set1Y2;</span>

<span class="fc" id="L571">            double dx2 = set2X1 - set2X2;</span>
<span class="fc" id="L572">            double dy2 = set2Y1 - set2Y2;</span>
            
<span class="fc" id="L574">            double theta = angleUtil.subtract(dx1, dy1, dx2, dy2);</span>

<span class="fc" id="L576">            theta *= -1;</span>
            
<span class="fc bfc" id="L578" title="All 2 branches covered.">            if (theta &lt; 0) {</span>
<span class="fc" id="L579">                theta = 2 * Math.PI + theta;</span>
            }
            
<span class="fc" id="L582">            double sep1 = Math.sqrt((dx1*dx1) + (dy1*dy1));</span>

<span class="fc" id="L584">            double sep2 = Math.sqrt((dx2*dx2) + (dy2*dy2));</span>

<span class="fc" id="L586">            double scale = sep2/sep1;</span>
            
            /*
            estimate translation:

            xr_0 = xc*scale + (((x0-xc)*scale*math.cos(theta)) - ((y0-yc)*scale*math.sin(theta)))

            xt_0 = xr_0 + transX = x1

            yr_0 = yc*scale + (((x0-xc)*scale*math.sin(theta)) + ((y0-yc)*scale*math.cos(theta)))

            yt_0 = yr_0 + transY = y1
            */
<span class="fc" id="L599">            double mc = Math.cos(theta);</span>
<span class="fc" id="L600">            double ms = Math.sin(theta);</span>

<span class="fc" id="L602">            double tr1X1 = centroidX1 * scale + (((set1X1 - centroidX1) * scale * mc)</span>
                + ((set1Y1 - centroidY1) * scale * ms));

<span class="fc" id="L605">            double tr1Y1 = centroidY1 * scale + (-(set1X1 - centroidX1) * scale * ms)</span>
                + ((set1Y1 - centroidY1) * scale * mc);

<span class="fc" id="L608">            double tr1X2 = centroidX1 * scale + (((set1X2 - centroidX1) * scale * mc)</span>
                + ((set1Y2 - centroidY1) * scale * ms));

<span class="fc" id="L611">            double tr1Y2 = centroidY1 * scale + (-(set1X2 - centroidX1) * scale * ms)</span>
                + ((set1Y2 - centroidY1) * scale * mc);

<span class="fc" id="L614">            double transX1 = (set2X1 - tr1X1);</span>
<span class="fc" id="L615">            double transX2 = (set2X2 - tr1X2);</span>
<span class="fc" id="L616">            double transY1 = (set2Y1 - tr1Y1);</span>
<span class="fc" id="L617">            double transY2 = (set2Y2 - tr1Y2);</span>

<span class="fc" id="L619">            double transX = 0.5 * (transX1 + transX2);</span>

<span class="fc" id="L621">            double transY = 0.5 * (transY1 + transY2);</span>
            
<span class="fc" id="L623">            float pairWeight = pairWeights.get(pairIndex).floatValue();</span>
<span class="fc" id="L624">            scaleAvg += (scale * pairWeight);</span>
<span class="fc" id="L625">            transXAvg += (transX * pairWeight);</span>
<span class="fc" id="L626">            transYAvg += (transY * pairWeight);</span>
            
<span class="fc" id="L628">            thetas.add(Double.valueOf(theta));</span>
<span class="fc" id="L629">            thetasWeights.add(Float.valueOf(pairWeight));</span>
            
<span class="fc" id="L631">            scales.add((float)scale);</span>
<span class="fc" id="L632">            transXs.add((float)transX);</span>
<span class="fc" id="L633">            transYs.add((float)transY);</span>
<span class="fc" id="L634">        }</span>
                
<span class="fc" id="L636">        List&lt;Double&gt; thetaCorr = new ArrayList&lt;Double&gt;(thetas);        </span>
<span class="fc" id="L637">        double[] quadrantCorrectedTheta = new double[2];</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (int i = 0; i &lt; (thetaCorr.size() - 1); ++i) {</span>
<span class="fc" id="L639">            AngleUtil.calcAngleAddition(thetaCorr.get(i), thetaCorr.get(i + 1), true, </span>
                quadrantCorrectedTheta);
<span class="fc" id="L641">            thetaCorr.set(i, quadrantCorrectedTheta[0]);</span>
<span class="fc" id="L642">            thetaCorr.set(i + 1, quadrantCorrectedTheta[1]);</span>
        }
        
<span class="fc" id="L645">        double thetaAvg = 0;</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">        for (int i = 0; i &lt; thetaCorr.size(); ++i) {</span>
<span class="fc" id="L647">            thetaAvg += thetaCorr.get(i) * thetasWeights.get(i);</span>
        }      
        
        // ----- determine standard deviations ----
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (outputScaleRotTransXYStDev != null) {</span>
<span class="fc" id="L652">            double scaleSum = 0;</span>
<span class="fc" id="L653">            double thetaSum = 0;</span>
<span class="fc" id="L654">            double transXSum = 0;</span>
<span class="fc" id="L655">            double transYSum = 0;</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">            for (int i = 0; i &lt; scales.size(); ++i) {</span>
<span class="fc" id="L657">                double diff = scales.get(i) - scaleAvg;</span>
<span class="fc" id="L658">                scaleSum += (diff * diff);</span>
                
<span class="fc" id="L660">                diff = thetaCorr.get(i) - thetaAvg;</span>
<span class="fc" id="L661">                thetaSum += (diff * diff);</span>
                
<span class="fc" id="L663">                diff = transXs.get(i) - transXAvg;</span>
<span class="fc" id="L664">                transXSum += (diff * diff);</span>
                
<span class="fc" id="L666">                diff = transYs.get(i) - transYAvg;</span>
<span class="fc" id="L667">                transYSum += (diff * diff);</span>
            }
<span class="fc" id="L669">            double scaleStDv = Math.sqrt(scaleSum/((double)scales.size() - 1.));</span>
<span class="fc" id="L670">            double thetaStDv = Math.sqrt(thetaSum/((double)scales.size() - 1.));</span>
<span class="fc" id="L671">            double transXStDv = Math.sqrt(transXSum/((double)scales.size() - 1.));</span>
<span class="fc" id="L672">            double transYStDv = Math.sqrt(transYSum/((double)scales.size() - 1.));</span>
            
<span class="fc" id="L674">            outputScaleRotTransXYStDev[0] = (float)scaleStDv;</span>
<span class="fc" id="L675">            outputScaleRotTransXYStDev[1] = (float)thetaStDv;</span>
<span class="fc" id="L676">            outputScaleRotTransXYStDev[2] = (float)transXStDv;</span>
<span class="fc" id="L677">            outputScaleRotTransXYStDev[3] = (float)transYStDv;</span>
        }
                
<span class="fc" id="L680">        TransformationParameters params = new TransformationParameters();</span>
<span class="fc" id="L681">        params.setRotationInRadians((float)thetaAvg);</span>
<span class="fc" id="L682">        params.setScale((float)scaleAvg);</span>
<span class="fc" id="L683">        params.setTranslationX((float)transXAvg);</span>
<span class="fc" id="L684">        params.setTranslationY((float)transYAvg);</span>
<span class="fc" id="L685">        params.setOriginX((float)centroidX1);</span>
<span class="fc" id="L686">        params.setOriginY((float)centroidY1);</span>
     
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L689">            log.info(&quot;params: &quot; + params.toString());</span>
        }

<span class="fc" id="L692">        return params;</span>
    }

    /**
     * from a set of transformation parameters params that transform
     * points in reference frame 1 into reference frame 2, create
     * a transformation that can transform points in reference frame 2
     * into reference frame 1.
     * @param params transformation parameters to apply to points in reference
     * frame 1 to put them in reference frame 2
     * @return transformation parameters that can transform points in reference
     * frame 2 into reference frame 1
     */
    TransformationParameters swapReferenceFrames(TransformationParameters
        params) {

<span class="pc bpc" id="L708" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L709">            throw new IllegalArgumentException(&quot;params cannot be null&quot;);</span>
        }

        /*
        xr_0 = xc*scale + (((x0-xc)*scale*math.cos(theta)) + ((y0-yc)*scale*math.sin(theta)))

        xt_0 = xr_0 + transX = x1

        yr_0 = yc*scale + (-((x0-xc)*scale*math.sin(theta)) + ((y0-yc)*scale*math.cos(theta)))

        yt_0 = yr_0 + transY = y1
        */

<span class="fc" id="L722">        double revRot = -1 * params.getRotationInRadians();</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        if (revRot &lt; 0) {</span>
<span class="fc" id="L724">            revRot += 2. * Math.PI;</span>
        }
<span class="fc" id="L726">        double revScale = 1. / params.getScale();</span>

<span class="fc" id="L728">        double transformedXC =</span>
<span class="fc" id="L729">            (params.getOriginX()*params.getScale()) + params.getTranslationX();</span>

<span class="fc" id="L731">        double transformedYC =</span>
<span class="fc" id="L732">            (params.getOriginY()*params.getScale()) + params.getTranslationY();</span>

<span class="fc" id="L734">        TransformationParameters paramsRev = new TransformationParameters();</span>
<span class="fc" id="L735">        paramsRev.setScale((float)revScale);</span>
<span class="fc" id="L736">        paramsRev.setRotationInRadians((float)revRot);</span>
<span class="fc" id="L737">        paramsRev.setTranslationX(0);</span>
<span class="fc" id="L738">        paramsRev.setTranslationY(0);</span>
<span class="fc" id="L739">        paramsRev.setOriginX((float)transformedXC);</span>
<span class="fc" id="L740">        paramsRev.setOriginY((float)transformedYC);</span>

        // transform the new origin, then the new translation is what is needed for it to equal the params origin
<span class="fc" id="L743">        Transformer transformer = new Transformer();</span>

<span class="fc" id="L745">        double[] revTransformedXYOrigin = transformer.applyTransformation(</span>
            paramsRev, transformedXC, transformedYC);

<span class="fc" id="L748">        double revTransX = params.getOriginX() - revTransformedXYOrigin[0];</span>
<span class="fc" id="L749">        double revTransY = params.getOriginY() - revTransformedXYOrigin[1];</span>

<span class="fc" id="L751">        paramsRev.setTranslationX((float)revTransX);</span>
<span class="fc" id="L752">        paramsRev.setTranslationY((float)revTransY);</span>

<span class="fc" id="L754">        return paramsRev;</span>
    }
    
    public boolean areSimilarByScaleAndRotation(TransformationParameters
        params1, TransformationParameters params2) {
        
<span class="fc" id="L760">        float scale = params1.getScale();</span>
<span class="fc" id="L761">        float rotation = params1.getRotationInDegrees();</span>

<span class="fc" id="L763">        float scale2 = params2.getScale();</span>
<span class="fc" id="L764">        float rotation2 = params2.getRotationInDegrees();</span>

        // scale similar within 10%?
<span class="fc" id="L767">        float scaleAvg = (scale + scale2) / 2.f;</span>
<span class="fc" id="L768">        float scaleTol = 0.1f * scaleAvg;</span>

<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (Math.abs(scale - scaleAvg) &gt; scaleTol) {</span>
<span class="fc" id="L771">            return false;</span>
        }
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">        if (Math.abs(scale2 - scaleAvg) &gt; scaleTol) {</span>
<span class="nc" id="L774">            return false;</span>
        }

<span class="fc" id="L777">        float diffR = AngleUtil.getAngleDifference(rotation, rotation2);</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">        if (Math.abs(diffR) &gt; 20) {</span>
<span class="fc" id="L779">            return false;</span>
        }
        
<span class="fc" id="L782">        return true;</span>
    }
    
    public Map&lt;Integer, Set&lt;Integer&gt;&gt; findSimilarByScaleAndRotation(
        List&lt;TransformationParameters&gt; params) {
        
<span class="fc" id="L788">        Map&lt;Integer, Set&lt;Integer&gt;&gt; sMap = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
        
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">        if (params.isEmpty()) {</span>
<span class="nc" id="L791">            return sMap;</span>
        }
        
<span class="fc bfc" id="L794" title="All 2 branches covered.">        for (int i = 0; i &lt; params.size(); ++i) {</span>
            
<span class="fc" id="L796">            TransformationParameters param = params.get(i);</span>
                       
<span class="fc" id="L798">            Set&lt;Integer&gt; sim = null;</span>
            
<span class="fc bfc" id="L800" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; params.size(); ++j) {</span>
                
<span class="fc" id="L802">                TransformationParameters param2 = params.get(j);</span>
                
<span class="fc bfc" id="L804" title="All 2 branches covered.">                if (!areSimilarByScaleAndRotation(param, param2)) {</span>
<span class="fc" id="L805">                    continue;</span>
                }
                
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">                if ((param.getOriginX() != param2.getOriginX() )</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">                    || (param.getOriginY() != param2.getOriginY())) {</span>

<span class="nc" id="L811">                    throw new IllegalArgumentException(</span>
                    &quot;params must all be with respect to same origin (x,y)&quot;);
                }
        
<span class="fc bfc" id="L815" title="All 2 branches covered.">                if (sim == null) {</span>
<span class="fc" id="L816">                    sim = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L817">                    sim.add(Integer.valueOf(i));</span>
                }
<span class="fc" id="L819">                sim.add(Integer.valueOf(j));</span>
            }
            
<span class="fc bfc" id="L822" title="All 2 branches covered.">            if (sim != null) {</span>
<span class="fc" id="L823">                sMap.put(Integer.valueOf(i), sim);</span>
            }
        }
        
        // remove similar solutions
<span class="fc bfc" id="L828" title="All 2 branches covered.">        for (int i = 0; i &lt; params.size(); ++i) {</span>
            
<span class="fc" id="L830">            Integer key = Integer.valueOf(i);</span>
<span class="fc" id="L831">            Set&lt;Integer&gt; sim = sMap.get(key);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            if (sim == null) {</span>
<span class="fc" id="L833">                continue;</span>
            }
            
<span class="fc bfc" id="L836" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; params.size(); ++j) {</span>
<span class="fc" id="L837">                Integer key2 = Integer.valueOf(j);</span>
<span class="fc" id="L838">                Set&lt;Integer&gt; sim2 = sMap.get(key2);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">                if (sim2 == null) {</span>
<span class="fc" id="L840">                    continue;</span>
                }
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">                if (sim.equals(sim2)) {</span>
<span class="nc" id="L843">                    sMap.remove(key2);</span>
                }
            }
        }
        
<span class="fc" id="L848">        return sMap;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
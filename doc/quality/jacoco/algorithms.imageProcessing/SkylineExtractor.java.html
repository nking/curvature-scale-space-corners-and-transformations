<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SkylineExtractor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">SkylineExtractor.java</span></div><h1>SkylineExtractor.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.CountingSort;
import algorithms.MultiArrayMergeSort;
import algorithms.compGeometry.EllipseHelper;
import algorithms.compGeometry.PerimeterFinder;
import algorithms.compGeometry.PointInPolygon;
import algorithms.imageProcessing.optimization.ANDedClauses;
import algorithms.imageProcessing.optimization.ColorData;
import algorithms.imageProcessing.optimization.SKYCONDITIONAL;
import algorithms.imageProcessing.optimization.SkylineANDedClauses;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Histogram;
import algorithms.misc.HistogramHolder;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.ArrayPair;
import algorithms.util.Errors;
import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.PolygonAndPointPlotter;
import algorithms.util.ResourceFinder;
import algorithms.util.ScatterPointPlotterPNG;
import java.awt.Color;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.logging.Logger;

/**
 * class to find the sky points in an image.  TODO: there needs
 * to be another class that is usable to combine information (sky masks) from
 * multiple images that are registered (aligned) in order to better define 
 * the skyline when there are optically thick clouds for instance.
 * 
 * @author nichole
 */
<span class="fc" id="L40">public class SkylineExtractor {</span>

<span class="fc" id="L42">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L44">    private boolean useAlternateSkySeeds = false;</span>
    
<span class="fc" id="L46">    private SunFinder sunFinder = null;</span>
<span class="fc" id="L47">    private RainbowFinder rainbowFinder = null;</span>
    
<span class="fc" id="L49">    private List&lt;PairIntArray&gt; skylineEdges = null;</span>
    
<span class="fc" id="L51">    public static String debugName = &quot;&quot;;</span>
    public static void setDebugName(String name) {
<span class="fc" id="L53">        debugName = name;</span>
<span class="fc" id="L54">    }</span>
    
    /**
     * NOT YET USABLE.  This method is a placeholder for a flag that can
     * be used to better select the sky location, perhaps by user
     * interaction with UI.
     */
    public void doUseAlternateSkySelection() {
        
<span class="nc" id="L63">        useAlternateSkySeeds = true;</span>
        
<span class="nc" id="L65">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    /**
     * using the edge filter products and color and contrast rules, find the
     * sky pixels in the image and extract the skyline from them.
     * 
     * @param theta
     * @param gradientXY
     * @param originalImage
     * @param outputSkyCentroid container to hold the output centroid of 
     * the sky.
     * @param edgeSettings
     * @return
     * @throws IOException
     * @throws NoSuchAlgorithmException 
     */
    public ImageExt createSkyMaskedImage(GreyscaleImage theta, 
        GreyscaleImage gradientXY, ImageExt originalImage,
        CannyEdgeFilterSettings edgeSettings) throws IOException, 
        NoSuchAlgorithmException {        
      
<span class="fc" id="L87">        PairIntArray outputSkyCentroid = new PairIntArray();</span>
        
<span class="fc" id="L89">        GreyscaleImage mask = createBestSkyMask(theta, gradientXY, originalImage, </span>
            edgeSettings, outputSkyCentroid);
       
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (mask == null) {</span>
<span class="nc" id="L93">            return null;</span>
        }
        
<span class="fc" id="L96">        ImageExt output = (ImageExt) originalImage.copyImage();</span>
        
<span class="fc" id="L98">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
<span class="fc" id="L100">        imageProcessor.multiplyBinary(output, mask);</span>
        
<span class="fc" id="L102">        return output;</span>
    }
    
     /**
     * using the edge filter products and color and contrast rules, find the
     * sky pixels in the image and extract the skyline from them.
     * 
     * @param theta
     * @param gradientXY
     * @param originalImage
     * @param outputSkyCentroid container to hold the output centroid of 
     * the sky.
     * @param edgeSettings
     * @return
     * @throws IOException
     * @throws NoSuchAlgorithmException 
     */
    public GreyscaleImage createSkyline(GreyscaleImage theta, 
        GreyscaleImage gradientXY, ImageExt originalImage,
        CannyEdgeFilterSettings edgeSettings, PairIntArray outputSkyCentroid) 
        throws IOException, NoSuchAlgorithmException {        
      
<span class="fc" id="L124">        GreyscaleImage mask = createBestSkyMask(theta, gradientXY, originalImage, </span>
            edgeSettings, outputSkyCentroid);
        
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (mask != null) {</span>
            
            // TODO: NOTE, could just find the border pixels of the mask's sky 
            // points which are done already within createBestSkyMask
            // instead of running the mask through the CannyEdgeFilter

<span class="fc" id="L133">            ImageProcessor imageProcessor = new ImageProcessor();</span>
            
<span class="fc" id="L135">            mask.multiply(255);</span>
            
<span class="fc" id="L137">            CannyEdgeFilter filter = new CannyEdgeFilter();</span>
            
<span class="fc" id="L139">            filter.setFilterImageTrim(theta.getXRelativeOffset(), </span>
<span class="fc" id="L140">                theta.getYRelativeOffset(), theta.getWidth(), </span>
<span class="fc" id="L141">                theta.getHeight());</span>
            
<span class="fc" id="L143">            filter.applyFilter(mask);</span>
            
<span class="fc" id="L145">            return mask;</span>
        }
        
<span class="nc" id="L148">        return null;</span>
    }
    
    protected int determineBinFactorForSkyMask(int numberOfThetaPixels) {
        
        //TODO: this can be adjusted by the jvm settings for stack size
<span class="fc" id="L154">        int defaultLimit = 87000;</span>
        
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (numberOfThetaPixels &lt;= defaultLimit) {</span>
<span class="nc" id="L157">            return 1;</span>
        }
                    
<span class="fc" id="L160">        double a = (double)numberOfThetaPixels/87000.;</span>
        // rounds down
<span class="fc" id="L162">        int f2 = (int)a/2;</span>
<span class="fc" id="L163">        int binFactor = f2 * 2;</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if ((a - binFactor) &gt; 0) {</span>
<span class="fc" id="L165">            binFactor += 2;</span>
        }
            
<span class="fc" id="L168">        return binFactor;</span>
    }
    
    /**
     * NOT READY FOR USE
     * 
     * create a mask for what is interpreted as sky in the image and return
     * a mask with 0's for sky and 1's for non-sky.
     * 
     * Internally, the method looks at contiguous regions of zero value pixels 
     * in the theta image and it looks at color in the original image.  
     * The camera image plane can have a rotation such that the 
     * horizon might not be along rows in the image, that is the method
     * looks for sky that is not necessarily at the top of the image, but 
     * should be on the boundary of the image
     * (note that reflection of sky can be found the same way, but this
     * method does not try to find sky that is not on the boundary of the
     * image).
     * (the &quot;boundary&quot; logic may change, in progress...)
     * 
     * Note that if the image contains a silhouette of featureless
     * foreground and a sky full of clouds, the method will interpret the
     * foreground as sky so it is up to the invoker to invert the mask.
     * 
     * NOTE: the cloud finding logic will currently fail if originalColorImage
     * is black and white.
     * 
     * @param theta
     * @param gradientXY
     * @param originalColorImage
     * @param edgeSettings
     * @param outputSkyCentroid container to hold the output centroid of 
     * the sky.
     * @return 
     * @throws java.io.IOException 
     * @throws java.security.NoSuchAlgorithmException 
     */
    public GreyscaleImage createBestSkyMask(final GreyscaleImage theta,
        GreyscaleImage gradientXY, ImageExt originalColorImage, 
        CannyEdgeFilterSettings edgeSettings, PairIntArray outputSkyCentroid) 
        throws IOException, NoSuchAlgorithmException {
        
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (theta == null) {</span>
<span class="nc" id="L211">            throw new IllegalArgumentException(&quot;theta cannot be null&quot;);</span>
        }
       
<span class="fc" id="L214">        RemovedSets removedSets = new RemovedSets();</span>
                
        //TODO: a placeholder for an alternate method to determine seed sky
        // points has been made but not implemented and that's presumably
        // needed for complex cases, such as smooth foreground which
        // has sky colors and a sky that has alot of cloud structure.
        // This method should allow user to see first guess at sky if in
        // interactive mode then allow them to select.
<span class="fc" id="L222">        Set&lt;PairInt&gt; points = extractSkyStarterPoints(theta, gradientXY, </span>
            originalColorImage, edgeSettings, outputSkyCentroid,
            removedSets);

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (points.isEmpty()) {</span>
            
<span class="nc" id="L228">            GreyscaleImage mask = theta.createWithDimensions();</span>
               
            // return an image of all 1's
<span class="nc" id="L231">            mask.fill(1);</span>
            
<span class="nc" id="L233">            return mask;</span>
        }
        
<span class="fc" id="L236">        int xOffset = theta.getXRelativeOffset();</span>
<span class="fc" id="L237">        int yOffset = theta.getYRelativeOffset();</span>
      
<span class="fc" id="L239">        GroupPixelColors allSkyColor = new GroupPixelColors(points,</span>
            originalColorImage, xOffset, yOffset);
        
<span class="fc" id="L242">        boolean skyIsDarkGrey = skyIsDarkGrey(allSkyColor);</span>
        
<span class="fc" id="L244">        log.info(&quot;skyIsDarkGrey=&quot; + skyIsDarkGrey + &quot; &quot; + debugName);</span>
        
<span class="fc" id="L246">        sunFinder = new SunFinder();</span>
<span class="fc" id="L247">        sunFinder.findSunPhotosphere(originalColorImage, xOffset, yOffset, </span>
            skyIsDarkGrey);
        
<span class="fc" id="L250">        log.info(sunFinder.toString());</span>

<span class="fc" id="L252">        rainbowFinder = new RainbowFinder();</span>
        
        // should not see sun and rainbow in same image
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (sunFinder.getSunPoints().isEmpty()) {</span>
                        
<span class="fc" id="L257">            rainbowFinder.findRainbowInImage(</span>
                points, 
<span class="fc" id="L259">                removedSets.getReflectedSunRemoved(), originalColorImage, </span>
<span class="fc" id="L260">                xOffset, yOffset, theta.getWidth(), theta.getHeight(),</span>
                skyIsDarkGrey, allSkyColor, removedSets);
            
<span class="fc" id="L263">            log.info(rainbowFinder.toString());</span>
        }
                
<span class="fc" id="L266">        int nSkyPointsBeforeFindClouds = points.size();</span>
        
<span class="fc" id="L268">        findClouds(points, rainbowFinder.getPointsToExcludeInHull(), </span>
            originalColorImage, theta);

<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (!rainbowFinder.getPointsToExcludeInHull().isEmpty()) {</span>
            // addRainbow to Hull, but only if there are sky points adjacent to hull
<span class="fc" id="L273">            rainbowFinder.addRainbowToSkyPoints(points,</span>
<span class="fc" id="L274">                theta.getWidth() - 1, theta.getHeight() - 1);</span>
        }
             
<span class="fc" id="L277">        addEmbeddedIfSimilarToSky(points, originalColorImage, </span>
            xOffset, yOffset, removedSets);

<span class="fc" id="L280">        Set&lt;PairInt&gt; exclude = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L281">        exclude.addAll(removedSets.getHighContrastRemoved());</span>
<span class="fc" id="L282">        exclude.addAll(sunFinder.getSunPoints());</span>

        // look for patches of sky that are not yet found and are on the image
        // boundaries
<span class="fc" id="L286">        int nAdded = addImageBoundaryEmbeddedSkyIfSimilar(points, exclude, </span>
            originalColorImage, xOffset, yOffset, removedSets, 
<span class="fc bfc" id="L288" title="All 2 branches covered.">            !sunFinder.getSunPoints().isEmpty());</span>
        
<span class="fc" id="L290">        log.info(&quot;number of sunPoints=&quot; + sunFinder.getSunPoints().size() + &quot; &quot;</span>
<span class="fc" id="L291">        + &quot;reflectedSunRemoved.size()=&quot; + removedSets.getReflectedSunRemoved().size());</span>

<span class="fc" id="L293">        boolean addEmbedded = false;</span>
        
        //if (sunPoints.isEmpty()) {
        
<span class="fc" id="L297">            growForLowContrastLimits(points, exclude, originalColorImage,</span>
                xOffset, yOffset, 
<span class="fc" id="L299">                determineBinFactorForSkyMask(theta.getNPixels()));</span>

<span class="fc" id="L301">            addEmbedded = true;</span>

        //}

<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (!sunFinder.getSunPoints().isEmpty()) {</span>
            
<span class="fc" id="L307">            sunFinder.correctSkylineForSun(points, originalColorImage, xOffset, </span>
                yOffset, gradientXY);
            
<span class="fc" id="L310">            addEmbedded = true;</span>
        }
        
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (addEmbedded) {</span>
<span class="fc" id="L314">            addEmbeddedIfSimilarToSky(points, originalColorImage, </span>
                xOffset, yOffset, removedSets);
        }
                
<span class="fc" id="L318">        points.addAll(sunFinder.getSunPoints());</span>
        
<span class="fc" id="L320">        this.skylineEdges = extractAndSmoothSkylinePoints(points, gradientXY);</span>
        
<span class="fc" id="L322">debugPlot(points, originalColorImage, theta.getXRelativeOffset(), theta.getYRelativeOffset(), </span>
&quot;final&quot;);

<span class="fc" id="L325">        GreyscaleImage mask = gradientXY.createWithDimensions();</span>
<span class="fc" id="L326">        mask.fill(1);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L328">            int x = p.getX();</span>
<span class="fc" id="L329">            int y = p.getY(); </span>
<span class="fc" id="L330">            mask.setValue(x, y, 0);</span>
<span class="fc" id="L331">        }</span>
        
<span class="fc" id="L333">        log.info(&quot;number of sky points=&quot; + points.size());</span>
        
<span class="fc" id="L335">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();        </span>
<span class="fc" id="L336">        double[] xycen = curveHelper.calculateXYCentroids(points);</span>
<span class="fc" id="L337">        outputSkyCentroid.add((int)Math.round(xycen[0]), (int)Math.round(xycen[1]));</span>

<span class="fc" id="L339">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L340">        imageProcessor.removeSpurs(mask);</span>
   
<span class="fc" id="L342">        return mask;</span>
    }
    
    /**
     * extract starter points for sky from the theta image and further filtering
     * color and contrast and the gradientXY image.
     * @param theta
     * @param gradientXY
     * @param originalColorImage
     * @param edgeSettings
     * @param outputSkyCentroid
     * @param removedSets
     * @return 
     */
    public Set&lt;PairInt&gt; extractSkyStarterPoints(final GreyscaleImage theta,
        GreyscaleImage gradientXY, ImageExt originalColorImage, 
        CannyEdgeFilterSettings edgeSettings, PairIntArray outputSkyCentroid,
        RemovedSets removedSets) {
        
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (theta == null) {</span>
<span class="nc" id="L362">            throw new IllegalArgumentException(&quot;theta cannot be null&quot;);</span>
        }
        
<span class="fc" id="L365">        int binFactor = determineBinFactorForSkyMask(theta.getNPixels());</span>

<span class="fc" id="L367">        log.info(&quot;binFactor=&quot; + binFactor);</span>
        
        /*TODO:  
        adjust this algorithm to allow alternate ways of determining the seed 
        sky points (and excluded points that should not be re-added).  
        Example case where this is needed here:
            an image with a foreground large smooth snow field and dark mountain 
            ranges under a cloudy structured sky.
            The edge detector w/o changes would probably find the mountain 
            ranges best in this case, but one would still not know &quot;sky&quot; without
            GPS or external sensors or assumption of horizontal.
            **The sunâ€™s position however is learnable from some images and 
            that would help determine the location of seed sky points correctly.
            **The scattered and reflected light from the sun and water might be 
            hard to distinguish. 
            Will look for a pattern in solar light as a function of distance
            along the increasing brightness axis.
            Note that when the sun is near the horizon, the light reaching the
            camera has been scattered less and so one might be able to make 
            a simple model of scattering of solar light off of
            optically thick water w/ consideration for mie and rayleigh 
            scattering in the atmosphere altering the received source light.
        */
       
<span class="fc" id="L391">        Set&lt;PairInt&gt; points = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L393">        GreyscaleImage threshholdedGXY = filterAndExtractSkyFromGradient(</span>
            originalColorImage, theta, gradientXY, binFactor, points,
            removedSets);
        
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (threshholdedGXY == null) {</span>
            
<span class="nc" id="L399">            return new HashSet&lt;PairInt&gt;();</span>
        }
        
        //now the coordinates in zeroPointLists are w.r.t. thetaImg

<span class="fc" id="L404">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>
<span class="fc" id="L405">        int[] skyRowMinMax = new int[2];</span>
<span class="fc" id="L406">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L407">        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRange = perimeterFinder.find(points, </span>
<span class="fc" id="L408">            skyRowMinMax, originalColorImage.getWidth(), outputEmbeddedGapPoints);</span>
        
<span class="fc" id="L410">        rightAndLowerDownSizingSkyPointCorrections(points, binFactor, </span>
            skyRowColRange, skyRowMinMax, originalColorImage,
<span class="fc" id="L412">            theta.getWidth(), theta.getHeight(),</span>
<span class="fc" id="L413">            theta.getXRelativeOffset(), theta.getYRelativeOffset());</span>

<span class="fc" id="L415">debugPlot(points, originalColorImage, theta.getXRelativeOffset(), theta.getYRelativeOffset(), </span>
&quot;after_downsize_corrections_2&quot;);
           
<span class="fc" id="L418">        populatePixelExtColors(points, originalColorImage, theta);</span>
        
<span class="fc" id="L420">        return points;</span>
    }
    
    public Set&lt;PairInt&gt; combine(List&lt;PairIntArray&gt; points) {
<span class="nc" id="L424">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L425">        combine(points, set);</span>
<span class="nc" id="L426">        return set;</span>
    }
    public void combine(List&lt;PairIntArray&gt; points, Set&lt;PairInt&gt; outputCombined) {
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (PairIntArray p : points) {</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">            for (int i = 0; i &lt; p.getN(); i++) {</span>
<span class="fc" id="L431">                int x = p.getX(i);</span>
<span class="fc" id="L432">                int y = p.getY(i);</span>
<span class="fc" id="L433">                PairInt pi = new PairInt(x, y);</span>
<span class="fc" id="L434">                outputCombined.add(pi);</span>
            }
<span class="fc" id="L436">        }</span>
<span class="fc" id="L437">    }</span>
    
    public List&lt;PairIntArray&gt; getLargestSortedContiguousZeros(GreyscaleImage theta) {
                 
<span class="nc" id="L441">        return getSortedContiguousValues(theta, 0, false, true);</span>
    }
    
    public List&lt;PairIntArray&gt; getSortedContiguousZeros(GreyscaleImage theta) {
                 
<span class="fc" id="L446">        return getSortedContiguousValues(theta, 0, false, false);</span>
    }
    
    public List&lt;PairIntArray&gt; getLargestSortedContiguousNonZeros(GreyscaleImage theta) {
                 
<span class="nc" id="L451">        return getSortedContiguousValues(theta, 0, true, true);</span>
    }
    
    private List&lt;PairIntArray&gt; getSortedContiguousValues(GreyscaleImage theta,
        int value, boolean excludeValue, boolean limitToLargest) {
        
<span class="fc" id="L457">        DFSContiguousValueFinder zerosFinder = new DFSContiguousValueFinder(theta);</span>
        
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (excludeValue) {</span>
<span class="nc" id="L460">            zerosFinder.findGroupsNotThisValue(value);</span>
        } else {
<span class="fc" id="L462">            zerosFinder.findGroups(value);</span>
        }
        
<span class="fc" id="L465">        int nGroups = zerosFinder.getNumberOfGroups();</span>
        
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (nGroups == 0) {</span>
<span class="nc" id="L468">            return new ArrayList&lt;PairIntArray&gt;();</span>
        }
        // ====== find the group(s) with the largest number of zero pixels =====
        
<span class="fc" id="L472">        int nMaxGroupN = Integer.MIN_VALUE;</span>
<span class="fc" id="L473">        int[] groupIndexes = new int[nGroups];</span>
<span class="fc" id="L474">        int[] groupN = new int[nGroups];</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (int gId = 0; gId &lt; nGroups; gId++) {</span>
<span class="fc" id="L476">            int n = zerosFinder.getNumberofGroupMembers(gId);</span>
<span class="fc" id="L477">            groupIndexes[gId] = gId;</span>
<span class="fc" id="L478">            groupN[gId] = n;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">            if (n &gt; nMaxGroupN) {</span>
<span class="fc" id="L480">                nMaxGroupN = n;</span>
            }
        }
        
<span class="fc" id="L484">        int maxValue = MiscMath.findMax(groupN);</span>
<span class="pc bpc" id="L485" title="3 of 4 branches missed.">        if ((maxValue &gt; groupN.length) || (nMaxGroupN &gt; 10000000)) {</span>
<span class="fc" id="L486">            MultiArrayMergeSort.sortByDecr(groupN, groupIndexes);</span>
        } else {
<span class="nc" id="L488">            CountingSort.sortByDecr(groupN, groupIndexes, maxValue);</span>
        }
        
<span class="fc" id="L491">        List&lt;Integer&gt; groupIds = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L492">        groupIds.add(Integer.valueOf(groupIndexes[0]));</span>
        
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (nGroups &gt; 1) {</span>
                        
<span class="fc" id="L496">            float n0 = (float)groupN[0];</span>
            
<span class="fc bfc" id="L498" title="All 2 branches covered.">            for (int i = 1; i &lt; groupN.length; i++) {</span>
                
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                if (limitToLargest) {</span>
<span class="nc" id="L501">                    float number = groupN[i];</span>

<span class="nc" id="L503">                    float frac = number/n0;</span>
                    //TODO: this should be adjusted by some metric.
                    //      a histogram?
                    // since most images should have been binned to &lt;= 300 x 300 pix,
                    // making an assumption about a group &gt;= 100 pixels 
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    if ((1 - frac) &lt; 0.4) {</span>
                    //if (number &gt; 100) {
<span class="nc" id="L510">                        groupIds.add(Integer.valueOf(groupIndexes[i]));</span>
                    } else {
                        break;
                    }
<span class="nc" id="L514">                } else {</span>
<span class="fc" id="L515">                    groupIds.add(Integer.valueOf(groupIndexes[i]));</span>
                }
            }
        }

<span class="fc" id="L520">        List&lt;PairIntArray&gt; list = new ArrayList&lt;PairIntArray&gt;();</span>
        
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (Integer gIndex : groupIds) {</span>
            
<span class="fc" id="L524">            int gIdx = gIndex.intValue();</span>
            
<span class="fc" id="L526">            PairIntArray points = zerosFinder.getXY(gIdx);</span>
            
<span class="fc" id="L528">            list.add(points);</span>
<span class="fc" id="L529">        }</span>
        
<span class="fc" id="L531">        return list;</span>
    }
    
    private void reduceToLargest(List&lt;PairIntArray&gt; zeroPointLists) {
        
<span class="fc" id="L536">        int rmIdx = -1;</span>
        
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (zeroPointLists.size() &gt; 1) {</span>
                        
<span class="fc" id="L540">            float n0 = (float)zeroPointLists.get(0).getN();</span>
            
<span class="fc bfc" id="L542" title="All 2 branches covered.">            for (int i = 1; i &lt; zeroPointLists.size(); i++) {</span>
                
<span class="fc" id="L544">                float number = zeroPointLists.get(i).getN();</span>

<span class="fc" id="L546">                float frac = number/n0;</span>
                //TODO: this should be adjusted by some metric.
                //      a histogram?
                // since most images should have been binned to &lt;= 300 x 300 pix,
                // making an assumption about a group &gt;= 100 pixels 
<span class="fc bfc" id="L551" title="All 2 branches covered.">                if (frac &lt; 0.1) {</span>
<span class="fc" id="L552">                    rmIdx = i;</span>
<span class="fc" id="L553">                    break;</span>
                }
            }
        }
        
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (rmIdx &gt; -1) {</span>
<span class="fc" id="L559">            List&lt;PairIntArray&gt; out = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">            for (int i = 0; i &lt; rmIdx; i++) {</span>
<span class="fc" id="L561">                out.add(zeroPointLists.get(i));</span>
            }
<span class="fc" id="L563">            zeroPointLists.clear();</span>
<span class="fc" id="L564">            zeroPointLists.addAll(out);</span>
        }
<span class="fc" id="L566">    }</span>
    
    /**
     * remove high contrast points from the sky points.  this helps to remove
     * points that are present due to &quot;blind spots&quot; in gradientXY on the scale
     * of the combined convolution of gaussians that created the gradientXY.
     * For example, repetitive structure like skyscraper windows are objects
     * in the color image which may be missing an outline in the gradientXY.
     * These features have higher contrast in the color image than the normal
     * sky because they are objects, not sky, so this method tries to find
     * those and remove them from the sky points.  Note that the method prefers
     * to err on the side of over subtracting because later steps can find 
     * and re-include any connected sky as long as the majority of sky points 
     * remain at the end of this method.
     * 
     * @param zeroPointLists
     * @param originalColorImage
     * @param theta
     * @param avgY
     * @param addAlongX
     * @param addAmount 
     * @param outputRemovedPoints is populated with removed points if 
     * the object is not null
     */
    private void removeHighContrastPoints(List&lt;PairIntArray&gt; 
        zeroPointLists, Image originalColorImage, GreyscaleImage theta,
        double avgY, Set&lt;PairInt&gt; outputRemovedPoints) {
        
<span class="fc" id="L594">        int xOffset = theta.getXRelativeOffset();</span>
<span class="fc" id="L595">        int yOffset = theta.getYRelativeOffset();</span>
        
        // remove points that have contrast larger than tail of histogram
<span class="fc" id="L598">        HistogramHolder h = createContrastHistogram(avgY, zeroPointLists, </span>
            originalColorImage, xOffset, yOffset);
        
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (h == null) {</span>
<span class="fc" id="L602">            return;</span>
        }

try {
<span class="fc" id="L606">    h.plotHistogram(&quot;contrast&quot;, 1);</span>
    // printed as bin/classes/points_and_polygon1.html
<span class="nc" id="L608">} catch (IOException e) {</span>
<span class="nc" id="L609">    log.severe(e.getMessage());</span>
<span class="fc" id="L610">}</span>
<span class="fc" id="L611">        List&lt;Integer&gt; strongPeaks = MiscMath.findStrongPeakIndexes(h, 0.1f);</span>
         
<span class="pc bpc" id="L613" title="2 of 4 branches missed.">        if (strongPeaks == null || strongPeaks.isEmpty()) {</span>
<span class="nc" id="L614">            return;</span>
        }
       
<span class="fc" id="L617">        int lastPeakIdx = strongPeaks.get(strongPeaks.size() - 1).intValue();</span>
        
        //TODO: this is sensitive to the histogram formation so needs a wide
        // variety of data for testing to make sure it finds the right characteristic
        
<span class="fc" id="L622">        int yPeakIdx = lastPeakIdx;</span>
<span class="fc" id="L623">        int tailXIdx = h.getXHist().length - 1;</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        if (tailXIdx &gt; yPeakIdx) {</span>
<span class="fc" id="L625">            float yPeak =  h.getYHist()[yPeakIdx];</span>
<span class="fc" id="L626">            float crit = 0.03f;</span>
<span class="fc" id="L627">            float dy = Float.MIN_VALUE;</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">            for (int i = (yPeakIdx + 1); i &lt; h.getYHist().length; i++) {</span>
                
<span class="fc" id="L630">                float f = (float)h.getYHist()[i]/yPeak;</span>
<span class="fc" id="L631">                dy = Math.abs(h.getYHist()[i] - h.getYHist()[i - 1]);</span>
                
<span class="fc" id="L633"> System.out.println(&quot;x=&quot; + h.getXHist()[i] + &quot; f=&quot; + f + &quot; dy=&quot; + dy);</span>
                
<span class="fc bfc" id="L635" title="All 2 branches covered.">                if (f &lt; crit) {</span>
<span class="fc" id="L636">                    tailXIdx = i;</span>
<span class="fc" id="L637">                    break;</span>
                }
            }
        }
        
<span class="fc" id="L642">        double[][] m = new double[3][];</span>
<span class="fc" id="L643">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="fc" id="L644">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="fc" id="L645">        m[2] = new double[]{0.439, -0.368, -0.072};</span>
        
        //remove points w/ contrast higher than the tail of the histogram
<span class="fc" id="L648">        double critContrast = h.getXHist()[tailXIdx];</span>
             
<span class="fc bfc" id="L650" title="All 2 branches covered.">        for (int gId = 0; gId &lt; zeroPointLists.size(); gId++) {</span>
                        
<span class="fc" id="L652">            PairIntArray points  = zeroPointLists.get(gId);</span>
                        
<span class="fc" id="L654">            Set&lt;PairInt&gt; pointsSet = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">            for (int i = 0; i &lt; points.getN(); i++) {</span>
<span class="fc" id="L656">                int x = points.getX(i);</span>
<span class="fc" id="L657">                int y = points.getY(i);</span>
<span class="fc" id="L658">                PairInt pi = new PairInt(x, y);</span>
<span class="fc" id="L659">                pointsSet.add(pi);</span>
            }

<span class="fc bfc" id="L662" title="All 2 branches covered.">            for (int i = 0; i &lt; points.getN(); i++) {</span>
                
<span class="fc" id="L664">                int x = points.getX(i);</span>
<span class="fc" id="L665">                int y = points.getY(i);</span>
                
<span class="fc" id="L667">                int ox = x + xOffset;</span>
<span class="fc" id="L668">                int oy = y + yOffset;</span>

<span class="pc bpc" id="L670" title="2 of 4 branches missed.">                if ((ox &lt; 0) || (ox &gt; (originalColorImage.getWidth() - 1))) {</span>
<span class="nc" id="L671">                    continue;</span>
                }
<span class="pc bpc" id="L673" title="2 of 4 branches missed.">                if ((oy &lt; 0) || (oy &gt; (originalColorImage.getHeight() - 1))) {</span>
<span class="nc" id="L674">                    continue;</span>
                }
                
<span class="fc" id="L677">                int idx = originalColorImage.getInternalIndex(ox, oy);</span>
        
<span class="fc" id="L679">                int r = originalColorImage.getR(idx);</span>
<span class="fc" id="L680">                int g = originalColorImage.getG(idx);</span>
<span class="fc" id="L681">                int b = originalColorImage.getB(idx);</span>
                
<span class="fc" id="L683">                double[] rgb = new double[]{r, g, b};</span>
                        
<span class="fc" id="L685">                double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="fc" id="L686">                yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>

<span class="fc" id="L688">                float contrast = (float)((avgY - yuv[0]) / yuv[0]);</span>
                
<span class="fc bfc" id="L690" title="All 2 branches covered.">                if (contrast &gt; critContrast) {</span>
                    
<span class="fc" id="L692">                    PairInt pi0 = new PairInt(x, y);</span>
                    
<span class="fc" id="L694">                    pointsSet.remove(pi0);</span>
                    
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">                    if (outputRemovedPoints != null) {</span>
<span class="fc" id="L697">                        outputRemovedPoints.add(pi0);                    </span>
                    }
                }
            }

<span class="pc bpc" id="L702" title="1 of 2 branches missed.">            if (pointsSet.size() != points.getN()) {</span>
<span class="fc" id="L703">                PairIntArray points2 = new PairIntArray();</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                for (PairInt pi : pointsSet) {</span>
<span class="fc" id="L705">                    points2.add(pi.getX(), pi.getY());</span>
<span class="fc" id="L706">                }</span>
<span class="fc" id="L707">                points.swapContents(points2);</span>
            }
        }
        
        // remove empty sets
<span class="fc bfc" id="L712" title="All 2 branches covered.">        for (int i = (zeroPointLists.size() - 1); i &gt; -1; i--) {</span>
<span class="fc" id="L713">            PairIntArray point = zeroPointLists.get(i);</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">            if (point.getN() == 0) {</span>
<span class="nc" id="L715">                zeroPointLists.remove(i);</span>
            }
        }
        
<span class="fc" id="L719">debugPlot(outputRemovedPoints, originalColorImage, xOffset, yOffset, &quot;filtered_out_high_contrast&quot;);</span>

<span class="fc" id="L721">    }</span>

    /**
     * If the range of contrast is large, return a contrast histogram,
     * else return null.  
     * TODO: refactor to move the logic to return null to the invoker. 
     * For now, the only use of this method is simpler if it does not
     * return a histogram when it won't be needed.  definitely should
     * be refactored...
     * 
     * @param avgY
     * @param zeroPointLists
     * @param originalColorImage
     * @param xOffset
     * @param yOffset
     * @return 
     */
    private HistogramHolder createContrastHistogram(double avgY,
        List&lt;PairIntArray&gt; zeroPointLists, Image originalColorImage,
        int xOffset, int yOffset) {
        
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (zeroPointLists.isEmpty()) {</span>
<span class="nc" id="L743">            return null;</span>
        }
        
<span class="fc" id="L746">        double[][] m = new double[3][];</span>
<span class="fc" id="L747">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="fc" id="L748">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="fc" id="L749">        m[2] = new double[]{0.439, -0.368, -0.072};</span>
                
<span class="fc" id="L751">        int nPoints = 0;</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">        for (int gId = 0; gId &lt; zeroPointLists.size(); gId++) {</span>
<span class="fc" id="L753">            nPoints += zeroPointLists.get(gId).getN();</span>
        }
        
<span class="fc" id="L756">        float[] yValues = new float[nPoints];</span>
        
<span class="fc" id="L758">        int count = 0;</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        for (int gId = 0; gId &lt; zeroPointLists.size(); gId++) {</span>
            
<span class="fc" id="L761">            PairIntArray points  = zeroPointLists.get(gId);</span>
                        
<span class="fc bfc" id="L763" title="All 2 branches covered.">            for (int i = 0; i &lt; points.getN(); i++) {</span>
                
<span class="fc" id="L765">                int x = points.getX(i);</span>
<span class="fc" id="L766">                int y = points.getY(i);</span>
         
<span class="fc" id="L768">                int ox = x + xOffset;</span>
<span class="fc" id="L769">                int oy = y + yOffset;</span>

<span class="pc bpc" id="L771" title="2 of 4 branches missed.">                if ((ox &lt; 0) || (ox &gt; (originalColorImage.getWidth() - 1))) {</span>
<span class="nc" id="L772">                    continue;</span>
                }
<span class="pc bpc" id="L774" title="2 of 4 branches missed.">                if ((oy &lt; 0) || (oy &gt; (originalColorImage.getHeight() - 1))) {</span>
<span class="nc" id="L775">                    continue;</span>
                }
                
<span class="fc" id="L778">                int idx = originalColorImage.getInternalIndex(ox, oy);</span>
        
<span class="fc" id="L780">                int r = originalColorImage.getR(idx);</span>
<span class="fc" id="L781">                int g = originalColorImage.getG(idx);</span>
<span class="fc" id="L782">                int b = originalColorImage.getB(idx);</span>
                
<span class="fc" id="L784">                double[] rgb = new double[]{r, g, b};</span>
                        
<span class="fc" id="L786">                double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="fc" id="L787">                yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>

<span class="fc" id="L789">                float contrastValue = (float)((avgY - yuv[0]) / yuv[0]);</span>
                
<span class="fc" id="L791">                yValues[count] = contrastValue;</span>
                
<span class="fc" id="L793">                count++;</span>
            }
        }
        
<span class="fc" id="L797">        float[] yErr = Errors.populateYErrorsBySqrt(yValues);</span>
<span class="fc" id="L798">        HistogramHolder h = Histogram.createSimpleHistogram(yValues, </span>
            yErr);

<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        if (h != null) {</span>
            
<span class="fc" id="L803">            int lastZeroIdx = MiscMath.findLastZeroIndex(h);</span>
            
<span class="fc" id="L805">            int nBins = h.getXHist().length;</span>
            
<span class="fc" id="L807">            int nLastZeros = nBins - lastZeroIdx;</span>
            
<span class="pc bpc" id="L809" title="1 of 4 branches missed.">            if ((nLastZeros &gt; 4) &amp;&amp; (lastZeroIdx &gt; -1)) {</span>
                
<span class="fc" id="L811">                float halfBinWidth = (h.getXHist()[1] - h.getXHist()[1]) / 2.f;</span>

<span class="fc" id="L813">                nBins = lastZeroIdx - 1;</span>
<span class="fc" id="L814">                float xMin = h.getXHist()[0] - halfBinWidth;</span>
<span class="fc" id="L815">                float xMax = h.getXHist()[lastZeroIdx - 1] + halfBinWidth;</span>

<span class="fc" id="L817">                float contrastRange = h.getXHist()[lastZeroIdx - 1]</span>
<span class="fc" id="L818">                    - h.getXHist()[0];</span>

<span class="fc bfc" id="L820" title="All 2 branches covered.">                if (contrastRange &gt; 1.5) {</span>

<span class="fc" id="L822">                    h = Histogram.calculateSturgesHistogramRemoveZeroTail(yValues, yErr);</span>
                    
<span class="pc bpc" id="L824" title="2 of 4 branches missed.">                    if ((h != null) &amp;&amp; (h.getXHist().length == 1)) {</span>
<span class="nc" id="L825">                        h = Histogram.calculateSturgesHistogram(xMin, xMax, yValues, yErr);</span>
                    }
                    
<span class="fc" id="L828">                    return h;</span>

                }
            }
        }
        
<span class="fc" id="L834">        return null;</span>
    }
    
   /**
     * using adaptive &quot;thresholding&quot; to subtract intensity levels from
     * gradientXY
     * 
     * @param gradientXY 
    * @return the threshold subtracted gradient image
     */
    public GreyscaleImage extractSkyFromGradientXY(GreyscaleImage gradientXY) {
        
<span class="fc" id="L846">        GreyscaleImage gXY2 = gradientXY.copyImage();</span>
                
        // x is pixelValue , y is number of pixels holding that value
        // last in array is for the smallest pixelValue
<span class="fc" id="L850">        PairIntArray gXYValues = Histogram.createADescendingSortByKeyArray(gXY2);</span>

<span class="fc" id="L852">        float sumF = 0;</span>
<span class="fc" id="L853">        int valueFor0Point9 = 0;</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        for (int i = (gXYValues.getN() - 1); i &gt; -1; i--) {</span>
<span class="fc" id="L855">            float f = (float)gXYValues.getY(i)/(float)gradientXY.getNPixels();</span>
<span class="fc" id="L856">            sumF += f;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">            if (sumF &gt; 0.9) {</span>
<span class="fc" id="L858">                break;</span>
            }
<span class="fc" id="L860">            valueFor0Point9 = gXYValues.getX(i);</span>
        }
/*        
float sumFrac = 0;
StringBuilder sb = new StringBuilder(&quot;gXY:\n&quot;);
for (int i = (gXYValues.getN() - 1); i &gt; -1; i--) {
int sumToHighValues = 0;
for (int ii = i; ii &gt; -1; ii--) {
    sumToHighValues += gXYValues.getY(ii);
}
float frac = (float)gXYValues.getY(i)/(float)gradientXY.getNPixels();
sumFrac += frac;
sb.append(String.format(&quot; value=%d count=%d  f=%f  sumToEnd=%d&quot;, 
gXYValues.getX(i), gXYValues.getY(i), frac, sumToHighValues));
sb.append(&quot;sumF=&quot;).append(Float.toString(sumFrac));
sb.append(&quot;\n&quot;);
}
log.info(sb.toString());
*/
<span class="fc" id="L879">        int subtract = 0;</span>
<span class="fc" id="L880">        int lastHistIdx = gXYValues.getN();</span>
        
<span class="fc" id="L882">        float c0 = (float)gXYValues.getY(gXYValues.getN() - 1)/(float)gradientXY.getNPixels();</span>
<span class="fc" id="L883">        float c1 = (float)gXYValues.getY(gXYValues.getN() - 2)/(float)gradientXY.getNPixels();</span>
        //float c01 = c1 + c0;
<span class="fc" id="L885">        float cm01 = c0 - c1;</span>
<span class="fc" id="L886">        log.info(&quot;valueFor0Point9=&quot; + valueFor0Point9 + &quot; cm01=&quot; + cm01);</span>
<span class="fc bfc" id="L887" title="All 4 branches covered.">        if ((cm01 &lt; 0.0) &amp;&amp; (valueFor0Point9 &lt;= 2)) {</span>
<span class="fc" id="L888">            subtract = 0;</span>
<span class="fc" id="L889">            lastHistIdx = gXYValues.getN();</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">        } else if (cm01 &lt; 0.3) {</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (valueFor0Point9 &lt;= 2) {</span>
<span class="fc" id="L892">                subtract = 2;</span>
<span class="fc" id="L893">                lastHistIdx = gXYValues.getN() - 2;</span>
            } /*else {
                subtract = 1;
                lastHistIdx = gXYValues.getN() - 1;
            }*/
<span class="pc bpc" id="L898" title="1 of 6 branches missed.">        } else if ((cm01 &gt;= 0.3) &amp;&amp; (cm01 &lt;= 0.45) &amp;&amp; (valueFor0Point9 &lt;= 2)) {</span>
<span class="fc" id="L899">            subtract = 1;</span>
<span class="fc" id="L900">            lastHistIdx = gXYValues.getN() - 1;</span>
        }
        
<span class="fc" id="L903">        int nIter = 0;</span>
        
<span class="fc" id="L905">        float originalMaxValue = gXYValues.getY(gXYValues.getN() - 1);</span>
          
        //TODO: the logic changed over time here to revisit this code
        // and remove iteration.
                
<span class="pc bpc" id="L910" title="1 of 4 branches missed.">        while ((subtract &lt; originalMaxValue) &amp;&amp; (nIter == 0)) {</span>
            
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">            if (nIter &gt; 0) {</span>
<span class="nc" id="L913">                gXY2 = gradientXY.copyImage();</span>
            }
            
<span class="fc" id="L916">            lastHistIdx--;</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">            if (lastHistIdx &lt; 1) {</span>
<span class="nc" id="L918">                break;</span>
            }
<span class="fc" id="L920">            subtract = gXYValues.getX(lastHistIdx);</span>

<span class="fc" id="L922">            subtractWithCorrectForNegative(gXY2, subtract);</span>
                                                               
<span class="fc" id="L924">            log.info(&quot;nIter=&quot; + nIter + &quot;)&quot; </span>
<span class="fc" id="L925">                + &quot; (level=&quot; + ((float)gXYValues.getY(lastHistIdx)/originalMaxValue) </span>
<span class="fc" id="L926">                + &quot; subtract=&quot; + subtract + &quot; out of max=&quot; + gXYValues.getX(0)</span>
                + &quot;)&quot;
            );
                  
<span class="fc" id="L930">            nIter++;</span>
        }
      
/*
try {
    Image img1 = gXY2.copyImageToGreen();
    ImageIOHelper.addToImage(skyPoints, 0, 0, img1);
    ImageDisplayer.displayImage(&quot;sky points subtract=&quot; + subtract, img1);
} catch (IOException ex) {
    log.severe(ex.getMessage());
}
*/         
<span class="fc" id="L942">        return gXY2;</span>
    }

    boolean isPerimeterUnbound(Map&lt;Integer, PairInt&gt; gRowColRange, 
        int[] gRowMinMax, Map&lt;Integer, PairInt&gt; boundingRowColRange, 
        int[] boundingRowMinMax,
        int xMinImage, int xMaxImage, int yMinImage, int yMaxImage) {
        
        // check top and bottom rows of group are within bounds
<span class="nc bnc" id="L951" title="All 2 branches missed.">        if (gRowMinMax[0] == boundingRowMinMax[0]) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (gRowMinMax[0] != yMinImage) {</span>
<span class="nc" id="L953">                return true;</span>
            }
<span class="nc bnc" id="L955" title="All 2 branches missed.">        } else if (gRowMinMax[0] &lt; boundingRowMinMax[0]) {</span>
<span class="nc" id="L956">            return true;</span>
        }
<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (gRowMinMax[1] == boundingRowMinMax[1]) {</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if (gRowMinMax[1] != yMaxImage) {</span>
<span class="nc" id="L960">                return true;</span>
            }
<span class="nc bnc" id="L962" title="All 2 branches missed.">        } else if (gRowMinMax[1] &gt; boundingRowMinMax[1]) {</span>
<span class="nc" id="L963">            return true;</span>
        }
        
<span class="nc bnc" id="L966" title="All 2 branches missed.">        for (int r = gRowMinMax[0]; r &lt;= gRowMinMax[1]; r++) {</span>
                    
<span class="nc" id="L968">            PairInt cRange = gRowColRange.get(Integer.valueOf(r));</span>
            
            // see if each point in cRange is on the boundary of rowColRange
            //   or within it
           
            // check left half            
<span class="nc" id="L974">            int x = cRange.getX();</span>
<span class="nc" id="L975">            int y = r;</span>
            
<span class="nc" id="L977">            PairInt cRange2 = boundingRowColRange.get(Integer.valueOf(y));</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">            if (cRange2 == null) {</span>
<span class="nc" id="L979">                return true;</span>
            }
<span class="nc" id="L981">            int x2 = cRange2.getX();</span>
            
<span class="nc bnc" id="L983" title="All 2 branches missed.">            if (x == x2) {</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (x &gt; xMinImage) {</span>
<span class="nc" id="L985">                    return true;</span>
                }
<span class="nc bnc" id="L987" title="All 2 branches missed.">            } else if (x &lt; x2) {</span>
                // x is outside of the larger region defined by gRowColRange
<span class="nc" id="L989">                return true;</span>
            }
            
            // check right half
<span class="nc" id="L993">            x2 = cRange2.getY();</span>
            
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (x == x2) {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                if (x &lt; xMaxImage) {</span>
<span class="nc" id="L997">                    return true;</span>
                }
<span class="nc bnc" id="L999" title="All 2 branches missed.">            } else if (x &gt; x2) {</span>
                // x is outside of the larger region defined by gRowColRange
<span class="nc" id="L1001">                return true;</span>
            }
        }
        
<span class="nc" id="L1005">        return false;</span>
    }
    
    private boolean isPerimeterUnbound(Map&lt;Integer, PairInt&gt; gRowColRange, 
        int[] gRowMinMax, Set&lt;PairInt&gt; skyPoints, double[] groupXYCen,
        int imageWidth, int imageHeight) {
        
<span class="nc" id="L1012">        boolean unbounded = false;</span>
        
<span class="nc bnc" id="L1014" title="All 2 branches missed.">        for (int r = gRowMinMax[0]; r &lt;= gRowMinMax[1]; r++) {</span>
                    
<span class="nc" id="L1016">            PairInt cRange = gRowColRange.get(Integer.valueOf(r));</span>
            
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            for (int k = 0; k &lt; 2; k++) {</span>
                int c;
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                switch(k) {</span>
                    case 0:
<span class="nc" id="L1022">                        c = cRange.getX();</span>
<span class="nc" id="L1023">                        break;</span>
                    default:
<span class="nc" id="L1025">                        c = cRange.getY();</span>
                        break;
                }
                
<span class="nc bnc" id="L1029" title="All 2 branches missed.">                if (c &lt; groupXYCen[0]) {</span>
                
                    // look for points to left
<span class="nc" id="L1032">                    int xt = c - 1;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                    if (xt &lt; 0) {</span>
                        // bounded by edge of image
<span class="nc" id="L1035">                        continue;</span>
                    }
                
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                    if (r &lt; groupXYCen[1]) {</span>
                
                        //look for points to left and top (=lower y)                            
<span class="nc" id="L1041">                        int yt = r;</span>
<span class="nc" id="L1042">                        PairInt p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                        if (!skyPoints.contains(p)) {</span>
                            // not bounded on left
<span class="nc" id="L1045">                            unbounded = true;</span>
<span class="nc" id="L1046">                            break;</span>
                        }
                        //found a sky point to the left
<span class="nc" id="L1049">                        yt--;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                        if (yt &lt; 0) {</span>
                            // bounded by edge of image
<span class="nc" id="L1052">                            continue;</span>
                        } else {
<span class="nc" id="L1054">                            p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                            if (!skyPoints.contains(p)) {</span>
                                // not bounded on left
<span class="nc" id="L1057">                                unbounded = true;</span>
<span class="nc" id="L1058">                                break;</span>
                            }
                        }
                        
<span class="nc" id="L1062">                    } else {</span>
                        
                        //look for bounding points to left, bottom (=higher y)
<span class="nc" id="L1065">                        int yt = r;</span>
<span class="nc" id="L1066">                        PairInt p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                        if (!skyPoints.contains(p)) {</span>
                            // not bounded on left
<span class="nc" id="L1069">                            unbounded = true;</span>
<span class="nc" id="L1070">                            break;</span>
                        }
<span class="nc" id="L1072">                        yt++;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                        if (yt &gt; (imageHeight - 1)) {</span>
                            // bounded by edge of image
<span class="nc" id="L1075">                            continue;</span>
                        } else {
<span class="nc" id="L1077">                            p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                            if (!skyPoints.contains(p)) {</span>
                                // not bounded on left
<span class="nc" id="L1080">                                unbounded = true;</span>
<span class="nc" id="L1081">                                break;</span>
                            }
                        }
                    }
                
<span class="nc" id="L1086">                } else {</span>

                    // look for points to the right
<span class="nc" id="L1089">                    int xt = c + 1;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">                    if (xt &gt; (imageWidth - 1)) {</span>
                        // bounded by edge of image
<span class="nc" id="L1092">                        continue;</span>
                    }
                
<span class="nc bnc" id="L1095" title="All 2 branches missed.">                    if (r &lt; groupXYCen[1]) {</span>

                        //look for bounding points to right, top (=lower y),

<span class="nc" id="L1099">                        int yt = r;</span>
<span class="nc" id="L1100">                        PairInt p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">                        if (!skyPoints.contains(p)) {</span>
                            // not bounded on left
<span class="nc" id="L1103">                            unbounded = true;</span>
<span class="nc" id="L1104">                            break;</span>
                        }
<span class="nc" id="L1106">                        yt--;</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                        if (yt &lt; 0) {</span>
                            // bounded by edge of image
<span class="nc" id="L1109">                            continue;</span>
                        } else {
<span class="nc" id="L1111">                            p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                            if (!skyPoints.contains(p)) {</span>
                                // not bounded on left
<span class="nc" id="L1114">                                unbounded = true;</span>
<span class="nc" id="L1115">                                break;</span>
                            }
                        }

<span class="nc" id="L1119">                    } else {</span>
                    
                        //look for bounding points to right, bottom (=higher y)

<span class="nc" id="L1123">                        int yt = r;</span>
<span class="nc" id="L1124">                        PairInt p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                        if (!skyPoints.contains(p)) {</span>
                            // not bounded on left
<span class="nc" id="L1127">                            unbounded = true;</span>
<span class="nc" id="L1128">                            break;</span>
                        }
<span class="nc" id="L1130">                        yt++;</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                        if (yt &gt; (imageHeight - 1)) {</span>
                            // bounded by edge of image
<span class="nc" id="L1133">                            continue;</span>
                        } else {
<span class="nc" id="L1135">                            p = new PairInt(xt, yt);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                            if (!skyPoints.contains(p)) {</span>
                                // not bounded on left
<span class="nc" id="L1138">                                unbounded = true;</span>
<span class="nc" id="L1139">                                break;</span>
                            }
                        }
                    }
                }
            }
            
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (unbounded) {</span>
<span class="nc" id="L1147">                break;</span>
            }
        }
        
<span class="nc" id="L1151">        return unbounded;</span>
    }

    /**
     * attempt to find within pixels connected to skyPoints, pixels that
     * look like sun pixels by color (hsb) and whose x,y distribution
     * resemble and ellipse (circle w/ possible occlusion).  
     * those sun points are then added to the skyPoints.
     * Note that if the sun is present in sky and in reflection, such as
     * water, their location in x, y must be fittable by an ellipse, else they 
     * may not be found as sun points.
     * @param skyPoints
     * @param reflectedSunRemoved previously removed points assumed to be
     * reflected light
     * @param clr
     * @param xOffset
     * @param yOffset 
     * @param skyIsDarkGrey 
     * @param outputYellowPoints 
     * @return ellipse fitting parameters if there are sun points
     *  [xc, yc, a, b, alpha]
     */
    protected double[] findSunConnectedToSkyPoints(Set&lt;PairInt&gt; skyPoints, 
        Set&lt;PairInt&gt; reflectedSunRemoved,
        ImageExt clr, int xOffset, int yOffset, boolean skyIsDarkGrey,
        Set&lt;PairInt&gt; outputYellowPoints) {
        
<span class="fc" id="L1178">        Set&lt;PairInt&gt; yellowPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L1180">        java.util.Stack&lt;PairInt&gt; yellowStack = new java.util.Stack&lt;PairInt&gt;();</span>
     
<span class="fc" id="L1182">        SunColors sunColors = new SunColors();</span>
        
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">        if (skyIsDarkGrey) {</span>
        
<span class="nc" id="L1186">            sunColors.useDarkSkiesLogic();</span>
        }
                
<span class="fc" id="L1189">        int width = clr.getWidth();</span>
<span class="fc" id="L1190">        int height = clr.getHeight();</span>
        
<span class="fc" id="L1192">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L1193">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>
       
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        for (PairInt p : skyPoints) {</span>

<span class="fc" id="L1197">            int x = p.getX() + xOffset;</span>
<span class="fc" id="L1198">            int y = p.getY() + yOffset;</span>
            
<span class="fc bfc" id="L1200" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; k++) {</span>
            
                // xx,yy are w.r.t full color img
<span class="fc" id="L1203">                int xx = x + dxs[k];</span>
<span class="fc" id="L1204">                int yy = y + dys[k];</span>
                
<span class="fc bfc" id="L1206" title="All 8 branches covered.">                if ((xx &lt; 0) || (xx &gt; (width - 1)) || (yy &lt; 0) || </span>
                    (yy &gt; (height - 1))) {
<span class="fc" id="L1208">                    continue;</span>
                }
            
<span class="fc" id="L1211">                PairInt p2 = new PairInt(xx - xOffset, yy - yOffset);</span>

<span class="pc bpc" id="L1213" title="1 of 4 branches missed.">                if (yellowPoints.contains(p2) || reflectedSunRemoved.contains(p2)) {</span>
<span class="nc" id="L1214">                    continue;</span>
                }
                
<span class="fc" id="L1217">                int vIdx = clr.getInternalIndex(xx, yy);</span>
                
<span class="fc bfc" id="L1219" title="All 2 branches covered.">                if (sunColors.isSunCenterColor(clr, vIdx)) {</span>
                    
<span class="fc" id="L1221">                    yellowPoints.add(p2);</span>

<span class="fc" id="L1223">                    yellowStack.add(p2);</span>
                    
                }
            }
<span class="fc" id="L1227">        }</span>
        
<span class="fc" id="L1229">        log.info(&quot;found &quot; + yellowPoints.size() + &quot; yellow points in connected search&quot;);</span>
        
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        if (yellowStack.size() &lt; 3) {</span>
<span class="fc" id="L1232">            return null;</span>
        }
        
<span class="fc" id="L1235">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1236">        visited.add(yellowStack.peek());</span>
       
<span class="fc bfc" id="L1238" title="All 2 branches covered.">        while (!yellowStack.isEmpty()) {</span>

<span class="fc" id="L1240">            PairInt uPoint = yellowStack.pop();</span>
            
<span class="fc" id="L1242">            int uX = uPoint.getX() + xOffset;</span>
<span class="fc" id="L1243">            int uY = uPoint.getY() + yOffset;</span>

            //(1 + frac)*O(N) where frac is the fraction added back to stack
            
<span class="fc bfc" id="L1247" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; k++) {</span>
                    
<span class="fc" id="L1249">                int dx = dxs[k];</span>
<span class="fc" id="L1250">                int dy = dys[k];</span>
                
<span class="fc" id="L1252">                int vX = uX + dx;</span>
<span class="fc" id="L1253">                int vY = uY + dy;</span>
                
<span class="pc bpc" id="L1255" title="4 of 8 branches missed.">                if ((vX &lt; 0) || (vX &gt; (width - 1)) || (vY &lt; 0) || </span>
                    (vY &gt; (height - 1))) {
<span class="nc" id="L1257">                    continue;</span>
                }
            
<span class="fc" id="L1260">                PairInt vPoint = new PairInt(vX - xOffset, vY - yOffset);</span>

                //TODO: consider whether sun would already be present in skyPoints 
                // and if so, a correction may be needed in invoking code
                
                // skypoints has already been check for same color criteria
                // so no need to check again here
<span class="fc bfc" id="L1267" title="All 2 branches covered.">                if (visited.contains(vPoint) || </span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">                    reflectedSunRemoved.contains(vPoint)</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">                    || yellowPoints.contains(vPoint)) {</span>
                    
<span class="fc" id="L1271">                    continue;</span>
                }

<span class="fc" id="L1274">                visited.add(vPoint);</span>

<span class="fc" id="L1276">                int vIdx = clr.getInternalIndex(vX, vY);</span>

<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">                if (sunColors.isSunCenterColor(clr, vIdx)) {</span>
                    
<span class="nc" id="L1280">                    yellowPoints.add(vPoint);</span>

<span class="nc" id="L1282">                    yellowStack.add(vPoint);</span>
                    
                }
            }
<span class="fc" id="L1286">        }</span>
        
<span class="fc" id="L1288">        log.info(&quot;found &quot; + yellowPoints.size() + &quot; points&quot;);</span>

<span class="fc bfc" id="L1290" title="All 2 branches covered.">        if (yellowPoints.size() &lt; 6) {</span>
<span class="fc" id="L1291">            return null;</span>
        }
        
        //fit ellipse to yellowPoints.  ellipse because of possible occlusion.
<span class="fc" id="L1295">        EllipseHelper ellipseHelper = new EllipseHelper();</span>
<span class="fc" id="L1296">        double[] params = ellipseHelper.fitEllipseToPoints(yellowPoints);</span>
        
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">        if (params == null) {</span>
            // not close to an ellipse
<span class="nc" id="L1300">            return null;</span>
        }
        
<span class="fc" id="L1303">        float xc = (float)params[0];</span>
<span class="fc" id="L1304">        float yc = (float)params[1];</span>
<span class="fc" id="L1305">        float a = (float)params[2];</span>
<span class="fc" id="L1306">        float b = (float)params[3];</span>
<span class="fc" id="L1307">        float alpha = (float)params[4];</span>
        
<span class="fc" id="L1309">        log.info(&quot;elliptical fit to yellow points: &quot; + Arrays.toString(params));</span>
       
        //TODO:  this may need adjustments.  top of sun rising over mountains..
        /*if ((a/b) &gt; 6) {
            return new HashSet&lt;PairInt&gt;();
        }*/
        
<span class="fc" id="L1316">        outputYellowPoints.addAll(yellowPoints);</span>
        
<span class="fc" id="L1318">        return params;</span>
    }
    
    private Map&lt;PairInt, PairFloat&gt; calculateContrastAndBOrR(
        Set&lt;PairInt&gt; points, boolean useBlue, Image originalColorImage, 
        double[] avgYRGB, int totalXOffset, int totalYOffset) {
        
<span class="nc" id="L1325">        double[][] m = new double[3][];</span>
<span class="nc" id="L1326">        m[0] = new double[]{0.256, 0.504, 0.098};</span>
<span class="nc" id="L1327">        m[1] = new double[]{-0.148, -0.291, 0.439};</span>
<span class="nc" id="L1328">        m[2] = new double[]{0.439, -0.368, -0.072};</span>
        
<span class="nc" id="L1330">        double yColor = avgYRGB[0];</span>
        
<span class="nc" id="L1332">        Map&lt;PairInt, PairFloat&gt; map = new HashMap&lt;PairInt, PairFloat&gt;();</span>
        
<span class="nc bnc" id="L1334" title="All 2 branches missed.">        for (PairInt p : points) {</span>
            
<span class="nc" id="L1336">            int x = p.getX();</span>
<span class="nc" id="L1337">            int y = p.getY();</span>
            
<span class="nc" id="L1339">            x += totalXOffset;</span>
<span class="nc" id="L1340">            y += totalYOffset;</span>
            
<span class="nc" id="L1342">            int idx = originalColorImage.getInternalIndex(x, y);</span>
        
<span class="nc" id="L1344">            int r = originalColorImage.getR(idx);</span>
<span class="nc" id="L1345">            int g = originalColorImage.getG(idx);</span>
<span class="nc" id="L1346">            int b = originalColorImage.getB(idx);</span>
                
<span class="nc" id="L1348">            double[] rgb = new double[]{r, g, b};</span>
<span class="nc" id="L1349">            double[] yuv = MatrixUtil.multiply(m, rgb);</span>
<span class="nc" id="L1350">            yuv = MatrixUtil.add(yuv, new double[]{16, 128, 128});</span>

<span class="nc" id="L1352">            float contrast= (float) ((yColor - yuv[0]) / yuv[0]);</span>
            
<span class="nc" id="L1354">            PairFloat crb = new PairFloat();</span>
<span class="nc" id="L1355">            crb.setX(contrast);</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">            if (useBlue) {</span>
<span class="nc" id="L1357">                crb.setY(b);</span>
            } else {
<span class="nc" id="L1359">                crb.setY(r);</span>
            }
            
<span class="nc" id="L1362">            map.put(p, crb);</span>
<span class="nc" id="L1363">        }</span>
        
<span class="nc" id="L1365">        return map;</span>
    }

    private void subtractWithCorrectForNegative(GreyscaleImage gXY2, int subtract) {

<span class="fc" id="L1370">        int nz = 0;</span>
        
<span class="fc bfc" id="L1372" title="All 2 branches covered.">        if (subtract &gt; 0) {</span>
            
<span class="fc bfc" id="L1374" title="All 2 branches covered.">            for (int i = 0; i &lt; gXY2.getNPixels(); i++) {</span>
<span class="fc" id="L1375">                int v = gXY2.getValue(i);</span>
<span class="fc" id="L1376">                v -= subtract;</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                if (v &lt; 0) {</span>
<span class="fc" id="L1378">                    v = 0;</span>
                }
<span class="fc" id="L1380">                gXY2.setValue(i, v);</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">                if (v == 0) {</span>
<span class="fc" id="L1382">                    nz++;</span>
                }
            }
        }

<span class="fc" id="L1387">        log.info(&quot;number of set 0's=&quot; + nz);</span>

<span class="fc" id="L1389">    }</span>

    /**
     * make downsizing corrections if any to fill in the rightmost sky points 
     * that would be missing due to down sizing
     * then the same for the lowest sky points in the image (highest y).
     * 
     * @param skyPoints
     * @param binFactor the size of the former down sizing to find sky points.
     * @param skyRowColRange the minimum row number of sky points with respect
     * to the canny edge filter product images (theta, gradientXY).
     * @param skyRowMinMax the maximum row number of sky points with respect
     * to the canny edge filter product images (theta, gradientXY).
     * @param originalColorImage the original color image
     * @param xRelativeOffset the offset in x of the canny edge filter intermediate
     * product images from the reference frame of the originalColorImage.
     * @param yRelativeOffset the offset in y of the canny edge filter intermediate
     * product images from the reference frame of the originalColorImage.
     */
    void rightAndLowerDownSizingSkyPointCorrections(Set&lt;PairInt&gt; skyPoints, 
        int binFactor, Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRange, int[] skyRowMinMax,
        Image originalColorImage, int imageWidth, int imageHeight,
        int xRelativeOffset, int yRelativeOffset) {
        
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">        if (binFactor == 1) {</span>
<span class="nc" id="L1414">            return;</span>
        }
        
        // right boundary
        
<span class="fc" id="L1419">        int lastCol = (originalColorImage.getWidth() - 1) - xRelativeOffset;</span>
        
<span class="fc bfc" id="L1421" title="All 2 branches covered.">        for (int r = skyRowMinMax[0]; r &lt;= skyRowMinMax[1]; r++) {</span>
            
<span class="fc" id="L1423">            final int row = r;</span>
<span class="fc" id="L1424">            final Integer rowIndex = Integer.valueOf(row);</span>
            
<span class="fc" id="L1426">            List&lt;PairInt&gt; cRanges = skyRowColRange.get(rowIndex);</span>
                        
<span class="fc bfc" id="L1428" title="All 2 branches covered.">            for (PairInt cRange : cRanges) {</span>
            
<span class="fc" id="L1430">                int rightCol = cRange.getY();</span>

<span class="fc bfc" id="L1432" title="All 2 branches covered.">                if (rightCol &lt; (lastCol - binFactor + 1)) {</span>
<span class="fc" id="L1433">                    continue;</span>
                }

<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">                for (int i = 1; i &lt;= binFactor; i++) {</span>

<span class="fc" id="L1438">                    int x = rightCol + i;</span>

<span class="fc bfc" id="L1440" title="All 2 branches covered.">                    if ((x + xRelativeOffset) &gt; (originalColorImage.getWidth() - 1)) {</span>
<span class="fc" id="L1441">                        break;</span>
                    }

<span class="fc" id="L1444">                    PairInt rightPoint = new PairInt(x, row);</span>

<span class="fc" id="L1446">                    skyPoints.add(rightPoint);</span>

<span class="fc" id="L1448">                    cRange.setY(x);</span>
                }
<span class="fc" id="L1450">            }            </span>
        }

        // lower boundary
<span class="fc" id="L1454">        int diff = imageHeight - skyRowMinMax[1];</span>
<span class="pc bpc" id="L1455" title="1 of 4 branches missed.">        if ((diff &lt;= binFactor) &amp;&amp; (diff &gt; 0)) {</span>
            
<span class="fc" id="L1457">            Integer rowIndex = Integer.valueOf(skyRowMinMax[1]);</span>
            
<span class="fc" id="L1459">            List&lt;PairInt&gt; cRanges = skyRowColRange.get(rowIndex);</span>
                        
<span class="fc bfc" id="L1461" title="All 2 branches covered.">            for (PairInt cRange : cRanges) {</span>
            
<span class="fc bfc" id="L1463" title="All 2 branches covered.">                for (int row = (skyRowMinMax[1] + 1); row &lt; imageHeight; row++) {</span>
                    
<span class="fc" id="L1465">                    PairInt colRange = new PairInt(cRange.getX(), cRange.getY());</span>
                    
<span class="fc" id="L1467">                    Integer key = Integer.valueOf(row);</span>
                    
                    // should be null:
<span class="fc" id="L1470">                    List&lt;PairInt&gt; cLRanges = skyRowColRange.get(key);</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">                    if (cLRanges == null) {</span>
<span class="fc" id="L1472">                        cLRanges = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L1473">                        skyRowColRange.put(key, cLRanges);</span>
                    }
<span class="fc" id="L1475">                    cLRanges.add(colRange);</span>
                    
<span class="fc bfc" id="L1477" title="All 2 branches covered.">                    for (int col = colRange.getX(); col &lt;= colRange.getY(); col++) {</span>
<span class="fc" id="L1478">                        skyPoints.add(new PairInt(col, row));</span>
                    }
                }
<span class="fc" id="L1481">            }</span>
<span class="fc" id="L1482">            skyRowMinMax[1] += diff;</span>
        }
<span class="fc" id="L1484">    }</span>
<span class="fc" id="L1485">static int outImgNum=0;</span>
    /**
     * given seed skyPoints to start from, use conservative limits on contrast
     * and color difference to add neighbors to skyPoints.  The conservative
     * limits are meant to help avoid overrunning the skyline for low
     * contrast such as a hazy sky and snow covered peaks, for example.
     * The conservative limits do not necessarily find all sky points.
     * 
     * @param skyPoints
     * @param originalColorImage
     * @param mask
     */
    void findClouds(Set&lt;PairInt&gt; skyPoints, Set&lt;PairInt&gt; excludePoints,
        ImageExt originalColorImage, GreyscaleImage thetaImg) {
        
        if (true) {
            
<span class="fc" id="L1502">            SkylineANDedClauses skylineANDedClauses = new SkylineANDedClauses();</span>
            
<span class="fc" id="L1504">            findClouds(skyPoints, excludePoints, originalColorImage, </span>
<span class="fc" id="L1505">                thetaImg, skylineANDedClauses.getAllClauses());</span>
            
<span class="fc" id="L1507">            return;</span>
        }
        
        int maskWidth = thetaImg.getWidth();
        int maskHeight = thetaImg.getHeight();
        
        ArrayDeque&lt;PairInt&gt; cloudQueue = new ArrayDeque&lt;PairInt&gt;(skyPoints.size());
        for (PairInt skyPoint : skyPoints) {
            cloudQueue.add(skyPoint);
        }
        
        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();
        visited.add(cloudQueue.peek());
              
        int xOffset = thetaImg.getXRelativeOffset();
        int yOffset = thetaImg.getYRelativeOffset();
        
        GroupPixelColors allSkyColor = new GroupPixelColors(skyPoints,
            originalColorImage, xOffset, yOffset);
        
        double rDivB = allSkyColor.getAvgRed() / allSkyColor.getAvgBlue();
        boolean skyIsRed = (rDivB &gt; 1);
       
        log.fine(&quot;==&gt; r/b=&quot; + rDivB
            + &quot; redStdev=&quot; + allSkyColor.getStdDevRed()
            + &quot; blueStDev=&quot; + allSkyColor.getStdDevBlue());
        
        CIEChromaticity cieC = new CIEChromaticity();
        PointInPolygon pInPoly = new PointInPolygon();
        
        int[] dxs = new int[]{-1,  0, 1, 0};
        int[] dys = new int[]{ 0, -1, 0, 1};
        
        while (!cloudQueue.isEmpty()) {

            PairInt uPoint = cloudQueue.poll();
                        
            int uX = uPoint.getX();
            int uY = uPoint.getY();
        
            //(1 + frac)*O(N) where frac is the fraction added back to stack
            for (int k = 0; k &lt; dxs.length; k++) {
                            
                int vX = uX + dxs[k];
                int vY = uY + dys[k];
                
                if ((vX &lt; 0) || (vX &gt; (maskWidth - 1)) || (vY &lt; 0) || 
                    (vY &gt; (maskHeight - 1))) {
                    continue;
                }
            
                PairInt vPoint = new PairInt(vX, vY);
                
                if (visited.contains(vPoint) || skyPoints.contains(vPoint) ||
                    excludePoints.contains(vPoint)) {
                    continue;
                }

                visited.add(vPoint);
                
                Set&lt;PairInt&gt; neighbors = getThe8NeighborPixelsWithin(
                    uPoint, skyPoints, maskWidth, maskHeight);             
                
                neighbors.add(uPoint);
                
                GroupPixelColors localSky = new GroupPixelColors(neighbors, 
                    originalColorImage, xOffset, yOffset);
                
                int vIdx = originalColorImage.getInternalIndex(vX + xOffset, 
                    vY + yOffset);

                int rV = originalColorImage.getR(vIdx);
                int gV = originalColorImage.getG(vIdx);
                int bV = originalColorImage.getB(vIdx);

                float totalRGBV = rV + gV + bV;
                
                float localSkyLuma = localSky.getAverageLuma();
                
                float lumaV = originalColorImage.getLuma(vIdx);
        
                double contrastV = (localSkyLuma - lumaV)/lumaV;

                double colorDiffV = localSky.calcColorDiffToOther(rV, gV, bV);

                double skyStDevContrast = localSky.getStdDevContrast();

                double skyStDevColorDiff = localSky.getStdDevColorDiff();

                boolean doNotAddToStack = false;
                 
 //TODO: this needs adjustments...
                float rPercentV = (float)rV/totalRGBV;
                float gPercentV = (float)gV/totalRGBV;
                float bPercentV = (float)bV/totalRGBV;
                
                float cieX = originalColorImage.getCIEX(vIdx);
                float cieY = originalColorImage.getCIEY(vIdx);
                double diffCIEX = Math.abs(cieX - localSky.getAverageCIEX());
                double diffCIEY = Math.abs(cieY - localSky.getAverageCIEY());
                
                float saturation = originalColorImage.getSaturation(vIdx);
                
                boolean isBrown = (Math.abs(rPercentV - 0.5) &lt; 0.4)
                    &amp;&amp; (Math.abs(gPercentV - 0.32) &lt; 0.1)
                    &amp;&amp; (Math.abs(bPercentV - 0.17) &lt; 0.1);

                if (isBrown) {
                    
                    // trying to skip over foreground such as land or sunset + water
                    
                    if (((colorDiffV/skyStDevColorDiff) &gt; 15) &amp;&amp; (saturation &lt; 0.5)) {
                        
                        if ((saturation &lt;= 0.4) &amp;&amp; ((colorDiffV/skyStDevColorDiff) &gt; 50) 
                            ) {

                            continue;
                        }
                         if ((saturation &lt;= 0.4) &amp;&amp; 
                            ((Math.abs(contrastV)/Math.abs(skyStDevContrast)) &gt; 10.)
                            ) {
                                                    
                            continue;
                        }
                    }
                }
                
                if ( // no contrast or color change, should be sky
                    (Math.abs(contrastV) &lt; 0.01)
                    &amp;&amp; (colorDiffV &lt; 10)
                    &amp;&amp; (diffCIEX &lt; 0.009) &amp;&amp; (diffCIEY &lt; 0.009)) {

                } else if (
                    (skyStDevContrast != 0.)
                    &amp;&amp; ((Math.abs(contrastV)/skyStDevContrast) &gt; 10.)
                    ) {

                    continue;
                } else if (
                    (skyStDevContrast != 0.)
                    &amp;&amp; ((Math.abs(contrastV) &gt; 0.1) 
                    &amp;&amp; ((Math.abs(contrastV)/skyStDevContrast) &gt; (1.5 + (Math.abs(contrastV)-0.5)*(-2.0))))
                    &amp;&amp; ((Math.abs(colorDiffV)/skyStDevColorDiff) &gt; 2.5)
                    ) {

                    continue;                     
                } else if (
                    (skyStDevContrast &gt; 0.005)
                    &amp;&amp; ((Math.abs(contrastV)/skyStDevContrast) &gt; 5.)
                    &amp;&amp; ((Math.abs(colorDiffV)/skyStDevColorDiff) &gt; 5.)
                    &amp;&amp; 
                    // if cieXY diffs are zero and within stdev, these are sky,
                    // so test for opposite for boundary pixel
                    (((diffCIEX &gt; 0.001) 
                        || ((diffCIEX/localSky.getStdDevCIEX()) &gt; 1.5)
                        || (diffCIEY &gt; 0.001) 
                        || ((diffCIEY/localSky.getStdDevCIEY()) &gt; 1.5)))                    
                    &amp;&amp; (skyStDevColorDiff &gt; 1.)
                    ) {

                    continue;
                } else if (skyIsRed) {
                                        
                    if (
                        // contrast is defined by luma, so might be weak near
                        // skyline near sun for example
                        (skyStDevContrast != 0.)
                        &amp;&amp; ((Math.abs(colorDiffV)/skyStDevColorDiff) &gt; 15.*diffCIEX)
                        &amp;&amp; (diffCIEX &gt; 0.03) 
                        &amp;&amp; ((diffCIEX/localSky.getStdDevCIEX()) &gt; 15.*diffCIEX)
                        ) {
                        continue;
                    } else if (
                        // contrast is defined by luma, so might be weak near
                        // skyline near sun for example
                        (skyStDevContrast != 0.)
                        &amp;&amp; ((Math.abs(colorDiffV)/skyStDevColorDiff) &gt; 15.*diffCIEY)
                        &amp;&amp; (diffCIEY &gt; 0.03) 
                        &amp;&amp; ((diffCIEY/localSky.getStdDevCIEY()) &gt; 15.*diffCIEY)
                        ) {
                        continue;
                    } else if (skyStDevContrast == 0.) {
                        if (contrastV &gt;= 0.) {
                            doNotAddToStack = true;
                        }
                        
                    } else {
                        //TODO:  if there are sun points, need a zone of
                        // avoidance to not erode the foreground 
                    }

                } else {
                    //blue filters
                    if (
                        (skyStDevContrast &gt; 0.0)
                        &amp;&amp; (contrastV &lt; 0.05) 
                        &amp;&amp; ((Math.abs(contrastV)/skyStDevContrast) &gt; 1.5)
                        &amp;&amp; ((Math.abs(colorDiffV)/skyStDevColorDiff) &gt; 3.0)
                        &amp;&amp; ((bPercentV &lt; 0.37) &amp;&amp; (bV &gt; 199) &amp;&amp; (gV &gt; 199))
                        ) {
                        continue;
                    } else if (
                        (skyStDevContrast &gt; 0.0)
                        &amp;&amp; (Math.abs(contrastV) &gt; 0.05)
                        &amp;&amp; ((Math.abs(colorDiffV)/skyStDevColorDiff) &gt; 1.5)
                        &amp;&amp; ((diffCIEX/localSky.getStdDevCIEX()) &gt; 0.9) // ?
                        &amp;&amp; ((diffCIEY/localSky.getStdDevCIEY()) &gt; 0.9) // ?                       
                        &amp;&amp; (skyStDevColorDiff &gt; 0.)
                    ){
                        continue;
                    } else if (
                    //(contrastV &lt; 0.05)
                    (Math.abs(contrastV) &lt; 0.05)
                    &amp;&amp; (diffCIEX &lt; 0.005) &amp;&amp; (diffCIEY &lt; 0.005)
                    &amp;&amp;
                        ((Math.abs(0.33 - rPercentV) &gt; 0.08)
                        || (Math.abs(0.33 - gPercentV) &gt; 0.03) 
                        || (Math.abs(0.33 - bPercentV) &gt; 0.03)
                        || (gV &gt; 199) || (bV &gt; 199))
                    ) {
                        continue;
                    } else {
                        continue;
                    }
                }
                
                skyPoints.add(vPoint);

                if (!doNotAddToStack) {
                    cloudQueue.add(vPoint);
                }
            }
        }
    }

    /**
     * given seed skyPoints to start from, use conservative limits on contrast
     * and color difference to add neighbors to skyPoints.  The conservative
     * limits are meant to help avoid overrunning the skyline for low
     * contrast such as a hazy sky and snow covered peaks, for example.
     * The conservative limits do not necessarily find all sky points.
     * 
     * &lt;pre&gt;
     * The contrast and color filters are supplied by params1, params2, gtOrLT,
     * and coefficients of format:
     *   (params1[i]/params2[i]) gtOrLT[i] coefficients[i]
     * and a set of those ANDed is present in each ANDedClauses[] clauses.
     * For example, 
     *    a clause to determine that a pixel is a border pixel because
     *    it has high contrast and high color difference might be:
     *       (((Math.abs(contrast)/1.0) &gt; coeff0) &amp;&amp; 
     *        ((Math.abs(contrast)/skyStDevContrast) &gt; 1.5*coeff0*coeff1) &amp;&amp;
     *        ((Math.abs(colorDiff)/1.0) &gt; coeff3) &amp;&amp; 
     *        ((Math.abs(colorDiff)/skyStDevcolorDiff) &gt; 1.5*coeff3*coeff4))
     *    (Note though that the use of 'coeff0*coeff1' has to be handled by the
     *    invoking code.  The ANDedClauses would actually just receive a
     *    coeff2, unaware that is it '1.5*coeff0*coeff1' to the invoker).
     * 
     * Then each ANDedClauses is 'OR'-ed with one another, trying to quickly
     * act if an ANDedClauses[i] evaluates to 'T'.  This is disjunctive 
     * normal form.
     * 
     *  if (is border pix)
     *      break
     *  else if (is border pix)
     *      break
     *  else if (is border pix)
     *      break
     *   
     *  a pixel making it to here looks like a sky pixel.
     * 
     * Note that internally, if the sky is red, the blue rules are removed
     * from the clauses and vice versa for blue skies.
     * &lt;/pre&gt;
     * 
     * @param skyPoints
     * @param originalColorImage
     */
    public void findClouds(Set&lt;PairInt&gt; skyPoints, Set&lt;PairInt&gt; excludePoints,
        ImageExt originalColorImage, GreyscaleImage thetaImage, 
        ANDedClauses[] clauses) {
        
<span class="fc" id="L1789">        int maskWidth = thetaImage.getWidth();</span>
<span class="fc" id="L1790">        int maskHeight = thetaImage.getHeight();</span>
        
<span class="fc" id="L1792">        ArrayDeque&lt;PairInt&gt; cloudQueue = new ArrayDeque&lt;PairInt&gt;(skyPoints.size());</span>
<span class="fc bfc" id="L1793" title="All 2 branches covered.">        for (PairInt skyPoint : skyPoints) {            </span>
<span class="fc" id="L1794">            cloudQueue.add(skyPoint);</span>
<span class="fc" id="L1795">        }</span>

<span class="fc" id="L1797">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L1798">        visited.add(cloudQueue.peek());</span>
              
<span class="fc" id="L1800">        int xOffset = thetaImage.getXRelativeOffset();</span>
<span class="fc" id="L1801">        int yOffset = thetaImage.getYRelativeOffset();</span>
        
<span class="fc" id="L1803">        GroupPixelColors allSkyColor = new GroupPixelColors(skyPoints,</span>
            originalColorImage, xOffset, yOffset);
        
<span class="fc" id="L1806">        double rDivB = allSkyColor.getAvgRed() / allSkyColor.getAvgBlue();</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">        boolean skyIsRed = (rDivB &gt; 1);</span>
        
<span class="fc" id="L1809">        clauses = filterForSkyColor(clauses, skyIsRed);</span>
       
<span class="fc" id="L1811">        log.fine(&quot;==&gt; r/b=&quot; + rDivB</span>
<span class="fc" id="L1812">            + &quot; redStdev=&quot; + allSkyColor.getStdDevRed()</span>
<span class="fc" id="L1813">            + &quot; blueStDev=&quot; + allSkyColor.getStdDevBlue());</span>
        
<span class="fc" id="L1815">        CIEChromaticity cieC = new CIEChromaticity();</span>
<span class="fc" id="L1816">        PointInPolygon pInPoly = new PointInPolygon();</span>
        
<span class="fc" id="L1818">        int[] dxs = new int[]{-1,  0, 1, 0};</span>
<span class="fc" id="L1819">        int[] dys = new int[]{ 0, -1, 0, 1};</span>
                
<span class="fc bfc" id="L1821" title="All 2 branches covered.">        while (!cloudQueue.isEmpty()) {</span>

<span class="fc" id="L1823">            PairInt uPoint = cloudQueue.poll();</span>
                        
<span class="fc" id="L1825">            int uX = uPoint.getX();</span>
<span class="fc" id="L1826">            int uY = uPoint.getY();</span>
        
            //(1 + frac)*O(N) where frac is the fraction added back to stack
<span class="fc bfc" id="L1829" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; k++) {</span>
                            
<span class="fc" id="L1831">                int vX = uX + dxs[k];</span>
<span class="fc" id="L1832">                int vY = uY + dys[k];</span>
                
<span class="fc bfc" id="L1834" title="All 8 branches covered.">                if ((vX &lt; 0) || (vX &gt; (maskWidth - 1)) || (vY &lt; 0) || </span>
                    (vY &gt; (maskHeight - 1))) {
<span class="fc" id="L1836">                    continue;</span>
                }
            
<span class="fc" id="L1839">                PairInt vPoint = new PairInt(vX, vY);</span>
                
<span class="fc bfc" id="L1841" title="All 2 branches covered.">                if (visited.contains(vPoint) || /*skyPoints.contains(vPoint) ||*/</span>
<span class="fc bfc" id="L1842" title="All 2 branches covered.">                    excludePoints.contains(vPoint)) {</span>

<span class="fc" id="L1844">                    continue;</span>
                }
                
<span class="fc" id="L1847">                visited.add(vPoint);</span>
                
<span class="fc" id="L1849">                Set&lt;PairInt&gt; neighbors = getThe8NeighborPixelsWithin(</span>
                    uPoint, skyPoints, maskWidth, maskHeight);             
                
<span class="fc" id="L1852">                neighbors.add(uPoint);</span>
                
<span class="fc" id="L1854">                GroupPixelColors localSky = new GroupPixelColors(neighbors, </span>
                    originalColorImage, xOffset, yOffset);
                
<span class="fc" id="L1857">                int vIdx = originalColorImage.getInternalIndex(vX + xOffset, </span>
                    vY + yOffset);

<span class="fc" id="L1860">                int rV = originalColorImage.getR(vIdx);</span>
<span class="fc" id="L1861">                int gV = originalColorImage.getG(vIdx);</span>
<span class="fc" id="L1862">                int bV = originalColorImage.getB(vIdx);</span>

<span class="fc" id="L1864">                float totalRGBV = rV + gV + bV;</span>
                
<span class="fc" id="L1866">                float localSkyLuma = localSky.getAverageLuma();</span>
                
<span class="fc" id="L1868">                float lumaV = originalColorImage.getLuma(vIdx);</span>
        
<span class="fc" id="L1870">                double contrastV = (localSkyLuma - lumaV)/lumaV;</span>

<span class="fc" id="L1872">                double colorDiffV = localSky.calcColorDiffToOther(rV, gV, bV);</span>

<span class="fc" id="L1874">                double skyStDevContrast = localSky.getStdDevContrast();</span>

<span class="fc" id="L1876">                double skyStDevColorDiff = localSky.getStdDevColorDiff();</span>
                 
 //TODO: this needs adjustments...
<span class="fc" id="L1879">                float rPercentV = (float)rV/totalRGBV;</span>
<span class="fc" id="L1880">                float gPercentV = (float)gV/totalRGBV;</span>
<span class="fc" id="L1881">                float bPercentV = (float)bV/totalRGBV;</span>
                
<span class="fc" id="L1883">                float cieX = originalColorImage.getCIEX(vIdx);</span>
<span class="fc" id="L1884">                float cieY = originalColorImage.getCIEY(vIdx);</span>
<span class="fc" id="L1885">                double diffCIEX = Math.abs(cieX - localSky.getAverageCIEX());</span>
<span class="fc" id="L1886">                double diffCIEY = Math.abs(cieY - localSky.getAverageCIEY());</span>
                
<span class="fc" id="L1888">                float saturation = originalColorImage.getSaturation(vIdx);</span>
                
<span class="fc bfc" id="L1890" title="All 2 branches covered.">                boolean isBrown = (Math.abs(rPercentV - 0.5) &lt; 0.4)</span>
<span class="fc bfc" id="L1891" title="All 2 branches covered.">                    &amp;&amp; (Math.abs(gPercentV - 0.32) &lt; 0.1)</span>
<span class="fc bfc" id="L1892" title="All 2 branches covered.">                    &amp;&amp; (Math.abs(bPercentV - 0.17) &lt; 0.1);</span>

<span class="fc bfc" id="L1894" title="All 2 branches covered.">                if (isBrown) {</span>
                    // trying to skip over foreground such as land or sunset + water                    
<span class="fc bfc" id="L1896" title="All 4 branches covered.">                    if ((colorDiffV &gt; 15*skyStDevColorDiff) &amp;&amp; (saturation &lt; 0.5)) {</span>
<span class="fc bfc" id="L1897" title="All 4 branches covered.">                        if ((saturation &lt;= 0.4) &amp;&amp; (colorDiffV &gt; 50*skyStDevColorDiff) </span>
                            ) {

<span class="fc" id="L1900">                            continue;</span>
                        }
<span class="fc bfc" id="L1902" title="All 2 branches covered.">                         if ((saturation &lt;= 0.4) &amp;&amp; </span>
<span class="fc bfc" id="L1903" title="All 2 branches covered.">                            (Math.abs(contrastV) &gt; 10.*Math.abs(skyStDevContrast))</span>
                            ) {

<span class="fc" id="L1906">                            continue;</span>
                        }
                    }
                }
                
<span class="fc" id="L1911">                boolean isSolarYellow = false;</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">                if (skyIsRed) {</span>
<span class="fc bfc" id="L1913" title="All 10 branches covered.">                    if ((skyStDevContrast != 0.) &amp;&amp; (contrastV &gt; 0.01) </span>
                        &amp;&amp; (colorDiffV &gt; 15*skyStDevColorDiff)
                        &amp;&amp; ((diffCIEX &gt; 0.03) || (diffCIEY &gt; 0.03))
                        ) {
<span class="fc" id="L1917">                        ArrayPair yellowGreenOrange = </span>
<span class="fc" id="L1918">                            cieC.getGreenishYellowThroughOrangePolynomial();</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">                        if (pInPoly.isInSimpleCurve(cieX, cieY,</span>
<span class="fc" id="L1920">                            yellowGreenOrange.getX(), yellowGreenOrange.getY(),</span>
<span class="fc" id="L1921">                            yellowGreenOrange.getX().length)) {</span>
<span class="fc" id="L1922">                            isSolarYellow = true;</span>
                        }
                    }
                }
                
<span class="fc" id="L1927">                ColorData data = new ColorData(skyIsRed,</span>
                    contrastV, colorDiffV,
                    diffCIEX, diffCIEY,
                    skyStDevContrast, skyStDevColorDiff,
<span class="fc" id="L1931">                    localSky.getStdDevCIEX(), localSky.getStdDevCIEY(), </span>
                    rV, gV, bV
                );
                
<span class="fc" id="L1935">                if (// no contrast or color change, should be sky</span>
<span class="fc bfc" id="L1936" title="All 2 branches covered.">                    (Math.abs(contrastV) &lt; 0.015)</span>
<span class="fc bfc" id="L1937" title="All 6 branches covered.">                    &amp;&amp; (Math.abs(colorDiffV) &lt; 10)</span>
                    &amp;&amp; (diffCIEX &lt; 0.009) &amp;&amp; (diffCIEY &lt; 0.009)) {
                    // this is a sky point

                //} else if (isSolarYellow) {
                    // this is a sky point
                } else {
                    
                    // evaluate clauses that evaluate to 'T' when the pixel 
                    // looks like a border (non-sky) pixel
<span class="fc" id="L1947">                    boolean isNotSky = false;</span>

<span class="fc bfc" id="L1949" title="All 2 branches covered.">                    for (ANDedClauses clause : clauses) {</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">                        if (clause.evaluate(data)) {</span>
<span class="fc" id="L1951">                            isNotSky = true;</span>
<span class="fc" id="L1952">                            break;</span>
                        }
                    }
            
<span class="fc bfc" id="L1956" title="All 2 branches covered.">                    if (isNotSky) {</span>
<span class="fc" id="L1957">                        continue;</span>
                    }
                }
                
<span class="fc" id="L1961">                skyPoints.add(vPoint);</span>

<span class="fc" id="L1963">                boolean doNotAddToStack = false;</span>
<span class="fc bfc" id="L1964" title="All 6 branches covered.">                if (skyIsRed &amp;&amp; (skyStDevContrast == 0.) &amp;&amp; (contrastV &gt;= 0.)) {</span>
<span class="fc" id="L1965">                    doNotAddToStack = true;</span>
                }
<span class="fc bfc" id="L1967" title="All 2 branches covered.">                if (!doNotAddToStack) {</span>
<span class="fc" id="L1968">                    cloudQueue.add(vPoint);</span>
                }
            }
<span class="fc" id="L1971">        }</span>

<span class="fc" id="L1973">    }</span>
   
    public static void getEmbeddedAndBorderPoints(Set&lt;PairInt&gt; skyPoints,
        int width, int height, Set&lt;PairInt&gt; outputEmbeddedGapPoints,
        Set&lt;PairInt&gt; outputBorderPoints) {
        
<span class="fc" id="L1979">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>

<span class="fc" id="L1981">        int imageMaxColumn = width - 1;</span>
<span class="fc" id="L1982">        int imageMaxRow = height - 1;</span>
       
<span class="fc" id="L1984">        int[] skyRowMinMax = new int[2];</span>
        
<span class="fc" id="L1986">        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRanges = perimeterFinder.find(</span>
            skyPoints, skyRowMinMax, imageMaxColumn, 
            outputEmbeddedGapPoints);

        // update the perimeter for &quot;filling in&quot; embedded points
<span class="fc" id="L1991">        perimeterFinder.updateRowColRangesForAddedPoints(skyRowColRanges, </span>
            skyRowMinMax, imageMaxColumn, outputEmbeddedGapPoints);
        
<span class="fc" id="L1994">        Set&lt;PairInt&gt; borderPixels = perimeterFinder.getBorderPixels(</span>
            skyRowColRanges, skyRowMinMax, imageMaxColumn, imageMaxRow);
        
<span class="fc" id="L1997">        outputBorderPoints.addAll(borderPixels);</span>
        
<span class="fc" id="L1999">    }</span>
    
    public static void getEmbeddedPoints(Set&lt;PairInt&gt; skyPoints,
        int width, int height, Set&lt;PairInt&gt; outputEmbeddedPoints) {
        
<span class="fc" id="L2004">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>

<span class="fc" id="L2006">        int imageMaxColumn = width - 1;</span>
<span class="fc" id="L2007">        int imageMaxRow = height - 1;</span>
       
<span class="fc" id="L2009">        int[] skyRowMinMax = new int[2];</span>
        
<span class="fc" id="L2011">        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRanges = perimeterFinder.find(</span>
            skyPoints, skyRowMinMax, imageMaxColumn, 
            outputEmbeddedPoints);
<span class="fc" id="L2014">    }</span>
    
    protected GroupPixelColors[] partitionInto3ByBrightness(
        Set&lt;PairInt&gt; skyPoints, 
        ImageExt originalColorImage, int xOffset, int yOffset, HistogramHolder[] h) {
         
<span class="fc" id="L2020">        int i = 0;</span>
<span class="fc" id="L2021">        float[] brightness = new float[skyPoints.size()];</span>
<span class="fc" id="L2022">        PairInt[] ps = new PairInt[brightness.length];</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">        for (PairInt p : skyPoints) {</span>
<span class="fc" id="L2024">            int x = p.getX() + xOffset;</span>
<span class="fc" id="L2025">            int y = p.getY() + yOffset;</span>
<span class="fc" id="L2026">            int idx = originalColorImage.getInternalIndex(x, y);</span>
            
<span class="fc" id="L2028">            brightness[i] = originalColorImage.getBrightness(idx);</span>
<span class="fc" id="L2029">            ps[i] = p;</span>
<span class="fc" id="L2030">            i++;</span>
<span class="fc" id="L2031">        }</span>
        
<span class="fc" id="L2033">        float min = MiscMath.findMin(brightness);</span>
<span class="fc" id="L2034">        float max = MiscMath.findMax(brightness);</span>
<span class="fc" id="L2035">        float[] yErr = Errors.populateYErrorsBySqrt(brightness);</span>
<span class="fc" id="L2036">        h[0] = Histogram.createSimpleHistogram(min, max, 3, </span>
            brightness, yErr);
        
        /*try {
            h[0].plotHistogram(&quot;sky brightness&quot;, 235);
        } catch(Exception e) {
    
        }*/    

<span class="fc" id="L2045">        Set&lt;PairInt&gt; set0 = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2046">        Set&lt;PairInt&gt; set1 = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2047">        Set&lt;PairInt&gt; set2 = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L2049">        float binSize = h[0].getXHist()[1] - h[0].getXHist()[0];</span>
        
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        for (i = 0; i &lt; brightness.length; i++) {</span>
<span class="fc" id="L2052">            float cd = brightness[i];</span>
<span class="fc" id="L2053">            int binN = (int)((cd - min)/binSize);</span>
<span class="fc bfc" id="L2054" title="All 3 branches covered.">            switch(binN) {</span>
                case 0:
<span class="fc" id="L2056">                    set0.add(ps[i]);</span>
<span class="fc" id="L2057">                    break;</span>
                case 1:
<span class="fc" id="L2059">                    set1.add(ps[i]);</span>
<span class="fc" id="L2060">                    break;</span>
                default:
<span class="fc" id="L2062">                    set2.add(ps[i]);</span>
                    break;
            }
        }
        
<span class="fc" id="L2067">        GroupPixelColors[] sets = new GroupPixelColors[3];</span>
<span class="fc" id="L2068">        sets[0] = new GroupPixelColors(set0, originalColorImage, xOffset, yOffset);</span>
<span class="fc" id="L2069">        sets[1] = new GroupPixelColors(set1, originalColorImage, xOffset, yOffset);</span>
<span class="fc" id="L2070">        sets[2] = new GroupPixelColors(set2, originalColorImage, xOffset, yOffset);</span>
        
<span class="fc" id="L2072">        return sets;</span>
    }
    
        /*
        scattering:
            for atmospheric particles, their size is much smaller than
            lambda, the wavelength of optical light:  
                Rayleigh scattering is prop to lambda^-4.
                this is responsible for blue or red skies compared to 
                the yellow color of the sun 
                (photosphere peak is near 5500 Angstroms).
        
            for clouds, the water droplets are the scatters and their
            size is comparable to lambda for optical light:
                Mie scattering affects optical colors roughly equally,
                so leads to less light without a color change.
        
        One could use the position of the sun to approximate the airmass for
        different depths of features and calculate the transmission of the solar 
        spectrum through atmosphere with absorption by water, scattering and 
        absorption by aerosols and Rayleigh scattering in addition to Mie 
        scattering by water droplets in the clouds
        combined with a model for water vapor in the atmosphere and a range 
        of cloud optical depths and locations and a camera response function 
        to estimate the colors expected in images...
        
        The source function upon the clouds could be modeled with
        http://rredc.nrel.gov/solar/pubs/spectral/model/section5.html
        
        Since that isn't feasible for now, could take skyPoints colors and colors
        from the outer patch of sun and look for some variations of those in the
        image close to, but unconnected to existing skyPoints.
        */


    private int count(List&lt;PairIntArray&gt; zeroPointLists) {
        
<span class="fc" id="L2109">        int n = 0;</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">        for (PairIntArray p : zeroPointLists) {</span>
<span class="fc" id="L2111">            n += p.getN();</span>
<span class="fc" id="L2112">        }</span>
        
<span class="fc" id="L2114">        return n;</span>
    }

    void debugPlot(Set&lt;PairInt&gt; extSkyPoints, Image originalColorImage, 
        int xOffset, int yOffset, String outputPrefixForFileName) {
        
        //plot is made in aspects
        
<span class="fc" id="L2122">    }</span>
    
    void debugPlot(Set&lt;PairInt&gt; r0, Set&lt;PairInt&gt; r1, Set&lt;PairInt&gt; r2, 
        Set&lt;PairInt&gt; r3, Image originalColorImage, int xOffset, int yOffset, 
        String filtered_out_of_clouds) {
        
        //plot is made in aspects
<span class="nc" id="L2129">    }</span>

    private void filterToAddCloudPixel(Set&lt;PairInt&gt; excludeFromThesePoints, 
        Set&lt;PairInt&gt; skyPoints, ImageExt origColorImg, 
        int xOffset, int yOffset, PairInt p,
        GroupPixelColors[] skyBinsByBrightness,
        boolean skyIsRed, boolean skyIsPurple, boolean hasDarkGreyClouds,
        boolean useKEqualsZero, boolean pointIsEmbeddedInSky,
        Set&lt;PairInt&gt; outputCloudPoints, Stack&lt;PairInt&gt; outputStack) {
        
<span class="pc bpc" id="L2139" title="2 of 4 branches missed.">        if (skyPoints.contains(p) || excludeFromThesePoints.contains(p)) {</span>
<span class="nc" id="L2140">            return;</span>
        }
        
<span class="fc" id="L2143">        int col = p.getX() + xOffset;</span>
<span class="fc" id="L2144">        int row = p.getY() + yOffset;</span>
        
<span class="pc bpc" id="L2146" title="3 of 6 branches missed.">        if ((col &lt; 0) || (col &gt; (origColorImg.getWidth() - 1)) ||</span>
<span class="pc bpc" id="L2147" title="1 of 2 branches missed.">            (row &lt; 0) || (row &gt; (origColorImg.getHeight() - 1))) {</span>
<span class="nc" id="L2148">            return;</span>
        }
<span class="fc bfc" id="L2150" title="All 4 branches covered.">if (col &gt; 581 &amp;&amp; row==282) {</span>
<span class="fc" id="L2151">    int z = 1;</span>
}
<span class="fc" id="L2153">        int idx = origColorImg.getInternalIndex(col, row);</span>
        
<span class="fc" id="L2155">        int r = origColorImg.getR(idx);</span>
<span class="fc" id="L2156">        int g = origColorImg.getG(idx);</span>
<span class="fc" id="L2157">        int b = origColorImg.getB(idx);</span>
                    
<span class="fc" id="L2159">        float luma = origColorImg.getLuma(idx);</span>
        
<span class="pc bpc" id="L2161" title="1 of 2 branches missed.">        for (int k = 2; k &gt;= 0; k--) {                    </span>

<span class="pc bpc" id="L2163" title="3 of 4 branches missed.">            if ((k == 0) &amp;&amp; !useKEqualsZero) {</span>
<span class="nc" id="L2164">                continue;</span>
            }             
            
<span class="fc" id="L2167">            float skyLuma = skyBinsByBrightness[k].getAverageLuma();</span>
            
<span class="fc" id="L2169">            float contrast = (skyLuma - luma)/luma;</span>

<span class="fc" id="L2171">            double diffContrast = contrast - skyLuma;</span>
            
<span class="pc bpc" id="L2173" title="1 of 6 branches missed.">            if (skyIsRed &amp;&amp; (diffContrast &gt; 0) &amp;&amp; !pointIsEmbeddedInSky) {</span>
<span class="nc" id="L2174">                continue;</span>
            }
            
<span class="fc" id="L2177">            double diffR = r - skyBinsByBrightness[k].getAvgRed();</span>
<span class="fc bfc" id="L2178" title="All 2 branches covered.">            if (diffR &lt; 0) {</span>
<span class="fc" id="L2179">                diffR *= -1;</span>
            }
<span class="fc" id="L2181">            double diffG = g - skyBinsByBrightness[k].getAvgGreen();</span>
<span class="fc bfc" id="L2182" title="All 2 branches covered.">            if (diffG &lt; 0) {</span>
<span class="fc" id="L2183">                diffG *= -1;</span>
            }
<span class="fc" id="L2185">            double diffB = b - skyBinsByBrightness[k].getAvgBlue();</span>
<span class="fc bfc" id="L2186" title="All 2 branches covered.">            if (diffB &lt; 0) {</span>
<span class="fc" id="L2187">                diffB *= -1;</span>
            }

<span class="pc bpc" id="L2190" title="1 of 2 branches missed.">            if (</span>
                (pointIsEmbeddedInSky) ||
                (
                (
<span class="nc bnc" id="L2194" title="All 4 branches missed.">                    (diffR &lt;= skyBinsByBrightness[k].getStdDevRed())</span>
                    ||
<span class="nc bnc" id="L2196" title="All 6 branches missed.">                    (skyIsRed &amp;&amp; (r &gt; skyBinsByBrightness[k].getAvgRed()))</span>
                    ||
                    (skyIsRed &amp;&amp; (r &gt; 155) &amp;&amp; 
<span class="nc bnc" id="L2199" title="All 4 branches missed.">                        (diffR &lt;= 3.5*skyBinsByBrightness[k].getStdDevRed())</span>
                    )
                    ||
                    (!skyIsRed &amp;&amp; /*hasDarkGreyClouds &amp;&amp;*/ 
<span class="nc bnc" id="L2203" title="All 2 branches missed.">                        (diffR &lt;= 2.0*skyBinsByBrightness[k].getStdDevRed())</span>
                    )
                )
                &amp;&amp; (
<span class="nc bnc" id="L2207" title="All 8 branches missed.">                    (diffG &lt;= 1.5*skyBinsByBrightness[k].getStdDevGreen())</span>
                    ||
                    //consider (contrast &lt; 0.) &amp;&amp; (contrast &gt; -0.05)
                    (skyIsRed &amp;&amp; (contrast &lt; 0.) &amp;&amp; (g &gt; 130) &amp;&amp; 
<span class="nc bnc" id="L2211" title="All 10 branches missed.">                        (diffG &lt;= 2.0*skyBinsByBrightness[k].getStdDevGreen())</span>
                    )
                    ||
                    ((skyIsPurple || skyIsRed) &amp;&amp; (contrast &gt; 0.) &amp;&amp; (g &lt; 130) &amp;&amp; 
<span class="nc bnc" id="L2215" title="All 6 branches missed.">                        (diffG &lt;= 2.0*skyBinsByBrightness[k].getStdDevGreen())</span>
                    )
                    ||
                    (!skyIsRed &amp;&amp; hasDarkGreyClouds &amp;&amp; 
<span class="nc bnc" id="L2219" title="All 2 branches missed.">                        (diffG &lt;= 2.0*skyBinsByBrightness[k].getStdDevGreen())</span>
                    )
                )
                &amp;&amp; (
<span class="nc bnc" id="L2223" title="All 8 branches missed.">                    (diffB &lt;= 1.2*skyBinsByBrightness[k].getStdDevBlue())</span>
                    ||
                    (skyIsPurple &amp;&amp; (contrast &gt; 0.) &amp;&amp; (b &lt; 130) &amp;&amp; 
<span class="nc bnc" id="L2226" title="All 4 branches missed.">                        (diffB &lt;= 2.5*skyBinsByBrightness[k].getStdDevBlue())</span>
                    )
                    ||
                    (!skyIsRed &amp;&amp; /*hasDarkGreyClouds &amp;&amp;*/
<span class="nc bnc" id="L2230" title="All 2 branches missed.">                        (diffB &lt;= 1.5*skyBinsByBrightness[k].getStdDevBlue())</span>
                    )
                )
                )
                ) {

<span class="fc" id="L2236">                outputCloudPoints.add(p);</span>

<span class="fc" id="L2238">                outputStack.add(p);</span>

<span class="fc" id="L2240">                break;</span>
            }
        }
<span class="fc" id="L2243">    }</span>

    void populatePixelExtColors(Set&lt;PairInt&gt; points, ImageExt originalColorImage, 
        GreyscaleImage mask) {
        
<span class="fc" id="L2248">        int xOffset = mask.getXRelativeOffset(); </span>
<span class="fc" id="L2249">        int yOffset = mask.getYRelativeOffset();</span>
        
<span class="fc bfc" id="L2251" title="All 2 branches covered.">        for (PairInt p : points) {</span>
            
<span class="fc" id="L2253">            int x = p.getX() + xOffset;</span>
<span class="fc" id="L2254">            int y = p.getY() + yOffset;</span>
<span class="fc" id="L2255">            int index = mask.getIndex(x, y);</span>
            
<span class="fc" id="L2257">            originalColorImage.calculateColorIncludingNeighbors(index, 0);</span>
<span class="fc" id="L2258">        }</span>
<span class="fc" id="L2259">    }</span>

    private Set&lt;PairInt&gt; removeReflectedSun(List&lt;PairIntArray&gt; zeroPointLists, 
        ImageExt colorImg, GreyscaleImage thetaImg) {
        
<span class="fc" id="L2264">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L2266" title="All 2 branches covered.">        for (int i = 0; i &lt; zeroPointLists.size(); i++) {</span>
            
<span class="fc" id="L2268">            PairIntArray zeroPointList = zeroPointLists.get(i);</span>
            
<span class="fc" id="L2270">            Set&lt;PairInt&gt; pointSet = new HashSet&lt;PairInt&gt;();</span>
            
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            for (int ii = 0; ii &lt; zeroPointList.getN(); ii++) {</span>
<span class="fc" id="L2273">                int x = zeroPointList.getX(ii);</span>
<span class="fc" id="L2274">                int y = zeroPointList.getY(ii);</span>
<span class="fc" id="L2275">                PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L2276">                pointSet.add(p);</span>
            }
            
<span class="fc" id="L2279">            Set&lt;PairInt&gt; sunPoints = new HashSet&lt;PairInt&gt;();</span>
            
<span class="fc" id="L2281">            double[] ellipFitParams = findSunConnectedToSkyPoints(pointSet,</span>
                new HashSet&lt;PairInt&gt;(),
<span class="fc" id="L2283">                colorImg, thetaImg.getXRelativeOffset(),</span>
<span class="fc" id="L2284">                thetaImg.getYRelativeOffset(), false, sunPoints);</span>
            
<span class="fc" id="L2286">            float fracSun = (float)sunPoints.size()/(float)pointSet.size();</span>
            
<span class="pc bpc" id="L2288" title="1 of 2 branches missed.">            if (fracSun &gt;= 0.8) {</span>
<span class="nc" id="L2289">                remove.add(Integer.valueOf(i));</span>
            }
        }
                
<span class="pc bpc" id="L2293" title="1 of 2 branches missed.">        if (!remove.isEmpty()) {</span>
            
<span class="nc" id="L2295">            Set&lt;PairInt&gt; reflectedSun = new HashSet&lt;PairInt&gt;();</span>
            
<span class="nc bnc" id="L2297" title="All 2 branches missed.">            for (int i = (remove.size() - 1); i &gt; -1; i--) {</span>
                
<span class="nc" id="L2299">                int idx = remove.get(i).intValue();</span>
                
<span class="nc" id="L2301">                PairIntArray pai = zeroPointLists.remove(idx);</span>
                
<span class="nc bnc" id="L2303" title="All 2 branches missed.">                for (int ii = 0; ii &lt; pai.getN(); ii++) {</span>
<span class="nc" id="L2304">                    int x = pai.getX(ii);</span>
<span class="nc" id="L2305">                    int y = pai.getY(ii);</span>
                    
<span class="nc" id="L2307">                    reflectedSun.add(new PairInt(x, y));</span>
                }
            }
            
<span class="nc" id="L2311">            log.info(&quot;removed &quot; + remove.size() + </span>
                &quot; points that resembled reflected sun&quot;);
            
<span class="nc" id="L2314">            return reflectedSun;</span>
        }
        
<span class="fc" id="L2317">        return new HashSet&lt;PairInt&gt;();</span>
    }

    private void growForLowContrastLimits(Set&lt;PairInt&gt; points, 
        Set&lt;PairInt&gt; excludePoints, ImageExt colorImg, int xOffset, int yOffset,
        int binFactor) {

        // it tries to avoid adding snowy mountain tops to hazy sky pixels,
        // for example.

<span class="fc" id="L2327">        int cWidth = colorImg.getWidth();</span>
<span class="fc" id="L2328">        int cHeight = colorImg.getHeight();</span>
<span class="fc" id="L2329">        int imageMaxColumn = cWidth;</span>
<span class="fc" id="L2330">        int imageMaxRow = cHeight;</span>

<span class="fc" id="L2332">        GroupPixelColors allSkyColor = new GroupPixelColors(points, colorImg, </span>
            xOffset, yOffset);

<span class="fc" id="L2335">        double rDivB = allSkyColor.getAvgRed()/allSkyColor.getAvgBlue();</span>

<span class="fc bfc" id="L2337" title="All 2 branches covered.">        boolean skyIsRed = (rDivB &gt; 1);</span>

<span class="fc" id="L2339">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>

<span class="fc" id="L2341">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L2342">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>

<span class="fc" id="L2344">        int nAdded = 0;</span>
<span class="fc" id="L2345">        int nIter = 0;</span>
<span class="fc" id="L2346">        int nMaxIter = binFactor;</span>

<span class="fc" id="L2348">        int[] skyRowMinMax = new int[2];</span>
<span class="fc" id="L2349">        Set&lt;PairInt&gt; embeddedPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2350">        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRange = perimeterFinder.find(points, skyRowMinMax, </span>
<span class="fc" id="L2351">            colorImg.getWidth(), embeddedPoints);</span>
<span class="fc" id="L2352">        Set&lt;PairInt&gt; borderPixels = null;</span>
        
<span class="fc bfc" id="L2354" title="All 6 branches covered.">        while ((nIter == 0) || ((nIter &lt; nMaxIter) &amp;&amp; (nAdded &gt; 0))) {</span>
            
<span class="fc bfc" id="L2356" title="All 2 branches covered.">            if (borderPixels != null) {</span>
<span class="fc" id="L2357">                skyRowColRange = perimeterFinder.find(</span>
                    points, skyRowMinMax, imageMaxColumn, 
                    embeddedPoints);
            }
<span class="fc" id="L2361">            borderPixels = perimeterFinder.getBorderPixels(</span>
                skyRowColRange, skyRowMinMax, imageMaxColumn, imageMaxRow);
            
<span class="fc" id="L2364">            nAdded = 0;          </span>

<span class="fc bfc" id="L2366" title="All 2 branches covered.">            for (PairInt uPoint : borderPixels) {</span>

<span class="fc" id="L2368">                int uX = uPoint.getX() + xOffset;</span>
<span class="fc" id="L2369">                int uY = uPoint.getY() + yOffset;</span>
                
<span class="fc" id="L2371">                Set&lt;PairInt&gt; neighborsInSky = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2372">                Set&lt;PairInt&gt; neighborsNotInSky = new HashSet&lt;PairInt&gt;();</span>
                                        
<span class="fc bfc" id="L2374" title="All 2 branches covered.">                for (int k = 0; k &lt; dxs.length; k++) {</span>

<span class="fc" id="L2376">                    int vX = uX + dxs[k];</span>
<span class="fc" id="L2377">                    int vY = uY + dys[k];</span>

<span class="fc bfc" id="L2379" title="All 8 branches covered.">                    if ((vX &lt; 0) || (vX &gt; (cWidth - 1)) || (vY &lt; 0) || </span>
                        (vY &gt; (cHeight - 1))) {
<span class="fc" id="L2381">                        continue;</span>
                    }

<span class="fc" id="L2384">                    PairInt vPoint = new PairInt(vX - xOffset, vY - yOffset);</span>
                    
<span class="pc bpc" id="L2386" title="1 of 4 branches missed.">                    if (uPoint.equals(vPoint) || excludePoints.contains(vPoint)) {</span>
<span class="fc" id="L2387">                        continue;</span>
                    }
                    
<span class="fc bfc" id="L2390" title="All 2 branches covered.">                    if (points.contains(vPoint)) {</span>
<span class="fc" id="L2391">                        neighborsInSky.add(vPoint);</span>
                    } else {
<span class="fc" id="L2393">                        neighborsNotInSky.add(vPoint);</span>
                    }
                }
                
<span class="fc bfc" id="L2397" title="All 2 branches covered.">                if (!neighborsNotInSky.isEmpty()) {</span>
                    
<span class="fc" id="L2399">                    GroupPixelColors gpc = new GroupPixelColors(neighborsInSky,</span>
                        colorImg, xOffset, yOffset);
                    
<span class="fc bfc" id="L2402" title="All 2 branches covered.">                    for (PairInt p : neighborsNotInSky) {</span>
                        
<span class="fc" id="L2404">                        int x = p.getX();</span>
<span class="fc" id="L2405">                        int y = p.getY();</span>
                        
<span class="fc" id="L2407">                        int idx = colorImg.getInternalIndex(x, y);</span>
        
<span class="fc" id="L2409">                        int r = colorImg.getR(idx);</span>
<span class="fc" id="L2410">                        int g = colorImg.getG(idx);</span>
<span class="fc" id="L2411">                        int b = colorImg.getB(idx);</span>
                        
<span class="fc" id="L2413">                        float contrast = gpc.calcContrastToOther(r, g, b);</span>
                        //double contrastDivStDev = contrast/gpc.getStdDevContrast();
                        //float colorDiff = gpc.calcColorDiffToOther(r, g, b);
<span class="fc bfc" id="L2416" title="All 2 branches covered.">                        double colorDiffForSkyColor = skyIsRed ? </span>
<span class="fc" id="L2417">                            (r - gpc.getAvgRed()) : (b - gpc.getAvgBlue());</span>
                        //double colorDiffForSkyColorDivStDev = skyIsRed ?
                        //    colorDiffForSkyColor/gpc.getStdDevRed() :
                        //    colorDiffForSkyColor/gpc.getStdDevBlue();
<span class="fc" id="L2421">                        double diffCIEX = colorImg.getCIEX(x, y) - gpc.getAverageCIEX();</span>
<span class="fc" id="L2422">                        double diffCIEY = colorImg.getCIEY(x, y) - gpc.getAverageCIEY();</span>
                        //double diffCIEXDivStDev = Math.abs(diffCIEX)/gpc.getStdDevCIEX();
                        //double diffCIEYDivStDev = Math.abs(diffCIEY)/gpc.getStdDevCIEY();
                           
<span class="fc bfc" id="L2426" title="All 4 branches covered.">                        if (</span>
                            (diffCIEX &lt; 0.01) &amp;&amp; (diffCIEY &lt; 0.01)
<span class="fc bfc" id="L2428" title="All 2 branches covered.">                            &amp;&amp; (Math.abs(contrast) &lt; 0.01)  //0.045 for less conservative</span>
                            ) {
<span class="fc" id="L2430">                            points.add(new PairInt(x - xOffset, y - yOffset));</span>
<span class="fc" id="L2431">                            nAdded++;</span>
<span class="fc bfc" id="L2432" title="All 4 branches covered.">                        } else if (</span>
                            (diffCIEX &lt; 0.005) &amp;&amp; (diffCIEY &lt; 0.005)
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">                            &amp;&amp; (Math.abs(contrast) &lt; 0.005)</span>
                            ) {
<span class="nc" id="L2436">                            points.add(new PairInt(x - xOffset, y - yOffset));</span>
<span class="nc" id="L2437">                            nAdded++;</span>
                        }
<span class="fc" id="L2439">                    }</span>
                }
<span class="fc" id="L2441">            }</span>
            
<span class="fc" id="L2443">            System.out.println(&quot;nAdded=&quot; + nAdded);</span>
            
<span class="fc" id="L2445">            nIter++;</span>
        }
<span class="fc" id="L2447">    }</span>

    boolean skyIsDarkGrey(GroupPixelColors allSkyColor) {
        
<span class="fc" id="L2451">        float rDiffG = Math.abs(allSkyColor.getAvgRed() -</span>
<span class="fc" id="L2452">            allSkyColor.getAvgGreen());</span>

<span class="fc" id="L2454">        float gDiffB = Math.abs(allSkyColor.getAvgGreen() -</span>
<span class="fc" id="L2455">            allSkyColor.getAvgBlue());</span>

<span class="fc" id="L2457">        float rDivB = Math.abs(allSkyColor.getAvgRed()/</span>
<span class="fc" id="L2458">            allSkyColor.getAvgBlue());</span>

<span class="pc bpc" id="L2460" title="1 of 8 branches missed.">        if ((rDivB &gt;= 0.85) &amp;&amp; (rDivB &lt;= 1.15) &amp;&amp; (rDiffG &lt; 20) &amp;&amp;</span>
<span class="fc bfc" id="L2461" title="All 2 branches covered.">            (gDiffB &lt; 20) &amp;&amp; (allSkyColor.getAvgGreen() &lt; 125)) {</span>

<span class="fc" id="L2463">            return true;</span>
        }
        
<span class="fc" id="L2466">        return false;</span>
    }

    private Set&lt;PairInt&gt; getThe8NeighborPixelsWithin(PairInt uPoint, 
        Set&lt;PairInt&gt; points, int width, int height) {
        
<span class="fc" id="L2472">        return getTheNeighborPixels(uPoint, points, width, height, 1);</span>
    }
    
    private Set&lt;PairInt&gt; getThe24NeighborPixelsWithin(PairInt uPoint, 
        Set&lt;PairInt&gt; points, int width, int height) {
        
<span class="nc" id="L2478">        return getTheNeighborPixels(uPoint, points, width, height, 2);</span>
    }

    Set&lt;PairInt&gt; getTheNeighborPixels(PairInt uPoint, 
        Set&lt;PairInt&gt; points, int width, int height, int radius) {
        
<span class="fc" id="L2484">        int uX = uPoint.getX();</span>
<span class="fc" id="L2485">        int uY = uPoint.getY();</span>
        
<span class="fc" id="L2487">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L2489" title="All 2 branches covered.">        for (int vX = (uX - radius); vX &lt;= (uX + radius); vX++) {</span>

<span class="fc bfc" id="L2491" title="All 4 branches covered.">            if ((vX &lt; 0) || (vX &gt; (width - 1))) {</span>
<span class="fc" id="L2492">                continue;</span>
            }

<span class="fc bfc" id="L2495" title="All 2 branches covered.">            for (int vY = (uY - radius); vY &lt;= (uY + radius); vY++) {</span>
                
<span class="fc bfc" id="L2497" title="All 4 branches covered.">                if ((vY &lt; 0) || (vY &gt; (height - 1))) {</span>
<span class="fc" id="L2498">                    continue;</span>
                }
                
<span class="fc" id="L2501">                PairInt vPoint = new PairInt(vX, vY);</span>
                
<span class="fc bfc" id="L2503" title="All 4 branches covered.">                if (uPoint.equals(vPoint) || !points.contains(vPoint)) {</span>
<span class="fc" id="L2504">                    continue;</span>
                }
                
<span class="fc" id="L2507">                set.add(vPoint);</span>
            }
        }
        
<span class="fc" id="L2511">        return set;</span>
    }

    private Set&lt;PairInt&gt; getThe8NeighborPixelsWithin(PairInt uPoint, 
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; excludePoints, int width, int height) {
        
<span class="nc" id="L2517">        int uX = uPoint.getX();</span>
<span class="nc" id="L2518">        int uY = uPoint.getY();</span>
        
<span class="nc" id="L2520">        Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L2522" title="All 2 branches missed.">        for (int vX = (uX - 1); vX &lt;= (uX + 1); vX++) {</span>

<span class="nc bnc" id="L2524" title="All 4 branches missed.">            if ((vX &lt; 0) || (vX &gt; (width - 1))) {</span>
<span class="nc" id="L2525">                continue;</span>
            }

<span class="nc bnc" id="L2528" title="All 2 branches missed.">            for (int vY = (uY - 1); vY &lt;= (uY + 1); vY++) {</span>
                
<span class="nc bnc" id="L2530" title="All 4 branches missed.">                if ((vY &lt; 0) || (vY &gt; (height - 1))) {</span>
<span class="nc" id="L2531">                    continue;</span>
                }
                
<span class="nc" id="L2534">                PairInt vPoint = new PairInt(vX, vY);</span>
                
<span class="nc bnc" id="L2536" title="All 4 branches missed.">                if (uPoint.equals(vPoint) || !points.contains(vPoint)</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">                    || !excludePoints.contains(vPoint)) {</span>
<span class="nc" id="L2538">                    continue;</span>
                }
                
<span class="nc" id="L2541">                set.add(vPoint);</span>
            }
        }
        
<span class="nc" id="L2545">        return set;</span>
    }

    private void removeBinFactorArtifacts(Set&lt;PairInt&gt; points, int binFactor, 
        int pointsImageWidth, int pointsImageHeight,
        int pointsImageXOffset, int pointsImageYOffset) {
        
<span class="pc bpc" id="L2552" title="1 of 2 branches missed.">        if (binFactor == 0) {</span>
<span class="nc" id="L2553">            return;</span>
        }
        
<span class="fc" id="L2556">        int yLimit = (pointsImageHeight + pointsImageYOffset - 1);</span>
        
<span class="fc" id="L2558">        List&lt;PairInt&gt; remove = new ArrayList&lt;PairInt&gt;();</span>
        
        // making vertical corrections only
<span class="fc bfc" id="L2561" title="All 2 branches covered.">        for (PairInt p : points) {</span>
            
<span class="fc" id="L2563">            int x = p.getX();</span>
<span class="fc" id="L2564">            int y = p.getY();</span>
            
<span class="fc" id="L2566">            boolean isProtruding = true;</span>
            
<span class="fc bfc" id="L2568" title="All 2 branches covered.">            for (int i = 1; i &lt; 4; i++) {</span>
                                
<span class="fc" id="L2570">                int y2 = y + i;</span>
                
<span class="fc bfc" id="L2572" title="All 2 branches covered.">                if (y2 &gt; yLimit) {</span>
<span class="fc" id="L2573">                    isProtruding = false;</span>
<span class="fc" id="L2574">                    break;</span>
                }
                
<span class="fc" id="L2577">                PairInt p2 = new PairInt(x, y2);</span>
<span class="fc bfc" id="L2578" title="All 2 branches covered.">                if (!points.contains(p2)) {</span>
<span class="fc" id="L2579">                    isProtruding = false;</span>
<span class="fc" id="L2580">                    break;</span>
                }
            }
            
<span class="fc bfc" id="L2584" title="All 2 branches covered.">            if (isProtruding) {</span>
                
                // check that there is no point at i=5, enclosing the protrusion
<span class="fc" id="L2587">                PairInt p2 = new PairInt(x, y + 5);</span>
<span class="pc bpc" id="L2588" title="1 of 4 branches missed.">                if ((y &lt; yLimit) &amp;&amp; points.contains(p2)) {</span>
<span class="fc" id="L2589">                    continue;</span>
                }
<span class="fc bfc" id="L2591" title="All 2 branches covered.">                for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L2592">                    int y2 = y + i;</span>
<span class="fc" id="L2593">                    p2 = new PairInt(x, y2);</span>
<span class="fc" id="L2594">                    remove.add(p2);</span>
                }
            }
<span class="fc" id="L2597">        }</span>
        
<span class="fc bfc" id="L2599" title="All 2 branches covered.">        for (PairInt p : remove) {</span>
<span class="fc" id="L2600">            points.remove(p);</span>
<span class="fc" id="L2601">        }</span>
<span class="fc" id="L2602">    }</span>
                    
    private Set&lt;PairInt&gt; removeSetsWithNonCloudColors(List&lt;PairIntArray&gt; 
        zeroPointLists, Image originalColorImage, GreyscaleImage theta,
        boolean addAlongX, int addAmount) {
        
<span class="fc" id="L2608">        int colorLimit = 100;</span>
        
<span class="fc" id="L2610">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
       
<span class="fc" id="L2612">        int xOffset = theta.getXRelativeOffset();</span>
<span class="fc" id="L2613">        int yOffset = theta.getYRelativeOffset();</span>
        
<span class="fc bfc" id="L2615" title="All 2 branches covered.">        for (int gId = 0; gId &lt; zeroPointLists.size(); gId++) {</span>
            
<span class="fc" id="L2617">            PairIntArray points  = zeroPointLists.get(gId);</span>
            
<span class="fc" id="L2619">            int nBelowLimit = 0;</span>
<span class="fc" id="L2620">            int nBelowLimit2 = 0;</span>
<span class="fc" id="L2621">            int nBelowLimit3 = 0;</span>
            
<span class="fc bfc" id="L2623" title="All 2 branches covered.">            for (int i = 0; i &lt; points.getN(); i++) {</span>
                
<span class="fc" id="L2625">                int x = points.getX(i);</span>
<span class="fc" id="L2626">                int y = points.getY(i);</span>
                
<span class="fc" id="L2628">                int ox = x + xOffset;</span>
<span class="fc" id="L2629">                int oy = y + yOffset;</span>
                
<span class="pc bpc" id="L2631" title="1 of 2 branches missed.">                if (addAlongX) {</span>
<span class="fc" id="L2632">                    ox += addAmount;</span>
                } else {
<span class="nc" id="L2634">                    oy += addAmount;</span>
                }

<span class="pc bpc" id="L2637" title="2 of 4 branches missed.">                if ((ox &lt; 0) || (ox &gt; (originalColorImage.getWidth() - 1))) {</span>
<span class="nc" id="L2638">                    continue;</span>
                }
<span class="pc bpc" id="L2640" title="2 of 4 branches missed.">                if ((oy &lt; 0) || (oy &gt; (originalColorImage.getHeight() - 1))) {</span>
<span class="nc" id="L2641">                    continue;</span>
                }
                
<span class="fc" id="L2644">                int idx = originalColorImage.getInternalIndex(ox, oy);</span>
                
<span class="fc" id="L2646">                int r = originalColorImage.getR(idx);</span>
<span class="fc" id="L2647">                int g = originalColorImage.getG(idx);</span>
<span class="fc" id="L2648">                int b = originalColorImage.getB(idx);</span>

<span class="fc bfc" id="L2650" title="All 6 branches covered.">                if ((r &lt; colorLimit) &amp;&amp; (b &lt; colorLimit) &amp;&amp; (g &lt; colorLimit)) {</span>
<span class="fc" id="L2651">                    nBelowLimit++;</span>
                }
                // tracking color of sand
<span class="fc bfc" id="L2654" title="All 2 branches covered.">                if ((Math.abs((r/255.) - 0.35) &lt; .10) </span>
<span class="fc bfc" id="L2655" title="All 2 branches covered.">                    &amp;&amp; (Math.abs((g/255.) - 0.35) &lt; .10) </span>
<span class="fc bfc" id="L2656" title="All 4 branches covered.">                    &amp;&amp; (Math.abs((b/255.) - 0.35) &lt; .10)</span>
                    &amp;&amp; (b &lt; g)) {
<span class="fc" id="L2658">                    nBelowLimit2++;</span>
                }
                // TODO: there has to be a better way to filter green and cyan
                // green colors
<span class="fc bfc" id="L2662" title="All 2 branches covered.">                if ((Math.abs((r/255.) - 0.55) &lt; .05) </span>
<span class="fc bfc" id="L2663" title="All 2 branches covered.">                    &amp;&amp; (Math.abs((g/255.) - 0.62) &lt; .05) </span>
<span class="pc bpc" id="L2664" title="1 of 4 branches missed.">                    &amp;&amp; (Math.abs((b/255.) - 0.25) &lt; .05)</span>
                    &amp;&amp; (b &lt; g)) {
<span class="fc" id="L2666">                    nBelowLimit3++;</span>
<span class="fc bfc" id="L2667" title="All 4 branches covered.">                } else if (((g - r) &gt;= 20) &amp;&amp; ((g - b) &gt;= 20)) {</span>
<span class="fc" id="L2668">                    nBelowLimit3++;</span>
<span class="fc bfc" id="L2669" title="All 2 branches covered.">                } else if ((Math.abs((r/255.) - 0.25) &lt; .03) </span>
<span class="fc bfc" id="L2670" title="All 2 branches covered.">                    &amp;&amp; (Math.abs((g/255.) - 0.38) &lt; .05) </span>
<span class="pc bpc" id="L2671" title="1 of 4 branches missed.">                    &amp;&amp; (Math.abs((b/255.) - 0.40) &lt; .05)</span>
                    &amp;&amp; (g &gt; 80)) {
<span class="fc" id="L2673">                    nBelowLimit3++;</span>
<span class="fc bfc" id="L2674" title="All 2 branches covered.">                } else if ((Math.abs((r/255.) - 0.41) &lt; .03) </span>
<span class="fc bfc" id="L2675" title="All 2 branches covered.">                    &amp;&amp; (Math.abs((g/255.) - 0.48) &lt; .03) </span>
<span class="pc bpc" id="L2676" title="1 of 4 branches missed.">                    &amp;&amp; (Math.abs((b/255.) - 0.49) &lt; .03)</span>
                    &amp;&amp; (g &gt; 80)) {
<span class="fc" id="L2678">                    nBelowLimit3++;</span>
                }
            }
            
<span class="fc" id="L2682">            log.fine(gId + &quot;) nBelowLimit=&quot; + nBelowLimit</span>
<span class="fc" id="L2683">                + &quot; (&quot; + ((double)nBelowLimit/(double)points.getN()) + &quot;)&quot;);</span>
         
<span class="fc bfc" id="L2685" title="All 2 branches covered.">            if (((double)nBelowLimit/(double)points.getN()) &gt; 0.5) {</span>
                
<span class="fc" id="L2687">                remove.add(Integer.valueOf(gId));</span>
                
<span class="fc bfc" id="L2689" title="All 2 branches covered.">            } else if (((double)nBelowLimit2/(double)points.getN()) &gt; 0.5) {</span>
                
<span class="fc" id="L2691">                remove.add(Integer.valueOf(gId));</span>
                
<span class="fc bfc" id="L2693" title="All 2 branches covered.">            } else if (((double)nBelowLimit3/(double)points.getN()) &gt; 0.5) {</span>
                
<span class="fc" id="L2695">                remove.add(Integer.valueOf(gId));</span>
            }
        }
        
<span class="fc" id="L2699">        Set&lt;PairInt&gt; removed = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L2701" title="All 2 branches covered.">        if (!remove.isEmpty()) {</span>
            
<span class="fc bfc" id="L2703" title="All 2 branches covered.">            for (int i = (remove.size() - 1); i &gt; -1; i--) {</span>
                
<span class="fc" id="L2705">                PairIntArray r = zeroPointLists.remove(remove.get(i).intValue());</span>
                
<span class="fc bfc" id="L2707" title="All 2 branches covered.">                for (int ii = 0; ii &lt; r.getN(); ii++) {</span>
                    
<span class="fc" id="L2709">                    int x = r.getX(ii);</span>
<span class="fc" id="L2710">                    int y = r.getY(ii);</span>
<span class="fc" id="L2711">                    PairInt p = new PairInt(x, y);</span>

<span class="fc" id="L2713">                    removed.add(p);</span>
                }
            }
        }
        
<span class="fc" id="L2718">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L2720">        Set&lt;PairInt&gt; removed2 = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2721">        int[] dxs8 = Misc.dx8;</span>
<span class="fc" id="L2722">        int[] dys8 = Misc.dy8;</span>
        //any point in the image that is mostly surrounded by a point in remove
        // should be removed too.  this helps include pixels that did not get 
        // included in skypoints from the gradient image due to structure like
        // a ridge or cloud
<span class="fc bfc" id="L2727" title="All 2 branches covered.">        for (PairInt p : removed) {</span>
<span class="fc bfc" id="L2728" title="All 2 branches covered.">            for (int i = 0; i &lt; dxs8.length; ++i) {</span>
<span class="fc" id="L2729">                int vX = p.getX() + dxs8[i];</span>
<span class="fc" id="L2730">                int vY = p.getY() + dys8[i];                </span>
<span class="fc" id="L2731">                PairInt pV = new PairInt(vX, vY);</span>
<span class="fc bfc" id="L2732" title="All 2 branches covered.">                if (!removed.contains(pV)) {</span>
<span class="fc" id="L2733">                    int nNeighbors = curveHelper.countNeighbors(vX, vY, removed, </span>
<span class="fc" id="L2734">                        theta.getWidth(), theta.getHeight());</span>
<span class="fc bfc" id="L2735" title="All 2 branches covered.">                    if (nNeighbors &gt; 2) {</span>
<span class="fc" id="L2736">                        removed2.add(pV);</span>
                    }
                }
            }
<span class="fc" id="L2740">        }</span>
        
<span class="fc" id="L2742">        remove.clear();</span>
<span class="fc bfc" id="L2743" title="All 2 branches covered.">        for (int gId = 0; gId &lt; zeroPointLists.size(); gId++) {</span>
<span class="fc" id="L2744">            PairIntArray points  = zeroPointLists.get(gId);            </span>
<span class="fc bfc" id="L2745" title="All 2 branches covered.">            for (int i = 0; i &lt; points.getN(); i++) {</span>
<span class="fc" id="L2746">                int x = points.getX(i);</span>
<span class="fc" id="L2747">                int y = points.getY(i);</span>
<span class="fc" id="L2748">                PairInt p = new PairInt(x, y);</span>
<span class="pc bpc" id="L2749" title="1 of 2 branches missed.">                if (removed2.contains(p)) {</span>
<span class="nc" id="L2750">                    remove.add(Integer.valueOf(i));</span>
<span class="nc" id="L2751">                    break;</span>
                }
            }
        }
<span class="pc bpc" id="L2755" title="1 of 2 branches missed.">        for (int i = (remove.size() - 1); i &gt; -1; i--) {</span>
<span class="nc" id="L2756">            PairIntArray r = zeroPointLists.remove(remove.get(i).intValue());</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">            for (int ii = 0; ii &lt; r.getN(); ii++) {</span>
<span class="nc" id="L2758">                int x = r.getX(ii);</span>
<span class="nc" id="L2759">                int y = r.getY(ii);</span>
<span class="nc" id="L2760">                PairInt p = new PairInt(x, y);</span>
<span class="nc" id="L2761">                removed.add(p);</span>
            }
        }
<span class="fc" id="L2764">        removed.addAll(removed2);</span>
                
<span class="fc" id="L2766">        return removed;</span>
    }
    
    Set&lt;PairInt&gt; findEmbeddedNonPoints(Set&lt;PairInt&gt; points,
        Set&lt;PairInt&gt; exclude0, Set&lt;PairInt&gt; exclude1, int imageMaxColumn) {
        
<span class="nc" id="L2772">        Set&lt;PairInt&gt; embeddedPoints = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L2774">        PerimeterFinder finder = new PerimeterFinder();</span>
<span class="nc" id="L2775">        int[] rowMinMax = new int[2];</span>
<span class="nc" id="L2776">        Map&lt;Integer, List&lt;PairInt&gt;&gt; rowColRange = finder.find(points, </span>
            rowMinMax, imageMaxColumn, embeddedPoints);
        
<span class="nc bnc" id="L2779" title="All 2 branches missed.">        for (PairInt exclude : exclude0) {</span>
<span class="nc" id="L2780">            embeddedPoints.remove(exclude);</span>
<span class="nc" id="L2781">        }</span>
        
<span class="nc bnc" id="L2783" title="All 2 branches missed.">        for (PairInt exclude : exclude1) {</span>
<span class="nc" id="L2784">            embeddedPoints.remove(exclude);</span>
<span class="nc" id="L2785">        }</span>
        
<span class="nc" id="L2787">        return embeddedPoints;</span>
    }
    
    public Set&lt;PairInt&gt; findEmbeddedNonPoints(Set&lt;PairInt&gt; points, 
        int imageMaxColumn) {
        
<span class="nc" id="L2793">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>
        
<span class="nc" id="L2795">        int[] skyRowMinMax = new int[2];</span>
        
<span class="nc" id="L2797">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L2799">        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRange = </span>
<span class="nc" id="L2800">            perimeterFinder.find(points, </span>
            skyRowMinMax, imageMaxColumn, outputEmbeddedGapPoints);
        
<span class="nc" id="L2803">        return outputEmbeddedGapPoints;</span>
    }
    
    GreyscaleImage filterAndExtractSkyFromGradient(ImageExt colorImg, 
        GreyscaleImage thetaImg, GreyscaleImage gXYImg, int binFactor,
        Set&lt;PairInt&gt; outputSkyPoints, RemovedSets removedSets) {
        
<span class="fc" id="L2810">        ImageProcessor imageProcessor = new ImageProcessor();</span>

<span class="fc" id="L2812">        GreyscaleImage originalThetaImg = thetaImg.copyImage();</span>
        
<span class="pc bpc" id="L2814" title="1 of 2 branches missed.">        if (binFactor &gt; 1) {</span>
<span class="fc" id="L2815">            thetaImg = imageProcessor.binImage(thetaImg, binFactor);</span>
<span class="fc" id="L2816">            colorImg = imageProcessor.binImage(colorImg, binFactor);</span>
<span class="fc" id="L2817">            gXYImg = imageProcessor.binImage(gXYImg, binFactor);</span>
        }

<span class="fc" id="L2820">        List&lt;PairIntArray&gt; zeroPointLists = getSortedContiguousZeros(thetaImg);</span>
        
<span class="pc bpc" id="L2822" title="1 of 2 branches missed.">        if (zeroPointLists.isEmpty()) {</span>
<span class="nc" id="L2823">            return null;</span>
        }
      
<span class="fc" id="L2826">        Set&lt;PairInt&gt; removedNonCloudColors = removeSetsWithNonCloudColors(</span>
            zeroPointLists, colorImg, thetaImg, true, 0);
        
<span class="pc bpc" id="L2829" title="1 of 2 branches missed.">        if (zeroPointLists.isEmpty()) {</span>
<span class="nc" id="L2830">            return null;</span>
        }
        
        /*
        usually, the largest smooth component of the image is sky and for that
        case, one just needs to retain the largest contiguous list in
        zeroPointLists as the seed of the sky points from which to find
        the remaining sky points.
        
        For a case such as a large smooth foreground field that has colors 
        similar to sky, such as a featureless snow field, one needs to 
        use other information to distinguish which points are sky points.
        --&gt; this can be seen when all lists in zeroPointLists, that is all points
        in zeroPointLists have cie X and Y white.
        */
        
        //TODO. This method should one day allow user to see first guess at sky 
        // if in interactive mode then allow them to select sky location.
                
<span class="pc bpc" id="L2849" title="1 of 2 branches missed.">        if (useAlternateSkySeeds) {</span>
            
<span class="nc" id="L2851">            zeroPointLists = selectFromSkySeeds(zeroPointLists, colorImg, </span>
                thetaImg);
            
        } else {
            
            /*if all of the zero point lists are red, grow the red points.
            for example, can see for the mn or arizona image that the
            findRainbowColoredPoints finds the sky really well
            
            GroupPixelColors allSkyColor = new GroupPixelColors(points,
                colorImg, xOffset, yOffset);
            
            Set&lt;PairInt&gt; rainbowPoints = findRainbowColoredPoints(colorImg, 
            reflectedSunRemoved, xOffset, yOffset, skyIsDarkGrey);
            */

            //createDebugPlots(zeroPointLists, colorImg, thetaImg);

<span class="fc" id="L2869">            float[] cieX = new float[zeroPointLists.size()];</span>
<span class="fc" id="L2870">            float[] cieY = new float[zeroPointLists.size()];</span>
<span class="fc" id="L2871">            float[] rDIVRGB = new float[zeroPointLists.size()];</span>
<span class="fc" id="L2872">            float[] bDIVRGB = new float[zeroPointLists.size()];</span>

<span class="fc" id="L2874">            calculateAverageColors(zeroPointLists, colorImg, thetaImg, </span>
                cieX, cieY, rDIVRGB, bDIVRGB);        
            
            // if all are white, reduce to the bluest lists
<span class="fc" id="L2878">            boolean didReduce = reduceToBluestIfAllAreWhite(zeroPointLists, </span>
                cieX, cieY, rDIVRGB, bDIVRGB);
        
            /*if (!didReduce) {
                didReduce = reduceToReddestIfAllAreRed(zeroPointLists, 
                    cieX, cieY, rDIVRGB, bDIVRGB);
            }*/
            //TODO:  assumes that largest smooth component of image is sky.
            // if sky is small and a foreground object is large and featureless
            // and not found as dark, this will fail. 
            // will adjust for that one day, possibly with color validation
            //if (!didReduceToBluest) {
<span class="fc" id="L2890">                reduceToLargest(zeroPointLists);</span>
            //}
        }
        
<span class="pc bpc" id="L2894" title="1 of 2 branches missed.">        if (zeroPointLists.isEmpty()) {</span>
<span class="nc" id="L2895">            return null;</span>
        }
        
<span class="fc" id="L2898">        double[] avgYRGB = imageProcessor.calculateYRGB(zeroPointLists.get(0),</span>
            colorImg,
<span class="fc" id="L2900">            thetaImg.getXRelativeOffset(), thetaImg.getYRelativeOffset(),</span>
            true, 0);
        
<span class="fc" id="L2903">        int nBeforeHighContrastRemoval = count(zeroPointLists);</span>
        
<span class="fc" id="L2905">        Set&lt;PairInt&gt; highContrastRemoved = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2906">        removeHighContrastPoints(zeroPointLists, colorImg, </span>
            thetaImg, avgYRGB[0], highContrastRemoved);
  
<span class="pc bpc" id="L2909" title="1 of 2 branches missed.">        if (zeroPointLists.isEmpty()) {</span>
<span class="nc" id="L2910">            return null;</span>
        }

<span class="fc" id="L2913">        int nAfterHighContrastRemoval = count(zeroPointLists);</span>

<span class="fc" id="L2915">        Set&lt;PairInt&gt; reflectedSunRemoved = removeReflectedSun(zeroPointLists, </span>
            colorImg, thetaImg);
 
<span class="pc bpc" id="L2918" title="1 of 2 branches missed.">        if (zeroPointLists.isEmpty()) {</span>
<span class="nc" id="L2919">            return null;</span>
        }
        
<span class="fc" id="L2922">        combine(zeroPointLists, outputSkyPoints);</span>
        
<span class="fc" id="L2924">        removedSets.setHighContrastRemoved(highContrastRemoved);</span>
<span class="fc" id="L2925">        removedSets.setReflectedSunRemoved(reflectedSunRemoved);</span>
<span class="fc" id="L2926">        removedSets.setRemovedNonCloudColors(removedNonCloudColors);</span>
<span class="fc" id="L2927">        removedSets.setBeforeHighContrastRemoval(nBeforeHighContrastRemoval);</span>
<span class="fc" id="L2928">        removedSets.setAfterHighContrastRemoval(nAfterHighContrastRemoval);</span>
        
<span class="fc" id="L2930">        GreyscaleImage thresholdedGXY = extractSkyFromGradientXY(gXYImg);</span>
        
<span class="pc bpc" id="L2932" title="1 of 2 branches missed.">        if (binFactor &gt; 1) {</span>
            
<span class="fc" id="L2934">            Set&lt;PairInt&gt; tmp = imageProcessor.unbinZeroPointLists(</span>
                outputSkyPoints, binFactor);
<span class="fc" id="L2936">            outputSkyPoints.clear();</span>
<span class="fc" id="L2937">            outputSkyPoints.addAll(tmp);</span>
            
<span class="fc" id="L2939">            tmp = imageProcessor.unbinZeroPointLists(</span>
                removedNonCloudColors, binFactor);
<span class="fc" id="L2941">            removedSets.setRemovedNonCloudColors(tmp);</span>
            
<span class="fc" id="L2943">            tmp = imageProcessor.unbinZeroPointLists(</span>
                highContrastRemoved, binFactor);
<span class="fc" id="L2945">            removedSets.setHighContrastRemoved(tmp);</span>
            
<span class="fc" id="L2947">            tmp = imageProcessor.unbinZeroPointLists(</span>
                reflectedSunRemoved, binFactor);
<span class="fc" id="L2949">            removedSets.setReflectedSunRemoved(tmp);</span>
            
<span class="fc" id="L2951">            thresholdedGXY = imageProcessor.unbinMask(gXYImg, </span>
                binFactor, originalThetaImg);
            
<span class="fc bfc" id="L2954" title="All 2 branches covered.">            if (!highContrastRemoved.isEmpty()) {</span>
                                
<span class="fc" id="L2956">                removeBinFactorArtifacts(outputSkyPoints, binFactor,</span>
<span class="fc" id="L2957">                    originalThetaImg.getWidth(), originalThetaImg.getHeight(),</span>
<span class="fc" id="L2958">                    originalThetaImg.getXRelativeOffset(), </span>
<span class="fc" id="L2959">                    originalThetaImg.getYRelativeOffset());</span>
            }
        }
        
<span class="fc" id="L2963">        return thresholdedGXY;</span>
    }

    protected void addIfSimilarToSky(Set&lt;PairInt&gt; embeddedPoints, 
        Set&lt;PairInt&gt; skyPoints, Set&lt;PairInt&gt; highContrastRemoved, 
        ImageExt originalColorImage, int xOffset, int yOffset,
        HistogramHolder[] brightnessHistogram, 
        GroupPixelColors[] skyPartitionedByBrightness) {
        
<span class="fc" id="L2972">        Set&lt;PairInt&gt; excludePoints = highContrastRemoved;</span>
        
<span class="fc" id="L2974">        boolean pointsAreEmbeddedInSky = true;</span>
        
<span class="fc" id="L2976">        double rDivB = skyPartitionedByBrightness[2].getAvgRed() /</span>
<span class="fc" id="L2977">            skyPartitionedByBrightness[2].getAvgBlue();</span>

<span class="fc bfc" id="L2979" title="All 2 branches covered.">        boolean skyIsRed = (rDivB &gt; 1);</span>

<span class="fc bfc" id="L2981" title="All 4 branches covered.">        boolean skyIsPurple = skyIsRed &amp;&amp; (rDivB &lt; 1.5) &amp;&amp;</span>
<span class="fc" id="L2982">            (Math.abs(</span>
<span class="fc" id="L2983">                skyPartitionedByBrightness[2].getAvgGreen() -</span>
<span class="fc" id="L2984">                skyPartitionedByBrightness[2].getAvgBlue())</span>
                &lt;
<span class="fc bfc" id="L2986" title="All 2 branches covered.">                0.1 * skyPartitionedByBrightness[2].getAvgBlue()</span>
            );
<span class="fc" id="L2988">        boolean hasDarkGreyClouds = false;</span>
//only perform k=0 if the sky has a narrow dark section
<span class="fc" id="L2990">        boolean useKEqualsZero =</span>
<span class="fc bfc" id="L2991" title="All 2 branches covered.">            (skyPartitionedByBrightness[0].getStdDevGreen() &lt; 10) &amp;&amp;</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">            (skyPartitionedByBrightness[0].getStdDevBlue() &lt; 10) &amp;&amp;</span>
<span class="pc bpc" id="L2993" title="1 of 2 branches missed.">            (skyPartitionedByBrightness[0].getStdDevContrast() &lt; 10)</span>
<span class="fc bfc" id="L2994" title="All 2 branches covered.">            &amp;&amp; (skyPartitionedByBrightness[0].getStdDevColorDiff()</span>
            &lt; 10);
<span class="fc bfc" id="L2996" title="All 2 branches covered.">        if (useKEqualsZero) {</span>
<span class="fc bfc" id="L2997" title="All 2 branches covered.">            if (skyIsRed) {</span>
<span class="pc bpc" id="L2998" title="1 of 2 branches missed.">                useKEqualsZero = useKEqualsZero &amp;&amp;</span>
<span class="pc bpc" id="L2999" title="1 of 2 branches missed.">                (skyPartitionedByBrightness[0].getStdDevRed() &lt; 20);</span>
            } else {
<span class="pc bpc" id="L3001" title="1 of 2 branches missed.">                useKEqualsZero = useKEqualsZero &amp;&amp;</span>
<span class="fc bfc" id="L3002" title="All 2 branches covered.">                (skyPartitionedByBrightness[0].getStdDevRed() &lt; 10);</span>
            }
        } else {
<span class="fc bfc" id="L3005" title="All 2 branches covered.">            if (!skyIsRed) {</span>
                // if the sky is grey, may have dark clouds
<span class="fc bfc" id="L3007" title="All 2 branches covered.">                if (skyIsDarkGrey(skyPartitionedByBrightness[0])) {</span>
<span class="fc" id="L3008">                    useKEqualsZero = true;</span>
<span class="fc" id="L3009">                    hasDarkGreyClouds = true;</span>
                }
            }
        }
        
<span class="fc" id="L3014">        Set&lt;PairInt&gt; outputCloudPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L3015">        Stack&lt;PairInt&gt; outputStack = new java.util.Stack&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L3017" title="All 2 branches covered.">        for (PairInt embeddedPoint : embeddedPoints) {</span>

<span class="fc bfc" id="L3019" title="All 2 branches covered.">            if (excludePoints.contains(embeddedPoint)) {</span>

<span class="fc" id="L3021">                continue;</span>
            }

<span class="fc" id="L3024">            filterToAddCloudPixel(excludePoints, skyPoints, </span>
                originalColorImage, xOffset, yOffset, embeddedPoint,
                skyPartitionedByBrightness,
                skyIsRed, skyIsPurple, hasDarkGreyClouds, useKEqualsZero,
                pointsAreEmbeddedInSky,
                outputCloudPoints, outputStack
            );
<span class="fc" id="L3031">        }</span>
<span class="fc" id="L3032">        skyPoints.addAll(outputCloudPoints);</span>
<span class="fc" id="L3033">    }</span>
    
    private ANDedClauses[] filterForSkyColor(ANDedClauses[] clauses, 
        boolean skyIsRed) {
        
<span class="fc" id="L3038">        int n = 0;</span>
<span class="fc bfc" id="L3039" title="All 2 branches covered.">        for (int i = 0; i &lt; clauses.length; i++) {</span>
            
<span class="fc" id="L3041">            ANDedClauses c = clauses[i];</span>
            
<span class="fc bfc" id="L3043" title="All 2 branches covered.">            if (c.getSKYCONDITIONAL().ordinal() == SKYCONDITIONAL.ALL.ordinal()) {</span>
<span class="fc" id="L3044">                n++;</span>
<span class="fc bfc" id="L3045" title="All 2 branches covered.">            } else if (skyIsRed &amp;&amp; (c.getSKYCONDITIONAL().ordinal() == </span>
<span class="fc bfc" id="L3046" title="All 2 branches covered.">                SKYCONDITIONAL.RED.ordinal())) {</span>
<span class="fc" id="L3047">                n++;</span>
<span class="fc bfc" id="L3048" title="All 2 branches covered.">            } else if (!skyIsRed &amp;&amp; (c.getSKYCONDITIONAL().ordinal() == </span>
<span class="fc bfc" id="L3049" title="All 2 branches covered.">                SKYCONDITIONAL.BLUE.ordinal())) {</span>
<span class="fc" id="L3050">                n++;</span>
            }
        }
        
<span class="fc" id="L3054">        ANDedClauses[] filtered = new ANDedClauses[n];</span>
<span class="fc" id="L3055">        int ii = 0;</span>
<span class="fc bfc" id="L3056" title="All 2 branches covered.">        for (int i = 0; i &lt; clauses.length; i++) {</span>
            
<span class="fc" id="L3058">            ANDedClauses c = clauses[i];</span>
            
<span class="fc bfc" id="L3060" title="All 2 branches covered.">            if (c.getSKYCONDITIONAL().ordinal() == SKYCONDITIONAL.ALL.ordinal()) {</span>
<span class="fc" id="L3061">                filtered[ii] = c;</span>
<span class="fc" id="L3062">                ii++;</span>
<span class="fc bfc" id="L3063" title="All 2 branches covered.">            } else if (skyIsRed &amp;&amp; (c.getSKYCONDITIONAL().ordinal() == </span>
<span class="fc bfc" id="L3064" title="All 2 branches covered.">                SKYCONDITIONAL.RED.ordinal())) {</span>
<span class="fc" id="L3065">                filtered[ii] = c;</span>
<span class="fc" id="L3066">                ii++;</span>
<span class="fc bfc" id="L3067" title="All 2 branches covered.">            } else if (!skyIsRed &amp;&amp; (c.getSKYCONDITIONAL().ordinal() == </span>
<span class="fc bfc" id="L3068" title="All 2 branches covered.">                SKYCONDITIONAL.BLUE.ordinal())) {</span>
<span class="fc" id="L3069">                filtered[ii] = c;</span>
<span class="fc" id="L3070">                ii++;</span>
            }
        }
        
<span class="fc" id="L3074">        return filtered;</span>
    }

    protected void orderByIncreasingXThenY(Set&lt;PairInt&gt; points,
        DoubleLinkedCircularList outputDLCList, 
        Map&lt;Integer, HeapNode&gt; outputFirstXLocator) {

<span class="fc" id="L3081">        int[] x = new int[points.size()];</span>
<span class="fc" id="L3082">        int[] y = new int[x.length];</span>
<span class="fc" id="L3083">        int i = 0;</span>
<span class="fc bfc" id="L3084" title="All 2 branches covered.">        for (PairInt p : points) {</span>
<span class="fc" id="L3085">            x[i] = p.getX();</span>
<span class="fc" id="L3086">            y[i] = p.getY();</span>
<span class="fc" id="L3087">            i++;</span>
<span class="fc" id="L3088">        }</span>
        //O(N*lg_2(N))
<span class="fc" id="L3090">        MultiArrayMergeSort.sortBy1stArgThen2nd(x, y);</span>
        
        //O(N)
<span class="fc bfc" id="L3093" title="All 2 branches covered.">        for (i = 0; i &lt; x.length; ++i) {</span>
            
<span class="fc" id="L3095">            PairInt p = new PairInt(x[i], y[i]);</span>
            
<span class="fc" id="L3097">            HeapNode node = new HeapNode(i);</span>
<span class="fc" id="L3098">            node.setData(p);</span>
<span class="fc" id="L3099">            outputDLCList.insert(node);</span>
            
<span class="fc" id="L3101">            Integer xCoord = Integer.valueOf(p.getX());</span>
<span class="fc bfc" id="L3102" title="All 2 branches covered.">            if (!outputFirstXLocator.containsKey(xCoord)) {</span>
<span class="fc" id="L3103">                outputFirstXLocator.put(xCoord, node);</span>
            }
        }
<span class="fc" id="L3106">    }</span>

    protected void addEmbeddedIfSimilarToSky(Set&lt;PairInt&gt; points, 
        ImageExt originalColorImage, int xOffset, int yOffset, 
        RemovedSets removedSets) {
        
<span class="fc" id="L3112">        Set&lt;PairInt&gt; embeddedPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L3113">        getEmbeddedPoints(points, originalColorImage.getWidth(), </span>
<span class="fc" id="L3114">            originalColorImage.getHeight(),</span>
            embeddedPoints);
        
<span class="fc bfc" id="L3117" title="All 2 branches covered.">        if (embeddedPoints.isEmpty()) {</span>
<span class="fc" id="L3118">            return;</span>
        }
        
<span class="fc" id="L3121">        HistogramHolder[] brightnessHistogram = new HistogramHolder[1];</span>

        // brightest sky is in bin [2], and dimmest is in [0]
<span class="fc" id="L3124">        GroupPixelColors[] skyPartitionedByBrightness = </span>
<span class="fc" id="L3125">            partitionInto3ByBrightness(points, originalColorImage, </span>
            xOffset, yOffset, brightnessHistogram);

        // no need to update rowColRanges as this was not an external &quot;grow&quot;
        //add embedded pixels if they're near existing sky colors
<span class="fc" id="L3130">        addIfSimilarToSky(embeddedPoints, points, </span>
<span class="fc" id="L3131">            removedSets.getHighContrastRemoved(),</span>
            originalColorImage, xOffset, yOffset,
            brightnessHistogram, skyPartitionedByBrightness);        

<span class="fc" id="L3135">    }</span>

    private void createDebugPlots(List&lt;PairIntArray&gt; zeroPointLists, 
        ImageExt colorImg, GreyscaleImage thetaImg) {
        
        // scatter diagrams of cie X vs cie Y,  a plot of their (x,y) locations
        // for the image dimensions, and scatter diagram of red/total vs blue/total.
        
<span class="nc" id="L3143">        PolygonAndPointPlotter plotter = null;</span>
        try {
<span class="nc" id="L3145">            plotter = new PolygonAndPointPlotter();</span>
<span class="nc" id="L3146">        } catch (IOException e) {</span>
<span class="nc" id="L3147">        }</span>
        
<span class="nc" id="L3149">        int xOffset = thetaImg.getXRelativeOffset();</span>
<span class="nc" id="L3150">        int yOffset = thetaImg.getYRelativeOffset();</span>
<span class="nc" id="L3151">        int count = 0;</span>
<span class="nc bnc" id="L3152" title="All 2 branches missed.">        for (PairIntArray pai : zeroPointLists) {</span>
<span class="nc" id="L3153">            int n = pai.getN();</span>
<span class="nc" id="L3154">            float[] xP = new float[n];</span>
<span class="nc" id="L3155">            float[] yP = new float[n];</span>
<span class="nc" id="L3156">            float[] rDivTotal = new float[n];</span>
<span class="nc" id="L3157">            float[] bDivTotal = new float[n];</span>
<span class="nc" id="L3158">            CIEChromaticity cieC = new CIEChromaticity();</span>
<span class="nc" id="L3159">            float[] cieX = new float[n];</span>
<span class="nc" id="L3160">            float[] cieY = new float[n];</span>
<span class="nc bnc" id="L3161" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L3162">                int x = pai.getX(i) + xOffset;</span>
<span class="nc" id="L3163">                int y = pai.getY(i) + yOffset;</span>
                
<span class="nc" id="L3165">                xP[i] = x;</span>
<span class="nc" id="L3166">                yP[i] = y;</span>
                
<span class="nc" id="L3168">                int idx = colorImg.getInternalIndex(x, y);</span>
                
<span class="nc" id="L3170">                int r = colorImg.getR(idx);</span>
<span class="nc" id="L3171">                int g = colorImg.getG(idx);</span>
<span class="nc" id="L3172">                int b = colorImg.getB(idx);</span>
<span class="nc" id="L3173">                int rgbTotal = r + g + b;</span>
<span class="nc" id="L3174">                rDivTotal[i] = (float)r/(float)rgbTotal;</span>
<span class="nc" id="L3175">                bDivTotal[i] = (float)b/(float)rgbTotal;</span>
                
<span class="nc" id="L3177">                float[] cie = cieC.rgbToXYChromaticity(r, g, b);</span>
<span class="nc" id="L3178">                cieX[i] = cie[0];</span>
<span class="nc" id="L3179">                cieY[i] = cie[1];                </span>
            }
        
            // scatter diagrams of cie X vs cie Y,  a plot of their (x,y) locations
            // for the image dimensions, and scatter diagram of red/total vs blue/total.

<span class="nc" id="L3185">            plotter.addPlot(0.f, 1.f, 0.f, 1.f, cieX, cieY, </span>
                null, null, &quot;cie X vs cie Y (&quot; + count + &quot;)&quot;);

<span class="nc" id="L3188">            plotter.addPlot(0.f, 0.4f, 0.f, 0.4f, rDivTotal, bDivTotal, </span>
                null, null, &quot;R/RGB vs B/RGB (&quot; + count + &quot;)&quot;);

<span class="nc" id="L3191">            plotter.addPlot(0.f, colorImg.getWidth(), 0, colorImg.getHeight(), </span>
                xP, yP, null, null, &quot;x vs y (&quot; + count + &quot;)&quot;);

<span class="nc" id="L3194">            count++;</span>
<span class="nc" id="L3195">        }</span>
        
        try {
<span class="nc" id="L3198">            String fileName = plotter.writeFile(Integer.valueOf(700 + count));</span>

<span class="nc" id="L3200">            log.info(&quot;fileName=&quot; + fileName);</span>
        
<span class="nc" id="L3202">        } catch (IOException e) {</span>
<span class="nc" id="L3203">            Logger.getLogger(this.getClass().getName()).severe(e.getMessage());</span>
<span class="nc" id="L3204">        }    </span>
<span class="nc" id="L3205">    }</span>
    
    private void calculateAverageColors(List&lt;PairIntArray&gt; zeroPointLists, 
        ImageExt colorImg, GreyscaleImage thetaImg, 
        float[] outputCIEX, float[] outputCIEY, 
        float[] outputRDIVRGB, float[] outputBDIVRGB) {
        
<span class="fc" id="L3212">        int xOffset = thetaImg.getXRelativeOffset();</span>
<span class="fc" id="L3213">        int yOffset = thetaImg.getYRelativeOffset();</span>
<span class="fc" id="L3214">        int count = 0;</span>
<span class="fc" id="L3215">        CIEChromaticity cieC = new CIEChromaticity();</span>
<span class="fc bfc" id="L3216" title="All 2 branches covered.">        for (PairIntArray pai : zeroPointLists) {</span>
                        
<span class="fc" id="L3218">            double sumCIEX = 0;</span>
<span class="fc" id="L3219">            double sumCIEY = 0;</span>
<span class="fc" id="L3220">            double sumRDIVGRB = 0;</span>
<span class="fc" id="L3221">            double sumBDIVGRB = 0;</span>
            
<span class="fc" id="L3223">            int n = pai.getN();</span>
            
<span class="fc bfc" id="L3225" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L3226">                int x = pai.getX(i) + xOffset;</span>
<span class="fc" id="L3227">                int y = pai.getY(i) + yOffset;</span>
                                
<span class="fc" id="L3229">                int idx = colorImg.getInternalIndex(x, y);</span>
                
<span class="fc" id="L3231">                int r = colorImg.getR(idx);</span>
<span class="fc" id="L3232">                int g = colorImg.getG(idx);</span>
<span class="fc" id="L3233">                int b = colorImg.getB(idx);</span>
                
<span class="fc" id="L3235">                sumRDIVGRB += ((double)r/(r + g + b));</span>
<span class="fc" id="L3236">                sumBDIVGRB += ((double)b/(r + g + b));</span>
                
<span class="fc" id="L3238">                float[] cie = cieC.rgbToXYChromaticity(r, g, b);</span>
<span class="fc bfc" id="L3239" title="All 4 branches covered.">                if (cie[0] &lt; 0.2 || cie[1] &lt; 0.2) {</span>
<span class="fc" id="L3240">                    int z = 1;</span>
                }
<span class="fc" id="L3242">                sumCIEX += cie[0];</span>
<span class="fc" id="L3243">                sumCIEY += cie[1];</span>
            }
<span class="fc" id="L3245">            outputCIEX[count] = (float)(sumCIEX/(float)n);</span>
<span class="fc" id="L3246">            outputCIEY[count] = (float)(sumCIEY/(float)n);</span>
            
<span class="fc" id="L3248">            outputRDIVRGB[count] = (float)(sumRDIVGRB/(float)n);</span>
<span class="fc" id="L3249">            outputBDIVRGB[count] = (float)(sumBDIVGRB/(float)n);</span>
            
<span class="fc" id="L3251">            count++;</span>
<span class="fc" id="L3252">        }</span>
<span class="fc" id="L3253">    }</span>

    private boolean reduceToBluestIfAllAreWhite(List&lt;PairIntArray&gt; zeroPointLists, 
        float[] cieX, float[] cieY, float[] rDIVRGB, float[] bDIVRGB) {
        
        //TODO: may need to revise the ranges here
<span class="fc" id="L3259">        boolean allAreWhite = true;</span>
<span class="fc bfc" id="L3260" title="All 2 branches covered.">        for (int i = 0; i &lt; cieX.length; i++) {</span>
<span class="fc" id="L3261">            float x = cieX[i];</span>
<span class="fc" id="L3262">            float y = cieY[i];</span>
<span class="fc" id="L3263">            float xDivY = x/y;</span>
<span class="pc bpc" id="L3264" title="1 of 6 branches missed.">            if (!((x &gt;= 0.23) &amp;&amp; (x &lt;= 0.43) &amp;&amp; (Math.abs(xDivY - 1) &lt; 0.2))){</span>
<span class="fc" id="L3265">                allAreWhite = false;</span>
<span class="fc" id="L3266">                break;</span>
            }
<span class="pc bpc" id="L3268" title="1 of 4 branches missed.">            if ((x &gt; 0.33) &amp;&amp; (y &lt; 0.28)) {</span>
<span class="nc" id="L3269">                allAreWhite = false;</span>
<span class="nc" id="L3270">                break;</span>
            }
<span class="pc bpc" id="L3272" title="2 of 6 branches missed.">            if ((x &gt; 0.25) &amp; (y &lt; 0.2)) {</span>
<span class="nc" id="L3273">                allAreWhite = false;</span>
<span class="nc" id="L3274">                break;</span>
            }
        }
<span class="fc bfc" id="L3277" title="All 2 branches covered.">        if (!allAreWhite) {</span>
<span class="fc" id="L3278">            return false;</span>
        }
        
        // Looking for differences between a snow field and clouds.
        // The Warren 1982 paper suggests that snow will have a redder slope
        // over the optical bandpass than optically thick clouds.  
        // The optically thick clouds will be grey if not slightly blue.
        
<span class="fc" id="L3286">        HistogramHolder bHist = Histogram.createSimpleHistogram(3,</span>
<span class="fc" id="L3287">            bDIVRGB, Errors.populateYErrorsBySqrt(bDIVRGB));</span>
<span class="fc" id="L3288">        log.info(&quot;bHist y=&quot; + Arrays.toString(bHist.getYHist()) </span>
<span class="fc" id="L3289">            + &quot; x=&quot; + Arrays.toString(bHist.getXHist()));</span>
        
        /*try {
            bHist.plotHistogram(&quot;blueHist&quot;, 8001);
        } catch (IOException e) {
        }*/
        
<span class="fc" id="L3296">        List&lt;PairIntArray&gt; keep = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc" id="L3297">        float limit = 0.5f*(bHist.getXHist()[1] + bHist.getXHist()[0]);</span>
<span class="fc bfc" id="L3298" title="All 2 branches covered.">        for (int i = 0; i &lt; bDIVRGB.length; i++) {</span>
<span class="fc bfc" id="L3299" title="All 2 branches covered.">            if (bDIVRGB[i] &gt;= limit) {</span>
<span class="fc" id="L3300">                keep.add(zeroPointLists.get(i));</span>
            }
        }
        
<span class="fc" id="L3304">        zeroPointLists.clear();</span>
<span class="fc" id="L3305">        zeroPointLists.addAll(keep);</span>
        
<span class="fc" id="L3307">        return true;</span>
    }

    private boolean reduceToReddestIfAllAreRed(List&lt;PairIntArray&gt; zeroPointLists, 
        float[] cieX, float[] cieY, float[] rDIVRGB, float[] bDIVRGB) {
        
        //TODO: may need to revise the ranges here
<span class="nc" id="L3314">        boolean allAreRed = true;</span>
<span class="nc bnc" id="L3315" title="All 2 branches missed.">        for (int i = 0; i &lt; cieX.length; i++) {</span>
<span class="nc" id="L3316">            float rDividedRGB = rDIVRGB[i];</span>
<span class="nc" id="L3317">            float bDividedRGB = bDIVRGB[i];</span>
<span class="nc bnc" id="L3318" title="All 4 branches missed.">            if (!((rDividedRGB &gt; 0.5) &amp;&amp; (bDividedRGB &lt; 0.25))){</span>
<span class="nc" id="L3319">                allAreRed = false;</span>
<span class="nc" id="L3320">                break;</span>
            }
        }
<span class="nc bnc" id="L3323" title="All 2 branches missed.">        if (!allAreRed) {</span>
<span class="nc" id="L3324">            return false;</span>
        }
        /*
        HistogramHolder bHist = Histogram.createSimpleHistogram(3,
            bDIVRGB, Errors.populateYErrorsBySqrt(bDIVRGB));
        log.info(&quot;bHist y=&quot; + Arrays.toString(bHist.getYHist()) 
            + &quot; x=&quot; + Arrays.toString(bHist.getXHist()));
        
        try {
            bHist.plotHistogram(&quot;blueHist&quot;, 8001);
        } catch (IOException e) {
        }*/
        
       /* List&lt;PairIntArray&gt; keep = new ArrayList&lt;PairIntArray&gt;();
        float limit = 0.5f*(bHist.getXHist()[1] + bHist.getXHist()[0]);
        for (int i = 0; i &lt; bDIVRGB.length; i++) {
            if (bDIVRGB[i] &gt;= limit) {
                keep.add(zeroPointLists.get(i));
            }
        }
        
        zeroPointLists.clear();
        zeroPointLists.addAll(keep);
        */
<span class="nc" id="L3348">        return true;</span>
    }
    
    protected int addImageBoundaryEmbeddedSkyIfSimilar(Set&lt;PairInt&gt; skyPoints, 
        Set&lt;PairInt&gt; exclude, ImageExt originalColorImage, int xOffset,
        int yOffset, RemovedSets removedSets, boolean foundSun) {
        
<span class="fc" id="L3355">        int nSkyBefore = skyPoints.size();</span>
        
<span class="fc" id="L3357">        int width = originalColorImage.getWidth();</span>
<span class="fc" id="L3358">        int height = originalColorImage.getHeight();</span>
        
<span class="fc" id="L3360">        GroupPixelColors allSkyColor = new GroupPixelColors(skyPoints,</span>
            originalColorImage, xOffset, yOffset);
        
<span class="fc" id="L3363">        boolean skyIsDarkGrey = skyIsDarkGrey(allSkyColor);</span>
        
<span class="fc" id="L3365">        double rDivB = allSkyColor.getAvgRed() / allSkyColor.getAvgBlue();</span>
<span class="fc bfc" id="L3366" title="All 6 branches covered.">        if (!skyIsDarkGrey &amp;&amp; (rDivB &gt; 1) &amp;&amp; !foundSun) {</span>
            
<span class="fc" id="L3368">            Set&lt;PairInt&gt; exclude2 = new HashSet&lt;PairInt&gt;(exclude);</span>
<span class="fc" id="L3369">            exclude2.addAll(removedSets.getRemovedNonCloudColors());</span>
            
<span class="fc" id="L3371">            RainbowFinder rf = new RainbowFinder();</span>
<span class="fc" id="L3372">            Set&lt;PairInt&gt; rainbowColoredPoints = rf.findRainbowColoredPoints(</span>
                originalColorImage, exclude2, xOffset, yOffset, skyIsDarkGrey);
            
            // if comparable or larger in number than skyPoints, probably is sky
<span class="fc bfc" id="L3376" title="All 2 branches covered.">            if (rainbowColoredPoints.size() &gt;= skyPoints.size()) {</span>
                // keep the rainbow colored points that are contiguous group
                // containing skyPoints
<span class="fc" id="L3379">                DFSConnectedGroupsFinder groupsFinder = new DFSConnectedGroupsFinder();</span>
<span class="fc" id="L3380">                groupsFinder.findConnectedPointGroups(rainbowColoredPoints, width, height);</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">                for (int i = 0; i &lt; groupsFinder.getNumberOfGroups(); ++i) {</span>
<span class="fc" id="L3382">                    Set&lt;PairInt&gt; group = groupsFinder.getXY(i);</span>
<span class="fc" id="L3383">                    boolean keep = false;</span>
<span class="fc bfc" id="L3384" title="All 2 branches covered.">                    for (PairInt p : group) {</span>
<span class="pc bpc" id="L3385" title="1 of 4 branches missed.">                        if (!exclude2.contains(p) &amp;&amp; skyPoints.contains(p)) {</span>
<span class="fc" id="L3386">                            keep = true;</span>
<span class="fc" id="L3387">                            break;</span>
                        }
<span class="fc" id="L3389">                    }</span>
<span class="fc bfc" id="L3390" title="All 2 branches covered.">                    if (keep) {</span>
<span class="fc" id="L3391">                        skyPoints.addAll(group);</span>
                    }
                }
/*
try {
    Image img1 = new Image(width, height);
    ImageIOHelper.addToImage(rainbowColoredPoints, 0, 0, img1);
    ImageIOHelper.writeOutputImage(ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/rainbowcolored.png&quot;, img1);
} catch (IOException ex) {
    log.severe(ex.getMessage());
}
try {
    Image img1 = new Image(width, height);
    ImageIOHelper.addToImage(skyPoints, 0, 0, img1);
    ImageIOHelper.writeOutputImage(ResourceFinder.findDirectory(&quot;bin&quot;) + &quot;/skypoints.png&quot;, img1);
} catch (IOException ex) {
    log.severe(ex.getMessage());
}*/
<span class="fc" id="L3409">                return (skyPoints.size() - nSkyBefore);</span>
            }
        }
        
<span class="fc" id="L3413">        PerimeterFinder perimeterFinder = new PerimeterFinder();</span>

<span class="fc" id="L3415">        int imageMaxColumn = width - 1;</span>
<span class="fc" id="L3416">        int imageMaxRow = height - 1;</span>
       
<span class="fc" id="L3418">        int[] skyRowMinMax = new int[2];</span>
        
<span class="fc" id="L3420">        Set&lt;PairInt&gt; embeddedPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L3421">        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRanges = perimeterFinder.find(</span>
            skyPoints, skyRowMinMax, imageMaxColumn, embeddedPoints);
        
<span class="fc" id="L3424">        int nEmbeddedBefore = embeddedPoints.size();</span>
        
<span class="fc" id="L3426">        fillInImageBoundaryGapsIfBoundedBySky(skyRowColRanges, skyRowMinMax,</span>
            width, height);
        
<span class="fc" id="L3429">        embeddedPoints = perimeterFinder.findEmbeddedGivenRowData(skyRowMinMax, </span>
            width - 1, skyRowColRanges);
        
<span class="fc bfc" id="L3432" title="All 2 branches covered.">        if (embeddedPoints.isEmpty()) {</span>
<span class="fc" id="L3433">            return 0;</span>
        }          
        
        //TODO: revisit this with more test images
<span class="fc" id="L3437">        float maxPossibleFracNewDivSky =</span>
<span class="fc" id="L3438">            ((float)(skyPoints.size() + embeddedPoints.size())/((float)(width * height)));</span>
<span class="fc bfc" id="L3439" title="All 2 branches covered.">        if (maxPossibleFracNewDivSky &gt; 0.75) {</span>
<span class="fc" id="L3440">            return 0;</span>
        }
        
<span class="fc" id="L3443">        float fracNewDivSky = (float)embeddedPoints.size()/(float)skyPoints.size();</span>
        //AZ        0.0070258044  &lt;== small amount helpful
        //rainbow   0.048877604
        //patagonia 0.45363995    &lt;== HELPFUL
        //rainier   0.080801226   &lt;== adding covers the entire image.  DO NOT USE FOR THIS
<span class="fc" id="L3448">        log.info(&quot;fracNewDivSky=&quot; + fracNewDivSky </span>
            + &quot; nEmbeddedBefore=&quot; + nEmbeddedBefore 
<span class="fc" id="L3450">            + &quot; embedded=&quot; + embeddedPoints.size() </span>
<span class="fc" id="L3451">            + &quot; nSky/nTotal=&quot; + ((float)skyPoints.size()/((float)(width * height)))</span>
            + &quot; (nSky + nEmbeded)/nTotal=&quot; 
<span class="fc" id="L3453">            + ((float)(skyPoints.size() + embeddedPoints.size())/((float)(width * height)))</span>
            + &quot; &quot; + debugName);
        
<span class="fc" id="L3456">        HistogramHolder[] brightnessHistogram = new HistogramHolder[1];</span>

        // brightest sky is in bin [2], and dimmest is in [0]
<span class="fc" id="L3459">        GroupPixelColors[] skyPartitionedByBrightness = </span>
<span class="fc" id="L3460">            partitionInto3ByBrightness(skyPoints, originalColorImage, </span>
            xOffset, yOffset, brightnessHistogram);

        // no need to update rowColRanges as this was not an external &quot;grow&quot;
        //add embedded pixels if they're near existing sky colors
<span class="fc" id="L3465">        addIfSimilarToSky(embeddedPoints, skyPoints, </span>
<span class="fc" id="L3466">            removedSets.getHighContrastRemoved(),</span>
            originalColorImage, xOffset, yOffset,
            brightnessHistogram, skyPartitionedByBrightness);
        
<span class="fc" id="L3470">        return (skyPoints.size() - nSkyBefore);</span>
    }

    private void fillInImageBoundaryGapsIfBoundedBySky(
        Map&lt;Integer, List&lt;PairInt&gt;&gt; skyRowColRanges, int[] skyRowMinMax, 
        int width, int height) {
        
<span class="fc" id="L3477">        int imageMaxColumn = width - 1;</span>
<span class="fc" id="L3478">        int imageMaxRow = height - 1;</span>
        
        // follow skyRowColRanges around image boundary to see if there gaps
        // on the bounds of the image.
        // Use a &quot;fudge&quot; to gather those image boundary touching pixels that
        //    are not in skyPoints and find the embedded among them then
        //    those that look like sky points:
        
        // ---- fill in any gaps in columns in top row if top row is 0 -----
<span class="fc bfc" id="L3487" title="All 2 branches covered.">        if (skyRowMinMax[0] == 0) {</span>
            
<span class="fc" id="L3489">            List&lt;PairInt&gt; rowColRanges = skyRowColRanges.get(Integer.valueOf(0));</span>
            
<span class="fc bfc" id="L3491" title="All 2 branches covered.">            if (rowColRanges.size() &gt; 1) {</span>
<span class="fc" id="L3492">                rowColRanges.get(0).setY(rowColRanges.get(</span>
<span class="fc" id="L3493">                    rowColRanges.size() - 1).getY());</span>
<span class="fc bfc" id="L3494" title="All 2 branches covered.">                for (int i = rowColRanges.size() - 1; i &gt; 0; i--) {</span>
<span class="fc" id="L3495">                    rowColRanges.remove(i);</span>
                }
            }
            
<span class="pc bpc" id="L3499" title="1 of 2 branches missed.">            if (!rowColRanges.isEmpty()) {</span>
                // fill in corners if the gap along that image boundary column
                // is bounded at a higher row.
<span class="fc" id="L3502">                boolean fillInLeftCorner = false;</span>
<span class="fc bfc" id="L3503" title="All 2 branches covered.">                if (rowColRanges.get(0).getX() &gt; 0) {</span>
                    // ascend rows to see if any have first colRange starting at 0
<span class="fc bfc" id="L3505" title="All 2 branches covered.">                    for (int row = skyRowMinMax[0] + 1; row &lt;= skyRowMinMax[1]; row++) {</span>
<span class="fc" id="L3506">                        List&lt;PairInt&gt; rcr = skyRowColRanges.get(Integer.valueOf(row));</span>
                        
<span class="pc bpc" id="L3508" title="1 of 4 branches missed.">                        if (!rcr.isEmpty() &amp;&amp; (rcr.get(0).getX() == 0)) {</span>
<span class="fc" id="L3509">                            fillInLeftCorner = true;</span>
<span class="fc" id="L3510">                            break;</span>
                        }
                    }
                }
<span class="fc bfc" id="L3514" title="All 2 branches covered.">                if (fillInLeftCorner) {</span>
<span class="fc" id="L3515">                    rowColRanges.get(0).setX(0);</span>
                }
            
<span class="fc" id="L3518">                boolean fillInRightCorner = false;</span>
<span class="fc bfc" id="L3519" title="All 2 branches covered.">                if (rowColRanges.get(rowColRanges.size() - 1).getY() &lt; imageMaxColumn) {</span>
                    // ascend rows to see if any have last colRange == imageMaxColumn
<span class="fc bfc" id="L3521" title="All 2 branches covered.">                    for (int row = skyRowMinMax[0] + 1; row &lt;= skyRowMinMax[1]; row++) {</span>
<span class="fc" id="L3522">                        List&lt;PairInt&gt; rcr = skyRowColRanges.get(Integer.valueOf(row));                        </span>
<span class="pc bpc" id="L3523" title="1 of 2 branches missed.">                        if (!rcr.isEmpty() &amp;&amp; </span>
<span class="fc bfc" id="L3524" title="All 2 branches covered.">                            (rcr.get(rcr.size() - 1).getY() == imageMaxColumn)) {</span>
<span class="fc" id="L3525">                            fillInRightCorner = true;</span>
<span class="fc" id="L3526">                            break;</span>
                        }
                    }
                }
<span class="fc bfc" id="L3530" title="All 2 branches covered.">                if (fillInRightCorner) {</span>
<span class="fc" id="L3531">                    rowColRanges.get(rowColRanges.size() - 1).setY(imageMaxColumn);</span>
                }
            }
        }
        
        // ---- fill in any gaps in columns in bottom row if top row is imageMaxRow -----
<span class="fc bfc" id="L3537" title="All 2 branches covered.">        if (skyRowMinMax[1] == imageMaxRow) {</span>
            
<span class="fc" id="L3539">            List&lt;PairInt&gt; rowColRanges = skyRowColRanges.get(</span>
<span class="fc" id="L3540">                Integer.valueOf(imageMaxRow));</span>
            
<span class="fc bfc" id="L3542" title="All 2 branches covered.">            if (rowColRanges.size() &gt; 1) {</span>
<span class="fc" id="L3543">                rowColRanges.get(0).setY(rowColRanges.get(</span>
<span class="fc" id="L3544">                    rowColRanges.size() - 1).getY());</span>
<span class="fc bfc" id="L3545" title="All 2 branches covered.">                for (int i = rowColRanges.size() - 1; i &gt; 0; i--) {</span>
<span class="fc" id="L3546">                    rowColRanges.remove(i);</span>
                }
            }
            
<span class="pc bpc" id="L3550" title="1 of 2 branches missed.">            if (!rowColRanges.isEmpty()) {</span>
                
                // fill in corners if the gap along that image boundary column
                // is bounded at a higher row.
<span class="fc" id="L3554">                boolean fillInLeftCorner = false;</span>
<span class="fc bfc" id="L3555" title="All 2 branches covered.">                if (rowColRanges.get(0).getX() &gt; 0) {</span>
                    // ascend rows to see if any have first colRange starting at 0
<span class="fc bfc" id="L3557" title="All 2 branches covered.">                    for (int row = skyRowMinMax[1] - 1; row &gt; skyRowMinMax[0]; row--) {</span>
<span class="fc" id="L3558">                        List&lt;PairInt&gt; rcr = skyRowColRanges.get(Integer.valueOf(row));                        </span>
<span class="pc bpc" id="L3559" title="1 of 4 branches missed.">                        if (!rcr.isEmpty() &amp;&amp; (rcr.get(0).getX() == 0)) {</span>
<span class="fc" id="L3560">                            fillInLeftCorner = true;</span>
<span class="fc" id="L3561">                            break;</span>
                        }
                    }
                }
<span class="fc bfc" id="L3565" title="All 2 branches covered.">                if (fillInLeftCorner) {</span>
<span class="fc" id="L3566">                    rowColRanges.get(0).setX(0);</span>
                }
            
<span class="fc" id="L3569">                boolean fillInRightCorner = false;</span>
<span class="fc bfc" id="L3570" title="All 2 branches covered.">                if (rowColRanges.get(rowColRanges.size() - 1).getY() &lt; imageMaxColumn) {</span>
                    // ascend rows to see if any have last colRange == imageMaxColumn
<span class="fc bfc" id="L3572" title="All 2 branches covered.">                    for (int row = skyRowMinMax[1] - 1; row &gt; skyRowMinMax[0]; row--) {</span>
<span class="fc" id="L3573">                        List&lt;PairInt&gt; rcr = skyRowColRanges.get(Integer.valueOf(row));</span>
<span class="pc bpc" id="L3574" title="1 of 2 branches missed.">                        if (!rcr.isEmpty() &amp;&amp; (</span>
<span class="fc bfc" id="L3575" title="All 2 branches covered.">                            rcr.get(rcr.size() - 1).getY() == imageMaxColumn)) {</span>
<span class="fc" id="L3576">                            fillInRightCorner = true;</span>
<span class="fc" id="L3577">                            break;</span>
                        }
                    }
                }
<span class="fc bfc" id="L3581" title="All 2 branches covered.">                if (fillInRightCorner) {</span>
<span class="fc" id="L3582">                    rowColRanges.get(rowColRanges.size() - 1).setY(imageMaxColumn);</span>
                }
            }
        }
        
        // --- fill in leftmost and rightmost image column gaps if bounded by sky ---
<span class="fc" id="L3588">        int minRowForFirstColumn = Integer.MAX_VALUE;</span>
<span class="fc" id="L3589">        int maxRowForFirstColumn = Integer.MIN_VALUE;</span>
<span class="fc" id="L3590">        int minRowForLastColumn = Integer.MAX_VALUE;</span>
<span class="fc" id="L3591">        int maxRowForLastColumn = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L3592" title="All 2 branches covered.">        for (int row = skyRowMinMax[0]; row &lt;= skyRowMinMax[1]; row++) {</span>
<span class="fc" id="L3593">            List&lt;PairInt&gt; rowColRanges = skyRowColRanges.get(Integer.valueOf(row));</span>
<span class="pc bpc" id="L3594" title="1 of 2 branches missed.">            if (rowColRanges.isEmpty()) {</span>
<span class="nc" id="L3595">                continue;</span>
            }
<span class="fc" id="L3597">            int firstColRangeX = rowColRanges.get(0).getX();</span>
<span class="fc" id="L3598">            int lastColRangeY = rowColRanges.get(rowColRanges.size() - 1).getY();</span>
<span class="fc bfc" id="L3599" title="All 2 branches covered.">            if (firstColRangeX == 0) {</span>
<span class="fc bfc" id="L3600" title="All 2 branches covered.">                if (row &lt; minRowForFirstColumn) {</span>
<span class="fc" id="L3601">                    minRowForFirstColumn = row;</span>
                }
<span class="pc bpc" id="L3603" title="1 of 2 branches missed.">                if (row &gt; maxRowForFirstColumn) {</span>
<span class="fc" id="L3604">                    maxRowForFirstColumn = row;</span>
                }
            }
<span class="fc bfc" id="L3607" title="All 2 branches covered.">            if (lastColRangeY == imageMaxColumn) {</span>
<span class="fc bfc" id="L3608" title="All 2 branches covered.">                if (row &lt; minRowForLastColumn) {</span>
<span class="fc" id="L3609">                    minRowForLastColumn = row;</span>
                }
<span class="pc bpc" id="L3611" title="1 of 2 branches missed.">                if (row &gt; maxRowForLastColumn) {</span>
<span class="fc" id="L3612">                    maxRowForLastColumn = row;</span>
                }
            }
        }
<span class="pc bpc" id="L3616" title="1 of 4 branches missed.">        if ((minRowForFirstColumn != Integer.MAX_VALUE) &amp;&amp;</span>
            (maxRowForFirstColumn != Integer.MIN_VALUE)) {
            
<span class="fc bfc" id="L3619" title="All 2 branches covered.">            for (int row = minRowForFirstColumn; row &lt;= maxRowForFirstColumn; row++) {</span>
                
<span class="fc" id="L3621">                List&lt;PairInt&gt; rowColRanges = skyRowColRanges.get(Integer.valueOf(row));</span>
                
<span class="pc bpc" id="L3623" title="1 of 2 branches missed.">                if (rowColRanges.isEmpty()) {</span>
<span class="nc" id="L3624">                    rowColRanges.add(new PairInt(0, 0));</span>
                } else {
<span class="fc" id="L3626">                    rowColRanges.get(0).setX(0);</span>
                }
            }
        }
<span class="pc bpc" id="L3630" title="1 of 4 branches missed.">        if ((minRowForLastColumn != Integer.MAX_VALUE) &amp;&amp;</span>
            (maxRowForLastColumn != Integer.MIN_VALUE)) {
            
<span class="fc bfc" id="L3633" title="All 2 branches covered.">            for (int row = minRowForLastColumn; row &lt;= maxRowForLastColumn; row++) {</span>
                
<span class="fc" id="L3635">                List&lt;PairInt&gt; rowColRanges = skyRowColRanges.get(Integer.valueOf(row));</span>
                
<span class="pc bpc" id="L3637" title="1 of 2 branches missed.">                if (rowColRanges.isEmpty()) {</span>
<span class="nc" id="L3638">                    rowColRanges.add(new PairInt(imageMaxColumn, imageMaxColumn));</span>
                } else {
<span class="fc" id="L3640">                    rowColRanges.get(rowColRanges.size() - 1).setY(imageMaxColumn);</span>
                }
            }
        }
<span class="fc" id="L3644">    }</span>

    /**
     * a placeholder for ability to select the seeds of the sky from the
     * zeroPointLists.  This might allow user interaction in the future.
     * 
     * 
     * @param zeroPointLists
     * @param colorImg
     * @param thetaImg
     * @return 
     */
    protected List&lt;PairIntArray&gt; selectFromSkySeeds(
        List&lt;PairIntArray&gt; zeroPointLists, ImageExt colorImg, 
        GreyscaleImage thetaImg) {
        
<span class="nc" id="L3660">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    protected List&lt;PairIntArray&gt; extractAndSmoothSkylinePoints(
        Set&lt;PairInt&gt; skyPoints, GreyscaleImage gradientXY) {
        
        /*
        could use border points directly followed by a line thinner 
        and then the EdgeExtractorWithJunctions, but
        a smoother curve is produced using a gradient produced from the
        mask (that is use a CannyEdgeDetector) followed by a line thinner 
        and then the EdgeExtractorWithJunctions.
        */

<span class="fc" id="L3674">        boolean useGradient = true;</span>
        
<span class="pc bpc" id="L3676" title="1 of 2 branches missed.">        if (useGradient) {</span>
            
<span class="fc" id="L3678">            GreyscaleImage mask = gradientXY.createWithDimensions();</span>
<span class="fc" id="L3679">            mask.fill(250);</span>
<span class="fc bfc" id="L3680" title="All 2 branches covered.">            for (PairInt p : skyPoints) {</span>
<span class="fc" id="L3681">                int x = p.getX();</span>
<span class="fc" id="L3682">                int y = p.getY(); </span>
<span class="fc" id="L3683">                mask.setValue(x, y, 0);</span>
<span class="fc" id="L3684">            }</span>

<span class="fc" id="L3686">            CannyEdgeFilter cFilter = new CannyEdgeFilter();</span>
<span class="fc" id="L3687">            cFilter.applyFilter(mask);</span>

<span class="fc" id="L3689">            IEdgeExtractor edgeExtractor = new EdgeExtractorWithJunctions(mask);</span>
<span class="fc" id="L3690">            edgeExtractor.removeShorterEdges(true);</span>
<span class="fc" id="L3691">            List&lt;PairIntArray&gt; edges = edgeExtractor.findEdges();</span>

            // transform the coordinates back into the reference frame of gradientXY
<span class="fc bfc" id="L3694" title="All 2 branches covered.">            for (PairIntArray edge : edges) {</span>
<span class="fc bfc" id="L3695" title="All 2 branches covered.">                for (int i = 0; i &lt; edge.getN(); ++i) {</span>
<span class="fc" id="L3696">                    int x = edge.getX(i) + mask.getXRelativeOffset() - </span>
<span class="fc" id="L3697">                        gradientXY.getXRelativeOffset();</span>
<span class="fc" id="L3698">                    int y = edge.getY(i) + mask.getYRelativeOffset() - </span>
<span class="fc" id="L3699">                        gradientXY.getYRelativeOffset();</span>
<span class="fc" id="L3700">                    edge.set(i, x, y);</span>
                }
<span class="fc" id="L3702">            }</span>
            
<span class="fc" id="L3704">            return edges;</span>
        }
        
<span class="nc" id="L3707">        Set&lt;PairInt&gt; outputBorderPoints = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L3709">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>
                
<span class="nc" id="L3711">        getEmbeddedAndBorderPoints(skyPoints, gradientXY.getWidth(),</span>
<span class="nc" id="L3712">            gradientXY.getHeight(), outputEmbeddedGapPoints,</span>
            outputBorderPoints);
                
<span class="nc" id="L3715">        PostLineThinnerCorrections pslt = new PostLineThinnerCorrections();</span>
<span class="nc" id="L3716">        pslt.correctForArtifacts(outputBorderPoints, gradientXY.getWidth(), </span>
<span class="nc" id="L3717">            gradientXY.getHeight());</span>
         
<span class="nc" id="L3719">        GreyscaleImage output = gradientXY.createWithDimensions();</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">        for (PairInt p : outputBorderPoints) {</span>
<span class="nc" id="L3721">            output.setValue(p.getX(), p.getY(), 1);</span>
<span class="nc" id="L3722">        }</span>
        
<span class="nc" id="L3724">        AbstractEdgeExtractor edgeExtractor = </span>
            new EdgeExtractorWithJunctions(output);
                
<span class="nc" id="L3727">        List&lt;PairIntArray&gt; edges = edgeExtractor.findEdges();</span>
  
<span class="nc" id="L3729">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="nc" id="L3731">        int k = 10;</span>
        
<span class="nc" id="L3733">        edges = curveHelper.smoothAndReExtractEdges(edges, gradientXY, k);    </span>
        
<span class="nc" id="L3735">        return edges;</span>
    }
    
<span class="fc" id="L3738">    public class RemovedSets {</span>
        private Set&lt;PairInt&gt; removedNonCloudColors = new HashSet&lt;PairInt&gt;();
        private Set&lt;PairInt&gt; highContrastRemoved = new HashSet&lt;PairInt&gt;();
        private Set&lt;PairInt&gt; reflectedSunRemoved = new HashSet&lt;PairInt&gt;();
        private int nBeforeHighContrastRemoval = Integer.MIN_VALUE;
        private int nAfterHighContrastRemoval = Integer.MIN_VALUE;
        
        public RemovedSets(){};
        public void setRemovedNonCloudColors(Set&lt;PairInt&gt; points) {
            this.removedNonCloudColors = points;
        }
        public void setHighContrastRemoved(Set&lt;PairInt&gt; points) {
            this.highContrastRemoved = points;
        }
        public void setReflectedSunRemoved(Set&lt;PairInt&gt; points) {
            this.reflectedSunRemoved = points;
        }
        public Set&lt;PairInt&gt; getRemovedNonCloudColors() {
            return removedNonCloudColors;
        }
        public Set&lt;PairInt&gt; getHighContrastRemoved() {
            return highContrastRemoved;
        }
        public Set&lt;PairInt&gt; getReflectedSunRemoved() {
            return reflectedSunRemoved;
        }

        private void setBeforeHighContrastRemoval(int nBeforeHighContrastRemoval) {
            this.nBeforeHighContrastRemoval = nBeforeHighContrastRemoval;
        }

        private void setAfterHighContrastRemoval(int nAfterHighContrastRemoval) {
            this.nAfterHighContrastRemoval = nAfterHighContrastRemoval;
        }
        
        private int getNBeforeHighContrastRemoval() {
            return nBeforeHighContrastRemoval;
        }

        private int getNAfterHighContrastRemoval() {
            return nAfterHighContrastRemoval;
        }
    }
    
    public SunFinder getSunFinderResults() {
<span class="nc" id="L3783">        return sunFinder;</span>
    }
    
    public RainbowFinder getRainbowFinderResults() {
<span class="nc" id="L3787">        return rainbowFinder;</span>
    }
    
    public List&lt;PairIntArray&gt; getSkylineEdges() {
<span class="fc" id="L3791">        return skylineEdges;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscellaneousCurveHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">MiscellaneousCurveHelper.java</span></div><h1>MiscellaneousCurveHelper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.convexHull.GrahamScanPairInt;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.imageProcessing.scaleSpace.CurvatureScaleSpaceContour;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.PairIntWithIndex0;
import algorithms.util.PairIntArray;
import algorithms.util.PairFloatArray;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;
import no.uib.cipr.matrix.Matrix;
import no.uib.cipr.matrix.MatrixEntry;

/**
 *
 * @author nichole
 */
<span class="fc" id="L28">public class MiscellaneousCurveHelper {</span>

<span class="fc" id="L30">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    // choosing a minimum size empirically from looking at edges in tests
<span class="fc" id="L33">    private static int minLedgeWidth = 4;</span>

<span class="fc" id="L35">    protected static final int[] eightNeighborsX =</span>
        new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
<span class="fc" id="L37">    protected static final int[] eightNeighborsY =</span>
        new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner 
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise(PairIntArray closedCurve) {

<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L57">            return false;</span>
        }

<span class="fc" id="L60">        int nNeg = 0;</span>
<span class="fc" id="L61">        int n = closedCurve.getN();</span>

<span class="fc bfc" id="L63" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

            long xm1, ym1, x, y, xp1, yp1;

<span class="fc bfc" id="L67" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L68">                xm1 = closedCurve.getX(closedCurve.getN() - 1);</span>
<span class="fc" id="L69">                ym1 = closedCurve.getY(closedCurve.getN() - 1);</span>
<span class="fc" id="L70">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L71">                yp1 = closedCurve.getY(i + 1);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            } else if (i == (closedCurve.getN() - 1)) {</span>
<span class="fc" id="L73">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L74">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L75">                xp1 = closedCurve.getX(0);</span>
<span class="fc" id="L76">                yp1 = closedCurve.getY(0);</span>
            } else {
<span class="fc" id="L78">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L79">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L80">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L81">                yp1 = closedCurve.getY(i + 1);</span>
            }
<span class="fc" id="L83">            x = closedCurve.getX(i);</span>
<span class="fc" id="L84">            y = closedCurve.getY(i);</span>

<span class="fc" id="L86">            long dxmxm1 = (x - xm1);</span>
<span class="fc" id="L87">            long dymym1 = (y - ym1);</span>
<span class="fc" id="L88">            long dxp1mx = (xp1 - x);</span>
<span class="fc" id="L89">            long dyp1my = (yp1 - y);</span>

            //(xi - xi-1) * (yi+1 - yi) - (yi - yi-1) * (xi+1 - xi)
<span class="fc" id="L92">            long crossProduct = (dxmxm1 * dyp1my) - (dymym1 * dxp1mx);</span>

<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (crossProduct &lt; 0) {</span>
                // clockwise when crossProduct is negative
<span class="fc" id="L96">                nNeg++;</span>
            }
        }

<span class="fc" id="L100">        int nPos = n - nNeg;//n - 2 - nNeg;</span>

        //log.info(closedCurve.toString());
        //log.info(&quot;n=&quot; + n + &quot; nNegative=&quot; + nNeg + &quot; nPositive=&quot; + nPos);

<span class="pc bpc" id="L105" title="2 of 6 branches missed.">        return ((n &gt; 2) &amp;&amp; (nNeg &gt;= nPos)) || (nNeg &gt; nPos);</span>
     }

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner by first computing the convex hull then
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise2(PairIntArray closedCurve) {

<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L125">            return false;</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        } else if (closedCurve.getN() &lt; 4) {</span>
<span class="nc" id="L127">            return curveIsOrderedClockwise(closedCurve);</span>
        }
        
<span class="fc" id="L130">        int n = closedCurve.getN();</span>
        
<span class="fc" id="L132">        PairIntWithIndex0[] p = new PairIntWithIndex0[n];</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L134">            p[i] = new PairIntWithIndex0(closedCurve.getX(i), closedCurve.getY(i),  i);</span>
        }
        
<span class="fc" id="L137">        GrahamScanPairInt&lt;PairIntWithIndex0&gt; scan = new GrahamScanPairInt&lt;PairIntWithIndex0&gt;();</span>
        try {
<span class="fc" id="L139">            scan.computeHull(p);</span>
            
            // hull returns points in clockwise order
            
<span class="fc" id="L143">            n = scan.getHull().size() - 1;</span>
            //PairIntArray hull = new PairIntArray(n);
            //List&lt;Integer&gt; hullCurveIndexes = new ArrayList&lt;Integer&gt;();
            //int[] deltaIndexes = new int[n];
            
            // nPos or nNeg might be 1 and then other n-2 if there is wrap-around
<span class="fc" id="L149">            int nNeg = 0;</span>
<span class="fc" id="L150">            int nPos = 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
                
<span class="fc" id="L153">                PairIntWithIndex0 p0 = scan.getHull().get(i);</span>
                
                //hull.add(Math.round(p0.getX()), Math.round(p0.getY()));
                //hullCurveIndexes.add(Integer.valueOf(p0.getPixIndex()));
                
                // for CW input, expect these to be + numbers
<span class="fc" id="L159">                int deltaIndex = scan.getHull().get(i + 1).getPixIndex() - p0.getPixIndex();</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                if (deltaIndex &gt; 0) {</span>
<span class="fc" id="L161">                    nPos++;</span>
                } else {
<span class="fc" id="L163">                    nNeg++;</span>
                }
            }
            
            //boolean isCW = curveIsOrderedClockwise(hull);
            //assert(isCW);
            
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (nPos &gt; nNeg) {</span>
<span class="fc" id="L171">                return true;</span>
            }
            
<span class="fc" id="L174">            return false;</span>
            
<span class="nc" id="L176">        } catch (GrahamScanTooFewPointsException ex) {</span>
<span class="nc" id="L177">            return curveIsOrderedClockwise(closedCurve);</span>
        }
    }

    public void additionalThinning45DegreeEdges(
        GreyscaleImage theta, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L193" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>

<span class="nc" id="L196">                int tG = theta.getValue(i, j);</span>

<span class="nc bnc" id="L198" title="All 6 branches missed.">                if (((tG == 45) || (tG == -45)) &amp;&amp; (input.getValue(i, j) &gt; 0)) {</span>

<span class="nc" id="L200">                    int tH0 = theta.getValue(i - 1, j);</span>
<span class="nc" id="L201">                    int tH1 = theta.getValue(i + 1, j);</span>
<span class="nc" id="L202">                    int tV0 = theta.getValue(i, j - 1);</span>
<span class="nc" id="L203">                    int tV1 = theta.getValue(i, j + 1);</span>

<span class="nc" id="L205">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L206">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L207">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L208">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L210" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L212">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L214">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L216" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L217" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L218">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L220">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L226">    }</span>
    
    /**
     * 
     * @param theta image with values in range 0 to 180.
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        double[][] theta, double[][] input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int i = 1; i &lt; (input.length - 1); i++) {</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            for (int j = 1; j &lt; (input[i].length - 1); j++) {</span>

<span class="fc" id="L248">                double vG = input[i][j];</span>
                              
<span class="fc bfc" id="L250" title="All 2 branches covered.">                if (vG &lt;= 0) {</span>
<span class="fc" id="L251">                    continue;</span>
                }
                
<span class="fc" id="L254">                int tG = convert360To45RefFrame((int)Math.round(theta[i][j]));</span>

<span class="fc bfc" id="L256" title="All 4 branches covered.">                if ((Math.abs(tG - 45) &lt; 5) || (Math.abs(tG - -45) &lt; 5)) {</span>

<span class="fc" id="L258">                    int tH0 = convert360To45RefFrame((int)Math.round(theta[i - 1][j]));</span>
<span class="fc" id="L259">                    int tH1 = convert360To45RefFrame((int)Math.round(theta[i + 1][j]));</span>
<span class="fc" id="L260">                    int tV0 = convert360To45RefFrame((int)Math.round(theta[i][j - 1]));</span>
<span class="fc" id="L261">                    int tV1 = convert360To45RefFrame((int)Math.round(theta[i][j + 1]));</span>

<span class="fc" id="L263">                    double gH0 = input[i - 1][j];</span>
<span class="fc" id="L264">                    double gH1 = input[i + 1][j];</span>
<span class="fc" id="L265">                    double gV0 = input[i][j - 1];</span>
<span class="fc" id="L266">                    double gV1 = input[i][j + 1];</span>

<span class="fc bfc" id="L268" title="All 4 branches covered.">                    if ((gH0 &gt; 0) &amp;&amp; (Math.abs(tH0 - tG) &lt; 5)) {</span>
<span class="fc bfc" id="L269" title="All 4 branches covered.">                        if ((gV0 &gt; 0) &amp;&amp; (Math.abs(tV0 - tG) &lt; 5)) {</span>
<span class="fc" id="L270">                            input[i][j] = 0;</span>
<span class="fc bfc" id="L271" title="All 4 branches covered.">                        } else if ((gV1 &gt; 0) &amp;&amp; (Math.abs(tV1 - tG) &lt; 5)) {</span>
<span class="fc" id="L272">                            input[i][j] = 0;</span>
                        }
<span class="fc bfc" id="L274" title="All 4 branches covered.">                    } else if ((gH1 &gt; 0) &amp;&amp; (Math.abs(tH1 - tG) &lt; 5)) {</span>
<span class="fc bfc" id="L275" title="All 4 branches covered.">                        if ((gV0 &gt; 0) &amp;&amp; (Math.abs(tV0 - tG) &lt; 5)) {</span>
<span class="fc" id="L276">                            input[i][j] = 0;</span>
<span class="fc bfc" id="L277" title="All 4 branches covered.">                        } else if ((gV1 &gt; 0) &amp;&amp; (Math.abs(tV1 - tG) &lt; 5)) {</span>
<span class="fc" id="L278">                            input[i][j] = 0;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L284">    }</span>
    
    /**
         *           Y
         *          90
         *     135   |    +45
         *           |
         *   180------------ 0   X
         *           |
         *    225    |   315
         *          270
         * 
         *  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45
        
     * @param angle360
     * @return 
     */
    private int convert360To45RefFrame(int angle360) {
        
<span class="fc bfc" id="L307" title="All 4 branches covered.">        if ((angle360 &lt; 23) || (angle360 &gt; 337)) {</span>
<span class="fc" id="L308">            return 0;</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">        } else if ((angle360 &gt; 157) &amp;&amp; (angle360 &lt; 203)) {</span>
<span class="fc" id="L310">            return 0;</span>
<span class="pc bpc" id="L311" title="1 of 8 branches missed.">        } else  if (((angle360 &gt; 22) &amp;&amp; (angle360 &lt; 68)) || </span>
            ((angle360 &gt; 202) &amp;&amp; (angle360 &lt; 248))) {
            // in range of +45 or +225
<span class="fc" id="L314">            return 45;</span>
<span class="pc bpc" id="L315" title="1 of 8 branches missed.">        } else if (((angle360 &gt; 67) &amp;&amp; (angle360 &lt; 113)) || </span>
            ((angle360 &gt; 247) &amp;&amp; (angle360 &lt; 293))) {
            // in range of +90 or +270
<span class="fc" id="L318">            return 90;</span>
        } else { //if (((t &gt; 112) &amp;&amp; (t &lt; 158)) || ((t &gt; 292) &amp;&amp; (t &lt; 338))) {
            // in range of +135 or +315
<span class="fc" id="L321">            return -45;</span>
        }
    }
    
    /**
     * thin a line that is the product in a canny edge detector, given
     * a theta image which has values between 0 and 360.
     * @param theta3602
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        GreyscaleImage theta3602, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L343" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>
                
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (input.getValue(i, j) == 0) {</span>
<span class="nc" id="L347">                    continue;</span>
                }

<span class="nc" id="L350">                int tG = convert360To45RefFrame(theta3602.getValue(i, j));</span>

<span class="nc bnc" id="L352" title="All 4 branches missed.">                if ((tG == 45) || (tG == -45)) {</span>

<span class="nc" id="L354">                    int tH0 = convert360To45RefFrame(theta3602.getValue(i - 1, j));</span>
<span class="nc" id="L355">                    int tH1 = convert360To45RefFrame(theta3602.getValue(i + 1, j));</span>
<span class="nc" id="L356">                    int tV0 = convert360To45RefFrame(theta3602.getValue(i, j - 1));</span>
<span class="nc" id="L357">                    int tV1 = convert360To45RefFrame(theta3602.getValue(i, j + 1));</span>

<span class="nc" id="L359">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L360">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L361">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L362">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L364" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L366">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L368">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L370" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L372">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L374">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L380">    }</span>
    
    /**
     * thin a line that is the product in a canny edge detector, given
     * a theta image which has values between 0 and 360.
     * @param theta3602
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        GreyscaleImage theta3602, GreyscaleImage input, double minResolvableAngle) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>
                
<span class="fc bfc" id="L403" title="All 2 branches covered.">                if (input.getValue(i, j) == 0) {</span>
<span class="fc" id="L404">                    continue;</span>
                }
                
<span class="fc" id="L407">                int t = theta3602.getValue(i, j);</span>
                
<span class="fc bfc" id="L409" title="All 2 branches covered.">                if ((Math.abs(t - 0) &lt; minResolvableAngle) || </span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">                    (Math.abs(180 - t) &lt; minResolvableAngle) || </span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">                    (Math.abs(360 - t) &lt; minResolvableAngle)) {</span>
                    // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L413">                    t = 90;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">                } else if ((Math.abs(90 - t) &lt; minResolvableAngle) ||</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">                    (Math.abs(270 - t) &lt; minResolvableAngle) ) {</span>
                    // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L417">                    t = 180;</span>
                }

<span class="fc" id="L420">                int tG = convert360To45RefFrame(t);</span>

<span class="fc bfc" id="L422" title="All 4 branches covered.">                if ((tG == 45) || (tG == -45)) {</span>

<span class="fc" id="L424">                    int tH0 = theta3602.getValue(i - 1, j);</span>
<span class="fc" id="L425">                    int tH1 = theta3602.getValue(i + 1, j);</span>
<span class="fc" id="L426">                    int tV0 = theta3602.getValue(i, j - 1);</span>
<span class="fc" id="L427">                    int tV1 = theta3602.getValue(i, j + 1);</span>
                    
<span class="fc bfc" id="L429" title="All 2 branches covered.">                    if ((Math.abs(tH0 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">                        || (Math.abs(180 - tH0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                        || (Math.abs(360 - tH0) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L433">                        tH0 = 90;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tH0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">                        || (Math.abs(270 - tH0) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L437">                        tH0 = 180;</span>
                    }
<span class="fc bfc" id="L439" title="All 2 branches covered.">                    if ((Math.abs(tH1 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">                        || (Math.abs(180 - tH1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                        || (Math.abs(360 - tH1) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L443">                        tH1 = 90;</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tH1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">                        || (Math.abs(270 - tH1) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L447">                        tH1 = 180;</span>
                    }
<span class="fc bfc" id="L449" title="All 2 branches covered.">                    if ((Math.abs(tV0 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                        || (Math.abs(180 - tV0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">                        || (Math.abs(360 - tV0) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L453">                        tV0 = 90;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tV0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                        || (Math.abs(270 - tV0) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L457">                        tV0 = 180;</span>
                    }
<span class="fc bfc" id="L459" title="All 2 branches covered.">                    if ((Math.abs(tV1 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">                        || (Math.abs(180 - tV1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                        || (Math.abs(360 - tV1) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L463">                        tV1 = 90;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tV1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                        || (Math.abs(270 - tV1) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L467">                        tV1 = 180;</span>
                    }
                    
<span class="fc" id="L470">                    tH0 = convert360To45RefFrame(tH0);</span>
<span class="fc" id="L471">                    tH1 = convert360To45RefFrame(tH1);</span>
<span class="fc" id="L472">                    tV0 = convert360To45RefFrame(tV0);</span>
<span class="fc" id="L473">                    tV1 = convert360To45RefFrame(tV1);</span>
                    
<span class="fc" id="L475">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="fc" id="L476">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="fc" id="L477">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="fc" id="L478">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="fc bfc" id="L480" title="All 4 branches covered.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="pc bpc" id="L481" title="1 of 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L482">                            input.setValue(i, j, 0);</span>
<span class="pc bpc" id="L483" title="1 of 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L484">                            input.setValue(i, j, 0);</span>
                        }
<span class="fc bfc" id="L486" title="All 4 branches covered.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="pc bpc" id="L487" title="1 of 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L488">                            input.setValue(i, j, 0);</span>
<span class="pc bpc" id="L489" title="1 of 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L490">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L496">    }</span>
    
    /**
     * return true if correlation shows that the 2 curves are adjacent
     * to one another.  Note that the method needs the points within the
     * curves to be ordered in a similar manner and for the endpoints of the
     * curves to be accurate.  If a point in the middle of the curve is
     * the first or last point, it may prevent comparison of it with another
     * edge's endpoints.
     *
     * @param curve0
     * @param curve1
     * @param correlationOffset offset of where the shorter curve starts
     *  with respect to the longer.  For example, an offset of -2 means that
     * the first 2 points in the shorter curve are outside of the longer curve,
     * but the next point in the longer curve is adjacent to the shorter.
     * Another example: if offset is +2, the first pixel in the shorter curve
     * is adjacent to the third pixel in the longer curve.  NOTE: the offset
     * is only useful if this method returns true;
     * @return
     */
    protected boolean correlation(PairIntArray curve0, PairIntArray curve1,
        int[] correlationOffset) {

<span class="fc" id="L520">        correlationOffset[0] = Integer.MAX_VALUE;</span>

        //TODO: look at string matching algorithms to explore improvements here

        PairIntArray shorter, longer;
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (curve0.getN() &lt;= curve1.getN()) {</span>
<span class="fc" id="L526">            shorter = curve0;</span>
<span class="fc" id="L527">            longer = curve1;</span>
        } else {
<span class="fc" id="L529">            shorter = curve1;</span>
<span class="fc" id="L530">            longer = curve0;</span>
        }

        /*
        len0 = 5; len1 = 11;
         #####
             +++++++++++
          #####
             +++++++++++
           #####
             +++++++++++
            #####
             +++++++++++
             #####
             +++++++++++

             #####
             +++++++++++

                       #####
             +++++++++++

        ccs = sqrt(sumsqdiff)/nOverlapping if nOverlapping &gt; 0.

        if (css &lt;= 1 pix * nOverlapping) {
            store as a possible adjacent curve
        }
        compare possible adjacent curves for the smallest css, and store that
        offset in correlationOffset and return true, else false
        */

<span class="fc" id="L561">        double cSSMin = Double.MAX_VALUE;</span>
<span class="fc" id="L562">        int cSSMinOffset = Integer.MAX_VALUE;</span>
<span class="fc" id="L563">        int cSSMinNOverlapping = 0;</span>

<span class="fc" id="L565">        double sqrtTwo = Math.sqrt(2);</span>

<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (int i = 0; i &lt; (longer.getN() + shorter.getN() - 1); i++) {</span>
            //siIdx is first index in shorter for comparison
            //sfIdx is last index in shorter for comparison
            //liIdx is first index of longer for comparison
            //lfIdx is last index of longer for comparison
            int siIdx, sfIdx, liIdx, lfIdx, offset;
<span class="fc bfc" id="L573" title="All 2 branches covered.">            if (i &lt; shorter.getN()) {</span>
                /*
                 #####
                     +++++++++++ i=0
                  #####
                     +++++++++++
                   #####
                     +++++++++++
                    #####
                     +++++++++++
                     #####
                     +++++++++++ i=4
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L587">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L588">                siIdx = sfIdx - i;</span>
<span class="fc" id="L589">                liIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L591">                lfIdx = sfIdx - siIdx;</span>
<span class="fc" id="L592">                offset = i - sfIdx;</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">            } else if (i &lt; longer.getN() ) {</span>

                /*
                      #####
                     +++++++++++  i=5

                       #####
                     +++++++++++

                        #####
                     +++++++++++

                         #####
                     +++++++++++

                          #####
                     +++++++++++

                           #####
                     +++++++++++ i = 10
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L616">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L617">                siIdx = 0;</span>
<span class="fc" id="L618">                liIdx = i - shorter.getN() + 1;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L620">                lfIdx = liIdx + shorter.getN() - 1;</span>
<span class="fc" id="L621">                offset = i - sfIdx;</span>

            } else {
                /*
                            #####
                     +++++++++++ i = 12
                     01234567890
                             #####
                     +++++++++++

                              #####
                     +++++++++++

                               #####
                     +++++++++++ i=15
                     01234567890
                */
<span class="fc" id="L638">                liIdx = i - shorter.getN() + 1;</span>
                //sfIdx is inclusive endpoint
<span class="fc" id="L640">                sfIdx = longer.getN() - liIdx - 1;</span>
<span class="fc" id="L641">                siIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L643">                lfIdx = liIdx + (sfIdx - siIdx);</span>
<span class="fc" id="L644">                offset = liIdx;</span>

            }

<span class="fc" id="L648">            int nOverLapping = (sfIdx - siIdx) + 1;</span>

<span class="pc bpc" id="L650" title="1 of 2 branches missed.">            if ((sfIdx - siIdx) != (lfIdx - liIdx)) {</span>
<span class="nc" id="L651">                throw new IllegalStateException(</span>
                    &quot;sample ranges are not correct&quot;);
            }

<span class="fc" id="L655">            double sumSq = 0;</span>

<span class="fc" id="L657">            int s = siIdx;</span>
<span class="fc" id="L658">            int l = liIdx;</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">            while (s &lt;= sfIdx) {</span>
<span class="fc" id="L660">                int xs = shorter.getX(s);</span>
<span class="fc" id="L661">                int xl = longer.getX(l);</span>
<span class="fc" id="L662">                int dx = xs - xl;</span>
<span class="fc" id="L663">                int ys = shorter.getY(s);</span>
<span class="fc" id="L664">                int yl = longer.getY(l);</span>
<span class="fc" id="L665">                int dy = ys - yl;</span>
<span class="fc" id="L666">                sumSq += ((dx*dx) + (dy*dy));</span>
<span class="fc" id="L667">                s++;</span>
<span class="fc" id="L668">                l++;</span>
<span class="fc" id="L669">            }</span>

<span class="fc" id="L671">            double tmp = Math.sqrt(sumSq/nOverLapping);</span>

            // assuming adjacent pixel has distance of sqrt(2) at the most
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (tmp &lt;= sqrtTwo) {</span>

<span class="pc bpc" id="L676" title="5 of 6 branches missed.">                if ((tmp &lt; cSSMin) ||</span>
                (tmp == cSSMin &amp;&amp; (nOverLapping &gt; cSSMinNOverlapping))
                ) {

<span class="fc" id="L680">                    cSSMin = tmp;</span>

<span class="fc" id="L682">                    cSSMinOffset = offset;</span>

<span class="fc" id="L684">                    cSSMinNOverlapping = nOverLapping;</span>
                }
            }
        }

<span class="fc bfc" id="L689" title="All 2 branches covered.">        if (cSSMin &lt; Double.MAX_VALUE) {</span>

<span class="fc" id="L691">            correlationOffset[0] = cSSMinOffset;</span>

<span class="fc" id="L693">            return true;</span>
        }

<span class="fc" id="L696">        return false;</span>
    }

    public double[] calculateXYCentroids1(List&lt;CurvatureScaleSpaceContour&gt; list) {
        
<span class="nc" id="L701">        double xc = 0;</span>
<span class="nc" id="L702">        double yc = 0;</span>

<span class="nc bnc" id="L704" title="All 2 branches missed.">        for (CurvatureScaleSpaceContour cr : list) {</span>
<span class="nc" id="L705">            double x = cr.getPeakDetails()[0].getXCoord();</span>
<span class="nc" id="L706">            double y = cr.getPeakDetails()[0].getYCoord();</span>
<span class="nc" id="L707">            xc += x;</span>
<span class="nc" id="L708">            yc += y;</span>
<span class="nc" id="L709">        }</span>
<span class="nc" id="L710">        xc /= (double)list.size();</span>
<span class="nc" id="L711">        yc /= (double)list.size();</span>

<span class="nc" id="L713">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy, float[] weights) {

<span class="fc" id="L718">        double xc = 0;</span>
<span class="fc" id="L719">        double yc = 0;</span>

<span class="fc bfc" id="L721" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
<span class="fc" id="L722">            double x1 = xy.getX(i);</span>
<span class="fc" id="L723">            xc += (weights[i] * x1);</span>

<span class="fc" id="L725">            double y1 = xy.getY(i);</span>
<span class="fc" id="L726">            yc += (weights[i] * y1);</span>
        }

<span class="fc" id="L729">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy) {

<span class="fc" id="L734">        double xc = 0;</span>
<span class="fc" id="L735">        double yc = 0;</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L739">            xc += xy.getX(i);</span>

<span class="fc" id="L741">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L744">        xc /= (double)xy.getN();</span>

<span class="fc" id="L746">        yc /= (double)xy.getN();</span>

<span class="fc" id="L748">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairFloatArray xy) {

<span class="fc" id="L753">        double xc = 0;</span>
<span class="fc" id="L754">        double yc = 0;</span>

<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L758">            xc += xy.getX(i);</span>

<span class="fc" id="L760">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L763">        xc /= (double)xy.getN();</span>

<span class="fc" id="L765">        yc /= (double)xy.getN();</span>

<span class="fc" id="L767">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(List&lt;PairIntArray&gt; xyList) {

<span class="nc" id="L772">        double xc = 0;</span>
<span class="nc" id="L773">        double yc = 0;</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">        for (PairIntArray points : xyList) {</span>

<span class="nc" id="L777">            double[] xycen = calculateXYCentroids(points);</span>

<span class="nc" id="L779">            xc += xycen[0];</span>
<span class="nc" id="L780">            yc += xycen[1];</span>
<span class="nc" id="L781">        }</span>

<span class="nc" id="L783">        xc /= (double)xyList.size();</span>
<span class="nc" id="L784">        yc /= (double)xyList.size();</span>

<span class="nc" id="L786">        return new double[]{xc, yc};</span>
    }

    public PairInt calculateXYCentroids2(Collection&lt;PairInt&gt; points) {
        
<span class="nc" id="L791">        double[] xyCen = calculateXYCentroids(points);</span>
        
<span class="nc" id="L793">        PairInt p = new PairInt((int)Math.round(xyCen[0]), (int)Math.round(xyCen[1]));</span>
        
<span class="nc" id="L795">        return p;</span>
    }
    
    public double[] calculateXYCentroids(Collection&lt;PairInt&gt; points) {

<span class="fc" id="L800">        double xc = 0;</span>
<span class="fc" id="L801">        double yc = 0;</span>

<span class="fc bfc" id="L803" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L805">           int x = p.getX();</span>
<span class="fc" id="L806">           int y = p.getY();</span>

<span class="fc" id="L808">            xc += x;</span>
<span class="fc" id="L809">            yc += y;</span>
<span class="fc" id="L810">        }</span>

<span class="fc" id="L812">        xc /= (double)(points.size());</span>

<span class="fc" id="L814">        yc /= (double)(points.size());</span>

<span class="fc" id="L816">        return new double[]{xc, yc};</span>
    }

    public int[] calculateRoundedXYCentroids(Set&lt;PairInt&gt; points) {

<span class="fc" id="L821">        double[] xyCen = calculateXYCentroids(points);</span>

<span class="fc" id="L823">        int[] out = new int[2];</span>
<span class="fc" id="L824">        out[0] = (int)Math.round(xyCen[0]);</span>
<span class="fc" id="L825">        out[1] = (int)Math.round(xyCen[1]);</span>

<span class="fc" id="L827">        return out;</span>
    }
    
    public int[] calculateRoundedXYCentroids(TIntSet pixelIdxs, int imgWidth) {

<span class="fc" id="L832">        double xc = 0;</span>
<span class="fc" id="L833">        double yc = 0;</span>

<span class="fc" id="L835">        TIntIterator iter = pixelIdxs.iterator();</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">        while (iter.hasNext()) {</span>

<span class="fc" id="L838">            int pixIdx = iter.next();</span>
            
<span class="fc" id="L840">            int y = pixIdx/imgWidth;</span>
<span class="fc" id="L841">            int x = pixIdx - (y * imgWidth);</span>
            
<span class="fc" id="L843">            xc += x;</span>
<span class="fc" id="L844">            yc += y;</span>
<span class="fc" id="L845">        }</span>

<span class="fc" id="L847">        xc /= (double)pixelIdxs.size();</span>
<span class="fc" id="L848">        yc /= (double)pixelIdxs.size();</span>
        
<span class="fc" id="L850">        int[] out = new int[2];</span>
<span class="fc" id="L851">        out[0] = (int)Math.round(xc);</span>
<span class="fc" id="L852">        out[1] = (int)Math.round(yc);</span>

<span class="fc" id="L854">        return out;</span>
    }

    public double[] calculateXYCentroids(float[] x, float[] y) {

<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L860">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L863">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L866">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="fc" id="L869">        double xc = 0;</span>
<span class="fc" id="L870">        double yc = 0;</span>

<span class="fc bfc" id="L872" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="fc" id="L874">            xc += x[i];</span>

<span class="fc" id="L876">            yc += y[i];</span>
        }

<span class="fc" id="L879">        xc /= (double)(x.length);</span>

<span class="fc" id="L881">        yc /= (double)(x.length);</span>

<span class="fc" id="L883">        return new double[]{xc, yc};</span>
    }

    /**
     * does removing the point at idx create a gap between it's neighboring
     * pixels?  this uses the simplest test of only the points at idx-1
     * and idx+1.
     *
     * @param edge
     * @param idx
     * @return
     */
    public boolean doesDisconnect(PairIntArray edge, int idx) {

        // test for endpoints first
<span class="nc bnc" id="L898" title="All 2 branches missed.">        if (idx == 0) {</span>

<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L901">                return true;</span>
            }

            // does this point currently connect to the last point?
<span class="nc" id="L905">            float diffX = edge.getX(idx) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L907">                diffX *= -1;</span>
            }
<span class="nc" id="L909">            float diffY = edge.getY(idx) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L911">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L913" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the last point in the edge
                // check to see if lastPoint and idx + 1 are adjacent
<span class="nc" id="L916">                diffX = edge.getX(idx + 1) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L918">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L920" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L921">                    return true;</span>
                }

<span class="nc" id="L924">                diffY = edge.getY(idx + 1) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L926">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L928" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L929">                    return true;</span>
                }
            }
<span class="nc" id="L932">            return false;</span>
        }

<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (idx == (edge.getN() - 1)) {</span>

<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L938">                return true;</span>
            }

            // does this point currently connect to the first point?
<span class="nc" id="L942">            float diffX = edge.getX(idx) - edge.getX(0);</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L944">                diffX *= -1;</span>
            }
<span class="nc" id="L946">            float diffY = edge.getY(idx) - edge.getY(0);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L948">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L950" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the first point in the edge
                // check to see if lastPoint - 1 and first point are adjacent
<span class="nc" id="L953">                diffX = edge.getX(idx - 1) - edge.getX(0);</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L955">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L957" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L958">                    return true;</span>
                }

<span class="nc" id="L961">                diffY = edge.getY(idx - 1) - edge.getY(0);</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L963">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L965" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L966">                    return true;</span>
                }
            }
<span class="nc" id="L969">            return false;</span>
        }

<span class="nc bnc" id="L972" title="All 2 branches missed.">        if ((idx + 1) &lt; edge.getN()) {</span>
<span class="nc" id="L973">            float diffX = edge.getX(idx - 1) - edge.getX(idx + 1);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L975">                diffX *= -1;</span>
            }
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L978">                return true;</span>
            }

<span class="nc" id="L981">            float diffY = edge.getY(idx - 1) - edge.getY(idx + 1);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L983">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L985" title="All 2 branches missed.">            if (diffY &gt; 1) {</span>
<span class="nc" id="L986">                return true;</span>
            }

<span class="nc" id="L989">            return false;</span>
        }

<span class="nc" id="L992">        return false;</span>
    }

    public double distanceFromPointToALine(float lineX0, float lineY0,
        float lineX1, float lineY1, float xP, float yP) {

        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)

        distance between that edge and a point (xP, yP) is

        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;

        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- )
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )
        */

<span class="fc" id="L1015">        float diffX = lineX1 - lineX0;</span>
<span class="fc" id="L1016">        float diffY = lineY1 - lineY0;</span>

<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (diffY == 0) {</span>
            // horizontal line
<span class="fc" id="L1020">            return Math.abs(yP - lineY0);</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="fc" id="L1023">            return Math.abs(xP - lineX0);</span>
        }

<span class="fc" id="L1026">        double pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>

<span class="fc" id="L1028">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc" id="L1030">        double dist = pt1/pt2;</span>

<span class="fc" id="L1032">        return dist;</span>
    }

    public void sortByX(PairIntArray curve) {
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">        if (curve.getN() &lt; 2) {</span>
<span class="nc" id="L1037">            return;</span>
        }
<span class="fc" id="L1039">        sortByX(curve, 0, curve.getN() - 1);</span>
<span class="fc" id="L1040">    }</span>

    private void sortByX(PairIntArray curve, int idxLo, int idxHi) {
<span class="fc bfc" id="L1043" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1044">            int idxMid = partitionByX(curve, idxLo, idxHi);</span>
<span class="fc" id="L1045">            sortByX(curve, idxLo, idxMid - 1);</span>
<span class="fc" id="L1046">            sortByX(curve, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1048">    }</span>

    private int partitionByX(PairIntArray curve, int idxLo, int idxHi) {

<span class="fc" id="L1052">        int x = curve.getX(idxHi);  //for comparison</span>
<span class="fc" id="L1053">        int store = idxLo - 1;      //store to swap after pivot</span>

<span class="fc bfc" id="L1055" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">            if (curve.getX(i) &lt;= x) {</span>
<span class="fc" id="L1057">                store++;</span>
<span class="fc" id="L1058">                int swapX = curve.getX(store);</span>
<span class="fc" id="L1059">                int swapY = curve.getY(store);</span>
<span class="fc" id="L1060">                curve.set(store, curve.getX(i), curve.getY(i));</span>
<span class="fc" id="L1061">                curve.set(i, swapX, swapY);</span>
            }
        }
<span class="fc" id="L1064">        store++;</span>

<span class="fc" id="L1066">        int swapX = curve.getX(store);</span>
<span class="fc" id="L1067">        int swapY = curve.getY(store);</span>
<span class="fc" id="L1068">        curve.set(store, curve.getX(idxHi), curve.getY(idxHi));</span>
<span class="fc" id="L1069">        curve.set(idxHi, swapX, swapY);</span>

<span class="fc" id="L1071">        return store;</span>
    }

    protected void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; tmpAddedPoints,
        Set&lt;PairInt&gt; tmpRemovedPoints, int imageWidth, int imageHeight) {

<span class="fc" id="L1078">        outputNeighbors.clear();</span>

<span class="fc bfc" id="L1080" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L1082">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L1083">            int y2 = y + eightNeighborsY[i];</span>

<span class="pc bpc" id="L1085" title="4 of 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1087">                continue;</span>
            }

<span class="fc" id="L1090">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L1092" title="All 2 branches covered.">            if (tmpRemovedPoints.contains(p2)) {</span>
<span class="fc" id="L1093">                continue;</span>
            }
<span class="pc bpc" id="L1095" title="1 of 4 branches missed.">            if (tmpAddedPoints.contains(p2) || points.contains(p2)) {</span>
<span class="fc" id="L1096">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L1099">    }</span>

    public Set&lt;PairInt&gt; findNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L1103">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1105" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1107">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1108">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L1110">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1112" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1113">                neighbors.add(p2);</span>
            }
        }

<span class="nc" id="L1117">        return neighbors;</span>
    }
        
    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; points, 
        Set&lt;PairInt&gt; excludePoints, int[] dxs, int[] dys, 
        Set&lt;PairInt&gt; outputNeighbors) {
        
<span class="nc" id="L1124">        outputNeighbors.clear();</span>
        
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        for (int i = 0; i &lt; dxs.length; i++) {</span>
            
<span class="nc" id="L1128">            int x2 = x + dxs[i];</span>
<span class="nc" id="L1129">            int y2 = y + dys[i];</span>
            
<span class="nc" id="L1131">            PairInt p2 = new PairInt(x2, y2);</span>
            
<span class="nc bnc" id="L1133" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1134">                continue;</span>
            }
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1137">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1140">    }</span>

    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L1145">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L1147" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1149">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1150">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1152" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1154">                continue;</span>
            }

<span class="nc" id="L1157">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1160">                continue;</span>
            }
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1163">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1166">    }</span>

    /**
     * iterate through points, counting the number of pixels on the image
     * boundaries, and return true if the number reaches numberOfPixels.
     * @param numberOfPixels the number of pixels for which to return true
     * if they are on the image boundaries.
     * @param points
     * @param imageWidth
     * @param imageHeight
     * @return
     */
    public boolean hasNumberOfPixelsOnImageBoundaries(int numberOfPixels,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="nc" id="L1181">        int n = 0;</span>

<span class="nc bnc" id="L1183" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L1185">            int x = p.getX();</span>
<span class="nc" id="L1186">            int y = p.getY();</span>

<span class="nc bnc" id="L1188" title="All 8 branches missed.">            if ((x == 0) || (y == 0) || (x == (imageWidth - 1)) ||</span>
                (y == (imageHeight - 1))) {

<span class="nc" id="L1191">                n++;</span>

<span class="nc bnc" id="L1193" title="All 2 branches missed.">                if (n == numberOfPixels) {</span>
<span class="nc" id="L1194">                    return true;</span>
                }
            }
<span class="nc" id="L1197">        }</span>

<span class="nc bnc" id="L1199" title="All 2 branches missed.">        return (n &gt;= numberOfPixels);</span>
    }

    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points, int imageWidth,
        int imageHeight) {

<span class="nc" id="L1205">        int nn = 0;</span>

<span class="nc bnc" id="L1207" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1209">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1210">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1212" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1214">                continue;</span>
            }

<span class="nc" id="L1217">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1219" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1220">                nn++;</span>
            }
        }

<span class="nc" id="L1224">        return nn;</span>
    }
    
    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L1229">        int nn = 0;</span>

<span class="nc bnc" id="L1231" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1233">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1234">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L1236">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1238" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1239">                nn++;</span>
            }
        }

<span class="nc" id="L1243">        return nn;</span>
    }

    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2) {
        
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">        if (idx2 &lt; 0) {</span>
<span class="nc" id="L1249">            return false;</span>
        }

<span class="fc" id="L1252">        int x1 = edge.getX(idx1);</span>
<span class="fc" id="L1253">        int y1 = edge.getY(idx1);</span>

<span class="fc" id="L1255">        int x2 = edge.getX(idx2);</span>
<span class="fc" id="L1256">        int y2 = edge.getY(idx2);</span>

<span class="fc" id="L1258">        int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L1259">        int diffY = Math.abs(y1 - y2);</span>

<span class="fc bfc" id="L1261" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L1262">            return true;</span>
        }

<span class="fc" id="L1265">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx, int x, int y) {
        
<span class="nc bnc" id="L1270" title="All 4 branches missed.">        if (idx &lt; 0 || idx &gt; (edge.getN() - 1)) {</span>
<span class="nc" id="L1271">            return false;</span>
        }

<span class="nc" id="L1274">        int x1 = edge.getX(idx);</span>
<span class="nc" id="L1275">        int y1 = edge.getY(idx);</span>

<span class="nc" id="L1277">        int diffX = Math.abs(x1 - x);</span>
<span class="nc" id="L1278">        int diffY = Math.abs(y1 - y);</span>

<span class="nc bnc" id="L1280" title="All 4 branches missed.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="nc" id="L1281">            return true;</span>
        }

<span class="nc" id="L1284">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2,
        float spacingBetweenPoints) {

<span class="nc" id="L1290">        int x1 = edge.getX(idx1);</span>
<span class="nc" id="L1291">        int y1 = edge.getY(idx1);</span>

<span class="nc" id="L1293">        int x2 = edge.getX(idx2);</span>
<span class="nc" id="L1294">        int y2 = edge.getY(idx2);</span>

<span class="nc" id="L1296">        int diffX = Math.abs(x1 - x2);</span>
<span class="nc" id="L1297">        int diffY = Math.abs(y1 - y2);</span>
        
<span class="nc" id="L1299">        float dist = (float)Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="nc bnc" id="L1301" title="All 2 branches missed.">        if (dist &lt;= spacingBetweenPoints) {</span>
<span class="nc" id="L1302">            return true;</span>
        }

<span class="nc" id="L1305">        return false;</span>
    }

    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * along the curve at the middle point, its direction is from p0 to p1.
     * &lt;pre&gt;
     * For example:
     * 
     * 135 degrees
     *       .---
     *       | .
     *           p2   
     *             p1
     *                p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleAtMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

        /*
        given the points (x1, y1) (x2, y2) and (x3, y3), 
        calculates the angle at the midpoint (x2, y2) for the path along
        the points.
        */
        
<span class="fc" id="L1338">        double theta1 = AngleUtil.polarAngleCCW(x2 - x1, y2 - y1);</span>
        
<span class="fc" id="L1340">        double theta2 = AngleUtil.polarAngleCCW(x3 - x2, y3 - y2);</span>
        
<span class="fc" id="L1342">        double theta = AngleUtil.getAngleAverageInRadians(theta1, theta2);</span>
                
<span class="fc" id="L1344">        return theta;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * tangent to the curve at the middle point - its direction follows
     * the right hand rule.
     * &lt;pre&gt;
     * For example:
     *                  45 degrees
     *               __
     *               . |
     *       p2    .
     *          p1
     *             p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleTangentToMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

<span class="fc" id="L1371">        double theta = calculateAngleAtMidpoint(x1, y1, x2, y2, x3, y3);</span>
               
<span class="fc" id="L1373">        double thetaMinus90 = theta - Math.PI/2.;</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">        if (thetaMinus90 &lt; 0) {</span>
<span class="fc" id="L1375">            thetaMinus90 += (2.*Math.PI);</span>
        }
        
<span class="fc" id="L1378">        return thetaMinus90;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which direction and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.  The points are also
     * checked to make sure they aren't in the points set.
     *
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @param points
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY,
        Set&lt;PairInt&gt; points) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        direction of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="nc" id="L1416">        int xmRot90 = xp + (ym - yp);</span>
<span class="nc" id="L1417">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="nc" id="L1419">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="nc" id="L1420">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="nc" id="L1422">        boolean rot90IsInPoints = points.contains(</span>
<span class="nc" id="L1423">            new PairInt(Math.round(xmRot90), Math.round(ymRot90)));</span>

<span class="nc" id="L1425">        boolean rotNegative90IsInPoints = points.contains(</span>
<span class="nc" id="L1426">            new PairInt(Math.round(xmRotNegative90),</span>
<span class="nc" id="L1427">            Math.round(ymRotNegative90)));</span>

<span class="nc" id="L1429">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="nc" id="L1432">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="nc" id="L1436">        double perp = theta;</span>

<span class="nc bnc" id="L1438" title="All 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L1439">            perp += Math.PI/2.;</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">        } else if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc bnc" id="L1441" title="All 4 branches missed.">            if (rot90IsInPoints &amp;&amp; !rotNegative90IsInPoints) {</span>
<span class="nc" id="L1442">                perp -= Math.PI/2.;</span>
<span class="nc bnc" id="L1443" title="All 4 branches missed.">            } else if (!rot90IsInPoints &amp;&amp; rotNegative90IsInPoints) {</span>
<span class="nc" id="L1444">                perp += Math.PI/2.;</span>
            } else {
<span class="nc" id="L1446">                throw new IllegalStateException(&quot;Error in algorithm:&quot; +</span>
                &quot; consider changing the test 90 and -90 points so that&quot; +
                &quot; one will always be in points set.&quot;);
            }
        } else {
<span class="nc" id="L1451">            perp -= Math.PI/2.;</span>
        }

<span class="nc bnc" id="L1454" title="All 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L1455">            perp = perp - 2*Math.PI;</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L1457">            perp += 2*Math.PI;</span>
        }

<span class="nc" id="L1460">        return perp;</span>
    }

    public double calculateArea(PairIntArray closedCurve) {
        
<span class="nc" id="L1465">        int n = closedCurve.getN();</span>
        
<span class="nc" id="L1467">        double sum = 0;</span>
        
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        for (int i = 0; i &lt; (n - 1); ++i) {</span>
            
<span class="nc" id="L1471">            double t = 0.5 * (closedCurve.getY(i + 1) + closedCurve.getY(i)) *</span>
<span class="nc" id="L1472">                (closedCurve.getX(i + 1) - closedCurve.getX(i));</span>
            
<span class="nc" id="L1474">            sum += t;</span>
        }
        
<span class="nc" id="L1477">        sum += ((closedCurve.getY(0) + closedCurve.getY(n - 1)) *</span>
<span class="nc" id="L1478">                (closedCurve.getX(0) - closedCurve.getX(n -1)));</span>
        
<span class="nc" id="L1480">        return sum;</span>
    }

    public PairIntArray scaleDown(PairIntArray a, float scale) {
        
<span class="fc" id="L1485">        double[] cenXY = calculateXYCentroids(a);</span>
     
<span class="fc" id="L1487">        TransformationParameters params = new TransformationParameters();</span>
<span class="fc" id="L1488">        params.setOriginX((float)cenXY[0]);</span>
<span class="fc" id="L1489">        params.setOriginX((float)cenXY[1]);</span>
<span class="fc" id="L1490">        params.setScale(scale);</span>
        
<span class="fc" id="L1492">        Transformer transformer = new Transformer();</span>
<span class="fc" id="L1493">        PairIntArray b = transformer.applyTransformation(params, a);</span>
    
        // when shrinking, there may be overlapping points
<span class="fc" id="L1496">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1497" title="All 2 branches covered.">        for (int i = (b.getN() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1498">            PairInt p = new PairInt(b.getX(i), b.getY(i));</span>
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1500">                b.removeRange(i, i);</span>
            } else {
<span class="fc" id="L1502">                added.add(p);</span>
            }
        }
        
<span class="fc" id="L1506">        return b;</span>
    }

    public PairIntArray createContiguousCircle(float radius) {

<span class="nc" id="L1511">        int shift = (int)Math.ceil(radius);</span>
    
<span class="nc" id="L1513">        return createContiguousCircle(radius, shift, shift);</span>
    }
    
    public PairIntArray createContiguousCircle(float radius, int xShift, 
        int yShift) {
        
        // for a change in y to be at least 1 pixel, theta would be:
        //   theta = asin(1/r)
<span class="fc" id="L1521">        double theta = Math.asin(1./radius);</span>
        
<span class="fc" id="L1523">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L1525">        PairIntArray circle = new PairIntArray();</span>
<span class="fc" id="L1526">        double t = 0;</span>
        int x, y;
<span class="fc bfc" id="L1528" title="All 2 branches covered.">        while (t &lt;= Math.PI/2.) {</span>
<span class="fc" id="L1529">            x = xShift + (int)Math.round(radius * Math.cos(t));</span>
<span class="fc" id="L1530">            y = yShift + (int)Math.round(radius * Math.sin(t));</span>
<span class="fc" id="L1531">            PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L1532">            t += theta;</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">            if (added.contains(p)) {</span>
<span class="fc" id="L1534">                continue;</span>
            }
<span class="fc" id="L1536">            circle.add(x, y);</span>
<span class="fc" id="L1537">            added.add(p);</span>
<span class="fc" id="L1538">        }</span>
<span class="fc" id="L1539">        int n90 = circle.getN();</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">        for (int i = (n90 - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1541">            x = xShift -1 * (circle.getX(i) - xShift);</span>
<span class="fc" id="L1542">            y = circle.getY(i);</span>
<span class="fc" id="L1543">            PairInt p = new PairInt(x, y);</span>
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1545">                continue;</span>
            }
<span class="fc" id="L1547">            circle.add(x, y);</span>
<span class="fc" id="L1548">            added.add(p);</span>
        }
<span class="fc" id="L1550">        int n180 = circle.getN();</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">        for (int i = (n180 - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1552">            x = circle.getX(i);</span>
<span class="fc" id="L1553">            y = yShift -1 * (circle.getY(i) - yShift);</span>
<span class="fc" id="L1554">            PairInt p = new PairInt(x, y);</span>
<span class="fc bfc" id="L1555" title="All 2 branches covered.">            if (added.contains(p)) {</span>
<span class="fc" id="L1556">                continue;</span>
            }
<span class="fc" id="L1558">            circle.add(x, y);</span>
<span class="fc" id="L1559">            added.add(p);</span>
        }
        
<span class="fc" id="L1562">        return circle;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
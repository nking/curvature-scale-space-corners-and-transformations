<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscellaneousCurveHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">MiscellaneousCurveHelper.java</span></div><h1>MiscellaneousCurveHelper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.convexHull.GrahamScanPairInt;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.imageProcessing.features.CornerRegion;
import algorithms.imageProcessing.scaleSpace.CurvatureScaleSpaceContour;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.PairIntWithIndex0;
import algorithms.misc.AverageUtil;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PairIntArrayComparator;
import algorithms.util.PairFloatArray;
import algorithms.util.PairInt;
import algorithms.util.PairIntArrayWithColor;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;
import org.ejml.simple.*;

/**
 *
 * @author nichole
 */
<span class="fc" id="L30">public class MiscellaneousCurveHelper {</span>

<span class="fc" id="L32">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    // choosing a minimum size empirically from looking at edges in tests
<span class="fc" id="L35">    private static int minLedgeWidth = 4;</span>

<span class="fc" id="L37">    protected static final int[] eightNeighborsX =</span>
        new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
<span class="fc" id="L39">    protected static final int[] eightNeighborsY =</span>
        new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner 
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise(PairIntArray closedCurve) {

<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="fc" id="L59">            return false;</span>
        }

<span class="fc" id="L62">        int nNeg = 0;</span>
<span class="fc" id="L63">        int n = closedCurve.getN();</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

            long xm1, ym1, x, y, xp1, yp1;

<span class="fc bfc" id="L69" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L70">                xm1 = closedCurve.getX(closedCurve.getN() - 1);</span>
<span class="fc" id="L71">                ym1 = closedCurve.getY(closedCurve.getN() - 1);</span>
<span class="fc" id="L72">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L73">                yp1 = closedCurve.getY(i + 1);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">            } else if (i == (closedCurve.getN() - 1)) {</span>
<span class="fc" id="L75">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L76">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L77">                xp1 = closedCurve.getX(0);</span>
<span class="fc" id="L78">                yp1 = closedCurve.getY(0);</span>
            } else {
<span class="fc" id="L80">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L81">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L82">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L83">                yp1 = closedCurve.getY(i + 1);</span>
            }
<span class="fc" id="L85">            x = closedCurve.getX(i);</span>
<span class="fc" id="L86">            y = closedCurve.getY(i);</span>

<span class="fc" id="L88">            long dxmxm1 = (x - xm1);</span>
<span class="fc" id="L89">            long dymym1 = (y - ym1);</span>
<span class="fc" id="L90">            long dxp1mx = (xp1 - x);</span>
<span class="fc" id="L91">            long dyp1my = (yp1 - y);</span>

            //(xi - xi-1) * (yi+1 - yi) - (yi - yi-1) * (xi+1 - xi)
<span class="fc" id="L94">            long crossProduct = (dxmxm1 * dyp1my) - (dymym1 * dxp1mx);</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (crossProduct &lt; 0) {</span>
                // clockwise when crossProduct is negative
<span class="fc" id="L98">                nNeg++;</span>
            }
        }

<span class="fc" id="L102">        int nPos = n - nNeg;//n - 2 - nNeg;</span>

        //log.info(closedCurve.toString());
        //log.info(&quot;n=&quot; + n + &quot; nNegative=&quot; + nNeg + &quot; nPositive=&quot; + nPos);

<span class="pc bpc" id="L107" title="1 of 6 branches missed.">        return ((n &gt; 2) &amp;&amp; (nNeg &gt;= nPos)) || (nNeg &gt; nPos);</span>
     }

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner by first computing the convex hull then
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise2(PairIntArray closedCurve) {

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="fc" id="L127">            return false;</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        } else if (closedCurve.getN() &lt; 4) {</span>
<span class="nc" id="L129">            return curveIsOrderedClockwise(closedCurve);</span>
        }
        
<span class="fc" id="L132">        int n = closedCurve.getN();</span>
        
<span class="fc" id="L134">        PairIntWithIndex0[] p = new PairIntWithIndex0[n];</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L136">            p[i] = new PairIntWithIndex0(closedCurve.getX(i), closedCurve.getY(i),  i);</span>
        }
        
<span class="fc" id="L139">        GrahamScanPairInt&lt;PairIntWithIndex0&gt; scan = new GrahamScanPairInt&lt;PairIntWithIndex0&gt;();</span>
        try {
<span class="fc" id="L141">            scan.computeHull(p);</span>
            
            // hull returns points in clockwise order
            
<span class="fc" id="L145">            n = scan.getHull().size() - 1;</span>
            //PairIntArray hull = new PairIntArray(n);
            //List&lt;Integer&gt; hullCurveIndexes = new ArrayList&lt;Integer&gt;();
            //int[] deltaIndexes = new int[n];
            
            // nPos or nNeg might be 1 and then other n-2 if there is wrap-around
<span class="fc" id="L151">            int nNeg = 0;</span>
<span class="fc" id="L152">            int nPos = 0;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
                
<span class="fc" id="L155">                PairIntWithIndex0 p0 = scan.getHull().get(i);</span>
                
                //hull.add(Math.round(p0.getX()), Math.round(p0.getY()));
                //hullCurveIndexes.add(Integer.valueOf(p0.getPixIndex()));
                
                // for CW input, expect these to be + numbers
<span class="fc" id="L161">                int deltaIndex = scan.getHull().get(i + 1).getPixIndex() - p0.getPixIndex();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">                if (deltaIndex &gt; 0) {</span>
<span class="fc" id="L163">                    nPos++;</span>
                } else {
<span class="fc" id="L165">                    nNeg++;</span>
                }
            }
            
            //boolean isCW = curveIsOrderedClockwise(hull);
            //assert(isCW);
            
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (nPos &gt; nNeg) {</span>
<span class="fc" id="L173">                return true;</span>
            }
            
<span class="fc" id="L176">            return false;</span>
            
<span class="nc" id="L178">        } catch (GrahamScanTooFewPointsException ex) {</span>
<span class="nc" id="L179">            return curveIsOrderedClockwise(closedCurve);</span>
        }
    }

    public void additionalThinning45DegreeEdges(
        GreyscaleImage theta, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L195" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>

<span class="nc" id="L198">                int tG = theta.getValue(i, j);</span>

<span class="nc bnc" id="L200" title="All 6 branches missed.">                if (((tG == 45) || (tG == -45)) &amp;&amp; (input.getValue(i, j) &gt; 0)) {</span>

<span class="nc" id="L202">                    int tH0 = theta.getValue(i - 1, j);</span>
<span class="nc" id="L203">                    int tH1 = theta.getValue(i + 1, j);</span>
<span class="nc" id="L204">                    int tV0 = theta.getValue(i, j - 1);</span>
<span class="nc" id="L205">                    int tV1 = theta.getValue(i, j + 1);</span>

<span class="nc" id="L207">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L208">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L209">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L210">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L212" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L214">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L216">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L218" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L220">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L222">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L228">    }</span>

     /**
     * this is a method to combine and prune adjacent lines, but
     * it knows nothing about the overall shape. it chooses to keep the longer
     * line and append any dangling members of the adjacent line to the longest.
     * It's a time consuming method (add runtime complexity here).  It isn't
     * used anymore because the results from the CannyEdgeFilter are now
     * 1 pixel thick edges already.
     * @param edges
     * @param imageWidth the image width in pixels
     * @return
     */
    public List&lt;PairIntArray&gt; pruneAndIncludeAdjacentCurves(
        List&lt;PairIntArray&gt; edges, int imageWidth) {

        //sort to place edges with fewest points at top
<span class="fc" id="L245">        Collections.sort(edges, new PairIntArrayComparator());</span>

<span class="fc" id="L247">        Stack&lt;PairIntArrayWithColor&gt; stack = new Stack&lt;PairIntArrayWithColor&gt;();</span>
<span class="fc" id="L248">        List&lt;PairIntArrayWithColor&gt; pruneThese = new ArrayList&lt;PairIntArrayWithColor&gt;();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
            // color: 0 = unvisited, 1 = processing, 2 = visited,
            //        3 = in an output edge, 4=pruned
<span class="fc" id="L252">            PairIntArrayWithColor node = new PairIntArrayWithColor(edges.get(i));</span>
<span class="fc" id="L253">            stack.add(node);</span>
<span class="fc" id="L254">            pruneThese.add(node);</span>
        }

<span class="fc" id="L257">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>

<span class="fc" id="L259">        PairIntArrayWithColor tmp = stack.peek();</span>
<span class="fc" id="L260">        tmp.setColor(2);</span>

<span class="fc" id="L262">        boolean foundOverlappingCurves = false;</span>
<span class="fc" id="L263">        boolean reversedPoints = false;</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>

<span class="fc" id="L267">            PairIntArrayWithColor uNode = stack.pop();</span>

<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (uNode.getColor() == 4) {</span>
<span class="fc" id="L270">                continue;</span>
            }

            // for each neighbor v of u
<span class="fc bfc" id="L274" title="All 2 branches covered.">            for (int i = (pruneThese.size() - 1); i &gt; -1; i--) {</span>

<span class="fc" id="L276">                PairIntArrayWithColor vNode = pruneThese.get(i);</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">                if (vNode.getColor() != 0) {</span>
<span class="fc" id="L279">                    continue;</span>
                }

                // because top item might be updated in processPair,
                //     place in v iter
<span class="fc" id="L284">                int uX = uNode.getX(0);</span>
<span class="fc" id="L285">                int uY = uNode.getY(0);</span>
<span class="fc" id="L286">                int uIdx = (uY * imageWidth) + uX;</span>

<span class="fc" id="L288">                int vX = vNode.getX(0);</span>
<span class="fc" id="L289">                int vY = vNode.getY(0);</span>
<span class="fc" id="L290">                int vIdx = (vY * imageWidth) + vX;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                if (uIdx == vIdx) {</span>
<span class="fc" id="L292">                    continue;</span>
                }

<span class="fc" id="L295">                boolean areOverlapping = processOverlappingPair(uNode, vNode);</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">                if (areOverlapping) {</span>

<span class="fc" id="L299">                    foundOverlappingCurves = true;</span>

                    // color: 0 = unvisited, 1 = processing, 2 = visited,
                    //        3 = in an output edge, 4=pruned
<span class="fc" id="L303">                    vNode.setColor(4);</span>

<span class="fc" id="L305">                    pruneThese.remove(vNode);</span>

                } // else insert into stack?
            }

<span class="fc bfc" id="L310" title="All 4 branches covered.">            if (!foundOverlappingCurves &amp;&amp; !reversedPoints) {</span>
<span class="fc" id="L311">                uNode.reverse();</span>
<span class="fc" id="L312">                reversedPoints = true;</span>
<span class="fc" id="L313">                log.fine(&quot;reversed edge to try again&quot;);</span>
<span class="fc" id="L314">                stack.add(uNode);</span>
<span class="fc" id="L315">                continue;</span>
            }

            // color: 0 = unvisited, 1 = processing, 2 = visited,
            //        3 = in an output edge, 4=pruned
<span class="fc" id="L320">            uNode.setColor(3);</span>

<span class="fc" id="L322">            output.add(uNode);</span>

<span class="fc" id="L324">            foundOverlappingCurves = false;</span>
<span class="fc" id="L325">            reversedPoints = false;</span>
<span class="fc" id="L326">        }</span>

<span class="fc" id="L328">        return output;</span>
    }

    /**
     * given 2 edges, return true if they overlap. If they overlap
     * curve0 is given the larger curve and any outlying points.
     * @param curve0
     * @param curve1
     * @return
     */
    protected boolean processOverlappingPair(PairIntArrayWithColor curve0,
        PairIntArrayWithColor curve1) {

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        boolean longerIsNode0 = (curve0.getN() &gt;= curve1.getN());</span>

        PairIntArray longer, shorter;
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (longerIsNode0) {</span>
<span class="fc" id="L345">            longer = curve0;</span>
<span class="fc" id="L346">            shorter = curve1;</span>
        } else {
<span class="nc" id="L348">            longer = curve1;</span>
<span class="nc" id="L349">            shorter = curve0;</span>
        }

        // used to return the offset w.r.t. the longest edge.
<span class="fc" id="L353">        int[] correlationOffset = new int[1];</span>

        /*
         returns whether the curve 'check' is adjacent to the curve 'node0',
         and if so, returns the offset in the frame of the larger curve.
         the offset represents where the first point in the shorter curve
         matches in the larger curve.
         */
<span class="fc" id="L361">        boolean isAdjacent = correlation(longer, shorter,</span>
            correlationOffset);

<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (isAdjacent) {</span>

            /*
                -- find any points in check outside of the overlap
                   and add those to the larger node.
            */
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">            if (correlationOffset[0] &lt; 0) {</span>
                // add from the beginning of shorter if any are unmatched
<span class="nc" id="L372">                int nInsert = -1*correlationOffset[0];</span>
<span class="nc" id="L373">                longer.insertSpaceAtTopOfArrays(nInsert);</span>

<span class="nc bnc" id="L375" title="All 2 branches missed.">                for (int ii = 0; ii &lt; nInsert; ii++) {</span>
<span class="nc" id="L376">                    longer.set(ii, shorter.getX(ii), shorter.getY(ii));</span>
                }
<span class="nc" id="L378">            } else {</span>
                //add from end of shorter if any are unmatched
<span class="fc" id="L380">                int n0 = longer.getN() - correlationOffset[0];</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">                if (n0 &lt; shorter.getN()) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                    for (int ii = n0; ii &lt; shorter.getN(); ii++) {</span>
<span class="fc" id="L383">                        longer.add(shorter.getX(ii), shorter.getY(ii));</span>
                    }
                }
            }

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            if (!longerIsNode0) {</span>
<span class="nc" id="L389">                curve0.swapContents(curve1);</span>
            }

<span class="fc" id="L392">            return true;</span>
        }

<span class="fc" id="L395">        return false;</span>
    }

    /**
     * return true if correlation shows that the 2 curves are adjacent
     * to one another.  Note that the method needs the points within the
     * curves to be ordered in a similar manner and for the endpoints of the
     * curves to be accurate.  If a point in the middle of the curve is
     * the first or last point, it may prevent comparison of it with another
     * edge's endpoints.
     *
     * @param curve0
     * @param curve1
     * @param correlationOffset offset of where the shorter curve starts
     *  with respect to the longer.  For example, an offset of -2 means that
     * the first 2 points in the shorter curve are outside of the longer curve,
     * but the next point in the longer curve is adjacent to the shorter.
     * Another example: if offset is +2, the first pixel in the shorter curve
     * is adjacent to the third pixel in the longer curve.  NOTE: the offset
     * is only useful if this method returns true;
     * @return
     */
    protected boolean correlation(PairIntArray curve0, PairIntArray curve1,
        int[] correlationOffset) {

<span class="fc" id="L420">        correlationOffset[0] = Integer.MAX_VALUE;</span>

        //TODO: look at string matching algorithms to explore improvements here

        PairIntArray shorter, longer;
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (curve0.getN() &lt;= curve1.getN()) {</span>
<span class="fc" id="L426">            shorter = curve0;</span>
<span class="fc" id="L427">            longer = curve1;</span>
        } else {
<span class="fc" id="L429">            shorter = curve1;</span>
<span class="fc" id="L430">            longer = curve0;</span>
        }

        /*
        len0 = 5; len1 = 11;
         #####
             +++++++++++
          #####
             +++++++++++
           #####
             +++++++++++
            #####
             +++++++++++
             #####
             +++++++++++

             #####
             +++++++++++

                       #####
             +++++++++++

        ccs = sqrt(sumsqdiff)/nOverlapping if nOverlapping &gt; 0.

        if (css &lt;= 1 pix * nOverlapping) {
            store as a possible adjacent curve
        }
        compare possible adjacent curves for the smallest css, and store that
        offset in correlationOffset and return true, else false
        */

<span class="fc" id="L461">        double cSSMin = Double.MAX_VALUE;</span>
<span class="fc" id="L462">        int cSSMinOffset = Integer.MAX_VALUE;</span>
<span class="fc" id="L463">        int cSSMinNOverlapping = 0;</span>

<span class="fc" id="L465">        double sqrtTwo = Math.sqrt(2);</span>

<span class="fc bfc" id="L467" title="All 2 branches covered.">        for (int i = 0; i &lt; (longer.getN() + shorter.getN() - 1); i++) {</span>
            //siIdx is first index in shorter for comparison
            //sfIdx is last index in shorter for comparison
            //liIdx is first index of longer for comparison
            //lfIdx is last index of longer for comparison
            int siIdx, sfIdx, liIdx, lfIdx, offset;
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (i &lt; shorter.getN()) {</span>
                /*
                 #####
                     +++++++++++ i=0
                  #####
                     +++++++++++
                   #####
                     +++++++++++
                    #####
                     +++++++++++
                     #####
                     +++++++++++ i=4
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L487">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L488">                siIdx = sfIdx - i;</span>
<span class="fc" id="L489">                liIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L491">                lfIdx = sfIdx - siIdx;</span>
<span class="fc" id="L492">                offset = i - sfIdx;</span>

<span class="fc bfc" id="L494" title="All 2 branches covered.">            } else if (i &lt; longer.getN() ) {</span>

                /*
                      #####
                     +++++++++++  i=5

                       #####
                     +++++++++++

                        #####
                     +++++++++++

                         #####
                     +++++++++++

                          #####
                     +++++++++++

                           #####
                     +++++++++++ i = 10
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L516">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L517">                siIdx = 0;</span>
<span class="fc" id="L518">                liIdx = i - shorter.getN() + 1;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L520">                lfIdx = liIdx + shorter.getN() - 1;</span>
<span class="fc" id="L521">                offset = i - sfIdx;</span>

            } else {
                /*
                            #####
                     +++++++++++ i = 12
                     01234567890
                             #####
                     +++++++++++

                              #####
                     +++++++++++

                               #####
                     +++++++++++ i=15
                     01234567890
                */
<span class="fc" id="L538">                liIdx = i - shorter.getN() + 1;</span>
                //sfIdx is inclusive endpoint
<span class="fc" id="L540">                sfIdx = longer.getN() - liIdx - 1;</span>
<span class="fc" id="L541">                siIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L543">                lfIdx = liIdx + (sfIdx - siIdx);</span>
<span class="fc" id="L544">                offset = liIdx;</span>

            }

<span class="fc" id="L548">            int nOverLapping = (sfIdx - siIdx) + 1;</span>

<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            if ((sfIdx - siIdx) != (lfIdx - liIdx)) {</span>
<span class="nc" id="L551">                throw new IllegalStateException(</span>
                    &quot;sample ranges are not correct&quot;);
            }

<span class="fc" id="L555">            double sumSq = 0;</span>

<span class="fc" id="L557">            int s = siIdx;</span>
<span class="fc" id="L558">            int l = liIdx;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            while (s &lt;= sfIdx) {</span>
<span class="fc" id="L560">                int xs = shorter.getX(s);</span>
<span class="fc" id="L561">                int xl = longer.getX(l);</span>
<span class="fc" id="L562">                int dx = xs - xl;</span>
<span class="fc" id="L563">                int ys = shorter.getY(s);</span>
<span class="fc" id="L564">                int yl = longer.getY(l);</span>
<span class="fc" id="L565">                int dy = ys - yl;</span>
<span class="fc" id="L566">                sumSq += ((dx*dx) + (dy*dy));</span>
<span class="fc" id="L567">                s++;</span>
<span class="fc" id="L568">                l++;</span>
<span class="fc" id="L569">            }</span>

<span class="fc" id="L571">            double tmp = Math.sqrt(sumSq/nOverLapping);</span>

            // assuming adjacent pixel has distance of sqrt(2) at the most
<span class="fc bfc" id="L574" title="All 2 branches covered.">            if (tmp &lt;= sqrtTwo) {</span>

<span class="pc bpc" id="L576" title="3 of 6 branches missed.">                if ((tmp &lt; cSSMin) ||</span>
                (tmp == cSSMin &amp;&amp; (nOverLapping &gt; cSSMinNOverlapping))
                ) {

<span class="fc" id="L580">                    cSSMin = tmp;</span>

<span class="fc" id="L582">                    cSSMinOffset = offset;</span>

<span class="fc" id="L584">                    cSSMinNOverlapping = nOverLapping;</span>
                }
            }
        }

<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (cSSMin &lt; Double.MAX_VALUE) {</span>

<span class="fc" id="L591">            correlationOffset[0] = cSSMinOffset;</span>

<span class="fc" id="L593">            return true;</span>
        }

<span class="fc" id="L596">        return false;</span>
    }

    /**
     * find the index where x is minimum value of closedCurve.  Note that when
     * there are more than one points with the same minimum x value, the point
     * with a smaller y is chosen.
     *
     * @param closedCurve
     * @return
     */
    public int findMinIdx(PairIntArray closedCurve) {

<span class="fc" id="L609">        int xMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L610">        int xMax = Integer.MIN_VALUE;</span>

<span class="fc" id="L612">        int xMinIdx = -1;</span>
<span class="fc" id="L613">        int xMaxIdx = -1;</span>

        // find xMin.  when xMin==x, use yMin too.  similar pattern for maxes
<span class="fc bfc" id="L616" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); i++) {</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">            if (closedCurve.getX(i) &lt; xMin) {</span>
<span class="fc" id="L618">                xMin = closedCurve.getX(i);</span>
<span class="fc" id="L619">                xMinIdx = i;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">            } else if (closedCurve.getX(i) == xMin) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">                if (closedCurve.getY(i) &lt; closedCurve.getY(xMinIdx)) {</span>
<span class="fc" id="L622">                    xMin = closedCurve.getX(i);</span>
<span class="fc" id="L623">                    xMinIdx = i;</span>
                }
            }
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (closedCurve.getX(i) &gt; xMax) {</span>
<span class="fc" id="L627">                xMax = closedCurve.getX(i);</span>
<span class="fc" id="L628">                xMaxIdx = i;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">            } else if (closedCurve.getX(i) == xMax) {</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">                if (closedCurve.getY(i) &gt; closedCurve.getY(xMaxIdx)) {</span>
<span class="nc" id="L631">                    xMax = closedCurve.getX(i);</span>
<span class="nc" id="L632">                    xMaxIdx = i;</span>
                }
            }
        }

<span class="fc" id="L637">        return xMinIdx;</span>
    }
    
    public &lt;T extends CornerRegion&gt; double[] calculateXYCentroids0(List&lt;T&gt; list) {
        
<span class="nc" id="L642">        double xc = 0;</span>
<span class="nc" id="L643">        double yc = 0;</span>

<span class="nc bnc" id="L645" title="All 2 branches missed.">        for (CornerRegion cr : list) {</span>
<span class="nc" id="L646">            double x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="nc" id="L647">            double y = cr.getY()[cr.getKMaxIdx()];</span>
<span class="nc" id="L648">            xc += x;</span>
<span class="nc" id="L649">            yc += y;</span>
<span class="nc" id="L650">        }</span>
<span class="nc" id="L651">        xc /= (double)list.size();</span>
<span class="nc" id="L652">        yc /= (double)list.size();</span>

<span class="nc" id="L654">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids1(List&lt;CurvatureScaleSpaceContour&gt; list) {
        
<span class="nc" id="L659">        double xc = 0;</span>
<span class="nc" id="L660">        double yc = 0;</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (CurvatureScaleSpaceContour cr : list) {</span>
<span class="nc" id="L663">            double x = cr.getPeakDetails()[0].getXCoord();</span>
<span class="nc" id="L664">            double y = cr.getPeakDetails()[0].getYCoord();</span>
<span class="nc" id="L665">            xc += x;</span>
<span class="nc" id="L666">            yc += y;</span>
<span class="nc" id="L667">        }</span>
<span class="nc" id="L668">        xc /= (double)list.size();</span>
<span class="nc" id="L669">        yc /= (double)list.size();</span>

<span class="nc" id="L671">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy, float[] weights) {

<span class="fc" id="L676">        double xc = 0;</span>
<span class="fc" id="L677">        double yc = 0;</span>

<span class="fc bfc" id="L679" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
<span class="fc" id="L680">            double x1 = xy.getX(i);</span>
<span class="fc" id="L681">            xc += (weights[i] * x1);</span>

<span class="fc" id="L683">            double y1 = xy.getY(i);</span>
<span class="fc" id="L684">            yc += (weights[i] * y1);</span>
        }

<span class="fc" id="L687">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy) {

<span class="fc" id="L692">        double xc = 0;</span>
<span class="fc" id="L693">        double yc = 0;</span>

<span class="fc bfc" id="L695" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L697">            xc += xy.getX(i);</span>

<span class="fc" id="L699">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L702">        xc /= (double)xy.getN();</span>

<span class="fc" id="L704">        yc /= (double)xy.getN();</span>

<span class="fc" id="L706">        return new double[]{xc, yc};</span>
    }

    /**
     * calculate the x and y centroids and return as
     * double[]{xCentroid, yCentroid}
     * @param xy a 3 x N matrix with column 0 being x and column 1 being y.
     * @return
     */
    public double[] calculateXYCentroids(SimpleMatrix xy) {

<span class="fc" id="L717">        double xc = 0;</span>
<span class="fc" id="L718">        double yc = 0;</span>

<span class="fc" id="L720">        int n = xy.numCols();</span>

<span class="fc bfc" id="L722" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

<span class="fc" id="L724">            xc += xy.get(0, i);</span>

<span class="fc" id="L726">            yc += xy.get(1, i);</span>
        }

<span class="fc" id="L729">        xc /= (double)n;</span>

<span class="fc" id="L731">        yc /= (double)n;</span>

<span class="fc" id="L733">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairFloatArray xy) {

<span class="fc" id="L738">        double xc = 0;</span>
<span class="fc" id="L739">        double yc = 0;</span>

<span class="fc bfc" id="L741" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L743">            xc += xy.getX(i);</span>

<span class="fc" id="L745">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L748">        xc /= (double)xy.getN();</span>

<span class="fc" id="L750">        yc /= (double)xy.getN();</span>

<span class="fc" id="L752">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(List&lt;PairIntArray&gt; xyList) {

<span class="nc" id="L757">        double xc = 0;</span>
<span class="nc" id="L758">        double yc = 0;</span>

<span class="nc bnc" id="L760" title="All 2 branches missed.">        for (PairIntArray points : xyList) {</span>

<span class="nc" id="L762">            double[] xycen = calculateXYCentroids(points);</span>

<span class="nc" id="L764">            xc += xycen[0];</span>
<span class="nc" id="L765">            yc += xycen[1];</span>
<span class="nc" id="L766">        }</span>

<span class="nc" id="L768">        xc /= (double)xyList.size();</span>
<span class="nc" id="L769">        yc /= (double)xyList.size();</span>

<span class="nc" id="L771">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(Set&lt;PairInt&gt; points) {

<span class="fc" id="L776">        double xc = 0;</span>
<span class="fc" id="L777">        double yc = 0;</span>

<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L781">           int x = p.getX();</span>
<span class="fc" id="L782">           int y = p.getY();</span>

<span class="fc" id="L784">            xc += x;</span>
<span class="fc" id="L785">            yc += y;</span>
<span class="fc" id="L786">        }</span>

<span class="fc" id="L788">        xc /= (double)(points.size());</span>

<span class="fc" id="L790">        yc /= (double)(points.size());</span>

<span class="fc" id="L792">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(float[] x, float[] y) {

<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L798">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L801">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L804">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="fc" id="L807">        double xc = 0;</span>
<span class="fc" id="L808">        double yc = 0;</span>

<span class="fc bfc" id="L810" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="fc" id="L812">            xc += x[i];</span>

<span class="fc" id="L814">            yc += y[i];</span>
        }

<span class="fc" id="L817">        xc /= (double)(x.length);</span>

<span class="fc" id="L819">        yc /= (double)(x.length);</span>

<span class="fc" id="L821">        return new double[]{xc, yc};</span>
    }

    /**
     * does removing the point at idx create a gap between it's neighboring
     * pixels?  this uses the simplest test of only the points at idx-1
     * and idx+1.
     *
     * @param edge
     * @param idx
     * @return
     */
    public boolean doesDisconnect(PairIntArray edge, int idx) {

        // test for endpoints first
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (idx == 0) {</span>

<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L839">                return true;</span>
            }

            // does this point currently connect to the last point?
<span class="nc" id="L843">            float diffX = edge.getX(idx) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L845">                diffX *= -1;</span>
            }
<span class="nc" id="L847">            float diffY = edge.getY(idx) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L849">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L851" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the last point in the edge
                // check to see if lastPoint and idx + 1 are adjacent
<span class="nc" id="L854">                diffX = edge.getX(idx + 1) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L856">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L858" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L859">                    return true;</span>
                }

<span class="nc" id="L862">                diffY = edge.getY(idx + 1) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L864">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L867">                    return true;</span>
                }
            }
<span class="nc" id="L870">            return false;</span>
        }

<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (idx == (edge.getN() - 1)) {</span>

<span class="nc bnc" id="L875" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L876">                return true;</span>
            }

            // does this point currently connect to the first point?
<span class="nc" id="L880">            float diffX = edge.getX(idx) - edge.getX(0);</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L882">                diffX *= -1;</span>
            }
<span class="nc" id="L884">            float diffY = edge.getY(idx) - edge.getY(0);</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L886">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L888" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the first point in the edge
                // check to see if lastPoint - 1 and first point are adjacent
<span class="nc" id="L891">                diffX = edge.getX(idx - 1) - edge.getX(0);</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L893">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L895" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L896">                    return true;</span>
                }

<span class="nc" id="L899">                diffY = edge.getY(idx - 1) - edge.getY(0);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L901">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L903" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L904">                    return true;</span>
                }
            }
<span class="nc" id="L907">            return false;</span>
        }

<span class="nc bnc" id="L910" title="All 2 branches missed.">        if ((idx + 1) &lt; edge.getN()) {</span>
<span class="nc" id="L911">            float diffX = edge.getX(idx - 1) - edge.getX(idx + 1);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L913">                diffX *= -1;</span>
            }
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L916">                return true;</span>
            }

<span class="nc" id="L919">            float diffY = edge.getY(idx - 1) - edge.getY(idx + 1);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L921">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L923" title="All 2 branches missed.">            if (diffY &gt; 1) {</span>
<span class="nc" id="L924">                return true;</span>
            }

<span class="nc" id="L927">            return false;</span>
        }

<span class="nc" id="L930">        return false;</span>
    }

    public double distanceFromPointToALine(float lineX0, float lineY0,
        float lineX1, float lineY1, float xP, float yP) {

        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)

        distance between that edge and a point (xP, yP) is

        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;

        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- )
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )
        */

<span class="fc" id="L953">        float diffX = lineX1 - lineX0;</span>
<span class="fc" id="L954">        float diffY = lineY1 - lineY0;</span>

<span class="fc bfc" id="L956" title="All 2 branches covered.">        if (diffY == 0) {</span>
            // horizontal line
<span class="fc" id="L958">            return Math.abs(yP - lineY0);</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="fc" id="L961">            return Math.abs(xP - lineX0);</span>
        }

<span class="fc" id="L964">        double pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>

<span class="fc" id="L966">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc" id="L968">        double dist = pt1/pt2;</span>

<span class="fc" id="L970">        return dist;</span>
    }

    /**
     * find the jagged line segments in the curve and return the ranges
     * of the point indexes.
     * This method searches for ledges first and then within the remaining
     * space, searches for stair cases and then 45 degree lines.
     * @param curve
     * @return
     */
    public PairIntArray findJaggedLineSegments(final PairIntArray curve) {

        //TODO: use minimum curve size
<span class="pc bpc" id="L984" title="2 of 4 branches missed.">        if (curve == null || curve.getN() &lt; 5) {</span>
<span class="nc" id="L985">            return new PairIntArray();</span>
        }

        /*
        search for ledges first, then in the space where ledges were not
        found, search for jagged lines (these have steps of height 1 but
        varying width).
        And as a comparison, for the spaces where ledges were not found,
        merge them if they are small and close and then research the
        merged ranges for jagged lines and then the remaining space
        for ledges.
        Combine the 2 results to make the best results.
        NOTE: need to simplify and combine the logic of the 2 searches...
         */

<span class="fc" id="L1000">        PairIntArray jaggedLines1 = findLedgesInCurve(curve);</span>

<span class="fc" id="L1002">        PairIntArray remainingRanges =</span>
<span class="fc" id="L1003">            writeRangesNotAlreadyIncluded(curve, jaggedLines1);</span>

<span class="fc bfc" id="L1005" title="All 2 branches covered.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {</span>

<span class="fc" id="L1007">            int r0 = remainingRanges.getX(i);</span>
<span class="fc" id="L1008">            int r1 = remainingRanges.getY(i);</span>

<span class="fc" id="L1010">            PairIntArray tmpStaircaseRanges =</span>
<span class="fc" id="L1011">                findJaggedLineStaircaseSegments(curve, r0, r1);</span>

<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">            if (tmpStaircaseRanges != null) {</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">                for (int j = 0; j &lt; tmpStaircaseRanges.getN(); j++) {</span>
<span class="fc" id="L1015">                    int s0 = tmpStaircaseRanges.getX(j);</span>
<span class="fc" id="L1016">                    int s1 = tmpStaircaseRanges.getY(j);</span>
<span class="fc" id="L1017">                    jaggedLines1.add(s0, s1);</span>
                }
            }
        }

<span class="fc" id="L1022">        sortByX(jaggedLines1);</span>

        // merge adjacent ranges
<span class="fc" id="L1025">        mergeRanges(curve, jaggedLines1);</span>

        // search for 45 degree lines
<span class="fc" id="L1028">        remainingRanges =</span>
<span class="fc" id="L1029">            writeRangesNotAlreadyIncluded(curve, jaggedLines1);</span>
<span class="fc" id="L1030">        boolean changed = false;</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {</span>
<span class="fc" id="L1032">            int r0 = remainingRanges.getX(i);</span>
<span class="fc" id="L1033">            int r1 = remainingRanges.getY(i);</span>
<span class="fc" id="L1034">            PairIntArray lineRanges =</span>
<span class="fc" id="L1035">                find45DegreeSegments(curve, r0, r1);</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">            if (lineRanges != null) {</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">                for (int j = 0; j &lt; lineRanges.getN(); j++) {</span>
<span class="fc" id="L1038">                    int s0 = lineRanges.getX(j);</span>
<span class="fc" id="L1039">                    int s1 = lineRanges.getY(j);</span>
<span class="fc" id="L1040">                    jaggedLines1.add(s0, s1);</span>
<span class="fc" id="L1041">                    changed = true;</span>
                }
            }
        }

<span class="fc bfc" id="L1046" title="All 2 branches covered.">        if (changed) {</span>

<span class="fc" id="L1048">            sortByX(jaggedLines1);</span>

            // merge ranges again
<span class="fc" id="L1051">            mergeRanges(curve, jaggedLines1);</span>
        }

<span class="fc" id="L1054">        return jaggedLines1;</span>
    }

    /**
     * find the jagged line segments in the curve and return the ranges
     * of the point indexes.
     * This method searches for staircases first and then within the remaining
     * space, searches for ledges and then 45 degree lines.
     * @param curve
     * @return
     */
    public PairIntArray findJaggedLineSegments2(final PairIntArray curve) {

        //TODO: use minimum curve size
<span class="pc bpc" id="L1068" title="2 of 4 branches missed.">        if (curve == null || curve.getN() &lt; 5) {</span>
<span class="nc" id="L1069">            return null;</span>
        }

        // if have a merged larger range, this suggests that starting a
        // search with staircases and following that with search for
        // ledges might result in more total accurately found jagged lines.
<span class="fc" id="L1075">        PairIntArray jaggedLines2 = findJaggedLineStaircaseSegments(</span>
<span class="fc" id="L1076">            curve, 0, curve.getN() - 1);</span>

<span class="fc" id="L1078">        PairIntArray remainingRanges = writeRangesNotAlreadyIncluded(curve,</span>
            jaggedLines2);
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {</span>
<span class="fc" id="L1081">            int r0 = remainingRanges.getX(i);</span>
<span class="fc" id="L1082">            int r1 = remainingRanges.getY(i);</span>
<span class="fc" id="L1083">            findLedgesWithinRange(curve, r0, r1, jaggedLines2);</span>
        }

<span class="fc" id="L1086">        sortByX(jaggedLines2);</span>

        // merge adjacent ranges
<span class="fc" id="L1089">        mergeRanges(curve, jaggedLines2);</span>

        // search for 45 degree lines
<span class="fc" id="L1092">        remainingRanges =</span>
<span class="fc" id="L1093">            writeRangesNotAlreadyIncluded(curve, jaggedLines2);</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {</span>
<span class="fc" id="L1095">            int r0 = remainingRanges.getX(i);</span>
<span class="fc" id="L1096">            int r1 = remainingRanges.getY(i);</span>
<span class="fc" id="L1097">            PairIntArray lineRanges =</span>
<span class="fc" id="L1098">                find45DegreeSegments(curve, r0, r1);</span>
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">            if (lineRanges != null) {</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">                for (int j = 0; j &lt; lineRanges.getN(); j++) {</span>
<span class="fc" id="L1101">                    int s0 = lineRanges.getX(j);</span>
<span class="fc" id="L1102">                    int s1 = lineRanges.getY(j);</span>
<span class="fc" id="L1103">                    jaggedLines2.add(s0, s1);</span>
                }
            }
        }

<span class="fc" id="L1108">        sortByX(jaggedLines2);</span>

        // merge ranges again
<span class="fc" id="L1111">        mergeRanges(curve, jaggedLines2);</span>

<span class="fc" id="L1113">        return jaggedLines2;</span>
    }

    private void mergeRanges(PairIntArray curve, PairIntArray ranges) {

<span class="fc" id="L1118">        int n = ranges.getN();</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        for (int i = (n - 1); i &gt; 0; i--) {</span>

<span class="fc" id="L1121">            int r0 = ranges.getX(i);</span>
<span class="fc" id="L1122">            int r1 = ranges.getY(i);</span>

            // gap between end of one range and start of the next that might
            // be part of both ranges
<span class="fc bfc" id="L1126" title="All 2 branches covered.">            if ((r0 - ranges.getY(i - 1)) &lt; 3) {</span>

                // check slopes before merging.

<span class="fc" id="L1130">                double theta10 = calcTheta(curve, r0, r1);</span>

<span class="fc" id="L1132">                int r2 = ranges.getX(i - 1);</span>
<span class="fc" id="L1133">                int r3 = ranges.getY(i - 1);</span>
<span class="fc" id="L1134">                double theta32 = calcTheta(curve, r2, r3);</span>

<span class="fc" id="L1136">                double diffTheta = Math.abs(theta10 - theta32);</span>

<span class="fc bfc" id="L1138" title="All 2 branches covered.">                if (diffTheta &gt; (Math.PI/4.)) {</span>
<span class="fc" id="L1139">                    continue;</span>
                }
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                if (diffTheta &gt; 0.1) {</span>
                    // this may be 2 regions due to 2 different methods,
                    // the ledges method and then staircase method,
                    // so retry the staircase alone for the full range to
                    // see if the entire region is found as a single region.
                    // r2 to r1
<span class="fc" id="L1147">                    PairIntArray staircaseRanges =</span>
<span class="fc" id="L1148">                        findJaggedLineStaircaseSegments(curve, r2, r1);</span>

<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">                    if (staircaseRanges != null) {</span>

<span class="fc bfc" id="L1152" title="All 2 branches covered.">                        for (int j = 0; j &lt; staircaseRanges.getN(); j++) {</span>
<span class="fc" id="L1153">                            int s0 = staircaseRanges.getX(j);</span>
<span class="fc" id="L1154">                            int s1 = staircaseRanges.getY(j);</span>
<span class="fc" id="L1155">                            log.fine(&quot;       &quot; + s0 + &quot; : &quot; + s1);</span>
                        }

<span class="fc bfc" id="L1158" title="All 2 branches covered.">                        if (staircaseRanges.getN() == 0) {</span>
                            // do not merge
<span class="fc" id="L1160">                            continue;</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">                        } else if (staircaseRanges.getN() == 1) {</span>
                            // does it match the whole range r2 to r1
                            // or only one of r2:r3 and r0:r1?
                            // if only matches one range, do not merge them

<span class="fc" id="L1166">                            int diff10 = Math.abs((r0 - staircaseRanges.getX(0)) +</span>
<span class="fc" id="L1167">                                (r1 - staircaseRanges.getY(0)));</span>

<span class="fc" id="L1169">                            int diff32 = Math.abs((r2 - staircaseRanges.getX(0)) +</span>
<span class="fc" id="L1170">                                (r3 - staircaseRanges.getY(0)));</span>

<span class="fc" id="L1172">                            int diff21 = Math.abs((r2 - staircaseRanges.getX(0)) +</span>
<span class="fc" id="L1173">                                (r1 - staircaseRanges.getY(0)));</span>

                            // which one is close to zero?
<span class="fc bfc" id="L1176" title="All 4 branches covered.">                            if ((diff21 &lt; diff10) &amp;&amp; (diff21 &lt; diff32)) {</span>
                                // let these merge
<span class="fc bfc" id="L1178" title="All 4 branches covered.">                            } else if ((diff32 &lt; diff10) &amp;&amp; (diff32 &lt; diff21)) {</span>
                                // matches the range r2 to r3, don't merge
<span class="fc" id="L1180">                                continue;</span>
<span class="pc bpc" id="L1181" title="1 of 4 branches missed.">                            } else if ((diff10 &lt; diff32) &amp;&amp; (diff10 &lt; diff21)) {</span>
                                // matches the range r0 to r1, don't merge
<span class="fc" id="L1183">                                continue;</span>
                            }

<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">                        } else if (staircaseRanges.getN() &gt; 1) {</span>
                            // keep the ranges separate
<span class="fc" id="L1188">                            continue;</span>
                        }
                    } else {
                        continue;
                    }
                }

<span class="fc" id="L1195">                ranges.set(i - 1, ranges.getX(i - 1), r1);</span>

<span class="fc" id="L1197">                ranges.removeRange(i, i);</span>
            }
        }

<span class="fc" id="L1201">    }</span>

    /**
     * find the lines composed of nearly uniform stairs and return them as
     * index ranges.  For example, a jagged line that extends from point
     * 10 to point 30 inclusive is present in the returned object as a pair
     * with (x, y) = (10, 30).
     * @param curve
     * @return
     */
    private PairIntArray findJaggedLineStaircaseSegments(final PairIntArray
        curve, int startIndex, int stopIndex) {

        //TODO: use minimum curve size
<span class="pc bpc" id="L1215" title="1 of 4 branches missed.">        if (curve == null || (stopIndex - startIndex) &lt; 5) {</span>
<span class="fc" id="L1216">            return new PairIntArray();</span>
        }

        /*
        iterate over the curve to find the nearly straight line segments.
        This is useful for quickly removing false corners due to jagged
        lines.
        -- move forward and learn dx and dy.  either dx or dy must be constant
        and have value -1 or +1.  the other dimension can only change by 0
        or by the same +1 or -1 always.  the step width between the change
        must be on average a certain value and any other steps included
        can be +1 or -1 in width (for example, if step width is 2, can have
        steps with width 1 and 3 included also).
        keep a moving average and when the just stated conditions cease,
        note the endpoints.
        --&gt; to be sure the section is a line, make an easy to remove section:
            fit the points to a line, noting the mean and stdev of the distance
            of them from the line.
            are the results consistent with a line?  mean error is?
        -- if the segment is longer than (tbd) pixels, store it
        -- repeat the above until end of curve is reached.
        */

<span class="fc" id="L1239">        PairIntArray lineSegmentRanges = new PairIntArray();</span>

<span class="fc" id="L1241">        int dx = 0;</span>
<span class="fc" id="L1242">        int dy = 0;</span>
<span class="fc" id="L1243">        int i = startIndex;</span>
<span class="fc" id="L1244">        Boolean widthIsAlongX = null;</span>
<span class="fc bfc" id="L1245" title="All 4 branches covered.">        while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1246">            i++;</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">            if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1248">                return lineSegmentRanges;</span>
            }
<span class="fc" id="L1250">            dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1251">            dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">            if (dx == 0) {</span>
<span class="fc" id="L1253">                widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">            } else if (dy == 0) {</span>
<span class="fc" id="L1255">                widthIsAlongX = Boolean.TRUE;</span>
            }
        }
<span class="fc" id="L1258">        int start = i;</span>

<span class="fc" id="L1260">        int keepDX = dx;</span>
<span class="fc" id="L1261">        int keepDY = dy;</span>

<span class="fc bfc" id="L1263" title="All 2 branches covered.">        if (widthIsAlongX == null) {</span>
<span class="fc bfc" id="L1264" title="All 4 branches covered.">            while ((dx != 0) &amp;&amp; (dy != 0)) {</span>
<span class="fc" id="L1265">                i++;</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">                if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1267">                    return lineSegmentRanges;</span>
                }
<span class="fc" id="L1269">                dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1270">                dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">                if (dx == 0) {</span>
<span class="fc" id="L1272">                    widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">                } else if (dy == 0) {</span>
<span class="fc" id="L1274">                    widthIsAlongX = Boolean.TRUE;</span>
                }
            }
        }
<span class="fc" id="L1278">        dx = keepDX;</span>
<span class="fc" id="L1279">        dy = keepDY;</span>
<span class="fc" id="L1280">        int stepStart = startIndex;</span>
<span class="fc" id="L1281">        int lineStart = startIndex;</span>
<span class="fc" id="L1282">        int nSteps = 0;</span>
<span class="fc" id="L1283">        int sumStepWidth = 0;</span>
<span class="fc" id="L1284">        float avgStepWidth = 0;</span>
<span class="fc" id="L1285">        float firstStepWidth = -1;</span>
<span class="fc" id="L1286">        float lastStepWidth = -1;</span>

<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">        for (i = start; i &lt;= stopIndex; i++) {</span>

<span class="fc" id="L1290">            int x = curve.getX(i);</span>
<span class="fc" id="L1291">            int y = curve.getY(i);</span>

<span class="fc" id="L1293">            int diffX = (x - curve.getX(i - 1));</span>

<span class="fc" id="L1295">            int diffY = (y - curve.getY(i - 1));</span>

            // if not a continuation of current step, increment step
<span class="fc" id="L1298">            if (!(</span>
<span class="fc bfc" id="L1299" title="All 6 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffX == dx) &amp;&amp; (diffY == 0))</span>
                ||
<span class="fc bfc" id="L1301" title="All 6 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffY == dy) &amp;&amp; (diffX == 0))</span>
                )
                ){

<span class="fc" id="L1305">                int currentStepWidth = i - stepStart;</span>

<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">                if (currentStepWidth &gt; 0) {</span>
<span class="fc bfc" id="L1308" title="All 2 branches covered.">                    if (nSteps == 0) {</span>
<span class="fc" id="L1309">                        firstStepWidth = currentStepWidth;</span>
                    }
<span class="fc" id="L1311">                    nSteps++;</span>
<span class="fc" id="L1312">                    sumStepWidth += currentStepWidth;</span>
<span class="fc" id="L1313">                    avgStepWidth = sumStepWidth/(float)nSteps;</span>
<span class="fc" id="L1314">                    stepStart = i;</span>
<span class="fc" id="L1315">                    lastStepWidth = currentStepWidth;</span>
                }
            }

            // if an invalid dx or dy, write the lineSegment and reset the range
<span class="fc bfc" id="L1320" title="All 2 branches covered.">            if ((i == stopIndex) ||</span>
<span class="fc bfc" id="L1321" title="All 4 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx))</span>
<span class="fc bfc" id="L1322" title="All 4 branches covered.">                || (!widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy))</span>
                ||
<span class="fc bfc" id="L1324" title="All 6 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy) &amp;&amp; (diffY != 0))</span>
                ||
<span class="fc bfc" id="L1326" title="All 6 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx) &amp;&amp; (diffX != 0))</span>
                ) {

<span class="fc bfc" id="L1329" title="All 2 branches covered.">                if (nSteps &gt; 2) {</span>

<span class="fc" id="L1331">                    int avg = Math.round(avgStepWidth);</span>

<span class="fc" id="L1333">                    int[] endSegment = validateJaggedLineSegment(curve,</span>
                        lineStart, (i - 1), avg, dx, dy,
                        widthIsAlongX);

                    // only store if has at least 3 steps (but if avg==1, 10)
<span class="fc bfc" id="L1338" title="All 8 branches covered.">                    if (</span>
                    ((avg == 1) &amp;&amp;
                        ((endSegment[0] - lineStart + 1) &gt;= 10)
                    )
                    ||
                    ((avg &gt; 1) &amp;&amp;
                        ((endSegment[0] - lineStart + 1) &gt;= 3 * avg)
                    )) {
<span class="fc bfc" id="L1346" title="All 8 branches covered.">                        if (</span>
                            ((lastStepWidth &gt;= 3) &amp;&amp; ((lastStepWidth/avg) &gt;= 2))
                            || ((lastStepWidth == 1) &amp;&amp; (avg &gt; 1))
                            ){

<span class="fc" id="L1351">                            int endMinus = (int)(endSegment[0] - lastStepWidth);</span>

<span class="fc bfc" id="L1353" title="All 2 branches covered.">                            if ((endMinus - lineStart + 1) &gt; 4) {</span>
<span class="fc" id="L1354">                                lineSegmentRanges.add(lineStart, endMinus);</span>
                            } else {
<span class="fc" id="L1356">                                lineSegmentRanges.add(lineStart, endSegment[0]);</span>
                            }
<span class="fc" id="L1358">                        } else {</span>
<span class="fc" id="L1359">                            lineSegmentRanges.add(lineStart, endSegment[0]);</span>
                        }
                    } else {
<span class="fc" id="L1362">                        i = lineStart + endSegment[1];</span>
                    }
                }

<span class="fc bfc" id="L1366" title="All 2 branches covered.">                if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1367">                    return lineSegmentRanges;</span>
                }

                //TODO: check the stepStart index
<span class="fc" id="L1371">                stepStart = i;</span>
<span class="fc" id="L1372">                lineStart = i;</span>

<span class="fc" id="L1374">                dx = 0;</span>
<span class="fc" id="L1375">                dy = 0;</span>
<span class="fc" id="L1376">                widthIsAlongX = null;</span>
<span class="fc" id="L1377">                int tmpI = i;</span>

<span class="fc bfc" id="L1379" title="All 4 branches covered.">                while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1380">                    i++;</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">                    if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1382">                        return lineSegmentRanges;</span>
                    }
<span class="fc" id="L1384">                    dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1385">                    dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">                    if (dx == 0) {</span>
<span class="fc" id="L1387">                        widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1388" title="All 2 branches covered.">                    } else if (dy == 0) {</span>
<span class="fc" id="L1389">                        widthIsAlongX = Boolean.TRUE;</span>
                    }
                }

<span class="fc" id="L1393">                keepDX = dx;</span>
<span class="fc" id="L1394">                keepDY = dy;</span>

<span class="fc bfc" id="L1396" title="All 2 branches covered.">                if (widthIsAlongX == null) {</span>
<span class="fc bfc" id="L1397" title="All 4 branches covered.">                    while ((dx != 0) &amp;&amp; (dy != 0)) {</span>
<span class="fc" id="L1398">                        i++;</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">                        if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1400">                            return lineSegmentRanges;</span>
                        }
<span class="fc" id="L1402">                        dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1403">                        dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">                        if (dx == 0) {</span>
<span class="fc" id="L1405">                            widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">                        } else if (dy == 0) {</span>
<span class="fc" id="L1407">                            widthIsAlongX = Boolean.TRUE;</span>
                        }
                    }

                } else {
                    // back track to find where the current linestart
                    // should be between tmpI and i
<span class="fc" id="L1414">                    boolean iChanged = false;</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">                    for (int j = (i - 1); j &gt; tmpI; j--) {</span>
<span class="fc" id="L1416">                        diffX = (curve.getX(j) - curve.getX(j - 1));</span>
<span class="fc" id="L1417">                        diffY = (curve.getY(j) - curve.getY(j - 1));</span>
<span class="fc bfc" id="L1418" title="All 6 branches covered.">                        if (widthIsAlongX &amp;&amp; (diffY == 0) &amp;&amp; (diffX == dx)) {</span>
<span class="fc" id="L1419">                            i = j;</span>
<span class="fc" id="L1420">                            iChanged = true;</span>
<span class="fc bfc" id="L1421" title="All 6 branches covered.">                        } else if (!widthIsAlongX &amp;&amp; (diffX == 0)</span>
                            &amp;&amp; (diffY == dy)) {
<span class="fc" id="L1423">                            i = j;</span>
<span class="fc" id="L1424">                            iChanged = true;</span>
                        }
                    }
<span class="fc bfc" id="L1427" title="All 2 branches covered.">                    if (iChanged) {</span>
<span class="fc" id="L1428">                        i--;</span>
                    }
                }

<span class="fc" id="L1432">                dx = keepDX;</span>
<span class="fc" id="L1433">                dy = keepDY;</span>
<span class="fc" id="L1434">                sumStepWidth = 0;</span>
<span class="fc" id="L1435">                avgStepWidth = 0;</span>
<span class="fc" id="L1436">                nSteps = 0;</span>
<span class="fc" id="L1437">                lastStepWidth = -1;</span>
<span class="fc" id="L1438">                firstStepWidth = -1;</span>

<span class="fc" id="L1440">                lineStart = i;</span>
            }
        }

<span class="nc" id="L1444">        return lineSegmentRanges;</span>

    }

    /**
     * find the lines composed of nearly uniform stairs and return them as
     * index ranges.  For example, a jagged line that extends from point
     * 10 to point 30 inclusive is present in the returned object as a pair
     * with (x, y) = (10, 30).
     * @param curve
     * @return
     */
    private PairIntArray find45DegreeSegments(final PairIntArray
        curve, int startIndex, int stopIndex) {

        //TODO: use minimum curve size
<span class="pc bpc" id="L1460" title="1 of 4 branches missed.">        if (curve == null || (stopIndex - startIndex) &lt; 5) {</span>
<span class="fc" id="L1461">            return new PairIntArray();</span>
        }

<span class="fc" id="L1464">        int minNSteps = 4;</span>

<span class="fc" id="L1466">        PairIntArray lineSegmentRanges = new PairIntArray();</span>

<span class="fc" id="L1468">        int dx = 0;</span>
<span class="fc" id="L1469">        int dy = 0;</span>
<span class="fc" id="L1470">        int i = startIndex;</span>
<span class="fc bfc" id="L1471" title="All 4 branches covered.">        while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1472">            i++;</span>
<span class="fc bfc" id="L1473" title="All 2 branches covered.">            if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1474">                return lineSegmentRanges;</span>
            }
<span class="fc" id="L1476">            dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1477">            dy = (curve.getY(i) - curve.getY(i - 1));</span>
        }
<span class="fc" id="L1479">        int start = i;</span>

<span class="fc" id="L1481">        int stepStart = startIndex;</span>
<span class="fc" id="L1482">        int lineStart = startIndex;</span>
<span class="fc" id="L1483">        int nSteps = 0;</span>
<span class="fc" id="L1484">        int sumStepWidth = 0;</span>
<span class="fc" id="L1485">        float avgStepWidth = 0;</span>
<span class="fc" id="L1486">        float firstStepWidth = -1;</span>
<span class="fc" id="L1487">        float lastStepWidth = -1;</span>

<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">        for (i = start; i &lt;= stopIndex; i++) {</span>

<span class="fc" id="L1491">            int x = curve.getX(i);</span>
<span class="fc" id="L1492">            int y = curve.getY(i);</span>

<span class="fc" id="L1494">            int diffX = (x - curve.getX(i - 1));</span>

<span class="fc" id="L1496">            int diffY = (y - curve.getY(i - 1));</span>

<span class="fc" id="L1498">            int currentStepWidth = i - stepStart;</span>

<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">            if (currentStepWidth &gt; 0) {</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                if (nSteps == 0) {</span>
<span class="fc" id="L1502">                    firstStepWidth = currentStepWidth;</span>
                }
<span class="fc" id="L1504">                nSteps++;</span>
<span class="fc" id="L1505">                sumStepWidth += currentStepWidth;</span>
<span class="fc" id="L1506">                avgStepWidth = sumStepWidth/(float)nSteps;</span>
<span class="fc" id="L1507">                stepStart = i;</span>
<span class="fc" id="L1508">                lastStepWidth = currentStepWidth;</span>
            }

            // if an invalid dx or dy, write the lineSegment and reset the range
<span class="fc bfc" id="L1512" title="All 6 branches covered.">            if ((i == stopIndex) || (diffX != dx) || (diffY != dy)</span>
                ) {

<span class="fc bfc" id="L1515" title="All 2 branches covered.">                if (nSteps &gt; minNSteps) {</span>

<span class="fc" id="L1517">                    lineSegmentRanges.add(lineStart, i - 1);</span>

                }

<span class="fc bfc" id="L1521" title="All 2 branches covered.">                if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1522">                    return lineSegmentRanges;</span>
                }

                //TODO: check the stepStart index
<span class="fc" id="L1526">                stepStart = i;</span>
<span class="fc" id="L1527">                lineStart = i;</span>

<span class="fc" id="L1529">                dx = 0;</span>
<span class="fc" id="L1530">                dy = 0;</span>

<span class="fc bfc" id="L1532" title="All 4 branches covered.">                while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1533">                    i++;</span>
<span class="fc bfc" id="L1534" title="All 2 branches covered.">                    if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1535">                        return lineSegmentRanges;</span>
                    }
<span class="fc" id="L1537">                    dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1538">                    dy = (curve.getY(i) - curve.getY(i - 1));</span>
                }

<span class="fc" id="L1541">                sumStepWidth = 0;</span>
<span class="fc" id="L1542">                avgStepWidth = 0;</span>
<span class="fc" id="L1543">                nSteps = 0;</span>
<span class="fc" id="L1544">                lastStepWidth = -1;</span>
<span class="fc" id="L1545">                firstStepWidth = -1;</span>

<span class="fc" id="L1547">                lineStart = i;</span>
            }
        }

<span class="nc" id="L1551">        return lineSegmentRanges;</span>

    }

    /**
     * validate that a line segment has steps only within +- 1 of
     * step stepWidth.  returns endIndex if entire region fits those
     * characteristics, else returns the last index where it does.
     *
     * @param curve
     * @param startIndex
     * @param stopIndex last index of line segment, inclusive
     * @param stepWidth
     * @param dy
     * @param dy
     * @param widthIsAlongX
     * @return
     */
     int[] validateJaggedLineSegment(final PairIntArray curve,
        int startIndex, int stopIndex, int stepWidth, int dx, int dy,
        Boolean widthIsAlongX) {

        //TODO: use minimum curve size
<span class="pc bpc" id="L1574" title="2 of 4 branches missed.">        if (curve == null || curve.getN() &lt; 5) {</span>
<span class="nc" id="L1575">            return new int[]{-1, -1};</span>
        }

<span class="fc" id="L1578">        int plusMinusWidth = 3;</span>

<span class="fc" id="L1580">        int n = curve.getN();</span>

<span class="fc" id="L1582">        int start = startIndex + 1;</span>

<span class="fc" id="L1584">        int stepStart = startIndex;</span>

        int i;
<span class="pc bpc" id="L1587" title="1 of 2 branches missed.">        for (i = start; i &lt;= stopIndex; i++) {</span>

<span class="fc" id="L1589">            int diffX = (curve.getX(i) - curve.getX(i - 1));</span>

<span class="fc" id="L1591">            int diffY = (curve.getY(i) - curve.getY(i - 1));</span>

<span class="fc bfc" id="L1593" title="All 4 branches covered.">            if ((widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx)) ||</span>
<span class="fc bfc" id="L1594" title="All 6 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy)</span>
                &amp;&amp; (diffY != 0)) ||
<span class="fc bfc" id="L1596" title="All 4 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy)) ||</span>
<span class="pc bpc" id="L1597" title="1 of 6 branches missed.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx)</span>
                &amp;&amp; (diffX != 0)) ) {

<span class="fc" id="L1600">                int currentStepWidth = i - stepStart;</span>
<span class="pc bpc" id="L1601" title="1 of 2 branches missed.">                if (currentStepWidth &gt; 0) {</span>
<span class="fc bfc" id="L1602" title="All 2 branches covered.">                    if (Math.abs(currentStepWidth - stepWidth) &gt; plusMinusWidth) {</span>
<span class="fc" id="L1603">                        return new int[]{(stepStart - 1), currentStepWidth};</span>
                    }
                } else {
<span class="nc" id="L1606">                    return new int[]{(stepStart - 1), currentStepWidth};</span>
                }

                /*
                (widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy)
                &amp;&amp; (diffY != 0))
                      --&gt; (stepStart - 1)
                */
<span class="fc" id="L1614">                return new int[]{(i - 1), 0};</span>
            }

            // else, if just stepped up or is last index, check step size

<span class="fc bfc" id="L1619" title="All 4 branches covered.">            if ((widthIsAlongX.booleanValue() &amp;&amp; (diffY == dy)) ||</span>
<span class="fc bfc" id="L1620" title="All 6 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffX == dx)) ||</span>
                (i == stopIndex)
            ) {

<span class="fc" id="L1624">                int currentStepWidth = i - stepStart;</span>

<span class="fc bfc" id="L1626" title="All 6 branches covered.">                if ((stepStart == 0) &amp;&amp; (stepWidth == 1) &amp;&amp;</span>
                    (currentStepWidth/stepWidth &gt; 1)) {

<span class="fc" id="L1629">                    return new int[]{0, currentStepWidth};</span>

<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">                } else if (currentStepWidth &gt; 0) {</span>

<span class="fc bfc" id="L1633" title="All 2 branches covered.">                    if (Math.abs(currentStepWidth - stepWidth) &gt; plusMinusWidth) {</span>
<span class="fc" id="L1634">                        return new int[]{(stepStart - 1), currentStepWidth};</span>
<span class="fc bfc" id="L1635" title="All 2 branches covered.">                    } else if (i == stopIndex) {</span>
<span class="fc" id="L1636">                        return new int[]{i, currentStepWidth};</span>
                    }

<span class="fc" id="L1639">                    stepStart = i;</span>

<span class="nc bnc" id="L1641" title="All 2 branches missed.">                } else if (currentStepWidth == 0) {</span>

<span class="nc" id="L1643">                    return new int[]{(stepStart - 1), 0};</span>
                }
            }
        }

<span class="nc" id="L1648">        return new int[]{(i - 1), 0};</span>
    }

     /**
      * write the set difference of the given set of ranges, indexRanges,
      * to create the set of ranges not included in indexRanges.  Note the
      * large universe that both are subsets of is curve.
      */
     private PairIntArray writeRangesNotAlreadyIncluded(PairIntArray curve,
        PairIntArray indexRanges) {

<span class="fc" id="L1659">        PairIntArray output = new PairIntArray();</span>

<span class="fc" id="L1661">        int n = curve.getN();</span>

<span class="fc bfc" id="L1663" title="All 2 branches covered.">        if (indexRanges.getN() == 0) {</span>
<span class="fc" id="L1664">            output.add(0, n - 1);</span>
        } else {
<span class="fc" id="L1666">            int idx0 = indexRanges.getX(0);</span>
<span class="fc bfc" id="L1667" title="All 2 branches covered.">            if (idx0 &gt; 0) {</span>
<span class="fc" id="L1668">                output.add(0, idx0 - 1);</span>
            }
<span class="fc bfc" id="L1670" title="All 2 branches covered.">            for (int si = 1; si &lt; indexRanges.getN(); si++) {</span>
<span class="fc" id="L1671">                output.add(indexRanges.getY(si - 1), indexRanges.getX(si));</span>
            }
<span class="fc" id="L1673">            output.add(indexRanges.getY(indexRanges.getN() - 1),</span>
<span class="fc" id="L1674">                curve.getN() - 1);</span>
        }

<span class="fc" id="L1677">        return output;</span>
     }

     /**
      * in the curve points that are not within the staircaseSegmentRanges,
      * look for the single pixel ledge in a long stretch of a line and store
      * the entire range.  There may be more than one single pixel range
      * within a range.  a range is stored in the return array as a
      * point (x,y) = (start of range, stop of range inclusive).
      * @param curve
      * @param staircaseSegmentRanges
      * @return
      */
    PairIntArray findLedgesInCurve(PairIntArray curve) {

        /*
        looking for long stretch of line that changes by 1 pixel and then
        continues in a long line
        */

<span class="fc" id="L1697">        PairIntArray allLedges = new PairIntArray();</span>

<span class="fc" id="L1699">        findLedgesWithinRange(curve, 0, curve.getN() - 1, allLedges);</span>

<span class="fc" id="L1701">        return allLedges;</span>
    }

    /**
     * find any ledges within the range start to stop, inclusive and return
     * them as indexes of the curve.  For example, a ledge extending from
     * point 10 to point 30 inclusive is in a pair in allLedges
     * as (x,y) = (10, 30);
     * @param curve set of x,y points which comprise a curve
     * @param start first index of curve to search, inclusive
     * @param stop last index of curve to search, inclusive
     * @param allLedges the set of ranges to add the results of this too.
     * It's the output for the method.
     */
    private void findLedgesWithinRange(PairIntArray curve, int start, int stop,
        PairIntArray allLedges) {

<span class="fc bfc" id="L1718" title="All 2 branches covered.">        if ((stop - start + 1) &lt; (2*minLedgeWidth)) {</span>
<span class="fc" id="L1719">            return;</span>
        }

        // similar o findJaggedLineStaircaseSegments, but with a step size of
        // &quot;1&quot;

<span class="fc" id="L1725">        int dx = 0;</span>
<span class="fc" id="L1726">        int dy = 0;</span>
<span class="fc" id="L1727">        int i = start;</span>
<span class="fc" id="L1728">        Boolean runIsAlongX = null;</span>
        // looking for straight lines of x or y
<span class="fc bfc" id="L1730" title="All 8 branches covered.">        while (!((dx == 0) &amp;&amp; (dy != 0)) &amp;&amp; !((dy == 0) &amp;&amp; (dx != 0))) {</span>
<span class="fc" id="L1731">            i++;</span>
<span class="fc bfc" id="L1732" title="All 2 branches covered.">            if (i &gt; (stop - 1)) {</span>
<span class="fc" id="L1733">                return;</span>
            }
<span class="fc" id="L1735">            dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1736">            dy = (curve.getY(i) - curve.getY(i - 1));</span>
        }

<span class="fc bfc" id="L1739" title="All 2 branches covered.">        if (dx == 0) {</span>
<span class="fc" id="L1740">            runIsAlongX = Boolean.FALSE;</span>
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">        } else if (dy == 0) {</span>
<span class="fc" id="L1742">            runIsAlongX = Boolean.TRUE;</span>
        }

<span class="fc" id="L1745">        int tmpI = i;</span>

        // back track to find where the current linestart
        // should be between start and i
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        for (int j = (i - 1); j &gt;= (start + 1); j--) {</span>
<span class="fc" id="L1750">            int diffX = (curve.getX(j) - curve.getX(j - 1));</span>
<span class="fc" id="L1751">            int diffY = (curve.getY(j) - curve.getY(j - 1));</span>
<span class="pc bpc" id="L1752" title="1 of 4 branches missed.">            if ((diffY != dy) || (diffX != dx)) {</span>
<span class="fc" id="L1753">                i = j;</span>
            }
        }

<span class="fc" id="L1757">        int lineStart = i;</span>

<span class="fc" id="L1759">        PairIntArray tmp = new PairIntArray();</span>
<span class="fc" id="L1760">        Boolean tmpRunIsAlongX = null;</span>
<span class="fc" id="L1761">        int tmpDX = -1;</span>
<span class="fc" id="L1762">        int tmpDY = -1;</span>

<span class="fc bfc" id="L1764" title="All 2 branches covered.">        for (i = (lineStart + 1); i &lt;= stop; i++) {</span>

<span class="fc" id="L1766">            int x = curve.getX(i);</span>
<span class="fc" id="L1767">            int y = curve.getY(i);</span>

<span class="fc" id="L1769">            int diffX = (x - curve.getX(i - 1));</span>

<span class="fc" id="L1771">            int diffY = (y - curve.getY(i - 1));</span>

            /* if there's a break in the line:
                  temporarily store the section so far.

                  if the next segment is consecutive and has same runIsAlongX
                  and same diffX and diffY,
                      continue with same tmp storage,
                  else {
                     inspect storage and add to allLedges if looks like a ledge,
                     then clear the tmp storage and the last vars&quot;
                  }
            */

<span class="fc bfc" id="L1785" title="All 4 branches covered.">            boolean runStopped = (runIsAlongX &amp;&amp; (diffY != 0)) ||</span>
<span class="fc bfc" id="L1786" title="All 4 branches covered.">                (!runIsAlongX &amp;&amp; (diffX != 0));</span>

<span class="fc bfc" id="L1788" title="All 4 branches covered.">            if ((i == stop) ||</span>
                runStopped ||
<span class="fc bfc" id="L1790" title="All 4 branches covered.">                (runIsAlongX &amp;&amp; (diffX != dx)) ||</span>
<span class="fc bfc" id="L1791" title="All 4 branches covered.">                (!runIsAlongX &amp;&amp; (diffY != dy)) ) {</span>

<span class="fc" id="L1793">                int rs = i - lineStart;</span>

<span class="fc bfc" id="L1795" title="All 2 branches covered.">                if (rs &gt;= minLedgeWidth) {</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">                    if (i == stop) {</span>
<span class="fc bfc" id="L1797" title="All 2 branches covered.">                        if (runStopped) {</span>
<span class="fc" id="L1798">                            tmp.add(lineStart, i - 1);</span>
                        } else {
<span class="fc" id="L1800">                            tmp.add(lineStart, i);</span>
                        }
                    } else {
<span class="fc" id="L1803">                        tmp.add(lineStart, i - 1);</span>
                    }
<span class="fc" id="L1805">                    tmpRunIsAlongX = runIsAlongX;</span>
<span class="fc" id="L1806">                    tmpDX = dx;</span>
<span class="fc" id="L1807">                    tmpDY = dy;</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">                } else if ((i == (curve.getN() - 1)) /*&amp;&amp; (tmp.getN() &gt; 0) &amp;&amp;</span>
                    (Math.abs(lineStart - tmp.getY(tmp.getN() - 1)) &lt; 2)*/) {
<span class="fc" id="L1810">                    tmp.add(lineStart, i);</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">                } else if (tmp.getN() == 1) {</span>
<span class="fc" id="L1812">                    allLedges.add(tmp.getX(0), tmp.getY(0));</span>
<span class="fc" id="L1813">                    tmp = new PairIntArray();</span>
                }

<span class="fc bfc" id="L1816" title="All 2 branches covered.">                if (i != stop) {</span>
                    // find the next line segment
<span class="fc" id="L1818">                    dx = 0;</span>
<span class="fc" id="L1819">                    dy = 0;</span>
<span class="fc" id="L1820">                    runIsAlongX = null;</span>
                    // looking for straight lines of x or y
<span class="fc" id="L1822">                    tmpI = i;</span>
<span class="fc bfc" id="L1823" title="All 8 branches covered.">                    while (!((dx == 0) &amp;&amp; (dy != 0)) &amp;&amp;</span>
                        !((dy == 0) &amp;&amp; (dx != 0))) {
<span class="fc" id="L1825">                        i++;</span>
<span class="fc bfc" id="L1826" title="All 2 branches covered.">                        if (i &gt;= stop) {</span>
<span class="fc" id="L1827">                            break;</span>
                        }
<span class="fc" id="L1829">                        dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1830">                        dy = (curve.getY(i) - curve.getY(i - 1));</span>
                    }

<span class="fc bfc" id="L1833" title="All 2 branches covered.">                    if (i &lt; stop) {</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">                        if (dx == 0) {</span>
<span class="fc" id="L1835">                            runIsAlongX = Boolean.FALSE;</span>
<span class="pc bpc" id="L1836" title="1 of 2 branches missed.">                        } else if (dy == 0) {</span>
<span class="fc" id="L1837">                            runIsAlongX = Boolean.TRUE;</span>
                        }

                        // back track to find where the current linestart
                        // should be between tmpI and i
<span class="fc bfc" id="L1842" title="All 2 branches covered.">                        for (int j = (i - 1); j &gt;= tmpI; j--) {</span>
<span class="fc" id="L1843">                            diffX = (curve.getX(j) - curve.getX(j - 1));</span>
<span class="fc" id="L1844">                            diffY = (curve.getY(j) - curve.getY(j - 1));</span>
<span class="fc bfc" id="L1845" title="All 4 branches covered.">                            if ((diffY != dy) || (diffX != dx)) {</span>
<span class="fc" id="L1846">                                i = j;</span>
                            }
                        }

<span class="fc" id="L1850">                        lineStart = i;</span>
                    }
                }

<span class="fc" id="L1854">                int tmpN = tmp.getN();</span>

                // if this is not consecutive segment,
                // decide whether to store, then reset tmp
<span class="fc bfc" id="L1858" title="All 2 branches covered.">                if ((i &gt;= stop) || (</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">                    (tmp.getN() &gt; 0) &amp;&amp;</span>
                    !(
<span class="fc bfc" id="L1861" title="All 6 branches covered.">                        (runIsAlongX.compareTo(tmpRunIsAlongX) == 0)</span>
                        &amp;&amp; (dx == tmpDX) &amp;&amp; (tmpDY == dy)
<span class="fc bfc" id="L1863" title="All 2 branches covered.">                        &amp;&amp; ((lineStart - (tmp.getY(tmpN - 1)) &lt; 3))</span>
                    )
                    )
                    ) {

<span class="fc bfc" id="L1868" title="All 4 branches covered.">                    if (tmp.getN() &gt; 1 || ((tmp.getN() &gt; 0)</span>
<span class="fc bfc" id="L1869" title="All 2 branches covered.">                        &amp;&amp; (i == (curve.getN() - 1)))) {</span>

                        // need to avoid removing a partial corner

<span class="fc" id="L1873">                        boolean keep = true;</span>

                        // check that the lines are not wrapping around a curve
<span class="fc bfc" id="L1876" title="All 2 branches covered.">                        if (tmp.getN() &gt; 1) {</span>
<span class="fc" id="L1877">                            int idx0f = tmp.getX(0);</span>
<span class="fc" id="L1878">                            int idx0l = tmp.getY(0);</span>
<span class="fc" id="L1879">                            double theta0 = calcTheta(curve, idx0f, idx0l);</span>

<span class="fc bfc" id="L1881" title="All 2 branches covered.">                            for (int j = 1; j &lt; tmp.getN(); j++) {</span>
<span class="fc" id="L1882">                                idx0f = tmp.getX(j);</span>
<span class="fc" id="L1883">                                idx0l = tmp.getY(j);</span>
<span class="fc" id="L1884">                                double theta1 = calcTheta(curve, idx0f, idx0l);</span>

                                // don't add corners
<span class="fc" id="L1887">                                double diff = Math.abs(theta0 - theta1);</span>
<span class="fc bfc" id="L1888" title="All 2 branches covered.">                                if (diff &gt; Math.PI/4.) {</span>
<span class="fc" id="L1889">                                    keep = false;</span>
<span class="fc" id="L1890">                                    break;</span>
                                }
<span class="fc" id="L1892">                                theta0 = theta1;</span>
                            }
                        }

<span class="fc bfc" id="L1896" title="All 2 branches covered.">                        if (keep) {</span>
<span class="fc" id="L1897">                            allLedges.add(tmp.getX(0), tmp.getY(tmp.getN() - 1));</span>
                        }

<span class="fc" id="L1900">                        tmp = new PairIntArray();</span>
                    }
                }
            }
        }
<span class="fc" id="L1905">    }</span>

    public void sortByX(PairIntArray curve) {
<span class="fc bfc" id="L1908" title="All 2 branches covered.">        if (curve.getN() &lt; 2) {</span>
<span class="fc" id="L1909">            return;</span>
        }
<span class="fc" id="L1911">        sortByX(curve, 0, curve.getN() - 1);</span>
<span class="fc" id="L1912">    }</span>

    private void sortByX(PairIntArray curve, int idxLo, int idxHi) {
<span class="fc bfc" id="L1915" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1916">            int idxMid = partitionByX(curve, idxLo, idxHi);</span>
<span class="fc" id="L1917">            sortByX(curve, idxLo, idxMid - 1);</span>
<span class="fc" id="L1918">            sortByX(curve, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1920">    }</span>

    private int partitionByX(PairIntArray curve, int idxLo, int idxHi) {

<span class="fc" id="L1924">        int x = curve.getX(idxHi);  //for comparison</span>
<span class="fc" id="L1925">        int store = idxLo - 1;      //store to swap after pivot</span>

<span class="fc bfc" id="L1927" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L1928" title="All 2 branches covered.">            if (curve.getX(i) &lt;= x) {</span>
<span class="fc" id="L1929">                store++;</span>
<span class="fc" id="L1930">                int swapX = curve.getX(store);</span>
<span class="fc" id="L1931">                int swapY = curve.getY(store);</span>
<span class="fc" id="L1932">                curve.set(store, curve.getX(i), curve.getY(i));</span>
<span class="fc" id="L1933">                curve.set(i, swapX, swapY);</span>
            }
        }
<span class="fc" id="L1936">        store++;</span>

<span class="fc" id="L1938">        int swapX = curve.getX(store);</span>
<span class="fc" id="L1939">        int swapY = curve.getY(store);</span>
<span class="fc" id="L1940">        curve.set(store, curve.getX(idxHi), curve.getY(idxHi));</span>
<span class="fc" id="L1941">        curve.set(idxHi, swapX, swapY);</span>

<span class="fc" id="L1943">        return store;</span>
    }

    private double calcTheta(PairIntArray curve, int idx0, int idx1) {

<span class="fc" id="L1948">        int x10 = curve.getX(idx1) - curve.getX(idx0);</span>
<span class="fc" id="L1949">        int y10 = curve.getY(idx1) - curve.getY(idx0);</span>
        double theta;
<span class="fc bfc" id="L1951" title="All 2 branches covered.">        if (x10 == 0) {</span>
<span class="fc bfc" id="L1952" title="All 2 branches covered.">            theta = (y10 &lt; 0) ? 1.5 * Math.PI : 0.5 * Math.PI;</span>
        } else {
<span class="fc" id="L1954">            theta = Math.atan((double) y10 / (double) x10);</span>
        }

<span class="fc" id="L1957">        return theta;</span>
    }

    public PairInt[] findClosestPair(Set&lt;PairInt&gt; set0, Set&lt;PairInt&gt; set1) {

<span class="pc bpc" id="L1962" title="1 of 2 branches missed.">        if (set0 == null) {</span>
<span class="nc" id="L1963">            throw new IllegalArgumentException(&quot;set0 cannot be null&quot;);</span>
        }

<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L1967">            throw new IllegalArgumentException(&quot;set1 cannot be null&quot;);</span>
        }

<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">        if (set0.isEmpty()) {</span>
<span class="nc" id="L1971">            throw new IllegalArgumentException(&quot;set0 cannot be empty&quot;);</span>
        }

<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">        if (set1.isEmpty()) {</span>
<span class="nc" id="L1975">            throw new IllegalArgumentException(&quot;set1 cannot be empty&quot;);</span>
        }

        //TODO: consider other algorithms besides brute force

<span class="fc" id="L1980">        double minDistSq = Double.MAX_VALUE;</span>
<span class="fc" id="L1981">        PairInt p0 = null;</span>
<span class="fc" id="L1982">        PairInt p1 = null;</span>

<span class="fc bfc" id="L1984" title="All 2 branches covered.">        for (PairInt s0 : set0) {</span>

<span class="fc" id="L1986">            double x = s0.getX();</span>
<span class="fc" id="L1987">            double y = s0.getY();</span>

<span class="fc bfc" id="L1989" title="All 2 branches covered.">            for (PairInt s1 : set1) {</span>

<span class="fc" id="L1991">                double x1 = s1.getX();</span>
<span class="fc" id="L1992">                double y1 = s1.getY();</span>

<span class="fc" id="L1994">                double diffX = x1 - x;</span>
<span class="fc" id="L1995">                double diffY = y1 - y;</span>

<span class="fc" id="L1997">                double distSq = (diffX * diffX) + (diffY * diffY);</span>

<span class="fc bfc" id="L1999" title="All 2 branches covered.">                if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L2000">                    minDistSq = distSq;</span>
<span class="fc" id="L2001">                    p0 = s0;</span>
<span class="fc" id="L2002">                    p1 = s1;</span>
                }
<span class="fc" id="L2004">            }</span>
<span class="fc" id="L2005">        }</span>

<span class="fc" id="L2007">        return new PairInt[]{p0, p1};</span>
    }

    public void populateGapsWithInterpolation(Set&lt;PairInt&gt; points) {

        // probably many ways to do this... ordered point algorithm?
        // dfs to find connected groups, then connect the closest among those?

<span class="fc" id="L2015">        int[] minMaxXY = MiscMath.findMinMaxXY(points);</span>

<span class="fc" id="L2017">        DFSConnectedGroupsFinder finder = new DFSConnectedGroupsFinder();</span>
<span class="fc" id="L2018">        finder.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L2019">        finder.findConnectedPointGroups(points, minMaxXY[1] + 1, minMaxXY[3] + 1);</span>

<span class="fc" id="L2021">        int nIter = 0;</span>
<span class="fc" id="L2022">        int nMaxIter = 10;</span>

<span class="fc" id="L2024">        int nGroups = finder.getNumberOfGroups();</span>

<span class="pc bpc" id="L2026" title="1 of 4 branches missed.">        while ((nGroups &gt; 1) &amp;&amp; (nIter &lt; nMaxIter)) {</span>

            // find the closest pair of points between any 2 groups

<span class="fc" id="L2030">            double minDistSq = Double.MAX_VALUE;</span>
<span class="fc" id="L2031">            PairInt minDistPoint0 = null;</span>
<span class="fc" id="L2032">            PairInt minDistPoint1 = null;</span>
<span class="fc" id="L2033">            int minDistGroupId0 = -1;</span>
<span class="fc" id="L2034">            int minDistGroupId1 = -1;</span>

<span class="fc bfc" id="L2036" title="All 2 branches covered.">            for (int g0Idx = 0; g0Idx &lt; nGroups; g0Idx++) {</span>

<span class="fc" id="L2038">                Set&lt;PairInt&gt; g0 = finder.getXY(g0Idx);</span>

<span class="fc bfc" id="L2040" title="All 2 branches covered.">                for (int g1Idx = 0; g1Idx &lt; nGroups; g1Idx++) {</span>

<span class="fc bfc" id="L2042" title="All 2 branches covered.">                    if (g0Idx == g1Idx) {</span>
<span class="fc" id="L2043">                        continue;</span>
                    }

<span class="fc" id="L2046">                    Set&lt;PairInt&gt; g1 = finder.getXY(g1Idx);</span>

<span class="fc" id="L2048">                    PairInt[] closestPair = findClosestPair(g0, g1);</span>

<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">                    if (closestPair == null) {</span>
<span class="nc" id="L2051">                        continue;</span>
                    }

<span class="fc" id="L2054">                    double x0 = closestPair[0].getX();</span>
<span class="fc" id="L2055">                    double y0 = closestPair[0].getY();</span>

<span class="fc" id="L2057">                    double x1 = closestPair[1].getX();</span>
<span class="fc" id="L2058">                    double y1 = closestPair[1].getY();</span>

<span class="fc" id="L2060">                    double diffX = x1 - x0;</span>
<span class="fc" id="L2061">                    double diffY = y1 - y0;</span>

<span class="fc" id="L2063">                    double distSq = (diffX * diffX) + (diffY * diffY);</span>

<span class="fc bfc" id="L2065" title="All 2 branches covered.">                    if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L2066">                        minDistSq = distSq;</span>
<span class="fc" id="L2067">                        minDistPoint0 = closestPair[0];</span>
<span class="fc" id="L2068">                        minDistPoint1 = closestPair[1];</span>
<span class="fc" id="L2069">                        minDistGroupId0 = g0Idx;</span>
<span class="fc" id="L2070">                        minDistGroupId1 = g1Idx;</span>
                    }
                }
            }

<span class="pc bpc" id="L2075" title="1 of 2 branches missed.">            if (minDistPoint0 != null) {</span>

<span class="fc" id="L2077">                double x1 = minDistPoint1.getX();</span>
<span class="fc" id="L2078">                double y1 = minDistPoint1.getY();</span>

<span class="fc" id="L2080">                double dxDivDy = (minDistPoint0.getX() - x1)/</span>
<span class="fc" id="L2081">                    (minDistPoint0.getY() - y1);</span>

                /*
                x0 - x1
                ------- = dxDivDy
                y0 - y1

                x0 - x1 = (y0 - y1) * dyDivDx;
                x0 = x1 + (y0 - y1) * dyDivDx;
                */
                int startY, stopY;
<span class="fc bfc" id="L2092" title="All 2 branches covered.">                if (minDistPoint0.getY() &lt; minDistPoint1.getY()) {</span>
<span class="fc" id="L2093">                    startY = minDistPoint0.getY();</span>
<span class="fc" id="L2094">                    stopY = minDistPoint1.getY();</span>
                } else {
<span class="fc" id="L2096">                    startY = minDistPoint1.getY();</span>
<span class="fc" id="L2097">                    stopY = minDistPoint0.getY();</span>
                }

<span class="fc bfc" id="L2100" title="All 2 branches covered.">                for (int y = startY; y &lt;= stopY; y++) {</span>

<span class="fc" id="L2102">                    int x = (int)Math.round(x1 + (y - y1) * dxDivDy);</span>

<span class="fc" id="L2104">                    PairInt p = new PairInt(x, y);</span>

<span class="fc" id="L2106">                    boolean added = points.add(p);</span>
                }

                /*
                y0 - y1
                ------- = dyDivDx
                x0 - x1

                y0 - y1 = (x0 - x1) * dxDivDy;
                y0 = y1 + (x0 - x1) * dxDivDy;
                */
<span class="fc" id="L2117">                double dyDivDx = (minDistPoint0.getY() - y1)/</span>
<span class="fc" id="L2118">                    (minDistPoint0.getX() - x1);</span>

                int startX, stopX;
<span class="fc bfc" id="L2121" title="All 2 branches covered.">                if (minDistPoint0.getX() &lt; minDistPoint1.getX()) {</span>
<span class="fc" id="L2122">                    startX = minDistPoint0.getX();</span>
<span class="fc" id="L2123">                    stopX = minDistPoint1.getX();</span>
                } else {
<span class="fc" id="L2125">                    startX = minDistPoint1.getX();</span>
<span class="fc" id="L2126">                    stopX = minDistPoint0.getX();</span>
                }

<span class="fc bfc" id="L2129" title="All 2 branches covered.">                for (int x = startX; x &lt;= stopX; x++) {</span>

<span class="fc" id="L2131">                    int y = (int)Math.round(y1 + (x - x1) * dyDivDx);</span>

<span class="fc" id="L2133">                    PairInt p = new PairInt(x, y);</span>

<span class="fc" id="L2135">                    boolean added = points.add(p);</span>
                }
            }

<span class="fc" id="L2139">            finder = new DFSConnectedGroupsFinder();</span>
<span class="fc" id="L2140">            finder.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L2141">            finder.findConnectedPointGroups(points, minMaxXY[1] + 1, minMaxXY[3] + 1);</span>

<span class="fc" id="L2143">            nGroups = finder.getNumberOfGroups();</span>

<span class="fc" id="L2145">            nIter++;</span>
<span class="fc" id="L2146">        }</span>
<span class="fc" id="L2147">    }</span>

    public void straightenLines(Set&lt;PairInt&gt; points,
        GreyscaleImage edgeGuideImage) {

<span class="pc bpc" id="L2152" title="1 of 2 branches missed.">        if (edgeGuideImage == null) {</span>
<span class="nc" id="L2153">            return;</span>
        }

        /*
        To move a pixel from one location to a better if possible
        means determining if the move does not break any line connections.
        Since the line widths have already been reduced to widths of '1',
        this should just be a matter of noting which points it is connected
        to and only choose points which are adjacent to the connected.

              V
              *                            V
           *     *  *  can be moved to  *  *  *  *

        The neighbors of p are p0 and p1 for example, so
        points which are within 1 pixel of p, p0, and p1 found as the centroid
        of them +- 1 pixel radius.

        Goal is to find if a point in points can be moved within a pixel's
        distance, to a position which is closer to the brightest pixel in the
        edgeGuideImage within range without breaking connections.

        For each point in points:
            -- find the adjacent points.
            -- determine a centroid for them and the point.
            -- iterate around the 8 neighboring pixels of point
               -- initialize maxIntensity w/ the current points's edgeGuideImage
                  intensity.
               -- if the pixel is further than 1 from the centroid, discard it,
                  else, compare the pixel's edgeGuideImage with maxIntensity and
                  keep if larger.
            -- if maxIntensityPoint is not null, move the current point to
               it (by adding point to the remove list and adding the new location
               to the add list).
        */

<span class="fc" id="L2189">        int imageWidth = edgeGuideImage.getWidth();</span>

<span class="fc" id="L2191">        int imageHeight = edgeGuideImage.getHeight();</span>

<span class="fc" id="L2193">        double onePixDist = Math.sqrt(2);</span>

<span class="fc" id="L2195">        Set&lt;PairInt&gt; tmpPointsAdded = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L2196">        Set&lt;PairInt&gt; tmpPointsRemoved = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L2198">        Set&lt;PairInt&gt; outputNeighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2200" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L2202">            int x = p.getX();</span>
<span class="fc" id="L2203">            int y = p.getY();</span>

<span class="fc" id="L2205">            findNeighbors(x, y, outputNeighbors, points,</span>
                tmpPointsAdded, tmpPointsRemoved, imageWidth, imageHeight);

<span class="fc" id="L2208">            int nBrs = outputNeighbors.size();</span>

<span class="fc bfc" id="L2210" title="All 2 branches covered.">            if (nBrs == 0) {</span>
<span class="fc" id="L2211">                continue;</span>
            }

            // determine centroid
<span class="fc" id="L2215">            double xc = p.getX();</span>
<span class="fc" id="L2216">            double yc = p.getY();</span>
<span class="fc bfc" id="L2217" title="All 2 branches covered.">            for (PairInt p2 : outputNeighbors) {</span>
<span class="fc" id="L2218">                xc += p2.getX();</span>
<span class="fc" id="L2219">                yc += p2.getY();</span>
<span class="fc" id="L2220">            }</span>
<span class="fc" id="L2221">            xc /= (double)(nBrs + 1);</span>
<span class="fc" id="L2222">            yc /= (double)(nBrs + 1);</span>

            // find highest intensity neighbor within 1 pix of centroid
<span class="fc" id="L2225">            int maxIntensity = edgeGuideImage.getValue(x, y);</span>
<span class="fc" id="L2226">            PairInt maxIntensityPoint = null;</span>

<span class="fc bfc" id="L2228" title="All 2 branches covered.">            for (int i = 0; i &lt; eightNeighborsX.length; ++i) {</span>
<span class="fc" id="L2229">                int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L2230">                int y2 = y + eightNeighborsY[i];</span>
<span class="pc bpc" id="L2231" title="4 of 8 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                    (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2233">                    continue;</span>
                }
<span class="fc" id="L2235">                PairInt p2 = new PairInt(x2, y2);</span>
                // discard if it's already a point
<span class="pc bpc" id="L2237" title="1 of 4 branches missed.">                if (outputNeighbors.contains(p2) || tmpPointsAdded.contains(p2)</span>
<span class="fc bfc" id="L2238" title="All 2 branches covered.">                    || points.contains(p2)) {</span>
<span class="fc" id="L2239">                    continue;</span>
                }

                // this is a vacant pixel.

                // check that it is within 1 pixel of (xc, yc)
<span class="fc" id="L2245">                double diffX = x2 - xc;</span>
<span class="fc" id="L2246">                double diffY = y2 - yc;</span>
<span class="fc" id="L2247">                double dist = Math.sqrt((diffX * diffX) + (diffY * diffY));</span>

<span class="fc bfc" id="L2249" title="All 2 branches covered.">                if (dist &lt;= (onePixDist/2.)) {</span>
<span class="fc" id="L2250">                    int v = edgeGuideImage.getValue(x2, y2);</span>
<span class="fc bfc" id="L2251" title="All 2 branches covered.">                    if (v &gt; maxIntensity) {</span>
<span class="fc" id="L2252">                        maxIntensity = v;</span>
<span class="fc" id="L2253">                        maxIntensityPoint = p2;</span>
                    }
                }
            }
<span class="fc bfc" id="L2257" title="All 2 branches covered.">            if (maxIntensityPoint != null) {</span>
                // &quot;change location&quot; of the point.
<span class="fc" id="L2259">                tmpPointsRemoved.add(p);</span>
<span class="fc" id="L2260">                tmpPointsRemoved.remove(maxIntensityPoint);</span>
<span class="fc" id="L2261">                tmpPointsAdded.add(maxIntensityPoint);</span>
            }
<span class="fc" id="L2263">        }</span>

<span class="fc" id="L2265">        int nCorrections = tmpPointsRemoved.size() + tmpPointsAdded.size();</span>

<span class="fc bfc" id="L2267" title="All 2 branches covered.">        for (PairInt p2 : tmpPointsRemoved) {</span>
<span class="fc" id="L2268">            points.remove(p2);</span>
<span class="fc" id="L2269">        }</span>
<span class="fc bfc" id="L2270" title="All 2 branches covered.">        for (PairInt p2 : tmpPointsAdded) {</span>
<span class="fc" id="L2271">            points.add(p2);</span>
<span class="fc" id="L2272">        }</span>

<span class="fc" id="L2274">        log.fine(&quot;method &quot; + MiscDebug.getInvokingMethodName() + &quot; nc=&quot; +</span>
<span class="fc" id="L2275">            Integer.toString(nCorrections));</span>
<span class="fc" id="L2276">    }</span>

    protected void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; tmpAddedPoints,
        Set&lt;PairInt&gt; tmpRemovedPoints, int imageWidth, int imageHeight) {

<span class="fc" id="L2282">        outputNeighbors.clear();</span>

<span class="fc bfc" id="L2284" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L2286">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L2287">            int y2 = y + eightNeighborsY[i];</span>

<span class="pc bpc" id="L2289" title="4 of 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2291">                continue;</span>
            }

<span class="fc" id="L2294">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L2296" title="All 2 branches covered.">            if (tmpRemovedPoints.contains(p2)) {</span>
<span class="fc" id="L2297">                continue;</span>
            }
<span class="fc bfc" id="L2299" title="All 4 branches covered.">            if (tmpAddedPoints.contains(p2) || points.contains(p2)) {</span>
<span class="fc" id="L2300">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L2303">    }</span>

    public Set&lt;PairInt&gt; findNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L2307">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L2309" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L2311">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L2312">            int y2 = y + eightNeighborsY[i];</span>

<span class="fc" id="L2314">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L2316" title="All 2 branches covered.">            if (points.contains(p2)) {</span>
<span class="fc" id="L2317">                neighbors.add(p2);</span>
            }
        }

<span class="fc" id="L2321">        return neighbors;</span>
    }
        
    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; points, 
        Set&lt;PairInt&gt; excludePoints, int[] dxs, int[] dys, 
        Set&lt;PairInt&gt; outputNeighbors) {
        
<span class="fc" id="L2328">        outputNeighbors.clear();</span>
        
<span class="fc bfc" id="L2330" title="All 2 branches covered.">        for (int i = 0; i &lt; dxs.length; i++) {</span>
            
<span class="fc" id="L2332">            int x2 = x + dxs[i];</span>
<span class="fc" id="L2333">            int y2 = y + dys[i];</span>
            
<span class="fc" id="L2335">            PairInt p2 = new PairInt(x2, y2);</span>
            
<span class="fc bfc" id="L2337" title="All 2 branches covered.">            if (excludePoints.contains(p2)) {</span>
<span class="fc" id="L2338">                continue;</span>
            }
<span class="fc bfc" id="L2340" title="All 2 branches covered.">            if (points.contains(p2)) {</span>
<span class="fc" id="L2341">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L2344">    }</span>

    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L2349">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L2351" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L2353">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L2354">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L2356" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2358">                continue;</span>
            }

<span class="nc" id="L2361">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L2363" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L2364">                continue;</span>
            }
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L2367">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L2370">    }</span>

    /**
     * iterate through points, counting the number of pixels on the image
     * boundaries, and return true if the number reaches numberOfPixels.
     * @param numberOfPixels the number of pixels for which to return true
     * if they are on the image boundaries.
     * @param points
     * @param imageWidth
     * @param imageHeight
     * @return
     */
    public boolean hasNumberOfPixelsOnImageBoundaries(int numberOfPixels,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="fc" id="L2385">        int n = 0;</span>

<span class="fc bfc" id="L2387" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L2389">            int x = p.getX();</span>
<span class="fc" id="L2390">            int y = p.getY();</span>

<span class="fc bfc" id="L2392" title="All 8 branches covered.">            if ((x == 0) || (y == 0) || (x == (imageWidth - 1)) ||</span>
                (y == (imageHeight - 1))) {

<span class="fc" id="L2395">                n++;</span>

<span class="fc bfc" id="L2397" title="All 2 branches covered.">                if (n == numberOfPixels) {</span>
<span class="fc" id="L2398">                    return true;</span>
                }
            }
<span class="fc" id="L2401">        }</span>

<span class="pc bpc" id="L2403" title="1 of 2 branches missed.">        return (n &gt;= numberOfPixels);</span>
    }

    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points, int imageWidth,
        int imageHeight) {

<span class="fc" id="L2409">        int nn = 0;</span>

<span class="fc bfc" id="L2411" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L2413">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L2414">            int y2 = y + eightNeighborsY[i];</span>

<span class="fc bfc" id="L2416" title="All 8 branches covered.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="fc" id="L2418">                continue;</span>
            }

<span class="fc" id="L2421">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L2423" title="All 2 branches covered.">            if (points.contains(p2)) {</span>
<span class="fc" id="L2424">                nn++;</span>
            }
        }

<span class="fc" id="L2428">        return nn;</span>
    }
    
    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L2433">        int nn = 0;</span>

<span class="fc bfc" id="L2435" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L2437">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L2438">            int y2 = y + eightNeighborsY[i];</span>

<span class="fc" id="L2440">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L2442" title="All 2 branches covered.">            if (points.contains(p2)) {</span>
<span class="fc" id="L2443">                nn++;</span>
            }
        }

<span class="fc" id="L2447">        return nn;</span>
    }

    public List&lt;PairIntArray&gt; smoothAndReExtractEdges(List&lt;PairIntArray&gt; edges,
        GreyscaleImage gradientXY, int smoothingFactor) {

<span class="nc" id="L2453">        AverageUtil avgUtil = new AverageUtil();</span>

<span class="nc" id="L2455">        GreyscaleImage output = gradientXY.createWithDimensions();</span>

<span class="nc bnc" id="L2457" title="All 2 branches missed.">        for (int i = 0; i &lt; edges.size(); ++i) {</span>
<span class="nc" id="L2458">            PairIntArray edge = edges.get(i);</span>
<span class="nc bnc" id="L2459" title="All 2 branches missed.">            if (edge.getN() &gt;= smoothingFactor) {</span>
<span class="nc" id="L2460">                edge = avgUtil.calculateBoxCarAverage(edges.get(i), smoothingFactor);</span>
<span class="nc bnc" id="L2461" title="All 2 branches missed.">                for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="nc" id="L2462">                    output.setValue(edge.getX(j), edge.getY(j), 1);</span>
                }
            }
        }

<span class="nc" id="L2467">        PostLineThinnerCorrections pslt = new PostLineThinnerCorrections();</span>
<span class="nc" id="L2468">        pslt.correctForArtifacts(output);</span>
<span class="nc" id="L2469">        IEdgeExtractor edgeExtractor = new EdgeExtractorWithJunctions(output);</span>
<span class="nc" id="L2470">        edgeExtractor.removeShorterEdges(true);</span>
<span class="nc" id="L2471">        edges = edgeExtractor.findEdges();</span>

<span class="nc" id="L2473">        return edges;</span>
    }

    public boolean hasAtLeastOneNonPointNeighbor(int x, int y,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="nc bnc" id="L2479" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L2481">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L2482">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L2484" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2486">                continue;</span>
            }

<span class="nc bnc" id="L2489" title="All 2 branches missed.">            if (!points.contains(new PairInt(x2, y2))) {</span>
<span class="nc" id="L2490">                return true;</span>
            }
        }

<span class="nc" id="L2494">        return false;</span>
    }

    public void findNeighborsWithAtLeastOneNonPoint(int x, int y,
        Set&lt;PairInt&gt; outputNeighbors, Set&lt;PairInt&gt; points,
        Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L2501">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L2503" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L2505">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L2506">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L2508" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2510">                continue;</span>
            }

<span class="nc" id="L2513">            boolean isPossiblyABorderPoint = hasAtLeastOneNonPointNeighbor(</span>
                x2, y2, points, imageWidth, imageHeight);

<span class="nc bnc" id="L2516" title="All 2 branches missed.">            if (!isPossiblyABorderPoint) {</span>
<span class="nc" id="L2517">                continue;</span>
            }

<span class="nc" id="L2520">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L2522" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L2523">                continue;</span>
            }
<span class="nc bnc" id="L2525" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L2526">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L2529">    }</span>

    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2) {

<span class="fc" id="L2533">        int x1 = edge.getX(idx1);</span>
<span class="fc" id="L2534">        int y1 = edge.getY(idx1);</span>

<span class="fc" id="L2536">        int x2 = edge.getX(idx2);</span>
<span class="fc" id="L2537">        int y2 = edge.getY(idx2);</span>

<span class="fc" id="L2539">        int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L2540">        int diffY = Math.abs(y1 - y2);</span>

<span class="fc bfc" id="L2542" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L2543">            return true;</span>
        }

<span class="fc" id="L2546">        return false;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which direction and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        direction of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="fc" id="L2580">        int xmRot90 = xp + (ym - yp);</span>
<span class="fc" id="L2581">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="fc" id="L2583">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="fc" id="L2584">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="fc" id="L2586">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="fc" id="L2589">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="fc" id="L2593">        double perp = theta;</span>

<span class="pc bpc" id="L2595" title="1 of 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L2596">            perp += Math.PI/2.;</span>
        } else {
<span class="fc" id="L2598">            perp -= Math.PI/2.;</span>
        }

<span class="pc bpc" id="L2601" title="1 of 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L2602">            perp = perp - 2*Math.PI;</span>
<span class="pc bpc" id="L2603" title="1 of 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L2604">            perp += 2*Math.PI;</span>
        }

<span class="fc" id="L2607">        return perp;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * along the curve at the middle point, its direction is from p0 to p1.
     * &lt;pre&gt;
     * For example:
     * 
     * 135 degrees
     *       .---
     *       | .
     *           p2   
     *             p1
     *                p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleAtMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

        /*
        given the points (x1, y1) (x2, y2) and (x3, y3), 
        calculates the angle at the midpoint (x2, y2) for the path along
        the points.
        */
        
<span class="fc" id="L2640">        double theta1 = AngleUtil.polarAngleCCW(x2 - x1, y2 - y1);</span>
        
<span class="fc" id="L2642">        double theta2 = AngleUtil.polarAngleCCW(x3 - x2, y3 - y2);</span>
        
<span class="fc" id="L2644">        double theta = AngleUtil.getAngleAverageInRadians(theta1, theta2);</span>
                
<span class="fc" id="L2646">        return theta;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * tangent to the curve at the middle point - its direction follows
     * the right hand rule.
     * &lt;pre&gt;
     * For example:
     *                  45 degrees
     *               __
     *               . |
     *       p2    .
     *          p1
     *             p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleTangentToMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

<span class="fc" id="L2673">        double theta = calculateAngleAtMidpoint(x1, y1, x2, y2, x3, y3);</span>
               
<span class="fc" id="L2675">        double thetaMinus90 = theta - Math.PI/2.;</span>
<span class="fc bfc" id="L2676" title="All 2 branches covered.">        if (thetaMinus90 &lt; 0) {</span>
<span class="fc" id="L2677">            thetaMinus90 += (2.*Math.PI);</span>
        }
        
<span class="fc" id="L2680">        return thetaMinus90;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which direction and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.  The points are also
     * checked to make sure they aren't in the points set.
     *
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @param points
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY,
        Set&lt;PairInt&gt; points) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        direction of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="nc" id="L2718">        int xmRot90 = xp + (ym - yp);</span>
<span class="nc" id="L2719">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="nc" id="L2721">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="nc" id="L2722">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="nc" id="L2724">        boolean rot90IsInPoints = points.contains(</span>
<span class="nc" id="L2725">            new PairInt(Math.round(xmRot90), Math.round(ymRot90)));</span>

<span class="nc" id="L2727">        boolean rotNegative90IsInPoints = points.contains(</span>
<span class="nc" id="L2728">            new PairInt(Math.round(xmRotNegative90),</span>
<span class="nc" id="L2729">            Math.round(ymRotNegative90)));</span>

<span class="nc" id="L2731">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="nc" id="L2734">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="nc" id="L2738">        double perp = theta;</span>

<span class="nc bnc" id="L2740" title="All 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L2741">            perp += Math.PI/2.;</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">        } else if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc bnc" id="L2743" title="All 4 branches missed.">            if (rot90IsInPoints &amp;&amp; !rotNegative90IsInPoints) {</span>
<span class="nc" id="L2744">                perp -= Math.PI/2.;</span>
<span class="nc bnc" id="L2745" title="All 4 branches missed.">            } else if (!rot90IsInPoints &amp;&amp; rotNegative90IsInPoints) {</span>
<span class="nc" id="L2746">                perp += Math.PI/2.;</span>
            } else {
<span class="nc" id="L2748">                throw new IllegalStateException(&quot;Error in algorithm:&quot; +</span>
                &quot; consider changing the test 90 and -90 points so that&quot; +
                &quot; one will always be in points set.&quot;);
            }
        } else {
<span class="nc" id="L2753">            perp -= Math.PI/2.;</span>
        }

<span class="nc bnc" id="L2756" title="All 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L2757">            perp = perp - 2*Math.PI;</span>
<span class="nc bnc" id="L2758" title="All 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L2759">            perp += 2*Math.PI;</span>
        }

<span class="nc" id="L2762">        return perp;</span>
    }

    /**
     * calculate theta in degrees as a value between -pi and pi for the given point
     * which should have a value greater than 0 at (x,y) and should be part
     * of a curve thinned to a width of 1.
     &lt;pre&gt;
                 90
           135    |    45
                  |
        180 ---------------  0
                  |
          -135    |   -45
                 -90
     &lt;/pre&gt;
     * @param x
     * @param y
     * @param img
     * @return 
     */
    public int calculateThetaForPointOnEdge(int x, int y, GreyscaleImage img) {
        
<span class="nc" id="L2785">        double[] gXY = calculateGradientsForPointOnEdge(x, y, img);</span>
        
        /*
        Math.atan arc tangent, angle is in the range -pi/2 through pi/2
        Math.atan2 conversion of rectangular coordinates (x, y) 
            to polar coordinates (r, theta). 
            This method computes the phase theta by computing an arc tangent 
            of y/x in the range of -pi to pi.
        */
<span class="nc" id="L2794">        double t = Math.atan2(gXY[1], gXY[0]);</span>
      
<span class="nc" id="L2796">        return (int)Math.round(t);</span>
    }

    /**
     * calculate gradient x and gradient y for the given point
     * which should have a value greater than 0 at (x,y) and should be part
     * of a curve thinned to a width of 1.
     
     * @param x
     * @param y
     * @param img
     * @return double{gradX, gradY}
     */
    public double[] calculateGradientsForPointOnEdge(int x, int y, GreyscaleImage img) {
        
<span class="fc" id="L2811">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>
        
<span class="fc" id="L2813">        float sigma = 0.42466090014400953f;</span>
        
<span class="fc" id="L2815">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L2817">        float[] kernel2 = Gaussian1D.getKernel(sigma * 1.6f);</span>
        
<span class="fc" id="L2819">        boolean calcForX = true;</span>
               
<span class="fc" id="L2821">        double convX1 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel, calcForX);
        
<span class="fc" id="L2824">        double convX2 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel2, calcForX);
             
<span class="fc" id="L2827">        calcForX = false;</span>
        
<span class="fc" id="L2829">        double convY1 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel, calcForX);
        
<span class="fc" id="L2832">        double convY2 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel2, calcForX);
        
<span class="fc" id="L2835">        double gX = convX2 - convX1;</span>
<span class="fc" id="L2836">        double gY = convY2 - convY1;</span>
        
<span class="fc" id="L2838">        return new double[]{gX, gY};</span>
    }
    
    /**
     * calculate gradient x and gradient y for the given point
     * which should have a value greater than 0 at (x,y) and should be part
     * of a curve thinned to a width of 1.
     * Note that the magnitudes have not been calibrated because the main
     * using method uses the results to calculate the polar angle, so 
     * factor applied to both not necessary.
       Note that the magnitudes have not been calibrated because the main
     * using method uses the results to calculate the polar angle, so 
     * factor applied to both not necessary.
     * @param x
     * @param y
     * @param points
     * @return double{gradX, gradY}
     */
    public double[] calculateGradientsForPointOnEdge(int x, int y, 
        Set&lt;PairInt&gt; points) {
        
<span class="fc" id="L2859">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>
        
<span class="fc" id="L2861">        float sigma = 0.42466090014400953f;</span>
        
<span class="fc" id="L2863">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L2865">        float[] kernel2 = Gaussian1D.getKernel(sigma * 1.6f);</span>
        
<span class="fc" id="L2867">        boolean calcForX = true;</span>
        
<span class="fc" id="L2869">        double convX1 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel, calcForX);
        
<span class="fc" id="L2872">        double convX2 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel2, calcForX);
             
<span class="fc" id="L2875">        calcForX = false;</span>
        
<span class="fc" id="L2877">        double convY1 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel, calcForX);
        
<span class="fc" id="L2880">        double convY2 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel2, calcForX);
             
<span class="fc" id="L2883">        double gX = convX2 - convX1;</span>
<span class="fc" id="L2884">        double gY = convY2 - convY1;</span>
        
<span class="fc" id="L2886">        return new double[]{gX, gY};</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
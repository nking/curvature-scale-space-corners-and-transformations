<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscellaneousCurveHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">MiscellaneousCurveHelper.java</span></div><h1>MiscellaneousCurveHelper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.MultiArrayMergeSort;
import algorithms.misc.AverageUtil;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PairIntArrayComparator;
import algorithms.util.PairFloatArray;
import algorithms.util.PairInt;
import algorithms.util.PairIntArrayWithColor;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;
import org.ejml.simple.*;

/**
 * 
 * @author nichole
 */
<span class="fc" id="L25">public class MiscellaneousCurveHelper {</span>
    
<span class="fc" id="L27">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    // choosing a minimum size empirically from looking at edges in tests
<span class="fc" id="L30">    private static int minLedgeWidth = 4;</span>
    
<span class="fc" id="L32">    protected static final int[] eightNeighborsX = </span>
        new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
<span class="fc" id="L34">    protected static final int[] eightNeighborsY = </span>
        new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};
    
    /**
     * determine whether the closed curve points are ordered in a clockwise
     * manner.
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     * 
     * @param closedCurve
     * @return 
     */
    public boolean curveIsOrderedClockwise(PairIntArray closedCurve) {
      
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L54">            return false;</span>
        }
        
<span class="fc" id="L57">        int nNeg = 0;</span>
<span class="fc" id="L58">        int n = closedCurve.getN();</span>
        
<span class="fc bfc" id="L60" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
            
            long xm1, ym1, x, y, xp1, yp1;
            
<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L65">                xm1 = closedCurve.getX(closedCurve.getN() - 1);</span>
<span class="fc" id="L66">                ym1 = closedCurve.getY(closedCurve.getN() - 1);</span>
<span class="fc" id="L67">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L68">                yp1 = closedCurve.getY(i + 1);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            } else if (i == (closedCurve.getN() - 1)) {</span>
<span class="fc" id="L70">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L71">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L72">                xp1 = closedCurve.getX(0);</span>
<span class="fc" id="L73">                yp1 = closedCurve.getY(0);</span>
            } else {
<span class="fc" id="L75">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L76">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L77">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L78">                yp1 = closedCurve.getY(i + 1);</span>
            }
<span class="fc" id="L80">            x = closedCurve.getX(i);</span>
<span class="fc" id="L81">            y = closedCurve.getY(i);</span>
            
<span class="fc" id="L83">            long dxmxm1 = (x - xm1);</span>
<span class="fc" id="L84">            long dymym1 = (y - ym1);</span>
<span class="fc" id="L85">            long dxp1mx = (xp1 - x);</span>
<span class="fc" id="L86">            long dyp1my = (yp1 - y);</span>
                
            //(xi - xi-1) * (yi+1 - yi) - (yi - yi-1) * (xi+1 - xi)
<span class="fc" id="L89">            long crossProduct = (dxmxm1 * dyp1my) - (dymym1 * dxp1mx);</span>
            
<span class="fc bfc" id="L91" title="All 2 branches covered.">            if (crossProduct &lt; 0) {</span>
<span class="fc" id="L92">                nNeg++;</span>
            }
        }
        
<span class="fc" id="L96">        Logger.getLogger(this.getClass().getName()).fine(</span>
            &quot;nNegative=&quot; + nNeg + &quot; nTotal=&quot; + n);
        
<span class="fc" id="L99">        int nPos = n - 2 - nNeg;</span>
        
        // note, may want to adjust this for image perspective where
        // positive y is in downward direction.
<span class="pc bpc" id="L103" title="2 of 6 branches missed.">        return ((n &gt; 2) &amp;&amp; (nNeg &gt;= nPos)) || (nNeg &gt; nPos);</span>
     }
     
    public void additionalThinning45DegreeEdges(
        GreyscaleImage theta, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by 
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, 
        //     VOL. 20, NO. 12
        // 
        //compare each edge pixel which has an edge orientation of 
        // 45o or -45o to one of its horizontal or vertical neighbors. 
        // If the neighbor has the same orientation, the other point can be 
        // removed.
<span class="nc bnc" id="L118" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>

<span class="nc" id="L121">                int tG = theta.getValue(i, j);</span>

<span class="nc bnc" id="L123" title="All 6 branches missed.">                if (((tG == 45) || (tG == -45)) &amp;&amp; (input.getValue(i, j) &gt; 0)) {</span>

<span class="nc" id="L125">                    int tH0 = theta.getValue(i - 1, j);</span>
<span class="nc" id="L126">                    int tH1 = theta.getValue(i + 1, j);</span>
<span class="nc" id="L127">                    int tV0 = theta.getValue(i, j - 1);</span>
<span class="nc" id="L128">                    int tV1 = theta.getValue(i, j + 1);</span>

<span class="nc" id="L130">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L131">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L132">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L133">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L135" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L137">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L139">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L141" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L142" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L143">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L145">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L151">    }</span>

     /**
     * this is a method to combine and prune adjacent lines, but
     * it knows nothing about the overall shape. it chooses to keep the longer
     * line and append any dangling members of the adjacent line to the longest.
     * It's a time consuming method (add runtime complexity here).  It isn't
     * used anymore because the results from the CannyEdgeFilter are now 
     * 1 pixel thick edges already.
     * @param edges
     * @param imageWidth the image width in pixels
     * @return 
     */
    public List&lt;PairIntArray&gt; pruneAndIncludeAdjacentCurves(
        List&lt;PairIntArray&gt; edges, int imageWidth) {
        
        //sort to place edges with fewest points at top
<span class="fc" id="L168">        Collections.sort(edges, new PairIntArrayComparator());</span>

<span class="fc" id="L170">        Stack&lt;PairIntArrayWithColor&gt; stack = new Stack&lt;PairIntArrayWithColor&gt;();</span>
<span class="fc" id="L171">        List&lt;PairIntArrayWithColor&gt; pruneThese = new ArrayList&lt;PairIntArrayWithColor&gt;();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
            // color: 0 = unvisited, 1 = processing, 2 = visited, 
            //        3 = in an output edge, 4=pruned
<span class="fc" id="L175">            PairIntArrayWithColor node = new PairIntArrayWithColor(edges.get(i));</span>
<span class="fc" id="L176">            stack.add(node);</span>
<span class="fc" id="L177">            pruneThese.add(node);</span>
        }

<span class="fc" id="L180">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>
               
<span class="fc" id="L182">        PairIntArrayWithColor tmp = stack.peek();</span>
<span class="fc" id="L183">        tmp.setColor(2);</span>
        
<span class="fc" id="L185">        boolean foundOverlappingCurves = false;</span>
<span class="fc" id="L186">        boolean reversedPoints = false;</span>
            
<span class="fc bfc" id="L188" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
            
<span class="fc" id="L190">            PairIntArrayWithColor uNode = stack.pop();</span>
            
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (uNode.getColor() == 4) {</span>
<span class="fc" id="L193">                continue;</span>
            }
                        
            // for each neighbor v of u
<span class="fc bfc" id="L197" title="All 2 branches covered.">            for (int i = (pruneThese.size() - 1); i &gt; -1; i--) {</span>
                
<span class="fc" id="L199">                PairIntArrayWithColor vNode = pruneThese.get(i);</span>
                
<span class="fc bfc" id="L201" title="All 2 branches covered.">                if (vNode.getColor() != 0) {</span>
<span class="fc" id="L202">                    continue;</span>
                }
                
                // because top item might be updated in processPair, 
                //     place in v iter
<span class="fc" id="L207">                int uX = uNode.getX(0);</span>
<span class="fc" id="L208">                int uY = uNode.getY(0);</span>
<span class="fc" id="L209">                int uIdx = (uY * imageWidth) + uX;</span>
                                
<span class="fc" id="L211">                int vX = vNode.getX(0);</span>
<span class="fc" id="L212">                int vY = vNode.getY(0);</span>
<span class="fc" id="L213">                int vIdx = (vY * imageWidth) + vX;</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                if (uIdx == vIdx) {</span>
<span class="fc" id="L215">                    continue;</span>
                }
                           
<span class="fc" id="L218">                boolean areOverlapping = processOverlappingPair(uNode, vNode);</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (areOverlapping) {</span>
                    
<span class="fc" id="L222">                    foundOverlappingCurves = true;</span>
                    
                    // color: 0 = unvisited, 1 = processing, 2 = visited, 
                    //        3 = in an output edge, 4=pruned
<span class="fc" id="L226">                    vNode.setColor(4);</span>
                                     
<span class="fc" id="L228">                    pruneThese.remove(vNode);</span>
                    
                } // else insert into stack?                                                 
            }
            
<span class="fc bfc" id="L233" title="All 4 branches covered.">            if (!foundOverlappingCurves &amp;&amp; !reversedPoints) {</span>
<span class="fc" id="L234">                uNode.reverse();</span>
<span class="fc" id="L235">                reversedPoints = true;</span>
<span class="fc" id="L236">                log.fine(&quot;reversed edge to try again&quot;);</span>
<span class="fc" id="L237">                stack.add(uNode);</span>
<span class="fc" id="L238">                continue;</span>
            }
            
            // color: 0 = unvisited, 1 = processing, 2 = visited, 
            //        3 = in an output edge, 4=pruned
<span class="fc" id="L243">            uNode.setColor(3);</span>
            
<span class="fc" id="L245">            output.add(uNode);</span>
                        
<span class="fc" id="L247">            foundOverlappingCurves = false;</span>
<span class="fc" id="L248">            reversedPoints = false;</span>
<span class="fc" id="L249">        }</span>
        
<span class="fc" id="L251">        return output;</span>
    }
    
    /**
     * given 2 edges, return true if they overlap. If they overlap
     * curve0 is given the larger curve and any outlying points.
     * @param curve0
     * @param curve1
     * @return 
     */
    protected boolean processOverlappingPair(PairIntArrayWithColor curve0, 
        PairIntArrayWithColor curve1) {
        
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        boolean longerIsNode0 = (curve0.getN() &gt;= curve1.getN());</span>
        
        PairIntArray longer, shorter;
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (longerIsNode0) {</span>
<span class="fc" id="L268">            longer = curve0;</span>
<span class="fc" id="L269">            shorter = curve1;</span>
        } else {
<span class="nc" id="L271">            longer = curve1;</span>
<span class="nc" id="L272">            shorter = curve0;</span>
        }
        
        // used to return the offset w.r.t. the longest edge.
<span class="fc" id="L276">        int[] correlationOffset = new int[1];</span>
          
        /*
         returns whether the curve 'check' is adjacent to the curve 'node0',
         and if so, returns the offset in the frame of the larger curve.
         the offset represents where the first point in the shorter curve
         matches in the larger curve.                
         */
<span class="fc" id="L284">        boolean isAdjacent = correlation(longer, shorter,</span>
            correlationOffset);

<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (isAdjacent) {</span>

            /*
                -- find any points in check outside of the overlap
                   and add those to the larger node.
            */
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            if (correlationOffset[0] &lt; 0) {</span>
                // add from the beginning of shorter if any are unmatched
<span class="nc" id="L295">                int nInsert = -1*correlationOffset[0];</span>
<span class="nc" id="L296">                longer.insertSpaceAtTopOfArrays(nInsert);</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">                for (int ii = 0; ii &lt; nInsert; ii++) {</span>
<span class="nc" id="L299">                    longer.set(ii, shorter.getX(ii), shorter.getY(ii));</span>
                }
<span class="nc" id="L301">            } else {</span>
                //add from end of shorter if any are unmatched
<span class="fc" id="L303">                int n0 = longer.getN() - correlationOffset[0];</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                if (n0 &lt; shorter.getN()) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">                    for (int ii = n0; ii &lt; shorter.getN(); ii++) {</span>
<span class="fc" id="L306">                        longer.add(shorter.getX(ii), shorter.getY(ii));</span>
                    }
                }
            }
                        
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            if (!longerIsNode0) {</span>
<span class="nc" id="L312">                curve0.swapContents(curve1);</span>
            }
            
<span class="fc" id="L315">            return true;</span>
        }
        
<span class="fc" id="L318">        return false;                   </span>
    }

    /**
     * return true if correlation shows that the 2 curves are adjacent
     * to one another.  Note that the method needs the points within the
     * curves to be ordered in a similar manner and for the endpoints of the
     * curves to be accurate.  If a point in the middle of the curve is 
     * the first or last point, it may prevent comparison of it with another
     * edge's endpoints.
     * 
     * @param curve0
     * @param curve1
     * @param correlationOffset offset of where the shorter curve starts
     *  with respect to the longer.  For example, an offset of -2 means that
     * the first 2 points in the shorter curve are outside of the longer curve,
     * but the next point in the longer curve is adjacent to the shorter.
     * Another example: if offset is +2, the first pixel in the shorter curve
     * is adjacent to the third pixel in the longer curve.  NOTE: the offset
     * is only useful if this method returns true;
     * @return 
     */
    protected boolean correlation(PairIntArray curve0, PairIntArray curve1, 
        int[] correlationOffset) {
        
<span class="fc" id="L343">        correlationOffset[0] = Integer.MAX_VALUE;</span>
        
        //TODO: look at string matching algorithms to explore improvements here
        
        PairIntArray shorter, longer;
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (curve0.getN() &lt;= curve1.getN()) {</span>
<span class="fc" id="L349">            shorter = curve0;</span>
<span class="fc" id="L350">            longer = curve1;</span>
        } else {
<span class="fc" id="L352">            shorter = curve1;</span>
<span class="fc" id="L353">            longer = curve0;</span>
        }

        /*
        len0 = 5; len1 = 11;
         #####
             +++++++++++
          #####
             +++++++++++
           #####
             +++++++++++
            #####
             +++++++++++
             #####
             +++++++++++
        
             #####
             +++++++++++  
                
                       #####
             +++++++++++
        
        ccs = sqrt(sumsqdiff)/nOverlapping if nOverlapping &gt; 0.
        
        if (css &lt;= 1 pix * nOverlapping) {
            store as a possible adjacent curve
        }
        compare possible adjacent curves for the smallest css, and store that 
        offset in correlationOffset and return true, else false        
        */

<span class="fc" id="L384">        double cSSMin = Double.MAX_VALUE;</span>
<span class="fc" id="L385">        int cSSMinOffset = Integer.MAX_VALUE;</span>
<span class="fc" id="L386">        int cSSMinNOverlapping = 0;</span>
        
<span class="fc" id="L388">        double sqrtTwo = Math.sqrt(2);</span>
        
<span class="fc bfc" id="L390" title="All 2 branches covered.">        for (int i = 0; i &lt; (longer.getN() + shorter.getN() - 1); i++) {</span>
            //siIdx is first index in shorter for comparison
            //sfIdx is last index in shorter for comparison
            //liIdx is first index of longer for comparison
            //lfIdx is last index of longer for comparison
            int siIdx, sfIdx, liIdx, lfIdx, offset;
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (i &lt; shorter.getN()) {</span>
                /*
                 #####
                     +++++++++++ i=0
                  #####
                     +++++++++++
                   #####
                     +++++++++++
                    #####
                     +++++++++++
                     #####
                     +++++++++++ i=4
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L410">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L411">                siIdx = sfIdx - i;</span>
<span class="fc" id="L412">                liIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L414">                lfIdx = sfIdx - siIdx;</span>
<span class="fc" id="L415">                offset = i - sfIdx;</span>
                
<span class="fc bfc" id="L417" title="All 2 branches covered.">            } else if (i &lt; longer.getN() ) {</span>
                
                /*
                      #####
                     +++++++++++  i=5
                
                       #####
                     +++++++++++
                
                        #####
                     +++++++++++
                    
                         #####   
                     +++++++++++
                
                          #####
                     +++++++++++
                
                           #####
                     +++++++++++ i = 10
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L439">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L440">                siIdx = 0;</span>
<span class="fc" id="L441">                liIdx = i - shorter.getN() + 1;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L443">                lfIdx = liIdx + shorter.getN() - 1;</span>
<span class="fc" id="L444">                offset = i - sfIdx;</span>
                
            } else {
                /*
                            #####
                     +++++++++++ i = 12
                     01234567890
                             #####
                     +++++++++++ 
                     
                              #####
                     +++++++++++
                
                               #####
                     +++++++++++ i=15
                     01234567890
                */
<span class="fc" id="L461">                liIdx = i - shorter.getN() + 1;</span>
                //sfIdx is inclusive endpoint
<span class="fc" id="L463">                sfIdx = longer.getN() - liIdx - 1;</span>
<span class="fc" id="L464">                siIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L466">                lfIdx = liIdx + (sfIdx - siIdx);</span>
<span class="fc" id="L467">                offset = liIdx;</span>
                
            }
            
<span class="fc" id="L471">            int nOverLapping = (sfIdx - siIdx) + 1;</span>
            
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">            if ((sfIdx - siIdx) != (lfIdx - liIdx)) {</span>
<span class="nc" id="L474">                throw new IllegalStateException(</span>
                    &quot;sample ranges are not correct&quot;);
            }
            
<span class="fc" id="L478">            double sumSq = 0;</span>
           
<span class="fc" id="L480">            int s = siIdx;</span>
<span class="fc" id="L481">            int l = liIdx;</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">            while (s &lt;= sfIdx) {</span>
<span class="fc" id="L483">                int xs = shorter.getX(s);</span>
<span class="fc" id="L484">                int xl = longer.getX(l);</span>
<span class="fc" id="L485">                int dx = xs - xl;</span>
<span class="fc" id="L486">                int ys = shorter.getY(s);</span>
<span class="fc" id="L487">                int yl = longer.getY(l);</span>
<span class="fc" id="L488">                int dy = ys - yl;</span>
<span class="fc" id="L489">                sumSq += ((dx*dx) + (dy*dy));</span>
<span class="fc" id="L490">                s++;</span>
<span class="fc" id="L491">                l++;</span>
<span class="fc" id="L492">            }</span>
           
<span class="fc" id="L494">            double tmp = Math.sqrt(sumSq/nOverLapping);</span>
            
            // assuming adjacent pixel has distance of sqrt(2) at the most
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (tmp &lt;= sqrtTwo) {</span>
                                
<span class="pc bpc" id="L499" title="3 of 6 branches missed.">                if ((tmp &lt; cSSMin) ||</span>
                (tmp == cSSMin &amp;&amp; (nOverLapping &gt; cSSMinNOverlapping))
                ) {
                    
<span class="fc" id="L503">                    cSSMin = tmp;</span>
                                        
<span class="fc" id="L505">                    cSSMinOffset = offset;</span>
                    
<span class="fc" id="L507">                    cSSMinNOverlapping = nOverLapping;</span>
                }
            }          
        }
             
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (cSSMin &lt; Double.MAX_VALUE) {</span>

<span class="fc" id="L514">            correlationOffset[0] = cSSMinOffset;</span>

<span class="fc" id="L516">            return true;</span>
        }
        
<span class="fc" id="L519">        return false;</span>
    }

    /**
     * find the index where x is minimum value of closedCurve.  Note that when
     * there are more than one points with the same minimum x value, the point
     * with a smaller y is chosen.
     * 
     * @param closedCurve
     * @return 
     */
    public int findMinIdx(PairIntArray closedCurve) {
        
<span class="fc" id="L532">        int xMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L533">        int xMax = Integer.MIN_VALUE;</span>
        
<span class="fc" id="L535">        int xMinIdx = -1;</span>
<span class="fc" id="L536">        int xMaxIdx = -1;</span>
        
        // find xMin.  when xMin==x, use yMin too.  similar pattern for maxes
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); i++) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (closedCurve.getX(i) &lt; xMin) {</span>
<span class="fc" id="L541">                xMin = closedCurve.getX(i);</span>
<span class="fc" id="L542">                xMinIdx = i;</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            } else if (closedCurve.getX(i) == xMin) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                if (closedCurve.getY(i) &lt; closedCurve.getY(xMinIdx)) {</span>
<span class="fc" id="L545">                    xMin = closedCurve.getX(i);</span>
<span class="fc" id="L546">                    xMinIdx = i;</span>
                }
            }
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (closedCurve.getX(i) &gt; xMax) {</span>
<span class="fc" id="L550">                xMax = closedCurve.getX(i);</span>
<span class="fc" id="L551">                xMaxIdx = i;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            } else if (closedCurve.getX(i) == xMax) {</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (closedCurve.getY(i) &gt; closedCurve.getY(xMaxIdx)) {</span>
<span class="nc" id="L554">                    xMax = closedCurve.getX(i);</span>
<span class="nc" id="L555">                    xMaxIdx = i;</span>
                }
            }
        }
        
<span class="fc" id="L560">        return xMinIdx;</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy, float[] weights) {
        
<span class="fc" id="L565">        double xc = 0;</span>
<span class="fc" id="L566">        double yc = 0;</span>
        
<span class="fc bfc" id="L568" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
<span class="fc" id="L569">            double x1 = xy.getX(i);</span>
<span class="fc" id="L570">            xc += (weights[i] * x1);</span>
            
<span class="fc" id="L572">            double y1 = xy.getY(i);</span>
<span class="fc" id="L573">            yc += (weights[i] * y1);</span>
        }
        
<span class="fc" id="L576">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids(PairIntArray xy) {
        
<span class="fc" id="L581">        double xc = 0;</span>
<span class="fc" id="L582">        double yc = 0;</span>
        
<span class="fc bfc" id="L584" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
            
<span class="fc" id="L586">            xc += xy.getX(i);</span>
            
<span class="fc" id="L588">            yc += xy.getY(i);</span>
        }
        
<span class="fc" id="L591">        xc /= (double)xy.getN();</span>
        
<span class="fc" id="L593">        yc /= (double)xy.getN();</span>
        
<span class="fc" id="L595">        return new double[]{xc, yc};</span>
    }
    
    /**
     * calculate the x and y centroids and return as 
     * double[]{xCentroid, yCentroid}
     * @param xy a 3 x N matrix with column 0 being x and column 1 being y.
     * @return 
     */
    public double[] calculateXYCentroids(SimpleMatrix xy) {
        
<span class="nc" id="L606">        double xc = 0;</span>
<span class="nc" id="L607">        double yc = 0;</span>
        
<span class="nc" id="L609">        int n = xy.numCols();</span>
        
<span class="nc bnc" id="L611" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
            
<span class="nc" id="L613">            xc += xy.get(0, i);</span>
            
<span class="nc" id="L615">            yc += xy.get(1, i);</span>
        }
        
<span class="nc" id="L618">        xc /= (double)n;</span>
        
<span class="nc" id="L620">        yc /= (double)n;</span>
        
<span class="nc" id="L622">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids(PairFloatArray xy) {
        
<span class="nc" id="L627">        double xc = 0;</span>
<span class="nc" id="L628">        double yc = 0;</span>
        
<span class="nc bnc" id="L630" title="All 2 branches missed.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
            
<span class="nc" id="L632">            xc += xy.getX(i);</span>
            
<span class="nc" id="L634">            yc += xy.getY(i);</span>
        }
        
<span class="nc" id="L637">        xc /= (double)xy.getN();</span>
        
<span class="nc" id="L639">        yc /= (double)xy.getN();</span>
        
<span class="nc" id="L641">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids(List&lt;PairIntArray&gt; xyList) {
        
<span class="nc" id="L646">        double xc = 0;</span>
<span class="nc" id="L647">        double yc = 0;</span>
        
<span class="nc bnc" id="L649" title="All 2 branches missed.">        for (PairIntArray points : xyList) {</span>
            
<span class="nc" id="L651">            double[] xycen = calculateXYCentroids(points);</span>
            
<span class="nc" id="L653">            xc += xycen[0];</span>
<span class="nc" id="L654">            yc += xycen[1];</span>
<span class="nc" id="L655">        }</span>
        
<span class="nc" id="L657">        xc /= (double)xyList.size();</span>
<span class="nc" id="L658">        yc /= (double)xyList.size();</span>
        
<span class="nc" id="L660">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids(Set&lt;PairInt&gt; points) {
        
<span class="nc" id="L665">        double xc = 0;</span>
<span class="nc" id="L666">        double yc = 0;</span>
        
<span class="nc bnc" id="L668" title="All 2 branches missed.">        for (PairInt p : points) {</span>
            
<span class="nc" id="L670">           int x = p.getX();</span>
<span class="nc" id="L671">           int y = p.getY();</span>
                    
<span class="nc" id="L673">            xc += x;</span>
<span class="nc" id="L674">            yc += y;</span>
<span class="nc" id="L675">        }</span>
        
<span class="nc" id="L677">        xc /= (double)(points.size());</span>
        
<span class="nc" id="L679">        yc /= (double)(points.size());</span>
            
<span class="nc" id="L681">        return new double[]{xc, yc};</span>
    }
        
    public double[] calculateXYCentroids(float[] x, float[] y) {
        
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L687">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L690">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L693">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }
        
<span class="nc" id="L696">        double xc = 0;</span>
<span class="nc" id="L697">        double yc = 0;</span>
        
<span class="nc bnc" id="L699" title="All 2 branches missed.">        for (int i = 0; i &lt; x.length; i++) {</span>
            
<span class="nc" id="L701">            xc += x[i];</span>
            
<span class="nc" id="L703">            yc += y[i];</span>
        }
        
<span class="nc" id="L706">        xc /= (double)(x.length);</span>
        
<span class="nc" id="L708">        yc /= (double)(x.length);</span>
        
<span class="nc" id="L710">        return new double[]{xc, yc};</span>
    }
    
    /**
     * search for point in edge with value (x, y) within indexes lowIdx to 
     * highIdx, inclusive and return true if found, else false.
     * Bounds checking is done internally, so it's safe to pass lowIdx
     * or highIdx out of range of edge.
     * @param x
     * @param i
     * @param edge
     * @param lowIdx
     * @param highIdx
     * @return 
     */
    private boolean pointExists(int x, int y, PairIntArray edge, int lowIdx, 
        int highIdx) {
        
<span class="nc bnc" id="L728" title="All 2 branches missed.">        for (int i = lowIdx; i &lt;= highIdx; i++) {</span>
<span class="nc bnc" id="L729" title="All 4 branches missed.">            if ((i &lt; 0) || (i &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L730">                continue;</span>
            }
<span class="nc bnc" id="L732" title="All 4 branches missed.">            if ((edge.getX(i) == x) &amp;&amp; (edge.getY(i) == y)) {</span>
<span class="nc" id="L733">                return true;</span>
            }
        }
        
<span class="nc" id="L737">        return false;</span>
    }

    public void removeRedundantPoints(List&lt;PairIntArray&gt; tmpEdges) {
        
<span class="nc" id="L742">        log.fine(&quot;removeRedundantPoints&quot;);</span>
        
        // if there are redundant points, remove the points in between
        
        //TODO: replace w/ faster algorithm...
        
<span class="nc bnc" id="L748" title="All 2 branches missed.">        for (int i = 0; i &lt; tmpEdges.size(); i++) {</span>
            
<span class="nc" id="L750">            List&lt;String&gt; points = new ArrayList&lt;String&gt;();</span>
            
<span class="nc" id="L752">            PairIntArray edge = tmpEdges.get(i);</span>
            
<span class="nc bnc" id="L754" title="All 2 branches missed.">            for (int j = (edge.getN() - 1); j &gt; -1; j--) {</span>
                
<span class="nc" id="L756">                String str = String.format(&quot;%d:%d&quot;, edge.getX(j), </span>
<span class="nc" id="L757">                    edge.getY(j));</span>
                
<span class="nc" id="L759">                int idx = points.indexOf(str);</span>
                
<span class="nc bnc" id="L761" title="All 2 branches missed.">                if (idx &gt; -1) {</span>
                    
                    //TODO: consider a limit for (pIdx - j)
                    
<span class="nc" id="L765">                    int pIdx = edge.getN() - idx - 1;</span>
                    
<span class="nc" id="L767">                    edge.removeRange(j, pIdx - 1);</span>
                    
                    // restart comparison? if we remove same region from points, we don't have to restart
<span class="nc" id="L770">                    points.clear();</span>
                    
<span class="nc" id="L772">                    j = edge.getN();</span>
                    
<span class="nc" id="L774">                } else {</span>
                    
<span class="nc" id="L776">                    points.add(str);</span>
                }
            }
        }      
<span class="nc" id="L780">    }</span>

    public void pruneAdjacentNeighborsTo2(List&lt;PairIntArray&gt; tmpEdges) {
       
<span class="nc" id="L784">        log.fine(&quot;pruneAdjacentNeighborsTo2&quot;);</span>
        
        // this will usually only have 2 in it, and most expected is 3
<span class="nc" id="L787">        int[] outputAdjacentNeighbors = new int[8];</span>
        
<span class="nc bnc" id="L789" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; tmpEdges.size(); lIdx++) {</span>
            
            // quick check for whether an edged has 3 neighbors, then
            // compare with patterns
            
<span class="nc" id="L794">            PairIntArray edge = tmpEdges.get(lIdx);</span>
            
<span class="nc bnc" id="L796" title="All 2 branches missed.">            for (int eIdx = 0; eIdx &lt; edge.getN(); eIdx++) {</span>
                
<span class="nc" id="L798">                int nNeighbors = getAdjacentNeighbors(edge, eIdx,</span>
                    outputAdjacentNeighbors);
                
<span class="nc bnc" id="L801" title="All 2 branches missed.">                if ((nNeighbors &gt; 2)) {</span>
                    
<span class="nc" id="L803">                    boolean pruned = pruneAdjacentNeighborsTo2(edge, eIdx, </span>
                        outputAdjacentNeighbors, nNeighbors);
   
<span class="nc bnc" id="L806" title="All 2 branches missed.">                    if (pruned) {</span>
                        // restart iteration for easier maintenance
<span class="nc" id="L808">                        eIdx = -1;</span>
                        //237,201  edge0
<span class="nc" id="L810">                        log.finest(&quot;removed a point from edge=&quot; + lIdx);</span>
                    }
                }
            }
        }
<span class="nc" id="L815">    }</span>
    
    /**
     * does removing the point at idx create a gap between it's neighboring
     * pixels?  this uses the simplest test of only the points at idx-1
     * and idx+1.
     * 
     * @param edge
     * @param idx
     * @return 
     */
    public boolean doesDisconnect(PairIntArray edge, int idx) {
                
        // test for endpoints first
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (idx == 0) {</span>
            
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L832">                return true;</span>
            }
            
            // does this point currently connect to the last point?
<span class="nc" id="L836">            float diffX = edge.getX(idx) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L838">                diffX *= -1;</span>
            }
<span class="nc" id="L840">            float diffY = edge.getY(idx) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L842">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L844" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the last point in the edge
                // check to see if lastPoint and idx + 1 are adjacent
<span class="nc" id="L847">                diffX = edge.getX(idx + 1) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L849">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L851" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L852">                    return true;</span>
                }

<span class="nc" id="L855">                diffY = edge.getY(idx + 1) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L857">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L859" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L860">                    return true;</span>
                }
            }
<span class="nc" id="L863">            return false;</span>
        }
        
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (idx == (edge.getN() - 1)) {</span>
            
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L869">                return true;</span>
            }
            
            // does this point currently connect to the first point?
<span class="nc" id="L873">            float diffX = edge.getX(idx) - edge.getX(0);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L875">                diffX *= -1;</span>
            }
<span class="nc" id="L877">            float diffY = edge.getY(idx) - edge.getY(0);</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L879">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L881" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the first point in the edge
                // check to see if lastPoint - 1 and first point are adjacent
<span class="nc" id="L884">                diffX = edge.getX(idx - 1) - edge.getX(0);</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L886">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L889">                    return true;</span>
                }

<span class="nc" id="L892">                diffY = edge.getY(idx - 1) - edge.getY(0);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L894">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L896" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L897">                    return true;</span>
                }
            }
<span class="nc" id="L900">            return false;</span>
        }
            
<span class="nc bnc" id="L903" title="All 2 branches missed.">        if ((idx + 1) &lt; edge.getN()) {</span>
<span class="nc" id="L904">            float diffX = edge.getX(idx - 1) - edge.getX(idx + 1);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L906">                diffX *= -1;</span>
            }
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L909">                return true;</span>
            }

<span class="nc" id="L912">            float diffY = edge.getY(idx - 1) - edge.getY(idx + 1);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L914">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if (diffY &gt; 1) {</span>
<span class="nc" id="L917">                return true;</span>
            }

<span class="nc" id="L920">            return false;</span>
        }
        
<span class="nc" id="L923">        return false;</span>
    }

    public boolean pruneAdjacentNeighborsTo2(PairIntArray edge, final int eIdx,
        int[] outputAdjacentNeighbors, int nOutputAdjacentNeighbors) {
                    
<span class="nc" id="L929">        int h = 5;</span>
<span class="nc bnc" id="L930" title="All 4 branches missed.">        if (((eIdx - h) &lt; 0) || ((eIdx + h) &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L931">            return false;</span>
        }

<span class="nc" id="L934">        final int x = edge.getX(eIdx);</span>
<span class="nc" id="L935">        final int y = edge.getY(eIdx);</span>
        
        // find which point among outputAdjacentNeighbors and eIdx is furthest
        // tangentially from a line formed by the neighboring 5 points on each 
        // side of (x, y) and remove that point from the edge
        
<span class="nc" id="L941">        int x0 = edge.getX(eIdx - h);</span>
<span class="nc" id="L942">        int y0 = edge.getY(eIdx - h);</span>
<span class="nc" id="L943">        int x1 = edge.getX(eIdx + h);</span>
<span class="nc" id="L944">        int y1 = edge.getY(eIdx + h);</span>

        // which of the 3 or more in outputAdjacentNeighbors do not disconnect
        //   the adjacent lines?
<span class="nc" id="L948">        double maxDistance = Double.MIN_VALUE;</span>
<span class="nc" id="L949">        int maxDistanceIdx = -1;</span>
        
        // if removing this point at eIdx would not disconnect the surrounding
        // points, initialize maxDistance and maxDistanceIdx with it
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (!doesDisconnect(edge, eIdx)) {</span>
<span class="nc" id="L954">            maxDistance = distanceFromPointToALine(x0, y0, x1, y1, x, y);</span>
<span class="nc" id="L955">            maxDistanceIdx = eIdx;</span>
        }
        
<span class="nc bnc" id="L958" title="All 2 branches missed.">        for (int i = 0; i &lt; nOutputAdjacentNeighbors; i++) {</span>
            
<span class="nc" id="L960">            int idx = outputAdjacentNeighbors[i];</span>
            
<span class="nc bnc" id="L962" title="All 2 branches missed.">            if (!doesDisconnect(edge, idx)) {</span>
<span class="nc" id="L963">                int xCompare = edge.getX(idx);</span>
<span class="nc" id="L964">                int yCompare = edge.getY(idx);</span>
                
<span class="nc" id="L966">                double dist = distanceFromPointToALine(x0, y0, x1, y1, xCompare, </span>
                    yCompare);
                
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (dist &gt; maxDistance) {</span>
<span class="nc" id="L970">                    maxDistance = dist;</span>
<span class="nc" id="L971">                    maxDistanceIdx = idx;</span>
                }
            }
        }
       
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (maxDistanceIdx == -1) {</span>
<span class="nc" id="L977">            return false;</span>
        }        
        
<span class="nc" id="L980">        log.finest(&quot;removing point (&quot; + edge.getX(maxDistanceIdx) </span>
<span class="nc" id="L981">            + &quot;,&quot; + edge.getY(maxDistanceIdx) + &quot;) &quot; + </span>
<span class="nc" id="L982">            &quot;idx=&quot; + maxDistanceIdx + &quot; out of &quot; + edge.getN());</span>
        
<span class="nc" id="L984">        edge.removeRange(maxDistanceIdx, maxDistanceIdx);</span>
        
<span class="nc" id="L986">        return true;</span>
    }
    
    /**
     * looks for the immediate adjacent neighbors and return their indexes
     * in outputAdjacentNeighborIndexes and return for the method the number
     * of items to read in outputAdjacentNeighborIndexes.
     * 
     * @param edge
     * @param idx
     * @param outputAdjacentNeighborIndexes
     * @return 
     */
    public int getAdjacentNeighbors(PairIntArray edge, int idx, 
        int[] outputAdjacentNeighborIndexes) {
        
<span class="nc" id="L1002">        float x = edge.getX(idx);</span>
<span class="nc" id="L1003">        float y = edge.getY(idx);</span>
        
<span class="nc" id="L1005">        int nAdjacent = 0;</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        for (int i = (idx - 2); i &lt;= (idx + 2); i++) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (i == idx) {</span>
<span class="nc" id="L1008">                continue;</span>
            }
<span class="nc bnc" id="L1010" title="All 4 branches missed.">            if ((i &lt; 0) || (i &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L1011">                continue;</span>
            }
            
<span class="nc" id="L1014">            float diffX = edge.getX(i) - x;</span>
<span class="nc" id="L1015">            float diffY = edge.getY(i) - y;</span>
            
<span class="nc bnc" id="L1017" title="All 4 branches missed.">            if ((Math.abs(diffX) &lt; 2) &amp;&amp; (Math.abs(diffY) &lt; 2)) {</span>
                
<span class="nc" id="L1019">                outputAdjacentNeighborIndexes[nAdjacent] = i;</span>
                
<span class="nc" id="L1021">                nAdjacent++;</span>
            }
        }
        
<span class="nc" id="L1025">        return nAdjacent;</span>
    }

    public double distanceFromPointToALine(float lineX0, float lineY0,
        float lineX1, float lineY1, float xP, float yP) {
        
        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
        
        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)
        
        distance between that edge and a point (xP, yP) is
        
        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;
        
        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- ) 
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )        
        */
        
<span class="fc" id="L1048">        float diffX = lineX1 - lineX0;</span>
<span class="fc" id="L1049">        float diffY = lineY1 - lineY0;</span>
        
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (diffY == 0) {</span>
            // horizontal line
<span class="fc" id="L1053">            return Math.abs(yP - lineY0);</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="fc" id="L1056">            return Math.abs(xP - lineX0);</span>
        }
        
<span class="fc" id="L1059">        double pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>
        
<span class="fc" id="L1061">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>
        
<span class="fc" id="L1063">        double dist = pt1/pt2;</span>
        
<span class="fc" id="L1065">        return dist;</span>
    }

    public double distanceFromPointToALine(int lineX0, int lineY0,
        int lineX1, int lineY1, int xP, int yP) {
        
        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
        
        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)
        
        distance between that edge and a point (xP, yP) is
        
        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;
        
        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- ) 
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )        
        */
        
<span class="nc" id="L1088">        int diffX = lineX1 - lineX0;</span>
<span class="nc" id="L1089">        int diffY = lineY1 - lineY0;</span>
        
<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (diffY == 0) {</span>
            // horizontal line
<span class="nc" id="L1093">            return Math.abs(yP - lineY0);</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="nc" id="L1096">            return Math.abs(xP - lineX0);</span>
        }
        
<span class="nc" id="L1099">        int pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>
        
<span class="nc" id="L1101">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>
        
<span class="nc" id="L1103">        double dist = pt1/pt2;</span>
        
<span class="nc" id="L1105">        return dist;</span>
    }

    public void correctCheckeredSegments(List&lt;PairIntArray&gt; tmpEdges) {
        
        /*
        there are sometimes sections in the line where one pixel is displaced
               @      @ @ @@@@@@@@@
        @@@@@@@ @@@@@@ @ @ 
        
        So far, only seen in horizontal or vertical segments.
        */
        
<span class="nc" id="L1118">        int[] xs = new int[2];</span>
<span class="nc" id="L1119">        int[] ys = new int[2];</span>
        
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        for (int lIdx = 0; lIdx &lt; tmpEdges.size(); lIdx++) {</span>
            
<span class="nc" id="L1123">            PairIntArray edge = tmpEdges.get(lIdx);</span>
            
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            for (int i = 0; i &lt; edge.getN(); i++) {</span>
                
<span class="nc" id="L1127">                correctCheckeredSegments(edge, i, xs, ys);</span>
            }
        }
<span class="nc" id="L1130">    }</span>
    
    public void debugPrint(PairIntArray edge) {
<span class="nc" id="L1133">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        for (int i = 0; i &lt; edge.getN(); i++) {</span>
<span class="nc" id="L1135">             int x = edge.getX(i);</span>
<span class="nc" id="L1136">             int y = edge.getY(i);</span>
<span class="nc" id="L1137">             sb.append(String.format(&quot;%d)  (%d, %d)\n&quot;, i, x, y));</span>
        }
<span class="nc" id="L1139">        log.info(sb.toString());</span>
<span class="nc" id="L1140">    }</span>
    
    public int indexOfPointsInRange(List&lt;PairIntArray&gt; edges, 
        int xLo, int xHi, int yLo, int yHi) {
        
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
            
<span class="nc" id="L1147">            PairIntArray edge = edges.get(i);</span>
            
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            for (int j = 0; j &lt; edge.getN(); j++) {</span>
<span class="nc" id="L1150">                int x = edge.getX(j);</span>
<span class="nc" id="L1151">                int y = edge.getY(j);</span>
<span class="nc bnc" id="L1152" title="All 8 branches missed.">                if ((x &gt;= xLo) &amp;&amp; (x &lt;= xHi) &amp;&amp; (y &gt;= yLo) &amp;&amp; (y &lt;= yHi)) {</span>
<span class="nc" id="L1153">                    return i;</span>
                }
            }
        }
        
<span class="nc" id="L1158">        return -1;</span>
    }
    
    public int debugFindEdgeContainingPoint(List&lt;PairIntArray&gt; edges, int x, int y) {
<span class="nc bnc" id="L1162" title="All 2 branches missed.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
<span class="nc" id="L1163">            PairIntArray edge = edges.get(i);</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">            if (debugEdgeContainsPoint(edge, x, y)) {</span>
<span class="nc" id="L1165">                return i;</span>
            }
        }
<span class="nc" id="L1168">        return -1;</span>
    }
    public boolean debugEdgeContainsPoint(PairIntArray edge, int x, int y) {
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        for (int i = 0; i &lt; edge.getN(); i++) {</span>
<span class="nc" id="L1172">            int xc = edge.getX(i);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">            if (xc != x) {</span>
<span class="nc" id="L1174">                continue;</span>
            }
<span class="nc" id="L1176">            int yc = edge.getY(i);</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">            if (yc != x) {</span>
<span class="nc" id="L1178">                continue;</span>
            }
<span class="nc" id="L1180">            return true;</span>
        }
<span class="nc" id="L1182">        return false;</span>
    }
    
    private boolean debugIsSection1(PairIntArray edge, int idx) {
<span class="nc" id="L1186">        int x = edge.getX(idx);</span>
<span class="nc" id="L1187">        int y = edge.getY(idx);</span>
<span class="nc bnc" id="L1188" title="All 8 branches missed.">        if ((x &gt; 92) &amp;&amp; (x &lt; 99) &amp;&amp; (y &gt; 58) &amp;&amp; (y &lt; 63)) {</span>
<span class="nc" id="L1189">            return true;</span>
        }
<span class="nc" id="L1191">        return false;</span>
    }
    
    private boolean debugIsSection2(PairIntArray edge, int idx) {
<span class="nc" id="L1195">        int x = edge.getX(idx);</span>
<span class="nc" id="L1196">        int y = edge.getY(idx);</span>
<span class="nc bnc" id="L1197" title="All 8 branches missed.">        if ((x &gt; 134) &amp;&amp; (x &lt; 147) &amp;&amp; (y &gt; 58) &amp;&amp; (y &lt; 63)) {</span>
<span class="nc" id="L1198">            return true;</span>
        }
<span class="nc" id="L1200">        return false;</span>
    }

    private void correctCheckeredSegments(PairIntArray edge, int idx,
        int[] xs, int[] ys) {
        
<span class="nc" id="L1206">        int h = 4;</span>
        
        /*
        there are sometimes sections in the line where one pixel is displaced
               @      @ @ @@@@@@@@@
        @@@@@@@ @@@@@@ @ @ 
        
        So far, only seen in horizontal or vertical segments.
        */
        
<span class="nc" id="L1216">        int nx = 0;</span>
<span class="nc" id="L1217">        int ny = 0;</span>
        
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        for (int i = (idx - h); i &lt;= (idx + h); i++) {</span>
            
<span class="nc bnc" id="L1221" title="All 4 branches missed.">            if ((i &lt; 0) || (i &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L1222">                continue;</span>
            }
            
<span class="nc" id="L1225">            int x = edge.getX(i);</span>
<span class="nc" id="L1226">            int y = edge.getY(i);</span>
            
<span class="nc bnc" id="L1228" title="All 2 branches missed.">            if (nx == 0) {</span>
<span class="nc" id="L1229">                xs[nx] = x;</span>
<span class="nc" id="L1230">                nx++;</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            } else if (nx == 1) {</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">                if (xs[0] != x) {</span>
<span class="nc" id="L1233">                    xs[nx] = x;</span>
<span class="nc" id="L1234">                    nx++;</span>
                }
<span class="nc bnc" id="L1236" title="All 4 branches missed.">            } else if ((xs[0] != x) &amp;&amp; (xs[1] != x)) {</span>
                // increment to higher than &quot;1&quot; so we know it's not a vertical
                // checkered/fence pattern
<span class="nc" id="L1239">                nx++;</span>
            }
            
<span class="nc bnc" id="L1242" title="All 2 branches missed.">            if (ny == 0) {</span>
<span class="nc" id="L1243">                ys[ny] = y;</span>
<span class="nc" id="L1244">                ny++;</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            } else if (ny == 1) {</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                if (ys[0] != y) {</span>
<span class="nc" id="L1247">                    ys[ny] = y;</span>
<span class="nc" id="L1248">                    ny++;</span>
                }
<span class="nc bnc" id="L1250" title="All 4 branches missed.">            } else if ((ys[0] != y) &amp;&amp; (ys[1] != y)) {</span>
                // increment to higher than &quot;2&quot; so we know it's not a horizontal
                // checkered/fence pattern
<span class="nc" id="L1253">                ny++;</span>
            }
        }
        
<span class="nc bnc" id="L1257" title="All 4 branches missed.">        if ((ny == 2) || (nx == 2)) {</span>
            
<span class="nc bnc" id="L1259" title="All 2 branches missed.">            for (int i = (idx - h + 2); i &lt;= (idx + h - 1); i++) {</span>
                
                //TODO: condense these:
<span class="nc bnc" id="L1262" title="All 4 branches missed.">                if ((i &lt; 0) || (i &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L1263">                    continue;</span>
                }
<span class="nc bnc" id="L1265" title="All 4 branches missed.">                if (((i - 1) &lt; 0) || ((i - 1) &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L1266">                    continue;</span>
                }
<span class="nc bnc" id="L1268" title="All 4 branches missed.">                if (((i - 2) &lt; 0) || ((i - 2) &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L1269">                    continue;</span>
                }
<span class="nc bnc" id="L1271" title="All 4 branches missed.">                if (((i + 1) &lt; 0) || ((i + 1) &gt; (edge.getN() - 1))) {</span>
<span class="nc" id="L1272">                    continue;</span>
                }
                
<span class="nc bnc" id="L1275" title="All 2 branches missed.">                if (ny == 2) {</span>
<span class="nc" id="L1276">                    int prev2Y = edge.getY(i - 2);                </span>
<span class="nc" id="L1277">                    int prev1Y = edge.getY(i - 1);</span>

<span class="nc bnc" id="L1279" title="All 2 branches missed.">                    if (prev2Y != prev1Y) {</span>
<span class="nc" id="L1280">                        continue;</span>
                    }

<span class="nc" id="L1283">                    int prev2X = edge.getX(i - 2);</span>
<span class="nc" id="L1284">                    int prev1X = edge.getX(i - 1);</span>
<span class="nc" id="L1285">                    int x = edge.getX(i);</span>
<span class="nc" id="L1286">                    int next1X = edge.getX(i + 1);</span>

<span class="nc" id="L1288">                    int dx = prev1X - prev2X;</span>

<span class="nc bnc" id="L1290" title="All 4 branches missed.">                    if (!(((prev1X + dx) == x) &amp;&amp; ((x + dx) == next1X))) {</span>
<span class="nc" id="L1291">                        continue;</span>
                    }

<span class="nc" id="L1294">                    int y = edge.getY(i);</span>
<span class="nc" id="L1295">                    int next1Y = edge.getY(i + 1);</span>
<span class="nc bnc" id="L1296" title="All 4 branches missed.">                    if ((next1Y == prev1Y) &amp;&amp; (next1Y != y)) {</span>
<span class="nc" id="L1297">                        edge.set(i, x, next1Y);</span>
                    }
<span class="nc" id="L1299">                } else {</span>
<span class="nc" id="L1300">                    int prev2X = edge.getX(i - 2);                </span>
<span class="nc" id="L1301">                    int prev1X = edge.getX(i - 1);</span>

<span class="nc bnc" id="L1303" title="All 2 branches missed.">                    if (prev2X != prev1X) {</span>
<span class="nc" id="L1304">                        continue;</span>
                    }
                    
<span class="nc" id="L1307">                    int prev2Y = edge.getY(i - 2);</span>
<span class="nc" id="L1308">                    int prev1Y = edge.getY(i - 1);</span>
<span class="nc" id="L1309">                    int y = edge.getY(i);</span>
<span class="nc" id="L1310">                    int next1Y = edge.getY(i + 1);</span>

<span class="nc" id="L1312">                    int dy = prev1Y - prev2Y;</span>

<span class="nc bnc" id="L1314" title="All 4 branches missed.">                    if (!(((prev1Y + dy) == y) &amp;&amp; ((y + dy) == next1Y))) {</span>
<span class="nc" id="L1315">                        continue;</span>
                    }
                    
<span class="nc" id="L1318">                    int x = edge.getX(i);</span>
<span class="nc" id="L1319">                    int next1X = edge.getX(i + 1);</span>
<span class="nc bnc" id="L1320" title="All 4 branches missed.">                    if ((next1X == prev1X) &amp;&amp; (next1X != x)) {</span>
<span class="nc" id="L1321">                        edge.set(i, next1X, y);</span>
                    }
                }
            }                
        }
<span class="nc" id="L1326">    }</span>
    
    /**
     * find the jagged line segments in the curve and return the ranges
     * of the point indexes.
     * This method searches for ledges first and then within the remaining
     * space, searches for stair cases and then 45 degree lines.
     * @param curve
     * @return 
     */
    public PairIntArray findJaggedLineSegments(final PairIntArray curve) {
        
        //TODO: use minimum curve size
<span class="pc bpc" id="L1339" title="2 of 4 branches missed.">        if (curve == null || curve.getN() &lt; 5) {</span>
<span class="nc" id="L1340">            return new PairIntArray();</span>
        }
        
        /*
        search for ledges first, then in the space where ledges were not 
        found, search for jagged lines (these have steps of height 1 but 
        varying width).
        And as a comparison, for the spaces where ledges were not found,
        merge them if they are small and close and then research the
        merged ranges for jagged lines and then the remaining space
        for ledges.
        Combine the 2 results to make the best results.
        NOTE: need to simplify and combine the logic of the 2 searches...
         */

<span class="fc" id="L1355">        PairIntArray jaggedLines1 = findLedgesInCurve(curve);</span>
        
<span class="fc" id="L1357">        PairIntArray remainingRanges = </span>
<span class="fc" id="L1358">            writeRangesNotAlreadyIncluded(curve, jaggedLines1);</span>
                
<span class="fc bfc" id="L1360" title="All 2 branches covered.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {</span>
            
<span class="fc" id="L1362">            int r0 = remainingRanges.getX(i);</span>
<span class="fc" id="L1363">            int r1 = remainingRanges.getY(i);</span>
           
<span class="fc" id="L1365">            PairIntArray tmpStaircaseRanges = </span>
<span class="fc" id="L1366">                findJaggedLineStaircaseSegments(curve, r0, r1);</span>
            
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">            if (tmpStaircaseRanges != null) {</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">                for (int j = 0; j &lt; tmpStaircaseRanges.getN(); j++) {</span>
<span class="fc" id="L1370">                    int s0 = tmpStaircaseRanges.getX(j);</span>
<span class="fc" id="L1371">                    int s1 = tmpStaircaseRanges.getY(j);</span>
<span class="fc" id="L1372">                    jaggedLines1.add(s0, s1);</span>
                }
            }
        }
        
<span class="fc" id="L1377">        sortByX(jaggedLines1);</span>
        
        // merge adjacent ranges
<span class="fc" id="L1380">        mergeRanges(curve, jaggedLines1);</span>
       
        // search for 45 degree lines 
<span class="fc" id="L1383">        remainingRanges = </span>
<span class="fc" id="L1384">            writeRangesNotAlreadyIncluded(curve, jaggedLines1);</span>
<span class="fc" id="L1385">        boolean changed = false;</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {            </span>
<span class="fc" id="L1387">            int r0 = remainingRanges.getX(i);</span>
<span class="fc" id="L1388">            int r1 = remainingRanges.getY(i);</span>
<span class="fc" id="L1389">            PairIntArray lineRanges = </span>
<span class="fc" id="L1390">                find45DegreeSegments(curve, r0, r1);</span>
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">            if (lineRanges != null) {</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">                for (int j = 0; j &lt; lineRanges.getN(); j++) {</span>
<span class="fc" id="L1393">                    int s0 = lineRanges.getX(j);</span>
<span class="fc" id="L1394">                    int s1 = lineRanges.getY(j);</span>
<span class="fc" id="L1395">                    jaggedLines1.add(s0, s1);</span>
<span class="fc" id="L1396">                    changed = true;</span>
                }
            }
        }
        
<span class="fc bfc" id="L1401" title="All 2 branches covered.">        if (changed) {</span>
        
<span class="fc" id="L1403">            sortByX(jaggedLines1);</span>
        
            // merge ranges again
<span class="fc" id="L1406">            mergeRanges(curve, jaggedLines1);</span>
        }
        
<span class="fc" id="L1409">        return jaggedLines1;</span>
    }
    
    /**
     * find the jagged line segments in the curve and return the ranges
     * of the point indexes.
     * This method searches for staircases first and then within the remaining
     * space, searches for ledges and then 45 degree lines.
     * @param curve
     * @return 
     */
    public PairIntArray findJaggedLineSegments2(final PairIntArray curve) {
        
        //TODO: use minimum curve size
<span class="nc bnc" id="L1423" title="All 4 branches missed.">        if (curve == null || curve.getN() &lt; 5) {</span>
<span class="nc" id="L1424">            return null;</span>
        }
        
        // if have a merged larger range, this suggests that starting a
        // search with staircases and following that with search for 
        // ledges might result in more total accurately found jagged lines.
<span class="nc" id="L1430">        PairIntArray jaggedLines2 = findJaggedLineStaircaseSegments(</span>
<span class="nc" id="L1431">            curve, 0, curve.getN() - 1);</span>

<span class="nc" id="L1433">        PairIntArray remainingRanges = writeRangesNotAlreadyIncluded(curve, </span>
            jaggedLines2);
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {</span>
<span class="nc" id="L1436">            int r0 = remainingRanges.getX(i);</span>
<span class="nc" id="L1437">            int r1 = remainingRanges.getY(i);</span>
<span class="nc" id="L1438">            findLedgesWithinRange(curve, r0, r1, jaggedLines2);</span>
        }
                       
<span class="nc" id="L1441">        sortByX(jaggedLines2);</span>
        
        // merge adjacent ranges
<span class="nc" id="L1444">        mergeRanges(curve, jaggedLines2);</span>
       
        // search for 45 degree lines 
<span class="nc" id="L1447">        remainingRanges = </span>
<span class="nc" id="L1448">            writeRangesNotAlreadyIncluded(curve, jaggedLines2);</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        for (int i = 0; i &lt; remainingRanges.getN(); i++) {            </span>
<span class="nc" id="L1450">            int r0 = remainingRanges.getX(i);</span>
<span class="nc" id="L1451">            int r1 = remainingRanges.getY(i);</span>
<span class="nc" id="L1452">            PairIntArray lineRanges = </span>
<span class="nc" id="L1453">                find45DegreeSegments(curve, r0, r1);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">            if (lineRanges != null) {</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">                for (int j = 0; j &lt; lineRanges.getN(); j++) {</span>
<span class="nc" id="L1456">                    int s0 = lineRanges.getX(j);</span>
<span class="nc" id="L1457">                    int s1 = lineRanges.getY(j);</span>
<span class="nc" id="L1458">                    jaggedLines2.add(s0, s1);</span>
                }
            }
        }
        
<span class="nc" id="L1463">        sortByX(jaggedLines2);</span>
        
        // merge ranges again
<span class="nc" id="L1466">        mergeRanges(curve, jaggedLines2);</span>
        
<span class="nc" id="L1468">        return jaggedLines2;</span>
    }
    
    private void mergeRanges(PairIntArray curve, PairIntArray ranges) {
        
<span class="fc" id="L1473">        int n = ranges.getN();</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">        for (int i = (n - 1); i &gt; 0; i--) {</span>
            
<span class="fc" id="L1476">            int r0 = ranges.getX(i);</span>
<span class="fc" id="L1477">            int r1 = ranges.getY(i);</span>
            
            // gap between end of one range and start of the next that might
            // be part of both ranges
<span class="fc bfc" id="L1481" title="All 2 branches covered.">            if ((r0 - ranges.getY(i - 1)) &lt; 3) {</span>
                
                // check slopes before merging.
                
<span class="fc" id="L1485">                double theta10 = calcTheta(curve, r0, r1);</span>
                
<span class="fc" id="L1487">                int r2 = ranges.getX(i - 1);</span>
<span class="fc" id="L1488">                int r3 = ranges.getY(i - 1);                </span>
<span class="fc" id="L1489">                double theta32 = calcTheta(curve, r2, r3);</span>
               
<span class="fc" id="L1491">                double diffTheta = Math.abs(theta10 - theta32);</span>
                
<span class="fc bfc" id="L1493" title="All 2 branches covered.">                if (diffTheta &gt; (Math.PI/4.)) { </span>
<span class="fc" id="L1494">                    continue;</span>
                }
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">                if (diffTheta &gt; 0.1) {</span>
                    // this may be 2 regions due to 2 different methods,
                    // the ledges method and then staircase method,
                    // so retry the staircase alone for the full range to
                    // see if the entire region is found as a single region.
                    // r2 to r1
<span class="fc" id="L1502">                    PairIntArray staircaseRanges = </span>
<span class="fc" id="L1503">                        findJaggedLineStaircaseSegments(curve, r2, r1);</span>
                    
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">                    if (staircaseRanges != null) {</span>
                        
<span class="fc bfc" id="L1507" title="All 2 branches covered.">                        for (int j = 0; j &lt; staircaseRanges.getN(); j++) {</span>
<span class="fc" id="L1508">                            int s0 = staircaseRanges.getX(j);</span>
<span class="fc" id="L1509">                            int s1 = staircaseRanges.getY(j);</span>
<span class="fc" id="L1510">                            log.fine(&quot;       &quot; + s0 + &quot; : &quot; + s1);</span>
                        }
                        
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">                        if (staircaseRanges.getN() == 0) {</span>
                            // do not merge
<span class="nc" id="L1515">                            continue;</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">                        } else if (staircaseRanges.getN() == 1) {</span>
                            // does it match the whole range r2 to r1
                            // or only one of r2:r3 and r0:r1?
                            // if only matches one range, do not merge them
                            
<span class="fc" id="L1521">                            int diff10 = Math.abs((r0 - staircaseRanges.getX(0)) +</span>
<span class="fc" id="L1522">                                (r1 - staircaseRanges.getY(0)));</span>
                            
<span class="fc" id="L1524">                            int diff32 = Math.abs((r2 - staircaseRanges.getX(0)) +</span>
<span class="fc" id="L1525">                                (r3 - staircaseRanges.getY(0)));</span>
                            
<span class="fc" id="L1527">                            int diff21 = Math.abs((r2 - staircaseRanges.getX(0)) +</span>
<span class="fc" id="L1528">                                (r1 - staircaseRanges.getY(0)));</span>
                            
                            // which one is close to zero?
<span class="fc bfc" id="L1531" title="All 4 branches covered.">                            if ((diff21 &lt; diff10) &amp;&amp; (diff21 &lt; diff32)) {</span>
                                // let these merge
<span class="pc bpc" id="L1533" title="1 of 4 branches missed.">                            } else if ((diff32 &lt; diff10) &amp;&amp; (diff32 &lt; diff21)) {</span>
                                // matches the range r2 to r3, don't merge
<span class="fc" id="L1535">                                continue;</span>
<span class="pc bpc" id="L1536" title="2 of 4 branches missed.">                            } else if ((diff10 &lt; diff32) &amp;&amp; (diff10 &lt; diff21)) {</span>
                                // matches the range r0 to r1, don't merge
<span class="fc" id="L1538">                                continue;</span>
                            }
                            
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">                        } else if (staircaseRanges.getN() &gt; 1) {</span>
                            // keep the ranges separate
<span class="fc" id="L1543">                            continue;</span>
                        }
                    } else {
                        continue;
                    }                  
                } 
                
<span class="fc" id="L1550">                ranges.set(i - 1, ranges.getX(i - 1), r1);</span>
                
<span class="fc" id="L1552">                ranges.removeRange(i, i);</span>
            }
        }        
       
<span class="fc" id="L1556">    }</span>
    
    /**
     * find the lines composed of nearly uniform stairs and return them as
     * index ranges.  For example, a jagged line that extends from point
     * 10 to point 30 inclusive is present in the returned object as a pair
     * with (x, y) = (10, 30).
     * @param curve
     * @return 
     */
    private PairIntArray findJaggedLineStaircaseSegments(final PairIntArray 
        curve, int startIndex, int stopIndex) {
        
        //TODO: use minimum curve size
<span class="pc bpc" id="L1570" title="1 of 4 branches missed.">        if (curve == null || (stopIndex - startIndex) &lt; 5) {</span>
<span class="fc" id="L1571">            return new PairIntArray();</span>
        }
        
        /*
        iterate over the curve to find the nearly straight line segments.
        This is useful for quickly removing false corners due to jagged
        lines.
        -- move forward and learn dx and dy.  either dx or dy must be constant
        and have value -1 or +1.  the other dimension can only change by 0
        or by the same +1 or -1 always.  the step width between the change
        must be on average a certain value and any other steps included
        can be +1 or -1 in width (for example, if step width is 2, can have
        steps with width 1 and 3 included also).
        keep a moving average and when the just stated conditions cease,
        note the endpoints.
        --&gt; to be sure the section is a line, make an easy to remove section:
            fit the points to a line, noting the mean and stdev of the distance
            of them from the line.
            are the results consistent with a line?  mean error is?
        -- if the segment is longer than (tbd) pixels, store it
        -- repeat the above until end of curve is reached.
        */
        
<span class="fc" id="L1594">        PairIntArray lineSegmentRanges = new PairIntArray();</span>
                    
<span class="fc" id="L1596">        int dx = 0;</span>
<span class="fc" id="L1597">        int dy = 0;</span>
<span class="fc" id="L1598">        int i = startIndex;</span>
<span class="fc" id="L1599">        Boolean widthIsAlongX = null;</span>
<span class="fc bfc" id="L1600" title="All 4 branches covered.">        while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1601">            i++;</span>
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">            if (i &gt;= stopIndex) {</span>
<span class="nc" id="L1603">                return lineSegmentRanges;</span>
            }
<span class="fc" id="L1605">            dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1606">            dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">            if (dx == 0) {</span>
<span class="nc" id="L1608">                widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">            } else if (dy == 0) {</span>
<span class="fc" id="L1610">                widthIsAlongX = Boolean.TRUE;</span>
            }
        }
<span class="fc" id="L1613">        int start = i;</span>
        
<span class="fc" id="L1615">        int keepDX = dx;</span>
<span class="fc" id="L1616">        int keepDY = dy;</span>
        
<span class="fc bfc" id="L1618" title="All 2 branches covered.">        if (widthIsAlongX == null) {</span>
<span class="fc bfc" id="L1619" title="All 4 branches covered.">            while ((dx != 0) &amp;&amp; (dy != 0)) {</span>
<span class="fc" id="L1620">                i++;</span>
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">                if (i &gt;= stopIndex) {</span>
<span class="nc" id="L1622">                    return lineSegmentRanges;</span>
                }
<span class="fc" id="L1624">                dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1625">                dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1626" title="All 2 branches covered.">                if (dx == 0) {</span>
<span class="fc" id="L1627">                    widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1628" title="All 2 branches covered.">                } else if (dy == 0) {</span>
<span class="fc" id="L1629">                    widthIsAlongX = Boolean.TRUE;</span>
                }
            }
        }
<span class="fc" id="L1633">        dx = keepDX;</span>
<span class="fc" id="L1634">        dy = keepDY;</span>
<span class="fc" id="L1635">        int stepStart = startIndex;</span>
<span class="fc" id="L1636">        int lineStart = startIndex;</span>
<span class="fc" id="L1637">        int nSteps = 0;</span>
<span class="fc" id="L1638">        int sumStepWidth = 0;</span>
<span class="fc" id="L1639">        float avgStepWidth = 0;</span>
<span class="fc" id="L1640">        float firstStepWidth = -1;</span>
<span class="fc" id="L1641">        float lastStepWidth = -1;</span>
        
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">        for (i = start; i &lt;= stopIndex; i++) {</span>
                    
<span class="fc" id="L1645">            int x = curve.getX(i);</span>
<span class="fc" id="L1646">            int y = curve.getY(i);</span>
            
<span class="fc" id="L1648">            int diffX = (x - curve.getX(i - 1));</span>
            
<span class="fc" id="L1650">            int diffY = (y - curve.getY(i - 1));</span>
            
            // if not a continuation of current step, increment step
<span class="fc" id="L1653">            if (!(</span>
<span class="fc bfc" id="L1654" title="All 6 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffX == dx) &amp;&amp; (diffY == 0))</span>
                || 
<span class="fc bfc" id="L1656" title="All 6 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffY == dy) &amp;&amp; (diffX == 0))</span>
                )
                ){
                
<span class="fc" id="L1660">                int currentStepWidth = i - stepStart;</span>
                
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">                if (currentStepWidth &gt; 0) {</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">                    if (nSteps == 0) {</span>
<span class="fc" id="L1664">                        firstStepWidth = currentStepWidth;</span>
                    }
<span class="fc" id="L1666">                    nSteps++;</span>
<span class="fc" id="L1667">                    sumStepWidth += currentStepWidth;</span>
<span class="fc" id="L1668">                    avgStepWidth = sumStepWidth/(float)nSteps;</span>
<span class="fc" id="L1669">                    stepStart = i;</span>
<span class="fc" id="L1670">                    lastStepWidth = currentStepWidth;</span>
                }                
            }
            
            // if an invalid dx or dy, write the lineSegment and reset the range
<span class="fc bfc" id="L1675" title="All 2 branches covered.">            if ((i == stopIndex) ||</span>
<span class="fc bfc" id="L1676" title="All 4 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx))</span>
<span class="fc bfc" id="L1677" title="All 4 branches covered.">                || (!widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy))</span>
                ||
<span class="fc bfc" id="L1679" title="All 6 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy) &amp;&amp; (diffY != 0))</span>
                ||
<span class="fc bfc" id="L1681" title="All 6 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx) &amp;&amp; (diffX != 0))</span>
                ) {
                
<span class="fc bfc" id="L1684" title="All 2 branches covered.">                if (nSteps &gt; 2) {</span>
                    
<span class="fc" id="L1686">                    int avg = Math.round(avgStepWidth);</span>
                    
<span class="fc" id="L1688">                    int[] endSegment = validateJaggedLineSegment(curve,</span>
                        lineStart, (i - 1), avg, dx, dy,
                        widthIsAlongX);
                    
                    // only store if has at least 3 steps (but if avg==1, 10)
<span class="fc bfc" id="L1693" title="All 8 branches covered.">                    if (</span>
                    ((avg == 1) &amp;&amp; 
                        ((endSegment[0] - lineStart + 1) &gt;= 10)
                    )
                    || 
                    ((avg &gt; 1) &amp;&amp; 
                        ((endSegment[0] - lineStart + 1) &gt;= 3 * avg)
                    )) {
<span class="fc bfc" id="L1701" title="All 8 branches covered.">                        if (</span>
                            ((lastStepWidth &gt;= 3) &amp;&amp; ((lastStepWidth/avg) &gt;= 2))
                            || ((lastStepWidth == 1) &amp;&amp; (avg &gt; 1))
                            ){
                            
<span class="fc" id="L1706">                            int endMinus = (int)(endSegment[0] - lastStepWidth);</span>
                            
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">                            if ((endMinus - lineStart + 1) &gt; 4) {</span>
<span class="fc" id="L1709">                                lineSegmentRanges.add(lineStart, endMinus);</span>
                            } else {
<span class="nc" id="L1711">                                lineSegmentRanges.add(lineStart, endSegment[0]);</span>
                            }
<span class="fc" id="L1713">                        } else {</span>
<span class="fc" id="L1714">                            lineSegmentRanges.add(lineStart, endSegment[0]);</span>
                        }
                    } else {
<span class="fc" id="L1717">                        i = lineStart + endSegment[1];</span>
                    }
                }
                
<span class="fc bfc" id="L1721" title="All 2 branches covered.">                if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1722">                    return lineSegmentRanges;</span>
                }
                
                //TODO: check the stepStart index
<span class="fc" id="L1726">                stepStart = i;</span>
<span class="fc" id="L1727">                lineStart = i;</span>
                
<span class="fc" id="L1729">                dx = 0;</span>
<span class="fc" id="L1730">                dy = 0;</span>
<span class="fc" id="L1731">                widthIsAlongX = null;</span>
<span class="fc" id="L1732">                int tmpI = i;</span>
                
<span class="fc bfc" id="L1734" title="All 4 branches covered.">                while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1735">                    i++;</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">                    if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1737">                        return lineSegmentRanges;</span>
                    }
<span class="fc" id="L1739">                    dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1740">                    dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1741" title="All 2 branches covered.">                    if (dx == 0) {</span>
<span class="fc" id="L1742">                        widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1743" title="All 2 branches covered.">                    } else if (dy == 0) {</span>
<span class="fc" id="L1744">                        widthIsAlongX = Boolean.TRUE;</span>
                    }
                }
                                
<span class="fc" id="L1748">                keepDX = dx;</span>
<span class="fc" id="L1749">                keepDY = dy;</span>
                
<span class="fc bfc" id="L1751" title="All 2 branches covered.">                if (widthIsAlongX == null) {</span>
<span class="fc bfc" id="L1752" title="All 4 branches covered.">                    while ((dx != 0) &amp;&amp; (dy != 0)) {</span>
<span class="fc" id="L1753">                        i++;</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">                        if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1755">                            return lineSegmentRanges;</span>
                        }
<span class="fc" id="L1757">                        dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1758">                        dy = (curve.getY(i) - curve.getY(i - 1));</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">                        if (dx == 0) {</span>
<span class="fc" id="L1760">                            widthIsAlongX = Boolean.FALSE;</span>
<span class="fc bfc" id="L1761" title="All 2 branches covered.">                        } else if (dy == 0) {</span>
<span class="fc" id="L1762">                            widthIsAlongX = Boolean.TRUE;</span>
                        }
                    }
                    
                } else {
                    // back track to find where the current linestart
                    // should be between tmpI and i
<span class="fc" id="L1769">                    boolean iChanged = false;</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">                    for (int j = (i - 1); j &gt; tmpI; j--) {</span>
<span class="fc" id="L1771">                        diffX = (curve.getX(j) - curve.getX(j - 1));</span>
<span class="fc" id="L1772">                        diffY = (curve.getY(j) - curve.getY(j - 1));</span>
<span class="pc bpc" id="L1773" title="2 of 6 branches missed.">                        if (widthIsAlongX &amp;&amp; (diffY == 0) &amp;&amp; (diffX == dx)) {</span>
<span class="fc" id="L1774">                            i = j;</span>
<span class="fc" id="L1775">                            iChanged = true;</span>
<span class="pc bpc" id="L1776" title="3 of 6 branches missed.">                        } else if (!widthIsAlongX &amp;&amp; (diffX == 0) </span>
                            &amp;&amp; (diffY == dy)) {
<span class="fc" id="L1778">                            i = j;</span>
<span class="fc" id="L1779">                            iChanged = true;</span>
                        }
                    }
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">                    if (iChanged) {</span>
<span class="fc" id="L1783">                        i--;</span>
                    }
                }
                
<span class="fc" id="L1787">                dx = keepDX;</span>
<span class="fc" id="L1788">                dy = keepDY;</span>
<span class="fc" id="L1789">                sumStepWidth = 0;</span>
<span class="fc" id="L1790">                avgStepWidth = 0;</span>
<span class="fc" id="L1791">                nSteps = 0;</span>
<span class="fc" id="L1792">                lastStepWidth = -1;</span>
<span class="fc" id="L1793">                firstStepWidth = -1;</span>
                
<span class="fc" id="L1795">                lineStart = i;</span>
            }
        }
                
<span class="nc" id="L1799">        return lineSegmentRanges;</span>
        
    }

    /**
     * find the lines composed of nearly uniform stairs and return them as
     * index ranges.  For example, a jagged line that extends from point
     * 10 to point 30 inclusive is present in the returned object as a pair
     * with (x, y) = (10, 30).
     * @param curve
     * @return 
     */
    private PairIntArray find45DegreeSegments(final PairIntArray 
        curve, int startIndex, int stopIndex) {
        
        //TODO: use minimum curve size
<span class="pc bpc" id="L1815" title="1 of 4 branches missed.">        if (curve == null || (stopIndex - startIndex) &lt; 5) {</span>
<span class="fc" id="L1816">            return new PairIntArray();</span>
        }
   
<span class="fc" id="L1819">        int minNSteps = 4;</span>
         
<span class="fc" id="L1821">        PairIntArray lineSegmentRanges = new PairIntArray();</span>
                    
<span class="fc" id="L1823">        int dx = 0;</span>
<span class="fc" id="L1824">        int dy = 0;</span>
<span class="fc" id="L1825">        int i = startIndex;</span>
<span class="pc bpc" id="L1826" title="1 of 4 branches missed.">        while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1827">            i++;</span>
<span class="pc bpc" id="L1828" title="1 of 2 branches missed.">            if (i &gt;= stopIndex) {</span>
<span class="nc" id="L1829">                return lineSegmentRanges;</span>
            }
<span class="fc" id="L1831">            dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1832">            dy = (curve.getY(i) - curve.getY(i - 1));</span>
        }
<span class="fc" id="L1834">        int start = i;</span>
        
<span class="fc" id="L1836">        int stepStart = startIndex;</span>
<span class="fc" id="L1837">        int lineStart = startIndex;</span>
<span class="fc" id="L1838">        int nSteps = 0;</span>
<span class="fc" id="L1839">        int sumStepWidth = 0;</span>
<span class="fc" id="L1840">        float avgStepWidth = 0;</span>
<span class="fc" id="L1841">        float firstStepWidth = -1;</span>
<span class="fc" id="L1842">        float lastStepWidth = -1;</span>
        
<span class="pc bpc" id="L1844" title="1 of 2 branches missed.">        for (i = start; i &lt;= stopIndex; i++) {</span>
                    
<span class="fc" id="L1846">            int x = curve.getX(i);</span>
<span class="fc" id="L1847">            int y = curve.getY(i);</span>
            
<span class="fc" id="L1849">            int diffX = (x - curve.getX(i - 1));</span>
            
<span class="fc" id="L1851">            int diffY = (y - curve.getY(i - 1));</span>
          
<span class="fc" id="L1853">            int currentStepWidth = i - stepStart;</span>

<span class="pc bpc" id="L1855" title="1 of 2 branches missed.">            if (currentStepWidth &gt; 0) {</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">                if (nSteps == 0) {</span>
<span class="fc" id="L1857">                    firstStepWidth = currentStepWidth;</span>
                }
<span class="fc" id="L1859">                nSteps++;</span>
<span class="fc" id="L1860">                sumStepWidth += currentStepWidth;</span>
<span class="fc" id="L1861">                avgStepWidth = sumStepWidth/(float)nSteps;</span>
<span class="fc" id="L1862">                stepStart = i;</span>
<span class="fc" id="L1863">                lastStepWidth = currentStepWidth;</span>
            }                
            
            // if an invalid dx or dy, write the lineSegment and reset the range
<span class="fc bfc" id="L1867" title="All 6 branches covered.">            if ((i == stopIndex) || (diffX != dx) || (diffY != dy)</span>
                ) {
                
<span class="fc bfc" id="L1870" title="All 2 branches covered.">                if (nSteps &gt; minNSteps) {</span>
                                        
<span class="fc" id="L1872">                    lineSegmentRanges.add(lineStart, i - 1);</span>
                    
                }
                
<span class="fc bfc" id="L1876" title="All 2 branches covered.">                if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1877">                    return lineSegmentRanges;</span>
                }
                
                //TODO: check the stepStart index
<span class="fc" id="L1881">                stepStart = i;</span>
<span class="fc" id="L1882">                lineStart = i;</span>
                
<span class="fc" id="L1884">                dx = 0;</span>
<span class="fc" id="L1885">                dy = 0;</span>
                
<span class="fc bfc" id="L1887" title="All 4 branches covered.">                while ((dx == 0) || (dy == 0)) {</span>
<span class="fc" id="L1888">                    i++;</span>
<span class="fc bfc" id="L1889" title="All 2 branches covered.">                    if (i &gt;= stopIndex) {</span>
<span class="fc" id="L1890">                        return lineSegmentRanges;</span>
                    }
<span class="fc" id="L1892">                    dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L1893">                    dy = (curve.getY(i) - curve.getY(i - 1));</span>
                }
                
<span class="fc" id="L1896">                sumStepWidth = 0;</span>
<span class="fc" id="L1897">                avgStepWidth = 0;</span>
<span class="fc" id="L1898">                nSteps = 0;</span>
<span class="fc" id="L1899">                lastStepWidth = -1;</span>
<span class="fc" id="L1900">                firstStepWidth = -1;</span>
                
<span class="fc" id="L1902">                lineStart = i;</span>
            }
        }
                
<span class="nc" id="L1906">        return lineSegmentRanges;</span>
        
    }
    
    /**
     * validate that a line segment has steps only within +- 1 of
     * step stepWidth.  returns endIndex if entire region fits those
     * characteristics, else returns the last index where it does.
     * 
     * @param curve
     * @param startIndex
     * @param stopIndex last index of line segment, inclusive
     * @param stepWidth
     * @param dy
     * @param dy
     * @param widthIsAlongX
     * @return 
     */
     int[] validateJaggedLineSegment(final PairIntArray curve,
        int startIndex, int stopIndex, int stepWidth, int dx, int dy,
        Boolean widthIsAlongX) {
        
        //TODO: use minimum curve size
<span class="pc bpc" id="L1929" title="2 of 4 branches missed.">        if (curve == null || curve.getN() &lt; 5) {</span>
<span class="nc" id="L1930">            return new int[]{-1, -1};</span>
        }
        
<span class="fc" id="L1933">        int plusMinusWidth = 3;</span>
              
<span class="fc" id="L1935">        int n = curve.getN();</span>
          
<span class="fc" id="L1937">        int start = startIndex + 1;</span>
        
<span class="fc" id="L1939">        int stepStart = startIndex;</span>
        
        int i;
<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">        for (i = start; i &lt;= stopIndex; i++) {</span>
       
<span class="fc" id="L1944">            int diffX = (curve.getX(i) - curve.getX(i - 1));</span>
            
<span class="fc" id="L1946">            int diffY = (curve.getY(i) - curve.getY(i - 1));</span>

<span class="pc bpc" id="L1948" title="1 of 4 branches missed.">            if ((widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx)) ||</span>
<span class="fc bfc" id="L1949" title="All 6 branches covered.">                (widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy)</span>
                &amp;&amp; (diffY != 0)) ||
<span class="pc bpc" id="L1951" title="1 of 4 branches missed.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy)) ||</span>
<span class="pc bpc" id="L1952" title="1 of 6 branches missed.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffX != dx)</span>
                &amp;&amp; (diffX != 0)) ) {

<span class="fc" id="L1955">                int currentStepWidth = i - stepStart;</span>
<span class="pc bpc" id="L1956" title="1 of 2 branches missed.">                if (currentStepWidth &gt; 0) {</span>
<span class="pc bpc" id="L1957" title="1 of 2 branches missed.">                    if (Math.abs(currentStepWidth - stepWidth) &gt; plusMinusWidth) {</span>
<span class="nc" id="L1958">                        return new int[]{(stepStart - 1), currentStepWidth};</span>
                    }
                } else {
<span class="nc" id="L1961">                    return new int[]{(stepStart - 1), currentStepWidth};</span>
                }
                
                /*
                (widthIsAlongX.booleanValue() &amp;&amp; (diffY != dy)
                &amp;&amp; (diffY != 0))
                      --&gt; (stepStart - 1)
                */
<span class="fc" id="L1969">                return new int[]{(i - 1), 0};</span>
            } 
            
            // else, if just stepped up or is last index, check step size
            
<span class="fc bfc" id="L1974" title="All 4 branches covered.">            if ((widthIsAlongX.booleanValue() &amp;&amp; (diffY == dy)) ||</span>
<span class="fc bfc" id="L1975" title="All 6 branches covered.">                (!widthIsAlongX.booleanValue() &amp;&amp; (diffX == dx)) ||</span>
                (i == stopIndex)
            ) {
                
<span class="fc" id="L1979">                int currentStepWidth = i - stepStart;</span>
                
<span class="pc bpc" id="L1981" title="3 of 6 branches missed.">                if ((stepStart == 0) &amp;&amp; (stepWidth == 1) &amp;&amp; </span>
                    (currentStepWidth/stepWidth &gt; 1)) {
                    
<span class="nc" id="L1984">                    return new int[]{0, currentStepWidth};</span>
                    
<span class="pc bpc" id="L1986" title="1 of 2 branches missed.">                } else if (currentStepWidth &gt; 0) {</span>
                    
<span class="fc bfc" id="L1988" title="All 2 branches covered.">                    if (Math.abs(currentStepWidth - stepWidth) &gt; plusMinusWidth) {</span>
<span class="fc" id="L1989">                        return new int[]{(stepStart - 1), currentStepWidth};</span>
<span class="fc bfc" id="L1990" title="All 2 branches covered.">                    } else if (i == stopIndex) {</span>
<span class="fc" id="L1991">                        return new int[]{i, currentStepWidth};</span>
                    }
                    
<span class="fc" id="L1994">                    stepStart = i;</span>
                    
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                } else if (currentStepWidth == 0) {</span>
                    
<span class="nc" id="L1998">                    return new int[]{(stepStart - 1), 0};</span>
                }
            }
        }
        
<span class="nc" id="L2003">        return new int[]{(i - 1), 0};</span>
    }

     /**
      * write the set difference of the given set of ranges, indexRanges,
      * to create the set of ranges not included in indexRanges.  Note the
      * large universe that both are subsets of is curve.
      */
     private PairIntArray writeRangesNotAlreadyIncluded(PairIntArray curve,
        PairIntArray indexRanges) {

<span class="fc" id="L2014">        PairIntArray output = new PairIntArray();</span>

<span class="fc" id="L2016">        int n = curve.getN();</span>

<span class="fc bfc" id="L2018" title="All 2 branches covered.">        if (indexRanges.getN() == 0) {</span>
<span class="fc" id="L2019">            output.add(0, n - 1);</span>
        } else {
<span class="fc" id="L2021">            int idx0 = indexRanges.getX(0);</span>
<span class="fc bfc" id="L2022" title="All 2 branches covered.">            if (idx0 &gt; 0) {</span>
<span class="fc" id="L2023">                output.add(0, idx0 - 1);</span>
            }
<span class="fc bfc" id="L2025" title="All 2 branches covered.">            for (int si = 1; si &lt; indexRanges.getN(); si++) {</span>
<span class="fc" id="L2026">                output.add(indexRanges.getY(si - 1), indexRanges.getX(si));</span>
            }
<span class="fc" id="L2028">            output.add(indexRanges.getY(indexRanges.getN() - 1), </span>
<span class="fc" id="L2029">                curve.getN() - 1);</span>
        }
        
<span class="fc" id="L2032">        return output;</span>
     }
     
     /**
      * in the curve points that are not within the staircaseSegmentRanges,
      * look for the single pixel ledge in a long stretch of a line and store 
      * the entire range.  There may be more than one single pixel range 
      * within a range.  a range is stored in the return array as a
      * point (x,y) = (start of range, stop of range inclusive).
      * @param curve
      * @param staircaseSegmentRanges
      * @return 
      */
    PairIntArray findLedgesInCurve(PairIntArray curve) {
        
        /*
        looking for long stretch of line that changes by 1 pixel and then
        continues in a long line
        */
         
<span class="fc" id="L2052">        PairIntArray allLedges = new PairIntArray();</span>
        
<span class="fc" id="L2054">        findLedgesWithinRange(curve, 0, curve.getN() - 1, allLedges);</span>
       
<span class="fc" id="L2056">        return allLedges;</span>
    }
    
    /**
     * find any ledges within the range start to stop, inclusive and return
     * them as indexes of the curve.  For example, a ledge extending from
     * point 10 to point 30 inclusive is in a pair in allLedges 
     * as (x,y) = (10, 30);
     * @param curve set of x,y points which comprise a curve
     * @param start first index of curve to search, inclusive
     * @param stop last index of curve to search, inclusive
     * @param allLedges the set of ranges to add the results of this too.
     * It's the output for the method.
     */
    private void findLedgesWithinRange(PairIntArray curve, int start, int stop, 
        PairIntArray allLedges) {
                
<span class="fc bfc" id="L2073" title="All 2 branches covered.">        if ((stop - start + 1) &lt; (2*minLedgeWidth)) {</span>
<span class="fc" id="L2074">            return;</span>
        }
        
        // similar o findJaggedLineStaircaseSegments, but with a step size of
        // &quot;1&quot;
        
<span class="fc" id="L2080">        int dx = 0;</span>
<span class="fc" id="L2081">        int dy = 0;</span>
<span class="fc" id="L2082">        int i = start;</span>
<span class="fc" id="L2083">        Boolean runIsAlongX = null;</span>
        // looking for straight lines of x or y
<span class="pc bpc" id="L2085" title="1 of 8 branches missed.">        while (!((dx == 0) &amp;&amp; (dy != 0)) &amp;&amp; !((dy == 0) &amp;&amp; (dx != 0))) {</span>
<span class="fc" id="L2086">            i++;</span>
<span class="pc bpc" id="L2087" title="1 of 2 branches missed.">            if (i &gt; (stop - 1)) {</span>
<span class="nc" id="L2088">                return;</span>
            }
<span class="fc" id="L2090">            dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L2091">            dy = (curve.getY(i) - curve.getY(i - 1));</span>
        }

<span class="fc bfc" id="L2094" title="All 2 branches covered.">        if (dx == 0) {</span>
<span class="fc" id="L2095">            runIsAlongX = Boolean.FALSE;</span>
<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">        } else if (dy == 0) {</span>
<span class="fc" id="L2097">            runIsAlongX = Boolean.TRUE;</span>
        }
        
<span class="fc" id="L2100">        int tmpI = i;</span>
        
        // back track to find where the current linestart
        // should be between start and i
<span class="pc bpc" id="L2104" title="1 of 2 branches missed.">        for (int j = (i - 1); j &gt;= (start + 1); j--) {</span>
<span class="nc" id="L2105">            int diffX = (curve.getX(j) - curve.getX(j - 1));</span>
<span class="nc" id="L2106">            int diffY = (curve.getY(j) - curve.getY(j - 1));</span>
<span class="nc bnc" id="L2107" title="All 4 branches missed.">            if ((diffY != dy) || (diffX != dx)) {</span>
<span class="nc" id="L2108">                i = j;</span>
            }
        }

<span class="fc" id="L2112">        int lineStart = i;</span>
                            
<span class="fc" id="L2114">        PairIntArray tmp = new PairIntArray();</span>
<span class="fc" id="L2115">        Boolean tmpRunIsAlongX = null;</span>
<span class="fc" id="L2116">        int tmpDX = -1;</span>
<span class="fc" id="L2117">        int tmpDY = -1;</span>
        
<span class="fc bfc" id="L2119" title="All 2 branches covered.">        for (i = (lineStart + 1); i &lt;= stop; i++) {</span>
           
<span class="fc" id="L2121">            int x = curve.getX(i);</span>
<span class="fc" id="L2122">            int y = curve.getY(i);</span>
            
<span class="fc" id="L2124">            int diffX = (x - curve.getX(i - 1));</span>

<span class="fc" id="L2126">            int diffY = (y - curve.getY(i - 1));</span>

            /* if there's a break in the line:
                  temporarily store the section so far.
            
                  if the next segment is consecutive and has same runIsAlongX
                  and same diffX and diffY,
                      continue with same tmp storage, 
                  else {
                     inspect storage and add to allLedges if looks like a ledge, 
                     then clear the tmp storage and the last vars&quot;
                  }
            */
            
<span class="fc bfc" id="L2140" title="All 4 branches covered.">            boolean runStopped = (runIsAlongX &amp;&amp; (diffY != 0)) ||</span>
<span class="fc bfc" id="L2141" title="All 4 branches covered.">                (!runIsAlongX &amp;&amp; (diffX != 0));</span>
            
<span class="pc bpc" id="L2143" title="1 of 4 branches missed.">            if ((i == stop) ||</span>
                runStopped ||
<span class="pc bpc" id="L2145" title="1 of 4 branches missed.">                (runIsAlongX &amp;&amp; (diffX != dx)) ||</span>
<span class="pc bpc" id="L2146" title="1 of 4 branches missed.">                (!runIsAlongX &amp;&amp; (diffY != dy)) ) {</span>

<span class="fc" id="L2148">                int rs = i - lineStart;</span>
                
<span class="fc bfc" id="L2150" title="All 2 branches covered.">                if (rs &gt;= minLedgeWidth) {</span>
<span class="pc bpc" id="L2151" title="1 of 2 branches missed.">                    if (i == stop) {</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">                        if (runStopped) {</span>
<span class="nc" id="L2153">                            tmp.add(lineStart, i - 1);</span>
                        } else {
<span class="nc" id="L2155">                            tmp.add(lineStart, i);</span>
                        }
                    } else {
<span class="fc" id="L2158">                        tmp.add(lineStart, i - 1);</span>
                    }
<span class="fc" id="L2160">                    tmpRunIsAlongX = runIsAlongX;</span>
<span class="fc" id="L2161">                    tmpDX = dx;</span>
<span class="fc" id="L2162">                    tmpDY = dy;</span>
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">                } else if ((i == (curve.getN() - 1)) /*&amp;&amp; (tmp.getN() &gt; 0) &amp;&amp;</span>
                    (Math.abs(lineStart - tmp.getY(tmp.getN() - 1)) &lt; 2)*/) {
<span class="nc" id="L2165">                    tmp.add(lineStart, i);</span>
<span class="fc bfc" id="L2166" title="All 2 branches covered.">                } else if (tmp.getN() == 1) {</span>
<span class="fc" id="L2167">                    allLedges.add(tmp.getX(0), tmp.getY(0));</span>
<span class="fc" id="L2168">                    tmp = new PairIntArray();</span>
                }

<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">                if (i != stop) {</span>
                    // find the next line segment
<span class="fc" id="L2173">                    dx = 0;</span>
<span class="fc" id="L2174">                    dy = 0;</span>
<span class="fc" id="L2175">                    runIsAlongX = null;</span>
                    // looking for straight lines of x or y
<span class="fc" id="L2177">                    tmpI = i;</span>
<span class="fc bfc" id="L2178" title="All 8 branches covered.">                    while (!((dx == 0) &amp;&amp; (dy != 0)) &amp;&amp;</span>
                        !((dy == 0) &amp;&amp; (dx != 0))) {
<span class="fc" id="L2180">                        i++;</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">                        if (i &gt;= stop) {</span>
<span class="fc" id="L2182">                            break;</span>
                        }
<span class="fc" id="L2184">                        dx = (curve.getX(i) - curve.getX(i - 1));</span>
<span class="fc" id="L2185">                        dy = (curve.getY(i) - curve.getY(i - 1));</span>
                    }

<span class="fc bfc" id="L2188" title="All 2 branches covered.">                    if (i &lt; stop) {</span>
<span class="fc bfc" id="L2189" title="All 2 branches covered.">                        if (dx == 0) {</span>
<span class="fc" id="L2190">                            runIsAlongX = Boolean.FALSE;</span>
<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">                        } else if (dy == 0) {</span>
<span class="fc" id="L2192">                            runIsAlongX = Boolean.TRUE;</span>
                        }

                        // back track to find where the current linestart
                        // should be between tmpI and i
<span class="fc bfc" id="L2197" title="All 2 branches covered.">                        for (int j = (i - 1); j &gt;= tmpI; j--) {</span>
<span class="fc" id="L2198">                            diffX = (curve.getX(j) - curve.getX(j - 1));</span>
<span class="fc" id="L2199">                            diffY = (curve.getY(j) - curve.getY(j - 1));</span>
<span class="pc bpc" id="L2200" title="1 of 4 branches missed.">                            if ((diffY != dy) || (diffX != dx)) {</span>
<span class="fc" id="L2201">                                i = j;</span>
                            }
                        }
                        
<span class="fc" id="L2205">                        lineStart = i;</span>
                    }
                }
                
<span class="fc" id="L2209">                int tmpN = tmp.getN();</span>
                     
                // if this is not consecutive segment, 
                // decide whether to store, then reset tmp
<span class="fc bfc" id="L2213" title="All 2 branches covered.">                if ((i &gt;= stop) || (</span>
<span class="fc bfc" id="L2214" title="All 2 branches covered.">                    (tmp.getN() &gt; 0) &amp;&amp;</span>
                    !(
<span class="pc bpc" id="L2216" title="1 of 6 branches missed.">                        (runIsAlongX.compareTo(tmpRunIsAlongX) == 0)</span>
                        &amp;&amp; (dx == tmpDX) &amp;&amp; (tmpDY == dy)
<span class="fc bfc" id="L2218" title="All 2 branches covered.">                        &amp;&amp; ((lineStart - (tmp.getY(tmpN - 1)) &lt; 3))</span>
                    )
                    )
                    ) {
                    
<span class="fc bfc" id="L2223" title="All 4 branches covered.">                    if (tmp.getN() &gt; 1 || ((tmp.getN() &gt; 0) </span>
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">                        &amp;&amp; (i == (curve.getN() - 1)))) {</span>
                        
                        // need to avoid removing a partial corner
                      
<span class="fc" id="L2228">                        boolean keep = true;</span>
                        
                        // check that the lines are not wrapping around a curve
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">                        if (tmp.getN() &gt; 1) {</span>
<span class="fc" id="L2232">                            int idx0f = tmp.getX(0);</span>
<span class="fc" id="L2233">                            int idx0l = tmp.getY(0);</span>
<span class="fc" id="L2234">                            double theta0 = calcTheta(curve, idx0f, idx0l);</span>
                            
<span class="fc bfc" id="L2236" title="All 2 branches covered.">                            for (int j = 1; j &lt; tmp.getN(); j++) {</span>
<span class="fc" id="L2237">                                idx0f = tmp.getX(j);</span>
<span class="fc" id="L2238">                                idx0l = tmp.getY(j);</span>
<span class="fc" id="L2239">                                double theta1 = calcTheta(curve, idx0f, idx0l);</span>
                                
                                // don't add corners
<span class="fc" id="L2242">                                double diff = Math.abs(theta0 - theta1);</span>
<span class="pc bpc" id="L2243" title="1 of 2 branches missed.">                                if (diff &gt; Math.PI/4.) {</span>
<span class="nc" id="L2244">                                    keep = false;</span>
<span class="nc" id="L2245">                                    break;</span>
                                }
<span class="fc" id="L2247">                                theta0 = theta1;</span>
                            }
                        }
                        
<span class="pc bpc" id="L2251" title="1 of 2 branches missed.">                        if (keep) {</span>
<span class="fc" id="L2252">                            allLedges.add(tmp.getX(0), tmp.getY(tmp.getN() - 1));</span>
                        }
                        
<span class="fc" id="L2255">                        tmp = new PairIntArray();</span>
                    } 
                }            
            }
        }
<span class="fc" id="L2260">    }</span>
   
    public void sortByX(PairIntArray curve) {
<span class="fc bfc" id="L2263" title="All 2 branches covered.">        if (curve.getN() &lt; 2) {</span>
<span class="fc" id="L2264">            return;</span>
        }
<span class="fc" id="L2266">        sortByX(curve, 0, curve.getN() - 1);</span>
<span class="fc" id="L2267">    }</span>
    
    private void sortByX(PairIntArray curve, int idxLo, int idxHi) {
<span class="fc bfc" id="L2270" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2271">            int idxMid = partitionByX(curve, idxLo, idxHi);</span>
<span class="fc" id="L2272">            sortByX(curve, idxLo, idxMid - 1);</span>
<span class="fc" id="L2273">            sortByX(curve, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2275">    }</span>

    private int partitionByX(PairIntArray curve, int idxLo, int idxHi) {
        
<span class="fc" id="L2279">        int x = curve.getX(idxHi);  //for comparison</span>
<span class="fc" id="L2280">        int store = idxLo - 1;      //store to swap after pivot</span>
        
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L2283" title="All 2 branches covered.">            if (curve.getX(i) &lt;= x) {</span>
<span class="fc" id="L2284">                store++;</span>
<span class="fc" id="L2285">                int swapX = curve.getX(store);</span>
<span class="fc" id="L2286">                int swapY = curve.getY(store);</span>
<span class="fc" id="L2287">                curve.set(store, curve.getX(i), curve.getY(i));</span>
<span class="fc" id="L2288">                curve.set(i, swapX, swapY);</span>
            }
        }
<span class="fc" id="L2291">        store++;</span>
        
<span class="fc" id="L2293">        int swapX = curve.getX(store);</span>
<span class="fc" id="L2294">        int swapY = curve.getY(store);</span>
<span class="fc" id="L2295">        curve.set(store, curve.getX(idxHi), curve.getY(idxHi));</span>
<span class="fc" id="L2296">        curve.set(idxHi, swapX, swapY);</span>
        
<span class="fc" id="L2298">        return store;</span>
    }

    private double calcTheta(PairIntArray curve, int idx0, int idx1) {
        
<span class="fc" id="L2303">        int x10 = curve.getX(idx1) - curve.getX(idx0);</span>
<span class="fc" id="L2304">        int y10 = curve.getY(idx1) - curve.getY(idx0);</span>
        double theta;
<span class="fc bfc" id="L2306" title="All 2 branches covered.">        if (x10 == 0) {</span>
<span class="fc bfc" id="L2307" title="All 2 branches covered.">            theta = (y10 &lt; 0) ? 1.5 * Math.PI : 0.5 * Math.PI;</span>
        } else {
<span class="fc" id="L2309">            theta = Math.atan((double) y10 / (double) x10);</span>
        }
        
<span class="fc" id="L2312">        return theta;</span>
    }

    /**
     * calculate centroid and then search nearby for the first closest
     * point in points.  the result approximates a sort by x and y and
       the returned values are actually present in points which is
       not guaranteed for calculateXYCentroids alone.
       * If that fails, it sorts all of points by y then x for the same
       * y and returns the median value present.
     * @param points
     * @return 
     */
    public double[] calculateXYMedian(PairIntArray points) {
        
<span class="nc" id="L2327">        Set&lt;PairInt&gt; points2 = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">        for (int i = 0; i &lt; points.getN(); i++) {</span>
<span class="nc" id="L2329">            int x = points.getX(i);</span>
<span class="nc" id="L2330">            int y = points.getY(i);</span>
<span class="nc" id="L2331">            PairInt p = new PairInt(x, y);</span>
<span class="nc" id="L2332">            points2.add(p);</span>
        }
        
<span class="nc" id="L2335">        double[] cen = calculateXYCentroids(points);</span>
        
<span class="nc" id="L2337">        int xc = (int)Math.round(cen[0]);</span>
<span class="nc" id="L2338">        int yc = (int)Math.round(cen[1]);</span>
        
<span class="nc" id="L2340">        int xMin = MiscMath.findMin(points.getX());</span>
<span class="nc" id="L2341">        int xMax = MiscMath.findMax(points.getX());</span>
<span class="nc" id="L2342">        int dXEnd = (xMax - xc);</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        if ((xc - xMin) &lt; dXEnd) {</span>
<span class="nc" id="L2344">            dXEnd = (xc - xMin);</span>
        }
<span class="nc" id="L2346">        int yMin = MiscMath.findMin(points.getY());</span>
<span class="nc" id="L2347">        int yMax = MiscMath.findMax(points.getY());</span>
<span class="nc" id="L2348">        int dYEnd = (yMax - yc);</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">        if ((yc - yMin) &lt; dYEnd) {</span>
<span class="nc" id="L2350">            dYEnd = (yc - yMin);</span>
        }
        
<span class="nc" id="L2353">        int[] signs = new int[]{-1, 1};</span>
        
<span class="nc bnc" id="L2355" title="All 2 branches missed.">        for (int dx = 0; dx &lt;= dXEnd; dx++) {</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">            for (int dy = 0; dy &lt;= dYEnd; dy++) {</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">                for (int fx : signs) {</span>
<span class="nc" id="L2358">                    dx *= fx;</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">                    for (int fy : signs) {</span>
<span class="nc" id="L2360">                        dy *= fy;</span>
                    }
                }
                
<span class="nc" id="L2364">                int x = xc + dx;</span>
<span class="nc" id="L2365">                int y = yc + dx;</span>
                
<span class="nc" id="L2367">                PairInt p = new PairInt(x, y);</span>
                
<span class="nc bnc" id="L2369" title="All 2 branches missed.">                if (points2.contains(p)) {</span>
<span class="nc" id="L2370">                    return new double[]{x, y};</span>
                }
            }
        }
        
<span class="nc" id="L2375">        log.warning(&quot;should not reach here.  should have found a point within &quot;</span>
            + &quot; range of values&quot;);
        
<span class="nc" id="L2378">        PairIntArray points3 = points.copy();</span>
        
<span class="nc" id="L2380">        MultiArrayMergeSort.sortByYThenX(points3);</span>
        
<span class="nc" id="L2382">        int idx = points3.getN()/2;</span>
        
<span class="nc" id="L2384">        return new double[]{points3.getX(idx), points3.getY(idx)};</span>
    }

    public PairInt[] findClosestPair(Set&lt;PairInt&gt; set0, Set&lt;PairInt&gt; set1) {
        
<span class="nc bnc" id="L2389" title="All 2 branches missed.">        if (set0 == null) {</span>
<span class="nc" id="L2390">            throw new IllegalArgumentException(&quot;set0 cannot be null&quot;);</span>
        }
        
<span class="nc bnc" id="L2393" title="All 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L2394">            throw new IllegalArgumentException(&quot;set1 cannot be null&quot;);</span>
        }
        
<span class="nc bnc" id="L2397" title="All 2 branches missed.">        if (set0.isEmpty()) {</span>
<span class="nc" id="L2398">            throw new IllegalArgumentException(&quot;set0 cannot be empty&quot;);</span>
        }
        
<span class="nc bnc" id="L2401" title="All 2 branches missed.">        if (set1.isEmpty()) {</span>
<span class="nc" id="L2402">            throw new IllegalArgumentException(&quot;set1 cannot be empty&quot;);</span>
        }
        
        //TODO: consider other algorithms besides brute force
    
<span class="nc" id="L2407">        double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2408">        PairInt p0 = null;</span>
<span class="nc" id="L2409">        PairInt p1 = null;</span>
        
<span class="nc bnc" id="L2411" title="All 2 branches missed.">        for (PairInt s0 : set0) {</span>
            
<span class="nc" id="L2413">            double x = s0.getX();</span>
<span class="nc" id="L2414">            double y = s0.getY();</span>
            
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            for (PairInt s1 : set1) {</span>
                
<span class="nc" id="L2418">                double x1 = s1.getX();</span>
<span class="nc" id="L2419">                double y1 = s1.getY();</span>
                
<span class="nc" id="L2421">                double diffX = x1 - x;</span>
<span class="nc" id="L2422">                double diffY = y1 - y;</span>
                
<span class="nc" id="L2424">                double distSq = (diffX * diffX) + (diffY * diffY);</span>
                
<span class="nc bnc" id="L2426" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L2427">                    minDistSq = distSq;</span>
<span class="nc" id="L2428">                    p0 = s0;</span>
<span class="nc" id="L2429">                    p1 = s1;</span>
                }
<span class="nc" id="L2431">            }</span>
<span class="nc" id="L2432">        }</span>
        
<span class="nc" id="L2434">        return new PairInt[]{p0, p1};</span>
    }
    
    public void populateGapsWithInterpolation(Set&lt;PairInt&gt; points) {
        
        // probably many ways to do this... ordered point algorithm?
        // dfs to find connected groups, then connect the closest among those?
        
<span class="nc" id="L2442">        int[] minMaxXY = MiscMath.findMinMaxXY(points);</span>
        
<span class="nc" id="L2444">        DFSConnectedGroupsFinder finder = new DFSConnectedGroupsFinder();</span>
<span class="nc" id="L2445">        finder.setMinimumNumberInCluster(1);</span>
<span class="nc" id="L2446">        finder.findConnectedPointGroups(points, minMaxXY[1] + 1, minMaxXY[3] + 1);</span>
        
<span class="nc" id="L2448">        int nIter = 0;</span>
<span class="nc" id="L2449">        int nMaxIter = 10;</span>
        
<span class="nc" id="L2451">        int nGroups = finder.getNumberOfGroups();</span>
        
<span class="nc bnc" id="L2453" title="All 4 branches missed.">        while ((nGroups &gt; 1) &amp;&amp; (nIter &lt; nMaxIter)) {</span>
            
            // find the closest pair of points between any 2 groups
                        
<span class="nc" id="L2457">            double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L2458">            PairInt minDistPoint0 = null;</span>
<span class="nc" id="L2459">            PairInt minDistPoint1 = null;</span>
<span class="nc" id="L2460">            int minDistGroupId0 = -1;</span>
<span class="nc" id="L2461">            int minDistGroupId1 = -1;</span>
                        
<span class="nc bnc" id="L2463" title="All 2 branches missed.">            for (int g0Idx = 0; g0Idx &lt; nGroups; g0Idx++) {</span>
                
<span class="nc" id="L2465">                Set&lt;PairInt&gt; g0 = finder.getXY(g0Idx);</span>
                
<span class="nc bnc" id="L2467" title="All 2 branches missed.">                for (int g1Idx = 0; g1Idx &lt; nGroups; g1Idx++) {</span>
                    
<span class="nc bnc" id="L2469" title="All 2 branches missed.">                    if (g0Idx == g1Idx) {</span>
<span class="nc" id="L2470">                        continue;</span>
                    }
                    
<span class="nc" id="L2473">                    Set&lt;PairInt&gt; g1 = finder.getXY(g1Idx);</span>
                    
<span class="nc" id="L2475">                    PairInt[] closestPair = findClosestPair(g0, g1);</span>
                    
<span class="nc bnc" id="L2477" title="All 2 branches missed.">                    if (closestPair == null) {</span>
<span class="nc" id="L2478">                        continue;</span>
                    }
                    
<span class="nc" id="L2481">                    double x0 = closestPair[0].getX();</span>
<span class="nc" id="L2482">                    double y0 = closestPair[0].getY();</span>

<span class="nc" id="L2484">                    double x1 = closestPair[1].getX();</span>
<span class="nc" id="L2485">                    double y1 = closestPair[1].getY();</span>
                    
<span class="nc" id="L2487">                    double diffX = x1 - x0;</span>
<span class="nc" id="L2488">                    double diffY = y1 - y0;</span>
                    
<span class="nc" id="L2490">                    double distSq = (diffX * diffX) + (diffY * diffY);</span>
                    
<span class="nc bnc" id="L2492" title="All 2 branches missed.">                    if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L2493">                        minDistSq = distSq;</span>
<span class="nc" id="L2494">                        minDistPoint0 = closestPair[0];</span>
<span class="nc" id="L2495">                        minDistPoint1 = closestPair[1];</span>
<span class="nc" id="L2496">                        minDistGroupId0 = g0Idx;</span>
<span class="nc" id="L2497">                        minDistGroupId1 = g1Idx;</span>
                    }
                }
            }
            
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            if (minDistPoint0 != null) {</span>
                
<span class="nc" id="L2504">                double x1 = minDistPoint1.getX();</span>
<span class="nc" id="L2505">                double y1 = minDistPoint1.getY();</span>
                
<span class="nc" id="L2507">                double dxDivDy = (minDistPoint0.getX() - x1)/</span>
<span class="nc" id="L2508">                    (minDistPoint0.getY() - y1);</span>
                
                /*
                x0 - x1
                ------- = dxDivDy
                y0 - y1
                
                x0 - x1 = (y0 - y1) * dyDivDx;
                x0 = x1 + (y0 - y1) * dyDivDx;
                */
                int startY, stopY;
<span class="nc bnc" id="L2519" title="All 2 branches missed.">                if (minDistPoint0.getY() &lt; minDistPoint1.getY()) {</span>
<span class="nc" id="L2520">                    startY = minDistPoint0.getY();</span>
<span class="nc" id="L2521">                    stopY = minDistPoint1.getY();</span>
                } else {
<span class="nc" id="L2523">                    startY = minDistPoint1.getY();</span>
<span class="nc" id="L2524">                    stopY = minDistPoint0.getY();</span>
                }
                
<span class="nc bnc" id="L2527" title="All 2 branches missed.">                for (int y = startY; y &lt;= stopY; y++) {</span>
                    
<span class="nc" id="L2529">                    int x = (int)Math.round(x1 + (y - y1) * dxDivDy);</span>
                    
<span class="nc" id="L2531">                    PairInt p = new PairInt(x, y);</span>
                    
<span class="nc" id="L2533">                    boolean added = points.add(p);                    </span>
                }
                
                /*
                y0 - y1
                ------- = dyDivDx
                x0 - x1
                
                y0 - y1 = (x0 - x1) * dxDivDy;
                y0 = y1 + (x0 - x1) * dxDivDy;
                */
<span class="nc" id="L2544">                double dyDivDx = (minDistPoint0.getY() - y1)/</span>
<span class="nc" id="L2545">                    (minDistPoint0.getX() - x1);</span>
                
                int startX, stopX;
<span class="nc bnc" id="L2548" title="All 2 branches missed.">                if (minDistPoint0.getX() &lt; minDistPoint1.getX()) {</span>
<span class="nc" id="L2549">                    startX = minDistPoint0.getX();</span>
<span class="nc" id="L2550">                    stopX = minDistPoint1.getX();</span>
                } else {
<span class="nc" id="L2552">                    startX = minDistPoint1.getX();</span>
<span class="nc" id="L2553">                    stopX = minDistPoint0.getX();</span>
                }
                
<span class="nc bnc" id="L2556" title="All 2 branches missed.">                for (int x = startX; x &lt;= stopX; x++) {</span>
                    
<span class="nc" id="L2558">                    int y = (int)Math.round(y1 + (x - x1) * dyDivDx);</span>
                    
<span class="nc" id="L2560">                    PairInt p = new PairInt(x, y);</span>
                    
<span class="nc" id="L2562">                    boolean added = points.add(p);     </span>
                }
            }
        
<span class="nc" id="L2566">            finder = new DFSConnectedGroupsFinder();</span>
<span class="nc" id="L2567">            finder.setMinimumNumberInCluster(1);</span>
<span class="nc" id="L2568">            finder.findConnectedPointGroups(points, minMaxXY[1] + 1, minMaxXY[3] + 1);</span>

<span class="nc" id="L2570">            nGroups = finder.getNumberOfGroups();</span>
            
<span class="nc" id="L2572">            nIter++;</span>
<span class="nc" id="L2573">        }</span>
<span class="nc" id="L2574">    }</span>
    
    public void pruneSpurs(List&lt;PairIntArray&gt; tmpEdges, int imageWidth,
        int imageHeight) {
        
        //TODO: improve this to follow a spur when found and remove the
        //  resulting spurs from the remove action
        
<span class="nc" id="L2582">        int nIter = 0;</span>
<span class="nc" id="L2583">        int nMaxIter = 3;</span>
<span class="nc" id="L2584">        int nRemoved = 0;</span>
                
<span class="nc bnc" id="L2586" title="All 2 branches missed.">        while (nIter &lt; nMaxIter) {</span>
            
<span class="nc" id="L2588">            nRemoved = 0;</span>
            
            /*
            0 0 0    0 0 0
            0 1 0    0 1 0
            0 _ _    _ _ 0
            */
            // indexes that have to be zeros that is, not within an edge
<span class="nc" id="L2596">            int[] topXIdx = new int[]{-1, 0, 1, -1, 1};</span>
<span class="nc" id="L2597">            int[] topYIdx = new int[]{ 1, 1, 1,  0, 0};</span>
<span class="nc" id="L2598">            int[] leftXIdx = new int[]{-1};</span>
<span class="nc" id="L2599">            int[] leftYIdx = new int[]{-1};</span>
<span class="nc" id="L2600">            int[] rightXIdx = new int[]{1};</span>
<span class="nc" id="L2601">            int[] rightYIdx = new int[]{-1};</span>
            // one must be a zero:
<span class="nc" id="L2603">            int[] leftOrZeroXIdx = new int[]{0, 1};</span>
<span class="nc" id="L2604">            int[] leftOrZeroYIdx = new int[]{-1, -1};</span>
<span class="nc" id="L2605">            int[] rightOrZeroXIdx = new int[]{-1, 0};</span>
<span class="nc" id="L2606">            int[] rightOrZeroYIdx = new int[]{-1, -1};</span>
        
<span class="nc bnc" id="L2608" title="All 2 branches missed.">            for (int r = 0; r &lt; 4; r++) {</span>
<span class="nc bnc" id="L2609" title="All 2 branches missed.">                if (r &gt; 0) {</span>
<span class="nc" id="L2610">                    rotateIndexesBy90(topXIdx, topYIdx);</span>
<span class="nc" id="L2611">                    rotateIndexesBy90(leftXIdx, leftYIdx);</span>
<span class="nc" id="L2612">                    rotateIndexesBy90(rightXIdx, rightYIdx);</span>
<span class="nc" id="L2613">                    rotateIndexesBy90(leftOrZeroXIdx, leftOrZeroYIdx);</span>
<span class="nc" id="L2614">                    rotateIndexesBy90(rightOrZeroXIdx, rightOrZeroYIdx);</span>
                }
<span class="nc bnc" id="L2616" title="All 2 branches missed.">                for (int i = 0; i &lt; tmpEdges.size(); i++) {</span>
                    
<span class="nc" id="L2618">                    PairIntArray edge = tmpEdges.get(i);</span>
                    
                    // skip the endpoints
<span class="nc bnc" id="L2621" title="All 2 branches missed.">                    for (int j = (edge.getN() - 1); j &gt; 0; j--) {</span>
                        
<span class="nc bnc" id="L2623" title="All 4 branches missed.">                        if ((j &lt; 0) || (j &gt; (edge.getN() - 1))) {break;}</span>
                        
<span class="nc" id="L2625">                        int x = edge.getX(j);</span>
<span class="nc" id="L2626">                        int y = edge.getY(j);</span>
                        
                        // TODO: consider a smaller range to search than +-10
<span class="nc" id="L2629">                        int start = j - 10;</span>
<span class="nc bnc" id="L2630" title="All 2 branches missed.">                        if (start &lt; 0) {</span>
<span class="nc" id="L2631">                            continue;</span>
                        }
<span class="nc" id="L2633">                        int stop = j + 10;</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">                        if (stop &gt; (edge.getN() - 1)) {</span>
<span class="nc" id="L2635">                            continue;</span>
                        }
                        // &quot;notFound&quot; is &quot;all are zeroes&quot;
<span class="nc" id="L2638">                        boolean notFound = notFound(edge, topXIdx, topYIdx, x, y, </span>
                            start, stop);
<span class="nc bnc" id="L2640" title="All 2 branches missed.">                        if (notFound) {</span>
<span class="nc" id="L2641">                            notFound = notFound(edge, leftXIdx, leftYIdx, x, y, </span>
                                start, stop);
<span class="nc bnc" id="L2643" title="All 2 branches missed.">                            if (notFound) {</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">                                if (hasAtLeastOneZero(edge, leftOrZeroXIdx,</span>
                                    leftOrZeroYIdx, x, y, start, stop, 
                                    imageWidth, imageHeight)) {
                                    
<span class="nc" id="L2648">                                    edge.removeRange(j, j);</span>
<span class="nc" id="L2649">                                    nRemoved++;</span>
                                }
                            } else {
<span class="nc" id="L2652">                                notFound = notFound(edge, rightXIdx, rightYIdx, x, y, </span>
                                    start, stop);
<span class="nc bnc" id="L2654" title="All 2 branches missed.">                                if (notFound) {</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                                    if (hasAtLeastOneZero(edge, rightOrZeroXIdx,</span>
                                        rightOrZeroYIdx, x, y, start, stop,
                                        imageWidth, imageHeight)) {
                                        
<span class="nc" id="L2659">                                        edge.removeRange(j, j);</span>
<span class="nc" id="L2660">                                        nRemoved++;</span>
                                    }
                                }
                            }
                        }
                    }
                }
            }
<span class="nc" id="L2668">            log.info(&quot;nRemoved=&quot; + nRemoved);</span>
<span class="nc bnc" id="L2669" title="All 2 branches missed.">            if (nRemoved == 0) {</span>
<span class="nc" id="L2670">                break;</span>
            }
<span class="nc" id="L2672">            nIter++;</span>
<span class="nc" id="L2673">        }</span>
<span class="nc" id="L2674">    }</span>
    
    /**
     * edge contains point pairs of (x, y).  this method searches edge to assert
     * that all of the specified points are not present, else returns as soon
     * as one of the specified points is found.  
     * The specified points are 
     * (xIndex + xIndexOffsets[i], yIndex + yIndexOffsets[i]).
     * The search through edge is done from startIdx to stopIdx, inclusive.
     * @param edge
     * @param xIndexOffsets
     * @param yIndexOffsets
     * @param xIndex
     * @param yIndex
     * @param startIdx
     * @param stopIdx
     * @return 
     */
    private boolean notFound(PairIntArray edge, 
        int[] xIndexOffsets, int[] yIndexOffsets,
        int xIndex, int yIndex, int startIdx, int stopIdx) {
        
<span class="nc" id="L2696">StringBuilder sb2 = new StringBuilder();</span>
        
<span class="nc bnc" id="L2698" title="All 2 branches missed.">        for (int j = 0; j &lt; xIndexOffsets.length; j++) {</span>
<span class="nc" id="L2699">            int xFind = xIndex + xIndexOffsets[j];</span>
<span class="nc" id="L2700">            int yFind = yIndex + yIndexOffsets[j];</span>
<span class="nc" id="L2701">sb2.append(String.format(&quot;(%d, %d)\n&quot;, xFind, yFind));</span>
<span class="nc bnc" id="L2702" title="All 2 branches missed.">            for (int i = startIdx; i &lt;= stopIdx; i++) {</span>
<span class="nc" id="L2703">                int x = edge.getX(i);</span>
<span class="nc" id="L2704">                int y = edge.getY(i);</span>
<span class="nc bnc" id="L2705" title="All 4 branches missed.">                if ((x == xFind) &amp;&amp; (y == yFind)) {</span>
<span class="nc" id="L2706">                    return false;</span>
                }
            }
        }
        
<span class="nc" id="L2711">StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">for (int i = 0; i &lt; edge.getN(); i++) {</span>
<span class="nc" id="L2713">     int x = edge.getX(i);</span>
<span class="nc" id="L2714">     int y = edge.getY(i);</span>
<span class="nc" id="L2715">     sb.append(String.format(&quot;%d)  (%d, %d)\n&quot;, i, x, y));</span>
}
        
<span class="nc" id="L2718">        return true;</span>
    }
    
    /**
     * edge contains point pairs of (x, y).  this method searches edge to assert
     * that all of the specified points are not present, else returns as soon
     * as one of the specified points is found.  
     * The specified points are 
     * (xIndex + xIndexOffsets[i], yIndex + yIndexOffsets[i]).
     * The search through edge is done from startIdx to stopIdx, inclusive.
     * NOTE: also checks for whether nulling the pixel at (xP, yP) is 
     * connected to the wall and returns false if it is.
     * @param edge
     * @param xIndexOffsets
     * @param yIndexOffsets
     * @param xIndex
     * @param yIndex
     * @param startIdx
     * @param stopIdx
     * @return 
     */
    private boolean hasAtLeastOneZero(PairIntArray edge, 
        int[] xIndexOffsets, int[] yIndexOffsets,
        int xP, int yP, int startIdx, int stopIdx, int imageWidth, int imageHeight) {
        
        // side logic of checking whether connected to wall.  return false if so
<span class="nc bnc" id="L2744" title="All 4 branches missed.">        if ((xP == 0) || (yP == 0)) {</span>
<span class="nc" id="L2745">            return false;</span>
        }
<span class="nc bnc" id="L2747" title="All 4 branches missed.">        if ((xP == (imageWidth - 1)) || (yP == (imageHeight - 1))) {</span>
<span class="nc" id="L2748">            return false;</span>
        }
        
<span class="nc" id="L2751">        int nOnes = 0;</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">        for (int j = 0; j &lt; xIndexOffsets.length; j++) {</span>
<span class="nc" id="L2753">            int xFind = xP + xIndexOffsets[j];</span>
<span class="nc" id="L2754">            int yFind = yP + yIndexOffsets[j];</span>
<span class="nc bnc" id="L2755" title="All 2 branches missed.">            for (int i = startIdx; i &lt;= stopIdx; i++) {</span>
<span class="nc" id="L2756">                int x = edge.getX(i);</span>
<span class="nc" id="L2757">                int y = edge.getY(i);</span>
<span class="nc bnc" id="L2758" title="All 4 branches missed.">                if ((x == xFind) &amp;&amp; (y == yFind)) {</span>
<span class="nc" id="L2759">                    nOnes++;</span>
                }
            }
        }        
        
<span class="nc bnc" id="L2764" title="All 2 branches missed.">        return (nOnes &lt; (xIndexOffsets.length));</span>
    }
    
    private void rotateIndexesBy90(int[] xOffsetIndexes, int[] yOffsetIndexes) {
        
<span class="nc bnc" id="L2769" title="All 2 branches missed.">        for (int i = 0; i &lt; xOffsetIndexes.length; i++) {</span>
<span class="nc" id="L2770">            int xoff = xOffsetIndexes[i];</span>
<span class="nc" id="L2771">            int yoff = yOffsetIndexes[i];</span>
           
<span class="nc bnc" id="L2773" title="All 4 branches missed.">            switch(xoff) {</span>
                case -1:
<span class="nc bnc" id="L2775" title="All 4 branches missed.">                    switch (yoff) {</span>
                        case -1:
<span class="nc" id="L2777">                            xOffsetIndexes[i] = -1;</span>
<span class="nc" id="L2778">                            yOffsetIndexes[i] = 1;</span>
<span class="nc" id="L2779">                            break;</span>
                        case 0:
<span class="nc" id="L2781">                            xOffsetIndexes[i] = 0;</span>
<span class="nc" id="L2782">                            yOffsetIndexes[i] = 1;</span>
<span class="nc" id="L2783">                            break;</span>
                        case 1:
<span class="nc" id="L2785">                            xOffsetIndexes[i] = 1;</span>
<span class="nc" id="L2786">                            yOffsetIndexes[i] = 1;</span>
                            break;
                    }
<span class="nc" id="L2789">                    break;</span>
                case 0:
<span class="nc bnc" id="L2791" title="All 4 branches missed.">                    switch (yoff) {</span>
                        case -1:
<span class="nc" id="L2793">                            xOffsetIndexes[i] = -1;</span>
<span class="nc" id="L2794">                            yOffsetIndexes[i] = 0;</span>
<span class="nc" id="L2795">                            break;</span>
                        case 0:
                            // remains same
<span class="nc" id="L2798">                            break;</span>
                        case 1:
<span class="nc" id="L2800">                            xOffsetIndexes[i] = 1;</span>
<span class="nc" id="L2801">                            yOffsetIndexes[i] = 0;</span>
                            break;
                    }
<span class="nc" id="L2804">                    break;</span>
                case 1:
<span class="nc bnc" id="L2806" title="All 4 branches missed.">                    switch (yoff) {</span>
                        case -1:
<span class="nc" id="L2808">                            xOffsetIndexes[i] = -1;</span>
<span class="nc" id="L2809">                            yOffsetIndexes[i] = -1;</span>
<span class="nc" id="L2810">                            break;</span>
                        case 0:
<span class="nc" id="L2812">                            xOffsetIndexes[i] = 0;</span>
<span class="nc" id="L2813">                            yOffsetIndexes[i] = -1;</span>
<span class="nc" id="L2814">                            break;</span>
                        case 1:
<span class="nc" id="L2816">                            xOffsetIndexes[i] = 1;</span>
<span class="nc" id="L2817">                            yOffsetIndexes[i] = -1;</span>
                            break;
                    }
                    break;
            }
        }
        /*
        1 2 3    7 4 1  
        4 5 6      5 2  
        7 _ _      6 3 
        
        (-1,1)    (1,1)   0
        (0,1)     (1,0)   1
        (1,1)     (1,-1)  2
        (-1,0)    (0,1)   3
        (0,0)     (0,0)   4
        (1,0)     (0,-1)  5
        (-1,-1)   (-1,1)  6
        (0,-1)    (-1,0)  7
        (1,-1)    (-1,-1) 8
        */
<span class="nc" id="L2838">    }</span>
    
    public void straightenLines(Set&lt;PairInt&gt; points, 
        GreyscaleImage edgeGuideImage) {
        
<span class="nc bnc" id="L2843" title="All 2 branches missed.">        if (edgeGuideImage == null) {</span>
<span class="nc" id="L2844">            return;</span>
        }
        
        /*
        To move a pixel from one location to a better if possible
        means determining if the move does not break any line connections.
        Since the line widths have already been reduced to widths of '1',
        this should just be a matter of noting which points it is connected
        to and only choose points which are adjacent to the connected.
        
              V
              *                            V
           *     *  *  can be moved to  *  *  *  *
        
        The neighbors of p are p0 and p1 for example, so
        points which are within 1 pixel of p, p0, and p1 found as the centroid
        of them +- 1 pixel radius.
        
        Goal is to find if a point in points can be moved within a pixel's 
        distance, to a position which is closer to the brightest pixel in the 
        edgeGuideImage within range without breaking connections.
     
        For each point in points:
            -- find the adjacent points.
            -- determine a centroid for them and the point.
            -- iterate around the 8 neighboring pixels of point
               -- initialize maxIntensity w/ the current points's edgeGuideImage
                  intensity.
               -- if the pixel is further than 1 from the centroid, discard it,
                  else, compare the pixel's edgeGuideImage with maxIntensity and
                  keep if larger.
            -- if maxIntensityPoint is not null, move the current point to 
               it (by adding point to the remove list and adding the new location
               to the add list).
        */
        
<span class="nc" id="L2880">        int imageWidth = edgeGuideImage.getWidth();</span>
        
<span class="nc" id="L2882">        int imageHeight = edgeGuideImage.getHeight();</span>

<span class="nc" id="L2884">        double onePixDist = Math.sqrt(2);</span>
        
<span class="nc" id="L2886">        Set&lt;PairInt&gt; tmpPointsAdded = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L2887">        Set&lt;PairInt&gt; tmpPointsRemoved = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc" id="L2889">        Set&lt;PairInt&gt; outputNeighbors = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L2891" title="All 2 branches missed.">        for (PairInt p : points) {</span>
            
<span class="nc" id="L2893">            int x = p.getX();</span>
<span class="nc" id="L2894">            int y = p.getY();</span>
            
<span class="nc" id="L2896">            findNeighbors(x, y, outputNeighbors, points, </span>
                tmpPointsAdded, tmpPointsRemoved, imageWidth, imageHeight);
            
<span class="nc" id="L2899">            int nBrs = outputNeighbors.size();</span>
            
<span class="nc bnc" id="L2901" title="All 2 branches missed.">            if (nBrs == 0) {</span>
<span class="nc" id="L2902">                continue;</span>
            }
            
            // determine centroid
<span class="nc" id="L2906">            double xc = p.getX();</span>
<span class="nc" id="L2907">            double yc = p.getY();</span>
<span class="nc bnc" id="L2908" title="All 2 branches missed.">            for (PairInt p2 : outputNeighbors) {</span>
<span class="nc" id="L2909">                xc += p2.getX();</span>
<span class="nc" id="L2910">                yc += p2.getY();</span>
<span class="nc" id="L2911">            }</span>
<span class="nc" id="L2912">            xc /= (double)(nBrs + 1);</span>
<span class="nc" id="L2913">            yc /= (double)(nBrs + 1);</span>
            
            // find highest intensity neighbor within 1 pix of centroid
<span class="nc" id="L2916">            int maxIntensity = edgeGuideImage.getValue(x, y);</span>
<span class="nc" id="L2917">            PairInt maxIntensityPoint = null;</span>
            
<span class="nc bnc" id="L2919" title="All 2 branches missed.">            for (int i = 0; i &lt; eightNeighborsX.length; ++i) {</span>
<span class="nc" id="L2920">                int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L2921">                int y2 = y + eightNeighborsY[i];</span>
<span class="nc bnc" id="L2922" title="All 8 branches missed.">                if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) || </span>
                    (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2924">                    continue;</span>
                }
<span class="nc" id="L2926">                PairInt p2 = new PairInt(x2, y2);</span>
                // discard if it's already a point
<span class="nc bnc" id="L2928" title="All 4 branches missed.">                if (outputNeighbors.contains(p2) || tmpPointsAdded.contains(p2) </span>
<span class="nc bnc" id="L2929" title="All 2 branches missed.">                    || points.contains(p2)) {</span>
<span class="nc" id="L2930">                    continue;</span>
                }
                
                // this is a vacant pixel.
                
                // check that it is within 1 pixel of (xc, yc) 
<span class="nc" id="L2936">                double diffX = x2 - xc;</span>
<span class="nc" id="L2937">                double diffY = y2 - yc;</span>
<span class="nc" id="L2938">                double dist = Math.sqrt((diffX * diffX) + (diffY * diffY));</span>
                
<span class="nc bnc" id="L2940" title="All 2 branches missed.">                if (dist &lt;= (onePixDist/2.)) {</span>
<span class="nc" id="L2941">                    int v = edgeGuideImage.getValue(x2, y2);</span>
<span class="nc bnc" id="L2942" title="All 2 branches missed.">                    if (v &gt; maxIntensity) {</span>
<span class="nc" id="L2943">                        maxIntensity = v;</span>
<span class="nc" id="L2944">                        maxIntensityPoint = p2;</span>
                    }
                }
            }
<span class="nc bnc" id="L2948" title="All 2 branches missed.">            if (maxIntensityPoint != null) {</span>
                // &quot;change location&quot; of the point.
<span class="nc" id="L2950">                tmpPointsRemoved.add(p);</span>
<span class="nc" id="L2951">                tmpPointsRemoved.remove(maxIntensityPoint);</span>
<span class="nc" id="L2952">                tmpPointsAdded.add(maxIntensityPoint);</span>
            }
<span class="nc" id="L2954">        }</span>
        
<span class="nc" id="L2956">        int nCorrections = tmpPointsRemoved.size() + tmpPointsAdded.size();</span>
        
<span class="nc bnc" id="L2958" title="All 2 branches missed.">        for (PairInt p2 : tmpPointsRemoved) {</span>
<span class="nc" id="L2959">            points.remove(p2);</span>
<span class="nc" id="L2960">        }</span>
<span class="nc bnc" id="L2961" title="All 2 branches missed.">        for (PairInt p2 : tmpPointsAdded) {</span>
<span class="nc" id="L2962">            points.add(p2);</span>
<span class="nc" id="L2963">        }</span>
        
<span class="nc" id="L2965">        log.fine(&quot;method &quot; + MiscDebug.getInvokingMethodName() + &quot; nc=&quot; + </span>
<span class="nc" id="L2966">            Integer.toString(nCorrections));</span>
<span class="nc" id="L2967">    }</span>
    
    protected void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; tmpAddedPoints, 
        Set&lt;PairInt&gt; tmpRemovedPoints, int imageWidth, int imageHeight) {
        
<span class="fc" id="L2973">        outputNeighbors.clear();</span>
                
<span class="fc bfc" id="L2975" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>
            
<span class="fc" id="L2977">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L2978">            int y2 = y + eightNeighborsY[i];</span>
            
<span class="pc bpc" id="L2980" title="4 of 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) || </span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L2982">                continue;</span>
            }
            
<span class="fc" id="L2985">            PairInt p2 = new PairInt(x2, y2);</span>
            
<span class="fc bfc" id="L2987" title="All 2 branches covered.">            if (tmpRemovedPoints.contains(p2)) {</span>
<span class="fc" id="L2988">                continue;</span>
            }
<span class="pc bpc" id="L2990" title="1 of 4 branches missed.">            if (tmpAddedPoints.contains(p2) || points.contains(p2)) {</span>
<span class="fc" id="L2991">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L2994">    }</span>

    public List&lt;PairIntArray&gt; smoothAndReExtractEdges(List&lt;PairIntArray&gt; edges,
        GreyscaleImage gradientXY, int smoothingFactor) {
        
<span class="nc" id="L2999">        AverageUtil avgUtil = new AverageUtil();</span>
        
<span class="nc" id="L3001">        GreyscaleImage output = gradientXY.createWithDimensions();       </span>
        
<span class="nc bnc" id="L3003" title="All 2 branches missed.">        for (int i = 0; i &lt; edges.size(); ++i) {</span>
<span class="nc" id="L3004">            PairIntArray edge = edges.get(i);</span>
<span class="nc bnc" id="L3005" title="All 2 branches missed.">            if (edge.getN() &gt;= smoothingFactor) {</span>
<span class="nc" id="L3006">                edge = avgUtil.calculateBoxCarAverage(edges.get(i), smoothingFactor);</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">                for (int j = 0; j &lt; edge.getN(); ++j) {</span>
<span class="nc" id="L3008">                    output.setValue(edge.getX(j), edge.getY(j), 1);</span>
                }
            }
        }
        
<span class="nc" id="L3013">        PostLineThinnerCorrections pslt = new PostLineThinnerCorrections();</span>
<span class="nc" id="L3014">        pslt.correctForArtifacts(output);        </span>
<span class="nc" id="L3015">        IEdgeExtractor edgeExtractor = new EdgeExtractorWithJunctions(output);</span>
<span class="nc" id="L3016">        edgeExtractor.removeShorterEdges(true);</span>
<span class="nc" id="L3017">        edges = edgeExtractor.findEdges();     </span>
        
<span class="nc" id="L3019">        return edges;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MiscellaneousCurveHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">MiscellaneousCurveHelper.java</span></div><h1>MiscellaneousCurveHelper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.convexHull.GrahamScanPairInt;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.imageProcessing.scaleSpace.CurvatureScaleSpaceContour;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.PairIntWithIndex0;
import algorithms.util.PairIntArray;
import algorithms.util.PairFloatArray;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
<span class="fc" id="L25">public class MiscellaneousCurveHelper {</span>

<span class="fc" id="L27">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    // choosing a minimum size empirically from looking at edges in tests
<span class="fc" id="L30">    private static int minLedgeWidth = 4;</span>

<span class="fc" id="L32">    protected static final int[] eightNeighborsX =</span>
        new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
<span class="fc" id="L34">    protected static final int[] eightNeighborsY =</span>
        new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner 
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise(PairIntArray closedCurve) {

<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L54">            return false;</span>
        }

<span class="fc" id="L57">        int nNeg = 0;</span>
<span class="fc" id="L58">        int n = closedCurve.getN();</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

            long xm1, ym1, x, y, xp1, yp1;

<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L65">                xm1 = closedCurve.getX(closedCurve.getN() - 1);</span>
<span class="fc" id="L66">                ym1 = closedCurve.getY(closedCurve.getN() - 1);</span>
<span class="fc" id="L67">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L68">                yp1 = closedCurve.getY(i + 1);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            } else if (i == (closedCurve.getN() - 1)) {</span>
<span class="fc" id="L70">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L71">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L72">                xp1 = closedCurve.getX(0);</span>
<span class="fc" id="L73">                yp1 = closedCurve.getY(0);</span>
            } else {
<span class="fc" id="L75">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L76">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L77">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L78">                yp1 = closedCurve.getY(i + 1);</span>
            }
<span class="fc" id="L80">            x = closedCurve.getX(i);</span>
<span class="fc" id="L81">            y = closedCurve.getY(i);</span>

<span class="fc" id="L83">            long dxmxm1 = (x - xm1);</span>
<span class="fc" id="L84">            long dymym1 = (y - ym1);</span>
<span class="fc" id="L85">            long dxp1mx = (xp1 - x);</span>
<span class="fc" id="L86">            long dyp1my = (yp1 - y);</span>

            //(xi - xi-1) * (yi+1 - yi) - (yi - yi-1) * (xi+1 - xi)
<span class="fc" id="L89">            long crossProduct = (dxmxm1 * dyp1my) - (dymym1 * dxp1mx);</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">            if (crossProduct &lt; 0) {</span>
                // clockwise when crossProduct is negative
<span class="fc" id="L93">                nNeg++;</span>
            }
        }

<span class="fc" id="L97">        int nPos = n - nNeg;//n - 2 - nNeg;</span>

        //log.info(closedCurve.toString());
        //log.info(&quot;n=&quot; + n + &quot; nNegative=&quot; + nNeg + &quot; nPositive=&quot; + nPos);

<span class="pc bpc" id="L102" title="2 of 6 branches missed.">        return ((n &gt; 2) &amp;&amp; (nNeg &gt;= nPos)) || (nNeg &gt; nPos);</span>
     }

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner by first computing the convex hull then
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise2(PairIntArray closedCurve) {

<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L122">            return false;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        } else if (closedCurve.getN() &lt; 4) {</span>
<span class="nc" id="L124">            return curveIsOrderedClockwise(closedCurve);</span>
        }
        
<span class="fc" id="L127">        int n = closedCurve.getN();</span>
        
<span class="fc" id="L129">        PairIntWithIndex0[] p = new PairIntWithIndex0[n];</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L131">            p[i] = new PairIntWithIndex0(closedCurve.getX(i), closedCurve.getY(i),  i);</span>
        }
        
<span class="fc" id="L134">        GrahamScanPairInt&lt;PairIntWithIndex0&gt; scan = new GrahamScanPairInt&lt;PairIntWithIndex0&gt;();</span>
        try {
<span class="fc" id="L136">            scan.computeHull(p);</span>
            
            // hull returns points in clockwise order
            
<span class="fc" id="L140">            n = scan.getHull().size() - 1;</span>
            //PairIntArray hull = new PairIntArray(n);
            //List&lt;Integer&gt; hullCurveIndexes = new ArrayList&lt;Integer&gt;();
            //int[] deltaIndexes = new int[n];
            
            // nPos or nNeg might be 1 and then other n-2 if there is wrap-around
<span class="fc" id="L146">            int nNeg = 0;</span>
<span class="fc" id="L147">            int nPos = 0;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
                
<span class="fc" id="L150">                PairIntWithIndex0 p0 = scan.getHull().get(i);</span>
                
                //hull.add(Math.round(p0.getX()), Math.round(p0.getY()));
                //hullCurveIndexes.add(Integer.valueOf(p0.getPixIndex()));
                
                // for CW input, expect these to be + numbers
<span class="fc" id="L156">                int deltaIndex = scan.getHull().get(i + 1).getPixIndex() - p0.getPixIndex();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                if (deltaIndex &gt; 0) {</span>
<span class="fc" id="L158">                    nPos++;</span>
                } else {
<span class="fc" id="L160">                    nNeg++;</span>
                }
            }
            
            //boolean isCW = curveIsOrderedClockwise(hull);
            //assert(isCW);
            
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (nPos &gt; nNeg) {</span>
<span class="fc" id="L168">                return true;</span>
            }
            
<span class="fc" id="L171">            return false;</span>
            
<span class="nc" id="L173">        } catch (GrahamScanTooFewPointsException ex) {</span>
<span class="nc" id="L174">            return curveIsOrderedClockwise(closedCurve);</span>
        }
    }

    public void additionalThinning45DegreeEdges(
        GreyscaleImage theta, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L190" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>

<span class="nc" id="L193">                int tG = theta.getValue(i, j);</span>

<span class="nc bnc" id="L195" title="All 6 branches missed.">                if (((tG == 45) || (tG == -45)) &amp;&amp; (input.getValue(i, j) &gt; 0)) {</span>

<span class="nc" id="L197">                    int tH0 = theta.getValue(i - 1, j);</span>
<span class="nc" id="L198">                    int tH1 = theta.getValue(i + 1, j);</span>
<span class="nc" id="L199">                    int tV0 = theta.getValue(i, j - 1);</span>
<span class="nc" id="L200">                    int tV1 = theta.getValue(i, j + 1);</span>

<span class="nc" id="L202">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L203">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L204">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L205">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L207" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L209">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L211">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L213" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L215">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L217">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L223">    }</span>
    
    /**
     * 
     * @param theta image with values in range 0 to 180.
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        double[][] theta, double[][] input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (int i = 1; i &lt; (input.length - 1); i++) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (int j = 1; j &lt; (input[i].length - 1); j++) {</span>

<span class="fc" id="L245">                double vG = input[i][j];</span>
                              
<span class="fc bfc" id="L247" title="All 2 branches covered.">                if (vG &lt;= 0) {</span>
<span class="fc" id="L248">                    continue;</span>
                }
                
<span class="fc" id="L251">                int tG = convert360To45RefFrame((int)Math.round(theta[i][j]));</span>

<span class="fc bfc" id="L253" title="All 4 branches covered.">                if ((Math.abs(tG - 45) &lt; 5) || (Math.abs(tG - -45) &lt; 5)) {</span>

<span class="fc" id="L255">                    int tH0 = convert360To45RefFrame((int)Math.round(theta[i - 1][j]));</span>
<span class="fc" id="L256">                    int tH1 = convert360To45RefFrame((int)Math.round(theta[i + 1][j]));</span>
<span class="fc" id="L257">                    int tV0 = convert360To45RefFrame((int)Math.round(theta[i][j - 1]));</span>
<span class="fc" id="L258">                    int tV1 = convert360To45RefFrame((int)Math.round(theta[i][j + 1]));</span>

<span class="fc" id="L260">                    double gH0 = input[i - 1][j];</span>
<span class="fc" id="L261">                    double gH1 = input[i + 1][j];</span>
<span class="fc" id="L262">                    double gV0 = input[i][j - 1];</span>
<span class="fc" id="L263">                    double gV1 = input[i][j + 1];</span>

<span class="fc bfc" id="L265" title="All 4 branches covered.">                    if ((gH0 &gt; 0) &amp;&amp; (Math.abs(tH0 - tG) &lt; 5)) {</span>
<span class="fc bfc" id="L266" title="All 4 branches covered.">                        if ((gV0 &gt; 0) &amp;&amp; (Math.abs(tV0 - tG) &lt; 5)) {</span>
<span class="fc" id="L267">                            input[i][j] = 0;</span>
<span class="fc bfc" id="L268" title="All 4 branches covered.">                        } else if ((gV1 &gt; 0) &amp;&amp; (Math.abs(tV1 - tG) &lt; 5)) {</span>
<span class="fc" id="L269">                            input[i][j] = 0;</span>
                        }
<span class="fc bfc" id="L271" title="All 4 branches covered.">                    } else if ((gH1 &gt; 0) &amp;&amp; (Math.abs(tH1 - tG) &lt; 5)) {</span>
<span class="fc bfc" id="L272" title="All 4 branches covered.">                        if ((gV0 &gt; 0) &amp;&amp; (Math.abs(tV0 - tG) &lt; 5)) {</span>
<span class="fc" id="L273">                            input[i][j] = 0;</span>
<span class="fc bfc" id="L274" title="All 4 branches covered.">                        } else if ((gV1 &gt; 0) &amp;&amp; (Math.abs(tV1 - tG) &lt; 5)) {</span>
<span class="fc" id="L275">                            input[i][j] = 0;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L281">    }</span>
    
    /**
         *           Y
         *          90
         *     135   |    +45
         *           |
         *   180------------ 0   X
         *           |
         *    225    |   315
         *          270
         * 
         *  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45
        
     * @param angle360
     * @return 
     */
    private int convert360To45RefFrame(int angle360) {
        
<span class="fc bfc" id="L304" title="All 4 branches covered.">        if ((angle360 &lt; 23) || (angle360 &gt; 337)) {</span>
<span class="fc" id="L305">            return 0;</span>
<span class="fc bfc" id="L306" title="All 4 branches covered.">        } else if ((angle360 &gt; 157) &amp;&amp; (angle360 &lt; 203)) {</span>
<span class="fc" id="L307">            return 0;</span>
<span class="pc bpc" id="L308" title="1 of 8 branches missed.">        } else  if (((angle360 &gt; 22) &amp;&amp; (angle360 &lt; 68)) || </span>
            ((angle360 &gt; 202) &amp;&amp; (angle360 &lt; 248))) {
            // in range of +45 or +225
<span class="fc" id="L311">            return 45;</span>
<span class="pc bpc" id="L312" title="1 of 8 branches missed.">        } else if (((angle360 &gt; 67) &amp;&amp; (angle360 &lt; 113)) || </span>
            ((angle360 &gt; 247) &amp;&amp; (angle360 &lt; 293))) {
            // in range of +90 or +270
<span class="fc" id="L315">            return 90;</span>
        } else { //if (((t &gt; 112) &amp;&amp; (t &lt; 158)) || ((t &gt; 292) &amp;&amp; (t &lt; 338))) {
            // in range of +135 or +315
<span class="fc" id="L318">            return -45;</span>
        }
    }
    
    /**
     * thin a line that is the product in a canny edge detector, given
     * a theta image which has values between 0 and 360.
     * @param theta3602
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        GreyscaleImage theta3602, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>
                
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (input.getValue(i, j) == 0) {</span>
<span class="nc" id="L344">                    continue;</span>
                }

<span class="nc" id="L347">                int tG = convert360To45RefFrame(theta3602.getValue(i, j));</span>

<span class="nc bnc" id="L349" title="All 4 branches missed.">                if ((tG == 45) || (tG == -45)) {</span>

<span class="nc" id="L351">                    int tH0 = convert360To45RefFrame(theta3602.getValue(i - 1, j));</span>
<span class="nc" id="L352">                    int tH1 = convert360To45RefFrame(theta3602.getValue(i + 1, j));</span>
<span class="nc" id="L353">                    int tV0 = convert360To45RefFrame(theta3602.getValue(i, j - 1));</span>
<span class="nc" id="L354">                    int tV1 = convert360To45RefFrame(theta3602.getValue(i, j + 1));</span>

<span class="nc" id="L356">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L357">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L358">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L359">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L361" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L362" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L363">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L365">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L367" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L369">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L371">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L377">    }</span>
    
    /**
     * thin a line that is the product in a canny edge detector, given
     * a theta image which has values between 0 and 360.
     * @param theta3602
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        GreyscaleImage theta3602, GreyscaleImage input, double minResolvableAngle) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="fc bfc" id="L397" title="All 2 branches covered.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>
                
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if (input.getValue(i, j) == 0) {</span>
<span class="fc" id="L401">                    continue;</span>
                }
                
<span class="fc" id="L404">                int t = theta3602.getValue(i, j);</span>
                
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if ((Math.abs(t - 0) &lt; minResolvableAngle) || </span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                    (Math.abs(180 - t) &lt; minResolvableAngle) || </span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">                    (Math.abs(360 - t) &lt; minResolvableAngle)) {</span>
                    // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L410">                    t = 90;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">                } else if ((Math.abs(90 - t) &lt; minResolvableAngle) ||</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">                    (Math.abs(270 - t) &lt; minResolvableAngle) ) {</span>
                    // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L414">                    t = 180;</span>
                }

<span class="fc" id="L417">                int tG = convert360To45RefFrame(t);</span>

<span class="fc bfc" id="L419" title="All 4 branches covered.">                if ((tG == 45) || (tG == -45)) {</span>

<span class="fc" id="L421">                    int tH0 = theta3602.getValue(i - 1, j);</span>
<span class="fc" id="L422">                    int tH1 = theta3602.getValue(i + 1, j);</span>
<span class="fc" id="L423">                    int tV0 = theta3602.getValue(i, j - 1);</span>
<span class="fc" id="L424">                    int tV1 = theta3602.getValue(i, j + 1);</span>
                    
<span class="fc bfc" id="L426" title="All 2 branches covered.">                    if ((Math.abs(tH0 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                        || (Math.abs(180 - tH0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">                        || (Math.abs(360 - tH0) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L430">                        tH0 = 90;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tH0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                        || (Math.abs(270 - tH0) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L434">                        tH0 = 180;</span>
                    }
<span class="fc bfc" id="L436" title="All 2 branches covered.">                    if ((Math.abs(tH1 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">                        || (Math.abs(180 - tH1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                        || (Math.abs(360 - tH1) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L440">                        tH1 = 90;</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tH1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">                        || (Math.abs(270 - tH1) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L444">                        tH1 = 180;</span>
                    }
<span class="fc bfc" id="L446" title="All 2 branches covered.">                    if ((Math.abs(tV0 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">                        || (Math.abs(180 - tV0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                        || (Math.abs(360 - tV0) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L450">                        tV0 = 90;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tV0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                        || (Math.abs(270 - tV0) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L454">                        tV0 = 180;</span>
                    }
<span class="fc bfc" id="L456" title="All 2 branches covered.">                    if ((Math.abs(tV1 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">                        || (Math.abs(180 - tV1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                        || (Math.abs(360 - tV1) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L460">                        tV1 = 90;</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tV1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                        || (Math.abs(270 - tV1) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L464">                        tV1 = 180;</span>
                    }
                    
<span class="fc" id="L467">                    tH0 = convert360To45RefFrame(tH0);</span>
<span class="fc" id="L468">                    tH1 = convert360To45RefFrame(tH1);</span>
<span class="fc" id="L469">                    tV0 = convert360To45RefFrame(tV0);</span>
<span class="fc" id="L470">                    tV1 = convert360To45RefFrame(tV1);</span>
                    
<span class="fc" id="L472">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="fc" id="L473">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="fc" id="L474">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="fc" id="L475">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="fc bfc" id="L477" title="All 4 branches covered.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="fc" id="L479">                            input.setValue(i, j, 0);</span>
<span class="fc bfc" id="L480" title="All 4 branches covered.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="fc" id="L481">                            input.setValue(i, j, 0);</span>
                        }
<span class="fc bfc" id="L483" title="All 4 branches covered.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="fc bfc" id="L484" title="All 4 branches covered.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="fc" id="L485">                            input.setValue(i, j, 0);</span>
<span class="fc bfc" id="L486" title="All 4 branches covered.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="fc" id="L487">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L493">    }</span>
    
    /**
     * return true if correlation shows that the 2 curves are adjacent
     * to one another.  Note that the method needs the points within the
     * curves to be ordered in a similar manner and for the endpoints of the
     * curves to be accurate.  If a point in the middle of the curve is
     * the first or last point, it may prevent comparison of it with another
     * edge's endpoints.
     *
     * @param curve0
     * @param curve1
     * @param correlationOffset offset of where the shorter curve starts
     *  with respect to the longer.  For example, an offset of -2 means that
     * the first 2 points in the shorter curve are outside of the longer curve,
     * but the next point in the longer curve is adjacent to the shorter.
     * Another example: if offset is +2, the first pixel in the shorter curve
     * is adjacent to the third pixel in the longer curve.  NOTE: the offset
     * is only useful if this method returns true;
     * @return
     */
    protected boolean correlation(PairIntArray curve0, PairIntArray curve1,
        int[] correlationOffset) {

<span class="fc" id="L517">        correlationOffset[0] = Integer.MAX_VALUE;</span>

        //TODO: look at string matching algorithms to explore improvements here

        PairIntArray shorter, longer;
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (curve0.getN() &lt;= curve1.getN()) {</span>
<span class="fc" id="L523">            shorter = curve0;</span>
<span class="fc" id="L524">            longer = curve1;</span>
        } else {
<span class="fc" id="L526">            shorter = curve1;</span>
<span class="fc" id="L527">            longer = curve0;</span>
        }

        /*
        len0 = 5; len1 = 11;
         #####
             +++++++++++
          #####
             +++++++++++
           #####
             +++++++++++
            #####
             +++++++++++
             #####
             +++++++++++

             #####
             +++++++++++

                       #####
             +++++++++++

        ccs = sqrt(sumsqdiff)/nOverlapping if nOverlapping &gt; 0.

        if (css &lt;= 1 pix * nOverlapping) {
            store as a possible adjacent curve
        }
        compare possible adjacent curves for the smallest css, and store that
        offset in correlationOffset and return true, else false
        */

<span class="fc" id="L558">        double cSSMin = Double.MAX_VALUE;</span>
<span class="fc" id="L559">        int cSSMinOffset = Integer.MAX_VALUE;</span>
<span class="fc" id="L560">        int cSSMinNOverlapping = 0;</span>

<span class="fc" id="L562">        double sqrtTwo = Math.sqrt(2);</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">        for (int i = 0; i &lt; (longer.getN() + shorter.getN() - 1); i++) {</span>
            //siIdx is first index in shorter for comparison
            //sfIdx is last index in shorter for comparison
            //liIdx is first index of longer for comparison
            //lfIdx is last index of longer for comparison
            int siIdx, sfIdx, liIdx, lfIdx, offset;
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (i &lt; shorter.getN()) {</span>
                /*
                 #####
                     +++++++++++ i=0
                  #####
                     +++++++++++
                   #####
                     +++++++++++
                    #####
                     +++++++++++
                     #####
                     +++++++++++ i=4
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L584">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L585">                siIdx = sfIdx - i;</span>
<span class="fc" id="L586">                liIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L588">                lfIdx = sfIdx - siIdx;</span>
<span class="fc" id="L589">                offset = i - sfIdx;</span>

<span class="fc bfc" id="L591" title="All 2 branches covered.">            } else if (i &lt; longer.getN() ) {</span>

                /*
                      #####
                     +++++++++++  i=5

                       #####
                     +++++++++++

                        #####
                     +++++++++++

                         #####
                     +++++++++++

                          #####
                     +++++++++++

                           #####
                     +++++++++++ i = 10
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L613">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L614">                siIdx = 0;</span>
<span class="fc" id="L615">                liIdx = i - shorter.getN() + 1;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L617">                lfIdx = liIdx + shorter.getN() - 1;</span>
<span class="fc" id="L618">                offset = i - sfIdx;</span>

            } else {
                /*
                            #####
                     +++++++++++ i = 12
                     01234567890
                             #####
                     +++++++++++

                              #####
                     +++++++++++

                               #####
                     +++++++++++ i=15
                     01234567890
                */
<span class="fc" id="L635">                liIdx = i - shorter.getN() + 1;</span>
                //sfIdx is inclusive endpoint
<span class="fc" id="L637">                sfIdx = longer.getN() - liIdx - 1;</span>
<span class="fc" id="L638">                siIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L640">                lfIdx = liIdx + (sfIdx - siIdx);</span>
<span class="fc" id="L641">                offset = liIdx;</span>

            }

<span class="fc" id="L645">            int nOverLapping = (sfIdx - siIdx) + 1;</span>

<span class="pc bpc" id="L647" title="1 of 2 branches missed.">            if ((sfIdx - siIdx) != (lfIdx - liIdx)) {</span>
<span class="nc" id="L648">                throw new IllegalStateException(</span>
                    &quot;sample ranges are not correct&quot;);
            }

<span class="fc" id="L652">            double sumSq = 0;</span>

<span class="fc" id="L654">            int s = siIdx;</span>
<span class="fc" id="L655">            int l = liIdx;</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">            while (s &lt;= sfIdx) {</span>
<span class="fc" id="L657">                int xs = shorter.getX(s);</span>
<span class="fc" id="L658">                int xl = longer.getX(l);</span>
<span class="fc" id="L659">                int dx = xs - xl;</span>
<span class="fc" id="L660">                int ys = shorter.getY(s);</span>
<span class="fc" id="L661">                int yl = longer.getY(l);</span>
<span class="fc" id="L662">                int dy = ys - yl;</span>
<span class="fc" id="L663">                sumSq += ((dx*dx) + (dy*dy));</span>
<span class="fc" id="L664">                s++;</span>
<span class="fc" id="L665">                l++;</span>
<span class="fc" id="L666">            }</span>

<span class="fc" id="L668">            double tmp = Math.sqrt(sumSq/nOverLapping);</span>

            // assuming adjacent pixel has distance of sqrt(2) at the most
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (tmp &lt;= sqrtTwo) {</span>

<span class="pc bpc" id="L673" title="5 of 6 branches missed.">                if ((tmp &lt; cSSMin) ||</span>
                (tmp == cSSMin &amp;&amp; (nOverLapping &gt; cSSMinNOverlapping))
                ) {

<span class="fc" id="L677">                    cSSMin = tmp;</span>

<span class="fc" id="L679">                    cSSMinOffset = offset;</span>

<span class="fc" id="L681">                    cSSMinNOverlapping = nOverLapping;</span>
                }
            }
        }

<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (cSSMin &lt; Double.MAX_VALUE) {</span>

<span class="fc" id="L688">            correlationOffset[0] = cSSMinOffset;</span>

<span class="fc" id="L690">            return true;</span>
        }

<span class="fc" id="L693">        return false;</span>
    }

    public double[] calculateXYCentroids1(List&lt;CurvatureScaleSpaceContour&gt; list) {
        
<span class="nc" id="L698">        double xc = 0;</span>
<span class="nc" id="L699">        double yc = 0;</span>

<span class="nc bnc" id="L701" title="All 2 branches missed.">        for (CurvatureScaleSpaceContour cr : list) {</span>
<span class="nc" id="L702">            double x = cr.getPeakDetails()[0].getXCoord();</span>
<span class="nc" id="L703">            double y = cr.getPeakDetails()[0].getYCoord();</span>
<span class="nc" id="L704">            xc += x;</span>
<span class="nc" id="L705">            yc += y;</span>
<span class="nc" id="L706">        }</span>
<span class="nc" id="L707">        xc /= (double)list.size();</span>
<span class="nc" id="L708">        yc /= (double)list.size();</span>

<span class="nc" id="L710">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy, float[] weights) {

<span class="fc" id="L715">        double xc = 0;</span>
<span class="fc" id="L716">        double yc = 0;</span>

<span class="fc bfc" id="L718" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
<span class="fc" id="L719">            double x1 = xy.getX(i);</span>
<span class="fc" id="L720">            xc += (weights[i] * x1);</span>

<span class="fc" id="L722">            double y1 = xy.getY(i);</span>
<span class="fc" id="L723">            yc += (weights[i] * y1);</span>
        }

<span class="fc" id="L726">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy) {

<span class="fc" id="L731">        double xc = 0;</span>
<span class="fc" id="L732">        double yc = 0;</span>

<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L736">            xc += xy.getX(i);</span>

<span class="fc" id="L738">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L741">        xc /= (double)xy.getN();</span>

<span class="fc" id="L743">        yc /= (double)xy.getN();</span>

<span class="fc" id="L745">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairFloatArray xy) {

<span class="fc" id="L750">        double xc = 0;</span>
<span class="fc" id="L751">        double yc = 0;</span>

<span class="fc bfc" id="L753" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L755">            xc += xy.getX(i);</span>

<span class="fc" id="L757">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L760">        xc /= (double)xy.getN();</span>

<span class="fc" id="L762">        yc /= (double)xy.getN();</span>

<span class="fc" id="L764">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(List&lt;PairIntArray&gt; xyList) {

<span class="nc" id="L769">        double xc = 0;</span>
<span class="nc" id="L770">        double yc = 0;</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">        for (PairIntArray points : xyList) {</span>

<span class="nc" id="L774">            double[] xycen = calculateXYCentroids(points);</span>

<span class="nc" id="L776">            xc += xycen[0];</span>
<span class="nc" id="L777">            yc += xycen[1];</span>
<span class="nc" id="L778">        }</span>

<span class="nc" id="L780">        xc /= (double)xyList.size();</span>
<span class="nc" id="L781">        yc /= (double)xyList.size();</span>

<span class="nc" id="L783">        return new double[]{xc, yc};</span>
    }

    public PairInt calculateXYCentroids2(Collection&lt;PairInt&gt; points) {
        
<span class="fc" id="L788">        double[] xyCen = calculateXYCentroids(points);</span>
        
<span class="fc" id="L790">        PairInt p = new PairInt((int)Math.round(xyCen[0]), (int)Math.round(xyCen[1]));</span>
        
<span class="fc" id="L792">        return p;</span>
    }
    
    public double[] calculateXYCentroids(Collection&lt;PairInt&gt; points) {

<span class="fc" id="L797">        double xc = 0;</span>
<span class="fc" id="L798">        double yc = 0;</span>

<span class="fc bfc" id="L800" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L802">           int x = p.getX();</span>
<span class="fc" id="L803">           int y = p.getY();</span>

<span class="fc" id="L805">            xc += x;</span>
<span class="fc" id="L806">            yc += y;</span>
<span class="fc" id="L807">        }</span>

<span class="fc" id="L809">        xc /= (double)(points.size());</span>

<span class="fc" id="L811">        yc /= (double)(points.size());</span>

<span class="fc" id="L813">        return new double[]{xc, yc};</span>
    }

    public int[] calculateRoundedXYCentroids(Set&lt;PairInt&gt; points) {

<span class="fc" id="L818">        double[] xyCen = calculateXYCentroids(points);</span>

<span class="fc" id="L820">        int[] out = new int[2];</span>
<span class="fc" id="L821">        out[0] = (int)Math.round(xyCen[0]);</span>
<span class="fc" id="L822">        out[1] = (int)Math.round(xyCen[1]);</span>

<span class="fc" id="L824">        return out;</span>
    }
    
    public int[] calculateRoundedXYCentroids(TIntSet pixelIdxs, int imgWidth) {

<span class="fc" id="L829">        double xc = 0;</span>
<span class="fc" id="L830">        double yc = 0;</span>

<span class="fc" id="L832">        TIntIterator iter = pixelIdxs.iterator();</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">        while (iter.hasNext()) {</span>

<span class="fc" id="L835">            int pixIdx = iter.next();</span>
            
<span class="fc" id="L837">            int y = pixIdx/imgWidth;</span>
<span class="fc" id="L838">            int x = pixIdx - (y * imgWidth);</span>
            
<span class="fc" id="L840">            xc += x;</span>
<span class="fc" id="L841">            yc += y;</span>
<span class="fc" id="L842">        }</span>

<span class="fc" id="L844">        xc /= (double)pixelIdxs.size();</span>
<span class="fc" id="L845">        yc /= (double)pixelIdxs.size();</span>
        
<span class="fc" id="L847">        int[] out = new int[2];</span>
<span class="fc" id="L848">        out[0] = (int)Math.round(xc);</span>
<span class="fc" id="L849">        out[1] = (int)Math.round(yc);</span>

<span class="fc" id="L851">        return out;</span>
    }

    public double[] calculateXYCentroids(float[] x, float[] y) {

<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L857">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L860">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L863">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="fc" id="L866">        double xc = 0;</span>
<span class="fc" id="L867">        double yc = 0;</span>

<span class="fc bfc" id="L869" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="fc" id="L871">            xc += x[i];</span>

<span class="fc" id="L873">            yc += y[i];</span>
        }

<span class="fc" id="L876">        xc /= (double)(x.length);</span>

<span class="fc" id="L878">        yc /= (double)(x.length);</span>

<span class="fc" id="L880">        return new double[]{xc, yc};</span>
    }
    
    public double[] calculateXYCentroids(int[] x, int[] y) {

<span class="pc bpc" id="L885" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L886">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L889">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L892">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="fc" id="L895">        double xc = 0;</span>
<span class="fc" id="L896">        double yc = 0;</span>

<span class="fc bfc" id="L898" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="fc" id="L900">            xc += x[i];</span>

<span class="fc" id="L902">            yc += y[i];</span>
        }

<span class="fc" id="L905">        xc /= (double)(x.length);</span>

<span class="fc" id="L907">        yc /= (double)(x.length);</span>

<span class="fc" id="L909">        return new double[]{xc, yc};</span>
    }

    /**
     * does removing the point at idx create a gap between it's neighboring
     * pixels?  this uses the simplest test of only the points at idx-1
     * and idx+1.
     *
     * @param edge
     * @param idx
     * @return
     */
    public boolean doesDisconnect(PairIntArray edge, int idx) {

        // test for endpoints first
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if (idx == 0) {</span>

<span class="nc bnc" id="L926" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L927">                return true;</span>
            }

            // does this point currently connect to the last point?
<span class="nc" id="L931">            float diffX = edge.getX(idx) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L933">                diffX *= -1;</span>
            }
<span class="nc" id="L935">            float diffY = edge.getY(idx) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L937">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L939" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the last point in the edge
                // check to see if lastPoint and idx + 1 are adjacent
<span class="nc" id="L942">                diffX = edge.getX(idx + 1) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L944">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L946" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L947">                    return true;</span>
                }

<span class="nc" id="L950">                diffY = edge.getY(idx + 1) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L952">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L955">                    return true;</span>
                }
            }
<span class="nc" id="L958">            return false;</span>
        }

<span class="nc bnc" id="L961" title="All 2 branches missed.">        if (idx == (edge.getN() - 1)) {</span>

<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L964">                return true;</span>
            }

            // does this point currently connect to the first point?
<span class="nc" id="L968">            float diffX = edge.getX(idx) - edge.getX(0);</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L970">                diffX *= -1;</span>
            }
<span class="nc" id="L972">            float diffY = edge.getY(idx) - edge.getY(0);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L974">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L976" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the first point in the edge
                // check to see if lastPoint - 1 and first point are adjacent
<span class="nc" id="L979">                diffX = edge.getX(idx - 1) - edge.getX(0);</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L981">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L983" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L984">                    return true;</span>
                }

<span class="nc" id="L987">                diffY = edge.getY(idx - 1) - edge.getY(0);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L989">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L991" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L992">                    return true;</span>
                }
            }
<span class="nc" id="L995">            return false;</span>
        }

<span class="nc bnc" id="L998" title="All 2 branches missed.">        if ((idx + 1) &lt; edge.getN()) {</span>
<span class="nc" id="L999">            float diffX = edge.getX(idx - 1) - edge.getX(idx + 1);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L1001">                diffX *= -1;</span>
            }
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L1004">                return true;</span>
            }

<span class="nc" id="L1007">            float diffY = edge.getY(idx - 1) - edge.getY(idx + 1);</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L1009">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            if (diffY &gt; 1) {</span>
<span class="nc" id="L1012">                return true;</span>
            }

<span class="nc" id="L1015">            return false;</span>
        }

<span class="nc" id="L1018">        return false;</span>
    }

    public double distanceFromPointToALine(float lineX0, float lineY0,
        float lineX1, float lineY1, float xP, float yP) {

        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)

        distance between that edge and a point (xP, yP) is

        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;

        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- )
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )
        */

<span class="fc" id="L1041">        float diffX = lineX1 - lineX0;</span>
<span class="fc" id="L1042">        float diffY = lineY1 - lineY0;</span>

<span class="fc bfc" id="L1044" title="All 2 branches covered.">        if (diffY == 0) {</span>
            // horizontal line
<span class="fc" id="L1046">            return Math.abs(yP - lineY0);</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="fc" id="L1049">            return Math.abs(xP - lineX0);</span>
        }

<span class="fc" id="L1052">        double pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>

<span class="fc" id="L1054">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc" id="L1056">        double dist = pt1/pt2;</span>

<span class="fc" id="L1058">        return dist;</span>
    }

    public void sortByX(PairIntArray curve) {
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">        if (curve.getN() &lt; 2) {</span>
<span class="nc" id="L1063">            return;</span>
        }
<span class="fc" id="L1065">        sortByX(curve, 0, curve.getN() - 1);</span>
<span class="fc" id="L1066">    }</span>

    private void sortByX(PairIntArray curve, int idxLo, int idxHi) {
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1070">            int idxMid = partitionByX(curve, idxLo, idxHi);</span>
<span class="fc" id="L1071">            sortByX(curve, idxLo, idxMid - 1);</span>
<span class="fc" id="L1072">            sortByX(curve, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1074">    }</span>

    private int partitionByX(PairIntArray curve, int idxLo, int idxHi) {

<span class="fc" id="L1078">        int x = curve.getX(idxHi);  //for comparison</span>
<span class="fc" id="L1079">        int store = idxLo - 1;      //store to swap after pivot</span>

<span class="fc bfc" id="L1081" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">            if (curve.getX(i) &lt;= x) {</span>
<span class="fc" id="L1083">                store++;</span>
<span class="fc" id="L1084">                int swapX = curve.getX(store);</span>
<span class="fc" id="L1085">                int swapY = curve.getY(store);</span>
<span class="fc" id="L1086">                curve.set(store, curve.getX(i), curve.getY(i));</span>
<span class="fc" id="L1087">                curve.set(i, swapX, swapY);</span>
            }
        }
<span class="fc" id="L1090">        store++;</span>

<span class="fc" id="L1092">        int swapX = curve.getX(store);</span>
<span class="fc" id="L1093">        int swapY = curve.getY(store);</span>
<span class="fc" id="L1094">        curve.set(store, curve.getX(idxHi), curve.getY(idxHi));</span>
<span class="fc" id="L1095">        curve.set(idxHi, swapX, swapY);</span>

<span class="fc" id="L1097">        return store;</span>
    }

    protected void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; tmpAddedPoints,
        Set&lt;PairInt&gt; tmpRemovedPoints, int imageWidth, int imageHeight) {

<span class="fc" id="L1104">        outputNeighbors.clear();</span>

<span class="fc bfc" id="L1106" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L1108">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L1109">            int y2 = y + eightNeighborsY[i];</span>

<span class="pc bpc" id="L1111" title="4 of 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1113">                continue;</span>
            }

<span class="fc" id="L1116">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L1118" title="All 2 branches covered.">            if (tmpRemovedPoints.contains(p2)) {</span>
<span class="fc" id="L1119">                continue;</span>
            }
<span class="pc bpc" id="L1121" title="1 of 4 branches missed.">            if (tmpAddedPoints.contains(p2) || points.contains(p2)) {</span>
<span class="fc" id="L1122">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L1125">    }</span>

    public Set&lt;PairInt&gt; findNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L1129">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1131" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1133">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1134">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L1136">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1138" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1139">                neighbors.add(p2);</span>
            }
        }

<span class="nc" id="L1143">        return neighbors;</span>
    }
        
    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; points, 
        Set&lt;PairInt&gt; excludePoints, int[] dxs, int[] dys, 
        Set&lt;PairInt&gt; outputNeighbors) {
        
<span class="nc" id="L1150">        outputNeighbors.clear();</span>
        
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        for (int i = 0; i &lt; dxs.length; i++) {</span>
            
<span class="nc" id="L1154">            int x2 = x + dxs[i];</span>
<span class="nc" id="L1155">            int y2 = y + dys[i];</span>
            
<span class="nc" id="L1157">            PairInt p2 = new PairInt(x2, y2);</span>
            
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1160">                continue;</span>
            }
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1163">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1166">    }</span>

    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L1171">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L1173" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1175">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1176">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1178" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1180">                continue;</span>
            }

<span class="nc" id="L1183">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1185" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1186">                continue;</span>
            }
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1189">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1192">    }</span>

    /**
     * iterate through points, counting the number of pixels on the image
     * boundaries, and return true if the number reaches numberOfPixels.
     * @param numberOfPixels the number of pixels for which to return true
     * if they are on the image boundaries.
     * @param points
     * @param imageWidth
     * @param imageHeight
     * @return
     */
    public boolean hasNumberOfPixelsOnImageBoundaries(int numberOfPixels,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="nc" id="L1207">        int n = 0;</span>

<span class="nc bnc" id="L1209" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L1211">            int x = p.getX();</span>
<span class="nc" id="L1212">            int y = p.getY();</span>

<span class="nc bnc" id="L1214" title="All 8 branches missed.">            if ((x == 0) || (y == 0) || (x == (imageWidth - 1)) ||</span>
                (y == (imageHeight - 1))) {

<span class="nc" id="L1217">                n++;</span>

<span class="nc bnc" id="L1219" title="All 2 branches missed.">                if (n == numberOfPixels) {</span>
<span class="nc" id="L1220">                    return true;</span>
                }
            }
<span class="nc" id="L1223">        }</span>

<span class="nc bnc" id="L1225" title="All 2 branches missed.">        return (n &gt;= numberOfPixels);</span>
    }

    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points, int imageWidth,
        int imageHeight) {

<span class="nc" id="L1231">        int nn = 0;</span>

<span class="nc bnc" id="L1233" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1235">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1236">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1238" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1240">                continue;</span>
            }

<span class="nc" id="L1243">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1245" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1246">                nn++;</span>
            }
        }

<span class="nc" id="L1250">        return nn;</span>
    }
    
    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L1255">        int nn = 0;</span>

<span class="nc bnc" id="L1257" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1259">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1260">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L1262">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1264" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1265">                nn++;</span>
            }
        }

<span class="nc" id="L1269">        return nn;</span>
    }

    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2) {
        
<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">        if (idx2 &lt; 0) {</span>
<span class="nc" id="L1275">            return false;</span>
        }

<span class="fc" id="L1278">        int x1 = edge.getX(idx1);</span>
<span class="fc" id="L1279">        int y1 = edge.getY(idx1);</span>

<span class="fc" id="L1281">        int x2 = edge.getX(idx2);</span>
<span class="fc" id="L1282">        int y2 = edge.getY(idx2);</span>

<span class="fc" id="L1284">        int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L1285">        int diffY = Math.abs(y1 - y2);</span>

<span class="fc bfc" id="L1287" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L1288">            return true;</span>
        }

<span class="fc" id="L1291">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx, int x, int y) {
        
<span class="nc bnc" id="L1296" title="All 4 branches missed.">        if (idx &lt; 0 || idx &gt; (edge.getN() - 1)) {</span>
<span class="nc" id="L1297">            return false;</span>
        }

<span class="nc" id="L1300">        int x1 = edge.getX(idx);</span>
<span class="nc" id="L1301">        int y1 = edge.getY(idx);</span>

<span class="nc" id="L1303">        int diffX = Math.abs(x1 - x);</span>
<span class="nc" id="L1304">        int diffY = Math.abs(y1 - y);</span>

<span class="nc bnc" id="L1306" title="All 4 branches missed.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="nc" id="L1307">            return true;</span>
        }

<span class="nc" id="L1310">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2,
        float spacingBetweenPoints) {

<span class="nc" id="L1316">        int x1 = edge.getX(idx1);</span>
<span class="nc" id="L1317">        int y1 = edge.getY(idx1);</span>

<span class="nc" id="L1319">        int x2 = edge.getX(idx2);</span>
<span class="nc" id="L1320">        int y2 = edge.getY(idx2);</span>

<span class="nc" id="L1322">        int diffX = Math.abs(x1 - x2);</span>
<span class="nc" id="L1323">        int diffY = Math.abs(y1 - y2);</span>
        
<span class="nc" id="L1325">        float dist = (float)Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="nc bnc" id="L1327" title="All 2 branches missed.">        if (dist &lt;= spacingBetweenPoints) {</span>
<span class="nc" id="L1328">            return true;</span>
        }

<span class="nc" id="L1331">        return false;</span>
    }

    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * along the curve at the middle point, its direction is from p0 to p1.
     * &lt;pre&gt;
     * For example:
     * 
     * 135 degrees
     *       .---
     *       | .
     *           p2   
     *             p1
     *                p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleAtMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

        /*
        given the points (x1, y1) (x2, y2) and (x3, y3), 
        calculates the angle at the midpoint (x2, y2) for the path along
        the points.
        */
        
<span class="fc" id="L1364">        double theta1 = AngleUtil.polarAngleCCW(x2 - x1, y2 - y1);</span>
        
<span class="fc" id="L1366">        double theta2 = AngleUtil.polarAngleCCW(x3 - x2, y3 - y2);</span>
        
<span class="fc" id="L1368">        double theta = AngleUtil.getAngleAverageInRadians(theta1, theta2);</span>
                
<span class="fc" id="L1370">        return theta;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * tangent to the curve at the middle point - its direction follows
     * the right hand rule.
     * &lt;pre&gt;
     * For example:
     *                  45 degrees
     *               __
     *               . |
     *       p2    .
     *          p1
     *             p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleTangentToMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

<span class="fc" id="L1397">        double theta = calculateAngleAtMidpoint(x1, y1, x2, y2, x3, y3);</span>
               
<span class="fc" id="L1399">        double thetaMinus90 = theta - Math.PI/2.;</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        if (thetaMinus90 &lt; 0) {</span>
<span class="fc" id="L1401">            thetaMinus90 += (2.*Math.PI);</span>
        }
        
<span class="fc" id="L1404">        return thetaMinus90;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which direction and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.  The points are also
     * checked to make sure they aren't in the points set.
     *
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @param points
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY,
        Set&lt;PairInt&gt; points) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        direction of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="nc" id="L1442">        int xmRot90 = xp + (ym - yp);</span>
<span class="nc" id="L1443">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="nc" id="L1445">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="nc" id="L1446">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="nc" id="L1448">        boolean rot90IsInPoints = points.contains(</span>
<span class="nc" id="L1449">            new PairInt(Math.round(xmRot90), Math.round(ymRot90)));</span>

<span class="nc" id="L1451">        boolean rotNegative90IsInPoints = points.contains(</span>
<span class="nc" id="L1452">            new PairInt(Math.round(xmRotNegative90),</span>
<span class="nc" id="L1453">            Math.round(ymRotNegative90)));</span>

<span class="nc" id="L1455">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="nc" id="L1458">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="nc" id="L1462">        double perp = theta;</span>

<span class="nc bnc" id="L1464" title="All 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L1465">            perp += Math.PI/2.;</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">        } else if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc bnc" id="L1467" title="All 4 branches missed.">            if (rot90IsInPoints &amp;&amp; !rotNegative90IsInPoints) {</span>
<span class="nc" id="L1468">                perp -= Math.PI/2.;</span>
<span class="nc bnc" id="L1469" title="All 4 branches missed.">            } else if (!rot90IsInPoints &amp;&amp; rotNegative90IsInPoints) {</span>
<span class="nc" id="L1470">                perp += Math.PI/2.;</span>
            } else {
<span class="nc" id="L1472">                throw new IllegalStateException(&quot;Error in algorithm:&quot; +</span>
                &quot; consider changing the test 90 and -90 points so that&quot; +
                &quot; one will always be in points set.&quot;);
            }
        } else {
<span class="nc" id="L1477">            perp -= Math.PI/2.;</span>
        }

<span class="nc bnc" id="L1480" title="All 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L1481">            perp = perp - 2*Math.PI;</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L1483">            perp += 2*Math.PI;</span>
        }

<span class="nc" id="L1486">        return perp;</span>
    }

    public double calculateArea(PairIntArray closedCurve) {
        
<span class="nc" id="L1491">        int n = closedCurve.getN();</span>
        
<span class="nc" id="L1493">        double sum = 0;</span>
        
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        for (int i = 0; i &lt; (n - 1); ++i) {</span>
            
<span class="nc" id="L1497">            double t = 0.5 * (closedCurve.getY(i + 1) + closedCurve.getY(i)) *</span>
<span class="nc" id="L1498">                (closedCurve.getX(i + 1) - closedCurve.getX(i));</span>
            
<span class="nc" id="L1500">            sum += t;</span>
        }
        
<span class="nc" id="L1503">        sum += ((closedCurve.getY(0) + closedCurve.getY(n - 1)) *</span>
<span class="nc" id="L1504">                (closedCurve.getX(0) - closedCurve.getX(n -1)));</span>
        
<span class="nc" id="L1506">        return sum;</span>
    }

    public PairIntArray scaleDown(PairIntArray a, float scale) {
        
<span class="fc" id="L1511">        double[] cenXY = calculateXYCentroids(a);</span>
     
<span class="fc" id="L1513">        TransformationParameters params = new TransformationParameters();</span>
<span class="fc" id="L1514">        params.setOriginX((float)cenXY[0]);</span>
<span class="fc" id="L1515">        params.setOriginX((float)cenXY[1]);</span>
<span class="fc" id="L1516">        params.setScale(scale);</span>
        
<span class="fc" id="L1518">        Transformer transformer = new Transformer();</span>
<span class="fc" id="L1519">        PairIntArray b = transformer.applyTransformation(params, a);</span>
    
        // when shrinking, there may be overlapping points
<span class="fc" id="L1522">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">        for (int i = (b.getN() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1524">            PairInt p = new PairInt(b.getX(i), b.getY(i));</span>
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1526">                b.removeRange(i, i);</span>
            } else {
<span class="fc" id="L1528">                added.add(p);</span>
            }
        }
        
<span class="fc" id="L1532">        return b;</span>
    }

    public PairIntArray createContiguousCircle(float radius) {

<span class="nc" id="L1537">        int shift = (int)Math.ceil(radius);</span>
    
<span class="nc" id="L1539">        return createContiguousCircle(radius, shift, shift);</span>
    }
    
    public PairIntArray createContiguousCircle(float radius, int xShift, 
        int yShift) {
        
        // for a change in y to be at least 1 pixel, theta would be:
        //   theta = asin(1/r)
<span class="fc" id="L1547">        double theta = Math.asin(1./radius);</span>
        
<span class="fc" id="L1549">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L1551">        PairIntArray circle = new PairIntArray();</span>
<span class="fc" id="L1552">        double t = 0;</span>
        int x, y;
<span class="fc bfc" id="L1554" title="All 2 branches covered.">        while (t &lt;= Math.PI/2.) {</span>
<span class="fc" id="L1555">            x = xShift + (int)Math.round(radius * Math.cos(t));</span>
<span class="fc" id="L1556">            y = yShift + (int)Math.round(radius * Math.sin(t));</span>
<span class="fc" id="L1557">            PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L1558">            t += theta;</span>
<span class="fc bfc" id="L1559" title="All 2 branches covered.">            if (added.contains(p)) {</span>
<span class="fc" id="L1560">                continue;</span>
            }
<span class="fc" id="L1562">            circle.add(x, y);</span>
<span class="fc" id="L1563">            added.add(p);</span>
<span class="fc" id="L1564">        }</span>
<span class="fc" id="L1565">        int n90 = circle.getN();</span>
<span class="fc bfc" id="L1566" title="All 2 branches covered.">        for (int i = (n90 - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1567">            x = xShift -1 * (circle.getX(i) - xShift);</span>
<span class="fc" id="L1568">            y = circle.getY(i);</span>
<span class="fc" id="L1569">            PairInt p = new PairInt(x, y);</span>
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1571">                continue;</span>
            }
<span class="fc" id="L1573">            circle.add(x, y);</span>
<span class="fc" id="L1574">            added.add(p);</span>
        }
<span class="fc" id="L1576">        int n180 = circle.getN();</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        for (int i = (n180 - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1578">            x = circle.getX(i);</span>
<span class="fc" id="L1579">            y = yShift -1 * (circle.getY(i) - yShift);</span>
<span class="fc" id="L1580">            PairInt p = new PairInt(x, y);</span>
<span class="fc bfc" id="L1581" title="All 2 branches covered.">            if (added.contains(p)) {</span>
<span class="fc" id="L1582">                continue;</span>
            }
<span class="fc" id="L1584">            circle.add(x, y);</span>
<span class="fc" id="L1585">            added.add(p);</span>
        }
        
<span class="fc" id="L1588">        return circle;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
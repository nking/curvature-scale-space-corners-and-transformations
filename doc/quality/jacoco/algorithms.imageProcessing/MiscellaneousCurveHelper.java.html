<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MiscellaneousCurveHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">MiscellaneousCurveHelper.java</span></div><h1>MiscellaneousCurveHelper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.convexHull.GrahamScanPairInt;
import algorithms.compGeometry.convexHull.GrahamScanTooFewPointsException;
import algorithms.imageProcessing.scaleSpace.CurvatureScaleSpaceContour;
import algorithms.imageProcessing.transform.TransformationParameters;
import algorithms.imageProcessing.transform.Transformer;
import algorithms.imageProcessing.util.AngleUtil;
import algorithms.imageProcessing.util.PairIntWithIndex0;
import algorithms.misc.AverageUtil;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PairIntArrayComparator;
import algorithms.util.PairFloatArray;
import algorithms.util.PairInt;
import algorithms.util.PairIntArrayWithColor;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.set.TIntSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;
import no.uib.cipr.matrix.Matrix;
import no.uib.cipr.matrix.MatrixEntry;

/**
 *
 * @author nichole
 */
<span class="fc" id="L36">public class MiscellaneousCurveHelper {</span>

<span class="fc" id="L38">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    // choosing a minimum size empirically from looking at edges in tests
<span class="fc" id="L41">    private static int minLedgeWidth = 4;</span>

<span class="fc" id="L43">    protected static final int[] eightNeighborsX =</span>
        new int[]{-1, -1,  0,  1, 1, 1, 0, -1};
<span class="fc" id="L45">    protected static final int[] eightNeighborsY =</span>
        new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner 
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise(PairIntArray closedCurve) {

<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L65">            return false;</span>
        }

<span class="fc" id="L68">        int nNeg = 0;</span>
<span class="fc" id="L69">        int n = closedCurve.getN();</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>

            long xm1, ym1, x, y, xp1, yp1;

<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L76">                xm1 = closedCurve.getX(closedCurve.getN() - 1);</span>
<span class="fc" id="L77">                ym1 = closedCurve.getY(closedCurve.getN() - 1);</span>
<span class="fc" id="L78">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L79">                yp1 = closedCurve.getY(i + 1);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">            } else if (i == (closedCurve.getN() - 1)) {</span>
<span class="fc" id="L81">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L82">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L83">                xp1 = closedCurve.getX(0);</span>
<span class="fc" id="L84">                yp1 = closedCurve.getY(0);</span>
            } else {
<span class="fc" id="L86">                xm1 = closedCurve.getX(i - 1);</span>
<span class="fc" id="L87">                ym1 = closedCurve.getY(i - 1);</span>
<span class="fc" id="L88">                xp1 = closedCurve.getX(i + 1);</span>
<span class="fc" id="L89">                yp1 = closedCurve.getY(i + 1);</span>
            }
<span class="fc" id="L91">            x = closedCurve.getX(i);</span>
<span class="fc" id="L92">            y = closedCurve.getY(i);</span>

<span class="fc" id="L94">            long dxmxm1 = (x - xm1);</span>
<span class="fc" id="L95">            long dymym1 = (y - ym1);</span>
<span class="fc" id="L96">            long dxp1mx = (xp1 - x);</span>
<span class="fc" id="L97">            long dyp1my = (yp1 - y);</span>

            //(xi - xi-1) * (yi+1 - yi) - (yi - yi-1) * (xi+1 - xi)
<span class="fc" id="L100">            long crossProduct = (dxmxm1 * dyp1my) - (dymym1 * dxp1mx);</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (crossProduct &lt; 0) {</span>
                // clockwise when crossProduct is negative
<span class="fc" id="L104">                nNeg++;</span>
            }
        }

<span class="fc" id="L108">        int nPos = n - nNeg;//n - 2 - nNeg;</span>

        //log.info(closedCurve.toString());
        //log.info(&quot;n=&quot; + n + &quot; nNegative=&quot; + nNeg + &quot; nPositive=&quot; + nPos);

<span class="pc bpc" id="L113" title="1 of 6 branches missed.">        return ((n &gt; 2) &amp;&amp; (nNeg &gt;= nPos)) || (nNeg &gt; nPos);</span>
     }

    /**
     * determine whether the closed curve points are ordered in a counter clockwise
     * manner by first computing the convex hull then
     * calculating the cross product between adjacent edges in sequence around
     * the polygon to determine if there are fewer that are positive (CCW)
     * than negative (CW).
     * The given closedCurve cannot intersect itself or have holes in it.
     * NOTE: the answer returns true if the points are ordered in CW manner, but
     * if one needs the answer w.r.t. viewing an image which has y increasing
     * downward, need the opposite of the return here.
     *
     * @param closedCurve
     * @return
     */
    public boolean curveIsOrderedClockwise2(PairIntArray closedCurve) {

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (closedCurve.getN() &lt; 2) {</span>
<span class="nc" id="L133">            return false;</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        } else if (closedCurve.getN() &lt; 4) {</span>
<span class="nc" id="L135">            return curveIsOrderedClockwise(closedCurve);</span>
        }
        
<span class="fc" id="L138">        int n = closedCurve.getN();</span>
        
<span class="fc" id="L140">        PairIntWithIndex0[] p = new PairIntWithIndex0[n];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L142">            p[i] = new PairIntWithIndex0(closedCurve.getX(i), closedCurve.getY(i),  i);</span>
        }
        
<span class="fc" id="L145">        GrahamScanPairInt&lt;PairIntWithIndex0&gt; scan = new GrahamScanPairInt&lt;PairIntWithIndex0&gt;();</span>
        try {
<span class="fc" id="L147">            scan.computeHull(p);</span>
            
            // hull returns points in clockwise order
            
<span class="fc" id="L151">            n = scan.getHull().size() - 1;</span>
            //PairIntArray hull = new PairIntArray(n);
            //List&lt;Integer&gt; hullCurveIndexes = new ArrayList&lt;Integer&gt;();
            //int[] deltaIndexes = new int[n];
            
            // nPos or nNeg might be 1 and then other n-2 if there is wrap-around
<span class="fc" id="L157">            int nNeg = 0;</span>
<span class="fc" id="L158">            int nPos = 0;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
                
<span class="fc" id="L161">                PairIntWithIndex0 p0 = scan.getHull().get(i);</span>
                
                //hull.add(Math.round(p0.getX()), Math.round(p0.getY()));
                //hullCurveIndexes.add(Integer.valueOf(p0.getPixIndex()));
                
                // for CW input, expect these to be + numbers
<span class="fc" id="L167">                int deltaIndex = scan.getHull().get(i + 1).getPixIndex() - p0.getPixIndex();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">                if (deltaIndex &gt; 0) {</span>
<span class="fc" id="L169">                    nPos++;</span>
                } else {
<span class="fc" id="L171">                    nNeg++;</span>
                }
            }
            
            //boolean isCW = curveIsOrderedClockwise(hull);
            //assert(isCW);
            
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (nPos &gt; nNeg) {</span>
<span class="fc" id="L179">                return true;</span>
            }
            
<span class="fc" id="L182">            return false;</span>
            
<span class="nc" id="L184">        } catch (GrahamScanTooFewPointsException ex) {</span>
<span class="nc" id="L185">            return curveIsOrderedClockwise(closedCurve);</span>
        }
    }

    public void additionalThinning45DegreeEdges(
        GreyscaleImage theta, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>

<span class="nc" id="L204">                int tG = theta.getValue(i, j);</span>

<span class="nc bnc" id="L206" title="All 6 branches missed.">                if (((tG == 45) || (tG == -45)) &amp;&amp; (input.getValue(i, j) &gt; 0)) {</span>

<span class="nc" id="L208">                    int tH0 = theta.getValue(i - 1, j);</span>
<span class="nc" id="L209">                    int tH1 = theta.getValue(i + 1, j);</span>
<span class="nc" id="L210">                    int tV0 = theta.getValue(i, j - 1);</span>
<span class="nc" id="L211">                    int tV1 = theta.getValue(i, j + 1);</span>

<span class="nc" id="L213">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L214">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L215">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L216">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L218" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L220">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L222">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L224" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L226">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L227" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L228">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L234">    }</span>
    
    /**
     * 
     * @param theta image with values in range 0 to 180.
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        double[][] theta, double[][] input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="fc bfc" id="L253" title="All 2 branches covered.">        for (int i = 1; i &lt; (input.length - 1); i++) {</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            for (int j = 1; j &lt; (input[i].length - 1); j++) {</span>

<span class="fc" id="L256">                double vG = input[i][j];</span>
                              
<span class="fc bfc" id="L258" title="All 2 branches covered.">                if (vG &lt;= 0) {</span>
<span class="fc" id="L259">                    continue;</span>
                }
                
<span class="fc" id="L262">                int tG = convert360To45RefFrame((int)Math.round(theta[i][j]));</span>

<span class="fc bfc" id="L264" title="All 4 branches covered.">                if ((Math.abs(tG - 45) &lt; 5) || (Math.abs(tG - -45) &lt; 5)) {</span>

<span class="fc" id="L266">                    int tH0 = convert360To45RefFrame((int)Math.round(theta[i - 1][j]));</span>
<span class="fc" id="L267">                    int tH1 = convert360To45RefFrame((int)Math.round(theta[i + 1][j]));</span>
<span class="fc" id="L268">                    int tV0 = convert360To45RefFrame((int)Math.round(theta[i][j - 1]));</span>
<span class="fc" id="L269">                    int tV1 = convert360To45RefFrame((int)Math.round(theta[i][j + 1]));</span>

<span class="fc" id="L271">                    double gH0 = input[i - 1][j];</span>
<span class="fc" id="L272">                    double gH1 = input[i + 1][j];</span>
<span class="fc" id="L273">                    double gV0 = input[i][j - 1];</span>
<span class="fc" id="L274">                    double gV1 = input[i][j + 1];</span>

<span class="fc bfc" id="L276" title="All 4 branches covered.">                    if ((gH0 &gt; 0) &amp;&amp; (Math.abs(tH0 - tG) &lt; 5)) {</span>
<span class="fc bfc" id="L277" title="All 4 branches covered.">                        if ((gV0 &gt; 0) &amp;&amp; (Math.abs(tV0 - tG) &lt; 5)) {</span>
<span class="fc" id="L278">                            input[i][j] = 0;</span>
<span class="fc bfc" id="L279" title="All 4 branches covered.">                        } else if ((gV1 &gt; 0) &amp;&amp; (Math.abs(tV1 - tG) &lt; 5)) {</span>
<span class="fc" id="L280">                            input[i][j] = 0;</span>
                        }
<span class="fc bfc" id="L282" title="All 4 branches covered.">                    } else if ((gH1 &gt; 0) &amp;&amp; (Math.abs(tH1 - tG) &lt; 5)) {</span>
<span class="fc bfc" id="L283" title="All 4 branches covered.">                        if ((gV0 &gt; 0) &amp;&amp; (Math.abs(tV0 - tG) &lt; 5)) {</span>
<span class="fc" id="L284">                            input[i][j] = 0;</span>
<span class="fc bfc" id="L285" title="All 4 branches covered.">                        } else if ((gV1 &gt; 0) &amp;&amp; (Math.abs(tV1 - tG) &lt; 5)) {</span>
<span class="fc" id="L286">                            input[i][j] = 0;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L292">    }</span>
    
    /**
         *           Y
         *          90
         *     135   |    +45
         *           |
         *   180------------ 0   X
         *           |
         *    225    |   315
         *          270
         * 
         *  -45    90    45          y/x
                -  |  +
            0 -----|----- 0
                +  |  -
            45    90    -45
        
     * @param angle360
     * @return 
     */
    private int convert360To45RefFrame(int angle360) {
        
<span class="fc bfc" id="L315" title="All 4 branches covered.">        if ((angle360 &lt; 23) || (angle360 &gt; 337)) {</span>
<span class="fc" id="L316">            return 0;</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">        } else if ((angle360 &gt; 157) &amp;&amp; (angle360 &lt; 203)) {</span>
<span class="fc" id="L318">            return 0;</span>
<span class="pc bpc" id="L319" title="1 of 8 branches missed.">        } else  if (((angle360 &gt; 22) &amp;&amp; (angle360 &lt; 68)) || </span>
            ((angle360 &gt; 202) &amp;&amp; (angle360 &lt; 248))) {
            // in range of +45 or +225
<span class="fc" id="L322">            return 45;</span>
<span class="pc bpc" id="L323" title="1 of 8 branches missed.">        } else if (((angle360 &gt; 67) &amp;&amp; (angle360 &lt; 113)) || </span>
            ((angle360 &gt; 247) &amp;&amp; (angle360 &lt; 293))) {
            // in range of +90 or +270
<span class="fc" id="L326">            return 90;</span>
        } else { //if (((t &gt; 112) &amp;&amp; (t &lt; 158)) || ((t &gt; 292) &amp;&amp; (t &lt; 338))) {
            // in range of +135 or +315
<span class="fc" id="L329">            return -45;</span>
        }
    }
    
    /**
     * thin a line that is the product in a canny edge detector, given
     * a theta image which has values between 0 and 360.
     * @param theta3602
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        GreyscaleImage theta3602, GreyscaleImage input) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="nc bnc" id="L351" title="All 2 branches missed.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>
                
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if (input.getValue(i, j) == 0) {</span>
<span class="nc" id="L355">                    continue;</span>
                }

<span class="nc" id="L358">                int tG = convert360To45RefFrame(theta3602.getValue(i, j));</span>

<span class="nc bnc" id="L360" title="All 4 branches missed.">                if ((tG == 45) || (tG == -45)) {</span>

<span class="nc" id="L362">                    int tH0 = convert360To45RefFrame(theta3602.getValue(i - 1, j));</span>
<span class="nc" id="L363">                    int tH1 = convert360To45RefFrame(theta3602.getValue(i + 1, j));</span>
<span class="nc" id="L364">                    int tV0 = convert360To45RefFrame(theta3602.getValue(i, j - 1));</span>
<span class="nc" id="L365">                    int tV1 = convert360To45RefFrame(theta3602.getValue(i, j + 1));</span>

<span class="nc" id="L367">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="nc" id="L368">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="nc" id="L369">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="nc" id="L370">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="nc bnc" id="L372" title="All 4 branches missed.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L374">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L376">                            input.setValue(i, j, 0);</span>
                        }
<span class="nc bnc" id="L378" title="All 4 branches missed.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L380">                            input.setValue(i, j, 0);</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L382">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L388">    }</span>
    
    /**
     * thin a line that is the product in a canny edge detector, given
     * a theta image which has values between 0 and 360.
     * @param theta3602
     * @param input 
     */
    public void additionalThinning45DegreeEdges2(
        GreyscaleImage theta3602, GreyscaleImage input, double minResolvableAngle) {

        // thin the edges for angles 45 and -45 as suggested by
        // 1998 Mokhtarian and Suomela
        // IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE,
        //     VOL. 20, NO. 12
        //
        //compare each edge pixel which has an edge orientation of
        // 45o or -45o to one of its horizontal or vertical neighbors.
        // If the neighbor has the same orientation, the other point can be
        // removed.
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (int i = 1; i &lt; (input.getWidth() - 1); i++) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">            for (int j = 1; j &lt; (input.getHeight() - 1); j++) {</span>
                
<span class="fc bfc" id="L411" title="All 2 branches covered.">                if (input.getValue(i, j) == 0) {</span>
<span class="fc" id="L412">                    continue;</span>
                }
                
<span class="fc" id="L415">                int t = theta3602.getValue(i, j);</span>
                
<span class="fc bfc" id="L417" title="All 2 branches covered.">                if ((Math.abs(t - 0) &lt; minResolvableAngle) || </span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                    (Math.abs(180 - t) &lt; minResolvableAngle) || </span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">                    (Math.abs(360 - t) &lt; minResolvableAngle)) {</span>
                    // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L421">                    t = 90;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">                } else if ((Math.abs(90 - t) &lt; minResolvableAngle) ||</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">                    (Math.abs(270 - t) &lt; minResolvableAngle) ) {</span>
                    // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L425">                    t = 180;</span>
                }

<span class="fc" id="L428">                int tG = convert360To45RefFrame(t);</span>

<span class="fc bfc" id="L430" title="All 4 branches covered.">                if ((tG == 45) || (tG == -45)) {</span>

<span class="fc" id="L432">                    int tH0 = theta3602.getValue(i - 1, j);</span>
<span class="fc" id="L433">                    int tH1 = theta3602.getValue(i + 1, j);</span>
<span class="fc" id="L434">                    int tV0 = theta3602.getValue(i, j - 1);</span>
<span class="fc" id="L435">                    int tV1 = theta3602.getValue(i, j + 1);</span>
                    
<span class="fc bfc" id="L437" title="All 2 branches covered.">                    if ((Math.abs(tH0 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                        || (Math.abs(180 - tH0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">                        || (Math.abs(360 - tH0) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L441">                        tH0 = 90;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tH0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                        || (Math.abs(270 - tH0) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L445">                        tH0 = 180;</span>
                    }
<span class="fc bfc" id="L447" title="All 2 branches covered.">                    if ((Math.abs(tH1 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                        || (Math.abs(180 - tH1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">                        || (Math.abs(360 - tH1) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L451">                        tH1 = 90;</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tH1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                        || (Math.abs(270 - tH1) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L455">                        tH1 = 180;</span>
                    }
<span class="fc bfc" id="L457" title="All 2 branches covered.">                    if ((Math.abs(tV0 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                        || (Math.abs(180 - tV0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">                        || (Math.abs(360 - tV0) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L461">                        tV0 = 90;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tV0) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">                        || (Math.abs(270 - tV0) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L465">                        tV0 = 180;</span>
                    }
<span class="fc bfc" id="L467" title="All 2 branches covered.">                    if ((Math.abs(tV1 - 0) &lt; minResolvableAngle)</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                        || (Math.abs(180 - tV1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                        || (Math.abs(360 - tV1) &lt; minResolvableAngle)) {</span>
                        // measured 0 or 180, but should be 90 or 270
<span class="fc" id="L471">                        tV1 = 90;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    } else if ((Math.abs(90 - tV1) &lt; minResolvableAngle)</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">                        || (Math.abs(270 - tV1) &lt; minResolvableAngle)) {</span>
                        // measured 90 or 270, but should be 0 or 180
<span class="fc" id="L475">                        tV1 = 180;</span>
                    }
                    
<span class="fc" id="L478">                    tH0 = convert360To45RefFrame(tH0);</span>
<span class="fc" id="L479">                    tH1 = convert360To45RefFrame(tH1);</span>
<span class="fc" id="L480">                    tV0 = convert360To45RefFrame(tV0);</span>
<span class="fc" id="L481">                    tV1 = convert360To45RefFrame(tV1);</span>
                    
<span class="fc" id="L483">                    int gH0 = input.getValue(i - 1, j);</span>
<span class="fc" id="L484">                    int gH1 = input.getValue(i + 1, j);</span>
<span class="fc" id="L485">                    int gV0 = input.getValue(i, j - 1);</span>
<span class="fc" id="L486">                    int gV1 = input.getValue(i, j + 1);</span>

<span class="fc bfc" id="L488" title="All 4 branches covered.">                    if ((tH0 == tG) &amp;&amp; (gH0 &gt; 0)) {</span>
<span class="pc bpc" id="L489" title="1 of 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L490">                            input.setValue(i, j, 0);</span>
<span class="pc bpc" id="L491" title="1 of 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L492">                            input.setValue(i, j, 0);</span>
                        }
<span class="fc bfc" id="L494" title="All 4 branches covered.">                    } else if ((tH1 == tG) &amp;&amp; (gH1 &gt; 0)) {</span>
<span class="pc bpc" id="L495" title="1 of 4 branches missed.">                        if ((tV0 == tG) &amp;&amp; (gV0 &gt; 0)) {</span>
<span class="nc" id="L496">                            input.setValue(i, j, 0);</span>
<span class="pc bpc" id="L497" title="1 of 4 branches missed.">                        } else if ((tV1 == tG) &amp;&amp; (gV1 &gt; 0)) {</span>
<span class="nc" id="L498">                            input.setValue(i, j, 0);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L504">    }</span>

    /**
     * given 2 edges, return true if they overlap. If they overlap
     * curve0 is given the larger curve and any outlying points.
     * @param curve0
     * @param curve1
     * @return
     */
    protected boolean processOverlappingPair(PairIntArrayWithColor curve0,
        PairIntArrayWithColor curve1) {

<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        boolean longerIsNode0 = (curve0.getN() &gt;= curve1.getN());</span>

        PairIntArray longer, shorter;
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (longerIsNode0) {</span>
<span class="fc" id="L520">            longer = curve0;</span>
<span class="fc" id="L521">            shorter = curve1;</span>
        } else {
<span class="nc" id="L523">            longer = curve1;</span>
<span class="nc" id="L524">            shorter = curve0;</span>
        }

        // used to return the offset w.r.t. the longest edge.
<span class="fc" id="L528">        int[] correlationOffset = new int[1];</span>

        /*
         returns whether the curve 'check' is adjacent to the curve 'node0',
         and if so, returns the offset in the frame of the larger curve.
         the offset represents where the first point in the shorter curve
         matches in the larger curve.
         */
<span class="fc" id="L536">        boolean isAdjacent = correlation(longer, shorter,</span>
            correlationOffset);

<span class="fc bfc" id="L539" title="All 2 branches covered.">        if (isAdjacent) {</span>

            /*
                -- find any points in check outside of the overlap
                   and add those to the larger node.
            */
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">            if (correlationOffset[0] &lt; 0) {</span>
                // add from the beginning of shorter if any are unmatched
<span class="nc" id="L547">                int nInsert = -1*correlationOffset[0];</span>
<span class="nc" id="L548">                longer.insertSpaceAtTopOfArrays(nInsert);</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">                for (int ii = 0; ii &lt; nInsert; ii++) {</span>
<span class="nc" id="L551">                    longer.set(ii, shorter.getX(ii), shorter.getY(ii));</span>
                }
<span class="nc" id="L553">            } else {</span>
                //add from end of shorter if any are unmatched
<span class="fc" id="L555">                int n0 = longer.getN() - correlationOffset[0];</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">                if (n0 &lt; shorter.getN()) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                    for (int ii = n0; ii &lt; shorter.getN(); ii++) {</span>
<span class="fc" id="L558">                        longer.add(shorter.getX(ii), shorter.getY(ii));</span>
                    }
                }
            }

<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (!longerIsNode0) {</span>
<span class="nc" id="L564">                curve0.swapContents(curve1);</span>
            }

<span class="fc" id="L567">            return true;</span>
        }

<span class="fc" id="L570">        return false;</span>
    }

    /**
     * return true if correlation shows that the 2 curves are adjacent
     * to one another.  Note that the method needs the points within the
     * curves to be ordered in a similar manner and for the endpoints of the
     * curves to be accurate.  If a point in the middle of the curve is
     * the first or last point, it may prevent comparison of it with another
     * edge's endpoints.
     *
     * @param curve0
     * @param curve1
     * @param correlationOffset offset of where the shorter curve starts
     *  with respect to the longer.  For example, an offset of -2 means that
     * the first 2 points in the shorter curve are outside of the longer curve,
     * but the next point in the longer curve is adjacent to the shorter.
     * Another example: if offset is +2, the first pixel in the shorter curve
     * is adjacent to the third pixel in the longer curve.  NOTE: the offset
     * is only useful if this method returns true;
     * @return
     */
    protected boolean correlation(PairIntArray curve0, PairIntArray curve1,
        int[] correlationOffset) {

<span class="fc" id="L595">        correlationOffset[0] = Integer.MAX_VALUE;</span>

        //TODO: look at string matching algorithms to explore improvements here

        PairIntArray shorter, longer;
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (curve0.getN() &lt;= curve1.getN()) {</span>
<span class="fc" id="L601">            shorter = curve0;</span>
<span class="fc" id="L602">            longer = curve1;</span>
        } else {
<span class="fc" id="L604">            shorter = curve1;</span>
<span class="fc" id="L605">            longer = curve0;</span>
        }

        /*
        len0 = 5; len1 = 11;
         #####
             +++++++++++
          #####
             +++++++++++
           #####
             +++++++++++
            #####
             +++++++++++
             #####
             +++++++++++

             #####
             +++++++++++

                       #####
             +++++++++++

        ccs = sqrt(sumsqdiff)/nOverlapping if nOverlapping &gt; 0.

        if (css &lt;= 1 pix * nOverlapping) {
            store as a possible adjacent curve
        }
        compare possible adjacent curves for the smallest css, and store that
        offset in correlationOffset and return true, else false
        */

<span class="fc" id="L636">        double cSSMin = Double.MAX_VALUE;</span>
<span class="fc" id="L637">        int cSSMinOffset = Integer.MAX_VALUE;</span>
<span class="fc" id="L638">        int cSSMinNOverlapping = 0;</span>

<span class="fc" id="L640">        double sqrtTwo = Math.sqrt(2);</span>

<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (int i = 0; i &lt; (longer.getN() + shorter.getN() - 1); i++) {</span>
            //siIdx is first index in shorter for comparison
            //sfIdx is last index in shorter for comparison
            //liIdx is first index of longer for comparison
            //lfIdx is last index of longer for comparison
            int siIdx, sfIdx, liIdx, lfIdx, offset;
<span class="fc bfc" id="L648" title="All 2 branches covered.">            if (i &lt; shorter.getN()) {</span>
                /*
                 #####
                     +++++++++++ i=0
                  #####
                     +++++++++++
                   #####
                     +++++++++++
                    #####
                     +++++++++++
                     #####
                     +++++++++++ i=4
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L662">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L663">                siIdx = sfIdx - i;</span>
<span class="fc" id="L664">                liIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L666">                lfIdx = sfIdx - siIdx;</span>
<span class="fc" id="L667">                offset = i - sfIdx;</span>

<span class="fc bfc" id="L669" title="All 2 branches covered.">            } else if (i &lt; longer.getN() ) {</span>

                /*
                      #####
                     +++++++++++  i=5

                       #####
                     +++++++++++

                        #####
                     +++++++++++

                         #####
                     +++++++++++

                          #####
                     +++++++++++

                           #####
                     +++++++++++ i = 10
                */
                //sfIdx is inclusive endpoint
<span class="fc" id="L691">                sfIdx = shorter.getN() - 1;</span>
<span class="fc" id="L692">                siIdx = 0;</span>
<span class="fc" id="L693">                liIdx = i - shorter.getN() + 1;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L695">                lfIdx = liIdx + shorter.getN() - 1;</span>
<span class="fc" id="L696">                offset = i - sfIdx;</span>

            } else {
                /*
                            #####
                     +++++++++++ i = 12
                     01234567890
                             #####
                     +++++++++++

                              #####
                     +++++++++++

                               #####
                     +++++++++++ i=15
                     01234567890
                */
<span class="fc" id="L713">                liIdx = i - shorter.getN() + 1;</span>
                //sfIdx is inclusive endpoint
<span class="fc" id="L715">                sfIdx = longer.getN() - liIdx - 1;</span>
<span class="fc" id="L716">                siIdx = 0;</span>
                //lfIdx is inclusive endpoint
<span class="fc" id="L718">                lfIdx = liIdx + (sfIdx - siIdx);</span>
<span class="fc" id="L719">                offset = liIdx;</span>

            }

<span class="fc" id="L723">            int nOverLapping = (sfIdx - siIdx) + 1;</span>

<span class="pc bpc" id="L725" title="1 of 2 branches missed.">            if ((sfIdx - siIdx) != (lfIdx - liIdx)) {</span>
<span class="nc" id="L726">                throw new IllegalStateException(</span>
                    &quot;sample ranges are not correct&quot;);
            }

<span class="fc" id="L730">            double sumSq = 0;</span>

<span class="fc" id="L732">            int s = siIdx;</span>
<span class="fc" id="L733">            int l = liIdx;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            while (s &lt;= sfIdx) {</span>
<span class="fc" id="L735">                int xs = shorter.getX(s);</span>
<span class="fc" id="L736">                int xl = longer.getX(l);</span>
<span class="fc" id="L737">                int dx = xs - xl;</span>
<span class="fc" id="L738">                int ys = shorter.getY(s);</span>
<span class="fc" id="L739">                int yl = longer.getY(l);</span>
<span class="fc" id="L740">                int dy = ys - yl;</span>
<span class="fc" id="L741">                sumSq += ((dx*dx) + (dy*dy));</span>
<span class="fc" id="L742">                s++;</span>
<span class="fc" id="L743">                l++;</span>
<span class="fc" id="L744">            }</span>

<span class="fc" id="L746">            double tmp = Math.sqrt(sumSq/nOverLapping);</span>

            // assuming adjacent pixel has distance of sqrt(2) at the most
<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (tmp &lt;= sqrtTwo) {</span>

<span class="pc bpc" id="L751" title="3 of 6 branches missed.">                if ((tmp &lt; cSSMin) ||</span>
                (tmp == cSSMin &amp;&amp; (nOverLapping &gt; cSSMinNOverlapping))
                ) {

<span class="fc" id="L755">                    cSSMin = tmp;</span>

<span class="fc" id="L757">                    cSSMinOffset = offset;</span>

<span class="fc" id="L759">                    cSSMinNOverlapping = nOverLapping;</span>
                }
            }
        }

<span class="fc bfc" id="L764" title="All 2 branches covered.">        if (cSSMin &lt; Double.MAX_VALUE) {</span>

<span class="fc" id="L766">            correlationOffset[0] = cSSMinOffset;</span>

<span class="fc" id="L768">            return true;</span>
        }

<span class="fc" id="L771">        return false;</span>
    }

    /**
     * find the index where x is minimum value of closedCurve.  Note that when
     * there are more than one points with the same minimum x value, the point
     * with a smaller y is chosen.
     *
     * @param closedCurve
     * @return
     */
    public int findMinIdx(PairIntArray closedCurve) {

<span class="fc" id="L784">        int xMin = Integer.MAX_VALUE;</span>
<span class="fc" id="L785">        int xMax = Integer.MIN_VALUE;</span>

<span class="fc" id="L787">        int xMinIdx = -1;</span>
<span class="fc" id="L788">        int xMaxIdx = -1;</span>

        // find xMin.  when xMin==x, use yMin too.  similar pattern for maxes
<span class="fc bfc" id="L791" title="All 2 branches covered.">        for (int i = 0; i &lt; closedCurve.getN(); i++) {</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">            if (closedCurve.getX(i) &lt; xMin) {</span>
<span class="fc" id="L793">                xMin = closedCurve.getX(i);</span>
<span class="fc" id="L794">                xMinIdx = i;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">            } else if (closedCurve.getX(i) == xMin) {</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">                if (closedCurve.getY(i) &lt; closedCurve.getY(xMinIdx)) {</span>
<span class="fc" id="L797">                    xMin = closedCurve.getX(i);</span>
<span class="fc" id="L798">                    xMinIdx = i;</span>
                }
            }
<span class="fc bfc" id="L801" title="All 2 branches covered.">            if (closedCurve.getX(i) &gt; xMax) {</span>
<span class="fc" id="L802">                xMax = closedCurve.getX(i);</span>
<span class="fc" id="L803">                xMaxIdx = i;</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">            } else if (closedCurve.getX(i) == xMax) {</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">                if (closedCurve.getY(i) &gt; closedCurve.getY(xMaxIdx)) {</span>
<span class="nc" id="L806">                    xMax = closedCurve.getX(i);</span>
<span class="nc" id="L807">                    xMaxIdx = i;</span>
                }
            }
        }

<span class="fc" id="L812">        return xMinIdx;</span>
    }
    
    public double[] calculateXYCentroids1(List&lt;CurvatureScaleSpaceContour&gt; list) {
        
<span class="nc" id="L817">        double xc = 0;</span>
<span class="nc" id="L818">        double yc = 0;</span>

<span class="nc bnc" id="L820" title="All 2 branches missed.">        for (CurvatureScaleSpaceContour cr : list) {</span>
<span class="nc" id="L821">            double x = cr.getPeakDetails()[0].getXCoord();</span>
<span class="nc" id="L822">            double y = cr.getPeakDetails()[0].getYCoord();</span>
<span class="nc" id="L823">            xc += x;</span>
<span class="nc" id="L824">            yc += y;</span>
<span class="nc" id="L825">        }</span>
<span class="nc" id="L826">        xc /= (double)list.size();</span>
<span class="nc" id="L827">        yc /= (double)list.size();</span>

<span class="nc" id="L829">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy, float[] weights) {

<span class="fc" id="L834">        double xc = 0;</span>
<span class="fc" id="L835">        double yc = 0;</span>

<span class="fc bfc" id="L837" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>
<span class="fc" id="L838">            double x1 = xy.getX(i);</span>
<span class="fc" id="L839">            xc += (weights[i] * x1);</span>

<span class="fc" id="L841">            double y1 = xy.getY(i);</span>
<span class="fc" id="L842">            yc += (weights[i] * y1);</span>
        }

<span class="fc" id="L845">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairIntArray xy) {

<span class="fc" id="L850">        double xc = 0;</span>
<span class="fc" id="L851">        double yc = 0;</span>

<span class="fc bfc" id="L853" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="fc" id="L855">            xc += xy.getX(i);</span>

<span class="fc" id="L857">            yc += xy.getY(i);</span>
        }

<span class="fc" id="L860">        xc /= (double)xy.getN();</span>

<span class="fc" id="L862">        yc /= (double)xy.getN();</span>

<span class="fc" id="L864">        return new double[]{xc, yc};</span>
    }

    /**
     * calculate the x and y centroids and return as
     * double[]{xCentroid, yCentroid}
     * @param xy a 3 x N matrix with column 0 being x and column 1 being y.
     * @return
     */
    public double[] calculateXYCentroids(Matrix xy) {

<span class="fc" id="L875">        double xc = 0;</span>
<span class="fc" id="L876">        double yc = 0;</span>

<span class="fc" id="L878">        int n = xy.numColumns();</span>

<span class="fc" id="L880">        Iterator&lt;MatrixEntry&gt; iter = xy.iterator();</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L882">            MatrixEntry entry = iter.next();</span>
<span class="fc" id="L883">            xc += entry.column();</span>
<span class="fc" id="L884">            yc += entry.row();</span>
<span class="fc" id="L885">        }</span>

<span class="fc" id="L887">        xc /= (double)n;</span>

<span class="fc" id="L889">        yc /= (double)n;</span>

<span class="fc" id="L891">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(PairFloatArray xy) {

<span class="nc" id="L896">        double xc = 0;</span>
<span class="nc" id="L897">        double yc = 0;</span>

<span class="nc bnc" id="L899" title="All 2 branches missed.">        for (int i = 0; i &lt; xy.getN(); i++) {</span>

<span class="nc" id="L901">            xc += xy.getX(i);</span>

<span class="nc" id="L903">            yc += xy.getY(i);</span>
        }

<span class="nc" id="L906">        xc /= (double)xy.getN();</span>

<span class="nc" id="L908">        yc /= (double)xy.getN();</span>

<span class="nc" id="L910">        return new double[]{xc, yc};</span>
    }

    public double[] calculateXYCentroids(List&lt;PairIntArray&gt; xyList) {

<span class="nc" id="L915">        double xc = 0;</span>
<span class="nc" id="L916">        double yc = 0;</span>

<span class="nc bnc" id="L918" title="All 2 branches missed.">        for (PairIntArray points : xyList) {</span>

<span class="nc" id="L920">            double[] xycen = calculateXYCentroids(points);</span>

<span class="nc" id="L922">            xc += xycen[0];</span>
<span class="nc" id="L923">            yc += xycen[1];</span>
<span class="nc" id="L924">        }</span>

<span class="nc" id="L926">        xc /= (double)xyList.size();</span>
<span class="nc" id="L927">        yc /= (double)xyList.size();</span>

<span class="nc" id="L929">        return new double[]{xc, yc};</span>
    }

    public PairInt calculateXYCentroids2(Collection&lt;PairInt&gt; points) {
        
<span class="nc" id="L934">        double[] xyCen = calculateXYCentroids(points);</span>
        
<span class="nc" id="L936">        PairInt p = new PairInt((int)Math.round(xyCen[0]), (int)Math.round(xyCen[1]));</span>
        
<span class="nc" id="L938">        return p;</span>
    }
    
    public double[] calculateXYCentroids(Collection&lt;PairInt&gt; points) {

<span class="fc" id="L943">        double xc = 0;</span>
<span class="fc" id="L944">        double yc = 0;</span>

<span class="fc bfc" id="L946" title="All 2 branches covered.">        for (PairInt p : points) {</span>

<span class="fc" id="L948">           int x = p.getX();</span>
<span class="fc" id="L949">           int y = p.getY();</span>

<span class="fc" id="L951">            xc += x;</span>
<span class="fc" id="L952">            yc += y;</span>
<span class="fc" id="L953">        }</span>

<span class="fc" id="L955">        xc /= (double)(points.size());</span>

<span class="fc" id="L957">        yc /= (double)(points.size());</span>

<span class="fc" id="L959">        return new double[]{xc, yc};</span>
    }

    public int[] calculateRoundedXYCentroids(Set&lt;PairInt&gt; points) {

<span class="fc" id="L964">        double[] xyCen = calculateXYCentroids(points);</span>

<span class="fc" id="L966">        int[] out = new int[2];</span>
<span class="fc" id="L967">        out[0] = (int)Math.round(xyCen[0]);</span>
<span class="fc" id="L968">        out[1] = (int)Math.round(xyCen[1]);</span>

<span class="fc" id="L970">        return out;</span>
    }
    
    public int[] calculateRoundedXYCentroids(TIntSet pixelIdxs, int imgWidth) {

<span class="fc" id="L975">        double xc = 0;</span>
<span class="fc" id="L976">        double yc = 0;</span>

<span class="fc" id="L978">        TIntIterator iter = pixelIdxs.iterator();</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">        while (iter.hasNext()) {</span>

<span class="fc" id="L981">            int pixIdx = iter.next();</span>
            
<span class="fc" id="L983">            int y = pixIdx/imgWidth;</span>
<span class="fc" id="L984">            int x = pixIdx - (y * imgWidth);</span>
            
<span class="fc" id="L986">            xc += x;</span>
<span class="fc" id="L987">            yc += y;</span>
<span class="fc" id="L988">        }</span>

<span class="fc" id="L990">        xc /= (double)pixelIdxs.size();</span>
<span class="fc" id="L991">        yc /= (double)pixelIdxs.size();</span>
        
<span class="fc" id="L993">        int[] out = new int[2];</span>
<span class="fc" id="L994">        out[0] = (int)Math.round(xc);</span>
<span class="fc" id="L995">        out[1] = (int)Math.round(yc);</span>

<span class="fc" id="L997">        return out;</span>
    }

    public double[] calculateXYCentroids(float[] x, float[] y) {

<span class="nc bnc" id="L1002" title="All 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L1003">            throw new IllegalArgumentException(&quot;x cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L1006">            throw new IllegalArgumentException(&quot;y cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L1009">            throw new IllegalArgumentException(&quot;x and y must be same length&quot;);</span>
        }

<span class="nc" id="L1012">        double xc = 0;</span>
<span class="nc" id="L1013">        double yc = 0;</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">        for (int i = 0; i &lt; x.length; i++) {</span>

<span class="nc" id="L1017">            xc += x[i];</span>

<span class="nc" id="L1019">            yc += y[i];</span>
        }

<span class="nc" id="L1022">        xc /= (double)(x.length);</span>

<span class="nc" id="L1024">        yc /= (double)(x.length);</span>

<span class="nc" id="L1026">        return new double[]{xc, yc};</span>
    }

    /**
     * does removing the point at idx create a gap between it's neighboring
     * pixels?  this uses the simplest test of only the points at idx-1
     * and idx+1.
     *
     * @param edge
     * @param idx
     * @return
     */
    public boolean doesDisconnect(PairIntArray edge, int idx) {

        // test for endpoints first
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        if (idx == 0) {</span>

<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L1044">                return true;</span>
            }

            // does this point currently connect to the last point?
<span class="nc" id="L1048">            float diffX = edge.getX(idx) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L1050">                diffX *= -1;</span>
            }
<span class="nc" id="L1052">            float diffY = edge.getY(idx) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L1054">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L1056" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the last point in the edge
                // check to see if lastPoint and idx + 1 are adjacent
<span class="nc" id="L1059">                diffX = edge.getX(idx + 1) - edge.getX(edge.getN() - 1);</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L1061">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L1064">                    return true;</span>
                }

<span class="nc" id="L1067">                diffY = edge.getY(idx + 1) - edge.getY(edge.getN() - 1);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L1069">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L1072">                    return true;</span>
                }
            }
<span class="nc" id="L1075">            return false;</span>
        }

<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (idx == (edge.getN() - 1)) {</span>

<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if (edge.getN() &lt; 3) {</span>
<span class="nc" id="L1081">                return true;</span>
            }

            // does this point currently connect to the first point?
<span class="nc" id="L1085">            float diffX = edge.getX(idx) - edge.getX(0);</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L1087">                diffX *= -1;</span>
            }
<span class="nc" id="L1089">            float diffY = edge.getY(idx) - edge.getY(0);</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L1091">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L1093" title="All 4 branches missed.">            if (((diffX &lt; 2) &amp;&amp; (diffY &lt; 2))) {</span>
                // this is connected to the first point in the edge
                // check to see if lastPoint - 1 and first point are adjacent
<span class="nc" id="L1096">                diffX = edge.getX(idx - 1) - edge.getX(0);</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if (diffX &lt; 0) {</span>
<span class="nc" id="L1098">                    diffX *= -1;</span>
                }
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                if (diffX &gt; 1) {</span>
<span class="nc" id="L1101">                    return true;</span>
                }

<span class="nc" id="L1104">                diffY = edge.getY(idx - 1) - edge.getY(0);</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                if (diffY &lt; 0) {</span>
<span class="nc" id="L1106">                    diffY *= -1;</span>
                }
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                if (diffY &gt; 1) {</span>
<span class="nc" id="L1109">                    return true;</span>
                }
            }
<span class="nc" id="L1112">            return false;</span>
        }

<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if ((idx + 1) &lt; edge.getN()) {</span>
<span class="nc" id="L1116">            float diffX = edge.getX(idx - 1) - edge.getX(idx + 1);</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if (diffX &lt; 0) {</span>
<span class="nc" id="L1118">                diffX *= -1;</span>
            }
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L1121">                return true;</span>
            }

<span class="nc" id="L1124">            float diffY = edge.getY(idx - 1) - edge.getY(idx + 1);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            if (diffY &lt; 0) {</span>
<span class="nc" id="L1126">                diffY *= -1;</span>
            }
<span class="nc bnc" id="L1128" title="All 2 branches missed.">            if (diffY &gt; 1) {</span>
<span class="nc" id="L1129">                return true;</span>
            }

<span class="nc" id="L1132">            return false;</span>
        }

<span class="nc" id="L1135">        return false;</span>
    }

    public double distanceFromPointToALine(float lineX0, float lineY0,
        float lineX1, float lineY1, float xP, float yP) {

        /*
        en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

        for the edge, we have the 2 points (lineX0, lineY0) and (lineX1, lineY1)

        distance between that edge and a point (xP, yP) is

        defining diffX = lineX1 - lineX0
                 diffY = lineY1 - lineY0;

        d =
           ( diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0 )
           ( --------------------------------------------------- )
           (         (diffX*diffX + diffY*diffY)^0.5             )
        )
        */

<span class="fc" id="L1158">        float diffX = lineX1 - lineX0;</span>
<span class="fc" id="L1159">        float diffY = lineY1 - lineY0;</span>

<span class="fc bfc" id="L1161" title="All 2 branches covered.">        if (diffY == 0) {</span>
            // horizontal line
<span class="fc" id="L1163">            return Math.abs(yP - lineY0);</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">        } else if (diffX == 0) {</span>
            // vertical line
<span class="fc" id="L1166">            return Math.abs(xP - lineX0);</span>
        }

<span class="fc" id="L1169">        double pt1 = Math.abs(diffY*xP - diffX*yP - lineX0*lineY1 + lineX1*lineY0);</span>

<span class="fc" id="L1171">        double pt2 = Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="fc" id="L1173">        double dist = pt1/pt2;</span>

<span class="fc" id="L1175">        return dist;</span>
    }

    public void sortByX(PairIntArray curve) {
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">        if (curve.getN() &lt; 2) {</span>
<span class="nc" id="L1180">            return;</span>
        }
<span class="fc" id="L1182">        sortByX(curve, 0, curve.getN() - 1);</span>
<span class="fc" id="L1183">    }</span>

    private void sortByX(PairIntArray curve, int idxLo, int idxHi) {
<span class="fc bfc" id="L1186" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1187">            int idxMid = partitionByX(curve, idxLo, idxHi);</span>
<span class="fc" id="L1188">            sortByX(curve, idxLo, idxMid - 1);</span>
<span class="fc" id="L1189">            sortByX(curve, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1191">    }</span>

    private int partitionByX(PairIntArray curve, int idxLo, int idxHi) {

<span class="fc" id="L1195">        int x = curve.getX(idxHi);  //for comparison</span>
<span class="fc" id="L1196">        int store = idxLo - 1;      //store to swap after pivot</span>

<span class="fc bfc" id="L1198" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">            if (curve.getX(i) &lt;= x) {</span>
<span class="fc" id="L1200">                store++;</span>
<span class="fc" id="L1201">                int swapX = curve.getX(store);</span>
<span class="fc" id="L1202">                int swapY = curve.getY(store);</span>
<span class="fc" id="L1203">                curve.set(store, curve.getX(i), curve.getY(i));</span>
<span class="fc" id="L1204">                curve.set(i, swapX, swapY);</span>
            }
        }
<span class="fc" id="L1207">        store++;</span>

<span class="fc" id="L1209">        int swapX = curve.getX(store);</span>
<span class="fc" id="L1210">        int swapY = curve.getY(store);</span>
<span class="fc" id="L1211">        curve.set(store, curve.getX(idxHi), curve.getY(idxHi));</span>
<span class="fc" id="L1212">        curve.set(idxHi, swapX, swapY);</span>

<span class="fc" id="L1214">        return store;</span>
    }

    public PairInt[] findClosestPair(Set&lt;PairInt&gt; set0, Set&lt;PairInt&gt; set1) {

<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (set0 == null) {</span>
<span class="nc" id="L1220">            throw new IllegalArgumentException(&quot;set0 cannot be null&quot;);</span>
        }

<span class="nc bnc" id="L1223" title="All 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L1224">            throw new IllegalArgumentException(&quot;set1 cannot be null&quot;);</span>
        }

<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (set0.isEmpty()) {</span>
<span class="nc" id="L1228">            throw new IllegalArgumentException(&quot;set0 cannot be empty&quot;);</span>
        }

<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if (set1.isEmpty()) {</span>
<span class="nc" id="L1232">            throw new IllegalArgumentException(&quot;set1 cannot be empty&quot;);</span>
        }

        //TODO: consider other algorithms besides brute force

<span class="nc" id="L1237">        double minDistSq = Double.MAX_VALUE;</span>
<span class="nc" id="L1238">        PairInt p0 = null;</span>
<span class="nc" id="L1239">        PairInt p1 = null;</span>

<span class="nc bnc" id="L1241" title="All 2 branches missed.">        for (PairInt s0 : set0) {</span>

<span class="nc" id="L1243">            double x = s0.getX();</span>
<span class="nc" id="L1244">            double y = s0.getY();</span>

<span class="nc bnc" id="L1246" title="All 2 branches missed.">            for (PairInt s1 : set1) {</span>

<span class="nc" id="L1248">                double x1 = s1.getX();</span>
<span class="nc" id="L1249">                double y1 = s1.getY();</span>

<span class="nc" id="L1251">                double diffX = x1 - x;</span>
<span class="nc" id="L1252">                double diffY = y1 - y;</span>

<span class="nc" id="L1254">                double distSq = (diffX * diffX) + (diffY * diffY);</span>

<span class="nc bnc" id="L1256" title="All 2 branches missed.">                if (distSq &lt; minDistSq) {</span>
<span class="nc" id="L1257">                    minDistSq = distSq;</span>
<span class="nc" id="L1258">                    p0 = s0;</span>
<span class="nc" id="L1259">                    p1 = s1;</span>
                }
<span class="nc" id="L1261">            }</span>
<span class="nc" id="L1262">        }</span>

<span class="nc" id="L1264">        return new PairInt[]{p0, p1};</span>
    }

    protected void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; tmpAddedPoints,
        Set&lt;PairInt&gt; tmpRemovedPoints, int imageWidth, int imageHeight) {

<span class="fc" id="L1271">        outputNeighbors.clear();</span>

<span class="fc bfc" id="L1273" title="All 2 branches covered.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="fc" id="L1275">            int x2 = x + eightNeighborsX[i];</span>
<span class="fc" id="L1276">            int y2 = y + eightNeighborsY[i];</span>

<span class="pc bpc" id="L1278" title="4 of 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1280">                continue;</span>
            }

<span class="fc" id="L1283">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="fc bfc" id="L1285" title="All 2 branches covered.">            if (tmpRemovedPoints.contains(p2)) {</span>
<span class="fc" id="L1286">                continue;</span>
            }
<span class="pc bpc" id="L1288" title="1 of 4 branches missed.">            if (tmpAddedPoints.contains(p2) || points.contains(p2)) {</span>
<span class="fc" id="L1289">                outputNeighbors.add(p2);</span>
            }
        }
<span class="fc" id="L1292">    }</span>

    public Set&lt;PairInt&gt; findNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L1296">        Set&lt;PairInt&gt; neighbors = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1300">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1301">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L1303">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1305" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1306">                neighbors.add(p2);</span>
            }
        }

<span class="nc" id="L1310">        return neighbors;</span>
    }
        
    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; points, 
        Set&lt;PairInt&gt; excludePoints, int[] dxs, int[] dys, 
        Set&lt;PairInt&gt; outputNeighbors) {
        
<span class="nc" id="L1317">        outputNeighbors.clear();</span>
        
<span class="nc bnc" id="L1319" title="All 2 branches missed.">        for (int i = 0; i &lt; dxs.length; i++) {</span>
            
<span class="nc" id="L1321">            int x2 = x + dxs[i];</span>
<span class="nc" id="L1322">            int y2 = y + dys[i];</span>
            
<span class="nc" id="L1324">            PairInt p2 = new PairInt(x2, y2);</span>
            
<span class="nc bnc" id="L1326" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1327">                continue;</span>
            }
<span class="nc bnc" id="L1329" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1330">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1333">    }</span>

    public void findNeighbors(int x, int y, Set&lt;PairInt&gt; outputNeighbors,
        Set&lt;PairInt&gt; points, Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L1338">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L1340" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1342">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1343">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1345" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1347">                continue;</span>
            }

<span class="nc" id="L1350">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1352" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1353">                continue;</span>
            }
<span class="nc bnc" id="L1355" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1356">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1359">    }</span>

    /**
     * iterate through points, counting the number of pixels on the image
     * boundaries, and return true if the number reaches numberOfPixels.
     * @param numberOfPixels the number of pixels for which to return true
     * if they are on the image boundaries.
     * @param points
     * @param imageWidth
     * @param imageHeight
     * @return
     */
    public boolean hasNumberOfPixelsOnImageBoundaries(int numberOfPixels,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="nc" id="L1374">        int n = 0;</span>

<span class="nc bnc" id="L1376" title="All 2 branches missed.">        for (PairInt p : points) {</span>

<span class="nc" id="L1378">            int x = p.getX();</span>
<span class="nc" id="L1379">            int y = p.getY();</span>

<span class="nc bnc" id="L1381" title="All 8 branches missed.">            if ((x == 0) || (y == 0) || (x == (imageWidth - 1)) ||</span>
                (y == (imageHeight - 1))) {

<span class="nc" id="L1384">                n++;</span>

<span class="nc bnc" id="L1386" title="All 2 branches missed.">                if (n == numberOfPixels) {</span>
<span class="nc" id="L1387">                    return true;</span>
                }
            }
<span class="nc" id="L1390">        }</span>

<span class="nc bnc" id="L1392" title="All 2 branches missed.">        return (n &gt;= numberOfPixels);</span>
    }

    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points, int imageWidth,
        int imageHeight) {

<span class="nc" id="L1398">        int nn = 0;</span>

<span class="nc bnc" id="L1400" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1402">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1403">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1405" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1407">                continue;</span>
            }

<span class="nc" id="L1410">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1412" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1413">                nn++;</span>
            }
        }

<span class="nc" id="L1417">        return nn;</span>
    }
    
    public int countNeighbors(int x, int y, Set&lt;PairInt&gt; points) {

<span class="nc" id="L1422">        int nn = 0;</span>

<span class="nc bnc" id="L1424" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1426">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1427">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc" id="L1429">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1432">                nn++;</span>
            }
        }

<span class="nc" id="L1436">        return nn;</span>
    }

    public boolean hasAtLeastOneNonPointNeighbor(int x, int y,
        Set&lt;PairInt&gt; points, int imageWidth, int imageHeight) {

<span class="nc bnc" id="L1442" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1444">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1445">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1447" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1449">                continue;</span>
            }

<span class="nc bnc" id="L1452" title="All 2 branches missed.">            if (!points.contains(new PairInt(x2, y2))) {</span>
<span class="nc" id="L1453">                return true;</span>
            }
        }

<span class="nc" id="L1457">        return false;</span>
    }

    public void findNeighborsWithAtLeastOneNonPoint(int x, int y,
        Set&lt;PairInt&gt; outputNeighbors, Set&lt;PairInt&gt; points,
        Set&lt;PairInt&gt; excludePoints, int imageWidth, int imageHeight) {

<span class="nc" id="L1464">        outputNeighbors.clear();</span>

<span class="nc bnc" id="L1466" title="All 2 branches missed.">        for (int i = 0; i &lt; eightNeighborsX.length; i++) {</span>

<span class="nc" id="L1468">            int x2 = x + eightNeighborsX[i];</span>
<span class="nc" id="L1469">            int y2 = y + eightNeighborsY[i];</span>

<span class="nc bnc" id="L1471" title="All 8 branches missed.">            if ((x2 &lt; 0) || (x2 &gt; (imageWidth - 1)) || (y2 &lt; 0) ||</span>
                (y2 &gt; (imageHeight - 1))) {
<span class="nc" id="L1473">                continue;</span>
            }

<span class="nc" id="L1476">            boolean isPossiblyABorderPoint = hasAtLeastOneNonPointNeighbor(</span>
                x2, y2, points, imageWidth, imageHeight);

<span class="nc bnc" id="L1479" title="All 2 branches missed.">            if (!isPossiblyABorderPoint) {</span>
<span class="nc" id="L1480">                continue;</span>
            }

<span class="nc" id="L1483">            PairInt p2 = new PairInt(x2, y2);</span>

<span class="nc bnc" id="L1485" title="All 2 branches missed.">            if (excludePoints.contains(p2)) {</span>
<span class="nc" id="L1486">                continue;</span>
            }
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            if (points.contains(p2)) {</span>
<span class="nc" id="L1489">                outputNeighbors.add(p2);</span>
            }
        }
<span class="nc" id="L1492">    }</span>

    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2) {
        
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">        if (idx2 &lt; 0) {</span>
<span class="nc" id="L1497">            return false;</span>
        }

<span class="fc" id="L1500">        int x1 = edge.getX(idx1);</span>
<span class="fc" id="L1501">        int y1 = edge.getY(idx1);</span>

<span class="fc" id="L1503">        int x2 = edge.getX(idx2);</span>
<span class="fc" id="L1504">        int y2 = edge.getY(idx2);</span>

<span class="fc" id="L1506">        int diffX = Math.abs(x1 - x2);</span>
<span class="fc" id="L1507">        int diffY = Math.abs(y1 - y2);</span>

<span class="fc bfc" id="L1509" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L1510">            return true;</span>
        }

<span class="fc" id="L1513">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx, int x, int y) {
        
<span class="nc bnc" id="L1518" title="All 4 branches missed.">        if (idx &lt; 0 || idx &gt; (edge.getN() - 1)) {</span>
<span class="nc" id="L1519">            return false;</span>
        }

<span class="nc" id="L1522">        int x1 = edge.getX(idx);</span>
<span class="nc" id="L1523">        int y1 = edge.getY(idx);</span>

<span class="nc" id="L1525">        int diffX = Math.abs(x1 - x);</span>
<span class="nc" id="L1526">        int diffY = Math.abs(y1 - y);</span>

<span class="nc bnc" id="L1528" title="All 4 branches missed.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="nc" id="L1529">            return true;</span>
        }

<span class="nc" id="L1532">        return false;</span>
    }
    
    public boolean isAdjacent(PairIntArray edge, int idx1, int idx2,
        float spacingBetweenPoints) {

<span class="nc" id="L1538">        int x1 = edge.getX(idx1);</span>
<span class="nc" id="L1539">        int y1 = edge.getY(idx1);</span>

<span class="nc" id="L1541">        int x2 = edge.getX(idx2);</span>
<span class="nc" id="L1542">        int y2 = edge.getY(idx2);</span>

<span class="nc" id="L1544">        int diffX = Math.abs(x1 - x2);</span>
<span class="nc" id="L1545">        int diffY = Math.abs(y1 - y2);</span>
        
<span class="nc" id="L1547">        float dist = (float)Math.sqrt(diffX*diffX + diffY*diffY);</span>

<span class="nc bnc" id="L1549" title="All 2 branches missed.">        if (dist &lt;= spacingBetweenPoints) {</span>
<span class="nc" id="L1550">            return true;</span>
        }

<span class="nc" id="L1553">        return false;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which direction and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        direction of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="fc" id="L1587">        int xmRot90 = xp + (ym - yp);</span>
<span class="fc" id="L1588">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="fc" id="L1590">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="fc" id="L1591">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="fc" id="L1593">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="fc" id="L1596">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="fc" id="L1600">        double perp = theta;</span>

<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L1603">            perp += Math.PI/2.;</span>
        } else {
<span class="fc" id="L1605">            perp -= Math.PI/2.;</span>
        }

<span class="pc bpc" id="L1608" title="1 of 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L1609">            perp = perp - 2*Math.PI;</span>
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L1611">            perp += 2*Math.PI;</span>
        }

<span class="fc" id="L1614">        return perp;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * along the curve at the middle point, its direction is from p0 to p1.
     * &lt;pre&gt;
     * For example:
     * 
     * 135 degrees
     *       .---
     *       | .
     *           p2   
     *             p1
     *                p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleAtMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

        /*
        given the points (x1, y1) (x2, y2) and (x3, y3), 
        calculates the angle at the midpoint (x2, y2) for the path along
        the points.
        */
        
<span class="fc" id="L1647">        double theta1 = AngleUtil.polarAngleCCW(x2 - x1, y2 - y1);</span>
        
<span class="fc" id="L1649">        double theta2 = AngleUtil.polarAngleCCW(x3 - x2, y3 - y2);</span>
        
<span class="fc" id="L1651">        double theta = AngleUtil.getAngleAverageInRadians(theta1, theta2);</span>
                
<span class="fc" id="L1653">        return theta;</span>
    }
    
    /**
     * given 3 counter-clockwise ordered points on a curve, calculate the angle 
     * tangent to the curve at the middle point - its direction follows
     * the right hand rule.
     * &lt;pre&gt;
     * For example:
     *                  45 degrees
     *               __
     *               . |
     *       p2    .
     *          p1
     *             p0
     * &lt;/pre&gt;
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @return
     */
    public double calculateAngleTangentToMidpoint(int x1, int y1, 
        int x2, int y2, int x3, int y3) {

<span class="fc" id="L1680">        double theta = calculateAngleAtMidpoint(x1, y1, x2, y2, x3, y3);</span>
               
<span class="fc" id="L1682">        double thetaMinus90 = theta - Math.PI/2.;</span>
<span class="fc bfc" id="L1683" title="All 2 branches covered.">        if (thetaMinus90 &lt; 0) {</span>
<span class="fc" id="L1684">            thetaMinus90 += (2.*Math.PI);</span>
        }
        
<span class="fc" id="L1687">        return thetaMinus90;</span>
    }

    /**
     * given theta and the point (xp, yp), determine which direction and hence
     * polar angle (clockwise) is perpendicular away from the centroid.
     * The reference point (xm, ym) is the point from which theta was also
     * calculated, which is probably the point for kMaxIdx.  The points are also
     * checked to make sure they aren't in the points set.
     *
     * @param theta
     * @param xp
     * @param yp
     * @param xm
     * @param ym
     * @param centroidXY
     * @param points
     * @return
     */
    public double calculatePerpendicularAngleAwayFromCentroid(
        double theta, int xp, int yp, int xm, int ym, double[] centroidXY,
        Set&lt;PairInt&gt; points) {

        /*
        rotate the point (xm, ym) around (xp, yp) 90 degrees and -90 degrees.
        The rotated point which is furthest from the centroid is the
        direction of the vector pointing away from the centroid.
        */

        /*
        math.cos(math.pi/2) = 0
        math.sin(math.pi/2) = 1
        math.sin(-math.pi/2) = -1

        double xr = centroidX + ((y - centroidY) * sine(angle)));
        double yr = centroidY + ((-(x - centroidX) * sine(angle)))
        */

<span class="nc" id="L1725">        int xmRot90 = xp + (ym - yp);</span>
<span class="nc" id="L1726">        int ymRot90 = yp + (-(xm - xp));</span>

<span class="nc" id="L1728">        int xmRotNegative90 = xp  - (ym - yp);</span>
<span class="nc" id="L1729">        int ymRotNegative90 = yp + (xm - xp);</span>

<span class="nc" id="L1731">        boolean rot90IsInPoints = points.contains(</span>
<span class="nc" id="L1732">            new PairInt(Math.round(xmRot90), Math.round(ymRot90)));</span>

<span class="nc" id="L1734">        boolean rotNegative90IsInPoints = points.contains(</span>
<span class="nc" id="L1735">            new PairInt(Math.round(xmRotNegative90),</span>
<span class="nc" id="L1736">            Math.round(ymRotNegative90)));</span>

<span class="nc" id="L1738">        double distSqRot90 = (xmRot90 - centroidXY[0]) * (xmRot90 - centroidXY[0])</span>
            + (ymRot90 - centroidXY[1]) * (ymRot90 - centroidXY[1]);

<span class="nc" id="L1741">        double distSqRotNegative90 =</span>
            (xmRotNegative90 - centroidXY[0]) * (xmRotNegative90 - centroidXY[0])
            + (ymRotNegative90 - centroidXY[1]) * (ymRotNegative90 - centroidXY[1]);

<span class="nc" id="L1745">        double perp = theta;</span>

<span class="nc bnc" id="L1747" title="All 2 branches missed.">        if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc" id="L1748">            perp += Math.PI/2.;</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">        } else if (distSqRot90 &gt; distSqRotNegative90) {</span>
<span class="nc bnc" id="L1750" title="All 4 branches missed.">            if (rot90IsInPoints &amp;&amp; !rotNegative90IsInPoints) {</span>
<span class="nc" id="L1751">                perp -= Math.PI/2.;</span>
<span class="nc bnc" id="L1752" title="All 4 branches missed.">            } else if (!rot90IsInPoints &amp;&amp; rotNegative90IsInPoints) {</span>
<span class="nc" id="L1753">                perp += Math.PI/2.;</span>
            } else {
<span class="nc" id="L1755">                throw new IllegalStateException(&quot;Error in algorithm:&quot; +</span>
                &quot; consider changing the test 90 and -90 points so that&quot; +
                &quot; one will always be in points set.&quot;);
            }
        } else {
<span class="nc" id="L1760">            perp -= Math.PI/2.;</span>
        }

<span class="nc bnc" id="L1763" title="All 2 branches missed.">        if (perp &gt;= 2*Math.PI) {</span>
<span class="nc" id="L1764">            perp = perp - 2*Math.PI;</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">        } else if (perp &lt; 0) {</span>
<span class="nc" id="L1766">            perp += 2*Math.PI;</span>
        }

<span class="nc" id="L1769">        return perp;</span>
    }

    /**
     * calculate theta in degrees as a value between -pi and pi for the given point
     * which should have a value greater than 0 at (x,y) and should be part
     * of a curve thinned to a width of 1.
     &lt;pre&gt;
                 90
           135    |    45
                  |
        180 ---------------  0
                  |
          -135    |   -45
                 -90
     &lt;/pre&gt;
     * @param x
     * @param y
     * @param img
     * @return 
     */
    public int calculateThetaForPointOnEdge(int x, int y, GreyscaleImage img) {
        
<span class="nc" id="L1792">        double[] gXY = calculateGradientsForPointOnEdge(x, y, img);</span>
        
        /*
        Math.atan arc tangent, angle is in the range -pi/2 through pi/2
        Math.atan2 conversion of rectangular coordinates (x,y) 
            to polar coordinates (r,theta). 
            This method computes the phase theta by computing an arc tangent 
            of y/x in the range of -pi to pi.
        */
<span class="nc" id="L1801">        double t = Math.atan2(gXY[1], gXY[0]);</span>
      
<span class="nc" id="L1803">        return (int)Math.round(t);</span>
    }

    /**
     * calculate gradient x and gradient y for the given point
     * which should have a value greater than 0 at (x,y) and should be part
     * of a curve thinned to a width of 1.
     
     * @param x
     * @param y
     * @param img
     * @return double{gradX, gradY}
     */
    public double[] calculateGradientsForPointOnEdge(int x, int y, GreyscaleImage img) {
        
<span class="fc" id="L1818">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>
        
<span class="fc" id="L1820">        float sigma = 0.42466090014400953f;</span>
        
<span class="fc" id="L1822">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1824">        float[] kernel2 = Gaussian1D.getKernel(sigma * 1.6f);</span>
        
<span class="fc" id="L1826">        boolean calcForX = true;</span>
               
<span class="fc" id="L1828">        double convX1 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel, calcForX);
        
<span class="fc" id="L1831">        double convX2 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel2, calcForX);
             
<span class="fc" id="L1834">        calcForX = false;</span>
        
<span class="fc" id="L1836">        double convY1 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel, calcForX);
        
<span class="fc" id="L1839">        double convY2 = kernel1DHelper.convolvePointWithKernel(</span>
            img, x, y, kernel2, calcForX);
        
<span class="fc" id="L1842">        double gX = convX2 - convX1;</span>
<span class="fc" id="L1843">        double gY = convY2 - convY1;</span>
        
<span class="fc" id="L1845">        return new double[]{gX, gY};</span>
    }
    
    /**
     * calculate gradient x and gradient y for the given point
     * which should have a value greater than 0 at (x,y) and should be part
     * of a curve thinned to a width of 1.
     * Note that the magnitudes have not been calibrated because the main
     * using method uses the results to calculate the polar angle, so 
     * factor applied to both not necessary.
       Note that the magnitudes have not been calibrated because the main
     * using method uses the results to calculate the polar angle, so 
     * factor applied to both not necessary.
     * @param x
     * @param y
     * @param points
     * @return double{gradX, gradY}
     */
    public double[] calculateGradientsForPointOnEdge(int x, int y, 
        Set&lt;PairInt&gt; points) {
        
<span class="fc" id="L1866">        Kernel1DHelper kernel1DHelper = new Kernel1DHelper();</span>
        
<span class="fc" id="L1868">        float sigma = 0.42466090014400953f;</span>
        
<span class="fc" id="L1870">        float[] kernel = Gaussian1D.getKernel(sigma);</span>

<span class="fc" id="L1872">        float[] kernel2 = Gaussian1D.getKernel(sigma * 1.6f);</span>
        
<span class="fc" id="L1874">        boolean calcForX = true;</span>
        
<span class="fc" id="L1876">        double convX1 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel, calcForX);
        
<span class="fc" id="L1879">        double convX2 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel2, calcForX);
             
<span class="fc" id="L1882">        calcForX = false;</span>
        
<span class="fc" id="L1884">        double convY1 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel, calcForX);
        
<span class="fc" id="L1887">        double convY2 = kernel1DHelper.convolvePointWithKernel(</span>
            points, x, y, kernel2, calcForX);
             
<span class="fc" id="L1890">        double gX = convX2 - convX1;</span>
<span class="fc" id="L1891">        double gY = convY2 - convY1;</span>
        
<span class="fc" id="L1893">        return new double[]{gX, gY};</span>
    }

    public double calculateArea(PairIntArray closedCurve) {
        
<span class="nc" id="L1898">        int n = closedCurve.getN();</span>
        
<span class="nc" id="L1900">        double sum = 0;</span>
        
<span class="nc bnc" id="L1902" title="All 2 branches missed.">        for (int i = 0; i &lt; (n - 1); ++i) {</span>
            
<span class="nc" id="L1904">            double t = 0.5 * (closedCurve.getY(i + 1) + closedCurve.getY(i)) *</span>
<span class="nc" id="L1905">                (closedCurve.getX(i + 1) - closedCurve.getX(i));</span>
            
<span class="nc" id="L1907">            sum += t;</span>
        }
        
<span class="nc" id="L1910">        sum += ((closedCurve.getY(0) + closedCurve.getY(n - 1)) *</span>
<span class="nc" id="L1911">                (closedCurve.getX(0) - closedCurve.getX(n -1)));</span>
        
<span class="nc" id="L1913">        return sum;</span>
    }

    public PairIntArray scaleDown(PairIntArray a, float scale) {
        
<span class="fc" id="L1918">        double[] cenXY = calculateXYCentroids(a);</span>
     
<span class="fc" id="L1920">        TransformationParameters params = new TransformationParameters();</span>
<span class="fc" id="L1921">        params.setOriginX((float)cenXY[0]);</span>
<span class="fc" id="L1922">        params.setOriginX((float)cenXY[1]);</span>
<span class="fc" id="L1923">        params.setScale(scale);</span>
        
<span class="fc" id="L1925">        Transformer transformer = new Transformer();</span>
<span class="fc" id="L1926">        PairIntArray b = transformer.applyTransformation(params, a);</span>
    
        // when shrinking, there may be overlapping points
<span class="fc" id="L1929">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L1930" title="All 2 branches covered.">        for (int i = (b.getN() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1931">            PairInt p = new PairInt(b.getX(i), b.getY(i));</span>
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1933">                b.removeRange(i, i);</span>
            } else {
<span class="fc" id="L1935">                added.add(p);</span>
            }
        }
        
<span class="fc" id="L1939">        return b;</span>
    }

    public PairIntArray createContiguousCircle(float radius) {

<span class="nc" id="L1944">        int shift = (int)Math.ceil(radius);</span>
    
<span class="nc" id="L1946">        return createContiguousCircle(radius, shift, shift);</span>
    }
    
    public PairIntArray createContiguousCircle(float radius, int xShift, 
        int yShift) {
        
        // for a change in y to be at least 1 pixel, theta would be:
        //   theta = asin(1/r)
<span class="fc" id="L1954">        double theta = Math.asin(1./radius);</span>
        
<span class="fc" id="L1956">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc" id="L1958">        PairIntArray circle = new PairIntArray();</span>
<span class="fc" id="L1959">        double t = 0;</span>
        int x, y;
<span class="fc bfc" id="L1961" title="All 2 branches covered.">        while (t &lt;= Math.PI/2.) {</span>
<span class="fc" id="L1962">            x = xShift + (int)Math.round(radius * Math.cos(t));</span>
<span class="fc" id="L1963">            y = yShift + (int)Math.round(radius * Math.sin(t));</span>
<span class="fc" id="L1964">            PairInt p = new PairInt(x, y);</span>
<span class="fc" id="L1965">            t += theta;</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">            if (added.contains(p)) {</span>
<span class="fc" id="L1967">                continue;</span>
            }
<span class="fc" id="L1969">            circle.add(x, y);</span>
<span class="fc" id="L1970">            added.add(p);</span>
<span class="fc" id="L1971">        }</span>
<span class="fc" id="L1972">        int n90 = circle.getN();</span>
<span class="fc bfc" id="L1973" title="All 2 branches covered.">        for (int i = (n90 - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1974">            x = xShift -1 * (circle.getX(i) - xShift);</span>
<span class="fc" id="L1975">            y = circle.getY(i);</span>
<span class="fc" id="L1976">            PairInt p = new PairInt(x, y);</span>
<span class="pc bpc" id="L1977" title="1 of 2 branches missed.">            if (added.contains(p)) {</span>
<span class="nc" id="L1978">                continue;</span>
            }
<span class="fc" id="L1980">            circle.add(x, y);</span>
<span class="fc" id="L1981">            added.add(p);</span>
        }
<span class="fc" id="L1983">        int n180 = circle.getN();</span>
<span class="fc bfc" id="L1984" title="All 2 branches covered.">        for (int i = (n180 - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L1985">            x = circle.getX(i);</span>
<span class="fc" id="L1986">            y = yShift -1 * (circle.getY(i) - yShift);</span>
<span class="fc" id="L1987">            PairInt p = new PairInt(x, y);</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">            if (added.contains(p)) {</span>
<span class="fc" id="L1989">                continue;</span>
            }
<span class="fc" id="L1991">            circle.add(x, y);</span>
<span class="fc" id="L1992">            added.add(p);</span>
        }
        
<span class="fc" id="L1995">        return circle;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
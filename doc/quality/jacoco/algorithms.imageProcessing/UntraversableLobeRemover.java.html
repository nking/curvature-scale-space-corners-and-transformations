<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>UntraversableLobeRemover.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">UntraversableLobeRemover.java</span></div><h1>UntraversableLobeRemover.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.shortestPath.AStar;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L20" title="1 of 2 branches missed.">class UntraversableLobeRemover {</span>

    /**
     * NOTE: very important that spurs be removed before using this because
     * a short spur found as a junction can lead to a false finding of the
     * shortest segment as a segment that isn't the spur.
     *
     * @param closedCurve
     * @return true if points were removed
     */
    public boolean applyFilter(Set&lt;PairInt&gt; closedCurve, Set&lt;PairInt&gt; exclude,
        int imageWidth, int imageHeight) {

        /*
        Example:
                         -3
                 #       -2
              -  #       -1    The center pattern can be found, then if each
           #  #  -  -     0    of the 3 has a neighbor that isn't adjacent
              -  #        1    to the others and those spokes are single pixel,
                    #          widths, it is a junction that cannot be traversed
                               one way and then the other.
       -2 -1  0  1  2

        To further locate the untraversable section, can find the longest path
        from each spoke back to a pixel adjacent to itself and
        the shortest of the longest paths can be trimmed.

        For example:
                        #         -3
             #          #         -2
          #     #     S2          -1
          #     #  S1              0
             #        S3           1
                         #         2
                            #      3
         -3 -2 -1  0  1  2  3

        Of the longest paths for S1, S2, and S3, that of S1 would be the
        shortest so could be trimmed.
        */

<span class="fc" id="L62">        int nChanges = 0;</span>
<span class="fc" id="L63">        int nIter = 0;</span>
<span class="fc" id="L64">        int nIterMax = 10;</span>

<span class="fc" id="L66">        boolean wasChanged = false;</span>

<span class="fc bfc" id="L68" title="All 6 branches covered.">        while ((nIter == 0) || ((nChanges &gt; 0) &amp;&amp; (nIter &lt; nIterMax))) {</span>

<span class="fc" id="L70">            nChanges = 0;</span>

if (false) {
Image img1 = new Image(imageWidth, imageHeight);
for (PairInt p : closedCurve) {
    img1.setRGB(p.getX(), p.getY(), 255, 0, 0);
}
MiscDebug.writeImage(img1, &quot;before_removed_untr_lobe_&quot;
    + MiscDebug.getCurrentTimeFormatted());
}
<span class="fc bfc" id="L80" title="All 2 branches covered.">            for (PairInt p : closedCurve) {</span>

<span class="fc bfc" id="L82" title="All 2 branches covered.">                if (exclude.contains(p)) {</span>
<span class="fc" id="L83">                    continue;</span>
                }

<span class="fc" id="L86">                Set&lt;PairInt&gt; junctionPoints = findJunction(p.getX(), p.getY(),</span>
                    closedCurve);

<span class="fc" id="L89">                Set&lt;PairInt&gt; diagJunctionPoints = null;</span>

<span class="fc" id="L91">                boolean isDefaultJunction = true;</span>
                
<span class="fc bfc" id="L93" title="All 2 branches covered.">                if (junctionPoints == null) {</span>

<span class="fc" id="L95">                    diagJunctionPoints = findDiagJunction(p.getX(), p.getY(),</span>
                        closedCurve);

<span class="fc bfc" id="L98" title="All 2 branches covered.">                    if (diagJunctionPoints == null) {</span>
<span class="fc" id="L99">                        continue;</span>
                    }
                    
<span class="fc" id="L102">                    isDefaultJunction = false;</span>
                }

<span class="pc bpc" id="L105" title="7 of 8 branches missed.">                assert((isDefaultJunction &amp;&amp; junctionPoints.size() == 3) ||</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">                    (!isDefaultJunction &amp;&amp; diagJunctionPoints.size() == 4));</span>

<span class="fc" id="L108">                Junction spokes = null;</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">                if (isDefaultJunction) {</span>
<span class="fc" id="L111">                    spokes = findSpokesOfJunction(junctionPoints,</span>
                        closedCurve);
                } else {
<span class="fc" id="L114">                    spokes = findSpokesOfJunction2(diagJunctionPoints,</span>
                        closedCurve);
                }

<span class="fc bfc" id="L118" title="All 2 branches covered.">                if (spokes == null) {</span>
<span class="fc" id="L119">                    continue;</span>
                }

<span class="fc" id="L122">                List&lt;Set&lt;PairInt&gt;&gt; longestPaths = findShortestPathBetweenSpokes(</span>
                    spokes, closedCurve, isDefaultJunction);

                //assert(longestPaths.size() == 3);

<span class="fc" id="L127">                removeShortestPath(spokes, longestPaths, closedCurve);</span>
if (false) {
Image img3 = new Image(imageWidth, imageHeight);
for (PairInt p2 : closedCurve) {
    img3.setRGB(p2.getX(), p2.getY(), 255, 0, 0);
}
MiscDebug.writeImage(img3, &quot;removed_untr_lobe_&quot;
+ MiscDebug.getCurrentTimeFormatted());
}
<span class="pc bpc" id="L136" title="3 of 4 branches missed.">                assert(closedCurve.size() &gt; 0);</span>

<span class="fc" id="L138">                SpurRemover spurRm = new SpurRemover();</span>
<span class="fc" id="L139">                spurRm.remove(closedCurve, imageWidth, imageHeight);</span>

<span class="pc bpc" id="L141" title="3 of 4 branches missed.">                assert(closedCurve.size() &gt; 0);</span>

<span class="fc" id="L143">                nChanges++;</span>

<span class="fc" id="L145">                wasChanged = true;</span>

<span class="fc" id="L147">                break;</span>
            }

<span class="fc" id="L150">            nIter++;</span>
        }

        // if any have changed, use contiguous pix finder to keep only
        // the contiguous
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (wasChanged) {</span>

<span class="fc" id="L157">            int[] minMaxXY = MiscMath.findMinMaxXY(closedCurve);</span>
<span class="fc" id="L158">            DFSConnectedGroupsFinder finder = new DFSConnectedGroupsFinder();</span>
<span class="fc" id="L159">            finder.findConnectedPointGroups(closedCurve, minMaxXY[1] + 1,</span>
                minMaxXY[3] + 1);
<span class="fc" id="L161">            int nMax = Integer.MIN_VALUE;</span>
<span class="fc" id="L162">            int maxIdx = -1;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            for (int i = 0; i &lt; finder.getNumberOfGroups(); ++i) {</span>
<span class="fc" id="L164">                int n = finder.getNumberofGroupMembers(i);</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                if (n &gt; nMax) {</span>
<span class="fc" id="L166">                    nMax = n;</span>
<span class="fc" id="L167">                    maxIdx = i;</span>
                }
            }
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (maxIdx &gt; -1) {</span>
<span class="fc" id="L171">                closedCurve.clear();</span>
<span class="fc" id="L172">                closedCurve.addAll(finder.getXY(maxIdx));</span>

<span class="fc" id="L174">                SpurRemover spurRm = new SpurRemover();</span>
<span class="fc" id="L175">                spurRm.remove(closedCurve, minMaxXY[1] + 1, minMaxXY[3] + 1);</span>
            }
        }

<span class="fc" id="L179">        return wasChanged;</span>
    }

    private Set&lt;PairInt&gt; findJunction(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L184">        Pattern pattern = getHorizPattern();</span>

<span class="fc" id="L186">        Set&lt;PairInt&gt; patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (patternPoints != null) {</span>
<span class="fc" id="L189">            return patternPoints;</span>
        }

<span class="fc" id="L192">        swapXDirection(pattern);</span>

<span class="fc" id="L194">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (patternPoints != null) {</span>
<span class="fc" id="L197">            return patternPoints;</span>
        }

<span class="fc" id="L200">        pattern = getVertPattern();</span>

<span class="fc" id="L202">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (patternPoints != null) {</span>
<span class="fc" id="L205">            return patternPoints;</span>
        }

<span class="fc" id="L208">        swapYDirection(pattern);</span>

<span class="fc" id="L210">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc" id="L212">        return patternPoints;</span>
    }

    private Set&lt;PairInt&gt; findDiagJunction(int x, int y, Set&lt;PairInt&gt; points) {

<span class="fc" id="L217">        Pattern pattern = getDiagPattern();</span>

<span class="fc" id="L219">        Set&lt;PairInt&gt; patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (patternPoints != null) {</span>
<span class="fc" id="L222">            return patternPoints;</span>
        }

<span class="fc" id="L225">        swapXDirection(pattern);</span>

<span class="fc" id="L227">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (patternPoints != null) {</span>
<span class="nc" id="L230">            return patternPoints;</span>
        }

<span class="fc" id="L233">        swapYDirection(pattern);</span>

<span class="fc" id="L235">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (patternPoints != null) {</span>
<span class="nc" id="L238">            return patternPoints;</span>
        }

<span class="fc" id="L241">        swapXDirection(pattern);</span>

<span class="fc" id="L243">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (patternPoints != null) {</span>
<span class="nc" id="L246">            return patternPoints;</span>
        }

        // ----- diag pattern 2 ---
<span class="fc" id="L250">        pattern = getDiagPattern2();</span>

<span class="fc" id="L252">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (patternPoints != null) {</span>
<span class="fc" id="L255">            return patternPoints;</span>
        }

<span class="fc" id="L258">        swapXDirection(pattern);</span>

<span class="fc" id="L260">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (patternPoints != null) {</span>
<span class="nc" id="L263">            return patternPoints;</span>
        }

<span class="fc" id="L266">        pattern = getDiagPattern3();</span>

<span class="fc" id="L268">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (patternPoints != null) {</span>
<span class="nc" id="L271">            return patternPoints;</span>
        }

<span class="fc" id="L274">        swapYDirection(pattern);</span>

<span class="fc" id="L276">        patternPoints = findPattern(x, y, points, pattern);</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (patternPoints != null) {</span>
<span class="fc" id="L279">            return patternPoints;</span>
        }

<span class="fc" id="L282">        return patternPoints;</span>
    }

    protected Pattern getHorizPattern() {

        /*
                         -3
                 .       -2
              -  #       -1
           .  #  -  -     0
              -  #        1
                    .

       -2 -1  0  1  2
        */

<span class="fc" id="L298">        Pattern pr = new Pattern();</span>
<span class="fc" id="L299">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L300">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L302">        pr.zeroes.add(new PairInt(0, 1)); pr.zeroes.add(new PairInt(0, -1));</span>
<span class="fc" id="L303">        pr.zeroes.add(new PairInt(1, 0));</span>
<span class="fc" id="L304">        pr.zeroes.add(new PairInt(2, 0));</span>

<span class="fc" id="L306">        pr.ones.add(new PairInt(1, 1)); pr.ones.add(new PairInt(1, -1));</span>

<span class="fc" id="L308">        return pr;</span>
    }

    protected Pattern getVertPattern() {

        /*
              .          -1
           -  #  -        0
           #  -  #        1
              -           2
       -2 -1  0  1  2
        */
<span class="fc" id="L320">        Pattern pr = new Pattern();</span>
<span class="fc" id="L321">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L322">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L324">        pr.zeroes.add(new PairInt(-1, 0));</span>
<span class="fc" id="L325">        pr.zeroes.add(new PairInt(0, 2)); pr.zeroes.add(new PairInt(0, 1));</span>
<span class="fc" id="L326">        pr.zeroes.add(new PairInt(1, 0));</span>

<span class="fc" id="L328">        pr.ones.add(new PairInt(-1, 1)); pr.ones.add(new PairInt(1, 1));</span>

<span class="fc" id="L330">        return pr;</span>
    }

    protected DiagPattern getDiagPattern() {

        /*
                         -3
              -  #  -    -2
              -  #  #    -1
              #  -  -     0
                          1
       -2 -1  0  1  2
        */

<span class="fc" id="L344">        DiagPattern pr = new DiagPattern();</span>
<span class="fc" id="L345">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L346">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L348">        pr.zeroes.add(new PairInt(0, -1)); pr.zeroes.add(new PairInt(0, -2));</span>
<span class="fc" id="L349">        pr.zeroes.add(new PairInt(1, 0));</span>
<span class="fc" id="L350">        pr.zeroes.add(new PairInt(2, 0)); pr.zeroes.add(new PairInt(2, -2));</span>

<span class="fc" id="L352">        pr.ones.add(new PairInt(1, -1)); pr.ones.add(new PairInt(1, -2));</span>
<span class="fc" id="L353">        pr.ones.add(new PairInt(2, -1));</span>

<span class="fc" id="L355">        return pr;</span>
    }

    protected DiagPattern getDiagPattern2() {

        /*
                         -3
              -  #  -    -2
              -  #  #    -1
              -  #  -     0
                          1
          -2 -1  0  1  2
        */

<span class="fc" id="L369">        DiagPattern pr = new DiagPattern();</span>
<span class="fc" id="L370">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L371">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L373">        pr.zeroes.add(new PairInt(-1, 0)); pr.zeroes.add(new PairInt(-1, -1)); pr.zeroes.add(new PairInt(-1, -2));</span>
<span class="fc" id="L374">        pr.zeroes.add(new PairInt(1, 0)); pr.zeroes.add(new PairInt(1, -2));</span>

<span class="fc" id="L376">        pr.ones.add(new PairInt(0, -1)); pr.ones.add(new PairInt(0, -2));</span>
<span class="fc" id="L377">        pr.ones.add(new PairInt(1, -1));</span>

<span class="fc" id="L379">        return pr;</span>
    }

    protected DiagPattern getDiagPattern3() {

        /*
                         -2
              -  #  -    -1
              #  #  #     0
              -  -  -     1

          -1  0  1  2
        */

<span class="fc" id="L393">        DiagPattern pr = new DiagPattern();</span>
<span class="fc" id="L394">        pr.ones = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L395">        pr.zeroes = new HashSet&lt;PairInt&gt;();</span>

<span class="fc" id="L397">        pr.zeroes.add(new PairInt(0, 1)); pr.zeroes.add(new PairInt(0, -1));</span>
<span class="fc" id="L398">        pr.zeroes.add(new PairInt(1, 1));</span>
<span class="fc" id="L399">        pr.zeroes.add(new PairInt(2, 1)); pr.zeroes.add(new PairInt(2, -1));</span>

<span class="fc" id="L401">        pr.ones.add(new PairInt(1, 0)); pr.ones.add(new PairInt(1, -1));</span>
<span class="fc" id="L402">        pr.ones.add(new PairInt(2, 0));</span>

<span class="fc" id="L404">        return pr;</span>
    }

    private void swapYDirection(Pattern pattern) {
        // ----- change the sign of y  -----
<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L410">            p.setY(-1 * p.getY());</span>
<span class="fc" id="L411">        }</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L413">            p.setY(-1 * p.getY());</span>
<span class="fc" id="L414">        }</span>
<span class="fc" id="L415">    }</span>

    private void swapXDirection(Pattern pattern) {
        // ----- change the sign of x  -----
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L420">            p.setX(-1 * p.getX());</span>
<span class="fc" id="L421">        }</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L423">            p.setX(-1 * p.getX());</span>
<span class="fc" id="L424">        }</span>
<span class="fc" id="L425">    }</span>

    private Set&lt;PairInt&gt; findPattern(int x, int y, Set&lt;PairInt&gt; points,
        Pattern pattern) {

<span class="fc" id="L430">        Set&lt;PairInt&gt; patternPoints = new HashSet&lt;PairInt&gt;();</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (PairInt p : pattern.zeroes) {</span>
<span class="fc" id="L433">            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (points.contains(p2)) {</span>
<span class="fc" id="L435">                return null;</span>
            }
<span class="fc" id="L437">        }</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (PairInt p : pattern.ones) {</span>
<span class="fc" id="L439">            PairInt p2 = new PairInt(x + p.getX(), y + p.getY());</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (!points.contains(p2)) {</span>
<span class="fc" id="L441">                return null;</span>
            }
<span class="fc" id="L443">            patternPoints.add(p2);</span>
<span class="fc" id="L444">        }</span>

<span class="fc" id="L446">        patternPoints.add(new PairInt(x, y));</span>

<span class="fc" id="L448">        return patternPoints;</span>
    }

    private Junction findSpokesOfJunction(Set&lt;PairInt&gt; junctionPoints,
        Set&lt;PairInt&gt; closedCurve) {

<span class="pc bpc" id="L454" title="3 of 4 branches missed.">        assert(junctionPoints.size() == 3);</span>

<span class="fc" id="L456">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

        /*
        Example:
                 S       -2
              -  #       -1    The center pattern can be found, then if each
           S  #  -  -     0    of the 3 has a neighbor that isn't adjacent
              -  #        1    to the others and those spokes are single pixel,
                    S          widths, it is a junction that cannot be traversed
                               one way and then the other.
       -2 -1  0  1  2
        */

<span class="fc" id="L469">        List&lt;Set&lt;PairInt&gt;&gt; spokes = null;</span>

<span class="fc" id="L471">        Junction junction = new Junction(3);</span>

<span class="fc" id="L473">        int count = 0;</span>

<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (PairInt p : junctionPoints) {</span>

<span class="fc" id="L477">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(p.getX(),</span>
<span class="fc" id="L478">                p.getY(), closedCurve);</span>

<span class="fc" id="L480">            neighbors.removeAll(junctionPoints);</span>

<span class="pc bpc" id="L482" title="1 of 4 branches missed.">            if (neighbors.size() &gt; 2 || neighbors.isEmpty()) {</span>
<span class="fc" id="L483">                return null;</span>
            }

<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (count == 0) {</span>
<span class="fc" id="L487">                spokes = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
            }
<span class="fc" id="L489">            junction.setJ(count, p);</span>
<span class="fc" id="L490">            Set&lt;PairInt&gt; spoke = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L491">            spoke.addAll(neighbors);</span>
<span class="fc" id="L492">            spokes.add(spoke);</span>

<span class="fc" id="L494">            count++;</span>
<span class="fc" id="L495">        }</span>

<span class="pc bpc" id="L497" title="3 of 4 branches missed.">        assert(spokes.size() == 3);</span>

        // assert that the points in one spoke are not adjacent to others
        // and not adjacent to the oppossing junction points
<span class="fc bfc" id="L501" title="All 2 branches covered.">        for (int i = 0; i &lt; spokes.size(); ++i) {</span>
<span class="fc" id="L502">            Set&lt;PairInt&gt; spokeI = spokes.get(i);</span>
<span class="pc bpc" id="L503" title="3 of 4 branches missed.">            assert(!spokeI.isEmpty());</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">            for (PairInt pI : spokeI) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                for (int j = (i + 1); j &lt; spokes.size(); ++j) {</span>
<span class="fc" id="L506">                    Set&lt;PairInt&gt; spokeJ = spokes.get(j);</span>
<span class="pc bpc" id="L507" title="3 of 4 branches missed.">                    assert(!spokeJ.isEmpty());</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                    for (PairInt pJ : spokeJ) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                        if (areAdjacent(pI, pJ)) {</span>
<span class="fc" id="L510">                            return null;</span>
                        }
<span class="fc" id="L512">                    }</span>
                }
<span class="fc bfc" id="L514" title="All 2 branches covered.">                if (i == 0) {</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">                    if (areAdjacent(pI, junction.getJ(1))) {</span>
<span class="nc" id="L516">                        return null;</span>
                    }
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">                    if (areAdjacent(pI, junction.getJ(2))) {</span>
<span class="nc" id="L519">                        return null;</span>
                    }
<span class="fc bfc" id="L521" title="All 2 branches covered.">                } else if (i == 1) {</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                    if (areAdjacent(pI, junction.getJ(0))) {</span>
<span class="nc" id="L523">                        return null;</span>
                    }
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                    if (areAdjacent(pI, junction.getJ(2))) {</span>
<span class="nc" id="L526">                        return null;</span>
                    }
                } else {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                    if (areAdjacent(pI, junction.getJ(0))) {</span>
<span class="nc" id="L530">                        return null;</span>
                    }
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                    if (areAdjacent(pI, junction.getJ(1))) {</span>
<span class="nc" id="L533">                        return null;</span>
                    }
                }
<span class="fc" id="L536">            }</span>
        }

<span class="fc" id="L539">        junction.setS0(spokes.get(0).iterator().next());</span>
<span class="fc" id="L540">        junction.setS1(spokes.get(1).iterator().next());</span>
<span class="fc" id="L541">        junction.setS2(spokes.get(2).iterator().next());</span>

<span class="fc" id="L543">        return junction;</span>
    }

    /**
     * find spokes for the diagonal patterns
     * @param junctionPoints
     * @param closedCurve
     * @return
     */
    private Junction findSpokesOfJunction2(Set&lt;PairInt&gt; junctionPoints,
        Set&lt;PairInt&gt; closedCurve) {

<span class="pc bpc" id="L555" title="3 of 4 branches missed.">        assert(junctionPoints.size() == 4);</span>

<span class="fc" id="L557">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

        /*
        Example:
              S          -2
              #          -1    The center pattern can be found, then if each
              #  #  S     0    of the 3 has a neighbor that isn't adjacent
              #           1    to the others and those spokes are single pixel,
              S                widths, it is a junction that cannot be traversed
                               one way and then the other.
       -2 -1  0  1  2
        */

<span class="fc" id="L570">        List&lt;Set&lt;PairInt&gt;&gt; spokes = null;</span>

<span class="fc" id="L572">        Junction junction = new Junction(4);</span>

<span class="fc" id="L574">        int count = 0;</span>

        // find the center junction by centroid
<span class="fc" id="L577">        double[] xyCen = curveHelper.calculateXYCentroids(junctionPoints);</span>
<span class="fc" id="L578">        PairInt jC = new PairInt((int)Math.round(xyCen[0]), (int)Math.round(xyCen[1]));</span>
<span class="pc bpc" id="L579" title="3 of 4 branches missed.">        assert(junctionPoints.contains(jC));</span>

<span class="fc bfc" id="L581" title="All 2 branches covered.">        for (PairInt p : junctionPoints) {</span>

<span class="fc" id="L583">            Set&lt;PairInt&gt; neighbors = curveHelper.findNeighbors(p.getX(),</span>
<span class="fc" id="L584">                p.getY(), closedCurve);</span>

<span class="fc" id="L586">            neighbors.removeAll(junctionPoints);</span>

<span class="fc bfc" id="L588" title="All 2 branches covered.">            if (!p.equals(jC)) {</span>
<span class="pc bpc" id="L589" title="1 of 4 branches missed.">                if (neighbors.isEmpty() || neighbors.size() &gt; 2) {</span>
<span class="fc" id="L590">                    return null;</span>
                }
<span class="fc bfc" id="L592" title="All 2 branches covered.">                if (neighbors.size() &gt; 1) {</span>
                    // keep the closest to jC
<span class="fc" id="L594">                    int minDistSq = Integer.MAX_VALUE;</span>
<span class="fc" id="L595">                    PairInt minDistP = null;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                    for (PairInt pN : neighbors) {</span>
<span class="fc" id="L597">                        int distSq = distSq(jC, pN);</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">                        if (distSq &lt; minDistSq) {</span>
<span class="fc" id="L599">                            minDistSq = distSq;</span>
<span class="fc" id="L600">                            minDistP = pN;</span>
                        }
<span class="fc" id="L602">                    }</span>
<span class="fc" id="L603">                    neighbors.clear();</span>
<span class="fc" id="L604">                    neighbors.add(minDistP);</span>
                }
            }

<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (count == 0) {</span>
<span class="fc" id="L609">                spokes = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
            }
<span class="fc" id="L611">            junction.setJ(count, p);</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (!p.equals(jC)) {</span>
<span class="fc" id="L613">                Set&lt;PairInt&gt; spoke = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L614">                spoke.addAll(neighbors);</span>
<span class="fc" id="L615">                spokes.add(spoke);</span>
            }

<span class="fc" id="L618">            count++;</span>
<span class="fc" id="L619">        }</span>

<span class="pc bpc" id="L621" title="3 of 4 branches missed.">        assert(spokes.size() == 3);</span>

        // assert that the points in one spoke are not adjacent to others
        // and not adjacent to the oppossing junction points
<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (int i = 0; i &lt; spokes.size(); ++i) {</span>
<span class="fc" id="L626">            Set&lt;PairInt&gt; spokeI = spokes.get(i);</span>
<span class="pc bpc" id="L627" title="3 of 4 branches missed.">            assert(!spokeI.isEmpty());</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">            for (PairInt pI : spokeI) {</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">                for (int j = (i + 1); j &lt; spokes.size(); ++j) {</span>
<span class="fc" id="L630">                    Set&lt;PairInt&gt; spokeJ = spokes.get(j);</span>
<span class="pc bpc" id="L631" title="3 of 4 branches missed.">                    assert(!spokeJ.isEmpty());</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">                    for (PairInt pJ : spokeJ) {</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                        if (areAdjacent(pI, pJ)) {</span>
<span class="nc" id="L634">                            return null;</span>
                        }
<span class="fc" id="L636">                    }</span>
                }
                // it will be adjacent to 1 junction point
<span class="fc" id="L639">                int nAdj = 0;</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                for (int k = 0; k &lt; junction.getJLength(); ++k) {</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                    if (areAdjacent(pI, junction.getJ(k))) {</span>
<span class="fc" id="L642">                        nAdj++;</span>
                    }
                }
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                if (nAdj &gt; 1) {</span>
<span class="nc" id="L646">                    return null;</span>
                }
<span class="fc" id="L648">            }</span>
        }

<span class="fc" id="L651">        junction.setS0(spokes.get(0).iterator().next());</span>
<span class="fc" id="L652">        junction.setS1(spokes.get(1).iterator().next());</span>
<span class="fc" id="L653">        junction.setS2(spokes.get(2).iterator().next());</span>

<span class="fc" id="L655">        return junction;</span>
    }

    private void removeShortestPath(Junction spokes, List&lt;Set&lt;PairInt&gt;&gt; longestPaths,
        Set&lt;PairInt&gt; closedCurve) {

<span class="fc" id="L661">        int minLen = Integer.MAX_VALUE;</span>
<span class="fc" id="L662">        int minIdx = -1;</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">        for (int i = 0; i &lt; longestPaths.size(); ++i) {</span>
<span class="fc" id="L664">            int n = longestPaths.get(i).size();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">            if (n &lt; minLen) {</span>
<span class="fc" id="L666">                minLen = n;</span>
<span class="fc" id="L667">                minIdx = i;</span>
            }
        }
<span class="pc bpc" id="L670" title="3 of 4 branches missed.">        assert(minIdx != -1);</span>
<span class="fc" id="L671">        Set&lt;PairInt&gt; rm = longestPaths.get(minIdx);</span>

        // make sure the junction points don't get removed
<span class="fc bfc" id="L674" title="All 2 branches covered.">        for (int j = 0; j &lt; spokes.getJLength(); ++j) {</span>
<span class="fc" id="L675">            rm.remove(spokes.getJ(j));</span>
        }

<span class="fc" id="L678">        closedCurve.removeAll(rm);</span>
<span class="fc" id="L679">    }</span>

    /**
     * find the shortest paths between spokes, excluding the junction points.
     * runtime complexity is O(|V|) + O(|E| + |V|lg2|V|).
     * @param spokes
     * @param closedCurve
     * @param isDefaultJunction if horiz or vert patterns were found, this
     * is the default junction pattern, else is one of the diag patterns
     * @return
     */
    private List&lt;Set&lt;PairInt&gt;&gt; findShortestPathBetweenSpokes(Junction spokes,
        Set&lt;PairInt&gt; closedCurve, boolean isDefaultJunction) {

<span class="fc" id="L693">        int n = closedCurve.size();</span>

        /*
        A* needs
        -- point list as an array (excluding junctions)
        -- adjacency list as a parallel array of linked lists holding indexes
        -- heuristics (or let the algorithm determine the line of sight from
           a point to the destination.  it's only needed for the points which
           are visited).
        -- the adjacency lists should not contain the junction points

        For local bookkeeping, need to keep track of where the spokes
        variables are and need to keep track of where the points are in the
        points array in order to be able to make the adjacency list.
        */

<span class="fc" id="L709">        Map&lt;PairInt, Integer&gt; coordsIndexMap = new HashMap&lt;PairInt, Integer&gt;();</span>

<span class="fc bfc" id="L711" title="All 2 branches covered.">        PairInt[] points = isDefaultJunction ?</span>
            new PairInt[n - 3] : new PairInt[n - 4];

<span class="fc" id="L714">        int s0Idx = -1;</span>
<span class="fc" id="L715">        int s1Idx = -1;</span>
<span class="fc" id="L716">        int s2Idx = -1;</span>

<span class="fc" id="L718">        int count = 0;</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">        for (PairInt p : closedCurve) {</span>
<span class="fc" id="L720">            boolean skip = false;</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">            for (int j = 0; j &lt; spokes.getJLength(); ++j) {</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">                if (p.equals(spokes.getJ(j))) {</span>
<span class="fc" id="L723">                    skip = true;</span>
<span class="fc" id="L724">                    break;</span>
                }
            }
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (skip) {</span>
<span class="fc" id="L728">                continue;</span>
            }
<span class="fc bfc" id="L730" title="All 2 branches covered.">            if (p.equals(spokes.getS0())) {</span>
<span class="fc" id="L731">                s0Idx = count;</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            } else if (p.equals(spokes.getS1())) {</span>
<span class="fc" id="L733">                s1Idx = count;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            } else if (p.equals(spokes.getS2())) {</span>
<span class="fc" id="L735">                s2Idx = count;</span>
            }
<span class="fc" id="L737">            points[count] = p;</span>

<span class="fc" id="L739">            coordsIndexMap.put(p, Integer.valueOf(count));</span>

<span class="fc" id="L741">            count++;</span>
<span class="fc" id="L742">        }</span>

<span class="pc bpc" id="L744" title="3 of 4 branches missed.">        assert(s0Idx &gt; -1);</span>
<span class="pc bpc" id="L745" title="3 of 4 branches missed.">        assert(s1Idx &gt; -1);</span>
<span class="pc bpc" id="L746" title="3 of 4 branches missed.">        assert(s2Idx &gt; -1);</span>
<span class="pc bpc" id="L747" title="9 of 10 branches missed.">        assert((isDefaultJunction &amp;&amp; (count == (n - 3))) ||</span>
            (!isDefaultJunction &amp;&amp; (count == (n - 4))));

<span class="fc" id="L750">        int[] dxs8 = Misc.dx8;</span>
<span class="fc" id="L751">        int[] dys8 = Misc.dy8;</span>

<span class="fc" id="L753">        List&lt;LinkedList&lt;Integer&gt;&gt; adjList = new ArrayList&lt;LinkedList&lt;Integer&gt;&gt;();</span>

<span class="fc bfc" id="L755" title="All 2 branches covered.">        for (int i = 0; i &lt; points.length; ++i) {</span>

<span class="fc" id="L757">            PairInt p = points[i];</span>

<span class="fc" id="L759">            LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L761" title="All 2 branches covered.">            for (int j = 0; j &lt; dxs8.length; ++j) {</span>
<span class="fc" id="L762">                PairInt p2 = new PairInt(p.getX() + dxs8[j], p.getY() + dys8[j]);</span>
<span class="fc" id="L763">                boolean skip = false;</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                for (int k = 0; k &lt; spokes.getJLength(); ++k) {</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                    if (p2.equals(spokes.getJ(k))) {</span>
<span class="fc" id="L766">                        skip = true;</span>
<span class="fc" id="L767">                        break;</span>
                    }
                }
<span class="fc bfc" id="L770" title="All 2 branches covered.">                if (skip) {</span>
<span class="fc" id="L771">                    continue;</span>
                }
<span class="fc" id="L773">                Integer index2 = coordsIndexMap.get(p2);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">                if (index2 == null) {</span>
<span class="fc" id="L775">                    continue;</span>
                }
<span class="fc" id="L777">                list.add(index2);</span>
            }
<span class="fc" id="L779">            adjList.add(list);</span>
        }

        /*
        shortest path from
           src0Idx to src1Idx
           src0Idx to src2Idx
           src1Idx to src2Idx
        */ 
        int[] path01;
        int[] path02;
        int[] path12;
        
        /*
        We want to find the smallest loop which only contains one of the
        spikes (or two in some case) to trim that leaving the longer
        traversable path.
        A combination of using AStar and reading the distance matrix
        finds this lobe.
        */
        
<span class="fc bfc" id="L800" title="All 2 branches covered.">        boolean s01IdxLess = (s0Idx &lt; s1Idx);</span>
<span class="fc" id="L801">        AStar aStar = new AStar(points, adjList, s0Idx, s1Idx);</span>
<span class="fc" id="L802">        path01 = aStar.search();</span>
<span class="fc" id="L803">        int[] path01Alt = aStar.createSourceToSourcePath();</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        if (path01 == null) {</span>
<span class="fc" id="L805">            path01 = path01Alt;</span>
<span class="pc bpc" id="L806" title="2 of 4 branches missed.">        } else if ((path01Alt != null) &amp;&amp; (path01.length &gt; path01Alt.length)) {</span>
<span class="nc" id="L807">            path01 = path01Alt;</span>
        }
            
<span class="fc bfc" id="L810" title="All 2 branches covered.">        boolean s02IdxLess = (s0Idx &lt; s2Idx);</span>
<span class="fc" id="L811">        aStar = new AStar(points, adjList, s0Idx, s2Idx);</span>
<span class="fc" id="L812">        path02 = aStar.search();</span>
<span class="fc" id="L813">        int[] path02Alt = aStar.createSourceToSourcePath();</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        if (path02 == null) {</span>
<span class="fc" id="L815">            path02 = path02Alt;</span>
<span class="pc bpc" id="L816" title="2 of 4 branches missed.">        } else if ((path02Alt != null) &amp;&amp; (path02.length &gt; path02Alt.length)) {</span>
<span class="nc" id="L817">            path02 = path02Alt;</span>
        }
     
<span class="fc bfc" id="L820" title="All 2 branches covered.">        boolean s12IdxLess = (s1Idx &lt; s2Idx);</span>
<span class="fc" id="L821">        aStar = new AStar(points, adjList, s1Idx, s2Idx);</span>
<span class="fc" id="L822">        path12 = aStar.search();</span>
<span class="fc" id="L823">        int[] path12Alt = aStar.createSourceToSourcePath();</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">        if (path12 == null) {</span>
<span class="fc" id="L825">            path12 = path12Alt;</span>
<span class="pc bpc" id="L826" title="2 of 4 branches missed.">        } else if ((path12Alt != null) &amp;&amp; (path12.length &gt; path12Alt.length)) {</span>
<span class="nc" id="L827">            path12 = path12Alt;</span>
        }
       
<span class="fc" id="L830">        List&lt;Set&lt;PairInt&gt;&gt; paths = new ArrayList&lt;Set&lt;PairInt&gt;&gt;();</span>
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        if (path01 != null) {</span>
<span class="fc" id="L832">            Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">            for (int i = 0; i &lt; path01.length; ++i) {</span>
<span class="fc" id="L834">                PairInt p = points[path01[i]];</span>
<span class="fc bfc" id="L835" title="All 4 branches covered.">                if (p.equals(spokes.getS0()) || p.equals(spokes.getS1())) {</span>
<span class="fc" id="L836">                    continue;</span>
                }
<span class="fc" id="L838">                set.add(p);</span>
            }
<span class="fc" id="L840">            paths.add(set);</span>
        }

<span class="pc bpc" id="L843" title="1 of 2 branches missed.">        if (path02 != null) {</span>
<span class="fc" id="L844">            Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">            for (int i = 0; i &lt; path02.length; ++i) {</span>
<span class="fc" id="L846">                PairInt p = points[path02[i]];</span>
<span class="fc bfc" id="L847" title="All 4 branches covered.">                if (p.equals(spokes.getS0()) || p.equals(spokes.getS2())) {</span>
<span class="fc" id="L848">                    continue;</span>
                }
<span class="fc" id="L850">                set.add(p);</span>
            }
<span class="fc" id="L852">            paths.add(set);</span>
        }

<span class="pc bpc" id="L855" title="1 of 2 branches missed.">        if (path12 != null) {</span>
<span class="fc" id="L856">            Set&lt;PairInt&gt; set = new HashSet&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">            for (int i = 0; i &lt; path12.length; ++i) {</span>
<span class="fc" id="L858">                PairInt p = points[path12[i]];</span>
<span class="fc bfc" id="L859" title="All 4 branches covered.">                if (p.equals(spokes.getS1()) || p.equals(spokes.getS2())) {</span>
<span class="fc" id="L860">                    continue;</span>
                }
<span class="fc" id="L862">                set.add(p);</span>
            }
<span class="fc" id="L864">            paths.add(set);</span>
        }

<span class="fc" id="L867">        return paths;</span>
    }

    private boolean areAdjacent(PairInt p0, PairInt p1) {
<span class="fc" id="L871">        int diffX = Math.abs(p0.getX() - p1.getX());</span>
<span class="fc" id="L872">        int diffY = Math.abs(p0.getY() - p1.getY());</span>
<span class="fc bfc" id="L873" title="All 4 branches covered.">        if ((diffX &lt; 2) &amp;&amp; (diffY &lt; 2)) {</span>
<span class="fc" id="L874">            return true;</span>
        }
<span class="fc" id="L876">        return false;</span>
    }
    
    private int distSq(PairInt p0, PairInt p1) {
<span class="fc" id="L880">        int diffX = Math.abs(p0.getX() - p1.getX());</span>
<span class="fc" id="L881">        int diffY = Math.abs(p0.getY() - p1.getY());</span>
<span class="fc" id="L882">        return (diffX*diffX) + (diffY*diffY);</span>
    }

    public static class Pattern {
        Set&lt;PairInt&gt; ones;
        Set&lt;PairInt&gt; zeroes;
    }

    public static class DiagPattern extends Pattern {
    }

<span class="fc" id="L893">    public static class Junction {</span>
        final PairInt[] s = new PairInt[3];
        final PairInt[] j;
        public Junction(int nJunctions) {
            j = new PairInt[nJunctions];
        }
        public void setS0(PairInt p) {
            s[0] = p;
        }
        public void setS1(PairInt p) {
            s[1] = p;
        }
        public void setS2(PairInt p) {
            s[2] = p;
        }
        public PairInt getS0() {
            return s[0];
        }
        public PairInt getS1() {
            return s[1];
        }
        public PairInt getS2() {
            return s[2];
        }
        public void setJ(int index, PairInt p) {
            if (index &lt; 0 || (index &gt; (j.length - 1))) {
                throw new IllegalArgumentException(&quot;index is out of bounds&quot;);
            }
            j[index] = p;
        }
        public PairInt getJ(int index) {
            if (index &lt; 0 || (index &gt; (j.length - 1))) {
                throw new IllegalArgumentException(&quot;index is out of bounds&quot;);
            }
            return j[index];
        }
        public int getJLength() {
            return j.length;
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
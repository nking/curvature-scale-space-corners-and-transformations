<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StereoProjectionTransformer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">StereoProjectionTransformer.java</span></div><h1>StereoProjectionTransformer.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.util.PairFloatArray;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import thirdparty.HungarianAlgorithm;
import org.ejml.simple.*;

/**
 * class to solve for the epipoles for two images with stereo projection
 * and apply the solution.
 * 
 * &lt;pre&gt;
 * The fundamental matrix is the projective solution for transformation
 * between 2 images of the same objects in pixel coordinates.
 * Present below is the solution for having 7 matched points between images
 * and the solution for having 8 or more matched points between the images.
 * Both use numerical conditioning and recipes suggested by Hartley 
 * (see reference below).
 * 
 * Matching the points before using this can be done with PointMatcher.
 * 
 * Following:
 * 
 * IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, VOL. 19, 
 * NO. 6, JUNE 1997
 * &quot;In Defense of the Eight-Point Algorithm&quot; by Richard Hartley

 * The 8-point algorithm matrix represents epipolar geometry, and can be
 * used with data from cameras whose characteristics are not known to solve
 * up to the projective transformation.
 * 
 * Some definitions:
    u^T*v represents the inner product
    u*v^T is a matrix
    the norm of a vector f is the square root of the sum or squares of its 
        entries.
    u_1 is the (x,y) points from image 1 and u_2 are the matched (x,y) points 
        from image 2.
    
    the fundamental matrix is defined:
        u_2^T * F * u_1 = 0  where u are the x,y points in images _1 and _2

    u_1 = (x_1, y_1, 1)^T
    u_2 = (x_2, y_2, 1)^T

    x_1*x_2*F_1_1 + x_1*y_2*F_2_1 + x_1*F_3_1 + y_1*x_2*F_1_2 + y_1*y_2*F_2_2
        + y_1*F_3_2 + x_2*F_1_3 + y_2*F_2_3 + F_3_3 = 0

    A * f = 0

    where A = x_1*x_2, x_1*y_2, x_1, y_1*x_2, y_1*y_2, y_1, x_2, y_2, 1

    To avoid the trivial scale, ||f|| = 1 where f is the norm of f

    And we need least squares fits because the set may be over determined 
    and not have a zero solution.

    we want the vector f that minimizes ||A*f|| subject to the constraint
    that ||f|| = f^T*f = 1

    the solution is the unit eigenvector corresponding to the smallest 
    eigenvalue of A^T*A.

    Since A^T*A is semi-definite and symmetric, all of its eigenvectors
    are real and positive or zero.
    This eigenvector is what he calls the least eigenvector of A^T*A and
    it is found via the Jacobi algorithm or Singular Value Decomposition.

    The solved for matrix will in general not have rank 2 and needs to, so
    further corrections are necessary:
        matrix F is replaced by F' that minimizes the Frobenius norm
        ||F - F'|| subject to the condition det F' = 0.
        A convenient method of doing this is to use the Singular Value
        Decomposition (SVD).
           let F = U*D*V^T be the SVD of F, where D is diagonal matrix 
           D = diag(r, s, t) satisfying r &gt;= s &gt;= t.
           let F' = U*diag(r, s, 0)*V^T.

 (1) Transforming the coordinates:

     Normalization for isotropic scaling.

     utrans = T * u ==&gt; u = utrans * inv(T)

     u_2^T * F * u_1 = 0 
     
        becomes   utrans_2^T * inv(T_2) * F * inv(T_1) * utrans_1 = 0

        and inv(T_2) * F * inv(T_1) is the fundamental matrix for
        utrans_2 &lt; -- &gt; utrans_1 which when found, will be subsequently
        denormalized.

    a) points are translated so that their centroid is at the origin.
    b) points are then scaled so that the average distance from the
       origin is sqrt(2)
    c) the transformation is applied to each of the 2 images separately.
     
 (2) build matrix A with the normalized x,y points
 
 (3) compute linear least square solution to the least eigenvector of f.
     solve A = U * D * V^T   for A*f = [..x...]*f = 0
     A has rank 8.  f has rank 2.
     calculate [U,D,V] from svd(A)
 
 (4) make the fundamental matrix have a rank of 2
     by performing a svd and then reconstructing with the two largest 
     singular values.
         [U,D,V] = svd(F,0);
         F = U * diag([D(1,1) D(2,2) 0]) * V^T; 
 
 (5) denormalize the fundamental matrix
     The related part of the normalization equation: inv(T_2) * F * inv(T_1)
     so denormalizing is:
     
         F = (T_1)^T * F * T_2
   
 (6) estimate the error in the fundamental matrix by calculating epipolar
     lines for points in image 1 and find their nearest points in image 2 
     and measure the perpendicular distance from the epipolar line for
     those nearest points.
 
 The 7-point algorithm is also implemented below and is similar to the 
 8-point solution except that is solves for the null space of the fundamental
 matrix and results in one or 3 solutions which can for some geometries
 be reduced to a single solution.
 The normalization and denormalization steps before and following the solution, 
 are the same as in the 8-point solution.
 * &lt;/pre&gt;
 * 
 * @author nichole
 */
<span class="fc" id="L139">public class StereoProjectionTransformer {</span>
    
<span class="fc" id="L141">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L143">    private SimpleMatrix leftXY = null;</span>
        
<span class="fc" id="L145">    private SimpleMatrix rightXY = null;</span>
        
<span class="fc" id="L147">    private SimpleMatrix fundamentalMatrix = null;</span>
    
<span class="fc" id="L149">    private double[] leftEpipole = null;</span>
    
<span class="fc" id="L151">    private double[] rightEpipole = null;</span>
    
    /**
     * each row is an epipolar line in the right image.
     * Each column corresponds to a point in leftXY and rightXY which are
     * in the same column.
     */
<span class="fc" id="L158">    private SimpleMatrix epipolarLinesInRight = null;</span>
    
    /**
     * calculate the epipolar projection for a set of 8 or more unmatched
     * points.  It uses PointMatcher, RANSACSolver and PointPartitioner
     * to obtain a solution for part of the images that best fits all of
     * the points.
     */
<span class="fc" id="L166">    private SimpleMatrix epipolarLinesInLeft = null;</span>
    
    private boolean fitIsBetter(StereoProjectionTransformerFit bestFit, 
        StereoProjectionTransformerFit compareFit) {
        
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (compareFit == null) {</span>
<span class="nc" id="L172">            return false;</span>
        }
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (bestFit == null) {</span>
<span class="nc" id="L175">            return true;</span>
        }
       
<span class="nc" id="L178">        long bestN = bestFit.getNMatches();</span>
<span class="nc" id="L179">        long compareN = compareFit.getNMatches();</span>
        
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (compareN == 0) {</span>
<span class="nc" id="L182">            return false;</span>
        }
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (bestN == 0) {</span>
<span class="nc" id="L185">            return true;</span>
        }
        
<span class="nc" id="L188">        double bestStat = (double)bestN/(double)bestFit.getNMaxMatchable();</span>
        
<span class="nc" id="L190">        double compareStat = (double)compareN/(double)compareFit.getNMaxMatchable();</span>
        
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (compareStat &gt; bestStat) {</span>
            
<span class="nc" id="L194">            return true;</span>
            
<span class="nc bnc" id="L196" title="All 2 branches missed.">        } else if (compareStat == bestStat) {</span>
            
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (!Double.isNaN(compareFit.getMeanDistance()) &amp;&amp; (</span>
<span class="nc" id="L199">                compareFit.getMeanDistance()</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                &lt; bestFit.getMeanDistance())) {</span>
                
<span class="nc" id="L202">                return true;</span>
                
<span class="nc" id="L204">            } else if (compareFit.getMeanDistance()</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                == bestFit.getMeanDistance()) {</span>
                
<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (compareFit.getStDevFromMean()&lt; bestFit.getStDevFromMean()) {</span>
                    
<span class="nc" id="L209">                    return true;</span>
                }
            }
        }
        
<span class="nc" id="L214">        return false;</span>
    }
    
    public SimpleMatrix calculateEpipolarProjectionForPerfectlyMatched(
        PairFloatArray pointsLeftXY,  PairFloatArray pointsRightXY) {
        
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (pointsLeftXY == null) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;refactorLeftXY cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (pointsRightXY == null) {</span>
<span class="nc" id="L224">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (pointsLeftXY.getN() != pointsRightXY.getN()) {</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(</span>
                &quot;refactorLeftXY and refactorRightXY must be same size&quot;);
        }
        
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (pointsLeftXY.getN() == 7) {</span>
<span class="nc" id="L232">            throw new IllegalArgumentException(</span>
                &quot;for 7 points, use calculateEpipolarProjectionFor7Points&quot;);
        }
        
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (pointsLeftXY.getN() &lt; 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L238">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot; 
<span class="nc" id="L240">                + &quot; refactorLeftXY.n=&quot; + pointsLeftXY.getN());</span>
        }
        
<span class="nc" id="L243">        return calculateEpipolarProjectionForPerfectlyMatched(</span>
<span class="nc" id="L244">            rewriteInto3ColumnMatrix(pointsLeftXY), </span>
<span class="nc" id="L245">            rewriteInto3ColumnMatrix(pointsRightXY));</span>
    }
    
    /**
     * calculate the epipolar projection for a set of 8 or more matched points.
     * 
     * @param theLeftXY
     * @param theRightXY
     * @return 
     */
    public SimpleMatrix calculateEpipolarProjectionForPerfectlyMatched(
        SimpleMatrix theLeftXY, SimpleMatrix theRightXY) {
                    
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (theLeftXY == null) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;theLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (theRightXY == null) {</span>
<span class="nc" id="L262">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (theLeftXY.numCols()!= theRightXY.numCols()) {</span>
<span class="nc" id="L265">            throw new IllegalArgumentException(</span>
                &quot;theLeftXY and theRightXY must be same size&quot;);
        }
        
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (theLeftXY.numCols() == 7) {</span>
<span class="nc" id="L270">            throw new IllegalArgumentException(</span>
                &quot;for 7 points, use calculateEpipolarProjectionFor7Points&quot;);
        }
        
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (theLeftXY.numCols() &lt; 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L276">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot; 
<span class="nc" id="L278">                + &quot; refactorLeftXY.n=&quot; +theLeftXY.numCols());</span>
        }
        
        //the matrix convention is [mRows][nCols]
        
<span class="fc" id="L283">        leftXY = theLeftXY;</span>
        
<span class="fc" id="L285">        rightXY = theRightXY;</span>
        
<span class="fc" id="L287">        fundamentalMatrix = calculateFundamentalMatrix(leftXY, rightXY)</span>
<span class="fc" id="L288">            .transpose();</span>
     
        // 2 x 3 matrix of leftEpipole in column 0 and rightEpipole in column 1.
<span class="fc" id="L291">        double[][] leftRightEpipoles = calculateEpipoles(fundamentalMatrix);</span>
        
<span class="fc" id="L293">        leftEpipole = leftRightEpipoles[0];</span>
        
<span class="fc" id="L295">        rightEpipole = leftRightEpipoles[1];</span>
        
<span class="fc" id="L297">        epipolarLinesInRight = calculateRightEpipolarLines();</span>
        
<span class="fc" id="L299">        epipolarLinesInLeft = calculateLeftEpipolarLines();</span>
       
        /*
        compute the perpendicular errors:
        
        transform points from the first image to get the equipolar lines
           in the second image.
        
        find the closest points in the 2nd image to the epipolar lines 
           store the difference
        
        do the same for the othe image
        
        equipolar lines:
           aVector = F^T * u_1
           then aVector^T*u_2 = aVector_1*x_2 + aVector_2*y_2 + aVector_3 = 0
        
        plot the differences, calc stats, determine inliers.
        use iterative method of choosing 8 or 8-best and error inspection to
        create a better solution (terminate when set of inliers does not 
        change).
        */
        
<span class="fc" id="L322">        return fundamentalMatrix;</span>
    }
    
    /**
     * NOTE: this method should only be used for comparison.  Prefer 
     * calculateEpipolarProjection().
     * 
     * @param pointsLeftXY
     * @param pointsRightXY 
     */
    public SimpleMatrix calculateEpipolarProjectionWithoutNormalization(
        PairFloatArray pointsLeftXY, PairFloatArray pointsRightXY) {
        
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (pointsLeftXY == null) {</span>
<span class="nc" id="L336">            throw new IllegalArgumentException(&quot;refactorLeftXY cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (pointsRightXY == null) {</span>
<span class="nc" id="L339">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (pointsLeftXY.getN() != pointsRightXY.getN()) {</span>
<span class="nc" id="L342">            throw new IllegalArgumentException(</span>
                &quot;refactorLeftXY and refactorRightXY must be same size&quot;);
        }
        
<span class="nc" id="L346">        log.warning(&quot;NOTE:  consider using calculateEpipolarProjection instead&quot;);</span>
        
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (pointsLeftXY.getN() &lt; 8) {</span>
            // cannot use this algorithm.
<span class="nc" id="L350">            throw new IllegalArgumentException(</span>
                &quot;the 8-point problem requires 8 or more points.&quot; 
<span class="nc" id="L352">                + &quot; refactorLeftXY.n=&quot; + pointsLeftXY.getN());</span>
        }
        
        //the matrix convention is [mRows][nCols]
        
<span class="nc" id="L357">        leftXY = rewriteInto3ColumnMatrix(pointsLeftXY);</span>
        
<span class="nc" id="L359">        rightXY = rewriteInto3ColumnMatrix(pointsRightXY);</span>
        
<span class="nc" id="L361">        fundamentalMatrix = calculateFundamentalMatrixWithoutNormalization(</span>
<span class="nc" id="L362">            leftXY, rightXY).transpose();</span>
     
        // 2 x 3 matrix of leftEpipole in column 0 and rightEpipole in column 1.
<span class="nc" id="L365">        double[][] leftRightEpipoles = calculateEpipoles(fundamentalMatrix);</span>
        
<span class="nc" id="L367">        leftEpipole = leftRightEpipoles[0];</span>
        
<span class="nc" id="L369">        rightEpipole = leftRightEpipoles[1];</span>
        
<span class="nc" id="L371">        epipolarLinesInRight = calculateRightEpipolarLines();</span>
        
<span class="nc" id="L373">        epipolarLinesInLeft = calculateLeftEpipolarLines();</span>
       
<span class="nc" id="L375">        return fundamentalMatrix;</span>
    }
    
    protected SimpleMatrix calculateFundamentalMatrix(SimpleMatrix leftXY, 
        SimpleMatrix rightXY) {
        
        //x is xy[0], y is xy[1], xy[2] is all 1's
<span class="fc" id="L382">        NormalizedXY normalizedXY1 = normalize(leftXY);</span>
        
<span class="fc" id="L384">        NormalizedXY normalizedXY2 = normalize(rightXY);        </span>
        
<span class="fc" id="L386">        return calculateFundamentalMatrix(normalizedXY1, normalizedXY2);</span>
    }
    
    /*
    for 7-point algorithm:
    
    (1) SVD of matrix A (as is done in 8-point algorithm)
        giving a matrix of rank 7
    (2) The homogeneous system AX = 0 is called the null space of matrix A.
        The system is nullable because rank 7 &lt; number of columns, 9.
    
        The nullable system must have a solution other than trivial where
        |A| = 0.
    
        There should be 9-7=2 linearly independent vectors u1, u2, ... , un-r 
        that span the null space of A.
    
        The right null space of A reduced by SVD is then 2D and the last
        2 columns of V can be extracted and reshaped to [3x3] as F1 and F2.
        
        A linear convex combination of F1 and F2 form the estimate of F.
    
        F = α*F1 + (1 − α)*F2  where α is between 0 and 1
    
        The eigenvalues of F are possible only if the determinant of F is 0.
        The determinant of F is a polynomial function, the characteristic
        polynomial whose degree is the order of the matrix, which is 3 in this 
        case. Therefore, the answer(s) to determinant(F) = 0 requires the cubic 
        roots of the equation.
        
        det A = 0 ==&gt; det(α*F1 + (1 − α)*F2) = 0
    
        because det(F1 + F2) != det(F1) + det(F2), have to step through the
        determinant of the sums, and group the terms by a^3, a^2, a^1, and a^0
        and then solve for the cubic roots as the values of 'a'.
    
   The matrices multiplied and summed:
    
    a*ff1[0][0] + (1-a)*ff2[0][0]   a*ff1[0][1] + (1-a)*ff2[0][1]   a*ff1[0][2] + (1-a)*ff2[0][2]
    a*ff1[1][0] + (1-a)*ff2[1][0]   a*ff1[1][1] + (1-a)*ff2[1][1]   a*ff1[1][2] + (1-a)*ff2[1][2]
    a*ff1[2][0] + (1-a)*ff2[2][0]   a*ff1[2][1] + (1-a)*ff2[2][1]   a*ff1[2][2] + (1-a)*ff2[2][2]
        
    The terms are further grouped below in methods
       calculateCubicRoot...OrderCoefficientFor7Point(ff1, ff2)
    
    After the cubic root(s) are solved, they are back substituted into :
        Fi = a(i) * FF{1} + (1-a(i)) * FF{2};
    to get the solutions Fi which may be one or 3 solutions.
    */
    
    /**
     * calculate the epipolar projection for a set of matched points that are
     * at 7 points in length.
     * 
     * @param pointsLeftXY
     * @param pointsRightXY 
     * @return  
     */
    public List&lt;SimpleMatrix&gt; calculateEpipolarProjectionFor7Points(
        PairFloatArray pointsLeftXY, PairFloatArray pointsRightXY) {
        
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (pointsLeftXY == null) {</span>
<span class="nc" id="L448">            throw new IllegalArgumentException(&quot;refactorLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (pointsRightXY == null) {</span>
<span class="nc" id="L451">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() != pointsRightXY.getN()) {</span>
<span class="nc" id="L454">            throw new IllegalArgumentException(</span>
                &quot;refactorLeftXY and refactorRightXY must be same size&quot;);
        }
        
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() != 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L460">            throw new IllegalArgumentException(</span>
                &quot;the 7-point problem requires 7 points.&quot; 
<span class="nc" id="L462">                + &quot; pointsLeftXY.n=&quot; + pointsLeftXY.getN());</span>
        }
        
<span class="fc" id="L465">        return calculateEpipolarProjectionFor7Points(</span>
<span class="fc" id="L466">            rewriteInto3ColumnMatrix(pointsLeftXY), </span>
<span class="fc" id="L467">            rewriteInto3ColumnMatrix(pointsRightXY));</span>
    }
    
    /**
     * calculate the epipolar projection for a set of matched points that are
     * at 7 points in length.
     * 
     * @param theLeftXY
     * @param theRightXY 
     * @return  
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public List&lt;SimpleMatrix&gt; calculateEpipolarProjectionFor7Points(
        SimpleMatrix theLeftXY, SimpleMatrix theRightXY) {
        
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (theLeftXY == null) {</span>
<span class="nc" id="L483">            throw new IllegalArgumentException(&quot;refactorLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        if (theRightXY == null) {</span>
<span class="nc" id="L486">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (theLeftXY.numRows() != theRightXY.numRows()) {</span>
<span class="nc" id="L489">            throw new IllegalArgumentException(</span>
                &quot;theLeftXY and theRightXY must be same size&quot;);
        }
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if (theLeftXY.numCols() != theRightXY.numCols()) {</span>
<span class="nc" id="L493">            throw new IllegalArgumentException(</span>
                &quot;theLeftXY and theRightXY must be same size&quot;);
        }
        
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (theLeftXY.numCols() != 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L499">            throw new IllegalArgumentException(</span>
                &quot;the 7-point problem requires 7 points.&quot; 
<span class="nc" id="L501">                + &quot; theLeftXY.n=&quot; + theLeftXY.numCols());</span>
        }
        
<span class="fc" id="L504">        leftXY = theLeftXY;</span>
        
<span class="fc" id="L506">        rightXY = theRightXY;</span>
        
        //x is xy[0], y is xy[1], xy[2] is all 1's
<span class="fc" id="L509">        NormalizedXY normalizedXY1 = normalize(leftXY);</span>
        
<span class="fc" id="L511">        NormalizedXY normalizedXY2 = normalize(rightXY);      </span>
        
<span class="fc" id="L513">        double[][] m = createFundamentalMatrix(</span>
<span class="fc" id="L514">            normalizedXY1.getXy(), normalizedXY2.getXy());</span>
        
<span class="fc" id="L516">        SimpleMatrix aMatrix = new SimpleMatrix(m);</span>
<span class="fc" id="L517">        SimpleSVD&lt;SimpleMatrix&gt; svd = aMatrix.svd();</span>
<span class="fc" id="L518">        SimpleMatrix nullSpace = svd.nullSpace();</span>
        
<span class="fc" id="L520">        double[][] ff1 = new double[3][3];</span>
<span class="fc" id="L521">        double[][] ff2 = new double[3][3];</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
            
<span class="fc" id="L524">            ff1[i] = new double[3];</span>
<span class="fc" id="L525">            ff1[i][0] = nullSpace.get((i * 3) + 0, 0);</span>
<span class="fc" id="L526">            ff1[i][1] = nullSpace.get((i * 3) + 1, 0);</span>
<span class="fc" id="L527">            ff1[i][2] = nullSpace.get((i * 3) + 2, 0);</span>
            
<span class="fc" id="L529">            ff2[i] = new double[3];</span>
<span class="fc" id="L530">            ff2[i][0] = nullSpace.get((i * 3) + 0, 1);</span>
<span class="fc" id="L531">            ff2[i][1] = nullSpace.get((i * 3) + 1, 1);</span>
<span class="fc" id="L532">            ff2[i][2] = nullSpace.get((i * 3) + 2, 1);</span>
        }
       
<span class="fc" id="L535">        SimpleMatrix[] solutions = solveFor7Point(ff1, ff2);</span>
        
        //denormalize:  F = (T_1)^T * F * T_2  
        //    T_1 is normalizedXY1.getNormalizationMatrix();
        //    T2 is normalizedXY2.getNormalizationMatrix();
        
<span class="fc" id="L541">        List&lt;SimpleMatrix&gt; denormalizedSolutions = new ArrayList&lt;SimpleMatrix&gt;();</span>

<span class="fc" id="L543">        SimpleMatrix t1Transpose = normalizedXY1.getNormalizationMatrix().transpose();</span>
<span class="fc" id="L544">        SimpleMatrix t2 = normalizedXY2.getNormalizationMatrix(); </span>
        
<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (SimpleMatrix solution : solutions) {</span>
                        
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            if (solution == null) {</span>
<span class="nc" id="L549">                continue;</span>
            }
            
<span class="fc" id="L552">            SimpleMatrix denormFundamentalMatrix = t1Transpose.mult(</span>
<span class="fc" id="L553">                solution.mult(t2));</span>
        
<span class="fc" id="L555">            denormFundamentalMatrix = denormFundamentalMatrix.scale(</span>
<span class="fc" id="L556">                1./denormFundamentalMatrix.get(2, 2));</span>
            
<span class="fc" id="L558">            denormFundamentalMatrix = denormFundamentalMatrix.transpose();</span>
            
<span class="fc" id="L560">            SimpleMatrix validated = validateSolution(denormFundamentalMatrix);</span>
            
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            if (validated != null) {</span>
<span class="fc" id="L563">                denormalizedSolutions.add(validated);</span>
            }
        }

<span class="fc" id="L567">        return denormalizedSolutions;</span>
    }
    
    /**
     * The validation of the 7-point algorithm follows source code adapted 
     * from this site and license:
     * 
     * based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        &quot;MATLAB Functions for Multiple View Geometry&quot;

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a 
        * copy of this software and associated documentation files 
        * (the &quot;Software&quot;), to deal in the Software without restriction, 
        * including without limitation the rights to use, copy, modify, merge, 
        * publish, distribute, sublicense, and/or sell copies of the Software, 
        * and to permit persons to whom the Software is furnished to do so, 
        * subject to the following conditions:

        The above copyright notice and this permission notice shall be included 
        * in all copies or substantial portions of the Software.

        The software is provided &quot;as is&quot;, without warranty of any kind, express 
        * or implied, including but not limited to the warranties of 
        * merchantability, fitness for a particular purpose and noninfringement. 
        * In no event shall the authors or copyright holders be liable for any 
        * claim, damages or other liability, whether in an action of contract, 
        * tort or otherwise, arising from, out of or in connection with the 
        * software or the use or other dealings in the software.

       vgg_multiview/vgg_F_from_7pts_2img.m
 
       The method &quot;signs_OK&quot; validates the solution matrices:
    
        for i = 1:length(a)
          Fi = a(i)*FF{1} + (1-a(i))*FF{2};
          %for n = 1:7, disp(norm(x(:,n,1)'*Fi*x(:,n,2))), end  % test code
          if signs_OK(Fi,x1,x2)
            F = cat(3, F, Fi);
          end
        end

        return

        %%%%%%%%%%%%%%%%%%%%%%%%%

        % Checks sign consistence of F and x
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F');
        e1 = v(:,3);
        l1 = vgg_contreps(e1)*x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s&gt;0) | all(s less than 0);
        return
        
    More on the subject is present in &quot;Cheirality in Epipolar Geometry&quot; by
    Werner &amp; Pajdla, 2000 regarding realizability of two images.
    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.9013&amp;rep=rep1&amp;type=pdf
        
    Very clear paper on cheirality:
    * http://users.cecs.anu.edu.au/~hartley/Papers/cheiral/revision/cheiral.pdf
    * The cheirality of a point is whether it lies in front of or behind a given
    * camera.  It's used to  distinguish between four different possible scene 
    * reconstructions from two views.
    * A transform is cheirality-reversing for a given point if it swaps the 
    * point from the front to the back of the camera, or vice-versa. 
    * Otherwise it is called cheirality-preserving.
    */
    @SuppressWarnings({&quot;unchecked&quot;})
    private SimpleMatrix validateSolution(SimpleMatrix solution) {
                            
        /*
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F');
        e1 = v(:,3);
        l1 = vgg_contreps(e1)*x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s&gt;0) | all(s&lt;0);

        (F*x2) .* l1 ==&gt;  (solution * rightXY) .* (testE1 * leftXY)
        '.*' is mattlab notation to operate on each field

        'sum' is a matlab function to sum for each column

        'all' is a function that returns '1' is all items are non-zero, else
            returns 0
        */

<span class="fc" id="L660">        double[][] leftRightEpipoles = calculateEpipoles(solution);</span>

<span class="fc" id="L662">        double[] testE1 = leftRightEpipoles[0];</span>

<span class="fc" id="L664">        SimpleMatrix l1 = leftXY.copy();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (int row = 0; row &lt; testE1.length; ++row){</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            for (int col = 0; col &lt; l1.numCols(); ++col) {</span>
<span class="fc" id="L667">                double value = testE1[row] * l1.get(row, col);</span>
<span class="fc" id="L668">                l1.set(row, col, value);</span>
            }
        }

<span class="fc" id="L672">        double[] sum = new double[l1.numCols()];</span>
<span class="fc" id="L673">        SimpleMatrix t1 = solution.mult(rightXY);</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        for (int row = 0; row &lt; testE1.length; ++row){</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">            for (int col = 0; col &lt; t1.numCols(); ++col) {</span>
<span class="fc" id="L676">                double value = l1.get(row, col) * t1.get(row, col);</span>
<span class="fc" id="L677">                t1.set(row, col, value);</span>
<span class="fc" id="L678">                sum[col] += value;</span>
            }
        }

<span class="fc bfc" id="L682" title="All 2 branches covered.">        for (int i = 0; i &lt; sum.length; ++i) {</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">            if (sum[i] == 0) {</span>
<span class="nc" id="L684">                return null;</span>
            }
        }

<span class="fc" id="L688">        return solution;        </span>
    }
     
    SimpleMatrix[] solveFor7Point(double[][] ff1, double[][] ff2) {
     
<span class="fc" id="L693">        double a0 = calculateCubicRoot3rdOrderCoefficientFor7Point(ff1, ff2);</span>
<span class="fc" id="L694">        double a1 = calculateCubicRoot2ndOrderCoefficientFor7Point(ff1, ff2);</span>
<span class="fc" id="L695">        double a2 = calculateCubicRoot1stOrderCoefficientFor7Point(ff1, ff2);</span>
<span class="fc" id="L696">        double a3 = calculateCubicRoot0thOrderCoefficientFor7Point(ff1, ff2);</span>
        
<span class="fc" id="L698">        double[] roots = MiscMath.solveCubicRoots(a0, a1, a2, a3);</span>
        
<span class="fc" id="L700">        double[][] m = new double[3][];</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L702">            m[i] = new double[3];</span>
        }
       
<span class="fc" id="L705">        SimpleMatrix[] solutions = new SimpleMatrix[roots.length];</span>
        
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (int i = 0; i &lt; roots.length; i++) {</span>
            
            //Fi = a(i)*FF{1} + (1-a(i))*FF{2};
            
<span class="fc" id="L711">            double a = roots[i];</span>
            
<span class="fc bfc" id="L713" title="All 2 branches covered.">            for (int row = 0; row &lt; 3; row++) {</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">                for (int col = 0; col &lt; 3; col++) {</span>
<span class="fc" id="L715">                    m[row][col] = a*ff1[row][col] + (1. - a)*ff2[row][col];</span>
                }
            }
            
<span class="fc" id="L719">            solutions[i] = new SimpleMatrix(m);</span>
        }
        
<span class="fc" id="L722">        return solutions;</span>
    }

    private double calculateCubicRoot3rdOrderCoefficientFor7Point(
        double[][] ff1, double[][] ff2) {
        
<span class="fc" id="L728">        double b = ff1[0][0];</span>
<span class="fc" id="L729">        double e = ff1[1][0];</span>
<span class="fc" id="L730">        double h = ff1[2][0];</span>
<span class="fc" id="L731">        double c = ff1[0][1];</span>
<span class="fc" id="L732">        double f = ff1[1][1];</span>
<span class="fc" id="L733">        double i = ff1[2][1];</span>
<span class="fc" id="L734">        double d = ff1[0][2];</span>
<span class="fc" id="L735">        double g = ff1[1][2];</span>
<span class="fc" id="L736">        double j = ff1[2][2];</span>
        
<span class="fc" id="L738">        double k = ff2[0][0];</span>
<span class="fc" id="L739">        double n = ff2[1][0];</span>
<span class="fc" id="L740">        double q = ff2[2][0];</span>
<span class="fc" id="L741">        double l = ff2[0][1];</span>
<span class="fc" id="L742">        double o = ff2[1][1];</span>
<span class="fc" id="L743">        double r = ff2[2][1];</span>
<span class="fc" id="L744">        double m = ff2[0][2];</span>
<span class="fc" id="L745">        double p = ff2[1][2];</span>
<span class="fc" id="L746">        double s = ff2[2][2];</span>
        
<span class="fc" id="L748">        double sum = h*g*c + h*o*d + h*o*m + h*p*l + i*e*d + i*g*k</span>
            + i*n*m + i*p*b + j*e*l + j*k*o + j*n*c + q*f*d
            + q*f*m + q*g*l + q*p*c + r*e*m + r*g*b + r*n*d
            + r*p*k + s*b*o + s*e*c + s*k*f + s*n*l + b*j*f
            - h*f*d - h*f*m - h*g*l - h*p*c - i*e*m - i*g*b
            - i*n*d - i*p*k - j*b*o - j*e*c - j*k*f - j*n*l
            - q*g*c - q*o*d - q*o*m - q*p*l - r*e*d - r*g*k
            - r*n*m - r*p*b - s*b*f - s*e*l - s*k*o - s*n*c;
        
<span class="fc" id="L757">        return sum;</span>
    }
    
    private double calculateCubicRoot2ndOrderCoefficientFor7Point(double[][] ff1, 
        double[][] ff2) {
        
<span class="fc" id="L763">        double b = ff1[0][0];</span>
<span class="fc" id="L764">        double e = ff1[1][0];</span>
<span class="fc" id="L765">        double h = ff1[2][0];</span>
<span class="fc" id="L766">        double c = ff1[0][1];</span>
<span class="fc" id="L767">        double f = ff1[1][1];</span>
<span class="fc" id="L768">        double i = ff1[2][1];</span>
<span class="fc" id="L769">        double d = ff1[0][2];</span>
<span class="fc" id="L770">        double g = ff1[1][2];</span>
<span class="fc" id="L771">        double j = ff1[2][2];</span>
        
<span class="fc" id="L773">        double k = ff2[0][0];</span>
<span class="fc" id="L774">        double n = ff2[1][0];</span>
<span class="fc" id="L775">        double q = ff2[2][0];</span>
<span class="fc" id="L776">        double l = ff2[0][1];</span>
<span class="fc" id="L777">        double o = ff2[1][1];</span>
<span class="fc" id="L778">        double r = ff2[2][1];</span>
<span class="fc" id="L779">        double m = ff2[0][2];</span>
<span class="fc" id="L780">        double p = ff2[1][2];</span>
<span class="fc" id="L781">        double s = ff2[2][2];</span>
        
<span class="fc" id="L783">        double sum = h*f*m + h*g*l + h*p*c + i*e*m + i*n*d + i*p*k</span>
            + i*p*k + j*b*o + j*k*f + j*n*l + j*n*l + q*g*c
            + q*o*d + q*o*d + q*o*m + q*o*m + q*o*m + q*p*l
            + q*p*l + q*p*l + r*e*d + r*g*k + r*g*k + r*n*m
            + r*n*m + r*n*m + r*p*b + r*p*b + s*o*k + s*b*f
            + s*e*l + s*e*l + s*k*o + s*k*o + s*n*c + s*n*c
            - h*o*d - h*o*m - h*o*m - h*p*l - h*p*l - i*g*k
            - i*n*m - i*n*m - i*p*b - j*e*l - j*k*o - j*n*c
            - j*o*k - q*f*d - q*f*m - q*f*m - q*g*l - q*g*l
            - q*p*c - q*p*c - r*e*m - r*e*m - r*g*b - r*n*d
            - r*n*d - r*p*k - r*p*k - r*p*k - s*b*o - s*b*o
            - s*e*c - s*k*f - s*k*f - s*n*l - s*n*l - s*n*l;
        
<span class="fc" id="L796">        return sum;</span>
    }
    
    private double calculateCubicRoot1stOrderCoefficientFor7Point(double[][] ff1, 
        double[][] ff2) {
        
        /*
        f1 =
         b c d
         e f g
         h i j
        f2 =
         k l m
         n o p
         q r s
        */
        
<span class="fc" id="L813">        double b = ff1[0][0];</span>
<span class="fc" id="L814">        double e = ff1[1][0];</span>
<span class="fc" id="L815">        double h = ff1[2][0];</span>
<span class="fc" id="L816">        double c = ff1[0][1];</span>
<span class="fc" id="L817">        double f = ff1[1][1];</span>
<span class="fc" id="L818">        double i = ff1[2][1];</span>
<span class="fc" id="L819">        double d = ff1[0][2];</span>
<span class="fc" id="L820">        double g = ff1[1][2];</span>
<span class="fc" id="L821">        double j = ff1[2][2];</span>
        
<span class="fc" id="L823">        double k = ff2[0][0];</span>
<span class="fc" id="L824">        double n = ff2[1][0];</span>
<span class="fc" id="L825">        double q = ff2[2][0];</span>
<span class="fc" id="L826">        double l = ff2[0][1];</span>
<span class="fc" id="L827">        double o = ff2[1][1];</span>
<span class="fc" id="L828">        double r = ff2[2][1];</span>
<span class="fc" id="L829">        double m = ff2[0][2];</span>
<span class="fc" id="L830">        double p = ff2[1][2];</span>
<span class="fc" id="L831">        double s = ff2[2][2];</span>
        
<span class="fc" id="L833">        double sum = h*o*m + h*p*l + i*n*m + j*o*k + q*f*m + q*g*l + q*p*c </span>
            + r*e*m + r*n*d + r*p*k + r*p*k + r*p*k + s*b*o + s*k*f 
            + s*n*l + s*n*l + s*n*l
            - i*p*k - j*n*l - q*o*d - q*o*m - q*o*m - q*o*m
            - q*p*l - q*p*l - q*p*l - r*g*k - r*n*m - r*n*m
            - r*n*m - r*p*b - s*e*l - s*k*o - s*n*c - s*o*k
            - s*o*k;

<span class="fc" id="L841">        return sum;</span>
    }
    
    private double calculateCubicRoot0thOrderCoefficientFor7Point(
        double[][] ff1, double[][] ff2) {
        
        /*
        f1 =
         b c d
         e f g
         h i j
        f2 =
         k l m
         n o p
         q r s
        */
        
<span class="fc" id="L858">        double k = ff2[0][0];</span>
<span class="fc" id="L859">        double n = ff2[1][0];</span>
<span class="fc" id="L860">        double q = ff2[2][0];</span>
<span class="fc" id="L861">        double l = ff2[0][1];</span>
<span class="fc" id="L862">        double o = ff2[1][1];</span>
<span class="fc" id="L863">        double r = ff2[2][1];</span>
<span class="fc" id="L864">        double m = ff2[0][2];</span>
<span class="fc" id="L865">        double p = ff2[1][2];</span>
<span class="fc" id="L866">        double s = ff2[2][2];</span>
        
<span class="fc" id="L868">        double sum = q * o * m + q * p * l + r * n * m + s * o * k - r*p*k</span>
            - s*n*l;
        
<span class="fc" id="L871">        return sum;</span>
    }
    
    @SuppressWarnings({&quot;unchecked&quot;})
    SimpleMatrix calculateFundamentalMatrix(NormalizedXY normalizedXY1, 
        NormalizedXY normalizedXY2) {
        
        //build the fundamental matrix
<span class="fc" id="L879">        double[][] m = createFundamentalMatrix(normalizedXY1.getXy(), </span>
<span class="fc" id="L880">            normalizedXY2.getXy());</span>

        /*
        compute linear least square solution:
            solve A = U * D * V^T   for A*f = [..x...]*f = 0
            A has rank 8.  f has rank 2.
        
        calculate [U,D,V] from svd(A):
           result has mRows = number of data points
                      nCols = 9
        */
<span class="fc" id="L891">        SimpleMatrix aMatrix = new SimpleMatrix(m);</span>
<span class="fc" id="L892">        SimpleSVD&lt;SimpleMatrix&gt; svd = aMatrix.svd();</span>
<span class="fc" id="L893">        SimpleMatrix V = svd.getV();</span>

        // creates U as 9 x nXY1 matrix
        //         D as length 9 array
        //         V as 9 x 9 matrix
        
        // mRows = 9; nCols = 9
        
        // reshape V to 3x3
        
<span class="fc" id="L903">        int vNCols = V.numCols();</span>
        
<span class="fc" id="L905">        double[][] ff = new double[3][3];</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L907">            ff[i] = new double[3];</span>
<span class="fc" id="L908">            ff[i][0] = V.get((i * 3) + 0, vNCols - 1);</span>
<span class="fc" id="L909">            ff[i][1] = V.get((i * 3) + 1, vNCols - 1);</span>
<span class="fc" id="L910">            ff[i][2] = V.get((i * 3) + 2, vNCols - 1);</span>
        }
<span class="fc" id="L912">        SimpleMatrix fMatrix = new SimpleMatrix(ff);</span>
        
        /* make the fundamental matrix have a rank of 2
        by performing a svd and then reconstructing with the two largest 
        singular values.
            [U,D,V] = svd(F,0);
        
        From [U,D,V] we create:
            F = U * diag([D(1,1) D(2,2) 0]) * V^T, where V^T is V transposed.
        */
<span class="fc" id="L922">        svd = fMatrix.svd();</span>
        
        // creates U as 3 x 3 matrix
        //         D as length 3 array
        //         V as 3 x 3 matrix
        
<span class="fc" id="L928">        SimpleMatrix d = svd.getW();</span>
        
        // remove the smallest singular value from D, making it rank 2
<span class="fc" id="L931">        double[] keep = new double[]{d.get(0, 0), d.get(1, 1), d.get(2, 2)};</span>
<span class="fc" id="L932">        Arrays.sort(keep);</span>
<span class="fc" id="L933">        d.set(0, 0, keep[2]);</span>
<span class="fc" id="L934">        d.set(1, 1, keep[1]);</span>
<span class="fc" id="L935">        d.set(2, 2, 0);</span>
        
        /*
        multiply the terms:
             F = dot(U, dot(diag(D),V^T))
        */               
<span class="fc" id="L941">        SimpleMatrix dDotV = d.mult(svd.getV().transpose());</span>
        
        // 3x3        
<span class="fc" id="L944">        SimpleMatrix theFundamentalMatrix = svd.getU().mult(dDotV);</span>
        
<span class="fc" id="L946">        SimpleMatrix denormFundamentalMatrix = </span>
<span class="fc" id="L947">            denormalizeTheFundamentalMatrix(theFundamentalMatrix, </span>
                normalizedXY1, normalizedXY2);
        
<span class="fc" id="L950">       denormFundamentalMatrix = denormFundamentalMatrix.scale(</span>
<span class="fc" id="L951">            1./denormFundamentalMatrix.get(2, 2));</span>
        
<span class="fc" id="L953">        return denormFundamentalMatrix;</span>
    }
    
    @SuppressWarnings({&quot;unchecked&quot;})
    SimpleMatrix denormalizeTheFundamentalMatrix(
        SimpleMatrix normalizedFundamentalMatrix,
        NormalizedXY normalizedLeftXY, NormalizedXY normalizedRightXY) {
        
        /*
        denormalize
            F = (T_1)^T * F * T_2  
            where T_1 is normalizedXY1.getNormalizationMatrix();
            and T2 is normalizedXY2.getNormalizationMatrix();
        */
        
<span class="fc" id="L968">        SimpleMatrix t1Transpose = normalizedLeftXY.getNormalizationMatrix().transpose();</span>
<span class="fc" id="L969">        SimpleMatrix t2 = normalizedRightXY.getNormalizationMatrix();</span>
        
<span class="fc" id="L971">        SimpleMatrix denormFundamentalMatrix = t1Transpose.mult(</span>
<span class="fc" id="L972">            normalizedFundamentalMatrix.mult(t2));</span>
        
<span class="fc" id="L974">        return denormFundamentalMatrix;</span>
    }
    
    /**
     * calculate the fundamental matrix without normalization.  Note, this
     * method should not be used, but is present for comparing solutions
     * during tests.
     * @param matchedXY1
     * @param matchedXY2
     * @return 
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    SimpleMatrix calculateFundamentalMatrixWithoutNormalization(
        SimpleMatrix matchedXY1, SimpleMatrix matchedXY2) {
        
        //build the fundamental matrix
<span class="nc" id="L990">        SimpleMatrix aMatrix = new SimpleMatrix(createFundamentalMatrix(</span>
            matchedXY1, matchedXY2));

        /*
        compute linear least square solution:
            solve A = U * D * V^T   for A*f = [..x...]*f = 0
            A has rank 8.  f has rank 2.
        
        calculate [U,D,V] from svd(A):
           result has mRows = number of data points
                      nCols = 9
        */
<span class="nc" id="L1002">        SimpleSVD&lt;SimpleMatrix&gt; svd = aMatrix.svd();</span>

        // creates U as 9 x nXY1 matrix
        //         D as length 9 array
        //         V as 9 x 9 matrix
        
        // mRows = 9; nCols = 9
<span class="nc" id="L1009">        SimpleMatrix V = svd.getV();</span>
<span class="nc" id="L1010">        int vNCols = V.numCols();</span>
        
        // reshape it to 3x3
<span class="nc" id="L1013">        double[][] ff = new double[3][3];</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L1015">            ff[i] = new double[3];</span>
<span class="nc" id="L1016">            ff[i][0] = V.get((i * 3) + 0, vNCols - 1);</span>
<span class="nc" id="L1017">            ff[i][1] = V.get((i * 3) + 1, vNCols - 1);</span>
<span class="nc" id="L1018">            ff[i][2] = V.get((i * 3) + 2, vNCols - 1);</span>
        }
<span class="nc" id="L1020">        SimpleMatrix fMatrix = new SimpleMatrix(ff);</span>
        
        /* make the fundamental matrix have a rank of 2
           by performing a svd and then reconstructing with the two largest 
           singular values.
              [U,D,V] = svd(F,0);
        
           then from [U,D,V], create F:
              F = U * diag([D(1,1) D(2,2) 0]) * V^T;
        */
<span class="nc" id="L1030">        svd = fMatrix.svd();</span>
        
        // creates U as 3 x 3 matrix
        //         D as length 3 array
        //         V as 3 x 3 matrix
        
<span class="nc" id="L1036">        SimpleMatrix d = svd.getW();</span>
        
        // remove the smallest singular value from D, making it rank 2
<span class="nc" id="L1039">        double[] keep = new double[]{d.get(0, 0), d.get(1, 1), d.get(2, 2)};</span>
<span class="nc" id="L1040">        Arrays.sort(keep);</span>
<span class="nc" id="L1041">        d.set(0, 0, keep[2]);</span>
<span class="nc" id="L1042">        d.set(1, 1, keep[1]);</span>
<span class="nc" id="L1043">        d.set(2, 2, 0);</span>
        
        /*
        multiply the terms:
             F = dot(U, dot(diag(D),V^T))
        */
<span class="nc" id="L1049">        SimpleMatrix dDotV = d.mult(svd.getV().transpose());</span>
        
        // 3x3        
<span class="nc" id="L1052">        SimpleMatrix theFundamentalMatrix = svd.getU().mult(dDotV);  </span>
        
<span class="nc" id="L1054">        theFundamentalMatrix = theFundamentalMatrix.scale(</span>
<span class="nc" id="L1055">            1./theFundamentalMatrix.get(2, 2));</span>
        
<span class="nc" id="L1057">        return theFundamentalMatrix;</span>
    } 

    /**
     normalize the x,y coordinates as recommended by Hartley 1997 and return
     the matrix and coordinates.
     does not modify the state of this transformer instance.
     * @param xyPair
     * @return 
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    NormalizedXY normalize(SimpleMatrix xy) {
        
        /*
        uTransposed = T * u 
        uTransposed * inv(T) = u
        
                uTransposed_2^T * inv(T_2) * F * inv(T_1) * uTransposed_1
        
        format the tensors T_1 and T_2 such that the applied translation
        and scaling have the effect of:
       
        a) points are translated so that their centroid is at the origin.
        b) points are then scaled so that the average distance from the
           origin is sqrt(2)
        c) the transformation is applied to each of the 2 images separately.
        */
       
<span class="fc" id="L1085">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L1087">        double[] centroidXY = curveHelper.calculateXYCentroids(xy);</span>
        
<span class="fc" id="L1089">        double mean = 0;</span>
<span class="fc" id="L1090">        int n = xy.numCols();</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1092">            double diffX = xy.get(0, i) - centroidXY[0];</span>
<span class="fc" id="L1093">            double diffY = xy.get(1, i) - centroidXY[1];</span>
<span class="fc" id="L1094">            double dist = Math.sqrt((diffX * diffX) + (diffY * diffY));</span>
<span class="fc" id="L1095">            mean += dist;</span>
        }
        
<span class="fc" id="L1098">        mean /= (double)n;</span>
        
        /*
        mean * factor = sqrt(2)        
        */
<span class="fc" id="L1103">        double scaleFactor = Math.sqrt(2)/mean;</span>
        
        /*
        x_1_0  x_1_1  x_1_2  x_1_3
        y_1_0  y_1_1  y_1_2  y_1_3
        1      1      1      1
        
        t00     t01(=0)  t02
        t10(=0) t11      t12
        0        0        1
        
        x_1_0*t00 + y_1_0*t01 + 1*t02 = (x_1_0 - cX) * s = x_1_0 * s - cX * s
                         0
             =&gt; t01 = 0
             =&gt; t00 = scaleFactor 
             =&gt; t02 = -scaleFactor * centroidXY[0]
        
        x_1_0*t10 + y_1_0*t11 + 1*t12 = (y_1_0 - cY) * s = y_1_0 * s - cY * s
            0
             =&gt; t10 = 0
             =&gt; t11 = scaleFactor 
             =&gt; t12 = -scaleFactor * centroidXY[1]
        */
        
<span class="fc" id="L1127">        double[][] t = new double[3][];</span>
<span class="fc" id="L1128">        t[0] = new double[]{scaleFactor, 0,           -scaleFactor * centroidXY[0]};</span>
<span class="fc" id="L1129">        t[1] = new double[]{0,           scaleFactor, -scaleFactor * centroidXY[1]};</span>
<span class="fc" id="L1130">        t[2] = new double[]{0,           0,           1};</span>
<span class="fc" id="L1131">        SimpleMatrix tMatrix = new SimpleMatrix(t);</span>
                
<span class="fc" id="L1133">        SimpleMatrix normXY = new SimpleMatrix(MatrixUtil.dot(tMatrix, xy));</span>
              
<span class="fc" id="L1135">        NormalizedXY normalizedXY = new NormalizedXY();</span>
<span class="fc" id="L1136">        normalizedXY.setCentroidXY(centroidXY);</span>
<span class="fc" id="L1137">        normalizedXY.setNormMatrix(tMatrix);</span>
<span class="fc" id="L1138">        normalizedXY.setXy(normXY);</span>
        
<span class="fc" id="L1140">        return normalizedXY;</span>
    }
    
    /**
     * write a matrix of size mRows = 3, nCols = xyPairs.getN()
     * @param xyPairs
     * @return 
     */
    public static SimpleMatrix rewriteInto3ColumnMatrix(PairFloatArray xyPairs) {
        
        // rewrite xyPairs into a matrix of size 3 X xy.getN();
        // column 0 is x
        // column 1 is y
        // column 2 is all 1's
<span class="fc" id="L1154">        double[][] xyPoints = new double[3][xyPairs.getN()];</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L1156">            xyPoints[i] = new double[xyPairs.getN()];</span>
        }
<span class="fc bfc" id="L1158" title="All 2 branches covered.">        for (int i = 0; i &lt; xyPairs.getN(); i++) {</span>
<span class="fc" id="L1159">            xyPoints[0][i] = xyPairs.getX(i);</span>
<span class="fc" id="L1160">            xyPoints[1][i] = xyPairs.getY(i);</span>
<span class="fc" id="L1161">            xyPoints[2][i] = 1;</span>
        }
        
        // matrix of size mRows x nCols
        
<span class="fc" id="L1166">        SimpleMatrix xy = new SimpleMatrix(xyPoints);</span>
        
<span class="fc" id="L1168">        return xy;</span>
    }
    
    /**
     * write a matrix of size mRows = 3, nCols = xyPairs.getN()
     * @param xyPairs
     * @return 
     */
    public static SimpleMatrix rewriteInto3ColumnMatrix(PairIntArray xyPairs) {
        
        // rewrite xyPairs into a matrix of size 3 X xy.getN();
        // column 0 is x
        // column 1 is y
        // column 2 is all 1's
<span class="nc" id="L1182">        double[][] xyPoints = new double[3][xyPairs.getN()];</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L1184">            xyPoints[i] = new double[xyPairs.getN()];</span>
        }
<span class="nc bnc" id="L1186" title="All 2 branches missed.">        for (int i = 0; i &lt; xyPairs.getN(); i++) {</span>
<span class="nc" id="L1187">            xyPoints[0][i] = xyPairs.getX(i);</span>
<span class="nc" id="L1188">            xyPoints[1][i] = xyPairs.getY(i);</span>
<span class="nc" id="L1189">            xyPoints[2][i] = 1;</span>
        }
        
        // matrix of size mRows x nCols
        
<span class="nc" id="L1194">        SimpleMatrix xy = new SimpleMatrix(xyPoints);</span>
        
<span class="nc" id="L1196">        return xy;</span>
    }
  
    /**
     * @param normXY1 a matrix of size 3 x nPoints, where 1st column is x,
     * second is y.
     * @param normXY2 a matrix of size 3 x nPoints, where 1st column is x,
     * second is y.
     * @return 
     */
    double[][] createFundamentalMatrix(SimpleMatrix normXY1, 
        SimpleMatrix normXY2) {
        
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        if (normXY1 == null) {</span>
<span class="nc" id="L1210">            throw new IllegalArgumentException(&quot;normXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">        if (normXY2 == null) {</span>
<span class="nc" id="L1213">            throw new IllegalArgumentException(&quot;normXY2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1215" title="1 of 2 branches missed.">        if (normXY1.numCols() != normXY2.numCols()) {</span>
<span class="nc" id="L1216">            throw new IllegalArgumentException(</span>
            &quot;the number of columns in normXY1 != number of cols in normXY2&quot;);
        }
        
<span class="fc" id="L1220">        int nXY1 = normXY1.numCols();</span>
                
        /*
        (2) each row in matrix A:
            x_1*x_2,  x_1*y_2,  x_1,  y_1*x_2,  y_1*y_2,  y_1,  x_2,  y_2,  1
        */
<span class="fc" id="L1226">        double[][] a = new double[nXY1][9];</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        for (int i = 0; i &lt; nXY1; i++) {</span>
<span class="fc" id="L1228">            a[i] = new double[9];</span>
<span class="fc" id="L1229">            double x1 = normXY1.get(0, i);</span>
<span class="fc" id="L1230">            double x2 = normXY2.get(0, i);</span>
<span class="fc" id="L1231">            double y1 = normXY1.get(1, i);</span>
<span class="fc" id="L1232">            double y2 = normXY2.get(1, i);</span>
<span class="fc" id="L1233">            a[i][0] = x1 * x2;</span>
<span class="fc" id="L1234">            a[i][1] = x1 * y2;</span>
<span class="fc" id="L1235">            a[i][2] = x1;</span>
<span class="fc" id="L1236">            a[i][3] = y1 * x2;</span>
<span class="fc" id="L1237">            a[i][4] = y1 * y2;</span>
<span class="fc" id="L1238">            a[i][5] = y1;</span>
<span class="fc" id="L1239">            a[i][6] = x2;</span>
<span class="fc" id="L1240">            a[i][7] = y2;</span>
<span class="fc" id="L1241">            a[i][8] = 1;</span>
        }
        
<span class="fc" id="L1244">        return a;</span>
    }

    /**
     * calculate the epipoles of the fundamental matrix and return them as
     * an array with left epipole in column 0 and right epipole in column 1.
     * @param fundamentalMatrix
     * @return 
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    double[][] calculateEpipoles(SimpleMatrix fundamentalMatrix) {
        
        /*
        The representation of lines in homogeneous projective coordinates
        is:   line a*x + b*y + c = 0
            | a |
            | b |
            | c |
        The line can be rewritten in slope, intercept form:
            y = intercept + slope * x
              = -(c/b) - slope*(a/b)*x
        
        written as homogenization form of lines:
            | -a/b |
            | -c/b |
        
        
        From u_2^T * F * u_1 = 0 
        
        epipoles: 
             [U,D,V] = svd(denormalized FundamentalMatrix);
             e1 = last column of V divided by it's last item 
             e2 = last column of U divided by it's last item 
                
        */
<span class="fc" id="L1279">        SimpleSVD&lt;SimpleMatrix&gt; svdE = fundamentalMatrix.svd();</span>
<span class="fc" id="L1280">        SimpleMatrix V = svdE.getV().transpose();</span>
<span class="fc" id="L1281">        double[] e1 = new double[V.numCols()];</span>
<span class="fc" id="L1282">        double e1Div = V.get(2, 2);</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">        for (int i = 0; i &lt; e1.length; i++) {</span>
<span class="fc" id="L1284">            e1[i] = V.get(i, 2)/e1Div;</span>
        }
<span class="fc" id="L1286">        SimpleMatrix U = svdE.getU();</span>
<span class="fc" id="L1287">        double[] e2 = new double[U.numCols()];</span>
<span class="fc" id="L1288">        double e2Div = U.get(2, 2);</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        for (int i = 0; i &lt; e2.length; i++) {</span>
<span class="fc" id="L1290">            e2[i] = U.get(i, 2)/e2Div;</span>
        }
        
<span class="fc" id="L1293">        double[][] e = new double[2][];</span>
<span class="fc" id="L1294">        e[0] = e1;</span>
<span class="fc" id="L1295">        e[1] = e2;</span>
        
<span class="fc" id="L1297">        return e;</span>
    }

    private SimpleMatrix calculateRightEpipolarLines() {
        
        /* calculate right epipolar lines
        F * leftPoint
        */
        
<span class="fc" id="L1306">        SimpleMatrix m = fundamentalMatrix.mult(leftXY);</span>
        
<span class="fc" id="L1308">        return m;</span>
    }
    
    private SimpleMatrix calculateLeftEpipolarLines() {
        
        //calculate left epipolar lines:  F^T * rightPoint
        
<span class="fc" id="L1315">        SimpleMatrix fundamentalMatrixTranspose = fundamentalMatrix.transpose();</span>
        
<span class="fc" id="L1317">        SimpleMatrix m = fundamentalMatrixTranspose.mult(rightXY);</span>
        
<span class="fc" id="L1319">        return m;</span>
    }

    /**
     * NOT YET READY FOR USE.
     * using the homography matrix bestFitProj, project the points in one set 
     * to epipolar lines in the other set and find the closest match that
     * works best in both frames.  The cost function for the match is the
     * perpendicular distance of a point to the epipolar line.
     * Currently, no information about the points position parallel to the
     * line is used.
     * 
     * @param fm projective transformation coefficients between left and right
     * @param unMatchedLeft
     * @param unMatchedRight
     * @param tolerance
     * @param outputMatchedLeft the output matched points for the left image.
     * the indexes for this are the same as the indexes for outputMatchedRight.
     * @param outputMatchedRight the output matched points for the right
     * image.  the indexes are the same as those in outputMatchedLeft.
     * @return 
     */
    public StereoProjectionTransformerFit evaluateFitAndMatchPoints(
        SimpleMatrix fm, PairIntArray unMatchedLeft, PairIntArray 
        unMatchedRight, double tolerance,
        PairIntArray outputMatchedLeft, PairIntArray outputMatchedRight) {
        
<span class="nc" id="L1346">        SimpleMatrix in1 = rewriteInto3ColumnMatrix(unMatchedLeft);</span>
<span class="nc" id="L1347">        SimpleMatrix in2 = rewriteInto3ColumnMatrix(unMatchedRight);</span>
        
<span class="nc" id="L1349">        return evaluateFitAndMatchPoints(fm, in1, in2, tolerance, unMatchedLeft, </span>
            unMatchedRight);
    }
    
    private StereoProjectionTransformerFit evaluateFitAndMatchPoints(
        SimpleMatrix fm, 
        SimpleMatrix unMatchedLeft, SimpleMatrix unMatchedRight, 
        double tolerance,
        PairIntArray outputMatchedLeft, PairIntArray outputMatchedRight) {
        
<span class="nc" id="L1359">        PairIntArray matchedIndexes = new PairIntArray();</span>
        
<span class="nc" id="L1361">        SimpleMatrix theRightEpipolarLines = fm.mult(unMatchedLeft);</span>
        
<span class="nc" id="L1363">        SimpleMatrix theLeftEpipolarLines = fm.transpose().mult(unMatchedRight);</span>
        
<span class="nc" id="L1365">        StereoProjectionTransformerFit fit =</span>
<span class="nc" id="L1366">            evaluateFitForUnmatchedOptimal(fm, theRightEpipolarLines,</span>
            theLeftEpipolarLines, unMatchedLeft, unMatchedRight, tolerance,
            matchedIndexes);
        
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        for (int i = 0; i &lt; matchedIndexes.getN(); i++) {</span>
<span class="nc" id="L1371">            int idx1 = matchedIndexes.getX(i);</span>
<span class="nc" id="L1372">            int idx2 = matchedIndexes.getY(i);</span>
<span class="nc" id="L1373">            outputMatchedLeft.add(</span>
<span class="nc" id="L1374">                (int)Math.round(unMatchedLeft.get(0, idx1)),</span>
<span class="nc" id="L1375">                (int)Math.round(unMatchedLeft.get(1, idx1)));</span>
<span class="nc" id="L1376">            outputMatchedRight.add(</span>
<span class="nc" id="L1377">                (int)Math.round(unMatchedRight.get(0, idx2)),</span>
<span class="nc" id="L1378">                (int)Math.round(unMatchedRight.get(1, idx2)));</span>
        }
        
<span class="nc" id="L1381">        return fit;</span>
    }
    
<span class="fc" id="L1384">    public static class NormalizedXY {</span>

        /**
         * 3 dimensional matrix, with column 0 being x, column 1 being y,
         * and the last column is place holder 1's
         */
        private SimpleMatrix xy = null;
        
        private double[] centroidXY = null;
        
        private SimpleMatrix normalizationMatrix = null;

        /**
         * @return the centroidXY
         */
        public double[] getCentroidXY() {
            return centroidXY;
        }

        /**
         * @param centroidXY the centroidXY to set
         */
        public void setCentroidXY(double[] centroidXY) {
            this.centroidXY = centroidXY;
        }

        /**
         * @return the factor
         */
        public SimpleMatrix getNormalizationMatrix() {
            return normalizationMatrix;
        }

        /**
         * @param normMatrix holding the scale and offsets to apply to x, y
         */
        public void setNormMatrix(SimpleMatrix normMatrix) {
            this.normalizationMatrix = normMatrix;
        }

        /**
         * @return the xy
         */
        public SimpleMatrix getXy() {
            return xy;
        }

        /**
         * @param xy the xy to set
         */
        public void setXy(SimpleMatrix xy) {
            this.xy = xy;
        }
    }
    
    public double[] getLeftEpipole() {
<span class="nc" id="L1440">        return leftEpipole;</span>
    }
    public double[] getRightEpipole() {
<span class="nc" id="L1443">        return rightEpipole;</span>
    }
    public SimpleMatrix getEpipolarLinesInRight() {
<span class="nc" id="L1446">        return epipolarLinesInRight;</span>
    }
    public SimpleMatrix getEpipolarLinesInLeft() {
<span class="nc" id="L1449">        return epipolarLinesInLeft;</span>
    }
    
    public PairIntArray getEpipolarLineInLeft(int imgWidth, int imgHeight, 
        int pointNumber) {
        
<span class="nc" id="L1455">        return getEpipolarLine(epipolarLinesInLeft, imgWidth, imgHeight, </span>
             pointNumber);
    }
    
    public PairIntArray getEpipolarLineInRight(int imgWidth, int imgHeight, 
        int pointNumber) {
        
<span class="nc" id="L1462">        return getEpipolarLine(epipolarLinesInRight, imgWidth, imgHeight, </span>
            pointNumber);
    }
     
    PairIntArray getEpipolarLine(SimpleMatrix epipolarLines, int imgWidth, 
        int imgHeight, int pointNumber) {
        
<span class="fc" id="L1469">        int n = imgWidth/10;</span>
        
<span class="fc" id="L1471">        PairIntArray line = new PairIntArray(n);</span>
        
<span class="fc" id="L1473">        double a = epipolarLines.get(0, pointNumber);</span>
<span class="fc" id="L1474">        double b = epipolarLines.get(1, pointNumber);</span>
<span class="fc" id="L1475">        double c = epipolarLines.get(2, pointNumber);</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        boolean isHoriz = (Math.abs(a/b) &lt;= 1.0);</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        if (isHoriz) {</span>
<span class="fc bfc" id="L1478" title="All 2 branches covered.">            for (int x = 0; x &lt; imgWidth; x++) {</span>
                //y = - (a/b) * x - (c/b)
<span class="fc" id="L1480">                double y = (c + (a * (double)x)) / (-b);</span>
<span class="fc" id="L1481">                line.add(x, (int) Math.round(y));</span>
            }
        } else {
<span class="fc bfc" id="L1484" title="All 2 branches covered.">            for (int y = 0; y &lt; imgHeight; y++) {</span>
                //y = - (a/b) * x - (c/b)
                //y+(c/b) = - (a/b) * x 
                // ==&gt; x = (-b/a) * (y+(c/b)) = y*(-b/a) - (c/a)
<span class="fc" id="L1488">                double x = -(c + (b * (double)y))/a;</span>
<span class="fc" id="L1489">                line.add((int) Math.round(x), y);</span>
            }
        }
  
<span class="fc" id="L1493">        return line;</span>
    }
    
    SimpleMatrix calculateEpipolarRightLines(SimpleMatrix points) {
<span class="nc" id="L1497">        return fundamentalMatrix.mult(points);</span>
    }
    
    SimpleMatrix calculateEpipolarLeftLines(SimpleMatrix points) {
<span class="nc" id="L1501">        return fundamentalMatrix.transpose().mult(points);</span>
    }

    public StereoProjectionTransformerFit evaluateFitForUnmatched(
        SimpleMatrix fm, SimpleMatrix leftPoints, SimpleMatrix rightPoints, 
        double tolerance, PairIntArray matchedIndexes) {
        
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1509">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
        
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L1513">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
        
<span class="nc bnc" id="L1516" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L1517">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
        
<span class="nc" id="L1520">        SimpleMatrix theRightEpipolarLines = fm.mult(leftPoints);</span>
       
<span class="nc" id="L1522">        SimpleMatrix theLeftEpipolarLines = fm.transpose().mult(rightPoints);</span>
        
        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
        
        /*
        for each left point, it's match in the right must be one of the closest
        to the right epipolar line and vice versa.
        
        one needs a bipartite matching (optimal matching) for each right
        epipolar line to the best reciprocating point within a certain distance,
        else no match.
        
        leftxy[0] has re[0] which finds rightxy[10],rightxy[12], rightxy[51]
           within tolerance.
           rightxy[10] has le[10] which &gt; tolerance from leftxy[0].
           rightxy[12] has le[12] which &lt; tolerance from leftxy[0].
           rightxy[51] has le[51] which &gt; tolerance from leftxy[0].
           ==&gt; so leftxy[0] would be matched with rightxy[12]
           and put into a left skip list to avoid repeating and
           put into a right skip list.
        
        this approach is however, a greedy match.  a point visited after 
        leftxy[0] might be the correct match to rightxy[12] and leftxy[0]
        might be noise.
        
        so an optimal match is possibly needed for some datasets.  the runtime
        complexity for an optimal match is large, so it should be avoided
        when possible (~O(N^4)).
       
        so, the distance stored for the match leftxy[i] to rightxy[j] would
        be the 2 added and this
        */
        
<span class="nc" id="L1555">        return evaluateFitForUnmatchedOptimal(fm, theRightEpipolarLines,</span>
            theLeftEpipolarLines, leftPoints, rightPoints, tolerance,
            matchedIndexes);
    }
  
    /**
     * 
     * @param fm
     * @param rightEpipolarLines
     * @param leftEpipolarLines
     * @param leftPoints
     * @param rightPoints
     * @param tolerance
     * @param matchedIndexes x is index from leftPoints.  y is index from 
     * rightPoints.
     * @return 
     */
    StereoProjectionTransformerFit evaluateFitForUnmatchedOptimal(
        SimpleMatrix fm, 
        SimpleMatrix rightEpipolarLines, SimpleMatrix leftEpipolarLines,
        SimpleMatrix leftPoints, SimpleMatrix rightPoints, double tolerance,
        PairIntArray matchedIndexes) {
        
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1579">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1581" title="All 2 branches missed.">        if (rightEpipolarLines == null) {</span>
<span class="nc" id="L1582">            throw new IllegalArgumentException(</span>
            &quot;rightEpipolarLines cannot be null&quot;);
        }
<span class="nc bnc" id="L1585" title="All 2 branches missed.">        if (leftEpipolarLines == null) {</span>
<span class="nc" id="L1586">            throw new IllegalArgumentException(</span>
            &quot;leftEpipolarLines cannot be null&quot;);
        }
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L1590">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1592" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L1593">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
        
<span class="nc" id="L1596">        float[] diffs = matchOptimallyAndCalcResiduals(fm, </span>
            rightEpipolarLines, leftEpipolarLines,
            leftPoints, rightPoints, tolerance, matchedIndexes);
                    
<span class="nc" id="L1600">        float[] avgAndStdDev = MiscMath.getAvgAndStDev(diffs);</span>
        
<span class="nc" id="L1602">        StereoProjectionTransformerFit fit = null;</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        if (diffs.length &gt; 0) {</span>
<span class="nc" id="L1604">            fit = new StereoProjectionTransformerFit(fm,</span>
                diffs.length, tolerance, 
                avgAndStdDev[0], avgAndStdDev[1]);
        } else {
<span class="nc" id="L1608">            fit = new StereoProjectionTransformerFit(fm,</span>
                diffs.length, tolerance, 
                Double.MAX_VALUE, Double.MAX_VALUE);
        }
        
<span class="nc" id="L1613">        int nMaxMatchable = leftPoints.numCols();</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">        if (rightPoints.numCols() &lt; nMaxMatchable) {</span>
<span class="nc" id="L1615">            nMaxMatchable = rightPoints.numCols();</span>
        }
        
<span class="nc" id="L1618">        fit.setNMaxMatchable(nMaxMatchable);</span>
        
<span class="nc" id="L1620">        return fit;</span>
    }
    
    float[] matchOptimallyAndCalcResiduals(
        SimpleMatrix fm, 
        SimpleMatrix rightEpipolarLines, SimpleMatrix leftEpipolarLines,
        SimpleMatrix leftPoints, SimpleMatrix rightPoints, double tolerance,
        PairIntArray outputMatchedIndexes) {
        
<span class="nc bnc" id="L1629" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1630">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1632" title="All 2 branches missed.">        if (rightEpipolarLines == null) {</span>
<span class="nc" id="L1633">            throw new IllegalArgumentException(</span>
            &quot;rightEpipolarLines cannot be null&quot;);
        }
<span class="nc bnc" id="L1636" title="All 2 branches missed.">        if (leftEpipolarLines == null) {</span>
<span class="nc" id="L1637">            throw new IllegalArgumentException(</span>
            &quot;leftEpipolarLines cannot be null&quot;);
        }
<span class="nc bnc" id="L1640" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L1641">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1643" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L1644">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
        
        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
        
        /*
        for each left point, it's match in the right must be one of the closest
        to the right epipolar line and vice versa.
        
        one needs a bipartite matching (optimal matching) for each right
        epipolar line to the best reciprocating point within a certain distance,
        else no match.
        
        leftxy[0] has re[0] which finds rightxy[10],rightxy[12], rightxy[51]
           within tolerance.
           rightxy[10] has le[10] which &gt; tolerance from leftxy[0].
           rightxy[12] has le[12] which &lt; tolerance from leftxy[0].
           rightxy[51] has le[51] which &gt; tolerance from leftxy[0].
           ==&gt; so leftxy[0] would be matched with rightxy[12]
           and put into a left skip list to avoid repeating and
           put into a right skip list.
        
        this approach is however, a greedy match.  a point visited after 
        leftxy[0] might be the correct match to rightxy[12] and leftxy[0]
        might be noise.
        
        so an optimal match is possibly needed for some datasets.  the runtime
        complexity for an optimal match is large, so it should be avoided
        when possible (~O(N^4)).
       
        so, the distance stored for the match leftxy[i] to rightxy[j] would
        be the 2 added and this
        */
                
<span class="nc" id="L1678">        int nPoints1 = rightEpipolarLines.numCols();</span>
<span class="nc" id="L1679">        int nPoints2 = leftEpipolarLines.numCols();</span>
        
<span class="nc bnc" id="L1681" title="All 4 branches missed.">        if ((nPoints1 == 0) || (nPoints2 == 0)) {</span>
<span class="nc" id="L1682">            return new float[0];</span>
        }
        
<span class="nc" id="L1685">        float[][] diffsAsCost = new float[nPoints1][nPoints2];</span>
        // the algorithm modifies diffsAsCost, so make a copy
<span class="nc" id="L1687">        float[][] diffsAsCostCopy = new float[nPoints1][nPoints2];</span>
        
<span class="nc bnc" id="L1689" title="All 2 branches missed.">        for (int i = 0; i &lt; leftPoints.numCols(); i++) {</span>

<span class="nc" id="L1691">            diffsAsCost[i] = new float[nPoints2];</span>
<span class="nc" id="L1692">            diffsAsCostCopy[i] = new float[nPoints2];</span>
        
<span class="nc" id="L1694">            double a = rightEpipolarLines.get(0, i);</span>
<span class="nc" id="L1695">            double b = rightEpipolarLines.get(1, i);</span>
<span class="nc" id="L1696">            double c = rightEpipolarLines.get(2, i);</span>
            
<span class="nc" id="L1698">            double aplusb = Math.sqrt((a*a) + (b*b));</span>
            
<span class="nc" id="L1700">            double xL = leftPoints.get(0, i);</span>
<span class="nc" id="L1701">            double yL = leftPoints.get(1, i);</span>
        
            //dist = (a*x + b*y + c)/sqrt(a^2 + b^2)
            
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            for (int j = 0; j &lt; rightPoints.numCols(); j++) {</span>
                
<span class="nc" id="L1707">                double x = rightPoints.get(0, j);</span>
<span class="nc" id="L1708">                double y = rightPoints.get(1, j);</span>
                
<span class="nc" id="L1710">                double d = (a*x + b*y + c)/aplusb;</span>
                
                // find the reverse distance by projection:
<span class="nc" id="L1713">                double aRev = leftEpipolarLines.get(0, j);</span>
<span class="nc" id="L1714">                double bRev = leftEpipolarLines.get(1, j);</span>
<span class="nc" id="L1715">                double cRev = leftEpipolarLines.get(2, j);</span>
                
<span class="nc" id="L1717">                double dRev = (aRev*xL + bRev*yL + cRev)/</span>
<span class="nc" id="L1718">                    Math.sqrt((aRev*aRev + bRev*bRev));</span>
                
<span class="nc" id="L1720">                float dist = (float)Math.sqrt(d*d + dRev*dRev);</span>

<span class="nc bnc" id="L1722" title="All 2 branches missed.">                if (dist &gt; 1.414*tolerance) {</span>
<span class="nc" id="L1723">                    dist = Float.MAX_VALUE;</span>
                }
<span class="nc" id="L1725">                diffsAsCost[i][j] = dist;</span>
<span class="nc" id="L1726">                diffsAsCostCopy[i][j] = dist;</span>
            }
        }
        
<span class="nc" id="L1730">        boolean transposed = false;</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">        if (nPoints1 &gt; nPoints2) {</span>
<span class="nc" id="L1732">            diffsAsCostCopy = MatrixUtil.transpose(diffsAsCostCopy);</span>
<span class="nc" id="L1733">            transposed = true;</span>
        }
        
<span class="nc" id="L1736">        HungarianAlgorithm b = new HungarianAlgorithm();</span>
<span class="nc" id="L1737">        int[][] match = b.computeAssignments(diffsAsCostCopy);</span>
        
        // count the number of matches before tolerance filter
<span class="nc" id="L1740">        int count = 0;</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
<span class="nc" id="L1742">            int idx1 = match[i][0];</span>
<span class="nc" id="L1743">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L1744" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1745">                continue;</span>
            }
<span class="nc" id="L1747">            count++;</span>
        }
        
        // at this point, have matches between 1 --&gt; 2 and a tolerance.
        // could return a tolerance filtered
        // reduced match list and the diffs for use with other methods
        // (for example, an invoker with mathing goals could use the
        // match list
        
        // x is index from leftPoints.  y is index from rightPoints.                
<span class="nc" id="L1757">        float[] diffs = new float[count];</span>
        
<span class="nc" id="L1759">        int nMatched = 0;</span>
        
<span class="nc bnc" id="L1761" title="All 2 branches missed.">        for (int i = 0; i &lt; match.length; i++) {</span>
           
<span class="nc" id="L1763">            int idx1 = match[i][0];</span>
<span class="nc" id="L1764">            int idx2 = match[i][1];</span>
<span class="nc bnc" id="L1765" title="All 4 branches missed.">            if (idx1 == -1 || idx2 == -1) {</span>
<span class="nc" id="L1766">                continue;</span>
            }
                        
<span class="nc bnc" id="L1769" title="All 2 branches missed.">            if (transposed) {</span>
<span class="nc" id="L1770">                int swap = idx1;</span>
<span class="nc" id="L1771">                idx1 = idx2;</span>
<span class="nc" id="L1772">                idx2 = swap;</span>
            }
            
<span class="nc" id="L1775">            float dist = diffsAsCost[idx1][idx2];</span>
            
<span class="nc bnc" id="L1777" title="All 2 branches missed.">            if (dist &gt; tolerance) {</span>
<span class="nc" id="L1778">                continue;</span>
            }
            
<span class="nc" id="L1781">            diffs[nMatched] = dist;</span>
            
<span class="nc" id="L1783">            outputMatchedIndexes.add(idx1, idx2);</span>
            
<span class="nc" id="L1785">            nMatched++;</span>
        }
        
<span class="nc" id="L1788">        diffs = Arrays.copyOf(diffs, nMatched);</span>
        
<span class="nc" id="L1790">        return diffs;</span>
    }
    
    /**
     * evaluate fit for matched point sets and the fundamental matrix
     * @param fm
     * @param matchedLeftPoints
     * @param matchedRightPoints
     * @param tolerance
     * @return 
     */
    public StereoProjectionTransformerFit evaluateFitForAlreadyMatched(
        SimpleMatrix fm, SimpleMatrix matchedLeftPoints, 
        SimpleMatrix matchedRightPoints, double tolerance) {
        
<span class="pc bpc" id="L1805" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1806">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L1809" title="1 of 2 branches missed.">        if (matchedLeftPoints == null) {</span>
<span class="nc" id="L1810">            throw new IllegalArgumentException(</span>
            &quot;matchedLeftPoints cannot be null&quot;);
        }
        
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">        if (matchedRightPoints == null) {</span>
<span class="nc" id="L1815">            throw new IllegalArgumentException(</span>
            &quot;matchedRightPoints cannot be null&quot;);
        }
        
<span class="fc" id="L1819">        SimpleMatrix theRightEpipolarLines = fm.mult(matchedLeftPoints);</span>
       
<span class="fc" id="L1821">        SimpleMatrix theLeftEpipolarLines = fm.transpose().mult(matchedRightPoints);</span>
        
        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
      
<span class="fc" id="L1825">        return evaluateFitForAlreadyMatched(fm, theRightEpipolarLines,</span>
            theLeftEpipolarLines, matchedLeftPoints, matchedRightPoints, 
            tolerance);
    }
    
    /**
     * evaluate fit for already matched point lists
     * @param fm
     * @param rightEpipolarLines
     * @param leftEpipolarLines
     * @param leftPoints
     * @param rightPoints
     * @param tolerance
     * @return 
     */
    StereoProjectionTransformerFit evaluateFitForAlreadyMatched(
        SimpleMatrix fm, 
        SimpleMatrix rightEpipolarLines, SimpleMatrix leftEpipolarLines,
        SimpleMatrix leftPoints, SimpleMatrix rightPoints, double tolerance) {
        
<span class="pc bpc" id="L1845" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1846">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">        if (rightEpipolarLines == null) {</span>
<span class="nc" id="L1849">            throw new IllegalArgumentException(</span>
            &quot;rightEpipolarLines cannot be null&quot;);
        }
<span class="pc bpc" id="L1852" title="1 of 2 branches missed.">        if (leftEpipolarLines == null) {</span>
<span class="nc" id="L1853">            throw new IllegalArgumentException(</span>
            &quot;leftEpipolarLines cannot be null&quot;);
        }
<span class="pc bpc" id="L1856" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L1857">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L1860">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
        
<span class="fc" id="L1863">        float[] diffs = new float[leftPoints.numCols()];</span>
        
<span class="fc" id="L1865">        int nMatched = 0;</span>
        
<span class="fc" id="L1867">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>
        
<span class="fc bfc" id="L1869" title="All 2 branches covered.">        for (int i = 0; i &lt; leftPoints.numCols(); i++) {</span>

<span class="fc" id="L1871">            double a = rightEpipolarLines.get(0, i);</span>
<span class="fc" id="L1872">            double b = rightEpipolarLines.get(1, i);</span>
<span class="fc" id="L1873">            double c = rightEpipolarLines.get(2, i);</span>
            
<span class="fc" id="L1875">            double aplusb = Math.sqrt((a*a) + (b*b));</span>
            
<span class="fc" id="L1877">            double xL = leftPoints.get(0, i);</span>
<span class="fc" id="L1878">            double yL = leftPoints.get(1, i);</span>
        
            //dist = (a*x + b*y + c)/sqrt(a^2 + b^2)
            
<span class="fc" id="L1882">            double x = rightPoints.get(0, i);</span>
<span class="fc" id="L1883">            double y = rightPoints.get(1, i);</span>
                
<span class="fc" id="L1885">            double d = (a*x + b*y + c)/aplusb;</span>
                
            // find the reverse distance by projection:
<span class="fc" id="L1888">            double aRev = leftEpipolarLines.get(0, i);</span>
<span class="fc" id="L1889">            double bRev = leftEpipolarLines.get(1, i);</span>
<span class="fc" id="L1890">            double cRev = leftEpipolarLines.get(2, i);</span>

<span class="fc" id="L1892">            double dRev = (aRev*xL + bRev*yL + cRev)/</span>
<span class="fc" id="L1893">                Math.sqrt((aRev*aRev + bRev*bRev));</span>

<span class="fc" id="L1895">            float dist = (float)Math.sqrt(d*d + dRev*dRev);</span>

<span class="fc bfc" id="L1897" title="All 2 branches covered.">            if (dist &gt; tolerance) {</span>
<span class="fc" id="L1898">                continue;</span>
            }
            
<span class="fc" id="L1901">            inlierIndexes.add(Integer.valueOf(i));</span>
            
<span class="fc" id="L1903">            diffs[nMatched] = dist;</span>
            
<span class="fc" id="L1905">            nMatched++;</span>
        }
        
<span class="fc" id="L1908">        diffs = Arrays.copyOf(diffs, nMatched);</span>
        
<span class="fc" id="L1910">        float[] avgAndStdDev = MiscMath.getAvgAndStDev(diffs);</span>
        
<span class="fc" id="L1912">        StereoProjectionTransformerFit fit = null;</span>
<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">        if (diffs.length &gt; 0) {</span>
<span class="fc" id="L1914">            fit = new StereoProjectionTransformerFit(fm, </span>
                diffs.length, tolerance, 
                avgAndStdDev[0], avgAndStdDev[1]);
        } else {
<span class="nc" id="L1918">            fit = new StereoProjectionTransformerFit(fm, </span>
                diffs.length, tolerance, 
                Double.MAX_VALUE, Double.MAX_VALUE);
        }
        
<span class="fc" id="L1923">        fit.setNMaxMatchable(leftPoints.numCols());</span>
        
<span class="fc" id="L1925">        fit.setInlierIndexes(inlierIndexes);</span>
        
<span class="fc" id="L1927">        return fit;</span>
    }

    public PairIntArray getRightXYInt() {
<span class="nc" id="L1931">        return getXYInt(rightXY);</span>
    }
    
    public PairIntArray getLeftXYInt() {                         
<span class="nc" id="L1935">        return getXYInt(leftXY);</span>
    }
    
    public int getNumberOfMatches() {
<span class="nc" id="L1939">        return leftXY.numCols();</span>
    }
    
    public PairFloatArray getRightXYFloat() {                         
<span class="nc" id="L1943">        return getXYFloat(rightXY);</span>
    }
    
    public PairFloatArray getLeftXYFloat() {
<span class="nc" id="L1947">        return getXYFloat(leftXY);</span>
    }
    
    private PairIntArray getXYInt(SimpleMatrix leftOrRightXY) {
                
<span class="nc" id="L1952">        int nPoints = leftOrRightXY.numCols();</span>
         
<span class="nc" id="L1954">        PairIntArray out = new PairIntArray();</span>
        
<span class="nc bnc" id="L1956" title="All 2 branches missed.">        for (int i = 0; i &lt; nPoints; i++) {</span>
            
<span class="nc" id="L1958">            float xP = (float) leftOrRightXY.get(0, i);</span>
<span class="nc" id="L1959">            float yP = (float) leftOrRightXY.get(1, i);</span>
           
<span class="nc" id="L1961">            out.add(Math.round(xP), Math.round(yP));</span>
        }
        
<span class="nc" id="L1964">        return out;</span>
    }
    
    private PairFloatArray getXYFloat(SimpleMatrix leftOrRightXY) {
                
<span class="nc" id="L1969">        int nPoints = leftOrRightXY.numCols();</span>
         
<span class="nc" id="L1971">        PairFloatArray out = new PairFloatArray();</span>
        
<span class="nc bnc" id="L1973" title="All 2 branches missed.">        for (int i = 0; i &lt; nPoints; i++) {</span>
            
<span class="nc" id="L1975">            float xP = (float) leftOrRightXY.get(0, i);</span>
<span class="nc" id="L1976">            float yP = (float) leftOrRightXY.get(1, i);</span>
           
<span class="nc" id="L1978">            out.add(xP, yP);</span>
        }
        
<span class="nc" id="L1981">        return out;</span>
    }
    
    /**
     * calculate the epipolar projection among the given points with the
     * assumption that some of the matches are not true matches.  It uses
     * a RANSAC approach and subsets to find inliers (true, low error matches)
     * and the calculates the fundamental matrix from those.
     * 
     * @param matchedLeftXY
     * @param matchedRightXY
     * @param outputLeftXY
     * @param outputRightXY
     * @return
     * @throws NoSuchAlgorithmException 
     */
    public StereoProjectionTransformerFit calculateEpipolarProjection(
        PairFloatArray matchedLeftXY, PairFloatArray matchedRightXY,
        PairFloatArray outputLeftXY, PairFloatArray outputRightXY) 
        throws NoSuchAlgorithmException {
        
<span class="nc" id="L2002">        RANSACSolver ransacSolver = new RANSACSolver();</span>
        
<span class="nc" id="L2004">        return ransacSolver.calculateEpipolarProjection(matchedLeftXY, </span>
            matchedRightXY, outputLeftXY, outputRightXY);
    }
    
    /**
    calculate the 4 possible projection matrices from the essential matrix.
    * Note that the essential matrix is the transformation matrix between points
    * that are in camera coordinates rather than in pixel coordinates.
    the method is adapted from: https://github.com/jesolem/PCV
    Their code is licensed under  BSD license (2-clause &quot;Simplified BSD License&quot;).
    */
    /*
    public SimpleMatrix[] calculatePFromEssential(SimpleMatrix essentialMatrix) {
        
        SimpleSVD&lt;SimpleMatrix&gt; svd = essentialMatrix.svd();
        
        SimpleMatrix v = svd.getV();
        double val = svd.getU().dot(v);
        if (val &lt; 0) {
            v = v.scale(-1);
        }
       
        SimpleMatrix diag = new SimpleMatrix();
        diag.set(0, 0, 1);
        diag.set(1, 1, 1);
        double[][] dDotV = MatrixUtil.dot(diag, v);
        SimpleMatrix d = new SimpleMatrix(dDotV);
        
        SimpleMatrix essentialMatrix2 = svd.getU().mult(d);
        
        SimpleMatrix w = new SimpleMatrix(3, 3);
        w.set(0, 1, -1);
        w.set(1, 0, 1);
        w.set(2, 2, 1);
        
        SimpleMatrix u = svd.getU();
        
        SimpleMatrix uwv = w.mult(v);
        uwv = u.mult(uwv);
        
        SimpleMatrix uwTransposev = u.mult(w.transpose().mult(v));
        
        SimpleMatrix uLastCol = u.extractVector(false, 2);
        
        SimpleMatrix pt1 = u.mult(uwv).transpose();
        SimpleMatrix pt2 = u.mult(uwTransposev).transpose();
        
        //dot(U,dot(W,V)).T,U[:,2])
        SimpleMatrix p1;//pt1,  uLastCol
        
        //(dot(U,dot(W,V)).T,-U[:,2])
        SimpleMatrix p2;//pt1, -uLastCol
        
        //(dot(U,dot(W.T,V)).T,U[:,2])
        SimpleMatrix p3;//pt2, uLastCol
        
        //(dot(U,dot(W.T,V)).T,-U[:,2])
        SimpleMatrix p4;//pt2, -uLastCol
        
    }*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
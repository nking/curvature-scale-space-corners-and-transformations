<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ContourFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">ContourFinder.java</span></div><h1>ContourFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.misc.MiscDebug;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import algorithms.util.PairIntArrayWithColor;
import algorithms.util.ScatterPointPlotterPNG;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 * class to identity contours in scale space images.
 *
 * @author nichole
 */
public class ContourFinder {

<span class="fc" id="L23">    private double thresholdFactor = 0.15;</span>

<span class="fc" id="L25">    protected Logger log = null;</span>

<span class="fc" id="L27">    private float overrideLimit = -1;</span>

<span class="fc" id="L29">    public ContourFinder() {</span>
<span class="fc" id="L30">        log = Logger.getLogger(this.getClass().getName());</span>
<span class="fc" id="L31">    }</span>

    public void overrideTheLowSigmaLimit(float lowSigmaLimit) {
<span class="nc bnc" id="L34" title="All 2 branches missed.">        if (lowSigmaLimit &gt; 1) {</span>
<span class="nc" id="L35">            overrideLimit = lowSigmaLimit;</span>
        }
<span class="nc" id="L37">    }</span>

    /**
     * find contours in this scale space map for an edge of given edgeNumber.
     * Note that the edgeNumber is not used, but is kept for use with the
     * indexes in debugging later.
     *
     * @param scaleSpaceImage
     * @param edgeNumber
     * @return
     */
    public List&lt;CurvatureScaleSpaceContour&gt; findContours(
        ScaleSpaceCurveImage scaleSpaceImage, int edgeNumber) {

<span class="fc" id="L51">        List&lt;CurvatureScaleSpaceContour&gt; contours = new ArrayList&lt;CurvatureScaleSpaceContour&gt;();</span>

<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if ((scaleSpaceImage == null)</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">            || (scaleSpaceImage.getImageSigmas().length == 0)) {</span>
<span class="fc" id="L55">            return contours;</span>
        }

<span class="fc" id="L58">        ScaleSpaceCurveImage space = scaleSpaceImage.copy();</span>

<span class="fc" id="L60">        double lowLimit = space.getImageSigmas()[0] * thresholdFactor;</span>
        //TODO: consider a low limit of sigma=3
<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (lowLimit &lt; 3) {</span>
<span class="fc" id="L63">            lowLimit = 3;</span>
        }

        // find the first contour at this height and extract it from the
        // dataset, nulling
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        for (int i = 0; i &lt; space.getImageSigmas().length; i++) {</span>

<span class="fc" id="L70">            float sigma = space.getImageSigmas()[i];</span>

<span class="pc bpc" id="L72" title="1 of 2 branches missed.">            if (overrideLimit &gt; -1) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">                if (sigma &lt; overrideLimit) {</span>
<span class="nc" id="L74">                    break;</span>
                }
<span class="fc bfc" id="L76" title="All 2 branches covered.">            } else if (sigma &lt; lowLimit) {</span>
<span class="fc" id="L77">                break;</span>
            }

<span class="fc" id="L80">            boolean extract = true;</span>

<span class="fc bfc" id="L82" title="All 2 branches covered.">            while (extract) {</span>

<span class="fc" id="L84">                CurvatureScaleSpaceContour contour = extractNextContour(</span>
                    scaleSpaceImage, i);

<span class="fc bfc" id="L87" title="All 2 branches covered.">                if (contour != null) {</span>

<span class="fc" id="L89">                    contours.add(contour);</span>

                } else {
<span class="fc" id="L92">                    extract = false;</span>
                }
<span class="fc" id="L94">            }</span>
        }

<span class="fc" id="L97">        correctForWrappedContours(contours);</span>

<span class="fc" id="L99">        return contours;</span>
    }

    private CurvatureScaleSpaceContour extractNextContour(
        ScaleSpaceCurveImage scaleSpaceImage, int sigmaIndex) {

<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if ((scaleSpaceImage == null)</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            || (scaleSpaceImage.getScaleSpaceImage().length == 0)) {</span>
<span class="nc" id="L107">            return null;</span>
        }

<span class="fc" id="L110">        float[] t = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex];</span>

<span class="pc bpc" id="L112" title="1 of 4 branches missed.">        if (t == null || t.length == 0) {</span>
<span class="fc" id="L113">            return null;</span>
        }

<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (int i = 0; i &lt; t.length; i++) {</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (t[i] &lt; 0) {</span>
<span class="fc" id="L119">                continue;</span>
            }

<span class="fc" id="L122">            CurvatureScaleSpaceContour contour = extractContour(scaleSpaceImage,</span>
                sigmaIndex, i);

<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (contour != null) {</span>

<span class="fc" id="L127">                return contour;</span>
            }
        }

<span class="fc" id="L131">        return null;</span>
    }

    private CurvatureScaleSpaceContour extractContour(ScaleSpaceCurveImage scaleSpaceImage, int sigmaIndex, int tIndex) {

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if ((scaleSpaceImage == null)</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            || (scaleSpaceImage.getScaleSpaceImage().length == 0)) {</span>
<span class="nc" id="L138">            return null;</span>
        }

<span class="fc" id="L141">        float tPoint = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (tPoint &lt; 0) {</span>
<span class="nc" id="L143">            return null;</span>
        }

<span class="fc" id="L146">        int nToRight = 0;</span>

<span class="fc" id="L148">        for (int i = (tIndex + 1);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            i &lt; scaleSpaceImage.getScaleSpaceImage()[sigmaIndex].length;</span>
<span class="fc" id="L150">            i++) {</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][i] &gt;= 0) {</span>
<span class="fc" id="L153">                nToRight++;</span>
            }
        }

<span class="fc" id="L157">        float sigma = scaleSpaceImage.getImageSigmas()[sigmaIndex];</span>

<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (nToRight == 0) {</span>

            // single peak contour if the value is larger than zero
<span class="fc" id="L162">            float t = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (t &lt; 0) {</span>
                // this has alredy been extracted, so return null
<span class="nc" id="L166">                return null;</span>
            }

<span class="fc" id="L169">            CurvatureScaleSpaceContour contour = new CurvatureScaleSpaceContour(</span>
                sigma, t);

<span class="fc" id="L172">            contour.setEdgeNumber(scaleSpaceImage.getEdgeNumber());</span>

<span class="fc" id="L174">            float t0 = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>
<span class="fc" id="L175">            int idx0 = Math.round(t0 * scaleSpaceImage.getEdgeSize());</span>

<span class="fc" id="L177">            CurvatureScaleSpaceImagePoint point0</span>
                = new CurvatureScaleSpaceImagePoint(sigma, t,
<span class="fc" id="L179">                    scaleSpaceImage.getXCoord(sigmaIndex, tIndex),</span>
<span class="fc" id="L180">                    scaleSpaceImage.getYCoord(sigmaIndex, tIndex),</span>
                    idx0);

<span class="fc" id="L183">            CurvatureScaleSpaceImagePoint[] peakPoints</span>
                = new CurvatureScaleSpaceImagePoint[]{point0};

<span class="fc" id="L186">            contour.setPeakDetails(peakPoints);</span>

            // for case when there's a single point for the peak:
<span class="fc" id="L189">            removeContourFromImage(scaleSpaceImage, sigmaIndex, tIndex);</span>

<span class="fc" id="L191">            return contour;</span>
        }

        /*
         Find the next non-negative value in scaleSpaceImage for sigma
         and determine where it's right branch is if any.

         For now, will assume that there is never an embedded contour
         which is starting, that is peaking at this same sigma level.

         Will look for the first non-negative to be a single peak
         or the left of a left and right of a peak.
         */
<span class="fc" id="L204">        boolean isASinglePeak = false;</span>

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (sigmaIndex == (scaleSpaceImage.getImageSigmas().length - 1)) {</span>

            // if there's a -1 to the right it's a single point, else, it
            // may be left and right branch or it may not.  doesn't matter
            // very much because this is the bottom sigma of the image
<span class="nc" id="L211">            float[] t = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex];</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (tIndex == (t.length - 1)) {</span>
<span class="nc" id="L213">                isASinglePeak = true;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            } else if (t[tIndex + 1] == -1) {</span>
<span class="nc" id="L215">                isASinglePeak = true;</span>
            }

<span class="nc" id="L218">        } else {</span>
            // descend one level to see if there are 2 peaks
            // under the current peak that are left and right of it.
            // if the right is closer than the next point on this same level,
            // the current point is a peak
<span class="fc" id="L223">            int leftIndexBelow = -1;</span>
<span class="fc" id="L224">            int rightIndexBelow = -1;</span>
<span class="fc" id="L225">            float minDiffLeftBelow = Float.MAX_VALUE;</span>
<span class="fc" id="L226">            float minDiffRightBelow = Float.MAX_VALUE;</span>

<span class="fc" id="L228">            float[] t = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex + 1];</span>
            // sometimes for low sigma, the contours are misshapen and have
            // vertical gaps, so iterating now to levels below to assert have
            // the contour values below this peak or partial peak
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (sigma &lt; 3.5) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                int t0 = (tIndex &gt; 0) ? (tIndex - 1) : tIndex;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                int t1 = ((tIndex + 1) &lt; t.length) ? tIndex + 1 : tIndex;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                if (t1 &gt; t0) {</span>
<span class="fc" id="L236">                    int si = sigmaIndex + 1;</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                    while (si &lt; (scaleSpaceImage.getScaleSpaceImage().length - 1)) {</span>
<span class="fc" id="L238">                        t = scaleSpaceImage.getScaleSpaceImage()[si + 1];</span>
<span class="fc" id="L239">                        int n = 0;</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                        for (int j = t0; j &lt; t.length; j++) {</span>
<span class="fc" id="L241">                            float tt = t[j];</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                            if (tt &gt; -1) {</span>
<span class="fc" id="L243">                                n++;</span>
                            }
                        }
<span class="fc bfc" id="L246" title="All 2 branches covered.">                        if (n &gt; 1) {</span>
<span class="fc" id="L247">                            break;</span>
                        }
<span class="fc" id="L249">                        si++;</span>
<span class="fc" id="L250">                    }</span>
                }
            }

<span class="fc bfc" id="L254" title="All 2 branches covered.">            int start = (tIndex &gt; 0) ? (tIndex - 1) : tIndex;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            for (int j = start; j &lt; t.length; j++) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">                if (t[j] &lt; 0) {</span>
<span class="fc" id="L257">                    continue;</span>
                }
<span class="fc" id="L259">                float lD = tPoint - t[j];</span>
<span class="fc" id="L260">                float rD = t[j] - tPoint;</span>

<span class="pc bpc" id="L262" title="1 of 4 branches missed.">                if ((lD &gt;= 0) &amp;&amp; (lD &lt; minDiffLeftBelow)) {</span>
<span class="fc" id="L263">                    minDiffLeftBelow = lD;</span>
<span class="fc" id="L264">                    leftIndexBelow = j;</span>
                }

<span class="fc bfc" id="L267" title="All 6 branches covered.">                if ((rD &gt;= 0) &amp;&amp; (rD &lt; minDiffRightBelow)</span>
                    &amp;&amp; (j &gt; leftIndexBelow)) {
<span class="fc" id="L269">                    minDiffRightBelow = rD;</span>
<span class="fc" id="L270">                    rightIndexBelow = j;</span>
                }
            }

<span class="fc" id="L274">            boolean isAnEdgePair = false;</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (rightIndexBelow == -1) {</span>
                //TODO: the 2nd conditional should be revised
<span class="fc bfc" id="L278" title="All 4 branches covered.">                if ((nToRight == 1) &amp;&amp; (tPoint &gt; 0.9)) {</span>
<span class="fc" id="L279">                    isAnEdgePair = true;</span>
                } else {
                    // this can happen if the contour has already been removed
<span class="fc" id="L282">                    return null;</span>
                }
            }

<span class="fc bfc" id="L286" title="All 2 branches covered.">            if (!isAnEdgePair) {</span>

<span class="fc" id="L288">                float tNext</span>
<span class="fc" id="L289">                    = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex + 1];</span>

<span class="fc bfc" id="L291" title="All 4 branches covered.">                isASinglePeak = (t[rightIndexBelow] &lt; tNext) || (tNext &lt; 0);</span>
            }
        }

<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (isASinglePeak) {</span>

            // it's a single peak
<span class="fc" id="L298">            CurvatureScaleSpaceContour contour = new CurvatureScaleSpaceContour(</span>
                sigma, tPoint);

<span class="fc" id="L301">            contour.setEdgeNumber(scaleSpaceImage.getEdgeNumber());</span>

<span class="fc" id="L303">            float t = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>

<span class="fc" id="L305">            float t0 = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>
<span class="fc" id="L306">            int idx0 = Math.round(t0 * scaleSpaceImage.getEdgeSize());</span>

<span class="fc" id="L308">            CurvatureScaleSpaceImagePoint point0</span>
                = new CurvatureScaleSpaceImagePoint(sigma, t,
<span class="fc" id="L310">                    scaleSpaceImage.getXCoord(sigmaIndex, tIndex),</span>
<span class="fc" id="L311">                    scaleSpaceImage.getYCoord(sigmaIndex, tIndex),</span>
                    idx0);

<span class="fc" id="L314">            CurvatureScaleSpaceImagePoint[] peakPoints</span>
                = new CurvatureScaleSpaceImagePoint[]{point0};

<span class="fc" id="L317">            contour.setPeakDetails(peakPoints);</span>

            // for case when there's a single point for the peak:
<span class="fc" id="L320">            removeContourFromImage(scaleSpaceImage, sigmaIndex, tIndex);</span>

<span class="fc" id="L322">            return contour;</span>

        } else {

            // else its the left side of a left and right point which are the peak
<span class="fc" id="L327">            float tNext</span>
<span class="fc" id="L328">                = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex + 1];</span>

<span class="fc" id="L330">            CurvatureScaleSpaceContour contour = new CurvatureScaleSpaceContour(</span>
                sigma, (tPoint + tNext) / 2.f);

<span class="fc" id="L333">            contour.setEdgeNumber(scaleSpaceImage.getEdgeNumber());</span>

<span class="fc" id="L335">            float t0 = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>
<span class="fc" id="L336">            float t1 = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex + 1];</span>

<span class="fc" id="L338">            int idx0 = Math.round(t0 * scaleSpaceImage.getEdgeSize());</span>
<span class="fc" id="L339">            int idx1 = Math.round(t1 * scaleSpaceImage.getEdgeSize());</span>

<span class="fc" id="L341">            CurvatureScaleSpaceImagePoint point0</span>
                = new CurvatureScaleSpaceImagePoint(sigma, t0,
<span class="fc" id="L343">                    scaleSpaceImage.getXCoord(sigmaIndex, tIndex),</span>
<span class="fc" id="L344">                    scaleSpaceImage.getYCoord(sigmaIndex, tIndex), idx0);</span>

<span class="fc" id="L346">            CurvatureScaleSpaceImagePoint point1</span>
                = new CurvatureScaleSpaceImagePoint(sigma, t1,
<span class="fc" id="L348">                    scaleSpaceImage.getXCoord(sigmaIndex, tIndex + 1),</span>
<span class="fc" id="L349">                    scaleSpaceImage.getYCoord(sigmaIndex, tIndex + 1), idx1);</span>

<span class="fc" id="L351">            CurvatureScaleSpaceImagePoint[] peakPoints</span>
                = new CurvatureScaleSpaceImagePoint[]{point0, point1};

<span class="fc" id="L354">            contour.setPeakDetails(peakPoints);</span>

<span class="fc" id="L356">            removeContourFromImage(scaleSpaceImage, sigmaIndex, tIndex,</span>
                tIndex + 1);

<span class="fc" id="L359">            return contour;</span>
        }

    }

    /**
     * remove the contour under a peak. Note that the method does not yet handle
     * complex morphologies, such as embedded contours right under the peak;
     *
     * @param scaleSpaceImage
     * @param sigmaIndex
     * @param tIndex
     */
    private void removeContourFromImage(ScaleSpaceCurveImage scaleSpaceImage,
        int sigmaIndex, int tIndex) {

<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if ((sigmaIndex &gt; (scaleSpaceImage.getScaleSpaceImage().length - 1))</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">            || (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex] == null)</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            || (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex].length == 0)) {</span>
<span class="nc" id="L378">            return;</span>
        }

<span class="fc" id="L381">        if ((tIndex</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">            &gt; (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex].length - 1))) {</span>
<span class="nc" id="L383">            return;</span>
        }

<span class="fc" id="L386">        float tLeft = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tIndex];</span>
<span class="fc" id="L387">        float tRight = tLeft;</span>
<span class="fc" id="L388">        int leftIndex = -1;</span>
<span class="fc" id="L389">        int rightIndex = -1;</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">        for (int i = sigmaIndex; i &lt; (sigmaIndex + 1); i++) {</span>

<span class="fc" id="L393">            float[] t = scaleSpaceImage.getScaleSpaceImage()[i];</span>

<span class="fc" id="L395">            float tPoint = t[tIndex];</span>

<span class="fc" id="L397">            leftIndex = -1;</span>
<span class="fc" id="L398">            rightIndex = -1;</span>
<span class="fc" id="L399">            float minDiffLeft = Float.MAX_VALUE;</span>
<span class="fc" id="L400">            float minDiffRight = Float.MAX_VALUE;</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            for (int j = tIndex; j &lt; t.length; j++) {</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">                if (t[j] &lt; 0) {</span>
<span class="fc" id="L404">                    continue;</span>
                }

<span class="fc" id="L407">                float lD = tPoint - t[j];</span>
<span class="fc" id="L408">                float rD = t[j] - tPoint;</span>

<span class="pc bpc" id="L410" title="1 of 4 branches missed.">                if ((lD &gt;= 0) &amp;&amp; (lD &lt; minDiffLeft)) {</span>
<span class="fc" id="L411">                    minDiffLeft = lD;</span>
<span class="fc" id="L412">                    leftIndex = j;</span>
                }

<span class="pc bpc" id="L415" title="2 of 6 branches missed.">                if ((rD &gt;= 0) &amp;&amp; (rD &lt; minDiffRight) &amp;&amp; (j &gt; leftIndex)) {</span>
<span class="fc" id="L416">                    minDiffRight = rD;</span>
<span class="fc" id="L417">                    rightIndex = j;</span>
                }
            }

<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if (leftIndex &gt; -1) {</span>
<span class="fc" id="L422">                tLeft = t[leftIndex];</span>
<span class="fc" id="L423">                t[leftIndex] = -1;</span>
            }
<span class="fc bfc" id="L425" title="All 2 branches covered.">            if (rightIndex &gt; -1) {</span>
<span class="fc" id="L426">                tRight = t[rightIndex];</span>
<span class="fc" id="L427">                t[rightIndex] = -1;</span>
            }

<span class="fc" id="L430">            boolean isEmpty = true;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            for (float tt : t) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                if (!(tt &lt; 0)) {</span>
<span class="fc" id="L433">                    isEmpty = false;</span>
<span class="fc" id="L434">                    break;</span>
                }
            }
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (isEmpty) {</span>
<span class="fc" id="L438">                scaleSpaceImage.getScaleSpaceImage()[sigmaIndex] = new float[0];</span>
            }
        }

<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (rightIndex == -1) {</span>
<span class="fc" id="L443">            rightIndex = leftIndex;</span>
        }

<span class="fc" id="L446">        removeContourFromImage(scaleSpaceImage, sigmaIndex + 1, leftIndex,</span>
            rightIndex);
<span class="fc" id="L448">    }</span>

    private void removeContourFromImage(ScaleSpaceCurveImage scaleSpaceImage,
        int sigmaIndex, int tLeftIndex, int tRightIndex) {

<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if ((scaleSpaceImage.getScaleSpaceImage() == null)</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            || (sigmaIndex &gt; (scaleSpaceImage.getScaleSpaceImage().length - 1))</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">            || (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex] == null)</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            || (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex].length == 0)) {</span>
<span class="fc" id="L457">            return;</span>
        }

<span class="fc" id="L460">        if ((tLeftIndex</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            &gt; (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex].length - 1))</span>
            || (tRightIndex
<span class="fc bfc" id="L463" title="All 2 branches covered.">            &gt; (scaleSpaceImage.getScaleSpaceImage()[sigmaIndex].length - 1))) {</span>
<span class="fc" id="L464">            return;</span>
        }

<span class="fc" id="L467">        float tLeft = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tLeftIndex];</span>
<span class="fc" id="L468">        float tRight = scaleSpaceImage.getScaleSpaceImage()[sigmaIndex][tRightIndex];</span>

<span class="fc bfc" id="L470" title="All 2 branches covered.">        for (int i = sigmaIndex; i &lt; scaleSpaceImage.getImageSigmas().length; i++) {</span>

<span class="fc" id="L472">            float[] t = scaleSpaceImage.getScaleSpaceImage()[i];</span>

<span class="fc" id="L474">            int leftIndex = -1;</span>
<span class="fc" id="L475">            int rightIndex = -1;</span>
<span class="fc" id="L476">            float minDiffLeft = Float.MAX_VALUE;</span>
<span class="fc" id="L477">            float minDiffRight = Float.MAX_VALUE;</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (int j = 0; j &lt; t.length; j++) {</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">                if (t[j] &lt; 0) {</span>
<span class="fc" id="L482">                    continue;</span>
                }

<span class="fc" id="L485">                float lD = tLeft - t[j];</span>
<span class="fc" id="L486">                float rD = t[j] - tRight;</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">                if (lD &lt; 0) {</span>
<span class="fc" id="L489">                    lD *= -1;</span>
                }
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (rD &lt; 0) {</span>
<span class="fc" id="L492">                    rD *= -1;</span>
                }

<span class="fc bfc" id="L495" title="All 2 branches covered.">                if (lD &lt; minDiffLeft) {</span>
<span class="fc" id="L496">                    minDiffLeft = lD;</span>
<span class="fc" id="L497">                    leftIndex = j;</span>
                }

<span class="fc bfc" id="L500" title="All 4 branches covered.">                if ((rD &lt; minDiffRight) &amp;&amp; (j &gt; leftIndex)) {</span>
<span class="fc" id="L501">                    minDiffRight = rD;</span>
<span class="fc" id="L502">                    rightIndex = j;</span>
                }
            }

            // TODO: improve correction for wrap around.
            // Also, this only includes peaks found at end, not beginning.
<span class="pc bpc" id="L508" title="1 of 8 branches missed.">            if ((leftIndex &gt; -1) &amp;&amp; (leftIndex == (t.length - 1))</span>
                &amp;&amp; (t[leftIndex] &gt;= 0.9)
                &amp;&amp; (t[0] &lt; 0.1)) {
<span class="fc" id="L511">                rightIndex = 0;</span>
            }

<span class="fc bfc" id="L514" title="All 2 branches covered.">            if (leftIndex &gt; -1) {</span>
<span class="fc" id="L515">                tLeft = t[leftIndex];</span>
<span class="fc" id="L516">                t[leftIndex] = -1;</span>
            }
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (rightIndex &gt; -1) {</span>
<span class="fc" id="L519">                tRight = t[rightIndex];</span>
<span class="fc" id="L520">                t[rightIndex] = -1;</span>
            }

<span class="fc" id="L523">            boolean isEmpty = true;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">            for (float tt : t) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                if (!(tt &lt; 0)) {</span>
<span class="fc" id="L526">                    isEmpty = false;</span>
<span class="fc" id="L527">                    break;</span>
                }
            }
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (isEmpty) {</span>
<span class="fc" id="L531">                scaleSpaceImage.getScaleSpaceImage()[sigmaIndex] = new float[0];</span>
            }
        }
<span class="fc" id="L534">    }</span>

    /**
     * looks for contours that may be wrap around contours that started near 1.0
     * and finished on the other side of zero, and corrects for that. Note that
     * this could be done more correctly before the left and right branches are
     * removed from the scale space image, but a correction at this stage
     * instead of that earlier stage is simpler and easier to maintain.
     *
     * @param contours
     */
    private void correctForWrappedContours(final List&lt;CurvatureScaleSpaceContour&gt; contours) {

<span class="pc bpc" id="L547" title="1 of 4 branches missed.">        if ((contours == null) || contours.isEmpty()) {</span>
<span class="fc" id="L548">            return;</span>
        }

        // roughly, look for features with peaks &gt; 0.9 and &lt; 0.1.
        // TODO: what shape would produce the widest possible contour in
        // this space?
<span class="fc" id="L554">        List&lt;Integer&gt; rightBorderPeakIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L555">        List&lt;Integer&gt; leftBorderPeakIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L557" title="All 2 branches covered.">        for (int i = 0; i &lt; contours.size(); i++) {</span>

<span class="fc" id="L559">            CurvatureScaleSpaceContour contour = contours.get(i);</span>

<span class="fc bfc" id="L561" title="All 2 branches covered.">            if (contour.getPeakScaleFreeLength() &gt; 0.9) {</span>
<span class="fc" id="L562">                rightBorderPeakIndexes.add(Integer.valueOf(i));</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            } else if (contour.getPeakScaleFreeLength() &lt; 0.1) {</span>
<span class="fc" id="L564">                leftBorderPeakIndexes.add(Integer.valueOf(i));</span>
            }
        }

<span class="fc" id="L568">        int maxIter = rightBorderPeakIndexes.size();</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        if (leftBorderPeakIndexes.size() &gt; maxIter) {</span>
<span class="fc" id="L570">            maxIter = leftBorderPeakIndexes.size();</span>
        }
<span class="fc" id="L572">        int nIter = 0;</span>
<span class="fc" id="L573">        int i = 0;</span>
<span class="fc" id="L574">        boolean resort = false;</span>

<span class="fc bfc" id="L576" title="All 4 branches covered.">        while ((nIter &lt; maxIter) &amp;&amp; !rightBorderPeakIndexes.isEmpty()</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            &amp;&amp; !leftBorderPeakIndexes.isEmpty()) {</span>

            // indexes are ordered by descending sigma
            // for now, make an unsafe assumption that there aren't any other
            // full contours within the 0.1 border regions in between the sigma
            // of contours that wrap around
            //if ((leftBorderPeakIndexes.size() == 1)
            //    &amp;&amp; (rightBorderPeakIndexes.size() == 1)) {
<span class="fc" id="L585">            int idxLeft = leftBorderPeakIndexes.get(i);</span>
<span class="fc" id="L586">            int idxRight = rightBorderPeakIndexes.get(i);</span>

<span class="fc" id="L588">            CurvatureScaleSpaceContour left = contours.get(idxLeft);</span>
<span class="fc" id="L589">            CurvatureScaleSpaceContour right = contours.get(idxRight);</span>

<span class="fc" id="L591">            boolean leftIsTaller = (left.getPeakSigma()</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">                &gt; right.getPeakSigma());</span>

<span class="fc" id="L594">            boolean rightIsTaller = (right.getPeakSigma()</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                &gt; left.getPeakSigma());</span>

<span class="fc bfc" id="L597" title="All 4 branches covered.">            if (leftIsTaller &amp;&amp; (left.getPeakDetails().length == 2)) {</span>

<span class="fc" id="L599">                contours.remove(right);</span>
<span class="fc" id="L600">                resort = true;</span>
<span class="pc bpc" id="L601" title="1 of 4 branches missed.">            } else if (rightIsTaller &amp;&amp; (right.getPeakDetails().length == 2)) {</span>

<span class="fc" id="L603">                contours.remove(left);</span>
<span class="fc" id="L604">                resort = true;</span>
            } else {

<span class="pc bpc" id="L607" title="2 of 4 branches missed.">                if (leftIsTaller &amp;&amp; (right.getPeakDetails().length == 2)) {</span>
                    // left has 1 peak
<span class="fc" id="L609">                    contours.remove(right);</span>
<span class="fc" id="L610">                    resort = true;</span>
<span class="nc bnc" id="L611" title="All 4 branches missed.">                } else if (rightIsTaller &amp;&amp; (left.getPeakDetails().length == 2)) {</span>
                    // right has 1 peak
<span class="nc" id="L613">                    contours.remove(left);</span>
<span class="nc" id="L614">                    resort = true;</span>
<span class="nc bnc" id="L615" title="All 4 branches missed.">                } else if (!rightIsTaller &amp;&amp; !leftIsTaller</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                    &amp;&amp; (right.getPeakDetails().length == 2)</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    &amp;&amp; (left.getPeakDetails().length == 2)) {</span>
                    // do nothing, both should remain
                } else {
                    // both have a single peak, so avg in sigma and t
<span class="nc" id="L621">                    float sigma = (left.getPeakSigma()</span>
<span class="nc" id="L622">                        + right.getPeakSigma()) / 2.f;</span>
<span class="nc" id="L623">                    float scaleFreeLength = (left.getPeakScaleFreeLength()</span>
<span class="nc" id="L624">                        + right.getPeakScaleFreeLength()) / 2.f;</span>

<span class="nc" id="L626">                    CurvatureScaleSpaceContour contour</span>
                        = new CurvatureScaleSpaceContour(sigma, scaleFreeLength);

<span class="nc" id="L629">                    contour.setEdgeNumber(left.getEdgeNumber());</span>

<span class="nc" id="L631">                    CurvatureScaleSpaceImagePoint[] peakPoints</span>
                        = new CurvatureScaleSpaceImagePoint[]{
<span class="nc" id="L633">                            left.getPeakDetails()[0],</span>
<span class="nc" id="L634">                            right.getPeakDetails()[0]};</span>

<span class="nc" id="L636">                    contour.setPeakDetails(peakPoints);</span>

<span class="nc" id="L638">                    contours.set(idxLeft, contour);</span>

<span class="nc" id="L640">                    contours.remove(left);</span>

<span class="nc" id="L642">                    contours.remove(right);</span>

<span class="nc" id="L644">                    resort = true;</span>
                }
            }
            //}

<span class="fc" id="L649">            leftBorderPeakIndexes.clear();</span>
<span class="fc" id="L650">            rightBorderPeakIndexes.clear();</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">            for (int ii = 0; ii &lt; contours.size(); ii++) {</span>

<span class="fc" id="L653">                CurvatureScaleSpaceContour contour = contours.get(ii);</span>

<span class="fc bfc" id="L655" title="All 2 branches covered.">                if (contour.getPeakScaleFreeLength() &gt; 0.9) {</span>
<span class="fc" id="L656">                    rightBorderPeakIndexes.add(Integer.valueOf(ii));</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                } else if (contour.getPeakScaleFreeLength() &lt; 0.1) {</span>
<span class="fc" id="L658">                    leftBorderPeakIndexes.add(Integer.valueOf(ii));</span>
                }
            }

<span class="fc" id="L662">            nIter++;</span>
<span class="fc" id="L663">        }</span>

<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (resort) {</span>
<span class="fc" id="L666">            Collections.sort(contours, new DescendingSigmaComparator());</span>
        }
<span class="fc" id="L668">    }</span>

    public boolean reverseIfClockwise(List&lt;CurvatureScaleSpaceContour&gt; result) {

<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (result.isEmpty()) {</span>
<span class="nc" id="L673">            return false;</span>
        }

<span class="nc" id="L676">        boolean didReverse = false;</span>

<span class="nc" id="L678">        PairIntArray testContour = new PairIntArray();</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        for (int j = 0; j &lt; result.size(); j++) {</span>
<span class="nc" id="L680">            CurvatureScaleSpaceContour c = result.get(j);</span>
<span class="nc" id="L681">            CurvatureScaleSpaceImagePoint[] points = c.getPeakDetails();</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            for (int jj = 0; jj &lt; points.length; jj++) {</span>
<span class="nc" id="L683">                testContour.add(points[jj].getXCoord(), points[jj].getYCoord());</span>
            }
        }

<span class="nc" id="L687">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="nc" id="L689">        boolean isCW = curveHelper.curveIsOrderedClockwise(testContour);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (isCW) {</span>
<span class="nc" id="L691">            didReverse = true;</span>
<span class="nc" id="L692">            reversePointOrder(result);</span>
        }

<span class="nc" id="L695">        return didReverse;</span>
    }

    public boolean reverseIfClockwise(List&lt;CurvatureScaleSpaceContour&gt; result,
        PairIntArray edge) {

<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (result.isEmpty()) {</span>
<span class="nc" id="L702">            return false;</span>
        }

<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (edge == null) {</span>
<span class="nc" id="L706">            return false;</span>
        }

<span class="fc" id="L709">        boolean didReverse = false;</span>

        /*
         using the inflection points and then points half way between them.
         */
<span class="fc" id="L714">        List&lt;Integer&gt; indexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">        for (int j = 0; j &lt; result.size(); j++) {</span>
<span class="fc" id="L716">            CurvatureScaleSpaceContour c = result.get(j);</span>
<span class="fc" id="L717">            CurvatureScaleSpaceImagePoint[] points = c.getPeakDetails();</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            for (int jj = 0; jj &lt; points.length; jj++) {</span>
<span class="fc" id="L719">                indexes.add(Integer.valueOf(points[jj].getCoordIdx()));</span>
            }
        }
<span class="fc" id="L722">        Collections.sort(indexes);</span>

<span class="fc" id="L724">        List&lt;Integer&gt; betweenInflectionIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L726" title="All 2 branches covered.">        for (int i = 1; i &lt; indexes.size(); ++i) {</span>
<span class="fc" id="L727">            int i0 = indexes.get(i - 1);</span>
<span class="fc" id="L728">            int i1 = indexes.get(i);</span>
<span class="fc" id="L729">            int iMid = (i1 + i0) / 2;</span>
<span class="fc" id="L730">            betweenInflectionIndexes.add(Integer.valueOf(iMid));</span>
        }
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">        boolean isClosedCurved = (edge instanceof PairIntArrayWithColor)</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">            &amp;&amp; (((PairIntArrayWithColor) edge).getColor() == 1);</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        if (isClosedCurved) {</span>
<span class="fc" id="L735">            int n = indexes.size();</span>
<span class="fc" id="L736">            int i0 = indexes.get(n - 1);</span>
<span class="fc" id="L737">            int i1 = indexes.get(0);</span>
<span class="fc" id="L738">            int len = (indexes.size() - i0 + i1);</span>
<span class="fc" id="L739">            int iMid = i0 + (len / 2);</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">            if (iMid &gt; (n - 1)) {</span>
<span class="fc" id="L741">                iMid = iMid - n;</span>
            }
<span class="fc" id="L743">            betweenInflectionIndexes.add(Integer.valueOf(iMid));</span>
        }
<span class="fc" id="L745">        indexes.addAll(betweenInflectionIndexes);</span>
<span class="fc" id="L746">        Collections.sort(indexes);</span>

<span class="fc" id="L748">        Set&lt;Integer&gt; added = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L749">        PairIntArray dirTst = new PairIntArray(indexes.size());</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        for (Integer index : indexes) {</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (added.contains(index)) {</span>
<span class="fc" id="L752">                continue;</span>
            }
<span class="fc" id="L754">            int idx = index.intValue();</span>
<span class="fc" id="L755">            int x = edge.getX(idx);</span>
<span class="fc" id="L756">            int y = edge.getY(idx);</span>
<span class="fc" id="L757">            dirTst.add(x, y);</span>
<span class="fc" id="L758">            added.add(index);</span>
<span class="fc" id="L759">        }</span>

<span class="fc" id="L761">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>

<span class="fc" id="L763">        boolean isCW = curveHelper.curveIsOrderedClockwise(dirTst);</span>
        /*
         try {
         ScatterPointPlotterPNG plotter = new ScatterPointPlotterPNG();
         float[] x = new float[dirTst.getN()];
         float[] y = new float[x.length];
         float xmn = Float.MAX_VALUE;
         float xmx = Float.MIN_VALUE;
         float ymn = Float.MAX_VALUE;
         float ymx = Float.MIN_VALUE;
         for (int i = 0; i &lt; dirTst.getN(); ++i) {
         x[i] = dirTst.getX(i);
         y[i] = dirTst.getY(i);
         if (x[i] &lt; xmn) {
         xmn = x[i];
         }
         if (x[i] &gt; xmx) {
         xmx = x[i];
         }
         if (y[i] &lt; ymn) {
         ymn = y[i];
         }
         if (y[i] &gt; ymx) {
         ymx = y[i];
         }
         }
         plotter.plotLabeledPoints(0.9f*xmn, 1.1f*xmx, 0.9f*ymn, 1.1f*ymx, x, y, &quot;isCW=&quot;+Boolean.toString(isCW), &quot;X&quot;, &quot;Y&quot;);
         plotter.writeFile(MiscDebug.getCurrentTimeFormatted());
         } catch (IOException e){}
         */

<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (isCW) {</span>
<span class="fc" id="L795">            didReverse = true;</span>
<span class="fc" id="L796">            reversePointOrder(result);</span>
        }

<span class="fc" id="L799">        return didReverse;</span>
    }

    static void reversePointOrder(List&lt;CurvatureScaleSpaceContour&gt; result) {

<span class="fc bfc" id="L804" title="All 2 branches covered.">        for (int j = 0; j &lt; result.size(); j++) {</span>
<span class="fc" id="L805">            CurvatureScaleSpaceContour contour = result.get(j);</span>
<span class="fc" id="L806">            CurvatureScaleSpaceContour reversed</span>
<span class="fc" id="L807">                = new CurvatureScaleSpaceContour(contour.getPeakSigma(),</span>
<span class="fc" id="L808">                    1.0f - contour.getPeakScaleFreeLength());</span>
<span class="fc" id="L809">            CurvatureScaleSpaceImagePoint[] points = contour.getPeakDetails();</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">            if (points.length &gt; 1) {</span>
<span class="nc" id="L811">                CurvatureScaleSpaceImagePoint tmp = points[0];</span>
<span class="nc" id="L812">                points[0] = points[1];</span>
<span class="nc" id="L813">                points[1] = tmp;</span>
            }
<span class="fc bfc" id="L815" title="All 2 branches covered.">            for (CurvatureScaleSpaceImagePoint point : points) {</span>
<span class="fc" id="L816">                point.setScaleFreeLength(1.0f - point.getScaleFreeLength());</span>
            }
<span class="fc" id="L818">            reversed.setPeakDetails(points);</span>
<span class="fc" id="L819">            reversed.setEdgeNumber(contour.getEdgeNumber());</span>
<span class="fc" id="L820">            result.set(j, reversed);</span>
        }

<span class="fc" id="L823">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
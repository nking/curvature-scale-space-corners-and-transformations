<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeatureMatcherWrapper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">FeatureMatcherWrapper.java</span></div><h1>FeatureMatcherWrapper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.RotatedOffsets;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

/**
 * class encapsulating the steps from scale calculation to matching corners
 * to make correspondence lists.
 * 
 * @author nichole
 */
public class FeatureMatcherWrapper {
    
    private final FeatureMatcherSettings settings;
    
    private final ImageExt img1;
    private final ImageExt img2;
    
<span class="pc" id="L31">    private GreyscaleImage gsImg1 = null;</span>
<span class="pc" id="L32">    private GreyscaleImage gsImg2 = null;</span>
        
<span class="pc" id="L34">    private Set&lt;CornerRegion&gt; cornerRegions1 = null;</span>
<span class="pc" id="L35">    private Set&lt;CornerRegion&gt; cornerRegions2 = null;</span>
    
    private enum State {
        DID_APPLY_HIST_EQ, COULD_NOT_DETERMINE_SCALE
    }
<span class="pc" id="L40">    private Set&lt;State&gt; stateSet = new HashSet&lt;State&gt;();</span>
    
    private final boolean doDetermineScale;
    
<span class="pc" id="L44">    private TransformationParameters params = null;</span>
            
<span class="pc" id="L46">    private float scaleTol = 0.2f;</span>
    
<span class="pc" id="L48">    private float rotationInRadiansTol = (float)(20. * Math.PI/180.);</span>
    
<span class="pc" id="L50">    private double ssdLimit = 1500;</span>
    
    //TODO: revise this...
<span class="pc" id="L53">    private int transXYTol = 20;</span>
    
<span class="pc" id="L55">    private RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
    
<span class="pc" id="L57">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    public FeatureMatcherWrapper(ImageExt image1, ImageExt image2,
<span class="fc" id="L60">        FeatureMatcherSettings settings) {</span>
                
<span class="fc" id="L62">        img1 = image1;</span>
<span class="fc" id="L63">        img2 = image2;</span>
        
<span class="fc" id="L65">        doDetermineScale = true;</span>
        
<span class="fc" id="L67">        this.settings = settings.copy();</span>
<span class="fc" id="L68">    }</span>
    
    /**
     * constructor accepting transformation parameters.  Note, for best results,
     * the standard deviations within parameters should be populated because they
     * are used as tolerances in matching.
     * @param image1
     * @param image2
     * @param parameters 
     * @param settings 
     */
    public FeatureMatcherWrapper(ImageExt image1, ImageExt image2, 
<span class="nc" id="L80">        TransformationParameters parameters, FeatureMatcherSettings settings) {</span>
        
<span class="nc" id="L82">        img1 = image1;</span>
<span class="nc" id="L83">        img2 = image2;</span>
<span class="nc" id="L84">        doDetermineScale = false;</span>
        
<span class="nc" id="L86">        this.settings = settings.copy();</span>
<span class="nc" id="L87">    }</span>
    
    public CorrespondenceList matchFeatures() throws IOException, 
        NoSuchAlgorithmException {
        
        /*
        options:
            (1) determine scale 
                (a) match remaining points derived in scale calc.
                    if resulting set spans the intersection,
                    make and return the correspondence list
                    else, follow (2)
            (2) given scale
                (b) extract corner regions from greyscale image
                (3) use feature matcher w/ scale to make the correspondence list
        */
        
<span class="fc" id="L104">        CorrespondenceList cl = null;</span>
        
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (doDetermineScale) {</span>
<span class="fc" id="L107">            return solveForScale();</span>
        }
               
<span class="nc" id="L110">        applyHistEqIfNeeded();</span>
                        
<span class="nc" id="L112">        cl = extractAndMatch(params);</span>
        
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (settings.debug()) {</span>
<span class="nc" id="L115">            printMatches(cl);</span>
        }
        
<span class="nc" id="L118">        return cl;</span>
    }
    
    private CorrespondenceList solveForScale() throws IOException, 
        NoSuchAlgorithmException {
                        
<span class="fc" id="L124">        BlobScaleFinderWrapper scaleFinder = new BlobScaleFinderWrapper(img1, </span>
            img2, settings, rotatedOffsets);
        
<span class="fc" id="L127">        params = scaleFinder.calculateScale();</span>
        
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L130">            stateSet.add(State.COULD_NOT_DETERMINE_SCALE);</span>
<span class="nc" id="L131">            return null;</span>
        }
        
<span class="fc" id="L134">        boolean didApplyHist = scaleFinder.img1Helper.didApplyHistEq();</span>
<span class="fc" id="L135">        this.gsImg1 = scaleFinder.img1Helper.getGreyscaleImage().copyImage();</span>
<span class="fc" id="L136">        this.gsImg2 = scaleFinder.img2Helper.getGreyscaleImage().copyImage();</span>
        
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (didApplyHist) {</span>
<span class="nc" id="L139">            stateSet.add(State.DID_APPLY_HIST_EQ);</span>
        }
        
<span class="fc" id="L142">        List&lt;FeatureComparisonStat&gt; stats = </span>
<span class="fc" id="L143">            scaleFinder.getSolution().getComparisonStats();</span>
        
<span class="fc" id="L145">        CorrespondenceList cl = null;</span>
        
        int tolXY;
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (params.getStandardDeviations() != null) {</span>
<span class="fc" id="L149">            tolXY = Math.round(Math.max(params.getStandardDeviations()[2], </span>
<span class="fc" id="L150">                params.getStandardDeviations()[3]));</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (tolXY &lt; 3) {</span>
<span class="nc" id="L152">                tolXY = 3;</span>
            }
        } else {
<span class="nc" id="L155">            tolXY = 10;</span>
        }
        
<span class="fc" id="L158">        int binFactor1 = scaleFinder.getBinFactor1();</span>
<span class="fc" id="L159">        int binFactor2 = scaleFinder.getBinFactor2();</span>
        
<span class="fc" id="L161">        int nLimit = 16;</span>
                
<span class="pc bpc" id="L163" title="3 of 4 branches missed.">        if (binFactor1 != 1 || binFactor2 != 1) {</span>

            //stats need to be revised for the location in the full size
            //image in order to be usable for correspondence
<span class="fc" id="L167">            List&lt;FeatureComparisonStat&gt; revisedStats = reviseStatsForFullImages(stats);</span>

<span class="fc" id="L169">            stats = revisedStats;</span>

<span class="fc" id="L171">            TransformationParameters revisedParams</span>
<span class="fc" id="L172">                = MiscStats.calculateTransformation(1, 1, stats, new float[4]);</span>

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (revisedParams != null) {</span>
<span class="fc" id="L175">                params = revisedParams;</span>
            } else {
<span class="nc" id="L177">                log.warning(&quot;possible ERROR in revision of stats&quot;);</span>
            }
        }
                
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="fc" id="L182">            printMatches(stats);</span>
        }
        
<span class="fc" id="L185">        boolean covers = ImageStatisticsHelper.statsCoverIntersection(params, stats, </span>
<span class="fc" id="L186">            img1.getWidth(), img1.getHeight(), img2.getWidth(), img2.getHeight());</span>
        
<span class="fc bfc" id="L188" title="All 4 branches covered.">        boolean extractMoreCorners = (stats.size() &lt; nLimit) || !covers;</span>
        
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (!extractMoreCorners) {</span>

<span class="fc" id="L192">            List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L193">            List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L194">            populateLists(stats, matched1, matched2);</span>

<span class="fc" id="L196">            cl = new CorrespondenceList(params.getScale(), </span>
<span class="fc" id="L197">                Math.round(params.getRotationInDegrees()), </span>
<span class="fc" id="L198">                Math.round(params.getTranslationX()),</span>
<span class="fc" id="L199">                Math.round(params.getTranslationY()), </span>
<span class="fc" id="L200">                Math.round(params.getStandardDeviations()[0]),</span>
<span class="fc" id="L201">                Math.round(params.getStandardDeviations()[2]),</span>
<span class="fc" id="L202">                Math.round(params.getStandardDeviations()[3]),</span>
                matched1, matched2);

<span class="fc" id="L205">            return cl;</span>
        }
            
<span class="fc" id="L208">        cl = extractAndMatch(params);</span>
            
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (cl != null) {</span>
            
<span class="fc" id="L212">            addStatsToSolution(cl, stats);</span>
            
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">            if (settings.debug()) {</span>
<span class="fc" id="L215">                printMatches(cl.getPoints1(), cl.getPoints2());</span>
                //MiscDebug.print(cl);
            }
        }
          
<span class="fc" id="L220">        return cl;</span>
    }
    
    private void applyHistEqIfNeeded() {
        
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (stateSet.contains(State.DID_APPLY_HIST_EQ)) {</span>
<span class="nc" id="L226">            return;</span>
        }
        
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (gsImg1 != null) {</span>
            // gs images were set during scale calculation
<span class="nc" id="L231">            return;</span>
        }
        
<span class="nc" id="L234">        this.gsImg1 = img1.copyToGreyscale();</span>
<span class="nc" id="L235">        this.gsImg2 = img2.copyToGreyscale();</span>
        
<span class="nc" id="L237">        ImageStatistics stats1 = ImageStatisticsHelper.examineImage(gsImg1, true);</span>
<span class="nc" id="L238">        ImageStatistics stats2 = ImageStatisticsHelper.examineImage(gsImg2, true);</span>
        
<span class="nc" id="L240">        boolean performHistEq = false;</span>
<span class="nc" id="L241">        double median1DivMedian2 = stats1.getMedian()/stats2.getMedian();</span>
<span class="nc" id="L242">        double meanDivMedian1 = stats1.getMean()/stats1.getMedian();</span>
<span class="nc" id="L243">        double meanDivMedian2 = stats2.getMean()/stats2.getMedian();</span>
<span class="nc bnc" id="L244" title="All 8 branches missed.">        if (</span>
            ((median1DivMedian2 &gt; 1) &amp;&amp; ((median1DivMedian2 - 1) &gt; 0.2)) ||
            ((median1DivMedian2 &lt; 1) &amp;&amp; (median1DivMedian2 &lt; 0.8))) {
<span class="nc" id="L247">            performHistEq = true;</span>
<span class="nc bnc" id="L248" title="All 8 branches missed.">        } else if (</span>
            ((meanDivMedian1 &gt; 1) &amp;&amp; ((meanDivMedian1 - 1) &gt; 0.2)) ||
            ((meanDivMedian1 &lt; 1) &amp;&amp; (meanDivMedian1 &lt; 0.8))) {
<span class="nc" id="L251">            performHistEq = true;</span>
<span class="nc bnc" id="L252" title="All 8 branches missed.">        } else if (</span>
            ((meanDivMedian2 &gt; 1) &amp;&amp; ((meanDivMedian2 - 1) &gt; 0.2)) ||
            ((meanDivMedian2 &lt; 1) &amp;&amp; (meanDivMedian2 &lt; 0.8))) {
<span class="nc" id="L255">            performHistEq = true;</span>
        }
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (performHistEq) {</span>
<span class="nc" id="L258">            log.info(&quot;use histogram equalization on the greyscale images&quot;);</span>
<span class="nc" id="L259">            HistogramEqualization hEq = new HistogramEqualization(gsImg1);</span>
<span class="nc" id="L260">            hEq.applyFilter();</span>
<span class="nc" id="L261">            hEq = new HistogramEqualization(gsImg2);</span>
<span class="nc" id="L262">            hEq.applyFilter();</span>
<span class="nc" id="L263">            stateSet.add(State.DID_APPLY_HIST_EQ);</span>
        }

<span class="nc" id="L266">    }</span>

    private void extractCornerRegions() {
        
<span class="fc" id="L270">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L271">        imageProcessor.blur(gsImg1, SIGMA.ONE);</span>
        
<span class="fc" id="L273">        CurvatureScaleSpaceCornerDetector detector = new</span>
            CurvatureScaleSpaceCornerDetector(gsImg1);
<span class="fc" id="L275">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L276">        detector.findCorners();</span>
//TODO: revisit to make sure coordinate systems are consistent:       
<span class="fc" id="L278">        cornerRegions1 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions1 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);
    
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="fc" id="L282">            List&lt;PairIntArray&gt; edges = detector.getEdgesInOriginalReferenceFrame();</span>
<span class="fc" id="L283">                Image imgCp = img1.copyImage();</span>
<span class="fc" id="L284">                ImageIOHelper.addAlternatingColorCurvesToImage(edges, imgCp, 3);</span>
<span class="fc" id="L285">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_1_edges_&quot;);</span>
<span class="fc" id="L286">                imgCp = img1.copyImage();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                for (CornerRegion cr : cornerRegions1) {</span>
<span class="fc" id="L288">                    int x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L289">                    int y = cr.getY()[cr.getKMaxIdx()];</span>
<span class="fc" id="L290">                    ImageIOHelper.addPointToImage(x, y, imgCp, 2, 255, 0, 0);</span>
<span class="fc" id="L291">                }</span>
<span class="fc" id="L292">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_1_cornerregions_&quot;);</span>
<span class="fc" id="L293">                Map&lt;Integer, Set&lt;Integer&gt;&gt; junctionMap = detector.getJunctionMap();</span>
<span class="fc" id="L294">                imgCp = img1.copyImage();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                for (Integer pixIndex : junctionMap.keySet()) {</span>
<span class="fc" id="L296">                    int x = imgCp.getCol(pixIndex.intValue());</span>
<span class="fc" id="L297">                    int y = imgCp.getRow(pixIndex.intValue());</span>
<span class="fc" id="L298">                    ImageIOHelper.addPointToImage(x, y, imgCp, 2, 255, 0, 0);</span>
<span class="fc" id="L299">                }</span>
<span class="fc" id="L300">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_1_junctions_&quot;);</span>
<span class="fc" id="L301">                imgCp = img1.copyImage();</span>
<span class="fc" id="L302">                PairIntArray corners = detector.getCornersInOriginalReferenceFrame();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                for (int ii = 0; ii &lt; corners.getN(); ++ii) {</span>
<span class="fc" id="L304">                    int x = corners.getX(ii);</span>
<span class="fc" id="L305">                    int y = corners.getY(ii);</span>
<span class="fc" id="L306">                    ImageIOHelper.addPointToImage(x, y, imgCp, 2, 255, 0, 0);</span>
                }
<span class="fc" id="L308">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_1_corners_&quot;);</span>
        }
        
        //-------
        
<span class="fc" id="L313">        imageProcessor.blur(gsImg2, SIGMA.ONE);</span>
        
<span class="fc" id="L315">        detector = new</span>
            CurvatureScaleSpaceCornerDetector(gsImg2);
<span class="fc" id="L317">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L318">        detector.findCorners();</span>
<span class="fc" id="L319">        cornerRegions2 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions2 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);
        
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="fc" id="L323">            List&lt;PairIntArray&gt; edges = detector.getEdgesInOriginalReferenceFrame();</span>
<span class="fc" id="L324">                Image imgCp = img2.copyImage();</span>
<span class="fc" id="L325">                ImageIOHelper.addAlternatingColorCurvesToImage(edges, imgCp, 3);</span>
<span class="fc" id="L326">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_2_edges_&quot;);</span>
<span class="fc" id="L327">                imgCp = img2.copyImage();</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">                for (CornerRegion cr : cornerRegions2) {</span>
<span class="fc" id="L329">                    int x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L330">                    int y = cr.getY()[cr.getKMaxIdx()];</span>
<span class="fc" id="L331">                    ImageIOHelper.addPointToImage(x, y, imgCp, 2, 255, 0, 0);</span>
<span class="fc" id="L332">                }</span>
<span class="fc" id="L333">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_2_corneregions_&quot;);</span>
<span class="fc" id="L334">                Map&lt;Integer, Set&lt;Integer&gt;&gt; junctionMap = detector.getJunctionMap();</span>
<span class="fc" id="L335">                imgCp = img2.copyImage();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                for (Integer pixIndex : junctionMap.keySet()) {</span>
<span class="fc" id="L337">                    int x = imgCp.getCol(pixIndex.intValue());</span>
<span class="fc" id="L338">                    int y = imgCp.getRow(pixIndex.intValue());</span>
<span class="fc" id="L339">                    ImageIOHelper.addPointToImage(x, y, imgCp, 2, 255, 0, 0);</span>
<span class="fc" id="L340">                }</span>
<span class="fc" id="L341">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_2_junctions_&quot;);</span>
<span class="fc" id="L342">                imgCp = img2.copyImage();</span>
<span class="fc" id="L343">                PairIntArray corners = detector.getCornersInOriginalReferenceFrame();</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                for (int ii = 0; ii &lt; corners.getN(); ++ii) {</span>
<span class="fc" id="L345">                    int x = corners.getX(ii);</span>
<span class="fc" id="L346">                    int y = corners.getY(ii);</span>
<span class="fc" id="L347">                    ImageIOHelper.addPointToImage(x, y, imgCp, 2, 255, 0, 0);</span>
                }
<span class="fc" id="L349">                MiscDebug.writeImage(imgCp, settings.getDebugTag() + &quot;_2_corners_&quot;);</span>
        }
<span class="fc" id="L351">    }</span>

    private CorrespondenceList findCorrespondence(TransformationParameters 
        parameters) {
        
<span class="fc" id="L356">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
        
        int tolXY;
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (params.getStandardDeviations() != null) {</span>
<span class="fc" id="L360">            tolXY = Math.round(Math.max(params.getStandardDeviations()[2], </span>
<span class="fc" id="L361">                params.getStandardDeviations()[3]));</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if (tolXY &lt; 3) {</span>
<span class="nc" id="L363">                tolXY = 3;</span>
            }
        } else {
<span class="nc" id="L366">            tolXY = transXYTol;</span>
        }
        
<span class="fc" id="L369">        int dither = 1;</span>
        
        //TODO: revise this
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if (tolXY &gt; 3) {</span>
<span class="fc" id="L373">            dither = 4;</span>
        }
        
<span class="fc" id="L376">        CorrespondenceList cl = featureMatcher.findSimilarFeatures(gsImg1,</span>
<span class="fc" id="L377">            cornerRegions1.toArray(new CornerRegion[cornerRegions1.size()]),</span>
            gsImg2,
<span class="fc" id="L379">            cornerRegions2.toArray(new CornerRegion[cornerRegions2.size()]), </span>
            parameters, scaleTol, rotationInRadiansTol, tolXY,
            dither, rotatedOffsets);

<span class="fc" id="L383">        return cl;</span>
    }
    
    private void populateLists(List&lt;FeatureComparisonStat&gt; stats, 
        List&lt;PairInt&gt; matched1, List&lt;PairInt&gt; matched2) {
        
<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
            
<span class="fc" id="L391">            int x1 = stat.getImg1Point().getX();</span>
<span class="fc" id="L392">            int y1 = stat.getImg1Point().getY();</span>
<span class="fc" id="L393">            int x2 = stat.getImg2Point().getX();</span>
<span class="fc" id="L394">            int y2 = stat.getImg2Point().getY();</span>
            
<span class="fc" id="L396">            matched1.add(new PairInt(x1, y1));</span>
            
<span class="fc" id="L398">            matched2.add(new PairInt(x2, y2));</span>
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">    }</span>
    
    private CorrespondenceList extractAndMatch(
        TransformationParameters parameters) {
        
<span class="fc" id="L405">        extractCornerRegions();</span>

<span class="fc" id="L407">        CorrespondenceList cl = findCorrespondence(parameters);</span>
        
<span class="fc" id="L409">        return cl;</span>
    }
    
    private List&lt;FeatureComparisonStat&gt; reviseStatsForFullImages(
        List&lt;FeatureComparisonStat&gt; stats) {
        
<span class="fc" id="L415">        List&lt;FeatureComparisonStat&gt; revised = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="fc" id="L417">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
        
<span class="fc" id="L419">        IntensityFeatures features1 = new IntensityFeatures(5, </span>
<span class="fc" id="L420">            settings.useNormalizedFeatures(), rotatedOffsets);</span>

<span class="fc" id="L422">        IntensityFeatures features2 = new IntensityFeatures(5, </span>
<span class="fc" id="L423">            settings.useNormalizedFeatures(), rotatedOffsets);</span>
        
<span class="fc" id="L425">        int rotD = Math.round(params.getRotationInDegrees());</span>
        
<span class="fc" id="L427">        final int rotationTolerance = 20;</span>
        
<span class="fc" id="L429">        final int dither = 4;</span>
        
<span class="fc bfc" id="L431" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
            
<span class="fc" id="L433">            FeatureComparisonStat stat = stats.get(i);</span>
            
<span class="fc" id="L435">            int x1 = stat.getImg1Point().getX() * stat.getBinFactor1();</span>
<span class="fc" id="L436">            int y1 = stat.getImg1Point().getY() * stat.getBinFactor1();</span>
<span class="fc" id="L437">            int x2 = stat.getImg2Point().getX() * stat.getBinFactor2();</span>
<span class="fc" id="L438">            int y2 = stat.getImg2Point().getY() * stat.getBinFactor2();</span>

            // have to discard the best angles found in stat and derive new
            // for these higher resolution images
<span class="fc" id="L442">            FeatureComparisonStat compStat = </span>
<span class="fc" id="L443">                featureMatcher.ditherAndRotateForBestLocation2(</span>
                    features1, features2, 
                    x1, y1, x2, y2,
                    dither, rotD, rotationTolerance, gsImg1, gsImg2);
           
<span class="fc bfc" id="L448" title="All 4 branches covered.">            if (compStat == null || (compStat.getSumIntensitySqDiff() &gt;= ssdLimit)) {</span>
<span class="fc" id="L449">                continue;</span>
            }

<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (compStat.getSumIntensitySqDiff() &lt; compStat.getImg2PointIntensityErr()) {</span>
<span class="fc" id="L453">                revised.add(compStat);</span>
            }
        }
        
<span class="fc" id="L457">        return revised;</span>
    }
    
    private void addStatsToSolution(CorrespondenceList cl, 
        List&lt;FeatureComparisonStat&gt; stats) {
        
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (cl == null) {</span>
<span class="nc" id="L464">            return;</span>
        }
        
<span class="fc" id="L467">        List&lt;PairInt&gt; matched01 = cl.getPoints1();</span>
<span class="fc" id="L468">        List&lt;PairInt&gt; matched02 = cl.getPoints2();</span>
        
<span class="fc" id="L470">        Set&lt;PairInt&gt; added1 = new HashSet&lt;PairInt&gt;(matched01);</span>
<span class="fc" id="L471">        Set&lt;PairInt&gt; added2 = new HashSet&lt;PairInt&gt;(matched02);</span>
        
<span class="fc" id="L473">        boolean didAdd = false;</span>
        
<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="fc" id="L476">            PairInt imPt1 = stat.getImg1Point();</span>
<span class="fc" id="L477">            PairInt imPt2 = stat.getImg2Point();</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">            if (added1.contains(imPt1) || added2.contains(imPt2)) {</span>
                //TODO: consider replacing the match with imPt1, imPt2 which is
                // usually better from the small first solution.
                // in that case, need to remove the added.adds below
<span class="fc" id="L482">                continue;</span>
            }
<span class="fc" id="L484">            matched01.add(imPt1);</span>
<span class="fc" id="L485">            matched02.add(imPt2);</span>
<span class="fc" id="L486">            added1.add(imPt1);</span>
<span class="fc" id="L487">            added2.add(imPt2);</span>
            
<span class="fc" id="L489">            didAdd = true;</span>
<span class="fc" id="L490">        }</span>
        
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if (didAdd) {</span>
            // TODO: redo ranges
        }
<span class="fc" id="L495">    }</span>

    private void printMatches(List&lt;FeatureComparisonStat&gt; stats) {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (stats == null) {</span>
<span class="nc" id="L499">            return;</span>
        }
<span class="fc" id="L501">        List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L502">        List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L503">        populateLists(stats, matched1, matched2);</span>
        
<span class="fc" id="L505">        printMatches(matched1, matched2);</span>
<span class="fc" id="L506">    }</span>
    
    private void printMatches(CorrespondenceList cl) {
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (cl == null) {</span>
<span class="nc" id="L510">            return;</span>
        }
<span class="nc" id="L512">        printMatches(cl.getPoints1(), cl.getPoints2());</span>
<span class="nc" id="L513">    }</span>
    
    private void printMatches(Collection&lt;PairInt&gt; m1, Collection&lt;PairInt&gt; m2) {
        
<span class="fc" id="L517">        int ts = MiscDebug.getCurrentTimeFormatted();</span>
<span class="fc" id="L518">        GreyscaleImage gsImg1 = img1.copyToGreyscale();</span>
<span class="fc" id="L519">        GreyscaleImage gsImg2 = img2.copyToGreyscale();</span>
<span class="fc" id="L520">        String name1 = &quot;1_&quot; + settings.getDebugTag() + &quot;_&quot; + ts;</span>
<span class="fc" id="L521">        String name2 = &quot;2_&quot; + settings.getDebugTag() + &quot;_&quot; + ts;</span>
<span class="fc" id="L522">        name1 = name1 + &quot;_matched&quot;;</span>
<span class="fc" id="L523">        name2 = name2 + &quot;_matched&quot;;</span>
<span class="fc" id="L524">        MiscDebug.plotCorners(gsImg1, m1, name1, 2);</span>
<span class="fc" id="L525">        MiscDebug.plotCorners(gsImg2, m2, name2, 2);</span>
<span class="fc" id="L526">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
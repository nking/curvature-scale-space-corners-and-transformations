<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeatureMatcherWrapper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">FeatureMatcherWrapper.java</span></div><h1>FeatureMatcherWrapper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.QuickSort;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * class encapsulating the steps from scale calculation to matching corners
 * to make correspondence lists.
 * 
 * @author nichole
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public class FeatureMatcherWrapper {</span>
    
    private final ImageExt img1;
    private final ImageExt img2;
    
<span class="pc" id="L31">    private GreyscaleImage gsImg1 = null;</span>
<span class="pc" id="L32">    private GreyscaleImage gsImg2 = null;</span>
        
<span class="pc" id="L34">    private Set&lt;CornerRegion&gt; cornerRegions1 = null;</span>
<span class="pc" id="L35">    private Set&lt;CornerRegion&gt; cornerRegions2 = null;</span>
    
    private enum State {
        DID_APPLY_HIST_EQ, COULD_NOT_DETERMINE_SCALE
    }
<span class="pc" id="L40">    private Set&lt;State&gt; stateSet = new HashSet&lt;State&gt;();</span>
    
    private final boolean doDetermineScale;
    
    private final boolean debug;
    
    private final String debugTagPrefix;
    
<span class="pc" id="L48">    private TransformationParameters params = null;</span>
            
<span class="pc" id="L50">    private float scaleTol = 0.2f;</span>
    
<span class="pc" id="L52">    private float rotationInRadiansTol = (float)(20. * Math.PI/180.);</span>
    
    //TODO: revise this...
<span class="pc" id="L55">    private int transXYTol = 20;</span>
    
<span class="pc" id="L57">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="nc" id="L59">    public FeatureMatcherWrapper(ImageExt image1, ImageExt image2) {</span>
<span class="nc" id="L60">        img1 = image1;</span>
<span class="nc" id="L61">        img2 = image2;</span>
<span class="nc" id="L62">        doDetermineScale = true;</span>
<span class="nc" id="L63">        debug = false;</span>
<span class="nc" id="L64">        debugTagPrefix = &quot;&quot;;</span>
<span class="nc" id="L65">    }</span>
    
    public FeatureMatcherWrapper(ImageExt image1, ImageExt image2, 
<span class="fc" id="L68">        String debugTagPrefix) {</span>
<span class="fc" id="L69">        img1 = image1;</span>
<span class="fc" id="L70">        img2 = image2;</span>
<span class="fc" id="L71">        doDetermineScale = true;</span>
<span class="fc" id="L72">        debug = true;</span>
<span class="fc" id="L73">        this.debugTagPrefix = debugTagPrefix;</span>
<span class="fc" id="L74">    }</span>
    
    /**
     * constructor accepting transformation parameters.  Note, for best results,
     * the standard deviations within parameters should be populated because they
     * are used as tolerances in matching.
     * @param image1
     * @param image2
     * @param parameters 
     */
    public FeatureMatcherWrapper(ImageExt image1, ImageExt image2, 
<span class="nc" id="L85">        TransformationParameters parameters) {</span>
<span class="nc" id="L86">        img1 = image1;</span>
<span class="nc" id="L87">        img2 = image2;</span>
<span class="nc" id="L88">        doDetermineScale = false;</span>
<span class="nc" id="L89">        params = parameters;</span>
<span class="nc" id="L90">        debug = false;</span>
<span class="nc" id="L91">        debugTagPrefix = &quot;&quot;;</span>
<span class="nc" id="L92">    }</span>
    
    /**
     * constructor accepting transformation parameters and a debugging tag for
     * image names.  Note, for best results, the standard deviations within 
     * parameters should be populated because they are used as tolerances in 
     * matching.
     * @param image1
     * @param image2
     * @param parameters
     * @param debugTagPrefix 
     */
    public FeatureMatcherWrapper(ImageExt image1, ImageExt image2, 
<span class="nc" id="L105">        TransformationParameters parameters, String debugTagPrefix) {</span>
<span class="nc" id="L106">        img1 = image1;</span>
<span class="nc" id="L107">        img2 = image2;</span>
<span class="nc" id="L108">        doDetermineScale = false;</span>
<span class="nc" id="L109">        params = parameters;</span>
<span class="nc" id="L110">        debug = true;</span>
<span class="nc" id="L111">        this.debugTagPrefix = debugTagPrefix;</span>
<span class="nc" id="L112">    }</span>
    
    public CorrespondenceList matchFeatures() throws IOException, 
        NoSuchAlgorithmException {
        
        /*
        options:
            (1) determine scale 
                (a) match remaining points derived in scale calc.
                    if resulting set spans the intersection,
                    make and return the correspondence list
                    else, follow (2)
            (2) given scale
                (b) extract corner regions from greyscale image
                (3) use feature matcher w/ scale to make the correspondence list
        */
        
<span class="fc" id="L129">        CorrespondenceList cl = null;</span>
        
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (doDetermineScale) {</span>
<span class="fc" id="L132">            cl = solveForScale();</span>
<span class="fc" id="L133">            return cl;</span>
        }
               
<span class="nc" id="L136">        applyHistEqIfNeeded();</span>
        
<span class="nc" id="L138">        extractCornerRegions();</span>
                
<span class="nc" id="L140">        cl = extractAndMatch(params);</span>
                
<span class="nc bnc" id="L142" title="All 4 branches missed.">        if (debug &amp;&amp; (cl != null)) {</span>
<span class="nc" id="L143">            Collection&lt;PairInt&gt; m1 = cl.getPoints1();</span>
<span class="nc" id="L144">            Collection&lt;PairInt&gt; m2 = cl.getPoints2();</span>

<span class="nc" id="L146">            MiscDebug.plotCorners(gsImg1.copyImage(), m1, debugTagPrefix + &quot;_1_matched&quot;, 2);</span>
<span class="nc" id="L147">            MiscDebug.plotCorners(gsImg2.copyImage(), m2, debugTagPrefix + &quot;_2_matched&quot;, 2);</span>
        }
        
<span class="nc" id="L150">        return cl;</span>
    }
    
    private CorrespondenceList solveForScale() throws IOException, 
        NoSuchAlgorithmException {
        
<span class="fc" id="L156">        BlobScaleFinderWrapper scaleFinder = null;</span>
            
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="fc" id="L159">            scaleFinder = new BlobScaleFinderWrapper(img1, img2, debugTagPrefix);</span>
        } else {
<span class="nc" id="L161">            scaleFinder = new BlobScaleFinderWrapper(img1, img2);</span>
        }
        
<span class="fc" id="L164">        params = scaleFinder.calculateScale();</span>
        
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L167">            stateSet.add(State.COULD_NOT_DETERMINE_SCALE);</span>
<span class="nc" id="L168">            return null;</span>
        }
        
<span class="fc" id="L171">        boolean didApplyHist = scaleFinder.img1Helper.didApplyHistEq();</span>
<span class="fc" id="L172">        this.gsImg1 = scaleFinder.img1Helper.getGreyscaleImage().copyImage();</span>
<span class="fc" id="L173">        this.gsImg2 = scaleFinder.img2Helper.getGreyscaleImage().copyImage();</span>
        
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (didApplyHist) {</span>
<span class="nc" id="L176">            stateSet.add(State.DID_APPLY_HIST_EQ);</span>
        }
        
<span class="fc" id="L179">        List&lt;FeatureComparisonStat&gt; stats = null;</span>
        
<span class="fc" id="L181">        CorrespondenceList cl = null;</span>
        
        int tolXY;
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (params.getStandardDeviations() != null) {</span>
<span class="fc" id="L185">            tolXY = Math.round(Math.max(params.getStandardDeviations()[2], </span>
<span class="fc" id="L186">                params.getStandardDeviations()[3]));</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (tolXY &lt; 3) {</span>
<span class="fc" id="L188">                tolXY = 3;</span>
            }
        } else {
<span class="nc" id="L191">            tolXY = 10;</span>
        }
           
        // try to match the remaining points created in the scale finder
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (scaleFinder.getAllCornerRegions1OfSolution() != null) {</span>
            
<span class="fc" id="L197">            List&lt;List&lt;CornerRegion&gt;&gt; transformedFilteredC1 </span>
                = new ArrayList&lt;List&lt;CornerRegion&gt;&gt;();
<span class="fc" id="L199">            List&lt;List&lt;CornerRegion&gt;&gt; filteredC1 = new ArrayList&lt;List&lt;CornerRegion&gt;&gt;();</span>
<span class="fc" id="L200">            List&lt;List&lt;CornerRegion&gt;&gt; filteredC2 = new ArrayList&lt;List&lt;CornerRegion&gt;&gt;();</span>
             
<span class="fc" id="L202">            FeatureMatcher.filterForIntersection(params, tolXY,</span>
<span class="fc" id="L203">                scaleFinder.getAllCornerRegions1OfSolution(),</span>
<span class="fc" id="L204">                scaleFinder.getAllCornerRegions2OfSolution(),</span>
                transformedFilteredC1, filteredC1, filteredC2);
            
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            if (debug) {</span>
                try {
<span class="fc" id="L209">                    Collection&lt;CornerRegion&gt; set1 = new HashSet&lt;CornerRegion&gt;();</span>
<span class="fc" id="L210">                    Collection&lt;CornerRegion&gt; set2 = new HashSet&lt;CornerRegion&gt;();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                    for (List&lt;CornerRegion&gt; list : filteredC1) {</span>
<span class="fc" id="L212">                        set1.addAll(list);</span>
<span class="fc" id="L213">                    }</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                    for (List&lt;CornerRegion&gt; list : filteredC2) {</span>
<span class="fc" id="L215">                        set2.addAll(list);</span>
<span class="fc" id="L216">                    }</span>
<span class="fc" id="L217">                    MiscDebug.writeImage(set1, gsImg1.copyToColorGreyscale(),</span>
                        debugTagPrefix + &quot;_filtered_1_corners_&quot;);
<span class="fc" id="L219">                    MiscDebug.writeImage(set2, gsImg2.copyToColorGreyscale(), </span>
                        debugTagPrefix + &quot;_filtered_2_corners_&quot;);
<span class="nc" id="L221">                } catch (IOException ex) {</span>
<span class="nc" id="L222">                    Logger.getLogger(FeatureMatcherWrapper.class.getName()).log(</span>
                        Level.SEVERE, null, ex);
<span class="fc" id="L224">                }</span>
            }
            
<span class="fc" id="L227">            stats = matchRemainingBlobCornerPoints(scaleFinder, </span>
                transformedFilteredC1, filteredC1, filteredC2);
 
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">            if ((stats.size() &gt;= 7) &amp;&amp; statsCoverIntersection(stats, filteredC2)) {</span>
                
<span class="fc" id="L232">                List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L233">                List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="fc" id="L234">                populateLists(stats, matched1, matched2);</span>
                
<span class="fc" id="L236">                cl = new CorrespondenceList(params.getScale(), </span>
<span class="fc" id="L237">                    Math.round(params.getRotationInDegrees()), </span>
<span class="fc" id="L238">                    Math.round(params.getTranslationX()),</span>
<span class="fc" id="L239">                    Math.round(params.getTranslationY()), </span>
<span class="fc" id="L240">                    Math.round(params.getStandardDeviations()[0]),</span>
<span class="fc" id="L241">                    Math.round(params.getStandardDeviations()[2]),</span>
<span class="fc" id="L242">                    Math.round(params.getStandardDeviations()[3]),</span>
                    matched1, matched2);
                
<span class="fc" id="L245">                return cl;</span>
            }
            
<span class="fc" id="L248">            cl = extractAndMatch(params);</span>
            
<span class="fc" id="L250">        } else {</span>
            
            // solve for contours, blob perimeter regions
<span class="nc" id="L253">            List&lt;List&lt;BlobPerimeterRegion&gt;&gt; transformedFilteredC1 </span>
                = new ArrayList&lt;List&lt;BlobPerimeterRegion&gt;&gt;();
<span class="nc" id="L255">            List&lt;List&lt;BlobPerimeterRegion&gt;&gt; filteredC1 = </span>
                new ArrayList&lt;List&lt;BlobPerimeterRegion&gt;&gt;();
<span class="nc" id="L257">            List&lt;List&lt;BlobPerimeterRegion&gt;&gt; filteredC2 = </span>
                new ArrayList&lt;List&lt;BlobPerimeterRegion&gt;&gt;();
                     
<span class="nc" id="L260">            FeatureMatcher.filterForIntersection(params, tolXY,</span>
<span class="nc" id="L261">                scaleFinder.getAllBlobRegions1OfSolution(),</span>
<span class="nc" id="L262">                scaleFinder.getAllBlobRegions2OfSolution(),</span>
                transformedFilteredC1, filteredC1, filteredC2);

<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L266">                List&lt;BlobPerimeterRegion&gt; set1 = new ArrayList&lt;BlobPerimeterRegion&gt;();</span>
<span class="nc" id="L267">                List&lt;BlobPerimeterRegion&gt; set2 = new ArrayList&lt;BlobPerimeterRegion&gt;();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                for (List&lt;BlobPerimeterRegion&gt; list : filteredC1) {</span>
<span class="nc" id="L269">                    set1.addAll(list);</span>
<span class="nc" id="L270">                }</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                for (List&lt;BlobPerimeterRegion&gt; list : filteredC2) {</span>
<span class="nc" id="L272">                    set2.addAll(list);</span>
<span class="nc" id="L273">                }</span>
<span class="nc" id="L274">                MiscDebug.writeImage(set1, img1.copyToImageExt(),</span>
                    debugTagPrefix + &quot;_filtered_1_contour_regions_&quot;);
<span class="nc" id="L276">                MiscDebug.writeImage(set2, img2.copyToImageExt(),</span>
                    debugTagPrefix + &quot;_filtered_2_contour_regions_&quot;);
            }
                        
<span class="nc" id="L280">            stats = matchRemainingBlobCornerPoints(scaleFinder, </span>
                transformedFilteredC1, filteredC1, filteredC2);
            
<span class="nc bnc" id="L283" title="All 4 branches missed.">            if ((stats.size() &gt;= 7) &amp;&amp; statsCoverIntersection(stats, filteredC2)) {</span>
                
<span class="nc" id="L285">                List&lt;PairInt&gt; matched1 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L286">                List&lt;PairInt&gt; matched2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L287">                populateLists(stats, matched1, matched2);</span>
                
<span class="nc" id="L289">                cl = new CorrespondenceList(params.getScale(), </span>
<span class="nc" id="L290">                    Math.round(params.getRotationInDegrees()), </span>
<span class="nc" id="L291">                    Math.round(params.getTranslationX()),</span>
<span class="nc" id="L292">                    Math.round(params.getTranslationY()), </span>
<span class="nc" id="L293">                    Math.round(params.getStandardDeviations()[0]),</span>
<span class="nc" id="L294">                    Math.round(params.getStandardDeviations()[2]),</span>
<span class="nc" id="L295">                    Math.round(params.getStandardDeviations()[3]),</span>
                    matched1, matched2);
                
<span class="nc" id="L298">                return cl;</span>
            }
            
<span class="nc" id="L301">            cl = extractAndMatch(params);</span>
        }
        
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (cl != null) {</span>
<span class="fc" id="L305">            return cl;</span>
        }
               
<span class="nc" id="L308">        return cl;</span>
    }
    
    private void applyHistEqIfNeeded() {
        
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (stateSet.contains(State.DID_APPLY_HIST_EQ)) {</span>
<span class="nc" id="L314">            return;</span>
        }
        
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (gsImg1 != null) {</span>
            // gs images were set during scale calculation
<span class="nc" id="L319">            return;</span>
        }
        
<span class="nc" id="L322">        this.gsImg1 = img1.copyToGreyscale();</span>
<span class="nc" id="L323">        this.gsImg2 = img2.copyToGreyscale();</span>
        
<span class="nc" id="L325">        ImageStatistics stats1 = ImageStatisticsHelper.examineImage(gsImg1, true);</span>
<span class="nc" id="L326">        ImageStatistics stats2 = ImageStatisticsHelper.examineImage(gsImg2, true);</span>
        
<span class="nc" id="L328">        boolean performHistEq = false;</span>
<span class="nc" id="L329">        double median1DivMedian2 = stats1.getMedian()/stats2.getMedian();</span>
<span class="nc" id="L330">        double meanDivMedian1 = stats1.getMean()/stats1.getMedian();</span>
<span class="nc" id="L331">        double meanDivMedian2 = stats2.getMean()/stats2.getMedian();</span>
<span class="nc bnc" id="L332" title="All 8 branches missed.">        if (</span>
            ((median1DivMedian2 &gt; 1) &amp;&amp; ((median1DivMedian2 - 1) &gt; 0.2)) ||
            ((median1DivMedian2 &lt; 1) &amp;&amp; (median1DivMedian2 &lt; 0.8))) {
<span class="nc" id="L335">            performHistEq = true;</span>
<span class="nc bnc" id="L336" title="All 8 branches missed.">        } else if (</span>
            ((meanDivMedian1 &gt; 1) &amp;&amp; ((meanDivMedian1 - 1) &gt; 0.2)) ||
            ((meanDivMedian1 &lt; 1) &amp;&amp; (meanDivMedian1 &lt; 0.8))) {
<span class="nc" id="L339">            performHistEq = true;</span>
<span class="nc bnc" id="L340" title="All 8 branches missed.">        } else if (</span>
            ((meanDivMedian2 &gt; 1) &amp;&amp; ((meanDivMedian2 - 1) &gt; 0.2)) ||
            ((meanDivMedian2 &lt; 1) &amp;&amp; (meanDivMedian2 &lt; 0.8))) {
<span class="nc" id="L343">            performHistEq = true;</span>
        }
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (performHistEq) {</span>
<span class="nc" id="L346">            log.info(&quot;use histogram equalization on the greyscale images&quot;);</span>
<span class="nc" id="L347">            HistogramEqualization hEq = new HistogramEqualization(gsImg1);</span>
<span class="nc" id="L348">            hEq.applyFilter();</span>
<span class="nc" id="L349">            hEq = new HistogramEqualization(gsImg2);</span>
<span class="nc" id="L350">            hEq.applyFilter();</span>
<span class="nc" id="L351">            stateSet.add(State.DID_APPLY_HIST_EQ);</span>
        }

<span class="nc" id="L354">    }</span>

    private void extractCornerRegions() {
        
<span class="fc" id="L358">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L359">        imageProcessor.blur(gsImg1, SIGMA.ONE);</span>
        
<span class="fc" id="L361">        CurvatureScaleSpaceCornerDetector detector = new</span>
            CurvatureScaleSpaceCornerDetector(gsImg1);
<span class="fc" id="L363">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L364">        detector.findCorners();</span>
//TODO: revisit to make sure coordinate systems are consistent:       
<span class="fc" id="L366">        cornerRegions1 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions1 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);
        
        //-------
        
<span class="fc" id="L371">        imageProcessor.blur(gsImg2, SIGMA.ONE);</span>
        
<span class="fc" id="L373">        detector = new</span>
            CurvatureScaleSpaceCornerDetector(gsImg2);
<span class="fc" id="L375">        detector.doNotPerformHistogramEqualization();</span>
<span class="fc" id="L376">        detector.findCorners();</span>
<span class="fc" id="L377">        cornerRegions2 = detector.getEdgeCornerRegions(true);</span>
        //cornerRegions2 = detector.getEdgeCornerRegionsInOriginalReferenceFrame(true);
        
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (debug) {</span>
            try {
<span class="fc" id="L382">                MiscDebug.writeImage(cornerRegions1, img1.copyImage(), debugTagPrefix + &quot;_1_corners_&quot;);</span>
<span class="fc" id="L383">                MiscDebug.writeImage(cornerRegions2, img2.copyImage(), debugTagPrefix + &quot;_2_corners_&quot;);</span>
<span class="nc" id="L384">            } catch (IOException ex) {</span>
<span class="nc" id="L385">                Logger.getLogger(FeatureMatcherWrapper.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L386">            }</span>
        }
<span class="fc" id="L388">    }</span>

    private CorrespondenceList findCorrespondence(TransformationParameters parameters) {
        
<span class="fc" id="L392">        FeatureMatcher matcher = new FeatureMatcher();</span>
        
        int tolXY;
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (params.getStandardDeviations() != null) {</span>
<span class="fc" id="L396">            tolXY = Math.round(Math.max(params.getStandardDeviations()[2], </span>
<span class="fc" id="L397">                params.getStandardDeviations()[3]));</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (tolXY &lt; 3) {</span>
<span class="fc" id="L399">                tolXY = 3;</span>
            }
        } else {
<span class="nc" id="L402">            tolXY = transXYTol;</span>
        }
        
<span class="fc" id="L405">        int dither = 1;</span>
        
        //TODO: revise this
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (tolXY &gt; 3) {</span>
<span class="fc" id="L409">            dither = 4;</span>
        }
        
<span class="fc" id="L412">        CorrespondenceList cl = matcher.findSimilarFeatures(gsImg1,</span>
<span class="fc" id="L413">            cornerRegions1.toArray(new CornerRegion[cornerRegions1.size()]),</span>
            gsImg2,
<span class="fc" id="L415">            cornerRegions2.toArray(new CornerRegion[cornerRegions2.size()]), </span>
            parameters, scaleTol, rotationInRadiansTol, tolXY,
            dither);

<span class="fc" id="L419">        return cl;</span>
    }
    
    private &lt;T extends CornerRegion&gt; List&lt;FeatureComparisonStat&gt; 
        matchRemainingBlobCornerPoints(BlobScaleFinderWrapper scaleFinder, 
        List&lt;List&lt;T&gt;&gt; filteredC1Transformed,
        List&lt;List&lt;T&gt;&gt; filteredC1, 
        List&lt;List&lt;T&gt;&gt; filteredC2) {
        
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (filteredC1Transformed.size() != filteredC1.size()) {</span>
<span class="nc" id="L429">            throw new IllegalArgumentException(&quot;filteredC1Transformed and &quot;</span>
            + &quot;filteredC1 are expected to be same size&quot;);
        }
        
        // use the association w/ tranformed blobs to make the matching faster

<span class="fc" id="L435">        List&lt;FeatureComparisonStat&gt; compStats = </span>
            new ArrayList&lt;FeatureComparisonStat&gt;(
<span class="fc" id="L437">                scaleFinder.getSolution().getComparisonStats());</span>
        
        /*
        choose the best for each '1' and if a high quality exists, store
        it for further quality check (theta and intensity) then add to compStats
        
        for transformedblob1
            init storage for best match to blob1
            for blob2
                if centroid within tolerance,
                    use features to match untransformed blob1 corners to blob2 corners
                    (this is the curve matcher within corner matcher for combinations?)
                    if results are high quality and better than best,
                        assign it as best
             store best in map for blob1
        remove outliers by theta and by ssd
        return combined results
        */
        
<span class="fc" id="L456">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L458">        Map&lt;Integer, IntensityFeatureComparisonStats&gt; index1Map </span>
            = new HashMap&lt;Integer, IntensityFeatureComparisonStats&gt;();
        
<span class="fc" id="L461">        Map&lt;Integer, Set&lt;Integer&gt;&gt; assignedIndex2 = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span>
        
<span class="fc" id="L463">        Set&lt;Integer&gt; redo = new HashSet&lt;Integer&gt;();</span>
        
        int tolXY;
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (params.getStandardDeviations() != null) {</span>
<span class="fc" id="L467">            tolXY = Math.round(Math.max(params.getStandardDeviations()[2], </span>
<span class="fc" id="L468">                params.getStandardDeviations()[3]));</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (tolXY &lt; 3) {</span>
<span class="fc" id="L470">                tolXY = 3;</span>
            } else {
<span class="fc" id="L472">                tolXY += 2;</span>
            }
        } else {
<span class="nc" id="L475">            tolXY = 10;</span>
        }
        
<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; filteredC1Transformed.size(); ++i1) {</span>
<span class="fc" id="L479">            List&lt;T&gt; trC1List = filteredC1Transformed.get(i1);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">            if (trC1List.isEmpty()) {</span>
<span class="fc" id="L481">                continue;</span>
            }
<span class="fc" id="L483">            List&lt;T&gt; c1List = filteredC1.get(i1);</span>
            
<span class="fc" id="L485">            double[] xyCen1 = curveHelper.&lt;T&gt;calculateXYCentroids0(trC1List);</span>
            
<span class="fc" id="L487">            IntensityFeatureComparisonStats best = null;</span>
            
<span class="fc bfc" id="L489" title="All 2 branches covered.">            for (int i2 = 0; i2 &lt; filteredC2.size(); ++i2) {</span>
<span class="fc" id="L490">                List&lt;T&gt; c2List = filteredC2.get(i2);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (c2List.isEmpty()) {</span>
<span class="fc" id="L492">                    continue;</span>
                }
<span class="fc" id="L494">                double[] xyCen2 = curveHelper.&lt;T&gt;calculateXYCentroids0(c2List);</span>
                
<span class="fc" id="L496">                double diffX = Math.abs(xyCen1[0] - xyCen2[0]);</span>
<span class="fc" id="L497">                double diffY = Math.abs(xyCen1[1] - xyCen2[1]);</span>
<span class="fc bfc" id="L498" title="All 4 branches covered.">                if ((diffX &gt; tolXY) || (diffY &gt; tolXY)) {</span>
<span class="fc" id="L499">                    continue;</span>
                }
                
<span class="fc" id="L502">                ClosedCurveCornerMatcherWrapper&lt;T&gt; mapper =</span>
                    new ClosedCurveCornerMatcherWrapper&lt;T&gt;();
                
<span class="fc" id="L505">                boolean matched = mapper.matchCorners(</span>
<span class="fc" id="L506">                    scaleFinder.getSolutionFeatures1(), </span>
<span class="fc" id="L507">                    scaleFinder.getSolutionFeatures2(),</span>
                    c1List, c2List, true, gsImg1, gsImg2);
                
<span class="fc bfc" id="L510" title="All 2 branches covered.">                if (!matched) {</span>
<span class="fc" id="L511">                    continue;</span>
                }
                
                //TODO: this should to be revised to scale w/ errors
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">                if (mapper.getSolvedCost() &gt; 800) {</span>
<span class="nc" id="L516">                    continue;</span>
                }
                
<span class="fc" id="L519">                TransformationPair2&lt;T&gt; transformationPair = mapper.getSolution();</span>
<span class="fc" id="L520">                transformationPair.setCornerListIndex1(i1);</span>
<span class="fc" id="L521">                transformationPair.setCornerListIndex2(i2);</span>
                
<span class="fc" id="L523">                TransformationParameters params2 = </span>
<span class="fc" id="L524">                    transformationPair.getTransformationParameters();</span>
                
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                if (params2 == null) {</span>
<span class="nc" id="L527">                    continue;</span>
                }
                
<span class="fc" id="L530">                List&lt;FeatureComparisonStat&gt; compStats2 = </span>
<span class="fc" id="L531">                    transformationPair.getNextCorner().getMatchedFeatureComparisonStats();</span>
               
<span class="fc" id="L533">                FeatureMatcher.removeDiscrepantThetaDiff(compStats2, </span>
<span class="fc" id="L534">                    params.getRotationInDegrees());</span>
                
<span class="fc bfc" id="L536" title="All 2 branches covered.">                if (compStats2.size() &lt; 2) {</span>
<span class="fc" id="L537">                    continue;</span>
                }
                
/*                
int nm = compStats2.size();
int x1 = compStats2.get(0).getImg1Point().getX();
int y1 = compStats2.get(0).getImg1Point().getY();
int x2 = compStats2.get(0).getImg2Point().getX();
int y2 = compStats2.get(0).getImg2Point().getY();
*/                
<span class="fc" id="L547">                IntensityFeatureComparisonStats stats2 = new </span>
                    IntensityFeatureComparisonStats(i1, i2,
<span class="fc" id="L549">                    mapper.getSolvedCost(), params.getScale());</span>
<span class="fc" id="L550">                stats2.addAll(compStats2);</span>
    
<span class="fc" id="L552">                int comp = -1;</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (best != null) {</span>
<span class="nc" id="L554">                    comp = stats2.compareTo(best);</span>
                }
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                if (comp == -1) {</span>
<span class="fc" id="L557">                    best = stats2;</span>
                }
            }
            
<span class="fc bfc" id="L561" title="All 2 branches covered.">            if (best != null) {</span>
                
<span class="fc" id="L563">                index1Map.put(Integer.valueOf(i1), best);</span>
                
<span class="fc" id="L565">                Set&lt;Integer&gt; a1 = assignedIndex2.get(Integer.valueOf(best.getIndex2()));</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                if (a1 != null) {</span>
<span class="fc" id="L567">                    redo.add(Integer.valueOf(i1));</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                    for (Integer index1 : a1) {</span>
<span class="fc" id="L569">                        redo.add(index1);</span>
<span class="fc" id="L570">                    }</span>
                } else {
<span class="fc" id="L572">                    a1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L573">                    assignedIndex2.put(Integer.valueOf(best.getIndex2()), a1);</span>
                }
<span class="fc" id="L575">                a1.add(Integer.valueOf(best.getIndex1()));</span>
            }
        }
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (!redo.isEmpty()) {</span>
            //TODO: consider using all points except conflicted indexes to
            // determine transformation params and then choose among conflict
            // those with closer match to expected transformed coordinates.
            // problem with this instead of SSD is it would perform worse for
            // projection.
             
<span class="fc" id="L585">            Set&lt;Integer&gt; resolved1 = new HashSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">            for (Integer redoIndex1 : redo) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (resolved1.contains(redoIndex1)) {</span>
<span class="fc" id="L588">                    continue;</span>
                }
<span class="fc" id="L590">                Integer conflictIndex2 = null;</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">                for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : assignedIndex2.entrySet()) {</span>
<span class="fc" id="L592">                    Set&lt;Integer&gt; indexes1 = entry.getValue();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">                    if (indexes1.contains(redoIndex1)) {</span>
<span class="fc" id="L594">                        conflictIndex2 = entry.getKey();</span>
<span class="fc" id="L595">                        break;</span>
                    }
<span class="fc" id="L597">                }</span>
<span class="fc" id="L598">                Set&lt;Integer&gt; conflictIndexes1 = assignedIndex2.get(conflictIndex2);</span>
                //decide by SSD or by difference from transformed point 1's
<span class="pc bpc" id="L600" title="3 of 4 branches missed.">                assert(conflictIndexes1 != null);</span>
<span class="fc" id="L601">                double bestCost = Double.MAX_VALUE;</span>
<span class="fc" id="L602">                Integer bestCostIndex1 = null;</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">                for (Integer index1 : conflictIndexes1) {</span>
<span class="fc" id="L604">                    IntensityFeatureComparisonStats st = index1Map.get(index1);</span>
<span class="pc bpc" id="L605" title="1 of 4 branches missed.">                    if ((bestCostIndex1 == null) || (bestCost &gt; st.getAdjustedCost())) {</span>
<span class="fc" id="L606">                        bestCost = st.getAdjustedCost();</span>
<span class="fc" id="L607">                        bestCostIndex1 = index1;</span>
                    }
<span class="fc" id="L609">                    resolved1.add(index1);</span>
<span class="fc" id="L610">                }</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                for (Integer index1 : conflictIndexes1) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                    if (index1.equals(bestCostIndex1)) {</span>
<span class="fc" id="L613">                        continue;</span>
                    }
<span class="fc" id="L615">                    index1Map.remove(index1);</span>
<span class="fc" id="L616">                }</span>
<span class="fc" id="L617">            }</span>
        }
        
<span class="fc" id="L620">        List&lt;FeatureComparisonStat&gt; add = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        for (Entry&lt;Integer, IntensityFeatureComparisonStats&gt; entry : index1Map.entrySet()) {</span>
            // make sure not already in compStats
<span class="fc bfc" id="L623" title="All 2 branches covered.">            for (FeatureComparisonStat stat : entry.getValue().getComparisonStats()) {</span>
<span class="fc" id="L624">                PairInt p1 = stat.getImg1Point();</span>
<span class="fc" id="L625">                PairInt p2 = stat.getImg2Point();</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">                for (FeatureComparisonStat cStat : compStats) {</span>
<span class="fc" id="L627">                    boolean found = false;</span>
<span class="fc" id="L628">                    PairInt p1c = cStat.getImg1Point();</span>
<span class="fc" id="L629">                    PairInt p2c = cStat.getImg2Point();</span>
<span class="pc bpc" id="L630" title="1 of 4 branches missed.">                    if (p1c.equals(p1) || p2c.equals(p2)) {</span>
<span class="fc" id="L631">                        found = true;</span>
<span class="fc" id="L632">                        break;</span>
                    }
<span class="fc" id="L634">                    int diffX1 = Math.abs(p1c.getX() - p1.getX());</span>
<span class="fc" id="L635">                    int diffY1 = Math.abs(p1c.getY() - p1.getY());</span>
<span class="fc bfc" id="L636" title="All 4 branches covered.">                    if ((diffX1 &lt; 5) &amp;&amp; (diffY1 &lt; 5)) {</span>
<span class="fc" id="L637">                        found = true;</span>
<span class="fc" id="L638">                        break;</span>
                    }
<span class="fc" id="L640">                    int diffX2 = Math.abs(p2c.getX() - p2.getX());</span>
<span class="fc" id="L641">                    int diffY2 = Math.abs(p2c.getY() - p2.getY());</span>
<span class="pc bpc" id="L642" title="1 of 4 branches missed.">                    if ((diffX2 &lt; 5) &amp;&amp; (diffY2 &lt; 5)) {</span>
<span class="nc" id="L643">                        found = true;</span>
<span class="nc" id="L644">                        break;</span>
                    }
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                    if (!found) {</span>
<span class="fc" id="L647">                        add.add(stat);</span>
                    }
<span class="fc" id="L649">                }</span>
<span class="fc" id="L650">            }</span>
<span class="fc" id="L651">        }</span>
        
<span class="fc" id="L653">        compStats.addAll(add);</span>
            
<span class="fc" id="L655">        return compStats;</span>
    }
    
    private &lt;T extends CornerRegion&gt; boolean statsCoverIntersection(
        List&lt;FeatureComparisonStat&gt; stats, List&lt;List&lt;T&gt;&gt; filteredC2) {
                
        /*
        dividing the range in filteredC2 by 2 in x and 2 in y and returning
        true if at least one point2 in stats is found in each division.             
        */
<span class="fc" id="L665">        int n = 0;</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">        for (List&lt;T&gt; list : filteredC2) {</span>
<span class="fc" id="L667">            n += list.size();</span>
<span class="fc" id="L668">        }</span>
<span class="fc" id="L669">        float[] xPoints = new float[n];</span>
<span class="fc" id="L670">        float[] yPoints = new float[n];</span>
        
<span class="fc" id="L672">        n = 0;</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">        for (List&lt;T&gt; list : filteredC2) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            for (T cr : list) {</span>
<span class="fc" id="L675">                float x = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L676">                float y = cr.getY()[cr.getKMaxIdx()];</span>
<span class="fc" id="L677">                xPoints[n] = x;</span>
<span class="fc" id="L678">                yPoints[n] = y;</span>
<span class="fc" id="L679">                ++n;</span>
<span class="fc" id="L680">            }</span>
<span class="fc" id="L681">        }</span>
        
<span class="fc" id="L683">        return statsCoverIntersection(stats, xPoints, yPoints);</span>
    }
    
    private boolean statsCoverIntersection(List&lt;FeatureComparisonStat&gt; stats, 
        final float[] xPoints, final float[] yPoints) {
               
<span class="fc" id="L689">        int n = xPoints.length;</span>
        
<span class="fc" id="L691">        QuickSort.sortBy1stThen2nd(xPoints, yPoints);</span>
        
<span class="fc" id="L693">        float minX = xPoints[0];</span>
<span class="fc" id="L694">        float maxX = xPoints[n - 1];</span>
<span class="fc" id="L695">        float divX = (maxX + minX)/2.f;</span>
       
        /*
        Finding y min and max within each of these division.  The reason
        for doing this separately from y min max over all of filteredC2 is that 
        the geometry of matchable points might not be rectangular.
        
            |          |          |
            |          |          |
            |          |          |
                 0           1
        */
        
<span class="fc" id="L708">        float[] yMin = new float[2];</span>
<span class="fc" id="L709">        Arrays.fill(yMin, Float.MAX_VALUE);</span>
<span class="fc" id="L710">        float[] yMax = new float[2];</span>
<span class="fc" id="L711">        Arrays.fill(yMax, Float.MIN_VALUE);</span>
        
<span class="fc bfc" id="L713" title="All 2 branches covered.">        for (int i = 0; i &lt; xPoints.length; ++i) {</span>
<span class="fc" id="L714">            float x = xPoints[i];</span>
<span class="fc" id="L715">            float y = yPoints[i];</span>
<span class="fc" id="L716">            int cIdx = 1;</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">            if (x &lt; divX) {</span>
<span class="fc" id="L718">                cIdx = 0;</span>
            }
<span class="fc bfc" id="L720" title="All 2 branches covered.">            if (y &lt; yMin[cIdx]) {</span>
<span class="fc" id="L721">                yMin[cIdx] = y;</span>
            }
<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (y &gt; yMax[cIdx]) {</span>
<span class="fc" id="L724">                yMax[cIdx] = y;</span>
            }
        }
        
<span class="fc" id="L728">        float yDiv12 = (yMax[0] + yMin[0])/2.f;</span>
<span class="fc" id="L729">        float yDiv03 = (yMax[1] + yMin[1])/2.f;</span>
        
        /*
             2       3
        |        |        |
             1       0
        */
        
<span class="fc" id="L737">        int[] counts = new int[4];</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
<span class="fc" id="L739">            PairInt p2 = stat.getImg2Point();</span>
<span class="fc" id="L740">            int x = p2.getX();</span>
<span class="fc" id="L741">            int y = p2.getY();</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">            if (x &lt; divX) {</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">                if (y &lt; yDiv12) {</span>
<span class="fc" id="L744">                    counts[1]++;</span>
                } else {
<span class="fc" id="L746">                    counts[2]++;</span>
                }
            } else {
<span class="fc bfc" id="L749" title="All 2 branches covered.">                if (y &lt; yDiv03) {</span>
<span class="fc" id="L750">                    counts[0]++;</span>
                } else {
<span class="fc" id="L752">                    counts[3]++;</span>
                }
            }
<span class="fc" id="L755">        }</span>
        
<span class="fc" id="L757">        int nq = 0;</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        for (int i = 0; i &lt; counts.length; ++i) {</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">            if (counts[i] &gt; 0) {</span>
<span class="fc" id="L760">                nq++;</span>
            }
        }
        
        // check that there is at least 1 in each quadrant
        //if (nq &gt;= 3) {
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (nq == 4) {</span>
<span class="fc" id="L767">            return true;</span>
        }
        
<span class="fc" id="L770">        return false;</span>
    }
    
    private void populateLists(List&lt;FeatureComparisonStat&gt; stats, 
        List&lt;PairInt&gt; matched1, List&lt;PairInt&gt; matched2) {
        
<span class="fc bfc" id="L776" title="All 2 branches covered.">        for (FeatureComparisonStat stat : stats) {</span>
            
<span class="fc" id="L778">            int x1 = stat.getImg1Point().getX();</span>
<span class="fc" id="L779">            int y1 = stat.getImg1Point().getY();</span>
<span class="fc" id="L780">            int x2 = stat.getImg2Point().getX();</span>
<span class="fc" id="L781">            int y2 = stat.getImg2Point().getY();</span>
            
<span class="fc" id="L783">            matched1.add(new PairInt(x1, y1));</span>
            
<span class="fc" id="L785">            matched2.add(new PairInt(x2, y2));</span>
<span class="fc" id="L786">        }</span>
<span class="fc" id="L787">    }</span>
    
    private CorrespondenceList extractAndMatch(
        TransformationParameters parameters) {
        
<span class="fc" id="L792">        extractCornerRegions();</span>

<span class="fc" id="L794">        CorrespondenceList cl = findCorrespondence(parameters);</span>
        
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        if (cl != null) {</span>
            // add stats in if not already present
<span class="fc" id="L798">            int z = 1;</span>
        }
        
<span class="fc" id="L801">        return cl;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BlobCornersScaleFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">BlobCornersScaleFinder.java</span></div><h1>BlobCornersScaleFinder.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.NearestPoints;
import algorithms.compGeometry.RotatedOffsets;
import algorithms.compGeometry.clustering.FixedDistanceGroupFinder;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.ScatterPointPlotterPNG;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * class to invoke methods needed to solve for euclidean scale between
 * image1 and image2 using methods specific to corners on closed curves.
 *
 * @author nichole
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public class BlobCornersScaleFinder extends AbstractBlobScaleFinder {</span>

<span class="fc" id="L28">    private double ssdLimit = 1500;</span>

    public MatchingSolution solveForScale(
        BlobCornerHelper img1Helper, IntensityFeatures features1,
        SegmentationType type1, boolean useBinned1,
        BlobCornerHelper img2Helper, IntensityFeatures features2,
        SegmentationType type2, boolean useBinned2) {

<span class="fc" id="L36">        List&lt;List&lt;CornerRegion&gt;&gt; corners1List = img1Helper.getPerimeterCorners(</span>
            type1, useBinned1);
<span class="fc" id="L38">        List&lt;List&lt;CornerRegion&gt;&gt; corners2List = img2Helper.getPerimeterCorners(</span>
            type2, useBinned2);
<span class="fc" id="L40">        List&lt;Set&lt;PairInt&gt;&gt; blobs1 = img1Helper.imgHelper.getBlobs(type1, useBinned1);</span>
<span class="fc" id="L41">        List&lt;Set&lt;PairInt&gt;&gt; blobs2 = img2Helper.imgHelper.getBlobs(type2, useBinned2);</span>
<span class="fc" id="L42">        List&lt;PairIntArray&gt; perimeters1 = img1Helper.imgHelper.getBlobPerimeters(</span>
            type1, useBinned1);
<span class="fc" id="L44">        List&lt;PairIntArray&gt; perimeters2 = img2Helper.imgHelper.getBlobPerimeters(</span>
            type2, useBinned2);

<span class="fc" id="L47">        GreyscaleImage img1 = img1Helper.imgHelper.getGreyscaleImage(useBinned1);</span>
<span class="fc" id="L48">        GreyscaleImage img2 = img2Helper.imgHelper.getGreyscaleImage(useBinned2);</span>
        
<span class="pc bpc" id="L50" title="3 of 4 branches missed.">        assert(blobs1.size() == perimeters1.size());</span>
<span class="pc bpc" id="L51" title="3 of 4 branches missed.">        assert(blobs1.size() == corners1List.size());</span>
<span class="pc bpc" id="L52" title="3 of 4 branches missed.">        assert(blobs2.size() == perimeters2.size());</span>
<span class="pc bpc" id="L53" title="3 of 4 branches missed.">        assert(blobs2.size() == corners2List.size());</span>

<span class="fc" id="L55">        float dist = 2.5f;</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        for (int i = 0; i &lt; perimeters1.size(); ++i) {</span>
<span class="fc" id="L57">            filterCorners(perimeters1.get(i), corners1List.get(i), dist);</span>
        }
<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (int i = 0; i &lt; perimeters2.size(); ++i) {</span>
<span class="fc" id="L60">            filterCorners(perimeters2.get(i), corners2List.get(i), dist);</span>
        }

        if (true) {
<span class="fc bfc" id="L64" title="All 2 branches covered.">            for (List&lt;CornerRegion&gt; list : corners1List) {</span>
<span class="fc" id="L65">                sortCornersToCCW(list);</span>
<span class="fc" id="L66">            }</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">            for (List&lt;CornerRegion&gt; list : corners2List) {</span>
<span class="fc" id="L68">                sortCornersToCCW(list);</span>
<span class="fc" id="L69">            }</span>
        }

<span class="fc" id="L72">        MatchingSolution soln = match(img1Helper, img2Helper, </span>
            features1, features2, img1, img2, corners1List, corners2List, 
            useBinned1, useBinned2);

<span class="fc" id="L76">        return soln;</span>
    }

    private &lt;T extends CornerRegion&gt; MatchingSolution match(
        BlobCornerHelper img1Helper, BlobCornerHelper img2Helper,
        IntensityFeatures features1, IntensityFeatures features2,
        GreyscaleImage img1, GreyscaleImage img2,
        List&lt;List&lt;T&gt;&gt; corners1List, List&lt;List&lt;T&gt;&gt; corners2List,
        boolean useBinned1, boolean useBinned2) {
        
<span class="fc" id="L86">        int binFactor1 = img1Helper.imgHelper.getBinFactor(useBinned1);</span>
<span class="fc" id="L87">        int binFactor2 = img2Helper.imgHelper.getBinFactor(useBinned2);</span>

/*
List&lt;PairIntArray&gt; perimeters1 = img1Helper.imgHelper.getBlobPerimeters(
    type1, useBinned1);
List&lt;PairIntArray&gt; perimeters2 = img2Helper.imgHelper.getBlobPerimeters(
    type2, useBinned2);
MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();
float[] xPoints1 = new float[perimeters1.size()];
float[] yPoints1 = new float[perimeters1.size()];
double[][] xy1 = new double[perimeters1.size()][2];
for (int i = 0; i &lt; perimeters1.size(); ++i) {
xy1[i] = curveHelper.calculateXYCentroids(perimeters1.get(i));
xPoints1[i] = (float)xy1[i][0];
yPoints1[i] = (float)xy1[i][1];
}
float[] xPoints2 = new float[perimeters2.size()];
float[] yPoints2 = new float[perimeters2.size()];
double[][] xy2 = new double[perimeters2.size()][2];
for (int i = 0; i &lt; perimeters2.size(); ++i) {
xy2[i] = curveHelper.calculateXYCentroids(perimeters2.get(i));
xPoints2[i] = (float)xy2[i][0];
yPoints2[i] = (float)xy2[i][1];
}

ScatterPointPlotterPNG plotter = new ScatterPointPlotterPNG();
plotter.plotLabeledPoints(0, img1.getWidth(), 0, img1.getHeight(), xPoints1, yPoints1,
&quot;img1&quot;, &quot;X&quot;, &quot;Y&quot;);
ScatterPointPlotterPNG plotter2 = new ScatterPointPlotterPNG();
plotter2.plotLabeledPoints(0, img2.getWidth(), 0, img2.getHeight(), xPoints2, yPoints2,
&quot;img2&quot;, &quot;X&quot;, &quot;Y&quot;);
try {
    plotter.writeToFile(&quot;img1_labelled.png&quot;);
    plotter2.writeToFile(&quot;img2_labelled.png&quot;);
} catch (IOException ex) {
    Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);
}

StringBuilder sb = new StringBuilder(&quot;xy1:\n&quot;);
for (int i = 0; i &lt; xy1.length; ++i) {
    sb.append(String.format(&quot;[%2d] (%3d, %3d)\n&quot;, i,
        (int)Math.round(xy1[i][0]), (int)Math.round(xy1[i][1])));
}
sb.append(&quot;xy2:\n&quot;);
for (int i = 0; i &lt; xy2.length; ++i) {
    sb.append(String.format(&quot;[%2d] (%3d, %3d)\n&quot;, i,
        (int)Math.round(xy2[i][0]), (int)Math.round(xy2[i][1])));
}
System.out.println(sb.toString());
*/
/*
PairInt[] im1Chk = new PairInt[]{
    new PairInt(59, 178), new PairInt(42, 110), new PairInt(27, 105),
    new PairInt(68,  80), new PairInt(25,  55), new PairInt(80, 144)
};
PairInt[] im2Chk = new PairInt[]{
    new PairInt(189, 179), new PairInt(164, 109), new PairInt(164, 109),
    new PairInt(189, 179), new PairInt(154,  59), new PairInt(193, 146)
};
int[] im1ChkIdxs = new int[im1Chk.length];
int[] im2ChkIdxs = new int[im2Chk.length];
for (int i = 0; i &lt; im1Chk.length; ++i) {
    PairInt p = im1Chk[i];
    for (int j = 0; j &lt; xy1.length; ++j) {
        double diffX = p.getX() - xy1[j][0];
        double diffY = p.getY() - xy1[j][1];
        if (Math.abs(diffX) &lt; 20 &amp;&amp; Math.abs(diffY) &lt; 20) {
            im1ChkIdxs[i] = j;
            break;
        }
    }
}
for (int i = 0; i &lt; im2Chk.length; ++i) {
    PairInt p = im2Chk[i];
    for (int j = 0; j &lt; xy2.length; ++j) {
        double diffX = p.getX() - xy2[j][0];
        double diffY = p.getY() - xy2[j][1];
        if (Math.abs(diffX) &lt; 20 &amp;&amp; Math.abs(diffY) &lt; 20) {
            im2ChkIdxs[i] = j;
            break;
        }
    }
}
sb = new StringBuilder(&quot;expeected matches:\n&quot;);
for (int i = 0; i &lt; im1ChkIdxs.length; ++i) {
    sb.append(String.format(&quot;[%d] to [%d]&quot;, im1ChkIdxs[i], im2ChkIdxs[i]));
    sb.append(&quot;\n&quot;);
}
System.out.println(sb.toString());
*/
<span class="fc" id="L177">        Map&lt;PairInt, TransformationParameters&gt; trMap</span>
            = new HashMap&lt;PairInt, TransformationParameters&gt;();

<span class="fc" id="L180">        int n1 = corners1List.size();</span>
<span class="fc" id="L181">        int n2 = corners2List.size();</span>

<span class="pc bpc" id="L183" title="2 of 4 branches missed.">        if (n1 == 0 || n2 == 0) {</span>
<span class="nc" id="L184">            return null;</span>
        }

        /*
        -- get best TransformationParameters for each idx1
           (this is at most 40 of them)
        -- consider combining similar parameters to reduce the eval step
        -- evaluate each param against all points.
            -- make 2 eval methods, hopefully the fastest is enough
               -- (1) eval by finding an existing point within tolerance of predicted position
               -- (2) eval by finding best SSD of points within tolerance of predicted and
                      use nEval, SSD and dist to return a normalized cost
        */

<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (int idx1 = 0; idx1 &lt; n1; ++idx1) {</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (corners1List.get(idx1).size() &lt; 3) {</span>
<span class="fc" id="L201">                continue;</span>
            }

<span class="fc" id="L204">            List&lt;T&gt; corners1 = corners1List.get(idx1);</span>

            /*
            first, see if nEval alone finds the true matches for curve to curve
            */
<span class="fc" id="L209">            int maxNEval = Integer.MIN_VALUE;</span>
<span class="fc" id="L210">            TransformationParameters maxNEvalParams = null;</span>
<span class="fc" id="L211">            Integer maxNEvalIndex2 = null;</span>
<span class="fc" id="L212">            double minCost = Double.MAX_VALUE;</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">            for (int idx2 = 0; idx2 &lt; n2; ++idx2) {</span>

<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (corners2List.get(idx2).size() &lt; 3) {</span>
<span class="fc" id="L217">                    continue;</span>
                }

<span class="fc" id="L220">                Integer index2 = Integer.valueOf(idx2);</span>

<span class="fc" id="L222">                List&lt;T&gt; corners2 = corners2List.get(idx2);</span>

<span class="fc" id="L224">                ClosedCurveCornerMatcher2&lt;T&gt; mapper =</span>
                    new ClosedCurveCornerMatcher2&lt;T&gt;();

<span class="fc" id="L227">                boolean matched = mapper.matchCorners(features1, features2,</span>
                    corners1, corners2, img1, img2, binFactor1, binFactor2);

<span class="fc bfc" id="L230" title="All 2 branches covered.">                if (!matched) {</span>
<span class="fc" id="L231">                    continue;</span>
                }

                // NOTE: if solving for binned, the params are in binned reference frame
<span class="fc" id="L235">                TransformationParameters params = mapper.getSolution();</span>
<span class="fc" id="L236">                int nEval = mapper.getNEval();</span>
<span class="fc" id="L237">                double cost = mapper.getSolutionCost();</span>
                
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (nEval &lt; 2) {</span>
<span class="fc" id="L240">                    continue;</span>
                }

<span class="fc bfc" id="L243" title="All 2 branches covered.">                if (cost &lt; minCost) {</span>
<span class="fc bfc" id="L244" title="All 4 branches covered.">                    if ((nEval &lt; 3) &amp;&amp; (maxNEval &gt; 4)) {</span>
                        // do not accept if nEval is much lower than maxNEval
<span class="fc" id="L246">                        continue;</span>
                    }
<span class="fc" id="L248">                    maxNEval = nEval;</span>
<span class="fc" id="L249">                    maxNEvalParams = params;</span>
<span class="fc" id="L250">                    maxNEvalIndex2 = index2;</span>
<span class="fc" id="L251">                    minCost = cost;</span>
<span class="fc bfc" id="L252" title="All 4 branches covered.">                } else if ((maxNEval == 2) &amp;&amp; (nEval &gt; 3)) {</span>
                    //TODO: may need to revise this
<span class="fc" id="L254">                    double avgCost = (cost + minCost)/2.;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                    if ((Math.abs(cost - avgCost)/(0.1*avgCost)) &lt; 2) {</span>
<span class="fc" id="L256">                        maxNEval = nEval;</span>
<span class="fc" id="L257">                        maxNEvalParams = params;</span>
<span class="fc" id="L258">                        maxNEvalIndex2 = index2;</span>
<span class="fc" id="L259">                        minCost = cost;</span>
                    }
                }
            }

<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (maxNEvalParams != null) {</span>
<span class="fc" id="L265">                trMap.put(new PairInt(idx1, maxNEvalIndex2.intValue()),</span>
                    maxNEvalParams);
            }
        }

<span class="fc" id="L270">        int n2c = 0;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        for (List&lt;T&gt; corners2 : corners2List) {</span>
<span class="fc" id="L272">            n2c += corners2.size();</span>
<span class="fc" id="L273">        }</span>

<span class="fc" id="L275">        List&lt;T&gt; cr2List = new ArrayList&lt;T&gt;();</span>
<span class="fc" id="L276">        int[] xC2 = new int[n2c];</span>
<span class="fc" id="L277">        int[] yC2 = new int[n2c];</span>
<span class="fc" id="L278">        n2c = 0;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (List&lt;T&gt; corners2 : corners2List) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            for (T cr2: corners2) {</span>
<span class="fc" id="L281">                xC2[n2c] = cr2.getX()[cr2.getKMaxIdx()];</span>
<span class="fc" id="L282">                yC2[n2c] = cr2.getY()[cr2.getKMaxIdx()];</span>
<span class="fc" id="L283">                cr2List.add(cr2);</span>
<span class="fc" id="L284">                n2c++;</span>
<span class="fc" id="L285">            }</span>
<span class="fc" id="L286">        }</span>

<span class="fc" id="L288">        NearestPoints np2 = new NearestPoints(xC2, yC2);</span>

<span class="fc" id="L290">        MatchingSolution soln = evaluateForBestUsingFeatures(</span>
            img1Helper, img2Helper, features1, features2, img1, img2,
            trMap, corners1List, cr2List, np2, binFactor1, binFactor2);

<span class="fc" id="L294">        return soln;</span>
    }

    /**
     * given parameters map, evaluate the corner lists and return the solution.
     * Note that if binFactors are not equal to '1', it's assumed that the
     * paramsMap are in the binned reference frame and corrections to that
     * are made for the returned solution.
     * @param &lt;T&gt;
     * @param img1Helper
     * @param img2Helper
     * @param features1
     * @param features2
     * @param img1
     * @param img2
     * @param paramsMap
     * @param corners1List
     * @param corners2List
     * @param np2
     * @param binFactor1
     * @param binFactor2
     * @return
     */
    private &lt;T extends CornerRegion&gt; MatchingSolution evaluateForBestUsingFeatures(
        BlobCornerHelper img1Helper, BlobCornerHelper img2Helper,
        IntensityFeatures features1, IntensityFeatures features2,
        GreyscaleImage img1, GreyscaleImage img2,
        Map&lt;PairInt, TransformationParameters&gt; paramsMap,
        List&lt;List&lt;T&gt;&gt; corners1List, List&lt;T&gt; corners2List,
        NearestPoints np2, int binFactor1, int binFactor2) {

<span class="fc" id="L325">        int tolTransXY = 5;//10;</span>

<span class="fc" id="L327">        double maxDistance = Math.sqrt(2) * tolTransXY;</span>

        /*
        -- evaluate each param against all points.
           -- (2) eval by finding best SSD of points within tolerance of predicted and
              use nEval, SSD and dist to return a normalized cost
        */

        //List&lt;TransformationParameters&gt; parameterList =
        //    MiscStats.filterToSimilarParamSets(paramsMap, binFactor1, binFactor2);

<span class="fc" id="L338">        List&lt;TransformationParameters&gt; parameterList =</span>
<span class="fc" id="L339">            MiscStats.filterToSimilarParamSets2(paramsMap, binFactor1, binFactor2);</span>

<span class="fc" id="L341">        int n1 = 0;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (List&lt;T&gt; corners1 : corners1List) {</span>
<span class="fc" id="L343">            n1 += corners1.size();</span>
<span class="fc" id="L344">        }</span>
<span class="fc" id="L345">        int n2 = corners2List.size();</span>
<span class="fc" id="L346">        int nMaxMatchable = Math.min(n1, n2);</span>

<span class="fc" id="L348">        FeatureMatcher featureMatcher = new FeatureMatcher();</span>
<span class="fc" id="L349">        Transformer transformer = new Transformer();</span>

<span class="fc" id="L351">        final int rotationTolerance = 20;</span>

<span class="fc" id="L353">        final int dither = 4;</span>

<span class="fc" id="L355">        TransformationParameters bestParams = null;</span>
<span class="fc" id="L356">        float bestCost = Float.MAX_VALUE;</span>
<span class="fc" id="L357">        float bestCost1Norm = Float.MAX_VALUE;</span>
<span class="fc" id="L358">        List&lt;FeatureComparisonStat&gt; bestStats = null;</span>
        
        // in the case that best is null, store and consider the best solution
        // that has a larger scatter in parameters (standard deviations are large)
<span class="fc" id="L362">        TransformationParameters bestParamsLg = null;</span>
<span class="fc" id="L363">        float bestCostLg = Float.MAX_VALUE;</span>
<span class="fc" id="L364">        float bestCost1NormLg = Float.MAX_VALUE;</span>
<span class="fc" id="L365">        List&lt;FeatureComparisonStat&gt; bestStatsLg = null;</span>

<span class="fc" id="L367">        boolean tolIsTooLarge = false;</span>

<span class="fc" id="L369">        int nIter = 0;</span>

<span class="fc" id="L371">        int deltaTol = 0;</span>

<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        while (nIter &lt; 2) {</span>

<span class="fc" id="L375">            tolIsTooLarge = false;</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">            for (TransformationParameters params : parameterList) {</span>

<span class="fc" id="L379">                double rotInRadians = params.getRotationInRadians();</span>
<span class="fc" id="L380">                double cos = Math.cos(rotInRadians);</span>
<span class="fc" id="L381">                double sin = Math.sin(rotInRadians);</span>

<span class="fc" id="L383">                int rotD = Math.round(params.getRotationInDegrees());</span>

<span class="fc" id="L385">                int tolTransXY2 = tolTransXY;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                if (params.getScale() &lt; 1) {</span>
<span class="fc" id="L387">                    tolTransXY2 = Math.round(tolTransXY * params.getScale());</span>
                }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                if (tolTransXY2 == 0) {</span>
<span class="nc" id="L390">                    tolTransXY2 = 1;</span>
                }
<span class="fc bfc" id="L392" title="All 2 branches covered.">                if (tolTransXY2 &gt; 1) {</span>
<span class="fc" id="L393">                    tolTransXY2 -= deltaTol;</span>
                }
<span class="fc" id="L395">                int dither2 = Math.round(dither * params.getScale());</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                if (dither2 == 0) {</span>
<span class="nc" id="L397">                    dither2 = 1;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                } else if (dither2 &gt; dither) {</span>
                    // large dither makes runtime larger
<span class="fc" id="L400">                    dither2 = dither;</span>
                }

<span class="fc" id="L403">                int nEval = 0;</span>
<span class="fc" id="L404">                double sumSSD = 0;</span>
<span class="fc" id="L405">                double sumDist = 0;</span>
<span class="fc" id="L406">                List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="fc bfc" id="L408" title="All 2 branches covered.">                for (List&lt;T&gt; corners1 : corners1List) {</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">                    for (T cr : corners1) {</span>

<span class="fc" id="L412">                        T crTr = transformer.applyTransformation(params, cr, cos, sin);</span>

<span class="fc" id="L414">                        Set&lt;Integer&gt; indexes2 = np2.findNeighborIndexes(</span>
<span class="fc" id="L415">                            crTr.getX()[crTr.getKMaxIdx()],</span>
<span class="fc" id="L416">                            crTr.getY()[crTr.getKMaxIdx()], tolTransXY2);</span>

<span class="fc bfc" id="L418" title="All 2 branches covered.">                        for (Integer index : indexes2) {</span>

<span class="fc" id="L420">                            int idx2 = index.intValue();</span>

<span class="fc" id="L422">                            T corner2 = corners2List.get(idx2);</span>

<span class="fc" id="L424">                            FeatureComparisonStat compStat = </span>
<span class="fc" id="L425">                                featureMatcher.ditherAndRotateForBestLocation2(</span>
                                features1, features2, cr, corner2, dither2,
                                rotD, rotationTolerance, img1, img2);
                            
<span class="fc bfc" id="L429" title="All 4 branches covered.">                            if (compStat == null || (compStat.getSumIntensitySqDiff() &gt;= ssdLimit)</span>
                                ||
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                                (compStat.getSumIntensitySqDiff() &gt;= compStat.getImg2PointIntensityErr())) {</span>
<span class="nc" id="L432">                                continue;</span>
                            }

<span class="fc" id="L435">                            double xTr = (compStat.getImg1Point().getX() *</span>
<span class="fc" id="L436">                                params.getScale() * cos) +</span>
<span class="fc" id="L437">                                (compStat.getImg1Point().getY() *</span>
<span class="fc" id="L438">                                params.getScale() * sin);</span>
<span class="fc" id="L439">                            xTr += params.getTranslationX();</span>

<span class="fc" id="L441">                            double yTr = (-compStat.getImg1Point().getX() *</span>
<span class="fc" id="L442">                                params.getScale() * sin) +</span>
<span class="fc" id="L443">                                (compStat.getImg1Point().getY() *</span>
<span class="fc" id="L444">                                params.getScale()* cos);</span>
<span class="fc" id="L445">                            yTr += params.getTranslationY();</span>

<span class="fc" id="L447">                            double dist = distance(xTr, yTr,</span>
<span class="fc" id="L448">                                compStat.getImg2Point().getX(),</span>
<span class="fc" id="L449">                                compStat.getImg2Point().getY());</span>

<span class="fc" id="L451">                            stats.add(compStat);</span>

<span class="fc" id="L453">                            sumDist += Math.abs(dist);</span>
<span class="fc" id="L454">                            sumSSD += compStat.getSumIntensitySqDiff();</span>
<span class="fc" id="L455">                            nEval++;</span>
<span class="fc" id="L456">                        }</span>
<span class="fc" id="L457">                    }</span>
<span class="fc" id="L458">                }</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">                if (nEval == 0) {</span>
<span class="fc" id="L461">                    continue;</span>
                }

                // distance needs to be adjusted by scale, else the cost prefers
                // small scale solutions
<span class="fc" id="L466">                sumDist /= params.getScale();</span>

<span class="fc" id="L468">                sumSSD /= (double)nEval;</span>
<span class="fc" id="L469">                sumDist /= (double)nEval;</span>

<span class="fc" id="L471">                float cost1Norm = 1.f/(float)nEval;</span>
<span class="fc" id="L472">                float cost2Norm = (float)(sumSSD/ssdLimit);</span>
<span class="fc" id="L473">                float cost3Norm = (float)sumDist;</span>
<span class="fc" id="L474">                float normalizedCost = cost1Norm * cost2Norm * cost3Norm;</span>
               
                //TODO: cost1Norm's proportion in normalizedCost should be higher
                
<span class="fc bfc" id="L478" title="All 2 branches covered.">                boolean t1 = (normalizedCost &lt; bestCost);</span>
                
<span class="fc bfc" id="L480" title="All 4 branches covered.">                if (t1 &amp;&amp; (nEval &gt; 2)) {</span>

<span class="fc" id="L482">                    TransformationParameters combinedParams =</span>
<span class="fc" id="L483">                        MiscStats.calculateTransformation(binFactor1, binFactor2,</span>
                            stats, new float[4]);

<span class="fc bfc" id="L486" title="All 2 branches covered.">                    if (combinedParams == null) {</span>
<span class="fc" id="L487">                        continue;</span>
                    }

<span class="fc bfc" id="L490" title="All 2 branches covered.">                    if (MiscStats.standardDeviationsAreSmall(combinedParams)) {</span>
<span class="fc" id="L491">                        tolIsTooLarge = false;</span>
<span class="fc" id="L492">                        bestCost = normalizedCost;</span>
<span class="fc" id="L493">                        bestParams = combinedParams;</span>
<span class="fc" id="L494">                        bestStats = stats;</span>
<span class="fc" id="L495">                        bestCost1Norm = cost1Norm;</span>
<span class="fc" id="L496">                        combinedParams.setNumberOfPointsUsed(stats.size());</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                    } else if (MiscStats.standardDeviationsAreSmall(params)) {</span>
                        //TODO: this suggests tolTransXY2 is too large
<span class="fc" id="L499">                        tolIsTooLarge = true;</span>
<span class="fc" id="L500">                        bestCost = normalizedCost;</span>
<span class="fc" id="L501">                        bestParams = params;</span>
<span class="fc" id="L502">                        bestStats = stats;</span>
<span class="fc" id="L503">                        bestCost1Norm = cost1Norm;</span>
<span class="fc" id="L504">                        params.setNumberOfPointsUsed(stats.size());</span>
                    } else {
<span class="fc bfc" id="L506" title="All 2 branches covered.">                        if (normalizedCost &lt; bestCostLg) {</span>
<span class="fc" id="L507">                            bestCostLg = normalizedCost;</span>
<span class="fc" id="L508">                            bestParamsLg = combinedParams;</span>
<span class="fc" id="L509">                            bestStatsLg = stats;</span>
<span class="fc" id="L510">                            bestCost1NormLg = cost1Norm;</span>
<span class="fc" id="L511">                            combinedParams.setNumberOfPointsUsed(stats.size());</span>
                        }
                    }
                }
<span class="fc" id="L515">            }</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (!tolIsTooLarge) {</span>
<span class="fc" id="L517">                break;</span>
            }
<span class="fc" id="L519">            deltaTol++;</span>

<span class="fc" id="L521">            nIter++;</span>
        }
        
<span class="pc bpc" id="L524" title="1 of 4 branches missed.">        if ((bestParamsLg != null) &amp;&amp; (bestParams != null)) {</span>
            
            /*
            When there are large projection effects, the standard deviation of 
            parameters has a larger scatter, but bestParamsLg may actually be
            the better solution over bestParams.
            
            Decide between the two based upon the stats sizes, norm costs,
            and stdevs.
            */
            
<span class="fc bfc" id="L535" title="All 4 branches covered.">            if ((bestCost1NormLg &lt; bestCost) &amp;&amp; (bestStatsLg.size() &gt; bestStats.size())) {            </span>
                  
                // TODO: needs a careful look at the range of values in pixel descriptors
                // and more testing to understand if this limit is always valid
<span class="fc" id="L539">                int n = bestStatsLg.size();</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                for (int i = (n - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L541">                    FeatureComparisonStat stat = bestStatsLg.get(i);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                    if (stat.getSumIntensitySqDiff() &gt; 800) {</span>
<span class="fc" id="L543">                        bestStatsLg.remove(i);</span>
                    }
                }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                if (n &lt; bestStatsLg.size()) {</span>
<span class="nc" id="L547">                    bestParamsLg = MiscStats.calculateTransformation(binFactor1, </span>
                        binFactor2, bestStatsLg, new float[4]);
                }
                
<span class="fc" id="L551">                float factor = Math.min(bestCost/bestCost1NormLg, </span>
<span class="fc" id="L552">                    bestStatsLg.size()/bestStats.size());</span>
                
<span class="fc" id="L554">                boolean t = true;</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">                for (int i = 0; i &lt; bestParams.getStandardDeviations().length; ++i) {</span>
<span class="fc" id="L556">                    float s0 = bestParams.getStandardDeviations()[i];</span>
<span class="fc" id="L557">                    float s1 = bestParamsLg.getStandardDeviations()[i];</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                    if (Math.abs(s0 - s1) &gt; (factor * s0)) {</span>
<span class="fc" id="L559">                        t = false;</span>
<span class="fc" id="L560">                        break;</span>
                    }
                }
                
<span class="fc bfc" id="L564" title="All 2 branches covered.">                if (t) {</span>
                    
                    /*
                    The large scatter in standard deviations implies that there
                    my be large projection effects.
                    For that reason, if there are not many points covering the 
                    intersection of the transformation,
                    using another segmenation and feature matching step to try to
                    constrain more of the transformation.
                    */

<span class="fc" id="L575">                    int img1Width = img1.getWidth();</span>
<span class="fc" id="L576">                    int img1Height = img1.getWidth();</span>
<span class="fc" id="L577">                    int img2Width = img2.getWidth();</span>
<span class="fc" id="L578">                    int img2Height = img2.getHeight();</span>

<span class="fc" id="L580">                    int[] qCounts = </span>
<span class="fc" id="L581">                        ImageStatisticsHelper.getQuadrantCountsForIntersection(</span>
                        bestParamsLg, bestStatsLg,
                        img1Width, img1Height, img2Width, img2Height);

<span class="fc" id="L585">                    boolean extractMoreFeatures = false;</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">                    for (int count : qCounts) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                        if (count &lt; 5) {</span>
<span class="fc" id="L588">                            extractMoreFeatures = true;</span>
<span class="fc" id="L589">                            break;</span>
                        }
                    }

<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                    if (extractMoreFeatures) {</span>

<span class="fc" id="L595">                        ImageExt imgExt1 = img1Helper.imgHelper.getImage().copyToImageExt();</span>
<span class="fc" id="L596">                        ImageExt imgExt2 = img2Helper.imgHelper.getImage().copyToImageExt();</span>
<span class="fc" id="L597">                        ImageProcessor imageProcessor = new ImageProcessor();</span>
                        int smallestGroupLimit, largestGroupLimit;
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">                        if (binFactor1 == 1) {</span>
<span class="nc" id="L600">                            smallestGroupLimit = img1Helper.imgHelper.getSmallestGroupLimit();</span>
<span class="nc" id="L601">                            largestGroupLimit = img1Helper.imgHelper.getLargestGroupLimit();</span>
                        } else {
<span class="fc" id="L603">                            imgExt1 = imageProcessor.binImage(imgExt1, binFactor1);</span>
<span class="fc" id="L604">                            smallestGroupLimit = img1Helper.imgHelper.getSmallestGroupLimitBinned();</span>
<span class="fc" id="L605">                            largestGroupLimit = img1Helper.imgHelper.getLargestGroupLimitBinned();</span>
                        }
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">                        if (binFactor2 != 1) {</span>
<span class="fc" id="L608">                            imgExt2 = imageProcessor.binImage(imgExt2, binFactor2);</span>
                        }
<span class="fc" id="L610">                        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
<span class="fc" id="L611">                        GreyscaleImage imgSeg1Tmp = imageSegmentation.createGreyscale7(imgExt1);</span>
<span class="fc" id="L612">                        GreyscaleImage imgSeg2Tmp = imageSegmentation.createGreyscale7(imgExt2);</span>

<span class="fc" id="L614">                        BlobCornerFinderForParameters finder = </span>
                            new BlobCornerFinderForParameters();

                        //TODO: possible problem here using same group limit size on both images
<span class="fc" id="L618">                        List&lt;FeatureComparisonStat&gt; stats2 = finder.extractFeatures(</span>
                            bestParamsLg, img1, img2,
                            imgSeg1Tmp, imgSeg2Tmp, 
                            binFactor1, binFactor2,
                            smallestGroupLimit, largestGroupLimit, 
<span class="fc" id="L623">                            features1.getRotatedOffsets(),</span>
<span class="fc" id="L624">                            img1Helper.imgHelper.isInDebugMode(),</span>
<span class="fc" id="L625">                            img1Helper.imgHelper.getDebugTag());</span>

                        /*
                        -- filter returned points already in statsLg unless the match
                           is different and has smaller SSD
                        -- recalculate transformation parameters
                        */

<span class="fc bfc" id="L633" title="All 2 branches covered.">                        for (int i = (stats2.size() - 1); i &gt; -1; --i) {</span>

<span class="fc" id="L635">                            FeatureComparisonStat fcs2 = stats2.get(i);</span>
<span class="fc" id="L636">                            PairInt p1 = fcs2.getImg1Point();</span>
<span class="fc" id="L637">                            PairInt p2 = fcs2.getImg2Point();</span>

<span class="fc" id="L639">                            boolean add = true;</span>
<span class="fc" id="L640">                            int rmIdx = -1;</span>

<span class="fc bfc" id="L642" title="All 2 branches covered.">                            for (int j = 0; j &lt; bestStatsLg.size(); ++j) {</span>

<span class="fc" id="L644">                                FeatureComparisonStat fcsb = bestStatsLg.get(j);</span>
<span class="fc" id="L645">                                PairInt s1 = fcsb.getImg1Point();</span>
<span class="fc" id="L646">                                PairInt s2 = fcsb.getImg2Point();</span>

<span class="pc bpc" id="L648" title="1 of 2 branches missed.">                                if (p1.equals(s1)) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">                                    if (!p2.equals(s2)) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">                                        if (fcs2.getSumIntensitySqDiff() &lt; fcsb.getSumIntensitySqDiff()) {</span>
<span class="nc" id="L651">                                            rmIdx = j;</span>
<span class="nc" id="L652">                                            break;</span>
                                        }
                                    }
<span class="nc" id="L655">                                    add = false;</span>
<span class="nc" id="L656">                                    break;</span>
                                }
                            }
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                            if (rmIdx &gt; -1) {</span>
<span class="nc" id="L660">                                bestStatsLg.remove(rmIdx);</span>
                            }
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">                            if (!add) {</span>
<span class="nc" id="L663">                                stats2.remove(i);</span>
                            }
                        }

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">                        if (stats2.size() &gt; 0) {</span>

<span class="fc" id="L669">                            bestStatsLg.addAll(stats2);</span>

<span class="fc" id="L671">                            bestParamsLg = MiscStats.calculateTransformation(binFactor1, </span>
                                binFactor2, bestStatsLg, new float[4]);
                        }
                    }
                
<span class="pc bpc" id="L676" title="3 of 4 branches missed.">                    if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">                        for (int i = 0; i &lt; bestStatsLg.size(); ++i) {</span>
<span class="fc" id="L678">                            FeatureComparisonStat stat = bestStatsLg.get(i);</span>
<span class="fc" id="L679">                            stat.setBinFactor1(binFactor1);</span>
<span class="fc" id="L680">                            stat.setBinFactor2(binFactor2);</span>
                        }
                    }
                    
<span class="fc" id="L684">                    MatchingSolution soln = new MatchingSolution(bestParamsLg, bestStatsLg);</span>
<span class="fc" id="L685">                    return soln;</span>
                }
            }                        
        }

<span class="pc bpc" id="L690" title="1 of 2 branches missed.">        if (bestParams != null) {</span>

<span class="pc bpc" id="L692" title="1 of 4 branches missed.">            if (binFactor1 != 1 || binFactor2 != 1) {</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">                for (int i = 0; i &lt; bestStats.size(); ++i) {</span>
<span class="fc" id="L694">                    FeatureComparisonStat stat = bestStats.get(i);</span>
<span class="fc" id="L695">                    stat.setBinFactor1(binFactor1);</span>
<span class="fc" id="L696">                    stat.setBinFactor2(binFactor2);</span>
                }
            }

<span class="fc" id="L700">            MatchingSolution soln = new MatchingSolution(bestParams, bestStats);</span>
<span class="fc" id="L701">            return soln;</span>
        }

<span class="nc" id="L704">        return null;</span>
    }

    protected void filterCorners(PairIntArray curve,
        List&lt;CornerRegion&gt; regions, float dist) {

        /*
        if there are more than 1 corner within dist of 2 or so of on another,
        remove all except strongest corner.
        */
<span class="fc" id="L714">        List&lt;Set&lt;Integer&gt;&gt; closeCornerIndexes = findCloseCorners(dist, regions);</span>

<span class="fc bfc" id="L716" title="All 2 branches covered.">        if (closeCornerIndexes.isEmpty()) {</span>
<span class="fc" id="L717">            return;</span>
        }

<span class="fc" id="L720">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        for (Set&lt;Integer&gt; set : closeCornerIndexes) {</span>
<span class="fc" id="L722">            float maxK = Float.MIN_VALUE;</span>
<span class="fc" id="L723">            Integer maxKIndex = null;</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">            for (Integer index : set) {</span>
<span class="fc" id="L725">                CornerRegion cr = regions.get(index.intValue());</span>
<span class="fc" id="L726">                float k = cr.getK()[cr.getKMaxIdx()];</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                if (k &gt; maxK) {</span>
<span class="fc" id="L728">                    maxK = k;</span>
<span class="fc" id="L729">                    maxKIndex = index;</span>
                }
<span class="fc" id="L731">            }</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            for (Integer index : set) {</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">                if (!index.equals(maxKIndex)) {</span>
<span class="fc" id="L734">                    remove.add(index);</span>
                }
<span class="fc" id="L736">            }</span>
<span class="fc" id="L737">        }</span>

<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (remove.size() &gt; 1) {</span>
<span class="fc" id="L740">            Collections.sort(remove);</span>
        }
<span class="fc bfc" id="L742" title="All 2 branches covered.">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L743">            regions.remove(remove.get(i).intValue());</span>
        }
<span class="fc" id="L745">    }</span>

    private static List&lt;Set&lt;Integer&gt;&gt; findCloseCorners(float tolD,
        List&lt;CornerRegion&gt; regions) {

<span class="fc" id="L750">        float[] x = new float[regions.size()];</span>
<span class="fc" id="L751">        float[] y = new float[regions.size()];</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">        for (int i = 0; i &lt; regions.size(); ++i) {</span>
<span class="fc" id="L753">            CornerRegion cr = regions.get(i);</span>
<span class="fc" id="L754">            x[i] = cr.getX()[cr.getKMaxIdx()];</span>
<span class="fc" id="L755">            y[i] = cr.getY()[cr.getKMaxIdx()];</span>
        }

<span class="fc" id="L758">        List&lt;Set&lt;Integer&gt;&gt; close = new ArrayList&lt;Set&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L760">        FixedDistanceGroupFinder groupFinder = new FixedDistanceGroupFinder(x, y);</span>

<span class="fc" id="L762">        groupFinder.findGroupsOfPoints(tolD);</span>

<span class="fc" id="L764">        int nGroups = groupFinder.getNumberOfGroups();</span>

<span class="fc bfc" id="L766" title="All 2 branches covered.">        for (int i = 0; i &lt; nGroups; ++i) {</span>
<span class="fc" id="L767">            Set&lt;Integer&gt; group = groupFinder.getGroupIndexes(i);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (group.size() &gt; 1) {</span>
<span class="fc" id="L769">                close.add(group);</span>
            }
        }

<span class="fc" id="L773">        return close;</span>
    }

    private double distance(double x1, double y1, double x2, double y2) {

<span class="fc" id="L778">        double diffX = x1 - x2;</span>
<span class="fc" id="L779">        double diffY = y1 - y2;</span>

<span class="fc" id="L781">        double dist = Math.sqrt(diffX * diffX + diffY * diffY);</span>

<span class="fc" id="L783">        return dist;</span>
    }

    private void sortCornersToCCW(List&lt;CornerRegion&gt; corners) {

<span class="fc" id="L788">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="fc" id="L789">        PairIntArray cornerXY = new PairIntArray();</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">        for (int ii = 0; ii &lt; corners.size(); ++ii) {</span>
<span class="fc" id="L791">            CornerRegion cr = corners.get(ii);</span>
<span class="fc" id="L792">            cornerXY.add(cr.getX()[cr.getKMaxIdx()], cr.getY()[cr.getKMaxIdx()]);</span>
        }
<span class="fc" id="L794">        boolean isCW = curveHelper.curveIsOrderedClockwise(cornerXY);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (isCW) {</span>
<span class="fc" id="L796">            int n = corners.size();</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">            if (n &gt; 1) {</span>
<span class="fc" id="L798">                int end = n &gt;&gt; 1;</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">                for (int ii = 0; ii &lt; end; ii++) {</span>
<span class="fc" id="L800">                    int idx2 = n - ii - 1;</span>
<span class="fc" id="L801">                    CornerRegion swap = corners.get(ii);</span>
<span class="fc" id="L802">                    corners.set(ii, corners.get(idx2));</span>
<span class="fc" id="L803">                    corners.set(idx2, swap);</span>
                }
            }
        }
<span class="fc" id="L807">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
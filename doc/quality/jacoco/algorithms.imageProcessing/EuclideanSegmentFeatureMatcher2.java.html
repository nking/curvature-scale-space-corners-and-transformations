<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EuclideanSegmentFeatureMatcher2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">EuclideanSegmentFeatureMatcher2.java</span></div><h1>EuclideanSegmentFeatureMatcher2.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.compGeometry.RotatedOffsets;
import algorithms.imageProcessing.util.MiscStats;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 class whose goal is to find best single euclidean transformation for 
 image1 to image2.  It uses segmentation to create blobs.
 The &quot;points of interest&quot; are either made from the blob perimeters or
 from 2nd derivatives of gaussian convolution with greyscale image.
 It matches the points from image1 against points from image 2
 using features and those with a close 2nd best SSD match are discarded.
 The points are then associated with the enclosing blobs and
 then combinations of the blobs are made to create euclidean transformations.
 The transformations are evaluated against all points.
 (Note if that is successful, will try to evaluate against only the
 matched points which are fewer in number and will change class to use that
 logic if tests pass).
 
 The checkerboard tests do not match well with this one because the points are
 not unique enough, but EuclideanSegmentFeatureMatcher does solve it.
 SO, when this method returns very few or no matched points, the invoker
 should then follow with EuclideanSegmentFeatureMatcher.
 
 * @author nichole
 */
<span class="pc bpc" id="L36" title="1 of 2 branches missed.">public class EuclideanSegmentFeatureMatcher2 extends AbstractFeatureMatcher {</span>

<span class="fc" id="L38">    protected TransformationParameters solutionTransformation = null;</span>
    
    public EuclideanSegmentFeatureMatcher2(ImageExt image1, ImageExt image2,
        FeatureMatcherSettings settings) {
        
<span class="fc" id="L43">          super(image1, image2, settings);</span>
<span class="fc" id="L44">    }</span>

    @Override
    protected boolean match(SegmentationType type, boolean useBinned) {
        
        int binFactor1, binFactor2;
        GreyscaleImage img1, img2;
        IntensityFeatures f1, f2;
        
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (useBinned) {</span>
<span class="fc" id="L54">            binFactor1 = img1Helper.getBinFactor(useBinned);</span>
<span class="fc" id="L55">            binFactor2 = img2Helper.getBinFactor(useBinned);</span>
<span class="fc" id="L56">            img1 = img1Helper.getGreyscaleImageBinned();</span>
<span class="fc" id="L57">            img2 = img2Helper.getGreyscaleImageBinned();</span>
<span class="fc" id="L58">            f1 = featuresBinned1;</span>
<span class="fc" id="L59">            f2 = featuresBinned2;</span>
        } else {
<span class="nc" id="L61">            binFactor1 = 1;</span>
<span class="nc" id="L62">            binFactor2 = 1;</span>
<span class="nc" id="L63">            img1 = img1Helper.getGreyscaleImage();</span>
<span class="nc" id="L64">            img2 = img2Helper.getGreyscaleImage();</span>
<span class="nc" id="L65">            f1 = features1;</span>
<span class="nc" id="L66">            f2 = features2;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">            if (!f1.gradientWasCreated()) {</span>
<span class="nc" id="L68">                f1.calculateGradientWithGreyscale(</span>
<span class="nc" id="L69">                    img1Helper.getGreyscaleImage().copyImage());</span>
            }
<span class="nc bnc" id="L71" title="All 2 branches missed.">            if (!f2.gradientWasCreated()) {</span>
<span class="nc" id="L72">                f2.calculateGradientWithGreyscale(</span>
<span class="nc" id="L73">                    img2Helper.getGreyscaleImage().copyImage());</span>
            }
        }
        
<span class="fc" id="L77">        List&lt;List&lt;CornerRegion&gt;&gt; corners1List = img1Helper.getPerimeterCorners(</span>
            type, useBinned);
        
<span class="fc" id="L80">        List&lt;List&lt;CornerRegion&gt;&gt; corners2List = img2Helper.getPerimeterCorners(</span>
            type, useBinned);
                 
<span class="fc" id="L83">        int dither = 1;        </span>
        
<span class="fc" id="L85">        List&lt;CornerRegion&gt; corners1 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc" id="L86">        List&lt;CornerRegion&gt; corners2 = new ArrayList&lt;CornerRegion&gt;();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        for (int i = 0; i &lt; corners1List.size(); ++i) {</span>
<span class="fc" id="L88">            corners1.addAll(corners1List.get(i));</span>
        }
<span class="fc bfc" id="L90" title="All 2 branches covered.">        for (int i = 0; i &lt; corners2List.size(); ++i) {</span>
<span class="fc" id="L91">            corners2.addAll(corners2List.get(i));</span>
        }

<span class="fc" id="L94">        CornerMatcher&lt;CornerRegion&gt; matcher = new CornerMatcher&lt;CornerRegion&gt;(dither);</span>

<span class="fc" id="L96">        boolean matched = matcher.matchCorners(f1, f2, corners1, corners2, </span>
            img1, img2, binFactor1, binFactor2);

<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (!matched) {</span>
<span class="nc" id="L100">            return false;</span>
        }
        
        /*MiscDebug.writeImagesInAlternatingColor(img1.copyToColorGreyscaleExt(), 
            img2.copyToColorGreyscaleExt(), matcher.getSolutionStats(), 
            &quot;_matched_non_euclid_&quot; + MiscDebug.getCurrentTimeFormatted(), 2);
        */
        
<span class="fc" id="L108">        List&lt;FeatureComparisonStat&gt; stats = new ArrayList&lt;FeatureComparisonStat&gt;(); </span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (FeatureComparisonStat stat :  matcher.getSolutionStats()) {</span>
<span class="fc" id="L110">            stats.add(stat.copy());</span>
<span class="fc" id="L111">        }</span>
        
<span class="fc" id="L113">        matcher = null;</span>
        
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (stats.isEmpty()) {</span>
<span class="nc" id="L116">            return false;</span>
        }
        
        /*
        matched1 and matched2 are both associated with blobs.
        
        key = index1, index2
        value = all matches for those 2 blobs
        
        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; 
        */
        
<span class="fc" id="L128">        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; index1Index2Matches </span>
<span class="fc" id="L129">            = associateMatchesWithBlobs(stats, </span>
<span class="fc" id="L130">            img1Helper.getBlobs(type, useBinned),</span>
<span class="fc" id="L131">            img2Helper.getBlobs(type, useBinned));</span>
        
<span class="fc" id="L133">        filterForLocalization(img1Helper.getGreyscaleImage(useBinned),</span>
<span class="fc" id="L134">            img2Helper.getGreyscaleImage(useBinned), f1, f2,</span>
            index1Index2Matches);
        /*
        if (true) {
            GreyscaleImage im1 = img1Helper.getGreyscaleImage(useBinned);
            GreyscaleImage im2 = img2Helper.getGreyscaleImage(useBinned);
            List&lt;FeatureComparisonStat&gt; blobAssoc = new ArrayList&lt;FeatureComparisonStat&gt;();
            for (java.util.Map.Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : index1Index2Matches.entrySet()) {
                blobAssoc.addAll(entry.getValue());
            }
            MiscDebug.writeImagesInAlternatingColor(img1.copyToColorGreyscaleExt(), 
                img2.copyToColorGreyscaleExt(), blobAssoc, 
                &quot;_matched_assoc_blobs_&quot; + MiscDebug.getCurrentTimeFormatted(), 2);
            log.info(index1Index2Matches.size() + &quot; blob pairs to match from&quot;);
            log.info(blobAssoc.size() + &quot; matched points associated w/ blobs&quot;);
        }*/
                
<span class="fc" id="L151">        BlobCornersEuclideanCalculator2 calculator = </span>
            new BlobCornersEuclideanCalculator2();
        
<span class="fc" id="L154">        MatchingSolution soln = calculator.solveTransformation(</span>
<span class="fc" id="L155">            img1Helper.getGreyscaleImage(useBinned),</span>
<span class="fc" id="L156">            img2Helper.getGreyscaleImage(useBinned),</span>
            f1, f2, dither, index1Index2Matches,
            corners1, corners2, binFactor1, binFactor2);
        
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (soln == null) {</span>
<span class="nc" id="L161">            return false;</span>
        }
        
<span class="fc" id="L164">        log.info(soln.getParams().toString());</span>
            
        // transform images to full size
<span class="fc" id="L167">        soln = transformSolutionToFullFrames(soln, img1Helper, img2Helper, </span>
            binFactor1, binFactor2);

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (soln == null) {</span>
<span class="nc" id="L171">            return false;</span>
        }
            
<span class="fc" id="L174">        log.info(&quot;full frame soln: &quot; + soln.getParams().toString());</span>
        
<span class="fc" id="L176">        copyToInstanceVars(soln.getComparisonStats());</span>
        
<span class="fc" id="L178">        solutionTransformation = soln.getParams().copy();</span>
                
<span class="fc" id="L180">        return true;</span>
    }
    
    private MatchingSolution transformSolutionToFullFrames(MatchingSolution 
        soln, BlobPerimeterCornerHelper img1Helper, 
        BlobPerimeterCornerHelper img2Helper, int binFactor1, int binFactor2) {
        
<span class="pc bpc" id="L187" title="3 of 4 branches missed.">        if (binFactor1 == 1 &amp;&amp; binFactor2 == 1) {</span>
<span class="nc" id="L188">            return soln;</span>
        }
       
<span class="fc" id="L191">        RotatedOffsets rotatedOffsets = RotatedOffsets.getInstance();</span>
        
<span class="pc bpc" id="L193" title="3 of 4 branches missed.">        assert(rotatedOffsets.containsData());</span>
        
<span class="fc" id="L195">        List&lt;FeatureComparisonStat&gt; stats = soln.getComparisonStats();</span>
        
<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
<span class="fc" id="L198">            FeatureComparisonStat stat = stats.get(i);</span>
<span class="fc" id="L199">            stat.setBinFactor1(binFactor1);</span>
<span class="fc" id="L200">            stat.setBinFactor2(binFactor2);</span>
        }
        
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            GreyscaleImage im1 = (binFactor1 != 1) ? </span>
<span class="pc" id="L205">                img1Helper.getGreyscaleImageBinned() :</span>
<span class="pc" id="L206">                img1Helper.getGreyscaleImage();</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            GreyscaleImage im2 = (binFactor2 != 1) ? </span>
<span class="pc" id="L208">                img2Helper.getGreyscaleImageBinned() :</span>
<span class="pc" id="L209">                img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L210">            MiscDebug.writeImages(im1, im2, stats, </span>
<span class="fc" id="L211">                &quot;_matched_binned_&quot; + settings.getDebugTag() </span>
<span class="fc" id="L212">                + MiscDebug.getCurrentTimeFormatted(), 1);</span>
        }
        
<span class="fc" id="L215">        FeatureMatcher matcher = new FeatureMatcher();</span>
        
<span class="fc" id="L217">        List&lt;FeatureComparisonStat&gt; fullStats = matcher.reviseStatsForFullImages(</span>
<span class="fc" id="L218">            img1Helper.getGreyscaleImage(),</span>
<span class="fc" id="L219">            img2Helper.getGreyscaleImage(),</span>
            settings,
<span class="fc" id="L221">            soln.getParams(), soln.getComparisonStats(),</span>
            binFactor1, binFactor2, rotatedOffsets);
            
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">        if ((fullStats == null) || fullStats.isEmpty()) {</span>
<span class="nc" id="L225">            return null;</span>
        }
        
<span class="fc" id="L228">        TransformationParameters revisedParams = </span>
<span class="fc" id="L229">            MiscStats.calculateTransformation(1, 1, fullStats,</span>
                new float[4], false);
        
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (revisedParams == null) {</span>
<span class="nc" id="L233">            return null;</span>
        }
        
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (settings.debug()) {</span>
<span class="fc" id="L237">            GreyscaleImage im1 = img1Helper.getGreyscaleImage();</span>
<span class="fc" id="L238">            GreyscaleImage im2 = img2Helper.getGreyscaleImage();</span>
<span class="fc" id="L239">            MiscDebug.writeImages(im1, im2, fullStats, </span>
<span class="fc" id="L240">                &quot;_matched_&quot; + settings.getDebugTag() +</span>
<span class="fc" id="L241">                MiscDebug.getCurrentTimeFormatted(), 2);</span>
        }
        
<span class="fc" id="L244">        MatchingSolution fullSoln = new MatchingSolution(revisedParams, </span>
            fullStats, 1, 1);
        
<span class="fc" id="L247">        return fullSoln;</span>
    }

    public TransformationParameters getSolutionTransformationParameters() {
<span class="fc" id="L251">        return solutionTransformation;</span>
    }

    private Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; associateMatchesWithBlobs(
        List&lt;FeatureComparisonStat&gt; stats, List&lt;Set&lt;PairInt&gt;&gt; blobs1, 
        List&lt;Set&lt;PairInt&gt;&gt; blobs2) {
        
        /*
        to make the lookups for stats points O(1), could make a large map for each
        blobs collection w/ key = coord and value= list index.  iterating over
        all blob points is nBlobs * avgBlobSize * 2 where 2 is once for image1,
        and then image2.
        
        if there are 100 stats and blobs1 size = blobs2 = 50,
        then finding indexes for all stats is at most 100*50 + 100*50 = 10,000
        
        if make large map, and if each blob has n points,
          50*n*2 + 100*2  is number of lookups, so it's only a better runtime if
        avg size of blobs is &lt; 100 for this example.
        */
        
<span class="fc" id="L272">        Map&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; matchedBlobs = </span>
            new HashMap&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt;();

<span class="fc bfc" id="L275" title="All 2 branches covered.">        for (int i = 0; i &lt; stats.size(); ++i) {</span>
            
<span class="fc" id="L277">            FeatureComparisonStat stat = stats.get(i);</span>
            
<span class="fc" id="L279">            PairInt p1 = stat.getImg1Point();</span>
<span class="fc" id="L280">            PairInt p2 = stat.getImg2Point();</span>
            
<span class="fc" id="L282">            PairInt indexes = new PairInt(0, 0);</span>
            
<span class="fc" id="L284">            boolean found = false;</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            for (int j = 0; j &lt; blobs1.size(); ++j) {</span>
<span class="fc" id="L286">                Set&lt;PairInt&gt; blob = blobs1.get(j);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                if (blob.contains(p1)) {</span>
<span class="fc" id="L288">                    indexes.setX(j);</span>
<span class="fc" id="L289">                    found = true;</span>
<span class="fc" id="L290">                    break;</span>
                }
            }
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L294">                continue;</span>
            }
<span class="fc" id="L296">            found = false;</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            for (int j = 0; j &lt; blobs2.size(); ++j) {</span>
<span class="fc" id="L298">                Set&lt;PairInt&gt; blob = blobs2.get(j);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                if (blob.contains(p2)) {</span>
<span class="fc" id="L300">                    indexes.setY(j);</span>
<span class="fc" id="L301">                    found = true;</span>
<span class="fc" id="L302">                    break;</span>
                }
            }
            
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L307">                continue;</span>
            }
            
<span class="fc" id="L310">            List&lt;FeatureComparisonStat&gt; list = matchedBlobs.get(indexes);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L312">                list = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
<span class="fc" id="L313">                matchedBlobs.put(indexes, list);</span>
            }
<span class="fc" id="L315">            list.add(stat);</span>
        }
        
<span class="fc" id="L318">        return matchedBlobs;</span>
    }

    private void filterForLocalization(GreyscaleImage img1, 
        GreyscaleImage img2, IntensityFeatures features1, 
        IntensityFeatures features2, Map&lt;PairInt, 
            List&lt;FeatureComparisonStat&gt;&gt; index1Index2Matches) {
        
<span class="fc" id="L326">        Set&lt;PairInt&gt; remove = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L328" title="All 2 branches covered.">        for (Entry&lt;PairInt, List&lt;FeatureComparisonStat&gt;&gt; entry : index1Index2Matches.entrySet()) {</span>
<span class="fc" id="L329">            List&lt;FeatureComparisonStat&gt; stats = entry.getValue();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">            for (int i = (stats.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L331">                FeatureComparisonStat stat = stats.get(i);</span>
<span class="fc" id="L332">                PairInt p1 = stat.getImg1Point();</span>
                try {
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    if (features1.removeDueToLocalization(img1, p1.getX(), p1.getY(),</span>
<span class="fc" id="L335">                        features1.calculateOrientation(p1.getX(), p1.getY()))) {</span>
<span class="fc" id="L336">                        stats.remove(i);</span>
<span class="fc" id="L337">                        continue;</span>
                    }
<span class="fc" id="L339">                    PairInt p2 = stat.getImg2Point();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                    if (features2.removeDueToLocalization(img2, p2.getX(), p2.getY(),</span>
<span class="fc" id="L341">                        features2.calculateOrientation(p2.getX(), p2.getY()))) {</span>
<span class="fc" id="L342">                        stats.remove(i);</span>
<span class="fc" id="L343">                        continue;</span>
                    }
<span class="nc" id="L345">                } catch (CornerRegion.CornerRegionDegneracyException ex) {</span>
<span class="fc" id="L346">                }</span>
            }
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (stats.isEmpty()) {</span>
<span class="fc" id="L349">                remove.add(entry.getKey());</span>
            }
<span class="fc" id="L351">        }</span>
        
<span class="fc bfc" id="L353" title="All 2 branches covered.">        for (PairInt key : remove) {</span>
<span class="fc" id="L354">            index1Index2Matches.remove(key);</span>
<span class="fc" id="L355">        }</span>
<span class="fc" id="L356">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
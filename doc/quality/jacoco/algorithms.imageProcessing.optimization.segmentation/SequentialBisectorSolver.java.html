<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SequentialBisectorSolver.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.optimization.segmentation</a> &gt; <span class="el_source">SequentialBisectorSolver.java</span></div><h1>SequentialBisectorSolver.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.optimization.segmentation;

import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.ImageIOHelper;
import algorithms.imageProcessing.ImageSegmentation;
import algorithms.misc.MiscDebug;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import algorithms.util.ResourceFinder;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * given training datasets, finds the best combination of
 * the 4 parameters of a segmentation algorithm using
 * a pattern of bisecting each parameter's range space sequentially until 
 * the solution converges.
 * It assumes the there is one global solution and no local minima.
 * 
 * @author nichole
 */
public class SequentialBisectorSolver {
        
    //private final Parameter tLen = new Parameter(1, 40, 5);
<span class="nc" id="L30">    private final Parameter tLen = new Parameter(1, 10, 2);</span>
    
    private final Parameter tColor;
    
    //private final Parameter tR = new Parameter(0.5f * 3.0f, 
    //    1.05f * 3.0f, 0.125f);
<span class="nc" id="L36">    private final Parameter tR = new Parameter(1.0f, </span>
        2.5f, 0.125f);
    
    //private final Parameter tSmallMerge = new Parameter(
    //    0.005f, 0.1f, 0.01f);
<span class="nc" id="L41">    private final Parameter tSmallMerge = new Parameter(</span>
        0.01f, 0.1f, 0.01f);
    
<span class="nc" id="L44">    private double difference = Double.MAX_VALUE;</span>
    
    private final int colorSpace;
    
    private final boolean reduceNoise;
    
    private SData[] trainingData;
    
<span class="nc" id="L52">    private FileWriter writer = null;</span>
    
    public SequentialBisectorSolver(boolean useHSV, boolean useLowNoiseEdges,
<span class="nc" id="L55">        SData[] trainingData) throws IOException {</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">        colorSpace = useHSV ? 1 : 0;</span>
<span class="nc" id="L57">        reduceNoise = useLowNoiseEdges;</span>
<span class="nc" id="L58">        this.trainingData = trainingData;</span>
        
<span class="nc bnc" id="L60" title="All 2 branches missed.">        if (useHSV) {</span>
<span class="nc" id="L61">            tColor = new Parameter(0.1f, 0.2f, 0.05f);</span>
        } else {
<span class="nc" id="L63">            tColor = new Parameter(2.5f, 6.f, 0.25f);</span>
        }
        
<span class="nc" id="L66">        String dir = ResourceFinder.findOutputTestDirectory();</span>
<span class="nc" id="L67">        writer = new FileWriter(dir + &quot;/opt_log.txt&quot;);</span>
<span class="nc" id="L68">    }</span>
    
    /*
    4 params:                    range of values
          int tLen,                   trying as an integer, but might need to use 1 to 0.1*nPixels.  try: 1 to 100   d=10, n=10
          double tColor,              for clrSpace=0   2.3 to 9   (2.5 to 5.5 is more reasonable)                    d=0.5, n=13
                                      for clrSpace=1   0.1 to 0.7                                                    d=0.05, n=12
          double tR,                  for clrSpace=0   0.5*3.0 to 0.95*3.0                                           d=0.5*3, n=18
                                      for clrSpace=1   0.5*3.0 to 0.95*3.0                                           d=0.5*3, n=18
          double tSmallMerge,         0.01 to 0.1                                                                    d=0.01, n=10

       *solve for using clrSpace = 0 then =1

       *solve for this as true and false:
          boolean reduceNoise,
    */
    
    /**
     * 
     * @throws IOException exceptions are thrown for errors in finding or
     * reading the training file data.
     */
    public double solve() throws IOException, Exception {
        
<span class="nc" id="L92">        Parameter[] parameters = new Parameter[]{</span>
            tLen, tColor, tR, tSmallMerge};
        
<span class="nc" id="L95">        int np = 1 &lt;&lt; parameters.length;</span>
          
<span class="nc" id="L97">        SegmentationResults[] expected = readTrainingFiles();</span>
        
<span class="nc" id="L99">        List&lt;List&lt;PairIntArray&gt;&gt; edgesList = extractEdges();</span>
        
<span class="nc" id="L101">        double lastDifference = Double.MAX_VALUE;</span>

<span class="nc" id="L103">        int nIter = 0;</span>
        
        // one high and one low eval for each param
        // in combination
        // 4 params each of two possible states:
        //   2^4 combinations = 16
<span class="nc" id="L109">        int nComb = 16;</span>
<span class="nc" id="L110">        int[][] tIdxs = new int[nComb][];</span>
<span class="nc" id="L111">        int[][] lowIdxs = new int[nComb][];</span>
<span class="nc" id="L112">        int[][] highIdxs = new int[nComb][];</span>
<span class="nc" id="L113">        int[][] loc = new int[nComb][];</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for (int i = 0; i &lt; nComb; ++i) {</span>
<span class="nc" id="L115">            tIdxs[i] = new int[4];</span>
<span class="nc" id="L116">            lowIdxs[i] = new int[4];</span>
<span class="nc" id="L117">            highIdxs[i] = new int[4];</span>
<span class="nc" id="L118">            loc[i] = new int[4];</span>
        }
        
        while (true) {
            
            //if ((nIter % 10) == 0) {
<span class="nc" id="L124">               print(parameters);</span>
            //}

<span class="nc" id="L127">            double minDiff = Double.MAX_VALUE;</span>
<span class="nc" id="L128">            int minDiffIdx = -1;</span>
            
<span class="nc" id="L130">            int count = 0;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            for (int p0 = 0; p0 &lt; 2; ++p0) {</span>
<span class="nc" id="L132">                int lowIdx0 = parameters[0].lowIdx;</span>
<span class="nc" id="L133">                int highIdx0 = parameters[0].highIdx;</span>
<span class="nc" id="L134">                int midIdx0 = (highIdx0 + lowIdx0) &gt;&gt; 1;</span>
                int tIdx0;
<span class="nc bnc" id="L136" title="All 2 branches missed.">                if (p0 == 0) {</span>
<span class="nc" id="L137">                    tIdx0 = (midIdx0 + lowIdx0) &gt;&gt; 1;</span>
                } else {
<span class="nc" id="L139">                    tIdx0 = (midIdx0 + highIdx0) &gt;&gt; 1;</span>
                }
<span class="nc bnc" id="L141" title="All 2 branches missed.">                for (int p1 = 0; p1 &lt; 2; ++p1) {</span>
<span class="nc" id="L142">                    int lowIdx1 = parameters[1].lowIdx;</span>
<span class="nc" id="L143">                    int highIdx1 = parameters[1].highIdx;</span>
<span class="nc" id="L144">                    int midIdx1 = (highIdx1 + lowIdx1) &gt;&gt; 1;</span>
                    int tIdx1;
<span class="nc bnc" id="L146" title="All 2 branches missed.">                    if (p1 == 0) {</span>
<span class="nc" id="L147">                        tIdx1 = (midIdx1 + lowIdx1) &gt;&gt; 1;</span>
                    } else {
<span class="nc" id="L149">                        tIdx1 = (midIdx1 + highIdx1) &gt;&gt; 1;</span>
                    }
<span class="nc bnc" id="L151" title="All 2 branches missed.">                    for (int p2 = 0; p2 &lt; 2; ++p2) {</span>
<span class="nc" id="L152">                        int lowIdx2 = parameters[2].lowIdx;</span>
<span class="nc" id="L153">                        int highIdx2 = parameters[2].highIdx;</span>
<span class="nc" id="L154">                        int midIdx2 = (highIdx2 + lowIdx2) &gt;&gt; 1;</span>
                        int tIdx2;
<span class="nc bnc" id="L156" title="All 2 branches missed.">                        if (p2 == 0) {</span>
<span class="nc" id="L157">                            tIdx2 = (midIdx2 + lowIdx2) &gt;&gt; 1;</span>
                        } else {
<span class="nc" id="L159">                            tIdx2 = (midIdx2 + highIdx2) &gt;&gt; 1;</span>
                        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">                        for (int p3 = 0; p3 &lt; 2; ++p3) {</span>
<span class="nc" id="L162">                            int lowIdx3 = parameters[3].lowIdx;</span>
<span class="nc" id="L163">                            int highIdx3 = parameters[3].highIdx;</span>
<span class="nc" id="L164">                            int midIdx3 = (highIdx3 + lowIdx3) &gt;&gt; 1;</span>
                            int tIdx3;
<span class="nc bnc" id="L166" title="All 2 branches missed.">                            if (p3 == 0) {</span>
<span class="nc" id="L167">                                tIdx3 = (midIdx3 + lowIdx3) &gt;&gt; 1;</span>
                            } else {
<span class="nc" id="L169">                                tIdx3 = (midIdx3 + highIdx3) &gt;&gt; 1;</span>
                            }
                          
<span class="nc" id="L172">                            lowIdxs[count][0] = lowIdx0; </span>
<span class="nc" id="L173">                            highIdxs[count][0] = highIdx0;</span>
<span class="nc" id="L174">                            tIdxs[count][0] = tIdx0;</span>
<span class="nc" id="L175">                            loc[count][0] = p0;</span>
                            
<span class="nc" id="L177">                            lowIdxs[count][1] = lowIdx1; </span>
<span class="nc" id="L178">                            highIdxs[count][1] = highIdx1;</span>
<span class="nc" id="L179">                            tIdxs[count][1] = tIdx1;</span>
<span class="nc" id="L180">                            loc[count][1] = p1;</span>
                            
<span class="nc" id="L182">                            lowIdxs[count][2] = lowIdx2; </span>
<span class="nc" id="L183">                            highIdxs[count][2] = highIdx2;</span>
<span class="nc" id="L184">                            tIdxs[count][2] = tIdx2;</span>
<span class="nc" id="L185">                            loc[count][2] = p2;</span>
                            
<span class="nc" id="L187">                            lowIdxs[count][3] = lowIdx3; </span>
<span class="nc" id="L188">                            highIdxs[count][3] = highIdx3;</span>
<span class="nc" id="L189">                            tIdxs[count][3] = tIdx3;</span>
<span class="nc" id="L190">                            loc[count][3] = p3;</span>
                            
<span class="nc" id="L192">                            ++count;</span>
                        }
                    }
                }
            }

<span class="nc bnc" id="L198" title="All 2 branches missed.">            for (int i = 0; i &lt; nComb; ++i) {</span>
<span class="nc" id="L199">               System.out.println(&quot;i=&quot; + i);            </span>
<span class="nc" id="L200">               double diff = invoke(</span>
<span class="nc" id="L201">                    parameters[0].getValue(tIdxs[i][0]),</span>
<span class="nc" id="L202">                    parameters[1].getValue(tIdxs[i][1]),</span>
<span class="nc" id="L203">                    parameters[2].getValue(tIdxs[i][2]),</span>
<span class="nc" id="L204">                    parameters[3].getValue(tIdxs[i][3]),</span>
                    expected, edgesList);
               
<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (diff &lt; minDiff) {</span>
<span class="nc" id="L208">                    minDiff = diff;</span>
<span class="nc" id="L209">                    minDiffIdx = i;</span>
                }
            }
            
<span class="nc bnc" id="L213" title="All 2 branches missed.">            for (int pIdx = 0; pIdx &lt; parameters.length; ++pIdx) {</span>
<span class="nc" id="L214">                int lowIdx = parameters[pIdx].lowIdx;</span>
<span class="nc" id="L215">                int highIdx = parameters[pIdx].highIdx;</span>
<span class="nc" id="L216">                int midIdx = (highIdx + lowIdx) &gt;&gt; 1;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                if (loc[minDiffIdx][pIdx] == 0) {</span>
<span class="nc" id="L218">                    int tIdx = (midIdx + lowIdx) &gt;&gt; 1;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                    if (minDiff == 0) {</span>
<span class="nc" id="L220">                        lowIdx = tIdx;</span>
<span class="nc" id="L221">                        highIdx = tIdx;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                    } else if (highIdx == tIdx) {</span>
<span class="nc" id="L223">                        highIdx--;</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                        if (highIdx &lt; lowIdx) {</span>
<span class="nc" id="L225">                            highIdx = lowIdx;</span>
                        }
                    } else {
<span class="nc" id="L228">                        highIdx = tIdx;</span>
                    }
<span class="nc" id="L230">                } else {</span>
<span class="nc" id="L231">                    int tIdx = (midIdx + highIdx) &gt;&gt; 1;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                    if (minDiff == 0) {</span>
<span class="nc" id="L233">                        lowIdx = tIdx;</span>
<span class="nc" id="L234">                        highIdx = tIdx;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                    } else if (lowIdx == tIdx) {</span>
<span class="nc" id="L236">                        lowIdx++;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                        if (lowIdx &gt; highIdx) {</span>
<span class="nc" id="L238">                            lowIdx = highIdx;</span>
                        }
                    } else {
<span class="nc" id="L241">                        lowIdx = tIdx;</span>
                    }
                }
<span class="nc" id="L244">                parameters[pIdx].lowIdx = lowIdx;</span>
<span class="nc" id="L245">                parameters[pIdx].highIdx = highIdx;</span>
            }

<span class="nc" id="L248">            lastDifference = minDiff;</span>
            
            if (true) {
<span class="nc" id="L251">                debugImages(parameters, edgesList);</span>
            }
        
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (minDiff == 0) {</span>
<span class="nc" id="L255">                break;</span>
            }                              
            // check for convergence
<span class="nc" id="L258">            boolean hasConverged = true;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            for (int pIdx = 0; pIdx &lt; parameters.length; ++pIdx) {</span>
                //if (parameters[pIdx].lowIdx != parameters[pIdx].highIdx) {
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if (parameters[pIdx].lowIdx &lt; parameters[pIdx].highIdx) {</span>
<span class="nc" id="L262">                    hasConverged = false;</span>
<span class="nc" id="L263">                    break;</span>
                }
            }

<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (hasConverged) {</span>
<span class="nc" id="L268">                break;</span>
            }

<span class="nc" id="L271">            nIter++;</span>
<span class="nc" id="L272">        }</span>
        
<span class="nc" id="L274">        return lastDifference;</span>
    }

    private double[] invoke(int pIdx, int tIdx1, int tIdx2,
        Parameter[] parameters, SegmentationResults[] expected,
        List&lt;List&lt;PairIntArray&gt;&gt; edgesList) throws Exception {
        
<span class="nc" id="L281">        double[] sumDiffs = new double[2];</span>
        
<span class="nc bnc" id="L283" title="All 4 branches missed.">        switch (pIdx) {</span>
            case 0:
<span class="nc" id="L285">                sumDiffs[0] = invoke(parameters[0].getValue(tIdx1),</span>
<span class="nc" id="L286">                    parameters[1].getMidValue(),</span>
<span class="nc" id="L287">                    parameters[2].getMidValue(),</span>
<span class="nc" id="L288">                    parameters[3].getMidValue(), expected, edgesList);</span>
<span class="nc" id="L289">                sumDiffs[1] = invoke(parameters[0].getValue(tIdx2),</span>
<span class="nc" id="L290">                    parameters[1].getMidValue(),</span>
<span class="nc" id="L291">                    parameters[2].getMidValue(),</span>
<span class="nc" id="L292">                    parameters[3].getMidValue(), expected, edgesList);</span>
<span class="nc" id="L293">                break;</span>
            case 1:
<span class="nc" id="L295">                sumDiffs[0] = invoke(</span>
<span class="nc" id="L296">                    parameters[0].getMidValue(),</span>
<span class="nc" id="L297">                    parameters[1].getValue(tIdx1),</span>
<span class="nc" id="L298">                    parameters[2].getMidValue(),</span>
<span class="nc" id="L299">                    parameters[3].getMidValue(), expected, edgesList);</span>
<span class="nc" id="L300">                sumDiffs[1] = invoke(</span>
<span class="nc" id="L301">                    parameters[0].getMidValue(),</span>
<span class="nc" id="L302">                    parameters[1].getValue(tIdx2),</span>
<span class="nc" id="L303">                    parameters[2].getMidValue(),</span>
<span class="nc" id="L304">                    parameters[3].getMidValue(), expected, edgesList);</span>
<span class="nc" id="L305">                break;</span>
            case 2:
<span class="nc" id="L307">                sumDiffs[0] = invoke(</span>
<span class="nc" id="L308">                    parameters[0].getMidValue(),</span>
<span class="nc" id="L309">                    parameters[1].getMidValue(),</span>
<span class="nc" id="L310">                    parameters[2].getValue(tIdx1),</span>
<span class="nc" id="L311">                    parameters[3].getMidValue(), expected, edgesList);</span>
<span class="nc" id="L312">                sumDiffs[1] = invoke(</span>
<span class="nc" id="L313">                    parameters[0].getMidValue(),</span>
<span class="nc" id="L314">                    parameters[1].getMidValue(),</span>
<span class="nc" id="L315">                    parameters[2].getValue(tIdx2),</span>
<span class="nc" id="L316">                    parameters[3].getMidValue(), expected, edgesList);</span>
<span class="nc" id="L317">                break;</span>
            default:
<span class="nc" id="L319">                sumDiffs[0] = invoke(</span>
<span class="nc" id="L320">                    parameters[0].getMidValue(),</span>
<span class="nc" id="L321">                    parameters[1].getMidValue(),</span>
<span class="nc" id="L322">                    parameters[2].getMidValue(),</span>
<span class="nc" id="L323">                    parameters[3].getValue(tIdx1), expected, edgesList);</span>
<span class="nc" id="L324">                sumDiffs[1] = invoke(</span>
<span class="nc" id="L325">                    parameters[0].getMidValue(),</span>
<span class="nc" id="L326">                    parameters[1].getMidValue(),</span>
<span class="nc" id="L327">                    parameters[2].getMidValue(),</span>
<span class="nc" id="L328">                    parameters[3].getValue(tIdx2), expected, edgesList);</span>
                break;
        }
        
<span class="nc" id="L332">        return sumDiffs;</span>
    }
    
    private SegmentationResults[] readTrainingFiles() throws IOException {
        
<span class="nc" id="L337">        BerkeleySegmentationFileReader reader = new BerkeleySegmentationFileReader();</span>
        
<span class="nc" id="L339">        SegmentationResults[] output = new SegmentationResults[trainingData.length];</span>
        
<span class="nc bnc" id="L341" title="All 2 branches missed.">        for (int i = 0; i &lt; trainingData.length; ++i) {</span>
            
            //String rootName = trainingData[i].imgFileName.split(&quot;\\.&quot;)[0];
<span class="nc" id="L344">            String segFilePath = trainingData[i].dirPath + &quot;/&quot; + trainingData[i].segFileName;</span>
            
<span class="nc" id="L346">            List&lt;Set&lt;PairInt&gt;&gt; set = reader.readFile(segFilePath);</span>
            
<span class="nc" id="L348">            output[i] = new SegmentationResults(set);</span>
        }
        
<span class="nc" id="L351">        return output;</span>
    }
    
    private List&lt;List&lt;PairIntArray&gt;&gt; extractEdges() throws Exception {
        
<span class="nc" id="L356">        List&lt;List&lt;PairIntArray&gt;&gt; output = new ArrayList&lt;List&lt;PairIntArray&gt;&gt;();</span>
        
<span class="nc" id="L358">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
                
<span class="nc bnc" id="L360" title="All 2 branches missed.">        for (int i = 0; i &lt; trainingData.length; ++i) {</span>
            
<span class="nc" id="L362">            String rootName = trainingData[i].imgFileName.split(&quot;\\.&quot;)[0];</span>
<span class="nc" id="L363">            String imgFilePath = trainingData[i].dirPath + &quot;/&quot; + trainingData[i].imgFileName;        </span>
            
<span class="nc" id="L365">            ImageExt img = ImageIOHelper.readImageExt(imgFilePath);</span>
        
<span class="nc" id="L367">            List&lt;PairIntArray&gt; edges = imageSegmentation.extractEdges(img, </span>
                reduceNoise, rootName);
            
<span class="nc" id="L370">            output.add(edges);</span>
        }
        
<span class="nc" id="L373">        return output;</span>
    }
    
    private double invoke(float tLenValue, float tColorValue, 
        float tRValue, float tSmallMergeValue, 
        SegmentationResults[] expected,
        List&lt;List&lt;PairIntArray&gt;&gt; edgesList) throws Exception {
                
<span class="nc" id="L381">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
        
<span class="nc" id="L383">        int dMax = 2;</span>
        
<span class="nc" id="L385">        double sumDifference = 0;</span>
        
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (int i = 0; i &lt; trainingData.length; ++i) {</span>
            
<span class="nc" id="L389">            String rootName = trainingData[i].imgFileName.split(&quot;\\.&quot;)[0];</span>
<span class="nc" id="L390">            String imgFilePath = trainingData[i].dirPath + &quot;/&quot; + trainingData[i].imgFileName;        </span>
            
<span class="nc" id="L392">            ImageExt img = ImageIOHelper.readImageExt(imgFilePath);</span>
            
<span class="nc" id="L394">            List&lt;Set&lt;PairInt&gt;&gt; results = </span>
<span class="nc" id="L395">                imageSegmentation.createColorEdgeSegmentation(img, </span>
<span class="nc" id="L396">                    edgesList.get(i),</span>
<span class="nc" id="L397">                    colorSpace, Math.round(tLenValue), </span>
                    tColorValue, tRValue, 
                    reduceNoise, tSmallMergeValue, rootName);
            
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (results.size() &gt; 1) {</span>
                
<span class="nc" id="L403">                SegmentationResults sr0 = new SegmentationResults(results);</span>

<span class="nc" id="L405">                SegmentationResults exp = expected[i];</span>

                // going to use 1 - fMeasure for now to convert
                // the score into a cost
<span class="nc" id="L409">                double fMeasure = sr0.evaluate(exp, dMax);</span>
<span class="nc" id="L410">                sumDifference += (1. - fMeasure);</span>
<span class="nc" id="L411">            } else {</span>
                // no edges, so cost is maximum cost
<span class="nc" id="L413">                sumDifference += 1;</span>
            }
        }
        
<span class="nc" id="L417">        return sumDifference;</span>
    }

    public float[] getParameters() {
        
<span class="nc" id="L422">        float[] output = new float[4];</span>
<span class="nc" id="L423">        output[0] = tLen.getMidValue();</span>
<span class="nc" id="L424">        output[1] = tColor.getMidValue();</span>
<span class="nc" id="L425">        output[2] = tR.getMidValue();</span>
<span class="nc" id="L426">        output[3] = tSmallMerge.getMidValue();</span>
        
<span class="nc" id="L428">        return output;</span>
    }

    private void print(Parameter[] parameters) {
<span class="nc" id="L432">        StringBuilder sb = new StringBuilder(&quot;\n&quot;);</span>
        //tLen, tColor, tR, tSmallMerge
<span class="nc bnc" id="L434" title="All 2 branches missed.">        for (int i = 0; i &lt; parameters.length; ++i) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L436">                sb.append(&quot;tLen: &quot;);</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            } else if (i == 1) {</span>
<span class="nc" id="L438">                sb.append(&quot;tColor: &quot;);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            } else if (i == 2) {</span>
<span class="nc" id="L440">                sb.append(&quot;tR: &quot;);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            } else if (i == 3) {</span>
<span class="nc" id="L442">                sb.append(&quot;tSmallMerge: &quot;);</span>
            }
<span class="nc" id="L444">            sb.append(parameters[i].getMidValue())</span>
<span class="nc" id="L445">               .append(&quot; loIdx=&quot;).append(parameters[i].lowIdx)</span>
<span class="nc" id="L446">               .append(&quot; hiIdx=&quot;).append(parameters[i].highIdx)</span>
<span class="nc" id="L447">               .append(&quot;\n&quot;);</span>
        }
        try {
<span class="nc" id="L450">            writer.write(sb.toString());</span>
<span class="nc" id="L451">            writer.flush();</span>
<span class="nc" id="L452">        } catch (IOException ex) {</span>
<span class="nc" id="L453">            Logger.getLogger(SequentialBisectorSolver.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L454">        }</span>
        //System.out.println(sb.toString());
<span class="nc" id="L456">    }</span>

    @Override
    protected void finalize() throws Throwable {
<span class="nc" id="L460">        writer.close();</span>
<span class="nc" id="L461">        super.finalize(); //To change body of generated methods, choose Tools | Templates.</span>
<span class="nc" id="L462">    }    </span>

    private static class Parameter {
        final float vFirst;
        final float vLast;
        final float deltaV;
        int lowIdx = 0;
        int highIdx;
        
        public Parameter(float startRange, float stopRange, float delta) {
            vFirst = startRange;
            vLast = stopRange;
            deltaV = delta;
            highIdx = Math.round((stopRange - startRange)/delta);
            //0.1 to 0.7     d=0.05, n=13
            // 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7
            //  0   1    2    3   4    5    6   7   8   9   10   11   12
        }
        
        public float getMidValue() {
            int m = (lowIdx + highIdx) &gt;&gt; 1;
            float v = (m * deltaV) + vFirst;
            return v;
        }
        
        public float getValue(int idx) {
            float v = (idx * deltaV) + vFirst;
            return v;
        }
    }
    
    private void debugImages(Parameter[] parameters, 
        List&lt;List&lt;PairIntArray&gt;&gt; edgesList) throws Exception {
              
        //tLen, tColor, tR, tSmallMerge
<span class="nc" id="L497">        print(parameters);</span>
        
<span class="nc" id="L499">        int tLen = (int)parameters[0].getMidValue();</span>
<span class="nc" id="L500">        float tColor = parameters[1].getMidValue();</span>
<span class="nc" id="L501">        float tR = parameters[2].getMidValue();</span>
<span class="nc" id="L502">        float tSmallMerge = parameters[3].getMidValue();</span>
        
<span class="nc" id="L504">        ImageSegmentation imageSegmentation = new ImageSegmentation();</span>
        
<span class="nc" id="L506">        long ts = MiscDebug.getCurrentTimeFormatted();</span>
                
<span class="nc bnc" id="L508" title="All 2 branches missed.">        for (int i = 0; i &lt; trainingData.length; ++i) {</span>
            
<span class="nc" id="L510">            String rootName = trainingData[i].imgFileName.split(&quot;\\.&quot;)[0];</span>
<span class="nc" id="L511">            String imgFilePath = trainingData[i].dirPath + &quot;/&quot; + trainingData[i].imgFileName;        </span>
            
<span class="nc" id="L513">            ImageExt img = ImageIOHelper.readImageExt(imgFilePath);</span>
            
<span class="nc" id="L515">            List&lt;Set&lt;PairInt&gt;&gt; results = </span>
<span class="nc" id="L516">                imageSegmentation.createColorEdgeSegmentation(img, </span>
<span class="nc" id="L517">                    edgesList.get(i),</span>
                    colorSpace, 
                    tLen, tColor, tR, 
                    reduceNoise, 
                    tSmallMerge, rootName);
            
<span class="nc" id="L523">            img = img.createWithDimensions();</span>
            
<span class="nc" id="L525">            MiscDebug.writeAlternatingColor(</span>
                img, results, &quot;seg_&quot; + rootName + &quot;_&quot; + ts);
        }
<span class="nc" id="L528">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HopcroftKarpRT2012.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.bipartite</a> &gt; <span class="el_source">HopcroftKarpRT2012.java</span></div><h1>HopcroftKarpRT2012.java</h1><pre class="source lang-java linenums">package algorithms.bipartite;

import algorithms.bipartite.MinCostUnbalancedAssignment.Forest;
import algorithms.bipartite.MinCostUnbalancedAssignment.LeftNode;
import algorithms.bipartite.MinCostUnbalancedAssignment.RightNode;
import algorithms.bipartite.MinCostUnbalancedAssignment.PathNode;
import static algorithms.bipartite.MinCostUnbalancedAssignment.extractNodes;
import algorithms.DoubleLinkedCircularList;
import algorithms.heapsAndPQs.HeapNode;
import algorithms.mst.PrimsMST;
import algorithms.util.PairInt;
import gnu.trove.iterator.TIntIntIterator;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

/**
 * NOTE:  this class is NOT READY FOR USE YET.
 * should possibly be refactored to use primitives where possible.
 * 
 * @author nichole
 */
<span class="nc bnc" id="L34" title="All 2 branches missed.">public class HopcroftKarpRT2012 {</span>
    
<span class="nc" id="L36">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    private final int maxNumberOfBitsInWeight;
    
<span class="nc" id="L40">    public HopcroftKarpRT2012() {</span>
<span class="nc" id="L41">        this.maxNumberOfBitsInWeight = 31;</span>
<span class="nc" id="L42">    }</span>
    
<span class="nc" id="L44">    public HopcroftKarpRT2012(int maxNumberOfBitsInWeight) {</span>
<span class="nc bnc" id="L45" title="All 4 branches missed.">        if (maxNumberOfBitsInWeight &gt; 31 ||  maxNumberOfBitsInWeight &lt; 2) {</span>
<span class="nc" id="L46">            throw new IllegalArgumentException(</span>
                &quot;maxNumberOfBitsInWeight must be between 2 and 31, inclusive&quot;);
        }
<span class="nc" id="L49">        this.maxNumberOfBitsInWeight = maxNumberOfBitsInWeight;</span>
<span class="nc" id="L50">    }</span>
    
    /**
     NOT READY FOR USE.
     should possibly be refactored to use primitives where possible.
     runtime complexity O(m * sqrt(s)) where m is number of edges and s is the 
     size of the matching whose target size may be less than the maximum 
     matchable.  
     @param g
     @return 
    */
    public TIntIntMap findMaxMatching(Graph g, int s) {
    
<span class="nc" id="L63">        TIntIntMap m = new TIntIntHashMap();</span>
                 
<span class="nc" id="L65">        ResidualDigraph rM = new ResidualDigraph(g, m);</span>
        
<span class="nc" id="L67">        int prevMSize = m.size();</span>
        
<span class="nc" id="L69">        int nIter = 0;</span>
            
        // estimate lambda for the dial array length by
        // looking at the number of edges with more than
        // one connection.
<span class="nc" id="L74">        int lambda = estimateLambda(rM);</span>

        while (true) {
                        
<span class="nc" id="L78">            boolean augmented = buildForestAndAugment(rM, lambda);</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">            if (!augmented) {</span>
<span class="nc" id="L81">                return m;</span>
            }
            
            /*            
            let P = {P1, P2, ...Pk} be a maximum set of vertex-disjoint
               shortest augmenting paths with respect to M
            M = the symmetric difference between M and
               (P1 union P2 union ...Pk)
            
            now applying the symmetric difference to m and m2
            */
            
<span class="nc" id="L93">            TIntIntMap m2 = rM.extractMatchings();</span>
                        
            //announce(M is a matching)
            
<span class="nc" id="L97">            log.fine(&quot;nIter=&quot; + nIter + &quot; m2.size=&quot; + m2.size()</span>
<span class="nc" id="L98">                + &quot; m.size=&quot; + m.size());</span>
            
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (m2.size() &gt;= s) {</span>
<span class="nc" id="L101">                return m2;</span>
            }
            
<span class="nc" id="L104">            TIntIntMap tmpM = new TIntIntHashMap(m);</span>
            
<span class="nc" id="L106">            TIntSet mR = new TIntHashSet(m.values());</span>
            // if m2 has a match that does not conflict with m,
            // add it to m (== vertex disjoint)

<span class="nc" id="L110">            TIntIntIterator iter = m2.iterator();</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">            for (int i = m2.size(); i-- &gt; 0;) {</span>
<span class="nc" id="L112">                iter.advance();</span>
<span class="nc" id="L113">                int key = iter.key();</span>
<span class="nc" id="L114">                int value = iter.value();</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">                if (!tmpM.containsKey(key) &amp;&amp; !mR.contains(value)) {</span>
<span class="nc" id="L116">                    tmpM.put(key, value);</span>
                }
<span class="nc" id="L118">            }</span>
            
<span class="nc" id="L120">            log.fine(&quot;union size=&quot; + tmpM.size());</span>
            
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (tmpM.size() &gt;= s) {</span>
<span class="nc" id="L123">                return tmpM;</span>
            }
            
            // remove the intersection of m and m2
<span class="nc" id="L127">            iter = m.iterator();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            for (int i = m.size(); i-- &gt; 0;) {</span>
<span class="nc" id="L129">                iter.advance();</span>
<span class="nc" id="L130">                int key = iter.key();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (m2.containsKey(key) &amp;&amp;</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                    m2.get(key)== iter.value()) {</span>
<span class="nc" id="L133">                    tmpM.remove(key);</span>
                }
<span class="nc" id="L135">            }</span>
            
<span class="nc" id="L137">            m = tmpM;</span>
<span class="nc" id="L138">            log.fine(&quot;symmetric diff of m and m2.size=&quot; + m.size());</span>
            
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (m.size() &gt;= s) {</span>
<span class="nc" id="L141">                return m;</span>
            }
            
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (prevMSize == m.size()) {</span>
                // user estimate of matching size might be an
                // overestimate.
<span class="nc" id="L147">                log.warning(&quot;m.size=&quot; + m.size() + &quot; which is&quot;</span>
                    + &quot; less than the requsted size s=&quot; +s);
<span class="nc" id="L149">                return m;</span>
            }
            
<span class="nc" id="L152">            rM = new ResidualDigraph(g, m);</span>
            
<span class="nc bnc" id="L154" title="All 4 branches missed.">            assert(prevMSize &lt; m.size());</span>
            
<span class="nc" id="L156">            prevMSize = m.size();</span>
<span class="nc" id="L157">            ++nIter;            </span>
<span class="nc" id="L158">        }        </span>
    }
    
    private int estimateLambda(ResidualDigraph rM) {
        //TODO: this may need to be revised
<span class="nc" id="L163">        int n = 0;</span>

<span class="nc" id="L165">        TIntObjectIterator&lt;TIntSet&gt; iter = rM.getForwardLinksRM().</span>
<span class="nc" id="L166">            iterator();</span>

<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int i = rM.getForwardLinksRM().size(); i-- &gt; 0;) {</span>
<span class="nc" id="L169">            iter.advance();</span>
<span class="nc" id="L170">            TIntSet set = iter.value();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (set.size() &gt; 1) {</span>
<span class="nc" id="L172">                n++;</span>
            }
<span class="nc" id="L174">        }</span>
<span class="nc" id="L175">        return (n + 2);</span>
    }

    /**
     * find augmenting paths of minimal length by building the shortest path 
     * forest.
     * 
     * implementing section 3.4, pg 22 of Ramshaw and Tarjan 2012.
     * 
     * @param rM the residual digraph built from the matching 
     * graph M of graph G.
     * 
     * @return a forest of trees whose forest array indexes 
     * are the path lengths and whose items hold at the root, the
     * remaining maidens, that is unmatched left nodes (a.k.a. G's
     * X nodes).
     * @param lambda the length to use for a counting sort of
     * augmenting path lengths
     */
    protected boolean buildForestAndAugment(final ResidualDigraph rM, int lambda) {
      
<span class="nc" id="L196">        Forest forest = new Forest(lambda);</span>
        
<span class="nc" id="L198">        MinHeapForRT2012 heap = new MinHeapForRT2012(4, </span>
<span class="nc" id="L199">            rM.countOfForwardBipartiteLinks(), maxNumberOfBitsInWeight);</span>
        
        /*
        this class is invoked as the first step in a
        hopcroft-karp matching algorithm and there are
        at first no matching nodes,
        so all X nodes are maiden nodes.
        but other uses may give the method a residual graph
        that has matched arcs in it.
        
        The code below treats each maiden X node as a single
        source shortest path problem.
           
        Note that book-keeping for the predecessors requires
        a copy be made upon insert of a node into the heap
        so that all possible foward links are present in 
        the heap.
        */
     
        // init all nodes to inf length
<span class="nc" id="L219">        PathNodes pathNodes = new PathNodes(rM.getNLeft(), </span>
<span class="nc" id="L220">            rM.getNRight());</span>
        
<span class="nc" id="L222">        TIntObjectMap&lt;LeftNode&gt; leftNodes </span>
<span class="nc" id="L223">            = pathNodes.getLeftNodes();</span>
<span class="nc" id="L224">        TIntObjectMap&lt;RightNode&gt; rightNodes </span>
<span class="nc" id="L225">            = pathNodes.getRightNodes();</span>
       
        /*
        for the bfs and tracking &quot;visited&quot;, need to track
        individually for each maiden as its own single shortest
        path.  doing so for the right nodes
        key = maiden node index (== X index)
        value = visited nodes along key path
        */
<span class="nc" id="L234">        TIntObjectMap&lt;TIntSet&gt; vXY = </span>
            new TIntObjectHashMap&lt;TIntSet&gt;();
        
<span class="nc" id="L237">        TIntSet augmentedLeft = new TIntHashSet();</span>
<span class="nc" id="L238">        TIntSet augmentedRight = new TIntHashSet();</span>
<span class="nc" id="L239">        long prevKey = -1;</span>
<span class="nc" id="L240">        long lastAugKey = -1;</span>
        
        // married X nodes
<span class="nc" id="L243">        TIntSet matchedLeft = new TIntHashSet(</span>
<span class="nc" id="L244">            rM.getBackwardLinksRM().values());    </span>
 
        // for all maidens
        // set key to 0, then ScanAndAdd(index)
<span class="nc" id="L248">        TIntSet maidens = new TIntHashSet();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (int i = 0; i &lt; rM.getNLeft(); ++i) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (matchedLeft.contains(i)) {</span>
<span class="nc" id="L251">                continue;</span>
            }
<span class="nc" id="L253">            maidens.add(i);</span>
<span class="nc" id="L254">            LeftNode node = leftNodes.get(i);</span>
<span class="nc" id="L255">            node.setKey(0);</span>
<span class="nc" id="L256">            vXY.put(i, new TIntHashSet());</span>
<span class="nc" id="L257">            prevKey = scanAndAdd(heap, forest, rM, </span>
                rightNodes, node, prevKey,
                augmentedLeft, augmentedRight, 
<span class="nc" id="L260">                node, vXY.get(i));</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">            assert(prevKey == 0L);</span>
        }
     
<span class="nc" id="L264">        int nRight = rM.getNRight();</span>
        
<span class="nc" id="L266">        log.fine(&quot;done adding &quot; + maidens.size() + </span>
            &quot; maiden nodes and their links to heap&quot;);
        
        // at this point, the maidens are all in index 0 of
        // the forest trees.
        
<span class="nc" id="L272">        int nIter = 0;</span>
        
<span class="nc bnc" id="L274" title="All 2 branches missed.">        while (heap.getNumberOfNodes() &gt; 0) {</span>
             
            // in the heap are men not in the forest who are in
            // an alternating path from a maiden.
            // the key is the length of shortest path so far
<span class="nc" id="L279">            PathNode y = (PathNode) heap.extractMin();</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">            assert(y instanceof RightNode);</span>
            
<span class="nc" id="L282">            log.fine(&quot;heap.size=&quot; + heap.getNumberOfNodes());</span>
            
<span class="nc" id="L284">            log.fine(&quot;extractMin=&quot; + y.toString());</span>
            
<span class="nc" id="L286">            int yIdx = y.index;</span>
        
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (augmentedRight.contains(yIdx)) {</span>
<span class="nc" id="L289">                continue;</span>
            }
            
<span class="nc bnc" id="L292" title="All 4 branches missed.">            assert(y.topPredecessor != null);</span>
            
<span class="nc" id="L294">            int topIdx = y.topPredecessor.index;</span>
            
<span class="nc" id="L296">            long currentKey = forest.add(y, prevKey);</span>
            
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (currentKey &gt; prevKey) {</span>
<span class="nc" id="L299">                log.fine(&quot;augment forest[&quot; + prevKey + &quot;] &quot;);</span>
                //forest[0] are the maiden nodes alone
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (prevKey &gt; 0) {</span>
                    //debug(forest);
<span class="nc" id="L303">                    augmentPath(rM, forest, prevKey, augmentedLeft,</span>
                        augmentedRight);
                }
<span class="nc" id="L306">                forest.removeFirstItem((int)prevKey);</span>
<span class="nc" id="L307">                lastAugKey = prevKey;</span>
<span class="nc" id="L308">                prevKey = currentKey;</span>
            }
            
            /*
            if y is married then
                x := wife of y;
                set l(x) := l(y) and 
                ScanAndAdd(x); 
            else
                exit(bachelor β := y reached); 
            fi;
            */
            
            // the married nodes are the keys in the backward
            // links of the residual digraph
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (rM.getBackwardLinksRM().containsKey(yIdx)) {</span>
<span class="nc" id="L324">                int xIdx = rM.getBackwardLinksRM().get(yIdx);</span>
<span class="nc" id="L325">                LeftNode xNode = leftNodes.get(xIdx);</span>
                
<span class="nc" id="L327">                xNode.setKey(y.getKey());</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if (xNode.pathPredecessor == null) {</span>
<span class="nc" id="L329">                    xNode.pathPredecessor = y;</span>
<span class="nc" id="L330">                    xNode.topPredecessor = y.topPredecessor;</span>
                }
                 
<span class="nc" id="L333">                currentKey = scanAndAdd(heap, forest, </span>
                    rM, rightNodes, xNode, prevKey,
                    augmentedLeft, augmentedRight, y.topPredecessor, 
<span class="nc" id="L336">                    vXY.get(topIdx));</span>
                
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if (currentKey &gt; prevKey) {</span>
<span class="nc" id="L339">                    log.fine(&quot;augment forest[&quot; + prevKey + &quot;] &quot;);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                    if (prevKey &gt; 0) {</span>
                        //debug(forest);
<span class="nc" id="L342">                        augmentPath(rM, forest, prevKey, augmentedLeft,</span>
                            augmentedRight);
                    }
<span class="nc" id="L345">                    forest.removeFirstItem((int)prevKey);</span>
<span class="nc" id="L346">                    lastAugKey = prevKey;</span>
<span class="nc" id="L347">                    prevKey = currentKey;    </span>
                }       
                
<span class="nc" id="L350">            } else {</span>
                //exit(bachelor β := y reached);
<span class="nc" id="L352">                log.fine(&quot;bachelor y=&quot; + y.toString());</span>
                
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if (maidens.contains(topIdx)) {</span>
<span class="nc" id="L355">                    maidens.remove(topIdx);                    </span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                } else if (maidens.isEmpty()) {</span>
<span class="nc" id="L357">                    log.fine(&quot;last maiden's bachelor reached&quot;);</span>
                    //debug(forest);
<span class="nc" id="L359">                    break;</span>
                }
            }
        
<span class="nc" id="L363">            log.fine(&quot;nIter=&quot; + nIter);</span>
<span class="nc" id="L364">        }</span>
        
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (lastAugKey &lt; prevKey) {</span>
<span class="nc" id="L367">            log.fine(&quot;augment forest[&quot; + prevKey + &quot;] &quot;);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (prevKey &gt; 0) {</span>
                //debug(forest);
<span class="nc" id="L370">                augmentPath(rM, forest, prevKey, augmentedLeft,</span>
                    augmentedRight);
            }
<span class="nc" id="L373">            lastAugKey = prevKey;</span>
        }
       
<span class="nc" id="L376">        log.fine(&quot;lastAugKey=&quot; + lastAugKey);</span>
        
<span class="nc bnc" id="L378" title="All 4 branches missed.">        return !(augmentedLeft.isEmpty() &amp;&amp; augmentedRight.isEmpty());</span>
    }

    /**    
    given a maiden (left) node, search forward links to 
    right nodes in alternating paths
    to insert right nodes into the heap
    or update their heap keys for shorter paths.
    
    note that any yNodes inserted into the heap internally,
    have their keys updated.
    
     * @param heap
     * @param forest
     * @param rM
     * @param yNodes
     * @param xNode 
     */
    private long scanAndAdd(MinHeapForRT2012 heap, Forest forest,
        ResidualDigraph rM, TIntObjectMap&lt;RightNode&gt; yNodes, 
        LeftNode xNode, long prevKey,
        TIntSet augmentedLeft,
        TIntSet augmentedRight,
        LeftNode topNode, TIntSet visitedY) {

<span class="nc" id="L403">        int xIdx = xNode.index;</span>
      
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (augmentedLeft.contains(xIdx)) {</span>
<span class="nc" id="L406">            return prevKey;</span>
        }
        
<span class="nc" id="L409">        long lX = xNode.getKey();</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">        assert(lX &lt; Long.MAX_VALUE);</span>
        
<span class="nc" id="L412">        TIntSet forwardLinks </span>
<span class="nc" id="L413">            = rM.getForwardLinksRM().get(xIdx);</span>
        
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (forwardLinks != null) {</span>
<span class="nc" id="L416">            TIntIterator iter = forwardLinks.iterator();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L418">                int yIdx = iter.next();</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                if (visitedY.contains(yIdx) ||</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    augmentedRight.contains(yIdx)) {</span>
<span class="nc" id="L421">                    continue;</span>
                }
<span class="nc" id="L423">                visitedY.add(yIdx);</span>
                
                //link length = net cost of the edge 
                //    (lp(x ⇒ y) = cp(X,Y))
                //link length of backward link Y-&gt;X, is 0, lp(y ⇒ x) := 0.

                // l(x) and l(y) are the keys in the heap node

<span class="nc" id="L431">                RightNode yNode = yNodes.get(yIdx);</span>
<span class="nc" id="L432">                long lOld = yNode.getKey();</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">                assert(yNode.index == yIdx);</span>
                
                //L := l(x) + lp(x ⇒ y) 
                //   = l(x) + cp(x, y)
                //   = l(x) + c(x, y) − pd(x) + pd(y)
                // from page 41 regarding first steps in FlowAssign:  
                // &quot;We first perform some initialization. 
                // Ignoring the edges weights, we use Hopcroft-Karp 
                // to look for some matching of size t.&quot;
                // so, c(x,y) which is the edge weight in Graph g,
                // is 1 here by this statement.
<span class="nc" id="L444">                int cp = 1;</span>

<span class="nc" id="L446">                long ell = lX + cp;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (ell &lt; lOld) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                    if (lOld == Long.MAX_VALUE) {</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">                        assert(yNode instanceof RightNode);</span>
<span class="nc" id="L450">                        yNode = (RightNode)yNode.copy();</span>
<span class="nc" id="L451">                        yNode.pathPredecessor = xNode.copy();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                        if (yNode.pathPredecessor.topPredecessor != null) {</span>
<span class="nc bnc" id="L453" title="All 4 branches missed.">                            assert (yNode.pathPredecessor.topPredecessor.index ==</span>
                                topNode.index);
<span class="nc" id="L455">                            yNode.topPredecessor</span>
                                = yNode.pathPredecessor.topPredecessor;
                        } else {
<span class="nc" id="L458">                            yNode.topPredecessor = topNode;</span>
                        }
<span class="nc" id="L460">                        yNode.setKey(ell);</span>
<span class="nc" id="L461">                        heap.insert(yNode);</span>
<span class="nc" id="L462">                        log.fine(String.format(&quot;HEAP insert: %s&quot;,</span>
<span class="nc" id="L463">                            yNode.toString()));</span>
                    } else {
<span class="nc bnc" id="L465" title="All 2 branches missed.">                        int prev = </span>
<span class="nc" id="L466">                            (yNode.pathPredecessor == null) ?</span>
                            null :
<span class="nc" id="L468">                            yNode.pathPredecessor.index;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                        int top = </span>
<span class="nc" id="L470">                            (yNode.topPredecessor == null) ?</span>
                            null :
<span class="nc" id="L472">                            yNode.topPredecessor.index;</span>
<span class="nc bnc" id="L473" title="All 4 branches missed.">                        assert(prev != -1);</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">                        assert(top != -1);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                        if (prev != xIdx) {</span>
<span class="nc" id="L476">                            yNode.pathPredecessor = xNode;</span>
<span class="nc" id="L477">                            yNode.topPredecessor = xNode.topPredecessor;</span>
                        }
<span class="nc" id="L479">                        heap.decreaseKey(yNode, ell);</span>
<span class="nc" id="L480">                        log.fine(String.format(&quot;HEAP decr: %s&quot;,</span>
<span class="nc" id="L481">                            yNode.toString()));</span>
                    }
                }
<span class="nc" id="L484">            }</span>
        }
        
        //add x to the forest;
<span class="nc" id="L488">        return forest.add(xNode, prevKey);</span>
    }
    
    private void augmentPath(ResidualDigraph rM, Forest forest, 
        long foresIdx, TIntSet augmentedLeft, 
        TIntSet augmentedRight) {

        /*
        will extract the paths, that is the branches in the
        tree forest[forestIdx]
        and find a maximal set of compatible paths within
        those.
        
        could use kruskal's or prims to create the set of
        edges (created from building the minimum spanning tree).
        then augment using each edge, but 
        skipping those violating vertex-disjoint.
        
        since prim's runtime complexity is better for
        |v| &lt; |E|, will use that.
        
        */
        
        // ---- extract the forest tree as edges ---
        
<span class="nc" id="L513">        DoubleLinkedCircularList tree = forest.get((int)foresIdx);</span>

<span class="nc bnc" id="L515" title="All 4 branches missed.">        assert(tree != null);</span>
        
<span class="nc" id="L517">        Set&lt;PairInt&gt; edges = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L518">        long n = tree.getNumberOfNodes();</span>
<span class="nc" id="L519">        HeapNode node = tree.getSentinel();</span>
<span class="nc" id="L520">        log.fine(&quot;number of branches in tree=&quot; + n);</span>
 
<span class="nc" id="L522">        int j = 0;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        while (j &lt; n) {</span>
<span class="nc" id="L524">            node = node.getLeft();</span>
            
<span class="nc" id="L526">            List&lt;PathNode&gt; path = MinCostUnbalancedAssignment.extractNodes((PathNode)node);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (path.size() &lt; 2) {</span>
<span class="nc" id="L528">                ++j;</span>
<span class="nc" id="L529">                continue;</span>
            }
            //debugPath(path);
            //discard if not vertex disjoint from augmented sets
<span class="nc" id="L533">            boolean skip = false;</span>
<span class="nc" id="L534">            List&lt;PairInt&gt; tmp = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            for (int ii = 0; ii &lt; (path.size() - 1); ++ii) {</span>
<span class="nc" id="L536">                PathNode node1 = path.get(ii);</span>
<span class="nc" id="L537">                PathNode node2 = path.get(ii + 1);</span>
                // index1 is the left index of arc
                // index2 is the right index of the arc
                int idx1, idx2;
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if (node1 instanceof LeftNode) {</span>
<span class="nc" id="L542">                    idx1 = node1.index;</span>
<span class="nc" id="L543">                    idx2 = node2.index;</span>
                } else {
<span class="nc" id="L545">                    idx1 = node2.index;</span>
<span class="nc" id="L546">                    idx2 = node1.index;</span>
                }
<span class="nc bnc" id="L548" title="All 2 branches missed.">                if (augmentedLeft.contains(idx1) ||</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                    augmentedRight.contains(idx2)) {</span>
<span class="nc" id="L550">                    skip = true;</span>
<span class="nc" id="L551">                    break;</span>
                }
<span class="nc" id="L553">                tmp.add(new PairInt(idx1, idx2));</span>
            }
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (!skip) {</span>
<span class="nc" id="L556">                edges.addAll(tmp);</span>
            }
<span class="nc" id="L558">            ++j;</span>
<span class="nc" id="L559">        }</span>
        
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (edges.isEmpty()) {</span>
<span class="nc" id="L562">            return;</span>
        }

        List&lt;PairInt&gt; edges2;
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (edges.size() &gt; 2) {</span>
            //edges2 = filterUsingMST(edges);
<span class="nc" id="L568">            edges2 = filter(edges);</span>
        } else {
<span class="nc" id="L570">            edges2 = new ArrayList&lt;PairInt&gt;(edges);</span>
        }

        //augment M along path;

        //pg 11: &quot;But our augmenting paths will be paths 
        //in an auxiliary graph called the residual digraph&quot;

        //&quot;We augment along a tight augmenting path 
        //by swapping the status of the edges that 
        //underlie its links, saturating the idle edges
        //and idling the saturated ones. This process 
        //increases the size of the matching by exactly 1. 
        //It marries off the maiden and bachelor at the 
        //ends of the augmenting path, thus reducing the
        //number of places where future augmenting paths 
        //can start or end.

        /*
        separating edits into 2 lists:
           undo &quot;saturated&quot; then make idle saturated
        */
<span class="nc" id="L592">        List&lt;PairInt&gt; undoSaturated = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L593">        List&lt;PairInt&gt; makeSaturated = new ArrayList&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L595" title="All 2 branches missed.">        for (PairInt edge : edges2) {</span>
<span class="nc" id="L596">            int leftIdx = edge.getX();</span>
<span class="nc" id="L597">            int rightIdx = edge.getY();</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (rM.getBackwardLinksRM().containsKey(rightIdx)) {</span>
<span class="nc" id="L599">                int bLeftIdx = rM.getBackwardLinksRM().get(</span>
                    rightIdx);
<span class="nc bnc" id="L601" title="All 2 branches missed.">                if (bLeftIdx == leftIdx) {</span>
<span class="nc" id="L602">                    undoSaturated.add(edge);</span>
                } else {
<span class="nc" id="L604">                    makeSaturated.add(edge);</span>
                }
<span class="nc" id="L606">            } else {</span>
<span class="nc" id="L607">                makeSaturated.add(edge);</span>
            }
<span class="nc" id="L609">        }</span>
                
<span class="nc bnc" id="L611" title="All 2 branches missed.">        for (PairInt edge : undoSaturated) {</span>

<span class="nc" id="L613">            int leftIdx = edge.getX();</span>
<span class="nc" id="L614">            int rightIdx = edge.getY();</span>

            // remove backwards link and mapping
<span class="nc" id="L617">            rM.getBackwardLinksRM().remove(rightIdx);</span>

<span class="nc" id="L619">            TIntSet rIndexes = rM.getForwardLinksRM().get(leftIdx);</span>
            // create a forward link        
<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (rIndexes == null) {</span>
<span class="nc" id="L622">                rIndexes = new TIntHashSet();</span>
<span class="nc" id="L623">                rM.getForwardLinksRM().put(leftIdx, rIndexes);</span>
            }
<span class="nc" id="L625">            rIndexes.add(rightIdx);</span>

<span class="nc" id="L627">            log.fine(&quot;augmented to remove :&quot; + leftIdx </span>
                + &quot; to &quot; + rightIdx);
            
<span class="nc" id="L630">            augmentedLeft.add(leftIdx);</span>
<span class="nc" id="L631">            augmentedRight.add(rightIdx);</span>
<span class="nc" id="L632">        }</span>
        
<span class="nc" id="L634">        TIntSet tmpAR = new TIntHashSet();</span>
<span class="nc" id="L635">        TIntSet tmpAL = new TIntHashSet();</span>
        
<span class="nc bnc" id="L637" title="All 2 branches missed.">        for (PairInt edge : makeSaturated) {</span>

<span class="nc" id="L639">            int rightIdx = edge.getY();</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (tmpAR.contains(rightIdx)) {</span>
<span class="nc" id="L642">                continue;</span>
            }
            
<span class="nc" id="L645">            int leftIdx = edge.getX();</span>
            
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (tmpAL.contains(leftIdx)) {</span>
<span class="nc" id="L648">                continue;</span>
            }
            
            // assert saturated mapping for right node doesn't exist
<span class="nc bnc" id="L652" title="All 4 branches missed.">            assert(rM.getBackwardLinksRM().containsKey(rightIdx));</span>
<span class="nc" id="L653">            int v2 = rM.getBackwardLinksRM().get(rightIdx);</span>
            
<span class="nc" id="L655">            TIntSet rIndexes = rM.getForwardLinksRM().get(leftIdx);</span>
        
<span class="nc bnc" id="L657" title="All 2 branches missed.">            boolean forwardFound = (rIndexes != null) &amp;&amp; </span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                rIndexes.contains(rightIdx);</span>
        
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (forwardFound) {</span>
                // remove existing &quot;idle&quot; forward link
<span class="nc" id="L662">                rIndexes.remove(rightIdx);</span>

                // create a backward link and matched mapping
<span class="nc" id="L665">                rM.getBackwardLinksRM().put(rightIdx, leftIdx);</span>

<span class="nc" id="L667">                log.fine(&quot;augmented to add :&quot; + leftIdx + &quot; to &quot; +</span>
                    rightIdx);
                
<span class="nc" id="L670">                tmpAL.add(leftIdx);</span>
<span class="nc" id="L671">                tmpAR.add(rightIdx);</span>
            }
<span class="nc" id="L673">        }</span>
<span class="nc" id="L674">        augmentedRight.addAll(tmpAR);</span>
<span class="nc" id="L675">        augmentedLeft.addAll(tmpAL);</span>
       
<span class="nc" id="L677">    }</span>
    
    private String debug(TIntSet aL, TIntSet aR) {
<span class="nc" id="L680">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L681">        sb.append(&quot;aL=[&quot;);</span>
<span class="nc" id="L682">        TIntIterator iter = aL.iterator();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L684">            int idx = iter.next();</span>
<span class="nc" id="L685">            sb.append(Integer.toString(idx)).append(&quot;,&quot;);</span>
<span class="nc" id="L686">        }</span>
<span class="nc" id="L687">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L688">        sb.append(&quot; aR=[&quot;);</span>
<span class="nc" id="L689">        iter = aR.iterator();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L691">            int idx = iter.next();</span>
<span class="nc" id="L692">            sb.append(Integer.valueOf(idx)).append(&quot;,&quot;);</span>
<span class="nc" id="L693">        }</span>
<span class="nc" id="L694">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L695">        return sb.toString();</span>
    }
    
    private List&lt;PairInt&gt; filterUsingMST(Set&lt;PairInt&gt; edges) {
        
        // ---- prepare edges as a single graph and
        //      adjacency map to give to prim's
        
        // re-number the vertexes and make an adjacency map or matrix
        // populate these from Set&lt;PairInt&gt; edges
<span class="nc" id="L705">        int nVertexes = 0;</span>
<span class="nc" id="L706">        TIntIntMap leftToNew = new TIntIntHashMap();</span>
<span class="nc" id="L707">        TIntIntMap revLeftToNew = new TIntIntHashMap();</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        for (PairInt edge : edges) {</span>
<span class="nc" id="L709">            int idx = edge.getX();</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (!leftToNew.containsKey(idx)) {</span>
<span class="nc" id="L711">                leftToNew.put(idx, nVertexes);</span>
<span class="nc" id="L712">                revLeftToNew.put(nVertexes, idx);</span>
<span class="nc" id="L713">                nVertexes++;</span>
            }
<span class="nc" id="L715">        }</span>
<span class="nc" id="L716">        int nL = nVertexes;        </span>
<span class="nc" id="L717">        TIntIntMap rightToNew = new TIntIntHashMap();</span>
<span class="nc" id="L718">        TIntIntMap revRightToNew = new TIntIntHashMap();</span>
        
<span class="nc bnc" id="L720" title="All 2 branches missed.">        for (PairInt edge : edges) {</span>
<span class="nc" id="L721">            int idx = edge.getY();</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if (!rightToNew.containsKey(idx)) {</span>
<span class="nc" id="L723">                rightToNew.put(idx, nVertexes);</span>
<span class="nc" id="L724">                revRightToNew.put(nVertexes, idx);</span>
<span class="nc" id="L725">                nVertexes++;</span>
            }
<span class="nc" id="L727">        }</span>
        
<span class="nc" id="L729">        TIntObjectMap&lt;TIntIntMap&gt; adjCostMap =</span>
            new TIntObjectHashMap&lt;TIntIntMap&gt;();
        
<span class="nc bnc" id="L732" title="All 2 branches missed.">        for (PairInt edge : edges) {</span>
<span class="nc" id="L733">            int idx1 = edge.getX();</span>
<span class="nc" id="L734">            idx1 = leftToNew.get(idx1);</span>
<span class="nc" id="L735">            int idx2 = edge.getY();</span>
<span class="nc" id="L736">            idx2 = rightToNew.get(idx2);</span>
            
<span class="nc" id="L738">            TIntIntMap map1 = adjCostMap.get(idx1);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (map1 == null) {</span>
<span class="nc" id="L740">                map1 = new TIntIntHashMap();</span>
<span class="nc" id="L741">                adjCostMap.put(idx1, map1);</span>
            }
            // using a cost of 1 for all edges
<span class="nc" id="L744">            map1.put(idx2, 1);</span>
            
<span class="nc" id="L746">            TIntIntMap map2 = adjCostMap.get(idx2);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (map2 == null) {</span>
<span class="nc" id="L748">                map2 = new TIntIntHashMap();</span>
<span class="nc" id="L749">                adjCostMap.put(idx2, map2);</span>
            }
            // using a cost of 1 for all edges
<span class="nc" id="L752">            map2.put(idx1, 1);</span>
<span class="nc" id="L753">        }</span>
                
        // use prim's mst to make a maximal set of edges
<span class="nc" id="L756">        PrimsMST prims = new PrimsMST();</span>
<span class="nc" id="L757">        prims.calculateMinimumSpanningTree(</span>
            nVertexes, adjCostMap); 
<span class="nc" id="L759">        int[] prev = prims.getPrecessorArray();</span>
<span class="nc" id="L760">        log.fine(&quot;predecessors=&quot; + Arrays.toString(prev));</span>
        
<span class="nc" id="L762">        edges.clear();</span>
        
<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (int idx2 = 0; idx2 &lt; prev.length; ++idx2) {</span>
<span class="nc" id="L765">            int idx1 = prev[idx2];</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (idx1 == -1) {</span>
<span class="nc" id="L767">                continue;</span>
            }
            int t1, t2;
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (idx2 &lt; nL) {</span>
                //[left] = right
<span class="nc" id="L772">                t1 = idx2;</span>
<span class="nc" id="L773">                t2 = idx1;</span>
            } else {
                //[right] = left
<span class="nc" id="L776">                t1 = idx1;</span>
<span class="nc" id="L777">                t2 = idx2;</span>
            }
            
<span class="nc" id="L780">            t1 = revLeftToNew.get(t1);            </span>
<span class="nc" id="L781">            t2 = revRightToNew.get(t2);</span>
         
<span class="nc" id="L783">            log.fine(&quot; passed filter1: &quot; + t1 + &quot;:&quot; + t2);</span>
            
<span class="nc" id="L785">            edges.add(new PairInt(t1, t2));            </span>
        }
        
<span class="nc" id="L788">        List&lt;PairInt&gt; edges2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L789">        int nIter = 0;</span>
<span class="nc" id="L790">        int nc = 0;</span>
<span class="nc bnc" id="L791" title="All 4 branches missed.">        while ((nIter == 0) || (nc &gt; 0)) {</span>
<span class="nc" id="L792">            nIter++;</span>
<span class="nc" id="L793">            TIntIntMap lF = new TIntIntHashMap();</span>
<span class="nc" id="L794">            TIntIntMap rF = new TIntIntHashMap();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            for (PairInt edge : edges) {</span>
<span class="nc" id="L796">                int idx1 = edge.getX();</span>
<span class="nc" id="L797">                int idx2 = edge.getY();</span>
                
<span class="nc bnc" id="L799" title="All 2 branches missed.">                if (!lF.containsKey(idx1)) {</span>
<span class="nc" id="L800">                    lF.put(idx1, 1);</span>
                } else {
<span class="nc" id="L802">                    int count = lF.get(idx1);</span>
<span class="nc" id="L803">                    lF.put(idx1, count + 1);</span>
                }
                
<span class="nc bnc" id="L806" title="All 2 branches missed.">                if (!rF.containsKey(idx2)) {</span>
<span class="nc" id="L807">                    rF.put(idx2, 1);</span>
                } else {
<span class="nc" id="L809">                    int count = rF.get(idx2);</span>
<span class="nc" id="L810">                    rF.put(idx2, count + 1);</span>
                }
<span class="nc" id="L812">            }</span>
            
            // add to edges2  edges w/
            // left indexes w/ frequency=1
            // right indexes w/ frequency=1
            // and remove those from edges
            
<span class="nc" id="L819">            nc = 0;</span>
            
<span class="nc" id="L821">            TIntIntIterator iter = lF.iterator();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">            for (int i = lF.size(); i-- &gt; 0;) {</span>
<span class="nc" id="L823">                iter.advance();                </span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                if (iter.value() == 1) {</span>
<span class="nc" id="L825">                    int idx1 = iter.key();</span>
<span class="nc" id="L826">                    PairInt p0 = null;</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                    for (PairInt p : edges) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                        if (p.getX() == idx1) {</span>
<span class="nc" id="L829">                            p0 = p;</span>
<span class="nc" id="L830">                            break;</span>
                        }
<span class="nc" id="L832">                    }</span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">                    assert (p0 != null);</span>
<span class="nc" id="L834">                    edges2.add(p0);</span>
<span class="nc" id="L835">                    edges.remove(p0);</span>
<span class="nc" id="L836">                    nc++;</span>
<span class="nc" id="L837">                }</span>
            }
            
<span class="nc" id="L840">            TIntIntIterator iter2 = rF.iterator();</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">            for (int i = rF.size(); i-- &gt; 0;) {</span>
<span class="nc" id="L842">                iter2.advance();                </span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">                if (iter2.value() == 1) {</span>
<span class="nc" id="L844">                    int idx2 = iter2.key();</span>
<span class="nc" id="L845">                    PairInt p0 = null;</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">                    for (PairInt p : edges) {</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">                        if (p.getY() == idx2) {</span>
<span class="nc" id="L848">                            p0 = p;</span>
<span class="nc" id="L849">                            break;</span>
                        }
<span class="nc" id="L851">                    }</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                    if (p0 != null) {</span>
<span class="nc" id="L853">                        edges2.add(p0);</span>
<span class="nc" id="L854">                        edges.remove(p0);</span>
<span class="nc" id="L855">                        nc++;</span>
                    }
<span class="nc" id="L857">                }</span>
            }
<span class="nc" id="L859">            log.fine(&quot;edges.size=&quot; + edges.size() + &quot; edges2.size=&quot;</span>
<span class="nc" id="L860">                + edges2.size());</span>
<span class="nc" id="L861">        }</span>
        
<span class="nc" id="L863">        edges2.addAll(edges);</span>

<span class="nc" id="L865">        return edges2;</span>
    }
    
    private List&lt;PairInt&gt; filter(Set&lt;PairInt&gt; edges) {
        
<span class="nc" id="L870">        List&lt;PairInt&gt; edges2 = new ArrayList&lt;PairInt&gt;();</span>
<span class="nc" id="L871">        int nIter = 0;</span>
<span class="nc" id="L872">        int nc = 0;</span>
<span class="nc bnc" id="L873" title="All 4 branches missed.">        while ((nIter == 0) || (nc &gt; 0)) {</span>
<span class="nc" id="L874">            nIter++;</span>
<span class="nc" id="L875">            TIntIntMap lF = new TIntIntHashMap();</span>
<span class="nc" id="L876">            TIntIntMap rF = new TIntIntHashMap();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            for (PairInt edge : edges) {</span>
<span class="nc" id="L878">                int idx1 = edge.getX();</span>
<span class="nc" id="L879">                int idx2 = edge.getY();</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                if (lF.containsKey(idx1)) {</span>
<span class="nc" id="L881">                    lF.put(idx1, 1);</span>
                } else {
<span class="nc" id="L883">                    int count = lF.get(idx1);</span>
<span class="nc" id="L884">                    lF.put(idx1, count + 1);</span>
                }
                
<span class="nc bnc" id="L887" title="All 2 branches missed.">                if (rF.containsKey(idx2)) {</span>
<span class="nc" id="L888">                    rF.put(idx2, 1);</span>
                } else {
<span class="nc" id="L890">                    int count = rF.get(idx2);</span>
<span class="nc" id="L891">                    rF.put(idx2, count + 1);</span>
                }
<span class="nc" id="L893">            }</span>
            
            // add to edges2  edges w/
            // left indexes w/ frequency=1
            // right indexes w/ frequency=1
            // and remove those from edges
            
<span class="nc" id="L900">            nc = 0;</span>
            
<span class="nc" id="L902">            TIntIntIterator iter = lF.iterator();</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">            for (int i = lF.size(); i-- &gt; 0;) {</span>
<span class="nc" id="L904">                iter.advance();</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                if (iter.value() == 1) {</span>
<span class="nc" id="L906">                    int idx1 = iter.key();</span>
<span class="nc" id="L907">                    PairInt p0 = null;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">                    for (PairInt p : edges) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">                        if (p.getX() == idx1) {</span>
<span class="nc" id="L910">                            p0 = p;</span>
<span class="nc" id="L911">                            break;</span>
                        }
<span class="nc" id="L913">                    }</span>
<span class="nc bnc" id="L914" title="All 4 branches missed.">                    assert (p0 != null);</span>
<span class="nc" id="L915">                    edges2.add(p0);</span>
<span class="nc" id="L916">                    edges.remove(p0);</span>
<span class="nc" id="L917">                    nc++;</span>
<span class="nc" id="L918">                }</span>
            }
            
<span class="nc" id="L921">            iter = rF.iterator();</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">            for (int i = rF.size(); i-- &gt; 0;) {</span>
<span class="nc" id="L923">                iter.advance();                </span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                if (iter.value() == 1) {</span>
<span class="nc" id="L925">                    int idx2 = iter.key();</span>
<span class="nc" id="L926">                    PairInt p0 = null;</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                    for (PairInt p : edges) {</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">                        if (p.getY() == idx2) {</span>
<span class="nc" id="L929">                            p0 = p;</span>
<span class="nc" id="L930">                            break;</span>
                        }
<span class="nc" id="L932">                    }</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">                    if (p0 != null) {</span>
<span class="nc" id="L934">                        edges2.add(p0);</span>
<span class="nc" id="L935">                        edges.remove(p0);</span>
<span class="nc" id="L936">                        nc++;</span>
                    }
<span class="nc" id="L938">                }</span>
            }
<span class="nc" id="L940">            log.fine(&quot;edges.size=&quot; + edges.size() + &quot; edges2.size=&quot;</span>
<span class="nc" id="L941">                + edges2.size());</span>
<span class="nc" id="L942">        }</span>
        
<span class="nc" id="L944">        edges2.addAll(edges);</span>

<span class="nc" id="L946">        return edges2;</span>
    }
    
    private void debug(Forest forest) {
        
<span class="nc bnc" id="L951" title="All 2 branches missed.">        for (Integer key : forest.getKeys()) {</span>

<span class="nc" id="L953">            DoubleLinkedCircularList tree = forest.get(key.intValue());</span>
            
<span class="nc" id="L955">            long n = tree.getNumberOfNodes();</span>
<span class="nc" id="L956">            HeapNode node = tree.getSentinel();</span>
<span class="nc" id="L957">            int j = 0;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">            while (j &lt; n) {</span>
<span class="nc" id="L959">                node = node.getLeft();</span>
                
<span class="nc" id="L961">                List&lt;PathNode&gt; path = extractNodes((PathNode)node);</span>
<span class="nc" id="L962">                int n2 = path.size();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                for (int ii = 0; ii &lt; n2; ++ii) {</span>
<span class="nc" id="L964">                    PathNode node1 = path.get(ii);</span>
<span class="nc" id="L965">                    log.info(&quot;forest[&quot; + key + &quot;] tree branch[&quot; </span>
<span class="nc" id="L966">                        + j + &quot;] node[&quot; + ii + &quot;]=&quot; + node1.toString());</span>
                }                    
<span class="nc" id="L968">                j++;</span>
<span class="nc" id="L969">            }</span>
<span class="nc" id="L970">        }            </span>
<span class="nc" id="L971">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
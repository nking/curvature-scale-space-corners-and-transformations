<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RegionAdjacencyGraphColor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.graphs</a> &gt; <span class="el_source">RegionAdjacencyGraphColor.java</span></div><h1>RegionAdjacencyGraphColor.java</h1><pre class="source lang-java linenums">package algorithms.graphs;

import algorithms.imageProcessing.CIEChromaticity;
import algorithms.imageProcessing.ColorHistogram;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.ImageProcessor;
import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.imageProcessing.segmentation.ColorSpace;
import algorithms.imageProcessing.segmentation.LabelToColorHelper;
import algorithms.util.PairInt;
import gnu.trove.map.TIntObjectMap;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import no.uib.cipr.matrix.sparse.FlexCompRowMatrix;

/**
 *
 * class to hold a list of region nodes and calculate an adjacency map
 * for them and pairwise color differences or similarity.
 * 
 * @author nichole
 */
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">public class RegionAdjacencyGraphColor extends RegionAdjacencyGraph {</span>
    
    /*
       4     
       3
       2       
       1      \|/_
       0 |/_  \|/_\|
         0  1  2   3
    
    For each pixel in img, the color difference or similarity to it's adjacent 
    pixels are calculated.  
    For each pixel, using a pattern of only calculating the neighbors for
    offsets (+1,0), (+1,+1), (0,+1), (-1,+1) calculates the edge without repeating
    a pair.
    
    The conversion from col, row to a single index will use the convention in 
    Image.java which is index = (row * width) + col.
    
    Also note that the normalized cuts class using the sparse matrix diffOrSim
    needs a symmetric matrix, so the pairs are stored in both [i][j] and [j][i].
    
    */
<span class="fc" id="L50">    protected FlexCompRowMatrix diffOrSim = null;</span>
    
<span class="fc" id="L52">    protected ColorSpace colorSpace = null;</span>
    
    protected final ImageExt img;
    
    protected final List&lt;NormalizedCutsNode&gt; nodes;
    
<span class="fc" id="L58">    private boolean ltRGB = false;</span>
    
    // TODO: experimental...
<span class="fc" id="L61">    private boolean useAdjMap = true;</span>
    
     /**
     * constructor.  
     *        
     * @param img 
     * @param labels double array of labels for each pixel using the convention
     * labels[pixelIndex]. Note that the labeled regions must be contiguous.
     */
    public RegionAdjacencyGraphColor(ImageExt img, int[] labels) {

<span class="fc" id="L72">        super(img, labels);  </span>
        
<span class="fc" id="L74">        this.img = img;</span>

        /*
        may make some improvements:
        (if the statement in the normalized cuts paper regarding bit significance
        is followed, I should be able to factor the doubles to integers.
        in that case, can use compression as I do in Image.java and
        find a linear algebra eigen solver which will use the get and set methods
        of my image class to keep the data small.
        Also note, that instead of using an eigen solver, could alternatively,
        use my two-point clustering code for the remaining logic.  the distance transform
        and histograms make the remaining logic very fast, but it is dependent upon
        the bounds of the data (that is maximum values of data points which would be
        differences here converted to integers).
        */
        
<span class="fc" id="L90">        int n = regions.size();</span>
<span class="fc" id="L91">        this.nodes = new ArrayList&lt;NormalizedCutsNode&gt;(n);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L93">            NormalizedCutsNode node = new NormalizedCutsNode(i);</span>
<span class="fc" id="L94">            nodes.add(node);</span>
        }
<span class="fc" id="L96">    }</span>
    
    public RAGCSubGraph createANodesGraph() {
<span class="fc" id="L99">        RAGCSubGraph g = new RAGCSubGraph(nodes, diffOrSim);</span>
<span class="fc" id="L100">        return g;</span>
    }
    
    public int[] relabelUsingNodes() {

//TODO: in the middle of using these as [row][col] so revisit for consistency check
        
<span class="fc" id="L107">        int n0 = labels.length;</span>
<span class="fc" id="L108">        int nPix = 0;</span>
        
<span class="fc" id="L110">        int[][] labels2 = new int[n0][];</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc" id="L112">            labels2[i] = new int[labels[i].length];</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">            for (int j = 0; j &lt; labels[i].length; ++j) {</span>
<span class="fc" id="L114">                int v = labels[i][j];</span>
<span class="fc" id="L115">                labels2[i][j] = nodes.get(v).getNCutsLabel();</span>
<span class="fc" id="L116">                ++nPix;</span>
            }
        }
<span class="pc bpc" id="L119" title="3 of 4 branches missed.">        assert(nPix == img.getNPixels());</span>

<span class="fc" id="L121">        int[] labeled = new int[nPix];</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (int i = 0; i &lt; n0; ++i) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            for (int j = 0; j &lt; labels2[i].length; ++j) {</span>
<span class="fc" id="L124">                int pixIdx = img.getInternalIndex(j, i);</span>
<span class="fc" id="L125">                labeled[pixIdx] = labels2[i][j];</span>
            }
        }
        
<span class="fc" id="L129">        return labeled;</span>
    }
    
    public void populateEdgesWithLowThreshRGBSimilarity(
        double sigma) {
<span class="nc" id="L134">        this.ltRGB = true;</span>
<span class="nc" id="L135">        populateEdgesWithColorSimilarity(ColorSpace.RGB,</span>
            sigma);
<span class="nc" id="L137">    }</span>
    
    public void populateEdgesWithLowThreshHSVSimilarity(
        double sigma) {
        
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (diffOrSim != null) {</span>
<span class="nc" id="L143">            throw new IllegalStateException(&quot;this method is expected to be invoked only once&quot;);</span>
        }
        
<span class="nc" id="L146">        this.colorSpace = ColorSpace.HSV;</span>
        
<span class="nc" id="L148">        int nNodes = regions.size();</span>
<span class="nc" id="L149">        int nCols = img.getWidth();</span>
<span class="nc" id="L150">        int nRows = img.getHeight();</span>

<span class="nc" id="L152">        diffOrSim = new FlexCompRowMatrix(nNodes, nNodes);</span>
                
        // calculate the average colors for each node
<span class="nc" id="L155">        float[][] nodeColors = calculateNodeAverageColors();</span>
        
        // calculate pairwise differences for adjacent nodes (similarity or distance edgeS)
        
<span class="nc" id="L159">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="nc" id="L161">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L163" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L164">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L165">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L167">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L170" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L171">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L173">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L176">                    continue;</span>
                }
<span class="nc" id="L178">                added.add(p);</span>
                
                // using max diff as the difference, so that normalized cuts
                // is less likely to merge (or more likely to see as not the same)
<span class="nc" id="L182">                double diff = Double.MIN_VALUE;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                for (int m = 0; m &lt; 3; ++m) {</span>
<span class="nc" id="L184">                    float d = nodeColors[m][idx1] - nodeColors[m][idx2];</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                    if (d &lt; 0) {</span>
<span class="nc" id="L186">                        d *= -1;</span>
                    }
<span class="nc bnc" id="L188" title="All 2 branches missed.">                    if (d &gt; diff) {</span>
<span class="nc" id="L189">                        diff = d;</span>
                    }
                }
  
                // set both [i][j] and [j][i] to make matrix symmetric
<span class="nc" id="L194">                diffOrSim.set(idx1, idx2, diff);</span>
<span class="nc" id="L195">                diffOrSim.set(idx2, idx1, diff);</span>
<span class="nc" id="L196">            }</span>
<span class="nc" id="L197">        }</span>

<span class="nc" id="L199">        added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L202">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L203">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L205">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L209">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L211">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L213" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L214">                    continue;</span>
                }
<span class="nc" id="L216">                added.add(p);</span>
                
                // set both [i][j] and [j][i] to make symmetric matrix
<span class="nc" id="L219">                double d = diffOrSim.get(idx1, idx2);</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">                assert(d == diffOrSim.get(idx2, idx1));</span>
<span class="nc" id="L221">                double similarity = Math.exp(-1*d*d/sigma);</span>
<span class="nc" id="L222">  System.out.println(&quot;similarity=&quot; + similarity);      </span>
<span class="nc" id="L223">                diffOrSim.set(idx1, idx2, similarity);</span>
<span class="nc" id="L224">                diffOrSim.set(idx2, idx1, similarity);</span>
<span class="nc" id="L225">            }</span>
<span class="nc" id="L226">        }        </span>
<span class="nc" id="L227">    }</span>
    
    public void populateEdgesWithHSVColorHistogramSimilarity(
        double sigma) {
        
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (diffOrSim != null) {</span>
<span class="nc" id="L233">            throw new IllegalStateException(&quot;this method is expected to be invoked only once&quot;);</span>
        }
        
<span class="nc" id="L236">        this.colorSpace = ColorSpace.HSV;</span>
        
<span class="nc" id="L238">        int nNodes = regions.size();</span>
<span class="nc" id="L239">        int nCols = img.getWidth();</span>
<span class="nc" id="L240">        int nRows = img.getHeight();</span>

<span class="nc" id="L242">        diffOrSim = new FlexCompRowMatrix(nNodes, nNodes);</span>
                
<span class="nc" id="L244">        int[][][] nodeCH = calculateNodeHSVHistograms();</span>
        
<span class="nc" id="L246">        ColorHistogram clrHist = new ColorHistogram();</span>
        
<span class="nc" id="L248">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L251">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L252">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L254">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L257" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L258">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L260">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L263">                    continue;</span>
                }
<span class="nc" id="L265">                added.add(p);</span>
                
<span class="nc" id="L267">                float diff = clrHist.intersection(nodeCH[idx1], nodeCH[idx2]);</span>
                
                // set both [i][j] and [j][i] to make matrix symmetric
<span class="nc" id="L270">                diffOrSim.set(idx1, idx2, diff);</span>
<span class="nc" id="L271">                diffOrSim.set(idx2, idx1, diff);</span>
<span class="nc" id="L272">            }</span>
<span class="nc" id="L273">        }</span>

<span class="nc" id="L275">        added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L277" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L278">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L279">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L281">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L285">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L287">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L289" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L290">                    continue;</span>
                }
<span class="nc" id="L292">                added.add(p);</span>
                
                // set both [i][j] and [j][i] to make symmetric matrix
<span class="nc" id="L295">                double d = diffOrSim.get(idx1, idx2);</span>
<span class="nc bnc" id="L296" title="All 4 branches missed.">                assert(d == diffOrSim.get(idx2, idx1));</span>
<span class="nc" id="L297">                double similarity = Math.exp(-1*d*d/sigma);</span>
<span class="nc" id="L298">  System.out.println(&quot;ch similarity=&quot; + similarity);      </span>
<span class="nc" id="L299">                diffOrSim.set(idx1, idx2, similarity);</span>
<span class="nc" id="L300">                diffOrSim.set(idx2, idx1, similarity);</span>
<span class="nc" id="L301">            }</span>
<span class="nc" id="L302">        }        </span>
<span class="nc" id="L303">    }</span>
    
    public void populateEdgesWithLowThreshHSVHistogramSimilarity(
        double sigma) {
        
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (diffOrSim != null) {</span>
<span class="nc" id="L309">            throw new IllegalStateException(&quot;this method is expected to be invoked only once&quot;);</span>
        }
        
<span class="nc" id="L312">        this.colorSpace = ColorSpace.HSV;</span>
        
<span class="nc" id="L314">        int nNodes = regions.size();</span>
<span class="nc" id="L315">        int nCols = img.getWidth();</span>
<span class="nc" id="L316">        int nRows = img.getHeight();</span>

<span class="nc" id="L318">        diffOrSim = new FlexCompRowMatrix(nNodes, nNodes);</span>
                
        // calculate the average colors for each node
<span class="nc" id="L321">        float[][] nodeColors = calculateNodeAverageColors();</span>
    
        // calculate pairwise differences for adjacent nodes (similarity or distance edgeS)
        
<span class="nc" id="L325">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="nc" id="L327">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L330">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L331">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L333">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L337">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L339">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L341" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L342">                    continue;</span>
                }
<span class="nc" id="L344">                added.add(p);</span>
                
                // using max diff as the difference, so that normalized cuts
                // is less likely to merge (or more likely to see as not the same)
<span class="nc" id="L348">                double diff = Double.MIN_VALUE;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                for (int m = 0; m &lt; 3; ++m) {</span>
<span class="nc" id="L350">                    float d = nodeColors[m][idx1] - nodeColors[m][idx2];</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (d &lt; 0) {</span>
<span class="nc" id="L352">                        d *= -1;</span>
                    }
<span class="nc bnc" id="L354" title="All 2 branches missed.">                    if (d &gt; diff) {</span>
<span class="nc" id="L355">                        diff = d;</span>
                    }
                }
  
                // set both [i][j] and [j][i] to make matrix symmetric
<span class="nc" id="L360">                diffOrSim.set(idx1, idx2, diff);</span>
<span class="nc" id="L361">                diffOrSim.set(idx2, idx1, diff);</span>
<span class="nc" id="L362">            }</span>
<span class="nc" id="L363">        }</span>

<span class="nc" id="L365">        added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L368">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L369">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L371">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L375">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L377">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L379" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L380">                    continue;</span>
                }
<span class="nc" id="L382">                added.add(p);</span>
                
                // set both [i][j] and [j][i] to make symmetric matrix
<span class="nc" id="L385">                double d = diffOrSim.get(idx1, idx2);</span>
<span class="nc bnc" id="L386" title="All 4 branches missed.">                assert(d == diffOrSim.get(idx2, idx1));</span>
<span class="nc" id="L387">                double similarity = Math.exp(-1*d*d/sigma);</span>
<span class="nc" id="L388">  System.out.println(&quot;similarity=&quot; + similarity);      </span>
<span class="nc" id="L389">                diffOrSim.set(idx1, idx2, similarity);</span>
<span class="nc" id="L390">                diffOrSim.set(idx2, idx1, similarity);</span>
<span class="nc" id="L391">            }</span>
<span class="nc" id="L392">        }        </span>
<span class="nc" id="L393">    }</span>
   
    public void populateEdgesWithColorSimilarity(
        ColorSpace clrSpace, double sigma) {
        
<span class="fc" id="L398">        populatePairDifferences(clrSpace);</span>

<span class="fc" id="L400">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="fc" id="L403">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L404">            int idx1 = index1.intValue();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">            for (Integer index2 : entry.getValue()) {</span>
<span class="fc" id="L406">                int idx2 = index2.intValue();</span>
<span class="pc bpc" id="L407" title="3 of 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="fc bfc" id="L409" title="All 2 branches covered.">                if (idx1 &lt; idx2) {</span>
<span class="fc" id="L410">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="fc" id="L412">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="fc bfc" id="L414" title="All 2 branches covered.">                if (added.contains(p)) {</span>
<span class="fc" id="L415">                    continue;</span>
                }
<span class="fc" id="L417">                added.add(p);</span>
                
                // set both [i][j] and [j][i] to make symmetric matrix
<span class="fc" id="L420">                double d = diffOrSim.get(idx1, idx2);</span>
<span class="pc bpc" id="L421" title="3 of 4 branches missed.">                assert(d == diffOrSim.get(idx2, idx1));</span>
<span class="fc" id="L422">                double similarity = Math.exp(-1*d*d/sigma);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">                if (useAdjMap) {</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">                    if (!adjacencyMap.containsKey(index1) ||</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                    !adjacencyMap.get(index1).contains(index2)) {</span>
<span class="nc" id="L426">                        similarity = 0;</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">                    } else if (!adjacencyMap.containsKey(index2) ||</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">                    !adjacencyMap.get(index2).contains(index1)) {</span>
<span class="nc" id="L429">                        similarity = 0;</span>
                    }
                }
<span class="fc" id="L432">                diffOrSim.set(idx1, idx2, similarity);</span>
<span class="fc" id="L433">                diffOrSim.set(idx2, idx1, similarity);</span>
<span class="fc" id="L434">            }</span>
<span class="fc" id="L435">        }</span>
<span class="fc" id="L436">    }</span>
    
    public void populateEdgesWithColorDifference(ColorSpace clrSpace) {
        
<span class="nc" id="L440">        populatePairDifferences(clrSpace);</span>
        
<span class="nc" id="L442">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="nc" id="L445">            Integer index1 = entry.getKey();</span>
<span class="nc" id="L446">            int idx1 = index1.intValue();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            for (Integer index2 : entry.getValue()) {</span>
<span class="nc" id="L448">                int idx2 = index2.intValue();</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (idx1 &lt; idx2) {</span>
<span class="nc" id="L452">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="nc" id="L454">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="nc bnc" id="L456" title="All 2 branches missed.">                if (added.contains(p)) {</span>
<span class="nc" id="L457">                    continue;</span>
                }
<span class="nc" id="L459">                added.add(p);</span>
                
                // set both [i][j] and [j][i] to make symmetric matrix
<span class="nc" id="L462">                double d = diffOrSim.get(idx1, idx2);</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">                assert(d == diffOrSim.get(idx2, idx1));</span>
<span class="nc" id="L464">                double diff = Math.abs(d);</span>
<span class="nc" id="L465">                diffOrSim.set(idx1, idx2, diff);</span>
<span class="nc" id="L466">                diffOrSim.set(idx2, idx1, diff);</span>
<span class="nc" id="L467">            }</span>
<span class="nc" id="L468">        }</span>
<span class="nc" id="L469">    }</span>
    
    public boolean isWithinImageBounds(int col, int row) {
<span class="nc bnc" id="L472" title="All 8 branches missed.">        if ((col &gt; (imageWidth - 1)) || (row &gt; (imageHeight - 1)) ||</span>
            (col &lt; 0) || (row &lt; 0)) {
<span class="nc" id="L474">            return false;</span>
        }
<span class="nc" id="L476">        return true;</span>
    }
    
    public int getImageWith() {
<span class="nc" id="L480">        return imageWidth;</span>
    }
    public int getImageHeight() {
<span class="nc" id="L483">        return imageHeight;</span>
    }
    
    public int calculatePixelIndex(int row, int col) {
<span class="nc" id="L487">        return (row * imageWidth) + col;</span>
    }
    public int getRowFromPixelIndex(int pixIdx) {
<span class="nc" id="L490">        return pixIdx/imageWidth;</span>
    }
    public int getColFromPixelIndex(int pixIdx) {
<span class="nc" id="L493">        int row = pixIdx/imageWidth;</span>
<span class="nc" id="L494">        return pixIdx - (row * imageWidth);</span>
    }
    
    private float[][] calculateNodeAverageColors() {
        
<span class="fc" id="L499">        int nNodes = regions.size();</span>
<span class="fc" id="L500">        int nCols = img.getWidth();</span>
<span class="fc" id="L501">        int nRows = img.getHeight();</span>

<span class="fc" id="L503">        diffOrSim = new FlexCompRowMatrix(nNodes, nNodes);</span>
                
        // calculate the average colors for each node
<span class="fc" id="L506">        float[][] nodeColors = new float[3][nNodes];</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L508">            nodeColors[i] = new float[nNodes];</span>
        }
<span class="fc" id="L510">        int[] count = new int[nNodes];</span>
        
<span class="fc" id="L512">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="fc" id="L514">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
<span class="fc bfc" id="L516" title="All 2 branches covered.">        for (int row = 0; row &lt; nRows; ++row) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            for (int col = 0; col &lt; nCols; ++col) {</span>

<span class="fc" id="L519">                int label = labels[row][col];</span>
                
<span class="fc" id="L521">                nodeColors[0][label] += img.getR(col, row);</span>
<span class="fc" id="L522">                nodeColors[1][label] += img.getG(col, row);</span>
<span class="fc" id="L523">                nodeColors[2][label] += img.getB(col, row);</span>
                
<span class="fc" id="L525">                count[label]++;</span>
            }
        }
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (int i = 0; i &lt; nNodes; ++i) {</span>
<span class="fc" id="L529">            nodeColors[0][i] /= (float)count[i];</span>
<span class="fc" id="L530">            nodeColors[1][i] /= (float)count[i];</span>
<span class="fc" id="L531">            nodeColors[2][i] /= (float)count[i];</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">            if (colorSpace.equals(ColorSpace.HSV)) {</span>
<span class="fc" id="L533">                float[] hsb = new float[3];</span>
<span class="fc" id="L534">                Color.RGBtoHSB(Math.round(nodeColors[0][i]), </span>
<span class="fc" id="L535">                    Math.round(nodeColors[1][i]), </span>
<span class="fc" id="L536">                    Math.round(nodeColors[2][i]), hsb);</span>
<span class="fc" id="L537">                nodeColors[0][i] = hsb[0];</span>
<span class="fc" id="L538">                nodeColors[1][i] = hsb[1];</span>
<span class="fc" id="L539">                nodeColors[2][i] = hsb[2];</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            } else if (colorSpace.equals(ColorSpace.CIELAB)) {</span>
<span class="nc" id="L541">                float[] lab = cieC.rgbToCIELAB1931(</span>
<span class="nc" id="L542">                    Math.round(nodeColors[0][i]), </span>
<span class="nc" id="L543">                    Math.round(nodeColors[1][i]), </span>
<span class="nc" id="L544">                    Math.round(nodeColors[2][i]));</span>
<span class="nc" id="L545">                nodeColors[0][i] = lab[0];</span>
<span class="nc" id="L546">                nodeColors[1][i] = lab[1];</span>
<span class="nc" id="L547">                nodeColors[2][i] = lab[2];</span>
<span class="pc bfc" id="L548" title="All 2 branches covered.">            } else if (colorSpace.equals(ColorSpace.POLAR_CIELAB)) {</span>
<span class="fc" id="L549">                int polarT = imageProcessor.calculateCIELABTheta(</span>
<span class="fc" id="L550">                    Math.round(nodeColors[0][i]), </span>
<span class="fc" id="L551">                    Math.round(nodeColors[1][i]), </span>
<span class="fc" id="L552">                    Math.round(nodeColors[2][i]), 255</span>
                );
                // TODO: make a graph for 1-D color space.
                //  this is a quick fudge to look at results
<span class="fc" id="L556">                nodeColors[0][i] = polarT;</span>
<span class="fc" id="L557">                nodeColors[1][i] = polarT;</span>
<span class="fc" id="L558">                nodeColors[2][i] = polarT;</span>
            }
        }
        
<span class="fc" id="L562">        return nodeColors;</span>
    }
        
    /**
     * 
     * @return [nNodes][h,s,v][16]
     */
    private int[][][] calculateNodeHSVHistograms() {
        
<span class="nc" id="L571">        int nNodes = regions.size();</span>
<span class="nc" id="L572">        int nCols = img.getWidth();</span>
<span class="nc" id="L573">        int nRows = img.getHeight();</span>

<span class="nc" id="L575">        diffOrSim = new FlexCompRowMatrix(nNodes, nNodes);</span>
          
        // NOTE: this is made in region adjacency graph and
        // could be saved from earlier step
<span class="nc" id="L579">        TIntObjectMap&lt;Set&lt;PairInt&gt;&gt; labelMap = LabelToColorHelper</span>
<span class="nc" id="L580">            .extractRowMajorLabelPoints(img, labels);</span>
        
<span class="nc" id="L582">        int nl = labelMap.size();</span>
        
<span class="nc bnc" id="L584" title="All 4 branches missed.">        assert(nl == nNodes);</span>
        
<span class="nc" id="L586">        ColorHistogram clrHist = new ColorHistogram();</span>
        
        // calculate the average colors for each node
<span class="nc" id="L589">        int[][][] nodeColors = new int[nNodes][][];</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        for (int i = 0; i &lt; nNodes; ++i) {</span>
<span class="nc" id="L591">            Set&lt;PairInt&gt; points = labelMap.get(i);</span>
<span class="nc" id="L592">            nodeColors[i] = clrHist.histogramHSV(img, points);</span>
        }
                
<span class="nc" id="L595">        return nodeColors;</span>
    }
        
    private void populatePairDifferences(ColorSpace clrSpace) {
        
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (diffOrSim != null) {</span>
<span class="nc" id="L601">            throw new IllegalStateException(&quot;this method is expected to be invoked only once&quot;);</span>
        }
        
<span class="fc" id="L604">        this.colorSpace = clrSpace;</span>
        
<span class="fc" id="L606">        int nNodes = regions.size();</span>
<span class="fc" id="L607">        int nCols = img.getWidth();</span>
<span class="fc" id="L608">        int nRows = img.getHeight();</span>

<span class="fc" id="L610">        diffOrSim = new FlexCompRowMatrix(nNodes, nNodes);</span>
                
        // calculate the average colors for each node
<span class="fc" id="L613">        float[][] nodeColors = calculateNodeAverageColors();</span>
        
        // calculate pairwise differences for adjacent nodes (similarity or distance edgeS)
        
<span class="fc" id="L617">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
<span class="fc" id="L619">        Set&lt;PairInt&gt; added = new HashSet&lt;PairInt&gt;();</span>
    
<span class="fc bfc" id="L621" title="All 2 branches covered.">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : adjacencyMap.entrySet()) {</span>
<span class="fc" id="L622">            Integer index1 = entry.getKey();</span>
<span class="fc" id="L623">            int idx1 = index1.intValue();</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">            for (Integer index2 : entry.getValue()) {</span>
<span class="fc" id="L625">                int idx2 = index2.intValue();</span>
<span class="pc bpc" id="L626" title="3 of 4 branches missed.">                assert(idx1 != idx2);</span>
                PairInt p;
<span class="fc bfc" id="L628" title="All 2 branches covered.">                if (idx1 &lt; idx2) {</span>
<span class="fc" id="L629">                    p = new PairInt(idx1, idx2);</span>
                } else {
<span class="fc" id="L631">                    p = new PairInt(idx2, idx1);</span>
                }
<span class="fc bfc" id="L633" title="All 2 branches covered.">                if (added.contains(p)) {</span>
<span class="fc" id="L634">                    continue;</span>
                }
<span class="fc" id="L636">                added.add(p);</span>
                
<span class="fc" id="L638">                float sumDiff = 0;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                for (int m = 0; m &lt; 3; ++m) {</span>
<span class="fc" id="L640">                    float d = nodeColors[m][idx1] - nodeColors[m][idx2];</span>
<span class="fc" id="L641">                    sumDiff += Math.sqrt(d * d);</span>
                }
<span class="fc" id="L643">                double diff = Math.sqrt(sumDiff);</span>
                
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                if (useAdjMap) {</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                    if (!adjacencyMap.containsKey(index1) ||</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">                    !adjacencyMap.get(index1).contains(index2)) {</span>
<span class="nc" id="L648">                        diff = Double.MAX_VALUE;</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                    } else if (!adjacencyMap.containsKey(index2) ||</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                    !adjacencyMap.get(index2).contains(index1)) {</span>
<span class="nc" id="L651">                        diff = Double.MAX_VALUE;</span>
                    }
                }
                
                // set both [i][j] and [j][i] to make matrix symmetric
<span class="fc" id="L656">                diffOrSim.set(idx1, idx2, diff);</span>
<span class="fc" id="L657">                diffOrSim.set(idx2, idx1, diff);</span>
<span class="fc" id="L658">            }</span>
<span class="fc" id="L659">        }                                       </span>
<span class="fc" id="L660">    }</span>
    
    /*
       calculate the normalized cute between regions regionIndex1 and
       regionIndex2 using
       normalized_cut(A, B) = 2 - normalized_assoc(A, B);
     
                               assoc(A, A) 
         normalized_assoc(A) = ----------- 
                               assoc(A, V)
                               
         where assoc(A, A) is the sum of all edges within region A
         and assoc(A, V) is the sum of all edges from A to another region.
    */
    
    public double[] calculateCentroidOfRegion(int regionIndex) {
<span class="nc" id="L676">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
<span class="nc" id="L677">        return curveHelper.calculateXYCentroids(regions.get(regionIndex).getPoints());</span>
    }
    
    /**
     * get the edge weights matrix of differences or similarity between 
     * image pixels as a sparse symmetric matrix. 
     * @return 
     */
    public FlexCompRowMatrix getEdgeMatrix() {
<span class="fc" id="L686">        return diffOrSim;</span>
    }
    
    public Set&lt;PairInt&gt; getRegionPoints(int regionIndex) {
<span class="nc" id="L690">        return regions.get(regionIndex).getPoints();</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
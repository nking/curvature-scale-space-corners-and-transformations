<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LBFGS.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.brendano.LBFGS</a> &gt; <span class="el_source">LBFGS.java</span></div><h1>LBFGS.java</h1><pre class="source lang-java linenums">package thirdparty.brendano.LBFGS;

import java.util.Arrays;

/**
 * The class implements a local search/optimization method that is 
 * quasi-Newton called L-BFGS by Broyden-Fletcher-Goldfarb-Shanno.
 * 
 * The code was imported from 
 * https://github.com/brendano/myutil/blob/master/src/util/LBFGS.java 
 * which has license: GPL version 2 
 * and the following documentation:
 *
 * a port of liblbfgs to java http://www.chokkan.org/software/liblbfgs/
 *
 *
 * @mainpage libLBFGS: a library of Limited-memory
 * Broyden-Fletcher-Goldfarb-Shanno (L-BFGS)
 *
 * @section intro Introduction
 *
 * This library is a C port of the implementation of Limited-memory
 * Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal.
 * The original FORTRAN source code is available at:
 * http://www.ece.northwestern.edu/~nocedal/lbfgs.html
 *
 * The L-BFGS method solves the unconstrainted minimization problem,
 *
 * &lt;pre&gt;
 * minimize F(x), x = (x1, x2, ..., xN),
 * &lt;/pre&gt;
 *
 * only if the objective function F(x) and its gradient G(x) are computable. The
 * well-known Newton's method requires computation of the inverse of the hessian
 * matrix of the objective function. However, the computational cost for the
 * inverse hessian matrix is expensive especially when the objective function
 * takes a large number of variables. The L-BFGS method iteratively finds a
 * minimizer by approximating the inverse hessian matrix by information from
 * last m iterations. This innovation saves the memory storage and computational
 * time drastically for large-scaled problems.
 *
 * Among the various ports of L-BFGS, this library provides several features: -
 * &lt;b&gt;Optimization with L1-norm (Orthant-Wise Limited-memory Quasi-Newton
 * (OWL-QN) method)&lt;/b&gt;: In addition to standard minimization problems, the
 * library can minimize a function F(x) combined with L1-norm |x| of the
 * variables, {F(x) + C |x|}, where C is a constant scalar parameter. This
 * feature is useful for estimating parameters of sparse log-linear models
 * (e.g., logistic regression and maximum entropy) with L1-regularization (or
 * Laplacian prior). - &lt;b&gt;Clean C code&lt;/b&gt;: Unlike C codes generated
 * automatically by f2c (Fortran 77 into C converter), this port includes
 * changes based on my interpretations, improvements, optimizations, and
 * clean-ups so that the ported code would be well-suited for a C code. In
 * addition to comments inherited from the original code, a number of comments
 * were added through my interpretations. - &lt;b&gt;Callback interface&lt;/b&gt;: The
 * library receives function and gradient values via a callback interface. The
 * library also notifies the progress of the optimization by invoking a callback
 * function. In the original implementation, a user had to set function and
 * gradient values every time the function returns for obtaining updated values.
 * - &lt;b&gt;Thread safe&lt;/b&gt;: The library is thread-safe, which is the secondary gain
 * from the callback interface. - &lt;b&gt;Cross platform.&lt;/b&gt; The source code can be
 * compiled on Microsoft Visual Studio 2010, GNU C Compiler (gcc), etc. -
 * &lt;b&gt;Configurable precision&lt;/b&gt;: A user can choose single-precision (float) or
 * double-precision (double) accuracy by changing ::LBFGS_FLOAT macro. -
 * &lt;b&gt;SSE/SSE2 optimization&lt;/b&gt;: This library includes SSE/SSE2 optimization
 * (written in compiler intrinsics) for vector arithmetic operations on
 * Intel/AMD processors. The library uses SSE for float values and SSE2 for
 * double values. The SSE/SSE2 optimization routine is disabled by default.
 *
 * This library is used by: -
 * &lt;a href=&quot;http://www.chokkan.org/software/crfsuite/&quot;&gt;CRFsuite: A fast
 * implementation of Conditional Random Fields (CRFs)&lt;/a&gt;
 * - &lt;a href=&quot;http://www.chokkan.org/software/classias/&quot;&gt;Classias: A collection
 * of machine-learning algorithms for classification&lt;/a&gt;
 * - &lt;a href=&quot;http://www.public.iastate.edu/~gdancik/mlegp/&quot;&gt;mlegp: an R package
 * for maximum likelihood estimates for Gaussian processes&lt;/a&gt;
 * - &lt;a href=&quot;http://infmath.uibk.ac.at/~matthiasf/imaging2/&quot;&gt;imaging2: the
 * imaging2 class library&lt;/a&gt;
 * -
 * &lt;a href=&quot;http://search.cpan.org/~laye/Algorithm-LBFGS-0.16/&quot;&gt;Algorithm::LBFGS
 * - Perl extension for L-BFGS&lt;/a&gt;
 * - &lt;a href=&quot;http://www.cs.kuleuven.be/~bernd/yap-lbfgs/&quot;&gt;YAP-LBFGS (an
 * interface to call libLBFGS from YAP Prolog)&lt;/a&gt;
 *
 * @section download Download
 *
 * -
 * &lt;a href=&quot;https://github.com/downloads/chokkan/liblbfgs/liblbfgs-1.10.tar.gz&quot;&gt;Source
 * code&lt;/a&gt;
 * - &lt;a href=&quot;https://github.com/chokkan/liblbfgs&quot;&gt;GitHub repository&lt;/a&gt;
 *
 * libLBFGS is distributed under the term of the
 * &lt;a href=&quot;http://opensource.org/licenses/mit-license.php&quot;&gt;MIT license&lt;/a&gt;.
 *
 * @section api Documentation
 *
 * - @ref liblbfgs_api &quot;libLBFGS API&quot;
 *
 * @section sample Sample code
 *
 * @include sample.c
 *
 * @section ack Acknowledgements
 *
 * The L-BFGS algorithm is described in: - Jorge Nocedal. Updating Quasi-Newton
 * Matrices with Limited Storage.
 * &lt;i&gt;Mathematics of Computation&lt;/i&gt;, Vol. 35, No. 151, pp. 773--782, 1980. -
 * Dong C. Liu and Jorge Nocedal. On the limited memory BFGS method for large
 * scale optimization.
 * &lt;i&gt;Mathematical Programming&lt;/i&gt; B, Vol. 45, No. 3, pp. 503-528, 1989.
 *
 * The line search algorithms used in this implementation are described in: -
 * John E. Dennis and Robert B. Schnabel.
 * &lt;i&gt;Numerical Methods for Unconstrained Optimization and Nonlinear
 * Equations&lt;/i&gt;, Englewood Cliffs, 1983. - Jorge J. More and David J. Thuente.
 * Line search algorithm with guaranteed sufficient decrease.
 * &lt;i&gt;ACM Transactions on Mathematical Software (TOMS)&lt;/i&gt;, Vol. 20, No. 3, pp.
 * 286-307, 1994.
 *
 * This library also implements Orthant-Wise Limited-memory Quasi-Newton
 * (OWL-QN) method presented in: - Galen Andrew and Jianfeng Gao. Scalable
 * training of L1-regularized log-linear models. In &lt;i&gt;Proceedings of the 24th
 * International Conference on Machine Learning (ICML 2007)&lt;/i&gt;, pp. 33-40,
 * 2007.
 *
 * @section reference Reference
 *
 * - &lt;a href=&quot;http://www.ece.northwestern.edu/~nocedal/lbfgs.html&quot;&gt;L-BFGS&lt;/a&gt; by
 * Jorge Nocedal. -
 * &lt;a href=&quot;http://research.microsoft.com/en-us/downloads/b1eb1016-1738-4bd5-83a9-370c9d498a03/default.aspx&quot;&gt;Orthant-Wise
 * Limited-memory Quasi-Newton Optimizer for L1-regularized Objectives&lt;/a&gt; by
 * Galen Andrew. - &lt;a href=&quot;http://chasen.org/~taku/software/misc/lbfgs/&quot;&gt;C port
 * (via f2c)&lt;/a&gt; by Taku Kudo. -
 * &lt;a href=&quot;http://www.alglib.net/optimization/lbfgs.php&quot;&gt;C#/C++/Delphi/VisualBasic6
 * port&lt;/a&gt; in ALGLIB. - &lt;a href=&quot;http://cctbx.sourceforge.net/&quot;&gt;Computational
 * Crystallography Toolbox&lt;/a&gt; includes
 * &lt;a href=&quot;http://cctbx.sourceforge.net/current_cvs/c_plus_plus/namespacescitbx_1_1lbfgs.html&quot;&gt;scitbx::lbfgs&lt;/a&gt;.
 */
<span class="nc" id="L138">public class LBFGS {</span>

    /*
	 *      C library of Limited memory BFGS (L-BFGS).
	 *
	 * Copyright (c) 1990, Jorge Nocedal
	 * Copyright (c) 2007-2010 Naoaki Okazaki
	 * All rights reserved.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the &quot;Software&quot;), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
     */

 /* $Id$ */

 /*
	 * The default precision of floating point values is 64bit (double).
     */
//	static final int LBFGS_FLOAT  = 64;

    /*
	 * Activate optimization routines for IEEE754 floating point values.
     */
//	#ifndef LBFGS_IEEE_FLOAT
//	#define LBFGS_IEEE_FLOAT    1
//	#endif/*LBFGS_IEEE_FLOAT*/
//	#if     LBFGS_FLOAT == 32
//	typedef float lbfgsfloatval_t;
//
//	#elif   LBFGS_FLOAT == 64
//	typedef double lbfgsfloatval_t;
//
//	#else
//	#error &quot;libLBFGS supports single (float; LBFGS_FLOAT = 32) or double (double; LBFGS_FLOAT=64) precision only.&quot;
//
//	#endif
    /**
     * \addtogroup liblbfgs_api libLBFGS API
     *
     * @{
     *
     * The libLBFGS API.
     */
    /**
     * Return values of lbfgs().
     *
     * Roughly speaking, a negative value indicates an error.
     */
    public static enum Status {
        /**
         * L-BFGS reaches convergence.
         */
        LBFGS_SUCCESS,
        LBFGS_STOP,
        /**
         * The initial variables already minimize the objective function.
         */
        LBFGS_ALREADY_MINIMIZED,
        /**
         * Unknown error.
         */
        LBFGSERR_UNKNOWNERROR,
        /**
         * Logic error.
         */
        LBFGSERR_LOGICERROR,
        /**
         * Insufficient memory.
         */
        LBFGSERR_OUTOFMEMORY,
        /**
         * The minimization process has been canceled.
         */
        LBFGSERR_CANCELED,
        /**
         * Invalid number of variables specified.
         */
        LBFGSERR_INVALID_N,
        /**
         * Invalid number of variables (for SSE) specified.
         */
        LBFGSERR_INVALID_N_SSE,
        /**
         * The array x must be aligned to 16 (for SSE).
         */
        LBFGSERR_INVALID_X_SSE,
        /**
         * Invalid parameter lbfgs_parameter_t::epsilon specified.
         */
        LBFGSERR_INVALID_EPSILON,
        /**
         * Invalid parameter lbfgs_parameter_t::past specified.
         */
        LBFGSERR_INVALID_TESTPERIOD,
        /**
         * Invalid parameter lbfgs_parameter_t::delta specified.
         */
        LBFGSERR_INVALID_DELTA,
        /**
         * Invalid parameter lbfgs_parameter_t::linesearch specified.
         */
        LBFGSERR_INVALID_LINESEARCH,
        /**
         * Invalid parameter lbfgs_parameter_t::max_step specified.
         */
        LBFGSERR_INVALID_MINSTEP,
        /**
         * Invalid parameter lbfgs_parameter_t::max_step specified.
         */
        LBFGSERR_INVALID_MAXSTEP,
        /**
         * Invalid parameter lbfgs_parameter_t::ftol specified.
         */
        LBFGSERR_INVALID_FTOL,
        /**
         * Invalid parameter lbfgs_parameter_t::wolfe specified.
         */
        LBFGSERR_INVALID_WOLFE,
        /**
         * Invalid parameter lbfgs_parameter_t::gtol specified.
         */
        LBFGSERR_INVALID_GTOL,
        /**
         * Invalid parameter lbfgs_parameter_t::xtol specified.
         */
        LBFGSERR_INVALID_XTOL,
        /**
         * Invalid parameter lbfgs_parameter_t::max_linesearch specified.
         */
        LBFGSERR_INVALID_MAXLINESEARCH,
        /**
         * Invalid parameter lbfgs_parameter_t::orthantwise_c specified.
         */
        LBFGSERR_INVALID_ORTHANTWISE,
        /**
         * Invalid parameter lbfgs_parameter_t::orthantwise_start specified.
         */
        LBFGSERR_INVALID_ORTHANTWISE_START,
        /**
         * Invalid parameter lbfgs_parameter_t::orthantwise_end specified.
         */
        LBFGSERR_INVALID_ORTHANTWISE_END,
        /**
         * The line-search step went out of the interval of uncertainty.
         */
        LBFGSERR_OUTOFINTERVAL,
        /**
         * A logic error occurred; alternatively, the interval of uncertainty
         * became too small.
         */
        LBFGSERR_INCORRECT_TMINMAX,
        /**
         * A rounding error occurred; alternatively, no line-search step
         * satisfies the sufficient decrease and curvature conditions.
         */
        LBFGSERR_ROUNDING_ERROR,
        /**
         * The line-search step became smaller than lbfgs_parameter_t::min_step.
         */
        LBFGSERR_MINIMUMSTEP,
        /**
         * The line-search step became larger than lbfgs_parameter_t::max_step.
         */
        LBFGSERR_MAXIMUMSTEP,
        /**
         * The line-search routine reaches the maximum number of evaluations.
         */
        LBFGSERR_MAXIMUMLINESEARCH,
        /**
         * The algorithm routine reaches the maximum number of iterations.
         */
        LBFGSERR_MAXIMUMITERATION,
        /**
         * Relative width of the interval of uncertainty is at most
         * lbfgs_parameter_t::xtol.
         */
        LBFGSERR_WIDTHTOOSMALL,
        /**
         * A logic error (negative line-search step) occurred.
         */
        LBFGSERR_INVALIDPARAMETERS,
        /**
         * The current search direction increases the objective function value.
         */
        LBFGSERR_INCREASEGRADIENT;

        public boolean hasConverged() {
            return this == LBFGS_SUCCESS || this == LBFGS_STOP;
        }

        public boolean isError() {
            return this != LBFGS_SUCCESS &amp;&amp; this != LBFGS_STOP &amp;&amp; this != LBFGS_ALREADY_MINIMIZED;
        }
    };

    /**
     * Line search algorithms.
     */
    enum LinesearchAlgorithm {
        /**
         * The default algorithm (MoreThuente method).
         */
//	    LBFGS_LINESEARCH_DEFAULT,

        /**
         * MoreThuente method proposd by More and Thuente.
         */
        LBFGS_LINESEARCH_MORETHUENTE,
        /**
         * Backtracking method with the Armijo condition. The backtracking
         * method finds the step length such that it satisfies the sufficient
         * decrease (Armijo) condition, - f(x + a * d) &lt;= f(x) +
         * lbfgs_parameter_t::ftol * a * g(x)^T d,
         *
         * where x is the current point, d is the current search direction, and
         * a is the step length.
         */
        LBFGS_LINESEARCH_BACKTRACKING_ARMIJO,
        /**
         * The backtracking method with the defualt (regular Wolfe) condition.
         */
        //	    LBFGS_LINESEARCH_BACKTRACKING,

        /**
         * Backtracking method with regular Wolfe condition. The backtracking
         * method finds the step length such that it satisfies both the Armijo
         * condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO) and the curvature
         * condition, - g(x + a * d)^T d &gt;= lbfgs_parameter_t::wolfe * g(x)^T d,
         *
         * where x is the current point, d is the current search direction, and
         * a is the step length.
         */
        LBFGS_LINESEARCH_BACKTRACKING_WOLFE,
        /**
         * Backtracking method with strong Wolfe condition. The backtracking
         * method finds the step length such that it satisfies both the Armijo
         * condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO) and the following
         * condition, - |g(x + a * d)^T d| &lt;= lbfgs_parameter_t::wolfe * |g(x)^T
         * d|,
         *
         * where x is the current point, d is the current search direction, and
         * a is the step length.
         */
        LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE,
    };

    static interface line_search_proc {

        public Status go(
            int n,
            double[] x,
            double[] f,
            double[] g,
            double[] s,
            double[] stp,
            final double[] xp,
            final double[] gp,
            double[] wa,
            callback_data_t cd,
            Params param
        );
    }


    /*
	 * static const lbfgs_parameter_t _defparam = {
    m 6, 
    epsilon 1e-5,
    past 0,
    delta 1e-5,
    maxiter 0,
    linesearch LBFGS_LINESEARCH_DEFAULT,
    maxlinesearch 40,
    minstep 1e-20,
    maxstep 1e20,
    ftol 1e-4,
    wolfe 0.9,
    gtol 0.9,
    xtol 1.0e-16,
    orthwantwisec 0.0,
    orthwantwisestart 0,
    orthantwiseend -1,
    
	};
     */
    /**
     * Parameters to control the optimizer. To control convergence/runtime, see:
     * {@link #max_iterations} and {@link #epsilon} To get L1 penalization, see:
     * {@link #orthantwise_c}, {@link #orthantwise_start}, {@link #orthantwise_end}
     */
    public static class Params {

        /**
         * The number of corrections to approximate the inverse hessian matrix.
         * The L-BFGS routine stores the computation results of previous \ref m
         * iterations to approximate the inverse hessian matrix of the current
         * iteration. This parameter controls the size of the limited memories
         * (corrections). The default value is \c 6. Values less than \c 3 are
         * not recommended. Large values will result in excessive computing
         * time.
         */
        public int m = 6;

        /**
         * Epsilon for convergence test. This parameter determines the accuracy
         * with which the solution is to be found. A minimization terminates
         * when ||g|| &lt; \ref epsilon * max(1, ||x||), where ||.|| denotes the
         * Euclidean (L2) norm. The default value is \c 1e-5.
         */
        public double epsilon = 1e-5;

        /**
         * Distance for delta-based convergence test. This parameter determines
         * the distance, in iterations, to compute the rate of decrease of the
         * objective function. If the value of this parameter is zero, the
         * library does not perform the delta-based convergence test.
         */
        public int past = 3; // BTO: changed from '0'

        /**
         * Delta for convergence test. This parameter determines the minimum
         * rate of decrease of the objective function. The library stops
         * iterations when the following condition is met: (f' - f) / f &lt; \ref
         * delta, where f' is the objective value of \ref past iterations ago,
         * and f is the objective value of the current iteration. The default
         * value is \c 0.
         *
         * REQUIRES 'past' TO BE SET
         */
        public double delta = 1e-5;

        /**
         * The maximum number of iterations. The lbfgs() function terminates an
         * optimization process with ::LBFGSERR_MAXIMUMITERATION status code
         * when the iteration count exceeds this parameter. Setting this
         * parameter to zero continues an optimization process until a
         * convergence or error. The default value is \c 0.
         */
        public int max_iterations = 0;

        /**
         * The line search algorithm. This parameter specifies a line search
         * algorithm to be used by the L-BFGS routine.
         */
//	    LinesearchAlgorithm linesearch = LinesearchAlgorithm.LBFGS_LINESEARCH_MORETHUENTE;
        // BTO: morethuente was default in LibLBFGS, disabling for now
        LinesearchAlgorithm linesearch = LinesearchAlgorithm.LBFGS_LINESEARCH_BACKTRACKING_WOLFE;

        /**
         * The maximum number of trials for the line search. This parameter
         * controls the number of function and gradients evaluations per
         * iteration for the line search routine. The default value is \c 40.
         */
        public int max_linesearch = 40;

        /**
         * The minimum step of the line search routine. The default value is \c
         * 1e-20. This value need not be modified unless the exponents are too
         * large for the machine being used, or unless the problem is extremely
         * badly scaled (in which case the exponents should be increased).
         */
        public double min_step = 1e-20;

        /**
         * The maximum step of the line search. The default value is \c 1e+20.
         * This value need not be modified unless the exponents are too large
         * for the machine being used, or unless the problem is extremely badly
         * scaled (in which case the exponents should be increased).
         */
        public double max_step = 1e20;

        /**
         * A parameter to control the accuracy of the line search routine. The
         * default value is \c 1e-4. This parameter should be greater than zero
         * and smaller than \c 0.5.
         */
        public double ftol = 1e-4;

        /**
         * A coefficient for the Wolfe condition. This parameter is valid only
         * when the backtracking line-search algorithm is used with the Wolfe
         * condition, ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE or
         * ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE . The default value is \c 0.9.
         * This parameter should be greater the \ref ftol parameter and smaller
         * than \c 1.0.
         */
        public double wolfe = 0.9;

        /**
         * A parameter to control the accuracy of the line search routine. The
         * default value is \c 0.9. If the function and gradient evaluations are
         * inexpensive with respect to the cost of the iteration (which is
         * sometimes the case when solving very large problems) it may be
         * advantageous to set this parameter to a small value. A typical small
         * value is \c 0.1. This parameter shuold be greater than the \ref ftol
         * parameter (\c 1e-4) and smaller than \c 1.0.
         */
        public double gtol = 0.9;

        /**
         * The machine precision for floating-point values. This parameter must
         * be a positive value set by a client program to estimate the machine
         * precision. The line search routine will terminate with the status
         * code (::LBFGSERR_ROUNDING_ERROR) if the relative width of the
         * interval of uncertainty is less than this parameter.
         */
        public double xtol = 1e-16;

        /**
         * Coefficient for the L1 norm of variables. This parameter should be
         * set to zero for standard minimization problems. 
         * Setting this
         * parameter to a positive value activates Orthant-Wise Limited-memory
         * Quasi-Newton (OWL-QN) method, which minimizes the objective function
         * F(x) combined with the L1 norm |x| of the variables, {F(x) + C |x|}.
         * This parameter is the coeefficient for the |x|, i.e., C. As the L1
         * norm |x| is not differentiable at zero, the library modifies function
         * and gradient evaluations from a client program suitably; a client
         * program thus have only to return the function value F(x) and
         * gradients G(x) as usual. The default value is zero.
         */
        public double orthantwise_c = 0;

        /**
         * Start index for computing L1 norm of the variables. This parameter is
         * valid only for OWL-QN method (i.e., \ref orthantwise_c != 0). This
         * parameter b (0 &lt;= b &lt; N) specifies the index number from which the
         * library computes the L1 norm of the variables x, |x| := |x_{b}| +
         * |x_{b+1}| + ... + |x_{N}| . In other words, variables x_1, ...,
         * x_{b-1} are not used for computing the L1 norm. Setting b (0 &lt; b &lt;
         * N), one can protect variables, x_1, ..., x_{b-1} (e.g., a bias term
         * of logistic regression) from being regularized. The default value is
         * zero.
         */
        public int orthantwise_start = 0;

        /**
         * End index for computing L1 norm of the variables. This parameter is
         * valid only for OWL-QN method (i.e., \ref orthantwise_c != 0). This
         * parameter e (0 &lt; e &lt;= N) specifies the index number at which the
         * library stops computing the L1 norm of the variables x,
         */
        public int orthantwise_end = -1;
    };

    /**
     * Callback interface to provide objective function and gradient
     * evaluations. [BTO: liblbfgs's wants both at once. this is smart: often
     * this halves the cost; e.g. evaluate partitions only once for loglinear
     * gradients.]
     *
     * The lbfgs() function call this function to obtain the values of objective
     * function and its gradients when needed. A client program must implement
     * this function to evaluate the values of the objective function and its
     * gradients, given current values of variables.
     */
    public static interface Function {

        /**
         * receive x. fill in g. return objective. Protocol: receive x, fill in
         * g, return objective.
         *
         * @param x The current values of variables.
         * @param g The gradient vector. The callback function must 
         * compute the
         * gradient values for the current variables.
         * @param n The number of variables.
         * @param step The current step of the line search routine.
         * @retval The value of the objective function for the current
         * variables.
         */
        public double evaluate(final double[] x, double[] g, int n, 
            double step);
    }

//	typedef lbfgsfloatval_t (*lbfgs_evaluate_t)(
//	    void *instance,
//	    const lbfgsfloatval_t *x,
//	    lbfgsfloatval_t *g,
//	    const int n,
//	    const lbfgsfloatval_t step
//	    );
    /**
     * Callback interface to receive the progress of the optimization process.
     */
    public static interface ProgressCallback {

        /**
         * * The lbfgs() function call this function for each iteration.
         * Implementing this function, a client program can store or display the
         * current progress of the optimization process.
         *
         * @param instance The user data sent for lbfgs() function by the
         * client. BTO removed
         * @param x The current values of variables.
         * @param g The current gradient values of variables.
         * @param fx The current value of the objective function.
         * @param xnorm The Euclidean norm of the variables.
         * @param gnorm The Euclidean norm of the gradients.
         * @param step The line-search step used for this iteration.
         * @param n The number of variables.
         * @param k The iteration count.
         * @param ls The number of evaluations called for this iteration.
         * @return int Zero to continue the optimization process. Returning a
         * non-zero value will cancel the optimization process.
         */
        public int apply(
            double[] x,
            double[] g,
            double fx,
            double xnorm,
            double gnorm,
            double step,
            int n,
            int iterNum,
            Status ls);
    }

//	typedef int (*lbfgs_progress_t)(
//	    void *instance,
//	    const lbfgsfloatval_t *x,
//	    const lbfgsfloatval_t *g,
//	    const lbfgsfloatval_t fx,
//	    const lbfgsfloatval_t xnorm,
//	    const lbfgsfloatval_t gnorm,
//	    const lbfgsfloatval_t step,
//	    int n,
//	    int k,
//	    int ls
//	    );

    /*
	A user must implement a function compatible with ::lbfgs_evaluate_t (evaluation
	callback) and pass the pointer to the callback function to lbfgs() arguments.
	Similarly, a user can implement a function compatible with ::lbfgs_progress_t
	(progress callback) to obtain the current progress (e.g., variables, function
	value, ||G||, etc) and to cancel the iteration process if necessary.
	Implementation of a progress callback is optional: a user can pass \c NULL if
	progress notification is not necessary.

	In addition, a user must preserve two requirements:
	    - The number of variables must be multiples of 16 (this is not 4).
	    - The memory block of variable array ::x must be aligned to 16.

	This algorithm terminates an optimization
	when:

	    ||G|| &lt; \epsilon \cdot \max(1, ||x||) .

	In this formula, ||.|| denotes the Euclidean norm.
     */
    public static class Result {

        public Status status;
        public int additionalStatus;
        public double objective = Double.MAX_VALUE;

        public Result(Status s) {
            status = s;
        }

        public String toString() {
            return String.format(&quot;status=%s obj=%g&quot;, status, objective);
        }
    }

    static double max3(double a, double b, double c) {
<span class="nc" id="L720">        return Math.max(Math.max(a, b), c);</span>
    }

    static class callback_data_t {

        int n;
        Function proc_evaluate;
        ProgressCallback proc_progress;
    }

    static class iteration_data_t {

        double alpha;
        // BTO tricky, i think these were aliased pointers or something?
        double[] s;
        /* [n] */
        double[] y;
        /* [n] */
        double ys;
        /* vecdot(y, s) */
    }
//	typedef struct tag_iteration_data iteration_data_t;

    /**
     * Use default parameters.
     * @param init The array of variables. 
     * A client program can set default values
     * for the optimization and receive the optimization result through this
     * array.
     * @param proc_evaluate The callback function to provide function and
     * gradient evaluations given a current values of variables. A client
     * program must implement a callback function compatible with \ref
     * lbfgs_evaluate_t and pass the pointer to the callback function.
     
     * @return Result The status code and final objective.
     */
    public static Result lbfgs(
        double[] init,
        Function proc_evaluate) {
        
<span class="fc" id="L760">        return lbfgs(init, proc_evaluate, null, new Params());</span>
    }

    /**
     * Use default parameters. See
     * @param init The array of variables. 
     * A client program can set default values
     * for the optimization and receive the optimization result through this
     * array.
     * @param proc_evaluate The callback function to provide function and
     * gradient evaluations given a current values of variables. A client
     * program must implement a callback function compatible with \ref
     * lbfgs_evaluate_t and pass the pointer to the callback function.
     * @param proc_progress The callback function to receive the progress (the
     * number of iterations, the current value of the objective function) of the
     * minimization process. This argument can be set to \c NULL if a progress
     * 
     * @return Result The status code and final objective.
     */
    public static Result lbfgs(
        double[] init,
        Function proc_evaluate,
        ProgressCallback proc_progress) {
        
<span class="fc" id="L784">        return lbfgs(init, proc_evaluate, proc_progress, new Params());</span>
    }

    /**
     * Use debug-friendly parameters &amp; callback. See
     * @param init The array of variables. 
     * A client program can set default values
     * for the optimization and receive the optimization result through this
     * array.
     * @param maxIter
     * @param proc_evaluate The callback function to provide function and
     * gradient evaluations given a current values of variables. A client
     * program must implement a callback function compatible with \ref
     * lbfgs_evaluate_t and pass the pointer to the callback function.
     * 
     * @return Result The status code and final objective.
     */
    public static Result lbfgs(
        double[] init,
        int maxIter,
        Function proc_evaluate) {
        
<span class="nc" id="L806">        Params p = new Params();</span>
<span class="nc" id="L807">        p.max_iterations = maxIter;</span>
<span class="nc" id="L808">        ProgressCallback cb = new ProgressCallback() {</span>
            @Override
            public int apply(double[] x, double[] g, double fx, double xnorm,
                double gnorm, double step, int n, int k, LBFGS.Status ls) {
                System.out.printf(&quot;optiter %d obj=%g solelt=%g\n&quot;, k, fx, x[0]);
                return 0;
            }
        };
<span class="nc" id="L816">        return lbfgs(init, proc_evaluate, cb, p);</span>
    }

    /**
     * safer &amp; debug-friendly options.
     * @param x The array of variables. 
     * A client program can set default values
     * for the optimization and receive the optimization result through this
     * array.
     * @param maxIter
     * @param proc_evaluate The callback function to provide function and
     * gradient evaluations given a current values of variables. A client
     * program must implement a callback function compatible with \ref
     * lbfgs_evaluate_t and pass the pointer to the callback function.
     * @param cb The callback function to receive the progress (the
     * number of iterations, the current value of the objective function) of the
     * minimization process. This argument can be set to \c NULL if a progress
     * report is unnecessary.
     
     * @return Result The status code and final objective.
     */
    public static Result lbfgsNice(
        double[] x,
        int maxIter,
        Function proc_evaluate,
        ProgressCallback cb) {
        
<span class="nc" id="L843">        Params p = new Params();</span>
<span class="nc" id="L844">        p.max_iterations = maxIter;</span>
<span class="nc" id="L845">        return lbfgs(x, proc_evaluate, cb, p);</span>
    }

    /**
     * Start a L-BFGS optimization.
     *
     * @param x The array of variables. 
     * A client program can set default values
     * for the optimization and receive the optimization result through this
     * array.
     * @param proc_evaluate The callback function to provide function and
     * gradient evaluations given a current values of variables. A client
     * program must implement a callback function compatible with \ref
     * lbfgs_evaluate_t and pass the pointer to the callback function.
     * @param proc_progress The callback function to receive the progress (the
     * number of iterations, the current value of the objective function) of the
     * minimization process. This argument can be set to \c NULL if a progress
     * report is unnecessary.
     * @param param The pointer to a structure representing parameters for
     * L-BFGS optimization. A client program can set this parameter to NULL to
     * use the default parameters.
     * @return Result The status code and final objective.
     */
    public static Result lbfgs(
        double[] x,
        Function proc_evaluate,
        ProgressCallback proc_progress,
        Params param) {
        
<span class="fc" id="L874">        int n = x.length;</span>

<span class="fc" id="L876">        Result ret = new Result(null);</span>
        int i, j, k, /*ls,*/ end, bound;
        Status ls;
<span class="fc" id="L879">        double[] step = new double[]{0};</span>

        /* Constant parameters and their default values. */
<span class="fc" id="L882">        final int m = param.m;</span>

        double[] xp;
        double g[], gp[], pg[];
<span class="fc" id="L886">        double d[], w[], pf[] = null;</span>
        iteration_data_t[] lm;
        iteration_data_t it;
        double ys, yy;
        double xnorm, gnorm, beta;
<span class="fc" id="L891">        double fx[] = new double[]{0}; // singleton passing to linesearch</span>
<span class="fc" id="L892">        double rate = 0;</span>
//	    line_search_proc linesearch = new line_search_morethuente();
<span class="fc" id="L894">        line_search_proc linesearch = new line_search_backtracking(); // BTO added for testing</span>

        /* Construct a callback data. */
<span class="fc" id="L897">        callback_data_t cd = new callback_data_t();</span>
<span class="fc" id="L898">        cd.n = n;</span>
<span class="fc" id="L899">        cd.proc_evaluate = proc_evaluate;</span>
<span class="fc" id="L900">        cd.proc_progress = proc_progress;</span>


        /* Check the input parameters for errors. */
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L905">            return new Result(Status.LBFGSERR_INVALID_N);</span>
        }
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">        if (param.epsilon &lt; 0.) {</span>
<span class="nc" id="L908">            return new Result(Status.LBFGSERR_INVALID_EPSILON);</span>
        }
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        if (param.past &lt; 0) {</span>
<span class="nc" id="L911">            return new Result(Status.LBFGSERR_INVALID_TESTPERIOD);</span>
        }
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">        if (param.delta &lt; 0.) {</span>
<span class="nc" id="L914">            return new Result(Status.LBFGSERR_INVALID_DELTA);</span>
        }
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        if (param.min_step &lt; 0.) {</span>
<span class="nc" id="L917">            return new Result(Status.LBFGSERR_INVALID_MINSTEP);</span>
        }
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        if (param.max_step &lt; param.min_step) {</span>
<span class="nc" id="L920">            return new Result(Status.LBFGSERR_INVALID_MAXSTEP);</span>
        }
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">        if (param.ftol &lt; 0.) {</span>
<span class="nc" id="L923">            return new Result(Status.LBFGSERR_INVALID_FTOL);</span>
        }
<span class="pc bpc" id="L925" title="3 of 4 branches missed.">        if (param.linesearch == LinesearchAlgorithm.LBFGS_LINESEARCH_BACKTRACKING_WOLFE</span>
            || param.linesearch == LinesearchAlgorithm.LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE) {
<span class="pc bpc" id="L927" title="2 of 4 branches missed.">            if (param.wolfe &lt;= param.ftol || 1. &lt;= param.wolfe) {</span>
<span class="nc" id="L928">                return new Result(Status.LBFGSERR_INVALID_WOLFE);</span>
            }
        }
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">        if (param.gtol &lt; 0.) {</span>
<span class="nc" id="L932">            return new Result(Status.LBFGSERR_INVALID_GTOL);</span>
        }
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        if (param.xtol &lt; 0.) {</span>
<span class="nc" id="L935">            return new Result(Status.LBFGSERR_INVALID_XTOL);</span>
        }
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if (param.max_linesearch &lt;= 0) {</span>
<span class="nc" id="L938">            return new Result(Status.LBFGSERR_INVALID_MAXLINESEARCH);</span>
        }
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        if (param.orthantwise_c &lt; 0.) {</span>
<span class="nc" id="L941">            return new Result(Status.LBFGSERR_INVALID_ORTHANTWISE);</span>
        }
<span class="pc bpc" id="L943" title="2 of 4 branches missed.">        if (param.orthantwise_start &lt; 0 || n &lt; param.orthantwise_start) {</span>
<span class="nc" id="L944">            return new Result(Status.LBFGSERR_INVALID_ORTHANTWISE_START);</span>
        }
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        if (param.orthantwise_end &lt; 0) {</span>
<span class="fc" id="L947">            param.orthantwise_end = n;</span>
        }
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">        if (n &lt; param.orthantwise_end) {</span>
<span class="nc" id="L950">            return new Result(Status.LBFGSERR_INVALID_ORTHANTWISE_END);</span>
        }
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">        if (param.orthantwise_c != 0.) {</span>
            /* Only the backtracking method is available. */
<span class="nc" id="L954">            linesearch = new line_search_backtracking_owlqn();</span>
        } else {
<span class="pc bpc" id="L956" title="2 of 3 branches missed.">            switch (param.linesearch) {</span>
                case LBFGS_LINESEARCH_MORETHUENTE:
<span class="nc" id="L958">                    linesearch = new line_search_morethuente();</span>
<span class="nc" id="L959">                    break;</span>
                case LBFGS_LINESEARCH_BACKTRACKING_ARMIJO:
                case LBFGS_LINESEARCH_BACKTRACKING_WOLFE:
                case LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE:
<span class="fc" id="L963">                    linesearch = new line_search_backtracking();</span>
<span class="fc" id="L964">                    break;</span>
                default:
<span class="nc" id="L966">                    return new Result(Status.LBFGSERR_INVALID_LINESEARCH);</span>
            }
        }

        /* Allocate working space. */
<span class="fc" id="L971">        xp = new double[n];</span>
<span class="fc" id="L972">        g = new double[n];</span>
<span class="fc" id="L973">        gp = new double[n];</span>
<span class="fc" id="L974">        d = new double[n];</span>
<span class="fc" id="L975">        w = new double[n];</span>

<span class="pc bpc" id="L977" title="1 of 2 branches missed.">        if (param.orthantwise_c != 0) {</span>
            /* Allocate working space for OW-LQN. */
<span class="nc" id="L979">            pg = new double[n];</span>
        } else {
<span class="fc" id="L981">            pg = new double[0]; // to make java compiler happy</span>
        }

        /* Allocate limited memory storage. */
<span class="fc" id="L985">        lm = new iteration_data_t[m];</span>

        /* Initialize the limited memory. */
<span class="fc bfc" id="L988" title="All 2 branches covered.">        for (i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L989">            lm[i] = new iteration_data_t();</span>
<span class="fc" id="L990">            it = lm[i];</span>
<span class="fc" id="L991">            it.alpha = 0;</span>
<span class="fc" id="L992">            it.ys = 0;</span>
<span class="fc" id="L993">            it.s = new double[n]; //(lbfgsfloatval_t*)vecalloc(n * sizeof(lbfgsfloatval_t));</span>
<span class="fc" id="L994">            it.y = new double[n]; //(lbfgsfloatval_t*)vecalloc(n * sizeof(lbfgsfloatval_t));</span>
//	        if (it-&gt;s == NULL || it-&gt;y == NULL) {
//	            ret = LBFGSERR_OUTOFMEMORY;
//	            goto lbfgs_exit;
//	        }
        }

        /* Allocate an array for storing previous values of the objective function. */
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">        if (0 &lt; param.past) {</span>
<span class="fc" id="L1003">            pf = new double[param.past]; //(lbfgsfloatval_t*)vecalloc(param.past * sizeof(lbfgsfloatval_t));</span>
        }

        /* Evaluate the function value and its gradient. */
<span class="fc" id="L1007">        fx[0] = cd.proc_evaluate.evaluate(x, g, cd.n, 0);</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        if (0. != param.orthantwise_c) {</span>
            /* Compute the L1 norm of the variable and add it to the object value. */
<span class="nc" id="L1010">            xnorm = owlqn_x1norm(x, param.orthantwise_start, param.orthantwise_end);</span>
<span class="nc" id="L1011">            fx[0] += xnorm * param.orthantwise_c;</span>
<span class="nc" id="L1012">            owlqn_pseudo_gradient(</span>
                pg, x, g, n,
                param.orthantwise_c, param.orthantwise_start, param.orthantwise_end
            );
        }

        /* Store the initial value of the objective function. */
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">        if (pf != null) {</span>
<span class="fc" id="L1020">            pf[0] = fx[0];</span>
        }

        /*
	        Compute the direction;
	        we assume the initial hessian matrix H_0 as the identity matrix.
         */
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (param.orthantwise_c == 0.) {</span>
<span class="fc" id="L1028">            vecncpy(d, g, n);</span>
        } else {
<span class="nc" id="L1030">            vecncpy(d, pg, n);</span>
        }

        /*
	       Make sure that the initial variables are not a minimizer.
         */
<span class="fc" id="L1036">        xnorm = vec2norm(x, n);</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">        if (param.orthantwise_c == 0.) {</span>
<span class="fc" id="L1038">            gnorm = vec2norm(g, n);</span>
        } else {
<span class="nc" id="L1040">            gnorm = vec2norm(pg, n);</span>
        }
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">        if (xnorm &lt; 1.0) {</span>
<span class="nc" id="L1043">            xnorm = 1.0;</span>
        }
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        if (gnorm / xnorm &lt;= param.epsilon) {</span>
<span class="nc" id="L1046">            return new Result(Status.LBFGS_ALREADY_MINIMIZED);</span>
        }

        /* Compute the initial step:
	        step = 1.0 / sqrt(vecdot(d, d, n))
         */
<span class="fc" id="L1052">        step[0] = vec2norminv(d, n);</span>

<span class="fc" id="L1054">        k = 1;</span>
<span class="fc" id="L1055">        end = 0;</span>
        for (;;) {
            /* Store the current position and gradient vectors. */
<span class="fc" id="L1058">            veccpy(xp, x, n);</span>
<span class="fc" id="L1059">            veccpy(gp, g, n);</span>

            /* Search for an optimal step. */
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">            if (param.orthantwise_c == 0.) {</span>
<span class="fc" id="L1063">                ls = linesearch.go(n, x, fx, g, d, step, xp, gp, w, cd, param);</span>
            } else {
<span class="nc" id="L1065">                ls = linesearch.go(n, x, fx, g, d, step, xp, pg, w, cd, param);</span>
<span class="nc" id="L1066">                owlqn_pseudo_gradient(</span>
                    pg, x, g, n,
                    param.orthantwise_c, param.orthantwise_start, param.orthantwise_end
                );
            }
<span class="pc bpc" id="L1071" title="1 of 4 branches missed.">            if (ls != null &amp;&amp; ls.isError()) {</span>
                /* Revert to the previous point. */
<span class="fc" id="L1073">                veccpy(x, xp, n);</span>
<span class="fc" id="L1074">                veccpy(g, gp, n);</span>
<span class="fc" id="L1075">                ret.status = ls;</span>
<span class="fc" id="L1076">                ret.objective = fx[0];</span>
<span class="fc" id="L1077">                return ret;</span>
            }

            /* Compute x and g norms. */
<span class="fc" id="L1081">            xnorm = vec2norm(x, n);</span>
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">            if (param.orthantwise_c == 0.) {</span>
<span class="fc" id="L1083">                gnorm = vec2norm(g, n);</span>
            } else {
<span class="nc" id="L1085">                gnorm = vec2norm(pg, n);</span>
            }

            /* Report the progress. */
<span class="fc bfc" id="L1089" title="All 2 branches covered.">            if (cd.proc_progress != null) {</span>
<span class="fc" id="L1090">                int stopEarly = cd.proc_progress.apply(x, g, fx[0], xnorm, gnorm, step[0], cd.n, k, ls);</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">                if (stopEarly != 0) {</span>
<span class="nc" id="L1092">                    ret.status = Status.LBFGS_STOP;</span>
<span class="nc" id="L1093">                    ret.additionalStatus = stopEarly;</span>
<span class="nc" id="L1094">                    ret.objective = fx[0];</span>
<span class="nc" id="L1095">                    return ret;</span>
                }
            }

            /*
	            Convergence test.
	            The criterion is given by the following formula:
	                |g(x)| / \max(1, |x|) &lt; \epsilon
             */
<span class="fc bfc" id="L1104" title="All 2 branches covered.">            if (xnorm &lt; 1.0) {</span>
<span class="fc" id="L1105">                xnorm = 1.0;</span>
            }
<span class="fc bfc" id="L1107" title="All 2 branches covered.">            if (gnorm / xnorm &lt;= param.epsilon) {</span>
                /* Convergence. */
<span class="fc" id="L1109">                ret.status = Status.LBFGS_SUCCESS;</span>
<span class="fc" id="L1110">                break;</span>
            }

            /*
	            Test for stopping criterion.
	            The criterion is given by the following formula:
	                (f(past_x) - f(x)) / f(x) &lt; \delta
             */
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">            if (pf != null) {</span>
                /* We don't test the stopping criterion while k &lt; past. */
<span class="fc bfc" id="L1120" title="All 2 branches covered.">                if (param.past &lt;= k) {</span>
                    /* Compute the relative improvement from the past. */
<span class="fc" id="L1122">                    rate = (pf[k % param.past] - fx[0]) / fx[0];</span>

                    /* The stopping criterion. */
<span class="fc bfc" id="L1125" title="All 2 branches covered.">                    if (rate &lt; param.delta) {</span>
<span class="fc" id="L1126">                        ret.status = Status.LBFGS_STOP;</span>
<span class="fc" id="L1127">                        break;</span>
                    }
                }

                /* Store the current value of the objective function. */
<span class="fc" id="L1132">                pf[k % param.past] = fx[0];</span>
            }

<span class="pc bpc" id="L1135" title="3 of 4 branches missed.">            if (param.max_iterations != 0 &amp;&amp; param.max_iterations &lt; k + 1) {</span>
                /* Maximum number of iterations. */
<span class="nc" id="L1137">                ret.status = Status.LBFGSERR_MAXIMUMITERATION;</span>
<span class="nc" id="L1138">                break;</span>
            }

            /*
	            Update vectors s and y:
	                s_{k+1} = x_{k+1} - x_{k} = \step * d_{k}.
	                y_{k+1} = g_{k+1} - g_{k}.
             */
<span class="fc" id="L1146">            it = lm[end];</span>
<span class="fc" id="L1147">            vecdiff(it.s, x, xp, n);</span>
<span class="fc" id="L1148">            vecdiff(it.y, g, gp, n);</span>

            /*
	            Compute scalars ys and yy:
	                ys = y^t \cdot s = 1 / \rho.
	                yy = y^t \cdot y.
	            Notice that yy is used for scaling the hessian matrix H_0 (Cholesky factor).
             */
<span class="fc" id="L1156">            ys = vecdot(it.y, it.s, n);</span>
<span class="fc" id="L1157">            yy = vecdot(it.y, it.y, n);</span>
<span class="fc" id="L1158">            it.ys = ys;</span>

            /*
	            Recursive formula to compute dir = -(H \cdot g).
	                This is described in page 779 of:
	                Jorge Nocedal.
	                Updating Quasi-Newton Matrices with Limited Storage.
	                Mathematics of Computation, Vol. 35, No. 151,
	                pp. 773--782, 1980.
             */
<span class="fc bfc" id="L1168" title="All 2 branches covered.">            bound = (m &lt;= k) ? m : k;</span>
<span class="fc" id="L1169">            ++k;</span>
<span class="fc" id="L1170">            end = (end + 1) % m;</span>

            /* Compute the steepest direction. */
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">            if (param.orthantwise_c == 0.) {</span>
                /* Compute the negative of gradients. */
<span class="fc" id="L1175">                vecncpy(d, g, n);</span>
            } else {
<span class="nc" id="L1177">                vecncpy(d, pg, n);</span>
            }

<span class="fc" id="L1180">            j = end;</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">            for (i = 0; i &lt; bound; ++i) {</span>
<span class="fc" id="L1182">                j = (j + m - 1) % m;</span>
                /* if (--j == -1) j = m-1; */
<span class="fc" id="L1184">                it = lm[j];</span>
                /* \alpha_{j} = \rho_{j} s^{t}_{j} \cdot q_{k+1}. */
<span class="fc" id="L1186">                it.alpha = vecdot(it.s, d, n);</span>
<span class="fc" id="L1187">                it.alpha /= it.ys;</span>
                /* q_{i} = q_{i+1} - \alpha_{i} y_{i}. */
<span class="fc" id="L1189">                vecadd(d, it.y, -it.alpha, n);</span>
            }

<span class="fc" id="L1192">            vecscale(d, ys / yy, n);</span>

<span class="fc bfc" id="L1194" title="All 2 branches covered.">            for (i = 0; i &lt; bound; ++i) {</span>
<span class="fc" id="L1195">                it = lm[j];</span>
                /* \beta_{j} = \rho_{j} y^t_{j} \cdot \gamma_{i}. */
<span class="fc" id="L1197">                beta = vecdot(it.y, d, n);</span>
<span class="fc" id="L1198">                beta /= it.ys;</span>
                /* \gamma_{i+1} = \gamma_{i} + (\alpha_{j} - \beta_{j}) s_{j}. */
<span class="fc" id="L1200">                vecadd(d, it.s, it.alpha - beta, n);</span>
<span class="fc" id="L1201">                j = (j + 1) % m;</span>
                /* if (++j == m) j = 0; */
            }

            /*
	            Constrain the search direction for orthant-wise updates.
             */
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">            if (param.orthantwise_c != 0.) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                for (i = param.orthantwise_start; i &lt; param.orthantwise_end; ++i) {</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                    if (d[i] * pg[i] &gt;= 0) {</span>
<span class="nc" id="L1211">                        d[i] = 0;</span>
                    }
                }
            }

            /*
	            Now the search direction d is ready. We try step = 1 first.
             */
<span class="fc" id="L1219">            step[0] = 1.0;</span>
        }

//	    lbfgs_exit:
        /* Return the final value of the objective function. */
//        if (ptr_fx != NULL) {
//            *ptr_fx = fx;
//        }
<span class="fc" id="L1227">        ret.objective = fx[0];</span>
<span class="fc" id="L1228">        return ret;</span>
    }

    //////////////////////
    public static double vecdot(double[] a, double[] b, int n) {
<span class="fc" id="L1233">        return innerProduct(a, b);</span>
    }

    static void veccpy(double[] y, double[] x, int n) {
<span class="fc" id="L1237">        System.arraycopy(x, 0, y, 0, n);</span>
<span class="fc" id="L1238">    }</span>

    static void vecadd(double[] y, final double[] x, final double c, final int n) {
        int i;

<span class="fc bfc" id="L1243" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1244">            y[i] += c * x[i];</span>
        }
<span class="fc" id="L1246">    }</span>

    static void vecncpy(double[] y, double[] x, int n) {
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1250">            y[i] = -x[i];</span>
        }
<span class="fc" id="L1252">    }</span>

    static void vecset(double[] x, final double c, final int n) {
<span class="nc bnc" id="L1255" title="All 2 branches missed.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="nc" id="L1256">            x[i] = c;</span>
        }
<span class="nc" id="L1258">    }</span>

    static void vecdiff(double[] z, final double[] x, final double[] y, final int n) {
<span class="fc bfc" id="L1261" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1262">            z[i] = x[i] - y[i];</span>
        }
<span class="fc" id="L1264">    }</span>

    static void vecscale(double[] y, final double c, final int n) {
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1268">            y[i] *= c;</span>
        }
<span class="fc" id="L1270">    }</span>

    static void vecmul(double[] y, final double[] x, final int n) {
<span class="nc bnc" id="L1273" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L1274">            y[i] *= x[i];</span>
        }
<span class="nc" id="L1276">    }</span>

    static double vec2norm(final double[] x, final int n) {
<span class="fc" id="L1279">        double s = vecdot(x, x, n);</span>
<span class="fc" id="L1280">        return Math.sqrt(s);</span>
    }

    static double vec2norminv(final double[] x, final int n) {
<span class="fc" id="L1284">        double s = vec2norm(x, n);</span>
<span class="fc" id="L1285">        return 1.0 / s;</span>
    }

    static class line_search_backtracking implements line_search_proc {

        public Status go(
            int n,
            double[] x,
            double[] f,
            double[] g,
            double[] s,
            double[] stp, // BTO: um i think this is supposed to be a singleton
            final double[] xp,
            final double[] gp,
            double[] wp,
            callback_data_t cd,
            Params param
        ) {
            int count = 0;
            double width, dg;
            double finit, dginit = 0., dgtest;
            final double dec = 0.5, inc = 2.1;

            /* Check the input parameters for errors. */
            if (stp[0] &lt;= 0.) {
                return Status.LBFGSERR_INVALIDPARAMETERS;
            }

            /* Compute the initial gradient in the search direction. */
            dginit = vecdot(g, s, n);

            /* Make sure that s points to a descent direction. */
            if (0 &lt; dginit) {
                return Status.LBFGSERR_INCREASEGRADIENT;
            }

            /* The initial value of the objective function. */
            finit = f[0];
            dgtest = param.ftol * dginit;

            for (;;) {
                veccpy(x, xp, n);
                vecadd(x, s, stp[0], n);

                /* Evaluate the function and gradient values. */
                f[0] = cd.proc_evaluate.evaluate(x, g, n, stp[0]);

                ++count;

                if (f[0] &gt; finit + stp[0] * dgtest) {
                    width = dec;
                } else {
                    /* The sufficient decrease condition (Armijo condition). */
                    if (param.linesearch == LinesearchAlgorithm.LBFGS_LINESEARCH_BACKTRACKING_ARMIJO) {
                        /* Exit with the Armijo condition. */
//	                return count; 
                        return Status.LBFGS_SUCCESS; // BTO changed

                    }

                    /* Check the Wolfe condition. */
                    dg = vecdot(g, s, n);
                    if (dg &lt; param.wolfe * dginit) {
                        width = inc;
                    } else {
                        if (param.linesearch == LinesearchAlgorithm.LBFGS_LINESEARCH_BACKTRACKING_WOLFE) {
                            /* Exit with the regular Wolfe condition. */
//			            return count;
                            return Status.LBFGS_SUCCESS; // BTO changed
                        }

                        /* Check the strong Wolfe condition. */
                        if (dg &gt; -param.wolfe * dginit) {
                            width = dec;
                        } else {
                            /* Exit with the strong Wolfe condition. */
//			            return count;
                            return Status.LBFGS_SUCCESS; // BTO changed
                        }
                    }
                }

                if (stp[0] &lt; param.min_step) {
                    /* The step is the minimum value. */
                    return Status.LBFGSERR_MINIMUMSTEP;
                }
                if (stp[0] &gt; param.max_step) {
                    /* The step is the maximum value. */
                    return Status.LBFGSERR_MAXIMUMSTEP;
                }
                if (param.max_linesearch &lt;= count) {
                    /* Maximum number of iteration. */
                    return Status.LBFGSERR_MAXIMUMLINESEARCH;
                }

                stp[0] *= width;
            }
        }
    }

    static class line_search_backtracking_owlqn implements line_search_proc {

        public Status go(
            int n,
            double[] x,
            double[] f,
            double[] g,
            double[] s,
            double[] stp,
            final double[] xp,
            final double[] gp,
            double[] wp,
            callback_data_t cd,
            Params param
        ) {
            int i, count = 0;
            double width = 0.5, norm = 0.;
            double finit = f[0], dgtest;

            /* Check the input parameters for errors. */
            if (stp[0] &lt;= 0.) {
                return Status.LBFGSERR_INVALIDPARAMETERS;
            }

            /* Choose the orthant for the new point. */
            for (i = 0; i &lt; n; ++i) {
                wp[i] = (xp[i] == 0.) ? -gp[i] : xp[i];
            }

            for (;;) {
                /* Update the current point. */
                veccpy(x, xp, n);
                vecadd(x, s, stp[0], n);

                /* The current point is projected onto the orthant. */
                owlqn_project(x, wp, param.orthantwise_start, param.orthantwise_end);

                /* Evaluate the function and gradient values. */
                f[0] = cd.proc_evaluate.evaluate(x, g, cd.n, stp[0]);

                /* Compute the L1 norm of the variables and add it to the object value. */
                norm = owlqn_x1norm(x, param.orthantwise_start, param.orthantwise_end);
                f[0] += norm * param.orthantwise_c;

                ++count;

                dgtest = 0.;
                for (i = 0; i &lt; n; ++i) {
                    dgtest += (x[i] - xp[i]) * gp[i];
                }

                if (f[0] &lt;= finit + param.ftol * dgtest) {
                    /* The sufficient decrease condition. */
//	            return count;
                    return Status.LBFGS_SUCCESS; // BTO changed
                }

                if (stp[0] &lt; param.min_step) {
                    /* The step is the minimum value. */
                    return Status.LBFGSERR_MINIMUMSTEP;
                }
                if (stp[0] &gt; param.max_step) {
                    /* The step is the maximum value. */
                    return Status.LBFGSERR_MAXIMUMSTEP;
                }
                if (param.max_linesearch &lt;= count) {
                    /* Maximum number of iteration. */
                    return Status.LBFGSERR_MAXIMUMLINESEARCH;
                }

                stp[0] *= width;
            }
        }
    }

    static class line_search_morethuente implements line_search_proc {

        @Override
        public Status go(int n, double[] x, double[] f, double[] g, double[] s,
            double[] stp, double[] xp, double[] gp, double[] wa,
            callback_data_t cd, Params param) {
            assert false : &quot;unimplemented&quot;;
            return null;
        }
    }

//	static class line_search_morethuente implements line_search_proc {
//	
//	public int go(
//	    int n,
//	    double[] x,
//	    double[] f,
//	    double[] g,
//	    double[] s,
//	    double[] stp,
//	    final double[] xp,
//	    final double[] gp,
//	    double[] wa,
//	    Function evaluator, ProgressCallback progress,
//	    Params param
//	    )
//	{
//	    int count = 0;
//	    int brackt, stage1, uinfo = 0;
//	    lbfgsfloatval_t dg;
//	    lbfgsfloatval_t stx, fx, dgx;
//	    lbfgsfloatval_t sty, fy, dgy;
//	    lbfgsfloatval_t fxm, dgxm, fym, dgym, fm, dgm;
//	    lbfgsfloatval_t finit, ftest1, dginit, dgtest;
//	    lbfgsfloatval_t width, prev_width;
//	    lbfgsfloatval_t stmin, stmax;
//
//	    /* Check the input parameters for errors. */
//	    if (*stp &lt;= 0.) {
//	        return LBFGSERR_INVALIDPARAMETERS;
//	    }
//
//	    /* Compute the initial gradient in the search direction. */
//	    vecdot(&amp;dginit, g, s, n);
//
//	    /* Make sure that s points to a descent direction. */
//	    if (0 &lt; dginit) {
//	        return LBFGSERR_INCREASEGRADIENT;
//	    }
//
//	    /* Initialize local variables. */
//	    brackt = 0;
//	    stage1 = 1;
//	    finit = *f;
//	    dgtest = param-&gt;ftol * dginit;
//	    width = param-&gt;max_step - param-&gt;min_step;
//	    prev_width = 2.0 * width;
//
//	    /*
//	        The variables stx, fx, dgx contain the values of the step,
//	        function, and directional derivative at the best step.
//	        The variables sty, fy, dgy contain the value of the step,
//	        function, and derivative at the other endpoint of
//	        the interval of uncertainty.
//	        The variables stp, f, dg contain the values of the step,
//	        function, and derivative at the current step.
//	    */
//	    stx = sty = 0.;
//	    fx = fy = finit;
//	    dgx = dgy = dginit;
//
//	    for (;;) {
//	        /*
//	            Set the minimum and maximum steps to correspond to the
//	            present interval of uncertainty.
//	         */
//	        if (brackt) {
//	            stmin = min2(stx, sty);
//	            stmax = max2(stx, sty);
//	        } else {
//	            stmin = stx;
//	            stmax = *stp + 4.0 * (*stp - stx);
//	        }
//
//	        /* Clip the step in the range of [stpmin, stpmax]. */
//	        if (*stp &lt; param-&gt;min_step) *stp = param-&gt;min_step;
//	        if (param-&gt;max_step &lt; *stp) *stp = param-&gt;max_step;
//
//	        /*
//	            If an unusual termination is to occur then let
//	            stp be the lowest point obtained so far.
//	         */
//	        if ((brackt &amp;&amp; ((*stp &lt;= stmin || stmax &lt;= *stp) || param-&gt;max_linesearch &lt;= count + 1 || uinfo != 0)) || (brackt &amp;&amp; (stmax - stmin &lt;= param-&gt;xtol * stmax))) {
//	            *stp = stx;
//	        }
//
//	        /*
//	            Compute the current value of x:
//	                x &lt;- x + (*stp) * s.
//	         */
//	        veccpy(x, xp, n);
//	        vecadd(x, s, *stp, n);
//
//	        /* Evaluate the function and gradient values. */
//	        *f = cd-&gt;proc_evaluate(cd-&gt;instance, x, g, cd-&gt;n, *stp);
//	        vecdot(&amp;dg, g, s, n);
//
//	        ftest1 = finit + *stp * dgtest;
//	        ++count;
//
//	        /* Test for errors and convergence. */
//	        if (brackt &amp;&amp; ((*stp &lt;= stmin || stmax &lt;= *stp) || uinfo != 0)) {
//	            /* Rounding errors prevent further progress. */
//	            return LBFGSERR_ROUNDING_ERROR;
//	        }
//	        if (*stp == param-&gt;max_step &amp;&amp; *f &lt;= ftest1 &amp;&amp; dg &lt;= dgtest) {
//	            /* The step is the maximum value. */
//	            return LBFGSERR_MAXIMUMSTEP;
//	        }
//	        if (*stp == param-&gt;min_step &amp;&amp; (ftest1 &lt; *f || dgtest &lt;= dg)) {
//	            /* The step is the minimum value. */
//	            return LBFGSERR_MINIMUMSTEP;
//	        }
//	        if (brackt &amp;&amp; (stmax - stmin) &lt;= param-&gt;xtol * stmax) {
//	            /* Relative width of the interval of uncertainty is at most xtol. */
//	            return LBFGSERR_WIDTHTOOSMALL;
//	        }
//	        if (param-&gt;max_linesearch &lt;= count) {
//	            /* Maximum number of iteration. */
//	            return LBFGSERR_MAXIMUMLINESEARCH;
//	        }
//	        if (*f &lt;= ftest1 &amp;&amp; fabs(dg) &lt;= param-&gt;gtol * (-dginit)) {
//	            /* The sufficient decrease condition and the directional derivative condition hold. */
//	            return count;
//	        }
//
//	        /*
//	            In the first stage we seek a step for which the modified
//	            function has a nonpositive value and nonnegative derivative.
//	         */
//	        if (stage1 &amp;&amp; *f &lt;= ftest1 &amp;&amp; min2(param-&gt;ftol, param-&gt;gtol) * dginit &lt;= dg) {
//	            stage1 = 0;
//	        }
//
//	        /*
//	            A modified function is used to predict the step only if
//	            we have not obtained a step for which the modified
//	            function has a nonpositive function value and nonnegative
//	            derivative, and if a lower function value has been
//	            obtained but the decrease is not sufficient.
//	         */
//	        if (stage1 &amp;&amp; ftest1 &lt; *f &amp;&amp; *f &lt;= fx) {
//	            /* Define the modified function and derivative values. */
//	            fm = *f - *stp * dgtest;
//	            fxm = fx - stx * dgtest;
//	            fym = fy - sty * dgtest;
//	            dgm = dg - dgtest;
//	            dgxm = dgx - dgtest;
//	            dgym = dgy - dgtest;
//
//	            /*
//	                Call update_trial_interval() to update the interval of
//	                uncertainty and to compute the new step.
//	             */
//	            uinfo = update_trial_interval(
//	                &amp;stx, &amp;fxm, &amp;dgxm,
//	                &amp;sty, &amp;fym, &amp;dgym,
//	                stp, &amp;fm, &amp;dgm,
//	                stmin, stmax, &amp;brackt
//	                );
//
//	            /* Reset the function and gradient values for f. */
//	            fx = fxm + stx * dgtest;
//	            fy = fym + sty * dgtest;
//	            dgx = dgxm + dgtest;
//	            dgy = dgym + dgtest;
//	        } else {
//	            /*
//	                Call update_trial_interval() to update the interval of
//	                uncertainty and to compute the new step.
//	             */
//	            uinfo = update_trial_interval(
//	                &amp;stx, &amp;fx, &amp;dgx,
//	                &amp;sty, &amp;fy, &amp;dgy,
//	                stp, f, &amp;dg,
//	                stmin, stmax, &amp;brackt
//	                );
//	        }
//
//	        /*
//	            Force a sufficient decrease in the interval of uncertainty.
//	         */
//	        if (brackt) {
//	            if (0.66 * prev_width &lt;= fabs(sty - stx)) {
//	                *stp = stx + 0.5 * (sty - stx);
//	            }
//	            prev_width = width;
//	            width = fabs(sty - stx);
//	        }
//	    }
//
//	    return LBFGSERR_LOGICERROR;
//	}
//	}
    /**
     * Define the local variables for computing minimizers.
     */
//	#define USES_MINIMIZER \
//	    lbfgsfloatval_t a, d, gamma, theta, p, q, r, s;
    /**
     * Find a minimizer of an interpolated cubic function.
     *
     * @param cm The minimizer of the interpolated cubic. BTO REMOVED, return
     * instead
     * @param u The value of one point, u.
     * @param fu The value of f(u).
     * @param du The value of f'(u).
     * @param v The value of another point, v.
     * @param fv The value of f(v).
     * @param du The value of f'(v).
     */
    static double CUBIC_MINIMIZER(double u, double fu, double du, double v, double fv, double dv) {
//	#define CUBIC_MINIMIZER(cm, u, fu, du, v, fv, dv) \
<span class="nc" id="L1683">        double d = (v) - (u);</span>
<span class="nc" id="L1684">        double theta = ((fu) - (fv)) * 3 / d + (du) + (dv);</span>
<span class="nc" id="L1685">        double p = Math.abs(theta);</span>
<span class="nc" id="L1686">        double q = Math.abs(du);</span>
<span class="nc" id="L1687">        double r = Math.abs(dv);</span>
<span class="nc" id="L1688">        double s = max3(p, q, r);</span>
        /* gamma = s*sqrt((theta/s)**2 - (du/s) * (dv/s)) */
<span class="nc" id="L1690">        double a = theta / s;</span>
<span class="nc" id="L1691">        double gamma = s * Math.sqrt(a * a - ((du) / s) * ((dv) / s));</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">        if ((v) &lt; (u)) {</span>
<span class="nc" id="L1693">            gamma = -gamma;</span>
        }
<span class="nc" id="L1695">        p = gamma - (du) + theta;</span>
<span class="nc" id="L1696">        q = gamma - (du) + gamma + (dv);</span>
<span class="nc" id="L1697">        r = p / q;</span>
<span class="nc" id="L1698">        double cm = (u) + r * d;</span>
<span class="nc" id="L1699">        return cm;</span>
    }

    /**
     * Find a minimizer of an interpolated cubic function.
     *
     * @param cm The minimizer of the interpolated cubic.
     * @param u The value of one point, u.
     * @param fu The value of f(u).
     * @param du The value of f'(u).
     * @param v The value of another point, v.
     * @param fv The value of f(v).
     * @param du The value of f'(v).
     * @param xmin The maximum value.
     * @param xmin The minimum value.
     */
//	#define CUBIC_MINIMIZER2(cm, u, fu, du, v, fv, dv, xmin, xmax) \
    static double CUBIC_MINIMIZER2(double u, double fu, double du, double v,
        double fv, double dv, double xmin, double xmax) {
<span class="nc" id="L1718">        double d = (v) - (u);</span>
<span class="nc" id="L1719">        double theta = ((fu) - (fv)) * 3 / d + (du) + (dv);</span>
<span class="nc" id="L1720">        double p = Math.abs(theta);</span>
<span class="nc" id="L1721">        double q = Math.abs(du);</span>
<span class="nc" id="L1722">        double r = Math.abs(dv);</span>
<span class="nc" id="L1723">        double s = max3(p, q, r);</span>
        /* gamma = s*sqrt((theta/s)**2 - (du/s) * (dv/s)) */
<span class="nc" id="L1725">        double a = theta / s;</span>
<span class="nc" id="L1726">        double gamma = s * Math.sqrt(Math.max(0, a * a - ((du) / s) * ((dv) / s)));</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">        if ((u) &lt; (v)) {</span>
<span class="nc" id="L1728">            gamma = -gamma;</span>
        }
<span class="nc" id="L1730">        p = gamma - (dv) + theta;</span>
<span class="nc" id="L1731">        q = gamma - (dv) + gamma + (du);</span>
<span class="nc" id="L1732">        r = p / q;</span>
        double cm;
<span class="nc bnc" id="L1734" title="All 4 branches missed.">        if (r &lt; 0. &amp;&amp; gamma != 0.) {</span>
<span class="nc" id="L1735">            (cm) = (v) - r * d;</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">        } else if (a &lt; 0) {</span>
<span class="nc" id="L1737">            (cm) = (xmax);</span>
        } else {
<span class="nc" id="L1739">            (cm) = (xmin);</span>
        }
<span class="nc" id="L1741">        return cm;</span>
    }

    /**
     * Find a minimizer of an interpolated quadratic function.
     *
     * @return The minimizer of the interpolated quadratic.
     * @param u The value of one point, u.
     * @param fu The value of f(u).
     * @param du The value of f'(u).
     * @param v The value of another point, v.
     * @param fv The value of f(v).
     */
    static double QUARD_MINIMIZER(double u, double fu, double du, double v, double fv) {
//	#define QUARD_MINIMIZER(qm, u, fu, du, v, fv) \
<span class="nc" id="L1756">        double a = (v) - (u);</span>
<span class="nc" id="L1757">        double qm = (u) + (du) / (((fu) - (fv)) / a + (du)) / 2 * a;</span>
<span class="nc" id="L1758">        return qm;</span>
    }

    /**
     * Find a minimizer of an interpolated quadratic function.
     *
     * @param qm The minimizer of the interpolated quadratic.
     * @param u The value of one point, u.
     * @param du The value of f'(u).
     * @param v The value of another point, v.
     * @param dv The value of f'(v).
     */
//	#define QUARD_MINIMIZER2(qm, u, du, v, dv) \
    static double QUARD_MINIMIZER2(double u, double du, double v, double dv) {
<span class="nc" id="L1772">        double a = (u) - (v);</span>
<span class="nc" id="L1773">        double qm = (v) + (dv) / ((dv) - (du)) * a;</span>
<span class="nc" id="L1774">        return qm;</span>
    }

    /**
     * Update a safeguarded trial value and interval for line search.
     *
     * The parameter x represents the step with the least function value. The
     * parameter t represents the current step. This function assumes that the
     * derivative at the point of x in the direction of the step. If the bracket
     * is set to true, the minimizer has been bracketed in an interval of
     * uncertainty with endpoints between x and y.
     *
     * @param x The pointer to the value of one endpoint.
     * @param fx The pointer to the value of f(x).
     * @param dx The pointer to the value of f'(x).
     * @param y The pointer to the value of another endpoint.
     * @param fy The pointer to the value of f(y).
     * @param dy The pointer to the value of f'(y).
     * @param t The pointer to the value of the trial value, t.
     * @param ft The pointer to the value of f(t).
     * @param dt The pointer to the value of f'(t).
     * @param tmin The minimum value for the trial value, t.
     * @param tmax The maximum value for the trial value, t.
     * @param brackt The pointer to the predicate if the trial value is
     * bracketed.
     * @retval int Status value. Zero indicates a normal termination.
     *
     * @see Jorge J. More and David J. Thuente. Line search algorithm with
     * guaranteed sufficient decrease. ACM Transactions on Mathematical Software
     * (TOMS), Vol 20, No 3, pp. 286-307, 1994.
     */
//	static int update_trial_interval(
//	    double[] x,
//	    double[] fx,
//	    double[] dx,
//	    double[] y,
//	    double[] fy,
//	    double[] dy,
//	    double[] t,
//	    double[] ft,
//	    double[] dt,
//	    final double tmin,
//	    final double tmax,
//	    int[] brackt
//	    )
//	{
//	    int bound;
//	    int dsign = fsigndiff(dt, dx);
//	    lbfgsfloatval_t mc; /* minimizer of an interpolated cubic. */
//	    lbfgsfloatval_t mq; /* minimizer of an interpolated quadratic. */
//	    lbfgsfloatval_t newt;   /* new trial value. */
//
//	    /* Check the input parameters for errors. */
//	    if (*brackt) {
//	        if (*t &lt;= min2(*x, *y) || max2(*x, *y) &lt;= *t) {
//	            /* The trival value t is out of the interval. */
//	            return LBFGSERR_OUTOFINTERVAL;
//	        }
//	        if (0. &lt;= *dx * (*t - *x)) {
//	            /* The function must decrease from x. */
//	            return LBFGSERR_INCREASEGRADIENT;
//	        }
//	        if (tmax &lt; tmin) {
//	            /* Incorrect tmin and tmax specified. */
//	            return LBFGSERR_INCORRECT_TMINMAX;
//	        }
//	    }
//
//	    /*
//	        Trial value selection.
//	     */
//	    if (*fx &lt; *ft) {
//	        /*
//	            Case 1: a higher function value.
//	            The minimum is brackt. If the cubic minimizer is closer
//	            to x than the quadratic one, the cubic one is taken, else
//	            the average of the minimizers is taken.
//	         */
//	        *brackt = 1;
//	        bound = 1;
//	        CUBIC_MINIMIZER(mc, *x, *fx, *dx, *t, *ft, *dt);
//	        QUARD_MINIMIZER(mq, *x, *fx, *dx, *t, *ft);
//	        if (fabs(mc - *x) &lt; fabs(mq - *x)) {
//	            newt = mc;
//	        } else {
//	            newt = mc + 0.5 * (mq - mc);
//	        }
//	    } else if (dsign) {
//	        /*
//	            Case 2: a lower function value and derivatives of
//	            opposite sign. The minimum is brackt. If the cubic
//	            minimizer is closer to x than the quadratic (secant) one,
//	            the cubic one is taken, else the quadratic one is taken.
//	         */
//	        *brackt = 1;
//	        bound = 0;
//	        CUBIC_MINIMIZER(mc, *x, *fx, *dx, *t, *ft, *dt);
//	        QUARD_MINIMIZER2(mq, *x, *dx, *t, *dt);
//	        if (fabs(mc - *t) &gt; fabs(mq - *t)) {
//	            newt = mc;
//	        } else {
//	            newt = mq;
//	        }
//	    } else if (fabs(*dt) &lt; fabs(*dx)) {
//	        /*
//	            Case 3: a lower function value, derivatives of the
//	            same sign, and the magnitude of the derivative decreases.
//	            The cubic minimizer is only used if the cubic tends to
//	            infinity in the direction of the minimizer or if the minimum
//	            of the cubic is beyond t. Otherwise the cubic minimizer is
//	            defined to be either tmin or tmax. The quadratic (secant)
//	            minimizer is also computed and if the minimum is brackt
//	            then the the minimizer closest to x is taken, else the one
//	            farthest away is taken.
//	         */
//	        bound = 1;
//	        CUBIC_MINIMIZER2(mc, *x, *fx, *dx, *t, *ft, *dt, tmin, tmax);
//	        QUARD_MINIMIZER2(mq, *x, *dx, *t, *dt);
//	        if (*brackt) {
//	            if (fabs(*t - mc) &lt; fabs(*t - mq)) {
//	                newt = mc;
//	            } else {
//	                newt = mq;
//	            }
//	        } else {
//	            if (fabs(*t - mc) &gt; fabs(*t - mq)) {
//	                newt = mc;
//	            } else {
//	                newt = mq;
//	            }
//	        }
//	    } else {
//	        /*
//	            Case 4: a lower function value, derivatives of the
//	            same sign, and the magnitude of the derivative does
//	            not decrease. If the minimum is not brackt, the step
//	            is either tmin or tmax, else the cubic minimizer is taken.
//	         */
//	        bound = 0;
//	        if (*brackt) {
//	            CUBIC_MINIMIZER(newt, *t, *ft, *dt, *y, *fy, *dy);
//	        } else if (*x &lt; *t) {
//	            newt = tmax;
//	        } else {
//	            newt = tmin;
//	        }
//	    }
//
//	    /*
//	        Update the interval of uncertainty. This update does not
//	        depend on the new step or the case analysis above.
//
//	        - Case a: if f(x) &lt; f(t),
//	            x &lt;- x, y &lt;- t.
//	        - Case b: if f(t) &lt;= f(x) &amp;&amp; f'(t)*f'(x) &gt; 0,
//	            x &lt;- t, y &lt;- y.
//	        - Case c: if f(t) &lt;= f(x) &amp;&amp; f'(t)*f'(x) &lt; 0, 
//	            x &lt;- t, y &lt;- x.
//	     */
//	    if (*fx &lt; *ft) {
//	        /* Case a */
//	        *y = *t;
//	        *fy = *ft;
//	        *dy = *dt;
//	    } else {
//	        /* Case c */
//	        if (dsign) {
//	            *y = *x;
//	            *fy = *fx;
//	            *dy = *dx;
//	        }
//	        /* Cases b and c */
//	        *x = *t;
//	        *fx = *ft;
//	        *dx = *dt;
//	    }
//
//	    /* Clip the new trial value in [tmin, tmax]. */
//	    if (tmax &lt; newt) newt = tmax;
//	    if (newt &lt; tmin) newt = tmin;
//
//	    /*
//	        Redefine the new trial value if it is close to the upper bound
//	        of the interval.
//	     */
//	    if (*brackt &amp;&amp; bound) {
//	        mq = *x + 0.66 * (*y - *x);
//	        if (*x &lt; *y) {
//	            if (mq &lt; newt) newt = mq;
//	        } else {
//	            if (newt &lt; mq) newt = mq;
//	        }
//	    }
//
//	    /* Return the new trial value. */
//	    *t = newt;
//	    return 0;
//	}
    static double owlqn_x1norm(
        final double[] x,
        final int start,
        final int n
    ) {
        int i;
<span class="nc" id="L1978">        double norm = 0.;</span>

<span class="nc bnc" id="L1980" title="All 2 branches missed.">        for (i = start; i &lt; n; ++i) {</span>
<span class="nc" id="L1981">            norm += Math.abs(x[i]);</span>
        }

<span class="nc" id="L1984">        return norm;</span>
    }

    static void owlqn_pseudo_gradient(
        double[] pg,
        final double[] x,
        final double[] g,
        final int n,
        final double c,
        final int start,
        final int end
    ) {
        int i;

        /* Compute the negative of gradients. */
<span class="nc bnc" id="L1999" title="All 2 branches missed.">        for (i = 0; i &lt; start; ++i) {</span>
<span class="nc" id="L2000">            pg[i] = g[i];</span>
        }

        /* Compute the psuedo-gradients. */
<span class="nc bnc" id="L2004" title="All 2 branches missed.">        for (i = start; i &lt; end; ++i) {</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">            if (x[i] &lt; 0.) {</span>
                /* Differentiable. */
<span class="nc" id="L2007">                pg[i] = g[i] - c;</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">            } else if (0. &lt; x[i]) {</span>
                /* Differentiable. */
<span class="nc" id="L2010">                pg[i] = g[i] + c;</span>
            } else {
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                if (g[i] &lt; -c) {</span>
                    /* Take the right partial derivative. */
<span class="nc" id="L2014">                    pg[i] = g[i] + c;</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                } else if (c &lt; g[i]) {</span>
                    /* Take the left partial derivative. */
<span class="nc" id="L2017">                    pg[i] = g[i] - c;</span>
                } else {
<span class="nc" id="L2019">                    pg[i] = 0.;</span>
                }
            }
        }

<span class="nc bnc" id="L2024" title="All 2 branches missed.">        for (i = end; i &lt; n; ++i) {</span>
<span class="nc" id="L2025">            pg[i] = g[i];</span>
        }
<span class="nc" id="L2027">    }</span>

    static void owlqn_project(
        double[] d,
        final double[] sign,
        final int start,
        final int end
    ) {
        int i;

<span class="nc bnc" id="L2037" title="All 2 branches missed.">        for (i = start; i &lt; end; ++i) {</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">            if (d[i] * sign[i] &lt;= 0) {</span>
<span class="nc" id="L2039">                d[i] = 0;</span>
            }
        }
<span class="nc" id="L2042">    }</span>
    
    private static double innerProduct(double[] a, double[] b) {
<span class="fc" id="L2045">        double result = 0.0;</span>
<span class="fc" id="L2046">        int len = Math.min(a.length, b.length);</span>
<span class="fc bfc" id="L2047" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L2048">            result += a[i] * b[i];</span>
        }
<span class="fc" id="L2050">        return result;</span>
    }

    ////////////////////////////////////////////////////
    static void linreg_test(final double[][] X, final double[] Y) {
<span class="nc" id="L2055">        final int Nfeat = X[0].length;</span>
<span class="nc" id="L2056">        Function f = new Function() {</span>
            @Override
            public double evaluate(double[] beta, double[] g, int n, double step) {
                double sqloss = 0;
                Arrays.fill(g, 0); // is this necessary?
                for (int i = 0; i &lt; n; i++) {
                    double pred = innerProduct(beta, X[i]);
                    double resid = pred - Y[i];
                    sqloss += Math.pow(resid, 2);
                    for (int j = 0; j &lt; Nfeat; j++) {
                        g[j] += X[i][j] * resid;
                    }
                }
                return sqloss;
            }
        };
<span class="nc" id="L2072">        Params p = new Params();</span>
<span class="nc" id="L2073">        ProgressCallback cb = new ProgressCallback() {</span>
            @Override
            public int apply(double[] x, double[] g, double fx, double xnorm,
                double gnorm, double step, int n, int k, Status ls) {
                System.out.printf(&quot;ITER %d obj=%g sol=%.6g\n&quot;, k, fx, x[0]);
                return 0;
            }
        };
<span class="nc" id="L2081">        double[] coef = new double[Nfeat];</span>
<span class="nc" id="L2082">        Result r = LBFGS.lbfgs(coef, f, cb, p);</span>
<span class="nc" id="L2083">        System.out.println(r);</span>
<span class="nc" id="L2084">        System.out.println(Arrays.toString(coef));</span>
<span class="nc" id="L2085">    }</span>

    static void mean_test() {
<span class="nc" id="L2088">        final int target = 3;</span>
<span class="nc" id="L2089">        Function f = new Function() {</span>
            @Override
            public double evaluate(double[] x, double[] g, int n, double step) {
                double resid = x[0] - target;
                double sqloss = Math.pow(resid, 2);
                g[0] = resid;
                return sqloss;
            }
        };
<span class="nc" id="L2098">        Params p = new Params();</span>
<span class="nc" id="L2099">        ProgressCallback cb = new ProgressCallback() {</span>
            @Override
            public int apply(double[] x, double[] g, double fx, double xnorm,
                double gnorm, double step, int n, int k, Status ls) {
                System.out.printf(&quot;ITER %d sol=%s obj=%g\n&quot;, 
                    k, Arrays.toString(x), fx);
                return 0;
            }
        };
<span class="nc" id="L2108">        double[] sol = new double[1];</span>
<span class="nc" id="L2109">        System.out.println(Arrays.toString(sol));</span>
<span class="nc" id="L2110">        Result r = LBFGS.lbfgs(sol, f, cb, p);</span>
<span class="nc" id="L2111">        System.out.println(r.toString());</span>
<span class="nc" id="L2112">        System.out.println(Arrays.toString(sol));</span>
<span class="nc" id="L2113">    }</span>

    public static void main(String[] args) {
//		mean_test();
        /*double[][] X = Arr.readDoubleMatrix(args[0]);
        double[] Y = Arr.readDoubleVector(args[1]);
        linreg_test(X, Y);*/
<span class="nc" id="L2120">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
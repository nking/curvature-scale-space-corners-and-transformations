<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Helper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.brendano.LBFGS</a> &gt; <span class="el_source">Helper.java</span></div><h1>Helper.java</h1><pre class="source lang-java linenums">package thirdparty.brendano.LBFGS;

import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Arrays;
import thirdparty.brendano.LBFGS.LBFGS.Function;

/**
 *
 * @author nichole
 */
<span class="nc" id="L13">public class Helper {</span>
   
    /**
     * NOTE: NOT READY FOR USE.  THE Gradient calculation needs to be
     * improved.
     * a function that calculates the negative of the log likelihood
     * useful for 2D curve fitting.
     */
    public static class FunctionPolyML implements Function {

        final double[] xp;
        final double[] yp;
        final double[] initVars;

        //TODO: consider a constructor that accepts errors for the points
        
        public FunctionPolyML(final double[] xPoints, double[] yPoints,
            double[] init) {
            if (xPoints.length != yPoints.length) {
                throw new IllegalArgumentException(
                    &quot;xPoints and yPoints must be same length&quot;);
            }
            this.xp = xPoints;
            this.yp = yPoints;
            this.initVars = init;
        }

        @Override
        public double evaluate(final double[] coeffs,
            final double[] outputGradient, int nCoeffs, double step) {
        
            final double[] diff = new double[yp.length];
            
            final double sumDiff = polynomialCoeffGradient(xp, yp, coeffs, 
                outputGradient, diff);
         
            // TODO: revisit this to consider including errors given
            //   to the code for each point.
            
            double[] mnAndStDv = MiscMath.getAvgAndStDev(diff);
            double sigma = mnAndStDv[1] * mnAndStDv[1];
            
            double f = Math.pow((1.0/(2.0*Math.PI*sigma)), (coeffs.length/2))
                * Math.exp(-1. * sumDiff/(2. * sigma));
    
            double lnf = -2. * Math.log(f);
            
            //System.out.println(&quot; lnf=&quot; + lnf);
         
            return lnf;
        }
    }
 
    /**
     * calculate the gradient of the polynomial coefficients and return the
     * square root of the sum of the squared differences between data (xp, yp)
     * and the generated polynomial while populating the difference array
     * of y in the generated model and data yp.
     * 
     * @param xp
     * @param yp
     * @param coeffs
     * @param outputCoeffGrad
     * @param outputDiffY
     * @return 
     */
    public static double polynomialCoeffGradient(final double[] xp, 
        final double[] yp, final double[] coeffs, 
        final double[] outputCoeffGrad, final double[] outputDiffY) {
        
<span class="fc" id="L83">        double[] y = new double[xp.length];</span>

<span class="fc" id="L85">        Arrays.fill(outputCoeffGrad, 0.);</span>

        /*
        calculating the gradient of the polynomial coefficients

        example function generated by 3 coefficients:
           gen = c0 * x^2 + c1 * x^1 + c2

           d(gen)/d(c0) = x^2
           d(gen)/d(c1) = x^1
           d(gen)/d(c2) = 1

           d(c0)= d(gen)/x^2
           d(c1)= d(gen)/x
           d(c2)= d(gen)

           gen = c0 * x^2 + c1 * x^1 + c2
           d(gen)/d(x) = 2 * c0 * x + c1
           d(gen) = d(x) * (2 * c0 * x + c1)

           d(c0)= d(gen)/x^2
                = d(x) * (2 * c0 * x + c1) / x^2
           d(c1)= d(gen)/x
                = d(x) * (2 * c0 * x + c1) / x
           d(c2)= d(gen)/x
                = d(x) * (2 * c0 * x + c1)
        */

<span class="fc" id="L113">        double[] gen = Misc.generate(coeffs, xp);</span>

<span class="fc" id="L115">        MatrixUtil.subtract(gen, yp, outputDiffY);</span>

<span class="fc" id="L117">        double sumDiff = 0;</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (int i = 0; i &lt; xp.length; ++i) {</span>
<span class="fc" id="L120">            double x2 = 1;</span>
<span class="fc" id="L121">            double dx = outputDiffY[i];</span>
<span class="fc" id="L122">            double d = dPolydX(coeffs, xp[i]);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            for (int j = coeffs.length - 1; j &gt; -1; j--) {</span>
<span class="fc" id="L124">                int varIdx = coeffs.length - j - 1;</span>
<span class="fc" id="L125">                outputCoeffGrad[varIdx] += (dx * d / x2);                      </span>
<span class="fc" id="L126">                x2 *= xp[i];</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                if (x2 == 0.0) {</span>
<span class="fc" id="L128">                    break;</span>
                }
            }
<span class="fc" id="L131">            sumDiff += (dx * dx);</span>
        }
<span class="fc" id="L133">        sumDiff = Math.sqrt(sumDiff);</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int j = 0; j &lt; coeffs.length; ++j) {</span>
<span class="fc" id="L136">            outputCoeffGrad[j] /= xp.length;</span>
        }

        /*
        System.out.println(&quot;==&gt;vars=&quot; + Arrays.toString(vars));
        System.out.println(&quot;==&gt;diff=&quot; + Arrays.toString(diff));
        System.out.println(&quot;==&gt;sumDiff=&quot; + sumDiff);
        System.out.println(&quot;==&gt;gradient=&quot; + Arrays.toString(outputGradient));
        */

<span class="fc" id="L146">        return sumDiff;</span>
    }
    
    /**
     * assuming that the polynomial coefficients coeff are given from
     * highest order to lowest, return the derivative of y with
     * respect to x.
     * e.g. for y = coeff[0] * x^2 + coeff[1] * x^1 + coeff[2]
     * it returns dydx = 2 * coeff[0] * x + coeff[1]
     * @param coeff
     * @param x
     * @return 
     */
    public static double dPolydX(double[] coeff, double x) {
        /*
        y = c0 * x^2 + c1 * x^1 + c2
        */
<span class="fc" id="L163">        double sum = 0;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        for (int order = (coeff.length - 1); order &gt; 0; --order) {</span>
<span class="fc" id="L165">            sum += dPolydX(order, coeff[order], x);</span>
        }
        
<span class="fc" id="L168">        return sum;</span>
    }
    
    private static double dPolydX(int order, double coeff, double x) {
        
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (order == 0) {</span>
<span class="nc" id="L174">            return 0;</span>
        }
        
<span class="fc" id="L177">        double dydx = coeff * (double)order * Math.pow(x, order - 1);</span>
        
<span class="fc" id="L179">        return dydx;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
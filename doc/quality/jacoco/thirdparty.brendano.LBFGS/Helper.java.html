<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Helper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.brendano.LBFGS</a> &gt; <span class="el_source">Helper.java</span></div><h1>Helper.java</h1><pre class="source lang-java linenums">package thirdparty.brendano.LBFGS;

import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Arrays;
import thirdparty.brendano.LBFGS.LBFGS.Function;

/**
 *
 * @author nichole
 */
<span class="nc" id="L13">public class Helper {</span>
   
    /**
     * NOTE: NOT READY FOR USE.  THE Gradient calculation needs to be
     * improved.
     * a function that calculates the negative of the log likelihood
     * useful for 2D curve fitting.
     */
    public static class FunctionPolyML implements Function {

        final double[] xp;
        final double[] yp;
        final double[] initVars;

        //TODO: consider a constructor that accepts errors for the points
        
        public FunctionPolyML(final double[] xPoints, double[] yPoints,
            double[] init) {
            if (xPoints.length != yPoints.length) {
                throw new IllegalArgumentException(
                    &quot;xPoints and yPoints must be same length&quot;);
            }
            this.xp = xPoints;
            this.yp = yPoints;
            this.initVars = init;
        }

        @Override
        public double evaluate(final double[] coeffs,
            final double[] outputGradient, int nCoeffs, double step) {
        
            final double[] diff = new double[yp.length];
            
            final double sumDiff = polynomialCoeffGradient(xp, yp, coeffs, 
                outputGradient, diff);
         
            // TODO: revisit this to consider including errors given
            //   to the code for each point.
            
            double[] mnAndStDv = MiscMath.getAvgAndStDev(diff);
            double sigma = mnAndStDv[1] * mnAndStDv[1];
            
            double f = Math.pow((1.0/(2.0*Math.PI*sigma)), (coeffs.length/2))
                * Math.exp(-1. * sumDiff/(2. * sigma));
    
            double lnf = -2. * Math.log(f);
            
            System.out.println(&quot; lnf=&quot; + lnf);

            return lnf;
        }
    }
 
    /**
     * calculate the gradient of the polynomial coefficients and return the
     * square root of the sum of the squared differences between data (xp, yp)
     * and the generated polynomial while populating the difference array
     * of y in the generated model and data yp.
     * 
     * @param xp
     * @param yp
     * @param coeffs
     * @param outputCoeffGrad
     * @param outputDiffY
     * @return 
     */
    public static double polynomialCoeffGradient(final double[] xp, 
        final double[] yp, final double[] coeffs, 
        final double[] outputCoeffGrad, final double[] outputDiffY) {
        
<span class="fc" id="L83">        double[] y = new double[xp.length];</span>

<span class="fc" id="L85">        Arrays.fill(outputCoeffGrad, 0.);</span>

        /*
        calculating the gradient of the polynomial coefficients

        example function generated by 3 coefficients:
           gen = c0 * x^2 + c1 * x^1 + c2
        
           d(gen)/d(c0) = x^2
           d(gen)/d(c1) = x^1
           d(gen)/d(c2) = 1
        */

<span class="fc" id="L98">        double[] gen = Misc.generate(coeffs, xp);</span>

<span class="fc" id="L100">        MatrixUtil.subtract(gen, yp, outputDiffY);</span>

<span class="fc" id="L102">        double sumDiff = 0;</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (int i = 0; i &lt; xp.length; ++i) {</span>
<span class="fc" id="L105">            double x2 = 1;</span>
<span class="fc" id="L106">            double dyAtX = outputDiffY[i];</span>
<span class="fc" id="L107">            double dydx = dPolydXHL(coeffs, xp[i]);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            for (int j = coeffs.length - 1; j &gt; -1; j--) {</span>
<span class="fc" id="L109">                int varIdx = coeffs.length - j - 1;</span>
                
                //dc/dx = dy/dx * dc/dy
                //dc = dx * dy/dx * dc/dy
                //outputCoeffGrad[varIdx] += (dyAtX * dydx / x2);
               
<span class="fc" id="L115">                double dx = dyAtX * (xp[i]/gen[i]);</span>
<span class="fc" id="L116">                outputCoeffGrad[varIdx] +=</span>
                    ( dx * dydx / (x2));
                
<span class="fc" id="L119">                x2 *= xp[i];</span>
                
<span class="fc bfc" id="L121" title="All 2 branches covered.">                if (x2 == 0.0) {</span>
<span class="fc" id="L122">                    break;</span>
                }
            }
<span class="fc" id="L125">            sumDiff += (dyAtX * dyAtX);</span>
        }
<span class="fc" id="L127">        sumDiff = Math.sqrt(sumDiff);</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (int j = 0; j &lt; coeffs.length; ++j) {</span>
<span class="fc" id="L130">            outputCoeffGrad[j] /= xp.length;</span>
        }
        
        /*
        System.out.println(&quot;==&gt;vars=&quot; + Arrays.toString(coeffs));
        System.out.print(&quot;==&gt;diff=&quot;); printFormattedArray(outputDiffY);
        System.out.println(&quot;==&gt;sumDiff=&quot; + sumDiff);
        System.out.print(&quot;==&gt;gradient=&quot;); printFormattedArray(outputCoeffGrad);
        */
        
<span class="fc" id="L140">        return sumDiff;</span>
    }
    
    /**
     * assuming that the polynomial coefficients coeff are given from
     * highest order to lowest, return the derivative of y with
     * respect to x.
     * e.g. for y = coeff[0] * x^2 + coeff[1] * x^1 + coeff[2]
     * it returns dydx = 2 * coeff[0] * x + coeff[1]
     * @param coeff
     * @param x
     * @return 
     */
    public static double dPolydXHL(double[] coeff, double x) {
        /*
        y = c0 * x^2 + c1 * x^1 + c2
        */
<span class="fc" id="L157">        double sum = 0;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        for (int i = 0; i &lt; coeff.length; ++i) {</span>
<span class="fc" id="L159">            int order = coeff.length - i - 1;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (order == 0) continue;</span>
<span class="fc" id="L161">            sum += dPolydX(order, coeff[i], x);</span>
        }
        
<span class="fc" id="L164">        return sum;</span>
    }
    
    /**
     * assuming that the polynomial coefficients coeff are given from
     * lowest order to highest, return the derivative of y with
     * respect to x.
     * e.g. for y = coeff[0] + coeff[1] * x + coeff[2]*x^2
     * it returns dydx = coeff[1] + 2.*coeff[1]*x
     * @param coeff
     * @param x
     * @return 
     */
    public static double dPolydXLH(double[] coeff, double x) {
       
<span class="nc" id="L179">        double sum = 0;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (int order = 1; order &lt; coeff.length; ++order) {</span>
<span class="nc" id="L181">            sum += dPolydX(order, coeff[order], x);</span>
        }
        
<span class="nc" id="L184">        return sum;</span>
    }
    
    private static double dPolydX(int order, double coeff, double x) {
        
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (order == 0) {</span>
<span class="nc" id="L190">            return 0;</span>
        }
        
<span class="fc" id="L193">        double dydx = coeff * (double)order * Math.pow(x, order - 1);</span>
        
<span class="fc" id="L195">        return dydx;</span>
    }
    
    private static void printFormattedArray(double[] a) {
<span class="nc" id="L199">        System.out.print(&quot;[&quot;);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        for (double m : a) {</span>
<span class="nc" id="L201">            System.out.format(&quot;%.3f, &quot;, (float)m);</span>
        }
<span class="nc" id="L203">        System.out.println(&quot;]&quot;);</span>
<span class="nc" id="L204">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
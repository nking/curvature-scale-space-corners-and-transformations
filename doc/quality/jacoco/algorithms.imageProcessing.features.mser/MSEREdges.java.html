<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MSEREdges.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features.mser</a> &gt; <span class="el_source">MSEREdges.java</span></div><h1>MSEREdges.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features.mser;

import algorithms.QuickSort;
import algorithms.bipartite.MinHeapForRT2012;
import algorithms.compGeometry.PerimeterFinder2;
import algorithms.imageProcessing.CannyEdgeColorAdaptive;
import algorithms.connected.ConnectedPointsFinder;
import algorithms.imageProcessing.CIEChromaticity;
import algorithms.imageProcessing.EdgeFilterProducts;
import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.GroupPixelHSV;
import algorithms.imageProcessing.GroupPixelHSV2;
import algorithms.imageProcessing.GroupPixelLUVWideRangeLightness;
import algorithms.heapsAndPQs.HeapNode;
import algorithms.imageProcessing.Image;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.ImageIOHelper;
import algorithms.imageProcessing.ImageProcessor;
import algorithms.compGeometry.MiscellaneousCurveHelper;
import algorithms.imageProcessing.SummedAreaTable;
import algorithms.imageProcessing.features.HCPT;
import algorithms.imageProcessing.features.HGS;
import algorithms.imageProcessing.features.HOGs;
import algorithms.imageProcessing.features.PatchUtil;
import algorithms.imageProcessing.features.mser.MSER.Threshold;
import algorithms.imageProcessing.matching.CMODE;
import algorithms.util.AngleUtil;
import algorithms.misc.Misc;
import algorithms.misc.MiscDebug;
import algorithms.packing.Intersection2DPacking;
import algorithms.util.PairInt;
import algorithms.util.PixelHelper;
import algorithms.VeryLongBitString;
import gnu.trove.iterator.TIntIntIterator;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.iterator.TIntObjectIterator;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TDoubleArrayList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import thirdparty.edu.princeton.cs.algs4.Interval;
import thirdparty.edu.princeton.cs.algs4.Interval2D;
import thirdparty.edu.princeton.cs.algs4.QuadTree;

/**
 * class to explore the boundaries of the accumulated points in MSER regions
 * to make edges that are complete contours (the level sets approach has a
 * much larger pixel association than the few pixels of canny edges for
 * example).
 *
 * It currently uses the level sets found in the MSER =made from
 * greyscale and &quot;H&quot; of LCH color space images (caveat, configured
 * to extract MSER regions from images from COTS of past several years
 * binned to size near 256 X 256).
 * The boundaries of the accumulated points in the regions are extracted
 * and the high scoring points are kept where score is a combination
 * of sobel color contrast and sobel greyscale intensity values).
 *
 * The class in not ready for use yet.
 *
 * NOTE that the default mode may change to the low contrast settings.
 *
 * Also note that there are fixed parameters tailored for the input images
 * scaled to 256 X 256, especially for the use of merging
 * (see int[] mszs = ...).
 * 
 * @author nichole
 */
public class MSEREdges {

    /*
    given a color image
      -- makes greyscale image and a polar theta of cie luv
      -- creates positive and negative mser regions for both,
            filtering by variation for the specific mser type
    extractEdges:
        -- uses PerimeterFinder2 extract the outer boundaries from each mser
           region points, and the same for the contiguous embedded regions.
           extractAndMergeEdges
        -- merges adjacent regions by similarity of color (and maybe texture in future)
        -- extracts edges using PerimeterFinder2 just as above

    */

    private enum STATE {
        INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
    }

    private final ImageExt clrImg;
    private final GreyscaleImage gsImg;
    private final GreyscaleImage ptImg;
    // ptImg shifted by +60 degrees in pixel values to look for wrap around affects
    private final GreyscaleImage ptImgShifted;
<span class="fc" id="L105">    private List&lt;Region&gt; regions = null;</span>

    //a re-extraction of regions on the gs positive image, but using the
    // MSER parameters used for the negative image.
    // this is not useful in edges, but is useful for other methods.
<span class="fc" id="L110">    private List&lt;Region&gt; sensitiveGS0 = null;</span>

    // the original regions for gs positive, negative, then pt positive
    // and negative.  regions should be prefered for most
    // uses.
<span class="fc" id="L115">    private List&lt;List&lt;Region&gt;&gt; origGsPtRegions = null;</span>

    
    /**
     * list of sets of labeled edges.  
     * NOTE that the indexes of edgeList are implicitly the labels and are the 
     * same labels present as the indexes of labeledSets.
     * labeledEdges are the boundary pixels of the labeledSets.
     * The values within the sets are the pixel indexes.
     * NOTE that the lists of regions DO NOT HAVE the same labels as indexes.
     */
<span class="fc" id="L126">    private List&lt;TIntSet&gt; labeledEdges = null;</span>

    /**
     * list of sets of labeled blobs.  
     * NOTE that the indexes of labeledSets are implicitly the labels and are the 
     * same labels present as the indexes of labeledEdges.
     * labeledEdges are the boundary pixels of the labeledSets.
     * The values within the sets are the pixel indexes.
     * NOTE that the lists of regions DO NOT HAVE the same labels as indexes.
     */
<span class="fc" id="L136">    private List&lt;TIntSet&gt; labeledSets = null;</span>

<span class="fc" id="L138">    private boolean debug = false;</span>

<span class="fc" id="L140">    private boolean useLowerContrastLimits = true;</span>

<span class="fc" id="L142">    private GreyscaleImage sobelScores = null;</span>

<span class="fc" id="L144">    private GreyscaleImage cannyEdges = null;</span>
    
<span class="fc" id="L146">    private EdgeFilterProducts edgeProducts = null;</span>

<span class="fc" id="L148">    private long ts = 0;</span>
    
<span class="fc" id="L150">    private static int thetaShift = 60;</span>

<span class="fc" id="L152">    private STATE state = null;</span>

<span class="fc" id="L154">    public MSEREdges(Image img) {</span>
        
<span class="fc" id="L156">        ImageProcessor imageProcessor = new ImageProcessor();</span>
<span class="fc" id="L157">        this.gsImg = img.copyToGreyscale2();</span>
<span class="fc" id="L158">        this.ptImg = imageProcessor.createCIELUVTheta_WideRangeLightness(img, 255);</span>
<span class="fc" id="L159">        this.clrImg = img.copyToImageExt();</span>

        //to correct for wrap around effects in ptImg, making a copy
        //   shifted by -60 degrees in pixel values.
        //   any false regions found due to the range 0-255 being wrap
        //   around from 255 to 0, but perceived as different can be
        //   found by comparing these two image's results, though
        //   there may be faster ways to achieve this.
<span class="fc" id="L167">        this.ptImgShifted = imageProcessor.copyAndShiftPolarAngleImage(ptImg, thetaShift);</span>

<span class="fc" id="L169">        state = STATE.INITIALIZED;</span>
<span class="fc" id="L170">    }</span>

    public void setToDebug() {
<span class="nc" id="L173">        debug = true;</span>
<span class="nc" id="L174">        ts = MiscDebug.getCurrentTimeFormatted();</span>
<span class="nc" id="L175">    }</span>

    public void extractEdges() {

        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (!state.equals(STATE.INITIALIZED)) {</span>
<span class="nc" id="L181">            throw new IllegalStateException(&quot;can only perform extraction of &quot;</span>
                + &quot;edges once&quot;);
        }
        
        /*if (debug) {
            MiscDebug.writeImage(ptImg, &quot;_&quot; + ts + &quot;_polartheta&quot;);
            MiscDebug.writeImage(gsImg, &quot;_&quot; + ts + &quot;_greyscale&quot;);
            MiscDebug.writeImage(ptImgShifted, &quot;_&quot; + ts + &quot;_polartheta_shifted&quot;);
        }*/

<span class="fc" id="L191">        extractRegions();</span>

<span class="fc" id="L193">        extractBoundaries();</span>

<span class="pc bnc" id="L195" title="All 2 branches missed.">        assert(labeledSets != null);</span>
<span class="pc bnc" id="L196" title="All 2 branches missed.">        assert(labeledEdges != null);</span>
<span class="pc bnc" id="L197" title="All 2 branches missed.">        assert(labeledEdges.size() == labeledSets.size());</span>

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L200">            printEdges();</span>
        }
<span class="fc" id="L202">    }</span>

    /**
     * merge regions and then extract edges.  this method is most useful when
     * setToLowerContrast() has been invoked before.
     */
    public void extractAndMergeEdges() {

        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (!state.equals(STATE.INITIALIZED)) {</span>
<span class="nc" id="L212">            throw new IllegalStateException(&quot;can only perform extraction of &quot;</span>
                + &quot;edges once&quot;);
        }
        
<span class="fc" id="L216">        long t0 = System.currentTimeMillis();</span>
        
<span class="fc" id="L218">        extractEdges();</span>

<span class="fc" id="L220">        mergeRegions();</span>

<span class="fc" id="L222">        long t1 = System.currentTimeMillis();</span>

<span class="fc" id="L224">        System.out.format(&quot;==&gt; %.3f sec for extractAndMerge\n&quot;, </span>
<span class="fc" id="L225">            ((float)(t1 - t0)/1000.f));</span>
        
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L228">            printEdges();</span>
        }
        
<span class="fc" id="L231">    }</span>

    private void extractRegions() {

        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (getState().equals(STATE.EDGES_EXTRACTED)) {</span>
<span class="nc" id="L237">            throw new IllegalStateException(&quot;can only perform extraction of &quot;</span>
                + &quot;edges once&quot;);
        }
        
<span class="fc" id="L241">        long t0 = System.currentTimeMillis();</span>

<span class="fc" id="L243">        List&lt;List&lt;Region&gt;&gt; gsRegions = extractMSERRegions(gsImg, Threshold.LESS_SENSITIVE);</span>

<span class="fc" id="L245">        List&lt;List&lt;Region&gt;&gt; ptRegions = extractMSERRegions(ptImg, Threshold.DEFAULT);</span>

<span class="fc" id="L247">        List&lt;List&lt;Region&gt;&gt; ptShiftedRegions = extractMSERRegions(</span>
            ptImgShifted, Threshold.DEFAULT);
            
        //_debugOrigRegions(ptRegions.get(0), &quot;__0&quot;);
        //_debugOrigRegions(ptShiftedRegions.get(0), &quot;_shifted_0&quot;);
        //_debugOrigRegions(ptShiftedRegions.get(1), &quot;_shifted_1&quot;);

<span class="fc" id="L254">        regions = new ArrayList&lt;Region&gt;();</span>
<span class="fc" id="L255">        Set&lt;Region&gt; uniqueRegions = new HashSet&lt;Region&gt;();</span>

<span class="fc" id="L257">        origGsPtRegions = new ArrayList&lt;List&lt;Region&gt;&gt;();</span>

<span class="fc" id="L259">        int w = ptImg.getWidth();</span>
<span class="fc" id="L260">        int h = ptImg.getHeight();</span>

        // for minArea 0.001, a gsRegions limit for var of 0. is used
        //   but for 0.0001, limit should be near 0.001

<span class="fc bfc" id="L265" title="All 2 branches covered.">        for (int type = 0; type &lt; 2; ++type) {</span>
<span class="fc" id="L266">            List&lt;Region&gt; list = gsRegions.get(type);</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">            for (int i = (list.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L269">                Region r = list.get(i);</span>
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">                if ((type == 1) &amp;&amp; r.getVariation() &gt; 2.) {</span>
<span class="nc" id="L271">                    list.remove(i);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                } else if ((type == 0)</span>
                    //&amp;&amp; r.getVariation() == 0.0) {
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">                    &amp;&amp; r.getVariation() &lt; 2.) {</span>
<span class="fc" id="L275">                    list.remove(i);</span>
                }
            }

            // copy list into origGsPtRegions
<span class="fc" id="L280">            List&lt;Region&gt; cpList = new ArrayList&lt;Region&gt;();</span>
<span class="fc" id="L281">            origGsPtRegions.add(cpList);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            for (Region r : list) {</span>
<span class="fc" id="L283">                cpList.add(r.copy());</span>
                //regions.add(r);
<span class="fc" id="L285">                uniqueRegions.add(r);</span>
<span class="fc" id="L286">            }</span>
        }

<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (int type = 0; type &lt; 2; ++type) {</span>
<span class="fc" id="L290">            List&lt;Region&gt; list = ptRegions.get(type);</span>
<span class="fc" id="L291">            GreyscaleImage negImg = null;</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (type == 1) {</span>
<span class="fc" id="L293">                negImg = ptImg.copyImage();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">                for (int i = 0; i &lt; ptImg.getNPixels(); ++i) {</span>
<span class="fc" id="L295">                    int v = ~ptImg.getValue(i);</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                    if (v &lt; 0) {</span>
<span class="fc" id="L297">                        v += 256;</span>
                    }
<span class="fc" id="L299">                    negImg.setValue(i, v);</span>
                }
            }

<span class="fc" id="L303">            boolean hadWrapAroundArtifacts = false;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (int i = (list.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L305">                Region r = list.get(i);</span>
                //System.out.println(i + &quot;) r=&quot; + r.toString());
<span class="fc bfc" id="L307" title="All 2 branches covered.">                if ((type == 1)</span>
                    //&amp;&amp; r.getVariation() &gt; 0.001) {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">                    &amp;&amp; r.getVariation() &gt; 2) {</span>
<span class="nc" id="L310">                    list.remove(i);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">                } else if ((type == 0)</span>
                    //&amp;&amp; r.getVariation() == 0.0) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">                    &amp;&amp; r.getVariation() != 0.0</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                    &amp;&amp; r.getVariation() &lt; 2) {</span>
<span class="fc" id="L315">                    list.remove(i);</span>
                } else {
                    // check for this Region being an artifact of wrap around
<span class="fc bfc" id="L318" title="All 2 branches covered.">                    if (r.level_ &lt; 25) {</span>
<span class="fc" id="L319">                        list.remove(i);</span>
<span class="fc" id="L320">                        hadWrapAroundArtifacts = true;</span>
                    } else {
                        int avgLevel;
<span class="fc bfc" id="L323" title="All 2 branches covered.">                        if (type == 0) {</span>
<span class="fc" id="L324">                            avgLevel = calcAvg(ptImg, r.getAcc(w));</span>
                        } else {
<span class="fc" id="L326">                            avgLevel = calcAvg(negImg, r.getAcc(w));</span>
                        }
                        //System.out.format(&quot; %d add x,y=%d,%d level=%d  avgLevel=%d\n&quot;,
                        //    type, (int)(r.moments_[0]/r.area_),
                        //    (int)(r.moments_[1]/r.area_), r.level_,
                        //    avgLevel);
<span class="fc bfc" id="L332" title="All 2 branches covered.">                        if (avgLevel &gt; 240) {//230?</span>
<span class="fc" id="L333">                            list.remove(i);</span>
                        }
                    }
                }
            }
            //System.out.println(&quot;hadWrapAroundArtifacts=&quot; + hadWrapAroundArtifacts);
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (hadWrapAroundArtifacts) {</span>
                // excluded level &lt; 25.
                //   so shift by +60 and any region found w level approx 60
                //   is a real region possibly excluded near level=0
                // if find a region near level=60, edit the level
                //   and add it to list
<span class="fc" id="L345">                List&lt;Region&gt; list2 = ptShiftedRegions.get(type);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                for (int i = (list2.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L347">                    Region r = list2.get(i);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                    if ((type == 1)</span>
                        //&amp;&amp; r.getVariation() &gt; 0.001) {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                        &amp;&amp; r.getVariation() &gt; 2) {</span>
<span class="nc" id="L351">                        list2.remove(i);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    } else if ((type == 0)</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">                        &amp;&amp; r.getVariation() != 0.0</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                        &amp;&amp; r.getVariation() &lt; 2) {</span>
<span class="fc" id="L355">                        list2.remove(i);</span>
                    } else {
                        //TODO: consider checking whether this already exists in
                        //   the list
<span class="fc bfc" id="L359" title="All 2 branches covered.">                        if (Math.abs(r.level_ - thetaShift) &lt; 20) {</span>
<span class="fc" id="L360">                            r.level_ += thetaShift;</span>
<span class="fc" id="L361">                            list.add(r);</span>
                            //System.out.format(&quot;  add shifted x,y=%d,%d level=%d\n&quot;,
                            //   (int)(r.moments_[0]/r.area_),
                            //   (int)(r.moments_[1]/r.area_), r.level_);
                        }
                        //TODO: consider adding other regions in list2
                        //   as long as level is &gt; 25 and &lt; 230
                    }
                }
            }

            // copy list into origGsPtRegions
<span class="fc" id="L373">            List&lt;Region&gt; cpList = new ArrayList&lt;Region&gt;();</span>
<span class="fc" id="L374">            origGsPtRegions.add(cpList);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            for (Region r : list) {</span>
                //regions.add(r);
<span class="fc" id="L377">                uniqueRegions.add(r);</span>
<span class="fc" id="L378">                cpList.add(r.copy());</span>
<span class="fc" id="L379">            }</span>
        }

<span class="fc" id="L382">        uniqueRegions.addAll(_extractSensitiveGS0());</span>
        //_debugOrigRegions(regions,&quot;_GS0__&quot;);

<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L386">            int[] xyCen = new int[2];</span>
            Image imCp;
            int n;
            List&lt;Region&gt; list;
<span class="nc bnc" id="L390" title="All 2 branches missed.">            for (int type = 0; type &lt; 2; ++type) {</span>
<span class="nc" id="L391">                imCp = gsImg.copyToColorGreyscale();</span>
<span class="nc" id="L392">                list = origGsPtRegions.get(type);</span>
<span class="nc" id="L393">                n = list.size();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L395">                    Region r = list.get(i);</span>
<span class="nc" id="L396">                    int[] clr = ImageIOHelper.getNextRGB(i);</span>
<span class="nc" id="L397">                    r.drawEllipse(imCp, 0, clr[0], clr[1], clr[2]);</span>
<span class="nc" id="L398">                    r.calculateXYCentroid(xyCen, imCp.getWidth(), imCp.getHeight());</span>
<span class="nc" id="L399">                    ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], imCp,</span>
                        1, 255, 0, 0);
                }
<span class="nc" id="L402">                MiscDebug.writeImage(imCp, &quot;_&quot; + ts + &quot;_regions_gs_&quot;+ type);</span>
            }
<span class="nc bnc" id="L404" title="All 2 branches missed.">            for (int type = 0; type &lt; 2; ++type) {</span>
<span class="nc" id="L405">                imCp = ptImg.copyToColorGreyscale();</span>
<span class="nc" id="L406">                list = origGsPtRegions.get(type + 2);</span>
<span class="nc" id="L407">                n = list.size();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L409">                    Region r = list.get(i);</span>
<span class="nc" id="L410">                    int[] clr = ImageIOHelper.getNextRGB(i);</span>
<span class="nc" id="L411">                    r.drawEllipse(imCp, 0, clr[0], clr[1], clr[2]);</span>
<span class="nc" id="L412">                    r.calculateXYCentroid(xyCen, imCp.getWidth(), imCp.getHeight());</span>
<span class="nc" id="L413">                    ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], imCp,</span>
                        1, 255, 0, 0);
                    //System.out.println(type + &quot; xy=&quot; + xyCen[0] + &quot;,&quot; + xyCen[1]
                    //    + &quot; variation=&quot; + r.getVariation());
                }
<span class="nc" id="L418">                MiscDebug.writeImage(imCp, &quot;_&quot; + ts + &quot;_regions_pt_&quot;+ type);</span>
            }
        }
        
<span class="fc" id="L422">        regions.addAll(uniqueRegions);</span>
        
<span class="fc" id="L424">        state = STATE.REGIONS_EXTRACTED;</span>
         
<span class="fc" id="L426">        long t1 = System.currentTimeMillis();</span>
        
<span class="fc" id="L428">        System.out.format(&quot;%.3f sec for extractRegions\n&quot;, </span>
<span class="fc" id="L429">            ((float)(t1 - t0)/1000.f));</span>
<span class="fc" id="L430">    }</span>

    private List&lt;List&lt;Region&gt;&gt; extractMSERRegions(GreyscaleImage img,
        Threshold threshold) {

<span class="fc" id="L435">        int delta = 2;</span>
<span class="fc" id="L436">        double minArea = 0.001;//.0001</span>
<span class="fc" id="L437">        double maxArea = 0.99;//0.1;</span>
<span class="fc" id="L438">        double maxVariation = 0.9;//0.5;</span>
<span class="fc" id="L439">        double minDiversity = 0.75;//0.1;//0.5</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (threshold.equals(Threshold.LESS_SENSITIVE)) {</span>
<span class="fc" id="L441">            maxVariation = 2.0;</span>
<span class="fc" id="L442">            minArea = 0.0075;</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            if (useLowerContrastLimits) {</span>
<span class="fc" id="L444">                minDiversity = 0.1;//.4</span>
<span class="fc" id="L445">                delta = 3;//5;</span>
            }
        }

<span class="fc" id="L449">        int[] a = MSER.readIntoArray(img);</span>

<span class="fc" id="L451">        MSER mser = new MSER();</span>

<span class="fc" id="L453">        List&lt;List&lt;Region&gt;&gt; regions = mser.findRegions(a, img.getWidth(),</span>
<span class="fc" id="L454">            img.getHeight(), delta, minArea, maxArea, maxVariation,</span>
            minDiversity);

<span class="fc" id="L457">        return regions;</span>
    }
    
    private TIntSet extractNonEdgePixels(TIntSet edgePixels) {
<span class="fc" id="L461">        int w = clrImg.getWidth();</span>
<span class="fc" id="L462">        int h = clrImg.getHeight();</span>
<span class="fc" id="L463">        int n = clrImg.getNPixels();</span>
        
<span class="fc" id="L465">        TIntSet nonEdgePixels = new TIntHashSet(n - edgePixels.size());</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        for (int pixIdx = 0; pixIdx &lt; n; ++pixIdx) {</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            if (!edgePixels.contains(pixIdx)) {</span>
<span class="fc" id="L468">                nonEdgePixels.add(pixIdx);</span>
            }
        }
        
<span class="fc" id="L472">        return nonEdgePixels;</span>
    }
    
    /**
     * extract the contiguous conneted pixels that are not in edgePixels
     * @param edgePixels
     * @param minGroupSize
     * @return 
     */
    private List&lt;TIntSet&gt; extractContiguousBetweenEdges(TIntSet 
        edgePixels) {
        
<span class="fc" id="L484">        int w = clrImg.getWidth();</span>
<span class="fc" id="L485">        int h = clrImg.getHeight();</span>
<span class="fc" id="L486">        int n = clrImg.getNPixels();</span>
        
<span class="fc" id="L488">        TIntSet nonEdgePixels = extractNonEdgePixels(edgePixels);</span>
    
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L491">            Image tmp = clrImg.createWithDimensions();</span>
<span class="nc" id="L492">            ImageIOHelper.addCurveToImage(</span>
                nonEdgePixels, tmp, 0, 255, 255, 0);
<span class="nc" id="L494">            MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_non_edge_&quot;);</span>
        }
        
<span class="fc" id="L497">        ConnectedPointsFinder finder = new ConnectedPointsFinder(w, h);</span>
<span class="fc" id="L498">        finder.setMinimumNumberInCluster(1);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L500">            finder.setDebug(debug);</span>
            
            //System.out.println(nonEdgePixels.size() + &quot; non-edge pixels&quot;);
        }
        
<span class="fc" id="L505">        finder.findConnectedPointGroups(nonEdgePixels);</span>
        
<span class="fc" id="L507">        List&lt;TIntSet&gt; output = new ArrayList&lt;TIntSet&gt;();</span>
        
<span class="fc" id="L509">        int ns = 0;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">        for (int i = 0; i &lt; finder.getNumberOfGroups(); ++i) {</span>
<span class="fc" id="L511">            TIntSet group = finder.getXY(i);</span>
<span class="fc" id="L512">            output.add(group);</span>
<span class="fc" id="L513">            ns += group.size();</span>
        }
        
<span class="pc bnc" id="L516" title="All 2 branches missed.">        assert(ns == nonEdgePixels.size());</span>
        
<span class="fc" id="L518">        return output;</span>
    }

    private void extractBoundaries() {

        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if (getState().equals(STATE.EDGES_EXTRACTED)) {</span>
<span class="nc" id="L525">            throw new IllegalStateException(&quot;can only perform extraction of &quot;</span>
                + &quot;edges once&quot;);
        }
        
<span class="fc" id="L529">        long t0 = System.currentTimeMillis();</span>

<span class="fc" id="L531">        TIntSet boundaries = combineBoundaries();</span>

<span class="fc" id="L533">        long t1 = System.currentTimeMillis();</span>

        // populate this.edgeList and this.labeledSets
<span class="fc" id="L536">        populateEdgeLists(boundaries);</span>
        
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L539">            Image tmp = clrImg.copyImage();</span>
<span class="nc" id="L540">            ImageIOHelper.addAlternatingColorPointSetsToImage2(</span>
                labeledSets, 0, 0, 0, tmp);
<span class="nc" id="L542">            MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_labeled_boundaries_&quot;);</span>
        }
        
<span class="fc" id="L545">        long ts1_2 = System.currentTimeMillis();</span>
        
<span class="fc" id="L547">        thinTheBoundaries(2);</span>

<span class="fc" id="L549">        long t2 = System.currentTimeMillis();</span>

<span class="fc" id="L551">        System.out.format(</span>
            &quot;%.3f sec for extractBoundaries (&quot;
                + &quot;\n  %.3f sec for combineBoundaries,&quot;
                + &quot;\n  %.3f sec for populateEdgeLists,&quot; 
                + &quot;\n  %.3f sec for thinTheBoundaries)\n&quot;,
<span class="fc" id="L556">            ((float)(t2 - t0)/1000.f), </span>
<span class="fc" id="L557">            ((float)(t1 - t0)/1000.f),</span>
<span class="fc" id="L558">            ((float)(ts1_2 - t1)/1000.f),</span>
<span class="fc" id="L559">            ((float)(t2 - ts1_2)/1000.f)</span>
        );

<span class="fc" id="L562">        state = STATE.EDGES_EXTRACTED;</span>
<span class="fc" id="L563">    }</span>

    private void printEdges() {

<span class="nc" id="L567">        Image im = clrImg.copyToGreyscale2().copyToColorGreyscale();</span>

<span class="nc" id="L569">        int[] clr = new int[]{255, 0, 0};</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">        for (int i = 0; i &lt; labeledEdges.size(); ++i) {</span>
            //int[] clr = ImageIOHelper.getNextRGB(i);
<span class="nc" id="L573">            ImageIOHelper.addCurveToImage(labeledEdges.get(i), im, 0, clr[0],</span>
                clr[1], clr[2]);
        }
<span class="nc" id="L576">        MiscDebug.writeImage(im, &quot;_&quot; + ts + &quot;_mser_edges_&quot;);</span>
<span class="nc" id="L577">        im = clrImg.copyImage();</span>
<span class="nc" id="L578">        ImageIOHelper.addAlternatingColorCurvesToImage3(</span>
            labeledSets, im, 0);
<span class="nc" id="L580">        MiscDebug.writeImage(im, &quot;_&quot; + ts + &quot;_sets_&quot;);</span>
<span class="nc" id="L581">    }</span>

    private void mergeRegions() {
<span class="fc" id="L584">        mergeRegionsWithHOGsHCPTHGS();</span>
<span class="fc" id="L585">    }</span>

    private void mergeRegionsWithHOGsHCPTHGS() {
       
        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if (!state.equals(STATE.EDGES_EXTRACTED)) {</span>
<span class="nc" id="L591">            throw new IllegalStateException(&quot;error in algorithm.  expecting&quot;</span>
                + &quot; edges were extracted.&quot;);
        }
        
<span class="fc" id="L595">        long t0 = System.currentTimeMillis();</span>

<span class="pc bnc" id="L597" title="All 2 branches missed.">        assert(labeledSets != null);</span>
<span class="pc bnc" id="L598" title="All 2 branches missed.">        assert(labeledEdges != null);</span>
<span class="pc bnc" id="L599" title="All 2 branches missed.">        assert(labeledSets.size() == labeledEdges.size());</span>

<span class="fc" id="L601">        ImageProcessor imageProcessor = new ImageProcessor();</span>
        
        // for hogs and white-white merge, 0.65 is
<span class="fc" id="L604">        float intersectionLimit  = 0.8f;//0.67f;</span>
<span class="fc" id="L605">        float intersectionLimit1 = 0.88f;//0.9f;//0.88f;//0.9f;//0.7f;</span>
<span class="fc" id="L606">        float intersectionLimit2 = 0.925f;</span>
        
<span class="fc" id="L608">        int nCellsPerDim = 3;//1</span>
<span class="fc" id="L609">        int nPixPerCellDim = 3;//6</span>
<span class="fc" id="L610">        int nBins = 9;</span>
        
<span class="fc" id="L612">        HOGs hogs = new HOGs(gsImg, nCellsPerDim, nPixPerCellDim, nBins);</span>
<span class="fc" id="L613">        HCPT hcpt = new HCPT(ptImg, nCellsPerDim, nPixPerCellDim, nBins);</span>
<span class="fc" id="L614">        HGS hgs = new HGS(gsImg, nCellsPerDim, nPixPerCellDim, nBins);</span>
        
        // integrating the histograms over the regions to be compared for merging
<span class="fc" id="L617">        TIntObjectMap&lt;List&lt;PatchUtil&gt;&gt; clrs = new TIntObjectHashMap&lt;List&lt;PatchUtil&gt;&gt;();</span>

<span class="fc" id="L619">        int w = gsImg.getWidth();</span>
<span class="fc" id="L620">        int h = gsImg.getHeight();</span>

<span class="fc" id="L622">        Intersection2DPacking ip = new Intersection2DPacking();</span>
        
<span class="fc bfc" id="L624" title="All 2 branches covered.">        for (int label = 0; label &lt; labeledSets.size(); ++label) {</span>
            
<span class="fc" id="L626">            TIntSet set = new TIntHashSet(labeledSets.get(label));</span>
            
<span class="fc" id="L628">            TIntSet points = ip.naiveStripPacking(set, w, nPixPerCellDim);</span>
        
            /*if (true || debug) {
                PixelHelper ph = new PixelHelper();
                int[] xy = new int[2];
                Image tmp = gsImg.copyToColorGreyscale();
                assert(w == hogs.getImageWidth());
                assert(h == hogs.getImageHeight());
                TIntIterator iter = set.iterator();
                while (iter.hasNext()) {
                    int pixIdx = iter.next();
                    ph.toPixelCoords(pixIdx, w, xy);
                    ImageIOHelper.addPointToImage(xy[0], xy[1], tmp, 0, 
                        255, 0, 0);
                }
                iter = points.iterator();
                while (iter.hasNext()) {
                    int pixIdx = iter.next();
                    ph.toPixelCoords(pixIdx, w, xy);
                    ImageIOHelper.addPointToImage(xy[0], xy[1], tmp, 0, 
                        0, 255, 0);
                }
                MiscDebug.writeImage(tmp, &quot;_dbg_set_&quot; + label + &quot;_&quot; + ts);
            }*/
            
<span class="fc" id="L653">            List&lt;PatchUtil&gt; list = new ArrayList&lt;PatchUtil&gt;();</span>
<span class="fc" id="L654">            PatchUtil p = new PatchUtil(w, h, nBins);</span>
<span class="fc" id="L655">            p.add(points, hogs);</span>
<span class="fc" id="L656">            list.add(p);</span>
<span class="fc" id="L657">            p = new PatchUtil(w, h, nBins);</span>
<span class="fc" id="L658">            p.add(points, hcpt);</span>
<span class="fc" id="L659">            list.add(p);</span>
<span class="fc" id="L660">            p = new PatchUtil(w, h, nBins);</span>
<span class="fc" id="L661">            p.add(points, hgs);</span>
<span class="fc" id="L662">            list.add(p);</span>
            
<span class="fc" id="L664">            clrs.put(label, list);</span>
        }
      
<span class="fc" id="L667">        int[] sizes = new int[labeledSets.size()];</span>
<span class="fc" id="L668">        int[] indexes = new int[sizes.length];</span>
        
<span class="fc" id="L670">        TIntIntMap pointIndexMap = new TIntIntHashMap();</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">        for (int label = 0; label &lt; labeledSets.size(); ++label) {</span>
<span class="fc" id="L672">            TIntSet pixIdxs = labeledSets.get(label);</span>
<span class="fc" id="L673">            TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L675">                int pixIdx = iter.next();</span>
<span class="fc" id="L676">                pointIndexMap.put(pixIdx, label);</span>
<span class="fc" id="L677">            }</span>
<span class="fc" id="L678">            sizes[label] = pixIdxs.size();</span>
<span class="fc" id="L679">            indexes[label] = label;</span>
        }
        
<span class="fc" id="L682">        QuickSort.sortBy1stArg(sizes, indexes);</span>
        
        // -- making adjacency map using edgeList ---
        // a map with key=label, value = bitstring marking the neighboring labels.
<span class="fc" id="L686">        TIntObjectMap&lt;VeryLongBitString&gt; adjMap = imageProcessor</span>
<span class="fc" id="L687">            .createAdjacencyMap(pointIndexMap, labeledEdges, w, h);</span>
        
<span class="fc" id="L689">        MiscellaneousCurveHelper ch = new MiscellaneousCurveHelper();</span>

        //DEBUG: needed just for logging
<span class="fc" id="L692">        TIntObjectMap&lt;PairInt&gt; centroidsMap = new TIntObjectHashMap&lt;PairInt&gt;();</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">        for (int i = 0; i &lt; labeledSets.size(); ++i) {</span>
<span class="fc" id="L694">            TIntSet pixIdxs = labeledSets.get(i);</span>
<span class="fc" id="L695">            int[] xyCen = ch.calculateRoundedXYCentroids(pixIdxs, w);</span>
<span class="fc" id="L696">            centroidsMap.put(i, new PairInt(xyCen[0], xyCen[1]));</span>
        }
        
<span class="fc" id="L699">        int mCount = 0;</span>
<span class="fc" id="L700">        int eCount = 0;</span>
        
        do {    
<span class="fc" id="L703">            eCount = 0;</span>
            
<span class="fc bfc" id="L705" title="All 2 branches covered.">            for (int i = 0; i &lt; labeledSets.size(); ++i) {</span>

<span class="fc" id="L707">                int label = indexes[i];</span>

<span class="fc" id="L709">                VeryLongBitString adjLabels = adjMap.get(label);</span>
<span class="pc bpc" id="L710" title="1 of 4 branches missed.">                if (adjLabels == null || adjLabels.getNSetBits() == 0) {</span>
<span class="nc" id="L711">                    continue;</span>
                }

                // subtr edges from sets
<span class="fc" id="L715">                TIntSet set1 = new TIntHashSet(labeledSets.get(label));</span>
<span class="fc" id="L716">                set1.removeAll(labeledEdges.get(label));</span>

<span class="fc" id="L718">                PairInt xy1 = centroidsMap.get(label);</span>

                //hog, hcot, and hgs
<span class="fc" id="L721">                List&lt;PatchUtil&gt; pList1 = clrs.get(label);</span>

<span class="fc" id="L723">                Set&lt;PairInt&gt; points1 = pList1.get(0).getPixelSet();</span>
<span class="fc" id="L724">                CMODE cmodeLUV1 = CMODE.determinePolarThetaMode(ptImg, points1);</span>
<span class="fc" id="L725">                CMODE cmode1 = CMODE.determineColorMode(clrImg, points1);</span>

<span class="fc" id="L727">                int[] adjBits = adjLabels.getSetBits();</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                for (int label2 : adjBits) {</span>

<span class="fc bfc" id="L730" title="All 2 branches covered.">                    if (!clrs.containsKey(label2)) {</span>
<span class="fc" id="L731">                        continue;</span>
                    }

<span class="fc" id="L734">                    PairInt xy2 = centroidsMap.get(label2);</span>

                    // subtr edges from sets
<span class="fc" id="L737">                    TIntSet set2 = new TIntHashSet(labeledSets.get(label2));</span>
<span class="fc" id="L738">                    set2.removeAll(labeledEdges.get(label2));</span>

                    //hog, hcot, and hgs
<span class="fc" id="L741">                    List&lt;PatchUtil&gt; pList2 = clrs.get(label2);</span>

<span class="fc" id="L743">                    Set&lt;PairInt&gt; points2 = pList2.get(0).getPixelSet();</span>
<span class="fc" id="L744">                    CMODE cmodeLUV2 = CMODE.determinePolarThetaMode(ptImg, points2);</span>
<span class="fc" id="L745">                    CMODE cmode2 = CMODE.determineColorMode(clrImg, points2);</span>

                    //TODO: could change the intersection to 
                    //  use a detector window which scans in x and y at each
                    //  cell interval.  currently, the intersection is for every
                    //  interior pixel
                   
                    //DEBUG
<span class="fc" id="L753">                    float inter0 = (float)pList1.get(0).intersection(pList2.get(0));</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">                    if (inter0 &lt; intersectionLimit) {</span>
<span class="fc" id="L755">                        continue;</span>
                    }
<span class="fc" id="L757">                    float inter1 = (float)pList1.get(1).intersection(pList2.get(1));</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">                    if (inter1 &lt; intersectionLimit1) {</span>
<span class="fc" id="L759">                        continue;</span>
                    }
<span class="fc" id="L761">                    float inter2 = (float)pList1.get(2).intersection(pList2.get(2));</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                    if (inter2 &lt; intersectionLimit2) {</span>
<span class="fc" id="L763">                        continue;</span>
                    }

                    /*System.out.format(
                        &quot;(%d,%d) %s %s : (%d,%d) %s %s intersection=%.3f,%.3f,%.3f&quot;, 
                        xy1.getX(), xy1.getY(), 
                        cmodeLUV1.name(), cmode1.name(),
                        xy2.getX(), xy2.getY(), 
                        cmodeLUV2.name(), cmode2.name(),
                        inter0, inter1, inter2
                    );*/
                    
                    // -- merge the adjacent into the current label ---
<span class="fc" id="L776">                    TIntSet points_2 = pList2.get(0).getPixelIndexes();</span>
<span class="fc" id="L777">                    pList1.get(0).add(points_2, hogs);</span>
<span class="fc" id="L778">                    pList1.get(1).add(points_2, hcpt);</span>
<span class="fc" id="L779">                    pList1.get(2).add(points_2, hgs);</span>

<span class="fc" id="L781">                    clrs.remove(label2);</span>

                    // not updating the pointIndexMap because not using it here

<span class="fc" id="L785">                    adjLabels.clearBit(label2);</span>

<span class="fc" id="L787">                    VeryLongBitString adjLabels2 = adjMap.get(label2);</span>
   //editing: bug on next line   adjLabels2 is null 
<span class="fc" id="L789">                    adjLabels2.clearBit(label);</span>
                    
<span class="fc" id="L791">                    int[] setBits2 = adjLabels2.getSetBits();</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                    for (int label2Adj : setBits2) {</span>
<span class="fc" id="L793">                        VeryLongBitString adjLabel2Adj = adjMap.get(label2Adj);</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">                        if (adjLabel2Adj == null) {</span>
<span class="fc" id="L795">                            adjLabels2.clearBit(label2Adj);</span>
<span class="fc" id="L796">                            continue;</span>
                        }
<span class="fc" id="L798">                        adjLabel2Adj.clearBit(label2);</span>
<span class="fc" id="L799">                        adjLabel2Adj.setBit(label);</span>
                    }

<span class="fc" id="L802">                    VeryLongBitString union = adjLabels.or(adjLabels2);</span>
<span class="fc" id="L803">                    adjMap.put(label, union);</span>
<span class="fc" id="L804">                    adjLabels = union;       </span>
<span class="fc" id="L805">                    adjMap.remove(label2);</span>

<span class="fc" id="L807">                    labeledSets.get(label).addAll(labeledSets.get(label2));</span>
<span class="fc" id="L808">                    labeledEdges.get(label).addAll(labeledEdges.get(label2));</span>
<span class="fc" id="L809">                    labeledSets.get(label2).clear();</span>
<span class="fc" id="L810">                    labeledEdges.get(label2).clear();</span>
                    
<span class="pc bnc" id="L812" title="All 2 branches missed.">                    assert(labeledEdges.size() == labeledSets.size());</span>

                    // subtr edges from sets
<span class="fc" id="L815">                    set1 = new TIntHashSet(labeledSets.get(label));</span>
<span class="fc" id="L816">                    set1.removeAll(labeledEdges.get(label));</span>

                    // debug
                    if (false &amp;&amp; debug) {
                        Image tmp = clrImg.copyImage();
                        ImageIOHelper.addAlternatingColorPointSetsToImage2(
                            labeledSets, 0, 0, 0, tmp);
                        String t = Integer.toString(mCount);
                        while (t.length() &lt; 5) {
                            t = &quot;0&quot; + t;
                        }
                        t = t + &quot;_&quot; + xy1.toString() + &quot;_&quot; + xy2.toString();
                        MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_merging_&quot; + t);
                    }

<span class="fc" id="L831">                    int[] xyCen = ch.calculateRoundedXYCentroids(set1, w);</span>
<span class="fc" id="L832">                    xy1 = new PairInt(xyCen[0], xyCen[1]);</span>
<span class="fc" id="L833">                    centroidsMap.put(label, xy1);</span>

                    //System.out.format(&quot; ==&gt; (%d,%d)\n&quot;, xy1.getX(), xy1.getY());
<span class="fc" id="L836">                    mCount++;</span>
<span class="fc" id="L837">                    eCount++;</span>
                    
                }
            }
<span class="fc bfc" id="L841" title="All 2 branches covered.">        } while (eCount &gt; 0);</span>
        
        // remove empty labeledSets
<span class="fc bfc" id="L844" title="All 2 branches covered.">        for (int i = (labeledSets.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L845">            TIntSet set = labeledSets.get(i);</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">            if (set.isEmpty()) {</span>
<span class="fc" id="L847">                labeledSets.remove(i);</span>
            }
        }
        
<span class="fc" id="L851">        PerimeterFinder2 finder2 = new PerimeterFinder2();</span>
        
<span class="fc" id="L853">        labeledEdges.clear();</span>
        
        // redo the edgeList since the merged sets have embedded edges
<span class="fc bfc" id="L856" title="All 2 branches covered.">        for (int i = 0; i &lt; labeledSets.size(); ++i) {</span>
<span class="fc" id="L857">            TIntSet set = labeledSets.get(i);</span>
<span class="fc" id="L858">            TIntSet embedded = new TIntHashSet();</span>
<span class="fc" id="L859">            TIntSet outerBorder = new TIntHashSet();</span>
<span class="fc" id="L860">            finder2.extractBorder2(set, embedded, outerBorder, w);</span>
<span class="fc" id="L861">            labeledEdges.add(outerBorder);</span>
        }
<span class="pc bnc" id="L863" title="All 2 branches missed.">        assert(getEdgeList().size() == labeledSets.size());</span>
        
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L866">            Image imgCp = clrImg.copyImage();</span>
<span class="nc" id="L867">            ImageIOHelper.addAlternatingColorCurvesToImage3(labeledEdges,</span>
                imgCp, 0);
<span class="nc" id="L869">            MiscDebug.writeImage(imgCp, &quot;_&quot; + ts + &quot;_MERGED_&quot;);</span>
        }
        
<span class="fc" id="L872">        long t1 = System.currentTimeMillis();</span>

<span class="fc" id="L874">        System.out.format(&quot;%.3f sec for mergeRegions\n&quot;, </span>
<span class="fc" id="L875">            ((float)(t1 - t0)/1000.f));</span>
<span class="fc" id="L876">    }</span>
    
    /**
     * experimental method for a specific use case.  if this method is retained
     * and used, it could be made more efficient.
     * @return
     */
    public List&lt;Region&gt; _extractSensitiveGS0() {

<span class="fc" id="L885">        GreyscaleImage invImg = gsImg.copyImage();</span>
        // Invert the pixel values
<span class="fc bfc" id="L887" title="All 2 branches covered.">        for (int i = 0; i &lt; invImg.getNPixels(); ++i) {</span>
<span class="fc" id="L888">            int v = invImg.getValue(i);</span>
<span class="fc" id="L889">            v = ~v;</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">            if (v &lt; 0) {</span>
<span class="fc" id="L891">                v += 256;</span>
            }
<span class="fc" id="L893">            invImg.setValue(i, v);</span>
        }

<span class="fc" id="L896">        List&lt;List&lt;Region&gt;&gt; gsRegions = extractMSERRegions(invImg,</span>
            Threshold.LESS_SENSITIVE);

<span class="fc" id="L899">        List&lt;Region&gt; regions2 = new ArrayList&lt;Region&gt;();</span>

<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int type = 1; type &lt; 2; ++type) {</span>
<span class="fc" id="L902">            List&lt;Region&gt; list = gsRegions.get(type);</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">            for (int i = (list.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L904">                Region r = list.get(i);</span>
<span class="pc bpc" id="L905" title="2 of 4 branches missed.">                if ((type == 1) &amp;&amp; r.getVariation() &gt; 2.) {</span>
<span class="nc" id="L906">                    list.remove(i);</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">                } else if ((type == 0)</span>
                    //&amp;&amp; r.getVariation() == 0.0) {
<span class="nc bnc" id="L909" title="All 2 branches missed.">                    &amp;&amp; r.getVariation() &lt; 2.) {</span>
<span class="nc" id="L910">                    list.remove(i);</span>
                } else {
<span class="fc" id="L912">                    regions2.add(r);</span>
                }
            }
        }

<span class="fc" id="L917">        return regions2;</span>
    }
    
    /**
     * experimental method for a specific use case.  if this method is retained
     * and used, it could be made more efficient.
     * @return
     */
    public List&lt;Region&gt; _extractSensitivePT0() {

<span class="fc" id="L927">        int delta = 2;</span>
<span class="fc" id="L928">        double minArea = 0.001;//.0001</span>
<span class="fc" id="L929">        double maxArea = 0.99;//0.1;</span>
<span class="fc" id="L930">        double maxVariation = 0.9;//0.5;</span>
<span class="fc" id="L931">        double minDiversity = 0.75;//0.1;//0.5</span>
        
<span class="fc" id="L933">        int[] a = MSER.readIntoArray(ptImg);</span>
        
<span class="fc" id="L935">        int w = ptImg.getWidth();</span>
<span class="fc" id="L936">        int h = ptImg.getHeight();</span>

<span class="fc" id="L938">        List&lt;Region&gt; pt0Regions = new ArrayList&lt;Region&gt;();</span>
<span class="fc" id="L939">        MSER mser8 = new MSER(delta, minArea, maxArea, maxVariation, </span>
            minDiversity, true);
<span class="fc" id="L941">        mser8.operator(a, w, h, pt0Regions);</span>
        
<span class="fc" id="L943">        a = MSER.readIntoArray(ptImgShifted);</span>
<span class="fc" id="L944">        List&lt;Region&gt; pt0ShiftedRegions = new ArrayList&lt;Region&gt;();</span>
<span class="fc" id="L945">        mser8 = new MSER(delta, minArea, maxArea, maxVariation, </span>
            minDiversity, true);
<span class="fc" id="L947">        mser8.operator(a, w, h, pt0ShiftedRegions);</span>
        
        //_debugOrigRegions(ptShiftedRegions.get(0), &quot;_shifted_0&quot;);
        //_debugOrigRegions(ptShiftedRegions.get(1), &quot;_shifted_1&quot;);
            
<span class="fc" id="L952">        boolean hadWrapAroundArtifacts = false;</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">        for (int i = (pt0Regions.size() - 1); i &gt; -1; --i) {</span>
            
<span class="fc" id="L955">            Region r = pt0Regions.get(i);</span>

<span class="fc bfc" id="L957" title="All 2 branches covered.">            if (r.getVariation() == 0.0) {</span>
                
<span class="fc" id="L959">                pt0Regions.remove(i);</span>
                
            } else {
                // check for this Region being an artifact of wrap around
<span class="fc bfc" id="L963" title="All 2 branches covered.">                if (r.level_ &lt; 25) {</span>
<span class="fc" id="L964">                    pt0Regions.remove(i);</span>
<span class="fc" id="L965">                    hadWrapAroundArtifacts = true;</span>
                } else {
<span class="fc" id="L967">                    int avgLevel = calcAvg(ptImg, r.getAcc(w));</span>
                    
                    //System.out.format(&quot; %d add x,y=%d,%d level=%d  avgLevel=%d\n&quot;,
                    //    type, (int)(r.moments_[0]/r.area_),
                    //    (int)(r.moments_[1]/r.area_), r.level_,
                    //    avgLevel);
<span class="fc bfc" id="L973" title="All 2 branches covered.">                    if (avgLevel &gt; 240) {//230?</span>
<span class="fc" id="L974">                        pt0Regions.remove(i);</span>
                    }
                }
            }
        }
        
<span class="fc bfc" id="L980" title="All 2 branches covered.">        if (hadWrapAroundArtifacts) {</span>
            // excluded level &lt; 25.
            //   so shift by +60 and any region found w level approx 60
            //   is a real region possibly excluded near level=0
            // if find a region near level=60, edit the level
            //   and add it to list
<span class="fc bfc" id="L986" title="All 2 branches covered.">            for (int i = (pt0ShiftedRegions.size() - 1); i &gt; -1; --i) {</span>
<span class="fc" id="L987">                Region r = pt0ShiftedRegions.get(i);</span>

<span class="fc bfc" id="L989" title="All 2 branches covered.">                if (r.getVariation() == 0.0) {</span>
<span class="fc" id="L990">                    pt0ShiftedRegions.remove(i);</span>
                } else {
                    //TODO: consider checking whether this already exists in
                    //   the list
<span class="fc bfc" id="L994" title="All 2 branches covered.">                    if (Math.abs(r.level_ - thetaShift) &lt; 20) {</span>
<span class="fc" id="L995">                        r.level_ += thetaShift;</span>
<span class="fc" id="L996">                        pt0Regions.add(r);</span>
                        //System.out.format(&quot;  add shifted x,y=%d,%d level=%d\n&quot;,
                        // (int)(r.moments_[0]/r.area_),
                        // (int)(r.moments_[1]/r.area_), r.level_);
                    }
                    //TODO: consider adding other regions in list2
                    //   as long as level is &gt; 25 and &lt; 230
                }
            }
        }
        
<span class="fc" id="L1007">        return pt0Regions;</span>
    }

    public List&lt;TIntList&gt; getEmbeddedGS0Levels() {
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if (sensitiveGS0 == null) {</span>
<span class="nc" id="L1012">            sensitiveGS0 = _extractSensitiveGS0();</span>
        }

<span class="nc" id="L1015">        return getEmbeddedLevels(sensitiveGS0);</span>
    }

    private List&lt;TIntList&gt; getEmbeddedLevels(List&lt;Region&gt; rs) {

        //NOTE: if end up using this heavily, should consider a layered level
        //   set structure from the start

        // looking for level sets of concentric ellipses
<span class="nc" id="L1024">        int[] sizes = new int[rs.size()];</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        for (int i = 0; i &lt; rs.size(); ++i) {</span>
<span class="nc" id="L1026">            sizes[i] = rs.get(i).area_;</span>
        }
<span class="nc" id="L1028">        QuickSort.sortBy1stArg(sizes, rs);</span>

        //_debugOrigRegions(rs, &quot;_rs_&quot;);

<span class="nc" id="L1032">        List&lt;EllipseHelper&gt; ehs = new ArrayList&lt;EllipseHelper&gt;();</span>
<span class="nc" id="L1033">        List&lt;GroupPixelHSV&gt; hsvs = new ArrayList&lt;GroupPixelHSV&gt;();</span>

<span class="nc" id="L1035">        int[] xyCen = new int[2];</span>
<span class="nc" id="L1036">        int w = clrImg.getWidth();</span>
<span class="nc" id="L1037">        int h = clrImg.getHeight();</span>

<span class="nc" id="L1039">        QuadTree&lt;Integer, Integer&gt; centroidQT = new QuadTree&lt;Integer, Integer&gt;();</span>

        // store the region centroids in quadtree
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        for (int i = 0; i &lt; rs.size(); ++i) {</span>
<span class="nc" id="L1043">            Region r = rs.get(i);</span>
<span class="nc" id="L1044">            r.calculateXYCentroid(xyCen, w, h);</span>
<span class="nc" id="L1045">            double[] coeffs = r.calcParamTransCoeff();</span>
<span class="nc" id="L1046">            EllipseHelper eh = new EllipseHelper(xyCen[0], xyCen[1], coeffs);</span>
<span class="nc" id="L1047">            ehs.add(eh);</span>

<span class="nc" id="L1049">            GroupPixelHSV gHSV = new GroupPixelHSV();</span>
<span class="nc" id="L1050">            gHSV.calculateColors(r.getAcc(), clrImg);</span>
<span class="nc" id="L1051">            hsvs.add(gHSV);</span>

<span class="nc" id="L1053">            centroidQT.insert(xyCen[0], xyCen[1], Integer.valueOf(i));</span>
        }

<span class="nc" id="L1056">        TIntList skip = new TIntArrayList();</span>

        /*
        concentric regions due to illumintion gradient tend to have
        similar eccentricities, orientation, and direction away from
        the largest region center.
        They also tend to have 3 or 4 of the ellipse semi major and
        minor endpoints within the largest region's bounds,
        that is the direction of the illumination gradient is in one
        direction.
        */

<span class="nc" id="L1068">        List&lt;TIntList&gt; concentric = new ArrayList&lt;TIntList&gt;();</span>

        // visit from largest region to smallest
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        for (int i = (rs.size() - 1); i &gt; -1; --i) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if (skip.contains(i)) { continue; }</span>
<span class="nc" id="L1073">            EllipseHelper eh = ehs.get(i);</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">            if (hsvs.get(i).getStdDevV() &gt; 0.075) {</span>
<span class="nc" id="L1076">                continue;</span>
            }

<span class="nc" id="L1079">            int[] minMaxXY = eh.getMinMaxXY();</span>

<span class="nc" id="L1081">            Interval&lt;Integer&gt; intX = new Interval&lt;Integer&gt;(minMaxXY[0], minMaxXY[1]);</span>
<span class="nc" id="L1082">            Interval&lt;Integer&gt; intY = new Interval&lt;Integer&gt;(minMaxXY[2], minMaxXY[3]);</span>
<span class="nc" id="L1083">            Interval2D&lt;Integer&gt; rect = new Interval2D&lt;Integer&gt;(intX, intY);</span>

<span class="nc" id="L1085">            List&lt;Integer&gt; indexes = centroidQT.query2D(rect);</span>
<span class="nc bnc" id="L1086" title="All 4 branches missed.">            if (indexes == null || indexes.size() &lt; 2) {</span>
<span class="nc" id="L1087">                continue;</span>
            }

<span class="nc" id="L1090">            float orientation = (float)(</span>
<span class="nc" id="L1091">                eh.getOrientation() * 180./Math.PI);</span>
<span class="nc" id="L1092">            double ecc = eh.getEccentricity();</span>

            /*
            System.out.format(
                &quot;OUTER (%d,%d) or=%.3f ecc=%.3f  stdvV=%.3f n=%d\n&quot;,
                eh.getXYCenter()[0], eh.getXYCenter()[1],
                (float)eh.getOrientation(),
                (float)eh.getEccentricity(), hsvs.get(i).getStdDevV(),
                rs.get(i).accX.size()
            );*/

<span class="nc" id="L1103">            TIntList idx2s = new TIntArrayList();</span>
<span class="nc" id="L1104">            TDoubleList dirs = new TDoubleArrayList();</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            for (int j = 0; j &lt; indexes.size(); ++j) {</span>
<span class="nc" id="L1106">                int idx2 = indexes.get(j).intValue();</span>
<span class="nc bnc" id="L1107" title="All 4 branches missed.">                if (idx2 == i || skip.contains(idx2)) { continue; }</span>

<span class="nc bnc" id="L1109" title="All 2 branches missed.">                if (hsvs.get(idx2).getStdDevV() &gt; 0.075) {</span>
<span class="nc" id="L1110">                    continue;</span>
                }

<span class="nc" id="L1113">                EllipseHelper eh2 = ehs.get(idx2);</span>
<span class="nc" id="L1114">                float orientation2 = (float)(</span>
<span class="nc" id="L1115">                    eh2.getOrientation() * 180./Math.PI);</span>
//TODO: revisit 
<span class="nc" id="L1117">                float diffOr = AngleUtil.getAngleDifference(orientation,</span>
                    orientation2);

<span class="nc bnc" id="L1120" title="All 2 branches missed.">                if (Math.abs(diffOr) &gt; 5.75) {</span>
<span class="nc" id="L1121">                    continue;</span>
                }
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                if (Math.abs(ecc - eh2.getEccentricity()) &gt; 0.07) {</span>
<span class="nc" id="L1124">                    continue;</span>
                }

<span class="nc" id="L1127">                PairInt[] ep = eh2.getSemiAxesEndoints();</span>
<span class="nc" id="L1128">                int nTrue = 0;</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">                for (int k = 0; k &lt; 4; ++k) {</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                    if (eh.isWithin(ep[k].getX(), ep[k].getY())) {</span>
<span class="nc" id="L1131">                        nTrue++;</span>
                    }
                }

<span class="nc" id="L1135">                boolean t0 = eh.isWithin(ep[0].getX(), ep[0].getY());</span>
<span class="nc" id="L1136">                boolean t1 = eh.isWithin(ep[1].getX(), ep[1].getY());</span>
<span class="nc" id="L1137">                boolean t2 = eh.isWithin(ep[2].getX(), ep[2].getY());</span>
<span class="nc" id="L1138">                boolean t3 = eh.isWithin(ep[3].getX(), ep[3].getY());</span>


<span class="nc" id="L1141">                double atan2 = Math.atan2(</span>
<span class="nc" id="L1142">                    (double)(eh2.getXYCenter()[1] -  eh.getXYCenter()[1]),</span>
<span class="nc" id="L1143">                    (double)(eh2.getXYCenter()[0] -  eh.getXYCenter()[0]))</span>
                    * 180./Math.PI;
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                if (atan2 &lt; 0) {</span>
<span class="nc" id="L1146">                    atan2 += 360;</span>
                }

                //System.out.println(&quot;     &quot; + Arrays.toString(ep));

                /*
                System.out.format(
                    &quot;     (%d,%d) or=%.3f ecc=%.3f atan2=%.3f &quot;
                        + &quot;isWithin=%b,%b,%b,%b  stdvV=%.3f n=%d\n&quot;,
                    eh2.getXYCenter()[0], eh2.getXYCenter()[1],
                    (float)eh2.getOrientation(),
                    (float)eh2.getEccentricity(), (float)atan2,
                    t0, t1, t2, t3, hsvs.get(idx2).getStdDevV(),
                    rs.get(idx2).accX.size()
                );*/

<span class="nc bnc" id="L1162" title="All 2 branches missed.">                if (nTrue &lt; 2) {</span>
<span class="nc" id="L1163">                    continue;</span>
                }

   //cannot include if there is alot of variation in the level set

                // can't tell which directions are consistent w/ a gradient
                // yet, so collect all
<span class="nc" id="L1170">                idx2s.add(idx2);</span>
<span class="nc" id="L1171">                dirs.add(atan2);</span>
            }

<span class="nc bnc" id="L1174" title="All 2 branches missed.">            if (dirs.size() &lt; 2) {</span>
<span class="nc" id="L1175">                continue;</span>
            }

            // gradient will be apparent as 2 or more regions having
            // similar atan2 (within approx 10 degrees)
            // key = bin number where bin size is 10 degrees, value = number
            //    of items in dirs which have that direction key bin
<span class="nc" id="L1182">            float binSz = 10.f;</span>
<span class="nc" id="L1183">            TIntIntMap dirFreq = new TIntIntHashMap();</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">            for (int k = 0; k &lt; dirs.size(); ++k) {</span>
<span class="nc" id="L1185">                double direction = dirs.get(k);</span>
<span class="nc" id="L1186">                int bin = (int)(direction/binSz);</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">                if (dirFreq.containsKey(bin)) {</span>
<span class="nc" id="L1188">                    int c = dirFreq.get(bin);</span>
<span class="nc" id="L1189">                    dirFreq.put(bin, c + 1);</span>
<span class="nc" id="L1190">                } else {</span>
<span class="nc" id="L1191">                    dirFreq.put(bin, 1);</span>
                }
            }
<span class="nc" id="L1194">            int maxFreq = Integer.MIN_VALUE;</span>
<span class="nc" id="L1195">            int maxFreqBin = -1;</span>
<span class="nc" id="L1196">            TIntIntIterator iter = dirFreq.iterator();</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">            for (int k = 0; k &lt; dirFreq.size(); ++k) {</span>
<span class="nc" id="L1198">                iter.advance();</span>
<span class="nc" id="L1199">                int c = iter.value();</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">                if (c &gt; maxFreq) {</span>
<span class="nc" id="L1201">                    maxFreq = c;</span>
<span class="nc" id="L1202">                    maxFreqBin = iter.key();</span>
                }
            }
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (maxFreq &lt; 2) {</span>
<span class="nc" id="L1206">                continue;</span>
            }
            // combine those ideally within 10 degrees of each other,
            //  so roughly 7.07 from bin center
<span class="nc" id="L1210">            float dirCenter = ((float)maxFreqBin)*binSz + (binSz/2.f);</span>
<span class="nc" id="L1211">            double dist = Math.sqrt(2) * binSz/2.;</span>

<span class="nc" id="L1213">            System.out.println(&quot;   adding&quot;);</span>

            //List&lt;TIntList&gt; concentric = new ArrayList&lt;TIntList&gt;();
<span class="nc" id="L1216">            TIntList concList = new TIntArrayList();</span>
<span class="nc" id="L1217">            concentric.add(concList);</span>
<span class="nc" id="L1218">            concList.add(i);</span>
<span class="nc" id="L1219">            skip.add(i);</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">            for (int k = 0; k &lt; dirs.size(); ++k) {</span>
<span class="nc" id="L1221">                double direction = dirs.get(k);</span>
<span class="nc" id="L1222">                double diff = Math.abs(direction - dirCenter);</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">                if (diff &gt; dist) {</span>
<span class="nc" id="L1224">                    continue;</span>
                }
<span class="nc" id="L1226">                int idx2 = idx2s.get(k);</span>
<span class="nc" id="L1227">                concList.add(idx2);</span>
<span class="nc" id="L1228">                skip.add(idx2);</span>
            }

            /*{//DEBUG
                List&lt;Region&gt; tmp = new ArrayList&lt;Region&gt;();
                for (int k = 0; k &lt; concList.size(); ++k) {
                    tmp.add(rs.get(concList.get(k)));
                }
                _debugOrigRegions(tmp, &quot;_rs_&quot; + concentric.size());
            }*/
        }

<span class="nc" id="L1240">        return concentric;</span>
    }

    public void _debugOrigRegions(int idx, String lbl) {
<span class="nc" id="L1244">        List&lt;Region&gt; list = origGsPtRegions.get(idx);</span>
<span class="nc" id="L1245">        lbl = lbl + &quot;_&quot; + idx + &quot;_&quot;;</span>
<span class="nc" id="L1246">        _debugOrigRegions(list, lbl);</span>
<span class="nc" id="L1247">    }</span>

    public void _debugOrigRegions(List&lt;Region&gt; list, String lbl) {
<span class="nc" id="L1250">        int[] xyCen = new int[2];</span>
        Image imCp;
<span class="nc" id="L1252">        System.out.println(&quot;printing &quot; + list.size());</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        for (int j = 0; j &lt; list.size(); ++j) {</span>
<span class="nc" id="L1254">            imCp = ptImg.copyToColorGreyscale();</span>
<span class="nc" id="L1255">            Region r = list.get(j);</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            for (int i = 0; i &lt; r.accX.size(); ++i) {</span>
<span class="nc" id="L1257">                int x = r.accX.get(i);</span>
<span class="nc" id="L1258">                int y = r.accY.get(i);</span>
<span class="nc" id="L1259">                ImageIOHelper.addPointToImage(x, y, imCp, 0, 0, 255, 0);</span>
            }
<span class="nc" id="L1261">            r.drawEllipse(imCp, 0, 255, 0, 0);</span>
<span class="nc" id="L1262">            r.calculateXYCentroid(xyCen, imCp.getWidth(), imCp.getHeight());</span>
<span class="nc" id="L1263">            ImageIOHelper.addPointToImage(xyCen[0], xyCen[1], imCp,</span>
                1, 255, 0, 0);
            //System.out.println(type + &quot; xy=&quot; + xyCen[0] + &quot;,&quot; + xyCen[1]
            //    + &quot; variation=&quot; + r.getVariation());
<span class="nc" id="L1267">            MiscDebug.writeImage(imCp, &quot;_&quot; + ts + &quot;_orig_regions_&quot; + lbl</span>
                + &quot;_&quot; + &quot;_&quot; + j + &quot;_&quot;);
        }
<span class="nc" id="L1270">    }</span>

    public List&lt;TIntSet&gt; getEdges() {

        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">        if (!state.equals(STATE.EDGES_EXTRACTED)) {</span>
<span class="nc" id="L1276">            throw new IllegalStateException(&quot;must use one of the extraction&quot;</span>
                + &quot; methods first&quot;);
        }

<span class="fc" id="L1280">        return labeledEdges;</span>
    }

    /**
     * get labeled sets of points separated by the edges.
     * Note that the method returns null unless extractAndMergeEdges was
     * already used.
     * @return
     */
    public List&lt;TIntSet&gt; getLabeledSets() {

        //INITIALIZED, REGIONS_EXTRACTED, MERGED, EDGES_EXTRACTED
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">        if (!state.equals(STATE.EDGES_EXTRACTED)) {</span>
<span class="nc" id="L1293">            throw new IllegalStateException(&quot;must use one of the extraction&quot;</span>
                + &quot; methods first&quot;);
        }

<span class="fc" id="L1297">        return labeledSets;</span>
    }

    /**
     * @return the clrImg
     */
    public ImageExt getClrImg() {
<span class="fc" id="L1304">        return clrImg;</span>
    }

    /**
     * @return the gsImg
     */
    public GreyscaleImage getGsImg() {
<span class="fc" id="L1311">        return gsImg;</span>
    }

    /**
     * @return the ptImg
     */
    public GreyscaleImage getPtImg() {
<span class="fc" id="L1318">        return ptImg;</span>
    }

    /**
     * @return the regions
     */
    public List&lt;Region&gt; getRegions() {
<span class="nc" id="L1325">        return regions;</span>
    }

    /**
     * @return the origGsPtRegions
     */
    public List&lt;List&lt;Region&gt;&gt; getOrigGsPtRegions() {
<span class="fc" id="L1332">        return origGsPtRegions;</span>
    }

    /**
     * @return the useLowerContrastLimits
     */
    public boolean isUsingLowerContrastLimits() {
<span class="nc" id="L1339">        return useLowerContrastLimits;</span>
    }

    private GreyscaleImage createSobelScores() {

<span class="fc" id="L1344">        int w = gsImg.getWidth();</span>
<span class="fc" id="L1345">        int h = gsImg.getHeight();</span>

        /*
        float[] sobelScores = imageProcessor.createSobelColorScores(
            gsImg, ptImg, 20);

        GreyscaleImage scaled = MiscMath.rescaleAndCreateImage(sobelScores,
            w, h);
        */

<span class="fc" id="L1355">        CannyEdgeColorAdaptive canny2 = new CannyEdgeColorAdaptive();</span>
<span class="fc" id="L1356">        canny2.overrideToNotUseLineThinner();</span>
<span class="fc" id="L1357">        canny2.applyFilter(clrImg);</span>
<span class="fc" id="L1358">        this.edgeProducts = canny2.getFilterProducts();</span>
<span class="fc" id="L1359">        GreyscaleImage scaled = edgeProducts.getGradientXY();</span>
<span class="fc" id="L1360">        scaled.multiply(255/scaled.max());</span>
        //MiscDebug.writeImage(scaled, debugLabel
        //    + &quot;_lc_mser_edges_&quot;);

        /*
        GreyscaleImage sobelLCH =
            imageProcessor.createSobelLCCombined(img);
        */

<span class="fc" id="L1369">        this.cannyEdges = scaled;</span>
                
        // smearing values over a 3 pixel window to avoid the potential
        //   1 pixel displacement of an edge from the level set boundaries
<span class="fc" id="L1373">        SummedAreaTable sumTable = new SummedAreaTable();</span>

<span class="fc" id="L1375">        GreyscaleImage imgM = sumTable.createAbsoluteSummedAreaTable(scaled);</span>
<span class="fc" id="L1376">        imgM = sumTable.applyMeanOfWindowFromSummedAreaTable(imgM, 3);</span>

<span class="fc" id="L1378">        return imgM;</span>
    }

    private TIntSet combineBoundaries() {

<span class="pc bpc" id="L1383" title="1 of 2 branches missed.">        if (sobelScores == null) {</span>
<span class="fc" id="L1384">            sobelScores = createSobelScores();</span>
            //MiscDebug.writeImage(sobelScores,
            //    &quot;_&quot; + ts + &quot;_canny_blurred_&quot;);
            //MiscDebug.writeImage(cannyEdges, &quot;_&quot; + ts + &quot;_canny_&quot;);
        }

        /*
        using the level set region boundaries as contours to complete
        the edges from the canny edges of L and C from LCH.

        -- first applying a filter that is the fraction of region
           boundary points which have a canny edge pixel to filter the
           mser regions list.
        -- then finding the contiguous sets of all matched region points
        and the sets of all unmatched points from those same regions
        (where matched means that the region pixel coordinates
        have canny edge pixel values &gt; 0).
        -- then finding the paths in the unmatched points that complete
        gaps between the matched segments.
        */

        // below this removes:
<span class="fc" id="L1406">        float mLimit = 0.4001f;</span>

        // maximum number of contiguous pixels that are not already canny
        //   edge points
<span class="fc" id="L1410">        int maxGapSize = 16;</span>

<span class="fc" id="L1412">        PerimeterFinder2 finder = new PerimeterFinder2();</span>

<span class="fc" id="L1414">        TIntSet allEdgePoints = new TIntHashSet();</span>
<span class="fc" id="L1415">        List&lt;TIntSet&gt; unmatchedRMap = new ArrayList&lt;TIntSet&gt;();</span>
        
<span class="fc" id="L1417">        TIntSet rmvdImgBorders = new TIntHashSet();</span>
        
<span class="fc" id="L1419">        double tt0 = System.currentTimeMillis();</span>
             
        Region r;
        TIntSet points;
<span class="fc" id="L1423">        TIntSet embedded = new TIntHashSet();</span>
<span class="fc" id="L1424">        TIntSet outerBorder = new TIntHashSet();</span>
        TIntSet matched;
        TIntSet unmatched;

<span class="fc bfc" id="L1428" title="All 2 branches covered.">        for (int rListIdx = 0; rListIdx &lt; regions.size(); ++rListIdx) {</span>
<span class="fc" id="L1429">            r = regions.get(rListIdx);</span>
<span class="fc" id="L1430">            points = r.getAcc(clrImg.getWidth());</span>
            
<span class="fc" id="L1432">            embedded.clear();</span>
<span class="fc" id="L1433">            outerBorder.clear();</span>
            //The runtime complexity is roughly O(N_points).
<span class="fc" id="L1435">            finder.extractBorder2(points, embedded, outerBorder, clrImg.getWidth());</span>

<span class="fc" id="L1437">            removeImageBorder(outerBorder, rmvdImgBorders,</span>
<span class="fc" id="L1438">                clrImg.getWidth(), clrImg.getHeight());</span>

<span class="fc" id="L1440">            matched = new TIntHashSet();</span>
<span class="fc" id="L1441">            unmatched = new TIntHashSet();</span>

<span class="fc" id="L1443">            double[] scoreAndMatch = calcAvgScore(outerBorder, sobelScores,</span>
<span class="fc" id="L1444">                matched, unmatched, clrImg.getWidth());</span>

<span class="fc" id="L1446">            double matchFraction = scoreAndMatch[1]/(double)outerBorder.size();</span>

            /*
            System.out.format(&quot; rIdx=%d score=%.3f &quot;
                + &quot; border2.n=%d nmf=%.3f  m.n=%d um.n=%d\n&quot;,
                rListIdx, (float)scoreAndMatch[0],
                border2.size(),
                (float)matchFraction, matched.size(), unmatched.size());
            */

<span class="fc bfc" id="L1456" title="All 4 branches covered.">            boolean doNotAdd = (matchFraction &lt; mLimit) ||</span>
                ((int)scoreAndMatch[1] == 0);

//Image tmpImg = sobelScores.copyToColorGreyscale();
//ImageIOHelper.addCurveToImage(border2, tmpImg, 0, 255, 0, 0);
//MiscDebug.writeImage(tmpImg, &quot;_r_&quot; + rListIdx);

<span class="fc bfc" id="L1463" title="All 2 branches covered.">            if (doNotAdd) {</span>
                
//Image tmpImg = sobelScores.copyToColorGreyscale();
//ImageIOHelper.addCurveToImage(border2, tmpImg, 0, 255, 0, 0);
//MiscDebug.writeImage(tmpImg, &quot;_r_&quot; + rListIdx);
//System.out.println(&quot;rListIdx=&quot; + rListIdx + &quot; matchFraction=&quot; + matchFraction
//+ &quot; (int)scoreAndMatch[1]=&quot; + (int)scoreAndMatch[1]);

<span class="fc" id="L1471">                continue;</span>
            }

//Image tmpImg = sobelScores.copyToColorGreyscale();
//ImageIOHelper.addCurveToImage(border2, tmpImg, 0, 255, 0, 0);
//MiscDebug.writeImage(tmpImg, &quot;_r_&quot; + rListIdx);

            /*
            to find the points in border2 which are not in the canny edges, but
            are the missing contour points of an object:

            -- separating the border2 points which are matched to canny edge
                 points from those which do not have a canny edge pixel
                 (done in steps above)
            -- for the matched points, putting them all in allPoints and
                putting unmatched into unmatchedSet.
            -- when this block is complete,
               -- will find the contiguous matched segments.
               -- will find the unmatchedSet points which are adjacent
                  to one of the matched.
                  these are the endpoints in the unmatched which may be path
                  endpoints between matched segments or they might not be.
               -- will search through unmatched points from the starting
                  endpoints to the other endpoints
                  and keep paths that are shorter than
                  maxGapSize
            */

<span class="fc" id="L1499">            allEdgePoints.addAll(matched);</span>
<span class="fc" id="L1500">            unmatchedRMap.add(unmatched);</span>
            
//Image tmpImg = sobelScores.copyToColorGreyscale();
//ImageIOHelper.addCurveToImage(unmatched, tmpImg, 0, 255, 0, 0);
//MiscDebug.writeImage(tmpImg, &quot;_u_&quot; + rListIdx);

        }
<span class="fc" id="L1507">        r = null;</span>
<span class="fc" id="L1508">        points = null;</span>
<span class="fc" id="L1509">        embedded = null;</span>
<span class="fc" id="L1510">        outerBorder = null;</span>
<span class="fc" id="L1511">        matched = null;</span>
<span class="fc" id="L1512">        unmatched = null;</span>
        
<span class="fc" id="L1514">        double tt1 = System.currentTimeMillis();</span>

<span class="fc" id="L1516">        addUnmatchedToEdgePoints(unmatchedRMap, allEdgePoints, rmvdImgBorders, </span>
            maxGapSize);
      
<span class="fc" id="L1519">        long tt2 = System.currentTimeMillis();</span>
        
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1522">            System.out.println(((tt1 - tt0)/1000.) + </span>
                &quot; sec for region filter &quot; +
                ((tt2 - tt1)/1000.) + &quot; sec for add unmatched &quot;
                );
        }
                
<span class="fc" id="L1528">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1529">        int[] dys = Misc.dy8;</span>
        
<span class="fc" id="L1531">        int w = clrImg.getWidth();</span>
<span class="fc" id="L1532">        int h = clrImg.getHeight();</span>
                
        //add back any points in rmvdImgBorders adjacent to allEdgePoints
<span class="fc" id="L1535">        TIntSet addRmvd = new TIntHashSet();</span>
<span class="fc" id="L1536">        TIntIterator iter = rmvdImgBorders.iterator();</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1538">            int pixIdx = iter.next();</span>
<span class="fc" id="L1539">            int y = pixIdx / w;</span>
<span class="fc" id="L1540">            int x = pixIdx - (y * w);</span>

            //System.out.println(&quot; imgB xy=&quot; + x + &quot;, &quot; + y);

<span class="fc bfc" id="L1544" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L1545">                int x2 = x + dxs[k];</span>
<span class="fc" id="L1546">                int y2 = y + dys[k];</span>
<span class="fc bfc" id="L1547" title="All 8 branches covered.">                if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt;= w) || (y2 &gt;= w)) {</span>
<span class="fc" id="L1548">                    continue;</span>
                }
<span class="fc" id="L1550">                int pixIdx2 = (y2 * w) + x2;</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">                if (allEdgePoints.contains(pixIdx2)) {</span>
<span class="fc" id="L1552">                    addRmvd.add(pixIdx);</span>
<span class="fc" id="L1553">                    break;</span>
                }
            }
<span class="fc" id="L1556">        }</span>
<span class="fc" id="L1557">        allEdgePoints.addAll(addRmvd);</span>

<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1560">            Image tmp = clrImg.copyToGreyscale2().copyToColorGreyscale();</span>
<span class="nc" id="L1561">            ImageIOHelper.addCurveToImage(allEdgePoints, tmp, 0, 255, 0, 0);</span>
<span class="nc" id="L1562">            MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_boundaries0_&quot;);</span>
        }

<span class="fc" id="L1565">        return allEdgePoints;</span>
    }

    /**
     * using the given edges as definitions of separation between
     * contiguous pixels in the image (== labels),
     * perform kmeans on the edge pixels to add them back to
     * the labels which are adjacent and closest in color.
     *
     * NOTE: has the side effect of populating this.edgeList and 
     * this.labeledSets
     */
    private void thinTheBoundaries(int minGroupSize) {

<span class="pc bpc" id="L1579" title="2 of 4 branches missed.">        if (this.labeledSets == null || this.labeledEdges == null) {</span>
<span class="nc" id="L1580">            throw new IllegalStateException(&quot;instance vars are null: &quot;</span>
                + &quot; labeledSets, edgeLists&quot;);
        }
        
<span class="fc" id="L1584">        PerimeterFinder2 finder2 = new PerimeterFinder2();</span>

<span class="fc" id="L1586">        int w = clrImg.getWidth();</span>
<span class="fc" id="L1587">        int h = clrImg.getHeight();</span>

<span class="fc" id="L1589">        float[][] luvws = new float[labeledSets.size()][];</span>

<span class="fc" id="L1591">        int[] labels = new int[clrImg.getNPixels()];</span>
<span class="fc" id="L1592">        Arrays.fill(labels, -1);</span>

<span class="fc bfc" id="L1594" title="All 2 branches covered.">        for (int label = 0; label &lt; labeledSets.size(); ++label) {</span>

<span class="fc" id="L1596">            TIntSet set = labeledSets.get(label);</span>

<span class="fc" id="L1598">            TIntIterator iter2 = set.iterator();</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L1600">                int pixIdx = iter2.next();</span>
<span class="fc" id="L1601">                labels[pixIdx] = label;</span>
<span class="fc" id="L1602">            }</span>

<span class="fc" id="L1604">            GroupPixelLUVWideRangeLightness luv = new GroupPixelLUVWideRangeLightness();</span>
<span class="fc" id="L1605">            luv.calculateColors(set, clrImg);</span>
<span class="fc" id="L1606">            luvws[label] = luv.getAvgLUV();</span>
        }

<span class="fc" id="L1609">        TIntSet unassignedSet = new TIntHashSet();</span>
<span class="fc bfc" id="L1610" title="All 2 branches covered.">        for (int i = 0; i &lt; clrImg.getNPixels(); ++i) {</span>
<span class="fc bfc" id="L1611" title="All 2 branches covered.">            if (labels[i] == -1) {</span>
<span class="fc" id="L1612">                unassignedSet.add(i);</span>
            }
        }

<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1617">            Image tmp = clrImg.copyImage();</span>
<span class="nc" id="L1618">            ImageIOHelper.addAlternatingColorPointSetsToImage2(</span>
                labeledSets, 0, 0, 0, tmp);
<span class="nc" id="L1620">            MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_before_assigned_&quot;);</span>
        }

<span class="fc" id="L1623">        _assignTheUnassigned(labeledSets, labels, luvws, unassignedSet);</span>

<span class="pc bpc" id="L1625" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1626">            Image tmp = clrImg.copyImage();</span>
<span class="nc" id="L1627">            ImageIOHelper.addAlternatingColorPointSetsToImage2(</span>
                labeledSets, 0, 0, 0, tmp);
<span class="nc" id="L1629">            MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_reassigned0_&quot;);</span>
        }

        // make successive passes through to re-assign the smallest sets,
        //    pixel by pixel.  the gradual merging of smaller sets helps
        //    preserve some of the low SNR object boundaries
        //    such as the gingerbread man in the test image android_statues_01
        //    downsampled to size near 256 pixels per dimension.
        //int[] mszs = new int[]{minGroupSize, 4, 6, 12, 18, 24};
<span class="fc" id="L1638">        int[] mszs = new int[]{minGroupSize, 4, 6};</span>

        float[][] hsvs;
        
<span class="fc bfc" id="L1642" title="All 2 branches covered.">        for (int msz : mszs) {</span>

<span class="fc" id="L1644">            List&lt;TIntSet&gt; contigousSets2 = new ArrayList&lt;TIntSet&gt;();</span>
<span class="fc" id="L1645">            List&lt;TIntSet&gt; edgeLists2 = new ArrayList&lt;TIntSet&gt;();</span>
<span class="fc" id="L1646">            TIntSet reassign = new TIntHashSet();</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">            for (int i = 0; i &lt; labeledSets.size(); ++i) {</span>
<span class="fc" id="L1648">                TIntSet set = labeledSets.get(i);</span>
<span class="fc" id="L1649">                TIntSet embedded = new TIntHashSet();</span>
<span class="fc" id="L1650">                TIntSet outerBorder = new TIntHashSet();</span>
<span class="fc" id="L1651">                finder2.extractBorder2(set, embedded, outerBorder, w);</span>
<span class="fc bfc" id="L1652" title="All 2 branches covered.">                if (set.size() - outerBorder.size() &gt;= msz) {</span>
<span class="fc" id="L1653">                    contigousSets2.add(set);</span>
<span class="fc" id="L1654">                    edgeLists2.add(outerBorder);</span>
                } else {
<span class="fc" id="L1656">                    reassign.addAll(set);</span>
                }
            }
<span class="fc bfc" id="L1659" title="All 2 branches covered.">            if (reassign.isEmpty()) {</span>
<span class="fc" id="L1660">                labeledSets = contigousSets2;</span>
<span class="fc" id="L1661">                labeledEdges = edgeLists2;</span>
            } else {
<span class="fc" id="L1663">                labels = new int[clrImg.getNPixels()];</span>
<span class="fc" id="L1664">                Arrays.fill(labels, -1);</span>
<span class="fc" id="L1665">                hsvs = new float[contigousSets2.size()][];</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">                for (int label = 0; label &lt; contigousSets2.size(); ++label) {</span>
<span class="fc" id="L1667">                    TIntSet set = contigousSets2.get(label);</span>
<span class="fc" id="L1668">                    TIntIterator iter2 = set.iterator();</span>
<span class="fc bfc" id="L1669" title="All 2 branches covered.">                    while (iter2.hasNext()) {</span>
<span class="fc" id="L1670">                        int pixIdx = iter2.next();</span>
<span class="fc" id="L1671">                        labels[pixIdx] = label;</span>
<span class="fc" id="L1672">                    }</span>
<span class="fc" id="L1673">                    GroupPixelHSV2 hsv = new GroupPixelHSV2();</span>
<span class="fc" id="L1674">                    hsv.calculateColors(set, clrImg);</span>
<span class="fc" id="L1675">                    hsvs[label] = new float[]{hsv.getAvgH(), hsv.getAvgS(),</span>
<span class="fc" id="L1676">                        hsv.getAvgV()};</span>
                }

<span class="fc" id="L1679">                assignTheUnassigned(contigousSets2, labels, hsvs, reassign);</span>

<span class="fc" id="L1681">                labeledSets.clear();</span>
<span class="fc" id="L1682">                labeledEdges.clear();</span>

<span class="fc bfc" id="L1684" title="All 2 branches covered.">                for (int i = 0; i &lt; contigousSets2.size(); ++i) {</span>
<span class="fc" id="L1685">                    TIntSet set = contigousSets2.get(i);</span>
<span class="fc" id="L1686">                    TIntSet embedded = new TIntHashSet();</span>
<span class="fc" id="L1687">                    TIntSet outerBorder = new TIntHashSet();</span>
<span class="fc" id="L1688">                    finder2.extractBorder2(set, embedded, outerBorder,</span>
<span class="fc" id="L1689">                        clrImg.getWidth());</span>

<span class="fc" id="L1691">                    labeledSets.add(set);</span>
<span class="fc" id="L1692">                    labeledEdges.add(outerBorder);</span>
                }
            }
            
            /*
            if (debug) {
                Image tmp = clrImg.copyImage();
                ImageIOHelper.addAlternatingColorPointSetsToImage2(
                    labeledSets, 0, 0, 0, tmp);
                MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;_dbg_&quot; + msz);
            }*/
        }

<span class="pc bpc" id="L1705" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1706">            Image tmp = clrImg.copyImage();</span>
<span class="nc" id="L1707">            ImageIOHelper.addAlternatingColorPointSetsToImage2(</span>
                labeledSets, 0, 0, 0, tmp);
<span class="nc" id="L1709">            MiscDebug.writeImage(tmp, &quot;_&quot; + ts + &quot;thinned0_&quot;);</span>
        }
<span class="fc" id="L1711">    }</span>

    /**
     * NOTE, this method actually finds the connected groups .geq.
     * minGroupSize and then extracts the boundaries from them.
     * If the set minus the boundaries is not at least minGroupSize,
     * then the set is excluded.
     * So the method uses a minGroupSize that does not include the boundary
     * pixels.
     * @param edgePixIdxs set of pixel indexes
     */
    private void populateEdgeLists(TIntSet edgePixIdxs) {

        //if (debug) {
        //    System.out.println(&quot;populateEdgeLists: nE=&quot; + edgePixIdxs.size() 
        //        + &quot; pixels&quot;);
        //}
        
        // find clusters (contiguous pixels of value 0) between edges
<span class="fc" id="L1730">        labeledSets = extractContiguousBetweenEdges(edgePixIdxs);</span>

<span class="fc" id="L1732">        labeledEdges = new ArrayList&lt;TIntSet&gt;();</span>

<span class="fc" id="L1734">        PerimeterFinder2 finder2 = new PerimeterFinder2();</span>

<span class="fc" id="L1736">        int ne = 0;</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">        for (int i = 0; i &lt; labeledSets.size(); ++i) {</span>
<span class="fc" id="L1738">            TIntSet set = labeledSets.get(i);</span>
<span class="fc" id="L1739">            TIntSet embedded = new TIntHashSet();</span>
<span class="fc" id="L1740">            TIntSet outerBorder = new TIntHashSet();</span>
<span class="fc" id="L1741">            finder2.extractBorder2(set, embedded, outerBorder, gsImg.getWidth());</span>

<span class="fc" id="L1743">            labeledEdges.add(outerBorder);</span>
        
<span class="fc" id="L1745">            ne += outerBorder.size();</span>
        }
        
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1749">            System.out.println(ne + &quot; pixels in edgeList&quot;);</span>
        }

<span class="pc bnc" id="L1752" title="All 2 branches missed.">        assert(labeledSets.size() == labeledEdges.size());</span>

<span class="fc" id="L1754">        System.out.println(labeledSets.size() + &quot; labeled sets&quot;);</span>
<span class="fc" id="L1755">    }</span>

    private void assignTheUnassigned(List&lt;TIntSet&gt; contiguous,
        int[] labels, float[][] hsvs, TIntSet unassignedSet) {

<span class="fc" id="L1760">        int w = clrImg.getWidth();</span>
<span class="fc" id="L1761">        int h = clrImg.getHeight();</span>
<span class="fc" id="L1762">        int n = clrImg.getNPixels();</span>

<span class="fc" id="L1764">        int maxValue = Math.max(w, h);</span>
<span class="fc" id="L1765">        int nBits = 1 + (int)Math.ceil(Math.log(maxValue)/Math.log(2));</span>
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">        if (nBits &gt; 31) {</span>
<span class="nc" id="L1767">            nBits = 31;</span>
        }
        
        //System.out.println(&quot;assign &quot; + unassignedSet.size() + &quot; out of &quot;
        //    + n + &quot; pixels&quot;);
        
        // key = pixel index of unassigned, value = adj pixels that are assigned
<span class="fc" id="L1774">        TIntObjectMap&lt;TIntSet&gt; adjAssignedMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
        // key = pixel index of unassigned, value = adj pixels that are unassigned
<span class="fc" id="L1777">        TIntObjectMap&lt;TIntSet&gt; adjUnassignedMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>

<span class="fc" id="L1779">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1780">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1782">        TIntIterator iter = unassignedSet.iterator();</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1784">            int pixIdx = iter.next();</span>
<span class="fc" id="L1785">            addNeighborLabelsForPoint(labels, adjAssignedMap, </span>
                adjUnassignedMap, pixIdx, dxs, dys);
<span class="fc" id="L1787">        }</span>
        
        // using a min heap whose priority is to set the nodes
        //    which have the largest number of assigned neighbors.
        //    nAssigned=8 -&gt; key=8-nAssigned = 0.
<span class="fc" id="L1792">        MinHeapForRT2012 heap = new MinHeapForRT2012(9, n, nBits);</span>

        // a map of nodes for the unassigned pixels
<span class="fc" id="L1795">        TIntObjectMap&lt;HeapNode&gt; unAMap = new TIntObjectHashMap&lt;HeapNode&gt;();</span>
        
<span class="fc" id="L1797">        iter = unassignedSet.iterator();</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
            
<span class="fc" id="L1800">            int pixIdx = iter.next();</span>
            
<span class="fc" id="L1802">            TIntSet neighbors = adjAssignedMap.get(pixIdx);</span>
<span class="pc bnc" id="L1803" title="All 2 branches missed.">            assert(neighbors != null);</span>
            
<span class="fc" id="L1805">            int nNeigbhors = neighbors.size();</span>
            
<span class="fc" id="L1807">            long key = 8 - nNeigbhors;</span>
<span class="fc" id="L1808">            HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L1809">            node.setData(Integer.valueOf(pixIdx));</span>
            
<span class="fc" id="L1811">            unAMap.put(pixIdx, node);</span>
            
<span class="fc" id="L1813">            heap.insert(node);</span>
<span class="fc" id="L1814">        }</span>
        
<span class="pc bnc" id="L1816" title="All 2 branches missed.">        assert(unassignedSet.size() == heap.getNumberOfNodes());</span>
        
<span class="fc" id="L1818">        float[] lab2 = null;</span>
<span class="fc" id="L1819">        float[] lab = new float[3];</span>
        
        
        //DEBUG
<span class="fc" id="L1823">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L1824">        int[] xyTmp = new int[2];</span>
<span class="fc" id="L1825">        int[] xyTmp2 = new int[2];</span>
<span class="fc" id="L1826">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
        
<span class="fc bfc" id="L1829" title="All 2 branches covered.">        while (heap.getNumberOfNodes() &gt; 0) {</span>
                        
<span class="fc" id="L1831">            HeapNode node = heap.extractMin();</span>
            
<span class="pc bnc" id="L1833" title="All 2 branches missed.">            assert(node != null);</span>
            
<span class="fc" id="L1835">            int pixIdx = ((Integer)node.getData()).intValue();</span>
 
<span class="fc" id="L1837">            clrImg.getHSB(pixIdx, lab);</span>

<span class="fc" id="L1839">            TIntSet adjAssigned = adjAssignedMap.get(pixIdx);</span>
<span class="pc bpc" id="L1840" title="1 of 2 branches missed.">            if (adjAssigned.isEmpty()) {</span>
<span class="nc" id="L1841">                System.out.println(&quot;priority=&quot; + node.getKey()</span>
                   + &quot; nUnassigned remaining=&quot; + 
<span class="nc" id="L1843">                    adjAssignedMap.size() + &quot; heap.n=&quot; +</span>
<span class="nc" id="L1844">                    heap.getNumberOfNodes());</span>
            }
<span class="pc bnc" id="L1846" title="All 2 branches missed.">            assert(!adjAssigned.isEmpty());</span>
            
<span class="fc" id="L1848">            double minD = Double.MAX_VALUE;</span>
<span class="fc" id="L1849">            int minLabel2 = -1;</span>
<span class="fc" id="L1850">            int minDBGPIXIDX2 = -1;</span>

<span class="fc" id="L1852">            TIntIterator iter2 = adjAssigned.iterator();</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L1854">                int pixIdx2 = iter2.next();</span>
<span class="fc" id="L1855">                int label2 = labels[pixIdx2];</span>
<span class="fc" id="L1856">                lab2 = hsvs[label2];</span>
                
<span class="fc" id="L1858">                double diffSum = 0;</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">                for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1860">                    float diff = lab[i] - lab2[i];</span>
<span class="fc" id="L1861">                    diffSum += (diff * diff);</span>
                }

<span class="fc bfc" id="L1864" title="All 2 branches covered.">                if (diffSum &lt; minD) {</span>
<span class="fc" id="L1865">                    minD = diffSum;</span>
<span class="fc" id="L1866">                    minLabel2 = label2;</span>
<span class="fc" id="L1867">                    minDBGPIXIDX2 = pixIdx2;</span>
                }
<span class="fc" id="L1869">            }</span>

<span class="fc" id="L1871">            labels[pixIdx] = minLabel2;</span>
     
<span class="fc" id="L1873">            adjAssignedMap.remove(pixIdx);</span>
            
<span class="fc" id="L1875">            unAMap.remove(pixIdx);</span>
            
            // update the adjacent unassigned pixels and their keys in heap.
            // these pixels are not in adjLabels.
<span class="fc" id="L1879">            TIntSet adjUnassigned = adjUnassignedMap.get(pixIdx);</span>
<span class="pc bpc" id="L1880" title="1 of 2 branches missed.">            if (adjUnassigned == null) {</span>
<span class="nc" id="L1881">                continue;</span>
            }
<span class="fc" id="L1883">            adjUnassignedMap.remove(pixIdx);</span>
            
<span class="fc" id="L1885">            iter2 = adjUnassigned.iterator();</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
                
                // this is an unassigned pixel
<span class="fc" id="L1889">                int pixIdx2 = iter2.next();</span>
<span class="pc bnc" id="L1890" title="All 2 branches missed.">                assert(pixIdx != pixIdx2);</span>
                
                // pixIdx should be in it's adj unassigned and then removed
<span class="fc" id="L1893">                TIntSet adj2 = adjUnassignedMap.get(pixIdx2);</span>
<span class="pc bnc" id="L1894" title="All 2 branches missed.">                assert(adj2 != null);</span>
<span class="fc" id="L1895">                boolean rmvd = adj2.remove(pixIdx);</span>
<span class="pc bnc" id="L1896" title="All 2 branches missed.">                assert(rmvd);</span>
                
                // add pixIdx to it's assigned pixels
<span class="fc" id="L1899">                adj2 = adjAssignedMap.get(pixIdx2);</span>
<span class="pc bnc" id="L1900" title="All 2 branches missed.">                assert(adj2 != null);</span>
<span class="fc" id="L1901">                adj2.add(pixIdx);</span>

<span class="fc" id="L1903">                HeapNode node2 = unAMap.get(pixIdx2);</span>
<span class="pc bnc" id="L1904" title="All 2 branches missed.">                assert(node2 != null);</span>
<span class="fc" id="L1905">                long key2 = 8 - adj2.size();</span>
<span class="pc bnc" id="L1906" title="All 2 branches missed.">                assert(key2 &gt; -1);</span>
<span class="pc bpc" id="L1907" title="1 of 2 branches missed.">                if (key2 &lt; node2.getKey()) {</span>
<span class="fc" id="L1908">                    heap.decreaseKey(node2, key2);</span>
                }
<span class="fc" id="L1910">            }</span>
<span class="fc" id="L1911">        }</span>

<span class="pc bnc" id="L1913" title="All 2 branches missed.">        assert(adjAssignedMap.isEmpty());</span>

<span class="fc" id="L1915">        iter = unassignedSet.iterator();</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1917">            int pixIdx = iter.next();</span>
<span class="fc" id="L1918">            int label = labels[pixIdx];</span>
<span class="fc" id="L1919">            contiguous.get(label).add(pixIdx);</span>
<span class="fc" id="L1920">        }</span>
<span class="fc" id="L1921">    }</span>
    
    private void _assignTheUnassigned(List&lt;TIntSet&gt; contiguous,
        int[] labels, float[][] luvws, TIntSet unassignedSet) {

<span class="fc" id="L1926">        int w = clrImg.getWidth();</span>
<span class="fc" id="L1927">        int h = clrImg.getHeight();</span>
<span class="fc" id="L1928">        int n = clrImg.getNPixels();</span>

<span class="fc" id="L1930">        int maxValue = Math.max(w, h);</span>
<span class="fc" id="L1931">        int nBits = 1 + (int)Math.ceil(Math.log(maxValue)/Math.log(2));</span>
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">        if (nBits &gt; 31) {</span>
<span class="nc" id="L1933">            nBits = 31;</span>
        }
        
        //System.out.println(&quot;assign &quot; + unassignedSet.size() + &quot; out of &quot;
        //    + n + &quot; pixels&quot;);
        
        // key = pixel index of unassigned, value = adj pixels that are assigned
<span class="fc" id="L1940">        TIntObjectMap&lt;TIntSet&gt; adjAssignedMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
        // key = pixel index of unassigned, value = adj pixels that are unassigned
<span class="fc" id="L1943">        TIntObjectMap&lt;TIntSet&gt; adjUnassignedMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>

<span class="fc" id="L1945">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L1946">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L1948">        TIntIterator iter = unassignedSet.iterator();</span>
<span class="fc bfc" id="L1949" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1950">            int pixIdx = iter.next();</span>
<span class="fc" id="L1951">            addNeighborLabelsForPoint(labels, adjAssignedMap, </span>
                adjUnassignedMap, pixIdx, dxs, dys);
<span class="fc" id="L1953">        }</span>
        
        // using a min heap whose priority is to set the nodes
        //    which have the largest number of assigned neighbors.
        //    nAssigned=8 -&gt; key=8-nAssigned = 0.
<span class="fc" id="L1958">        MinHeapForRT2012 heap = new MinHeapForRT2012(9, n, nBits);</span>

        // a map of nodes for the unassigned pixels
<span class="fc" id="L1961">        TIntObjectMap&lt;HeapNode&gt; unAMap = new TIntObjectHashMap&lt;HeapNode&gt;();</span>
        
<span class="fc" id="L1963">        iter = unassignedSet.iterator();</span>
<span class="fc bfc" id="L1964" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
            
<span class="fc" id="L1966">            int pixIdx = iter.next();</span>
            
<span class="fc" id="L1968">            TIntSet neighbors = adjAssignedMap.get(pixIdx);</span>
<span class="pc bnc" id="L1969" title="All 2 branches missed.">            assert(neighbors != null);</span>
            
<span class="fc" id="L1971">            int nNeigbhors = neighbors.size();</span>
            
<span class="fc" id="L1973">            long key = 8 - nNeigbhors;</span>
<span class="fc" id="L1974">            HeapNode node = new HeapNode(key);</span>
<span class="fc" id="L1975">            node.setData(Integer.valueOf(pixIdx));</span>
            
<span class="fc" id="L1977">            unAMap.put(pixIdx, node);</span>
            
<span class="fc" id="L1979">            heap.insert(node);</span>
<span class="fc" id="L1980">        }</span>
        
<span class="pc bnc" id="L1982" title="All 2 branches missed.">        assert(unassignedSet.size() == heap.getNumberOfNodes());</span>
        
<span class="fc" id="L1984">        float[] luv2 = null;</span>
<span class="fc" id="L1985">        float[] luv = new float[3];</span>
        
        
        //DEBUG
<span class="fc" id="L1989">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L1990">        int[] xyTmp = new int[2];</span>
<span class="fc" id="L1991">        int[] xyTmp2 = new int[2];</span>
<span class="fc" id="L1992">        CIEChromaticity cieC = new CIEChromaticity();</span>
        
        
<span class="fc bfc" id="L1995" title="All 2 branches covered.">        while (heap.getNumberOfNodes() &gt; 0) {</span>
                        
<span class="fc" id="L1997">            HeapNode node = heap.extractMin();</span>
            
<span class="pc bnc" id="L1999" title="All 2 branches missed.">            assert(node != null);</span>
            
<span class="fc" id="L2001">            int pixIdx = ((Integer)node.getData()).intValue();</span>
            
<span class="fc" id="L2003">            luv = cieC.rgbToCIELUV_WideRangeLightness(</span>
<span class="fc" id="L2004">                clrImg.getR(pixIdx), clrImg.getG(pixIdx), clrImg.getB(pixIdx));</span>

<span class="fc" id="L2006">            TIntSet adjAssigned = adjAssignedMap.get(pixIdx);</span>
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">            if (adjAssigned.isEmpty()) {</span>
<span class="nc" id="L2008">                System.out.println(&quot;priority=&quot; + node.getKey()</span>
                   + &quot; nUnassigned remaining=&quot; + 
<span class="nc" id="L2010">                    adjAssignedMap.size() + &quot; heap.n=&quot; +</span>
<span class="nc" id="L2011">                    heap.getNumberOfNodes());</span>
            }
<span class="pc bnc" id="L2013" title="All 2 branches missed.">            assert(!adjAssigned.isEmpty());</span>
            
<span class="fc" id="L2015">            double minD = Double.MAX_VALUE;</span>
<span class="fc" id="L2016">            int minLabel2 = -1;</span>

<span class="fc" id="L2018">            TIntIterator iter2 = adjAssigned.iterator();</span>
<span class="fc bfc" id="L2019" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L2020">                int pixIdx2 = iter2.next();</span>
<span class="fc" id="L2021">                int label2 = labels[pixIdx2];</span>
<span class="fc" id="L2022">                luv2 = luvws[label2];</span>
                
<span class="fc" id="L2024">                double diffSum = 0;</span>
<span class="fc bfc" id="L2025" title="All 2 branches covered.">                for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L2026">                    float diff = cieC.calcNormalizedDifferenceLUV_WideRangeLightness(luv, luv2);</span>
<span class="fc" id="L2027">                    diffSum += (diff * diff);</span>
                }

<span class="fc bfc" id="L2030" title="All 2 branches covered.">                if (diffSum &lt; minD) {</span>
<span class="fc" id="L2031">                    minD = diffSum;</span>
<span class="fc" id="L2032">                    minLabel2 = label2;</span>
                }
<span class="fc" id="L2034">            }</span>

<span class="fc" id="L2036">            labels[pixIdx] = minLabel2;</span>
     
<span class="fc" id="L2038">            adjAssignedMap.remove(pixIdx);</span>
            
<span class="fc" id="L2040">            unAMap.remove(pixIdx);</span>
            
            // update the adjacent unassigned pixels and their keys in heap.
            // these pixels are not in adjLabels.
<span class="fc" id="L2044">            TIntSet adjUnassigned = adjUnassignedMap.get(pixIdx);</span>
<span class="pc bpc" id="L2045" title="1 of 2 branches missed.">            if (adjUnassigned == null) {</span>
<span class="nc" id="L2046">                continue;</span>
            }
<span class="fc" id="L2048">            adjUnassignedMap.remove(pixIdx);</span>
            
<span class="fc" id="L2050">            iter2 = adjUnassigned.iterator();</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
                
                // this is an unassigned pixel
<span class="fc" id="L2054">                int pixIdx2 = iter2.next();</span>
<span class="pc bnc" id="L2055" title="All 2 branches missed.">                assert(pixIdx != pixIdx2);</span>
                
                // pixIdx should be in it's adj unassigned and then removed
<span class="fc" id="L2058">                TIntSet adj2 = adjUnassignedMap.get(pixIdx2);</span>
<span class="pc bnc" id="L2059" title="All 2 branches missed.">                assert(adj2 != null);</span>
<span class="fc" id="L2060">                boolean rmvd = adj2.remove(pixIdx);</span>
<span class="pc bnc" id="L2061" title="All 2 branches missed.">                assert(rmvd);</span>
                
                // add pixIdx to it's assigned pixels
<span class="fc" id="L2064">                adj2 = adjAssignedMap.get(pixIdx2);</span>
<span class="pc bnc" id="L2065" title="All 2 branches missed.">                assert(adj2 != null);</span>
<span class="fc" id="L2066">                adj2.add(pixIdx);</span>

<span class="fc" id="L2068">                HeapNode node2 = unAMap.get(pixIdx2);</span>
<span class="pc bnc" id="L2069" title="All 2 branches missed.">                assert(node2 != null);</span>
<span class="fc" id="L2070">                long key2 = 8 - adj2.size();</span>
<span class="pc bnc" id="L2071" title="All 2 branches missed.">                assert(key2 &gt; -1);</span>
<span class="pc bpc" id="L2072" title="1 of 2 branches missed.">                if (key2 &lt; node2.getKey()) {</span>
<span class="fc" id="L2073">                    heap.decreaseKey(node2, key2);</span>
                }
<span class="fc" id="L2075">            }</span>
<span class="fc" id="L2076">        }</span>

<span class="pc bnc" id="L2078" title="All 2 branches missed.">        assert(adjAssignedMap.isEmpty());</span>

<span class="fc" id="L2080">        iter = unassignedSet.iterator();</span>
<span class="fc bfc" id="L2081" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2082">            int pixIdx = iter.next();</span>
<span class="fc" id="L2083">            int label = labels[pixIdx];</span>
<span class="fc" id="L2084">            contiguous.get(label).add(pixIdx);</span>
<span class="fc" id="L2085">        }</span>
<span class="fc" id="L2086">    }</span>

    private void addNeighborLabelsForPoint(int[] labels,
        TIntObjectMap&lt;TIntSet&gt; adjAssignedMap, 
        TIntObjectMap&lt;TIntSet&gt; adjUnassignedMap,
        int pixIdx, int[] dxs, int[] dys) {

<span class="fc" id="L2093">        int w = clrImg.getWidth();</span>
<span class="fc" id="L2094">        int h = clrImg.getHeight();</span>

<span class="fc" id="L2096">        TIntSet adjLabels = adjAssignedMap.get(pixIdx);</span>
<span class="fc" id="L2097">        TIntSet adjULabels = adjUnassignedMap.get(pixIdx);</span>
<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">        if (adjLabels == null) {</span>
<span class="pc bnc" id="L2099" title="All 2 branches missed.">            assert(adjULabels == null);</span>
            
<span class="fc" id="L2101">            adjLabels = new TIntHashSet();</span>
<span class="fc" id="L2102">            adjAssignedMap.put(pixIdx, adjLabels);</span>
            
<span class="fc" id="L2104">            adjULabels = new TIntHashSet();</span>
<span class="fc" id="L2105">            adjUnassignedMap.put(pixIdx, adjULabels);</span>
        }
        
<span class="fc" id="L2108">        int j = pixIdx/w;</span>
<span class="fc" id="L2109">        int i = pixIdx - (j * w);</span>

<span class="fc bfc" id="L2111" title="All 2 branches covered.">        for (int m = 0; m &lt; dxs.length; ++m) {</span>
<span class="fc" id="L2112">            int x2 = i + dxs[m];</span>
<span class="fc" id="L2113">            int y2 = j + dys[m];</span>
<span class="fc bfc" id="L2114" title="All 8 branches covered.">            if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt; (w - 1)) || (y2 &gt; (h - 1))) {</span>
<span class="fc" id="L2115">                continue;</span>
            }
<span class="fc" id="L2117">            int pixIdx2 = (y2 * w) + x2;</span>
<span class="fc bfc" id="L2118" title="All 2 branches covered.">            if (labels[pixIdx2] == -1) {</span>
<span class="fc" id="L2119">                adjULabels.add(pixIdx2);</span>
            } else {
<span class="fc" id="L2121">                adjLabels.add(pixIdx2);</span>
            }
        }
<span class="fc" id="L2124">    }</span>
    
    private void removeImageBorder(TIntSet pixIdxs, TIntSet outputRmvd,
        int width, int height) {

<span class="fc" id="L2129">        TIntSet rm = new TIntHashSet();</span>
<span class="fc" id="L2130">        TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2132">            int pixIdx = iter.next();</span>
<span class="fc" id="L2133">            int y = pixIdx/width;</span>
<span class="fc" id="L2134">            int x = pixIdx - (y * width);</span>
<span class="fc bfc" id="L2135" title="All 8 branches covered.">            if (x == 0 || y == 0 || x == (width - 1) || (y == (height - 1))) {</span>
<span class="fc" id="L2136">                rm.add(pixIdx);</span>
<span class="fc" id="L2137">                outputRmvd.add(pixIdx);</span>
            }
<span class="fc" id="L2139">        }</span>

<span class="fc" id="L2141">        pixIdxs.removeAll(rm);</span>
<span class="fc" id="L2142">    }</span>

    // calc avg score and count the points w/ v&gt;0
    private double[] calcAvgScore(TIntSet pixIdxs, GreyscaleImage sobelScores,
        TIntSet outputMatched, TIntSet outputUnmatched, int imgWidth) {

<span class="fc" id="L2148">        double sum = 0;</span>
<span class="fc" id="L2149">        TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2151">            int pixIdx = iter.next();</span>
<span class="fc" id="L2152">            int v = sobelScores.getValue(pixIdx);</span>
<span class="fc" id="L2153">            sum += v;</span>
<span class="fc bfc" id="L2154" title="All 2 branches covered.">            if (v &gt; 0) {</span>
<span class="fc" id="L2155">                outputMatched.add(pixIdx);</span>
            } else {
<span class="fc" id="L2157">                outputUnmatched.add(pixIdx);</span>
            }
<span class="fc" id="L2159">        }</span>

<span class="fc" id="L2161">        sum /= (double) pixIdxs.size();</span>

<span class="fc" id="L2163">        return new double[]{sum, outputMatched.size()};</span>
    }

    private int calcAvg(GreyscaleImage img, TIntSet pixIdxs) {

<span class="fc" id="L2168">        double sum = 0;</span>
<span class="fc" id="L2169">        TIntIterator iter = pixIdxs.iterator();</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2171">            int pixIdx = iter.next();</span>
<span class="fc" id="L2172">            sum += img.getValue(pixIdx);</span>
<span class="fc" id="L2173">        }</span>
<span class="fc" id="L2174">        sum /= (double)pixIdxs.size();</span>

<span class="fc" id="L2176">        return (int)Math.round(sum);</span>
    }
    
    // the values are sorted
    private TIntObjectMap&lt;TIntList&gt; findEndpoints(
        TIntSet unmatchedPoints,
        TIntIntMap matchedPointsIdxMap, int width, int height) {

<span class="fc" id="L2184">        int bIdx = -1;</span>
        
<span class="fc" id="L2186">        TIntObjectMap&lt;TIntList&gt; umEPIdxMap =</span>
            new TIntObjectHashMap&lt;TIntList&gt;();

<span class="fc" id="L2189">        int[] dxs = Misc.dx8;</span>
<span class="fc" id="L2190">        int[] dys = Misc.dy8;</span>

<span class="fc" id="L2192">        TIntIterator iter = unmatchedPoints.iterator();</span>
<span class="fc bfc" id="L2193" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2194">            int pixIdx = iter.next();</span>
<span class="fc" id="L2195">            int y = pixIdx/width;</span>
<span class="fc" id="L2196">            int x = pixIdx - (y * width);</span>

            // add fake point if this is adjacent to an image border pixel
<span class="fc bfc" id="L2199" title="All 8 branches covered.">            if ((x == 1) || (y == 1) || (x == (width - 2)) || (y == (height - 2))) {</span>
<span class="fc" id="L2200">                TIntList idxs = umEPIdxMap.get(pixIdx);</span>
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">                if (idxs == null) {</span>
<span class="fc" id="L2202">                    idxs = new TIntArrayList(3);</span>
<span class="fc" id="L2203">                    umEPIdxMap.put(pixIdx, idxs);</span>
                }
<span class="fc" id="L2205">                idxs.add(bIdx);</span>
<span class="fc" id="L2206">                --bIdx;</span>
            }
            
<span class="fc bfc" id="L2209" title="All 2 branches covered.">            for (int k = 0; k &lt; dxs.length; ++k) {</span>
<span class="fc" id="L2210">                int x2 = x + dxs[k];</span>
<span class="fc" id="L2211">                int y2 = y + dys[k];</span>
<span class="pc bpc" id="L2212" title="4 of 8 branches missed.">                if (x2 &lt; 0 || y2 &lt; 0 || (x2 &gt;= width) || (y2 &gt;= height)) {</span>
<span class="nc" id="L2213">                    continue;</span>
                }
<span class="fc" id="L2215">                int pixIdx2 = (y2 * width) + x2;</span>
<span class="fc bfc" id="L2216" title="All 2 branches covered.">                if (matchedPointsIdxMap.containsKey(pixIdx2)) {</span>
<span class="fc" id="L2217">                    TIntList values = umEPIdxMap.get(pixIdx);</span>
<span class="fc bfc" id="L2218" title="All 2 branches covered.">                    if (values == null) {</span>
<span class="fc" id="L2219">                        values = new TIntArrayList(3);</span>
<span class="fc" id="L2220">                        umEPIdxMap.put(pixIdx, values);</span>
                    }
<span class="fc" id="L2222">                    values.add(matchedPointsIdxMap.get(pixIdx2));</span>
                }
            }
<span class="fc" id="L2225">        }</span>
        
<span class="fc" id="L2227">        return umEPIdxMap;</span>
    }
    
    private List&lt;List&lt;TIntSet&gt;&gt; extractontiguousSegments(
        List&lt;TIntSet&gt; unmatchedRMap) {
       
<span class="fc" id="L2233">        int n = unmatchedRMap.size();</span>
        
<span class="fc" id="L2235">        System.out.println(&quot;number of unmatched regions=&quot; + n);</span>
        
<span class="fc" id="L2237">        List&lt;List&lt;TIntSet&gt;&gt; output = new ArrayList&lt;List&lt;TIntSet&gt;&gt;();</span>
        
<span class="fc bfc" id="L2239" title="All 2 branches covered.">        for (int i = 0; i &lt; unmatchedRMap.size(); ++i) {</span>
                        
<span class="fc" id="L2241">            TIntSet idxs = unmatchedRMap.get(i);</span>
            
<span class="fc" id="L2243">            ConnectedPointsFinder finder3 = new ConnectedPointsFinder(</span>
<span class="fc" id="L2244">                clrImg.getWidth(), clrImg.getHeight());</span>
<span class="fc" id="L2245">            finder3.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L2246">            finder3.setToUse8Neighbors();</span>
<span class="fc" id="L2247">            finder3.findConnectedPointGroups(idxs);</span>
            
<span class="fc" id="L2249">            List&lt;TIntSet&gt; list = new ArrayList&lt;TIntSet&gt;();</span>
<span class="fc" id="L2250">            output.add(list);</span>
            
<span class="fc" id="L2252">            int n3 = finder3.getNumberOfGroups();</span>
<span class="fc bfc" id="L2253" title="All 2 branches covered.">            for (int ii = 0; ii &lt; n3; ++ii) {</span>
                
<span class="fc" id="L2255">                TIntSet segment = finder3.getXY(ii);</span>
                
<span class="fc" id="L2257">                list.add(segment);</span>
            }
        }
       
<span class="fc" id="L2261">        return output;</span>
    }
    
    private void addUnmatchedToEdgePoints(List&lt;TIntSet&gt; unmatchedRMap, 
        TIntSet allEdgePoints, TIntSet rmvdImgBorders, int maxGapSize) {
        
        //make contiguous connected segments of matched set.
<span class="fc" id="L2268">        ConnectedPointsFinder finder2 = new ConnectedPointsFinder(</span>
<span class="fc" id="L2269">            clrImg.getWidth(), clrImg.getHeight());</span>
<span class="fc" id="L2270">        finder2.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L2271">        finder2.findConnectedPointGroups(allEdgePoints);</span>

<span class="fc" id="L2273">        final int n2 = finder2.getNumberOfGroups();</span>

<span class="fc" id="L2275">        System.out.println(&quot;number of matched segments=&quot; + n2);</span>

        // key = matched point, value = finder2 index of point
<span class="fc" id="L2278">        TIntIntMap mpIdxMap = finder2.createPointIndexMap();</span>

        //   sections in unmatchedRMap are single width segments
        //   .  when a segment is adjacent to 2 matched segments (from finder2),
        //      that unmatched segment can be added.
        //      note that multiple regions may have adjacent arcs in
        //      an unmatched area, so to thin to the best path,
        //      could either take the best
        //      unmatched segment that connects those 2 matched segments
        //      for that area, or could let the &quot;assignTheUnassigned&quot;
        //      kmeans-style method handle this thinning.
        //      choosing the later since it is needed for the matched
        //      points already.
        //      NOTE: the unmatched dist between endpoints AND the number
        //            of pixels in the unmatched segment still need to remain under
        //            the maxGapSize, helping to avoid adding the region
        //            portions which are not edges.
<span class="fc" id="L2295">        List&lt;List&lt;TIntSet&gt;&gt; unmatchedRSegments</span>
<span class="fc" id="L2296">            = extractontiguousSegments(unmatchedRMap);</span>

<span class="fc bfc" id="L2298" title="All 2 branches covered.">        for (List&lt;TIntSet&gt; segmentList : unmatchedRSegments) {</span>

<span class="fc bfc" id="L2300" title="All 2 branches covered.">            for (TIntSet segment : segmentList) {</span>

<span class="fc bfc" id="L2302" title="All 2 branches covered.">                if (segment.size() &gt; maxGapSize) {</span>
<span class="fc" id="L2303">                    continue;</span>
                }

                // key = pixIdx, value=edge segment indexes that key
                //       pixel is adjacent to
                // NOTE, that for pixels adjacent to an image border pixel,
                //       that is one off from image border, a fake edge
                //       is added to the values and those fake edges are
                //       negative numbers starting at -1
<span class="fc" id="L2312">                TIntObjectMap&lt;TIntList&gt; umEPIdxMap = findEndpoints(segment, mpIdxMap, clrImg.getWidth(), clrImg.getHeight());</span>

<span class="fc bfc" id="L2314" title="All 2 branches covered.">                if (umEPIdxMap.isEmpty()) {</span>
<span class="fc" id="L2315">                    continue;</span>
                }

                // for any 2 entries in umEPIdxMap
                //   if the set difference operation results in 2 edge
                //      indexes, can add this segment to allEdgePoints.
<span class="fc" id="L2321">                TIntSet posEdgeIdxs = new TIntHashSet(3);</span>
<span class="fc" id="L2322">                boolean connectsToBorder = false;</span>

<span class="fc" id="L2324">                TIntObjectIterator&lt;TIntList&gt; iter11 = umEPIdxMap.iterator();</span>
<span class="fc bfc" id="L2325" title="All 2 branches covered.">                for (int ii = 0; ii &lt; umEPIdxMap.size(); ++ii) {</span>
<span class="fc" id="L2326">                    iter11.advance();</span>
<span class="fc" id="L2327">                    TIntList eIdxs = iter11.value();</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">                    for (int jj = 0; jj &lt; eIdxs.size(); ++jj) {</span>
<span class="fc" id="L2329">                        int eIdx = eIdxs.get(jj);</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">                        if (eIdx &lt; 0) {</span>
<span class="fc" id="L2331">                            connectsToBorder = true;</span>
                        } else {
<span class="fc" id="L2333">                            posEdgeIdxs.add(eIdx);</span>
                        }
                    }
                }

<span class="fc bfc" id="L2338" title="All 2 branches covered.">                if (posEdgeIdxs.size() &gt;= 1) {</span>
<span class="fc" id="L2339">                    allEdgePoints.addAll(segment);</span>
                }
<span class="fc" id="L2341">            }</span>
<span class="fc" id="L2342">        }</span>

<span class="fc" id="L2344">    }</span>
    
    public EdgeFilterProducts getEdgeFilterProducts() {
<span class="fc" id="L2347">        return edgeProducts;</span>
    }

    /**
     * @return the edgeList
     */
    public List&lt;TIntSet&gt; getEdgeList() {
<span class="nc" id="L2354">        return labeledEdges;</span>
    }

    /**
     * @return the state
     */
    public STATE getState() {
<span class="fc" id="L2361">        return state;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Region.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features.mser</a> &gt; <span class="el_source">Region.java</span></div><h1>Region.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features.mser;

import algorithms.QuickSort;
import algorithms.imageProcessing.Image;
import algorithms.imageProcessing.ImageIOHelper;
import algorithms.util.PairInt;
import algorithms.util.TrioInt;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
MSER.java and Region.java are java ports of the C++ MSER
implementation of MSER by Charles Dubout &lt;charles.dubout@idiap.ch&gt;
downloaded from https://github.com/idiap/mser

The C++ code has copyright:
--------------------------
GNU GENERAL PUBLIC LICENSE, Version 3

Copyright (c) 2011 Idiap Research Institute, http://www.idiap.ch/.
Written by Charles Dubout &lt;charles.dubout@idiap.ch&gt;.
 
MSER is free software: you can redistribute it and/or modify it under the terms of the GNU
General Public License version 3 as published by the Free Software Foundation.
 MSER is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.

You should have received a copy of the GNU General Public License along with MSER. If not, see
&lt;http://www.gnu.org/licenses/&gt;.
--------------------------

Linear time Maximally Stable Extremal Regions (MSER) implementation as described
in D. Nistér and H. Stewénius, &quot;Linear Time Maximally Stable Extremal Regions&quot;,
ECCV 2008.
The functionality is similar to that of VLFeat MSER feature detector
&lt;http://www.vlfeat.org/overview/mser.html&gt; but the code is several time faster.
MSER is a blob detector, like the Laplacian of Gaussian used by the SIFT
algorithm. It extracts stable connected regions of some level sets from an
image, and optionally fits ellipses to them.
* 
* ------
* Nichole King ported the C++ code of Charles Dubout to java and added
* methods used in canonicalization.
* 
* The equals and hashcode have been tailored to consider the composite of
* pixel_, area_ and moments_ as the primary key (for Collections, etc.).
*/
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">public class Region {</span>

    /**
     * Level at which the region is processed.
     */
    public int level_;

    /**
     * Index of the initial pixel (y * width + x).
     */
    int pixel_;

    /**
     * Area of the region (moment zero), that is, the number of
     * pixels in this region.
     */
    int area_;
    
    /**
     * First and second moments of the region as (x, y, x^2, xy, y^2).
     */
    double[] moments_;

    /**
     * MSER variation.
     */
    double variation_;

    /**
     * Flag indicating if the region is stable
     */
    private boolean stable_;

<span class="fc" id="L88">    private Region parent_ = null;</span>
<span class="fc" id="L89">    private Region child_ = null;</span>
<span class="fc" id="L90">    private Region next_ = null;</span>
   
    // temporary storage of accumulated points to look at partial edges
<span class="fc" id="L93">    public TIntList accX = new TIntArrayList();</span>
<span class="fc" id="L94">    public TIntList accY = new TIntArrayList();</span>
    
    /**
     * constructor with default level = 256 and pixel=0.  255 is the maximum
     * values of any pixel used in MSER.  the default level is used when
     * instantiating MSER to start with a high component level.
     * This constructor uses a default level of 256 and default pixel of 0.
     */
<span class="fc" id="L102">    public Region() {</span>
<span class="fc" id="L103">        int level = 256;</span>
<span class="fc" id="L104">        int pixel = 0;</span>
<span class="fc" id="L105">        init(level, pixel);</span>
<span class="fc" id="L106">    }</span>

    /**
     * @param level Level at which the region is processed (default level is 256)
     * @param pixel Index of the initial pixel = (y * width + x). (default pixel is 0)
     */
<span class="fc" id="L112">    public Region(int level, int pixel) {</span>
<span class="fc" id="L113">        init(level, pixel);</span>
<span class="fc" id="L114">    }</span>

    public double getVariation() {
<span class="fc" id="L117">        return variation_;</span>
    }
    
    private void init(int level, int pixel) {
<span class="fc" id="L121">        this.level_ = level;</span>
<span class="fc" id="L122">        this.pixel_ = pixel;</span>
<span class="fc" id="L123">        this.area_ = 0;</span>

<span class="fc" id="L125">        this.moments_ = new double[5];</span>

<span class="fc" id="L127">        this.variation_ = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L128">        this.stable_ = false;</span>

<span class="fc" id="L130">        this.parent_ = null;</span>
<span class="fc" id="L131">        this.child_ = null;</span>
<span class="fc" id="L132">        this.next_ = null;</span>
        
<span class="fc" id="L134">    }</span>

    public void accumulate(int x, int y) {
<span class="fc" id="L137">        ++area_;</span>
<span class="fc" id="L138">        moments_[0] += x;</span>
<span class="fc" id="L139">        moments_[1] += y;</span>
<span class="fc" id="L140">        moments_[2] += x * x;</span>
<span class="fc" id="L141">        moments_[3] += x * y;</span>
<span class="fc" id="L142">        moments_[4] += y * y;</span>
        
        // temporarily adding these to look at partial edges
<span class="fc" id="L145">        this.accX.add(x);</span>
<span class="fc" id="L146">        this.accY.add(y);</span>
<span class="fc" id="L147">    }</span>

    void merge(Region child) {
<span class="pc bpc" id="L150" title="3 of 4 branches missed.">        assert(child.parent_ == null);</span>
<span class="pc bpc" id="L151" title="3 of 4 branches missed.">        assert(child.next_ == null);</span>

        // Add the moments together
<span class="fc" id="L154">        area_ += child.area_;</span>
<span class="fc" id="L155">        moments_[0] += child.moments_[0];</span>
<span class="fc" id="L156">        moments_[1] += child.moments_[1];</span>
<span class="fc" id="L157">        moments_[2] += child.moments_[2];</span>
<span class="fc" id="L158">        moments_[3] += child.moments_[3];</span>
<span class="fc" id="L159">        moments_[4] += child.moments_[4];</span>
        
<span class="fc" id="L161">        this.accX.addAll(child.accX);</span>
<span class="fc" id="L162">        this.accY.addAll(child.accY);</span>
        
<span class="fc" id="L164">        child.next_ = child_;</span>
<span class="fc" id="L165">        child_ = child;</span>
<span class="fc" id="L166">        child.parent_ = this;</span>
<span class="fc" id="L167">    }</span>

    void detect(int delta, int minArea, int maxArea,
        double maxVariation, double minDiversity,
        List&lt;Region&gt; regions) {

<span class="fc" id="L173">        process(delta, minArea, maxArea, maxVariation);</span>

<span class="fc" id="L175">        save(minDiversity, regions);</span>
<span class="fc" id="L176">    }</span>

    private void process(int delta, int minArea, int maxArea,
        double maxVariation) {

        // Find the last parent with level not higher than level + delta
<span class="fc" id="L182">        Region parent = this;</span>

<span class="fc bfc" id="L184" title="All 4 branches covered.">        while (parent.parent_ != null</span>
            &amp;&amp; (parent.parent_.level_ &lt;= (level_ + delta))) {

<span class="fc" id="L187">            parent = parent.parent_;</span>
        }

        // Calculate variation
<span class="fc" id="L191">        variation_ = ((double)(parent.area_ - area_)) / (double)area_;</span>

        // Whether or not the region *could* be stable
<span class="fc bfc" id="L194" title="All 10 branches covered.">        boolean stable</span>
            = ((parent_ == null) || (variation_ &lt;= parent_.variation_))
            &amp;&amp; (area_ &gt;= minArea) &amp;&amp; (area_ &lt;= maxArea)
            &amp;&amp; (variation_ &lt;= maxVariation);

        // Process all the children
<span class="fc bfc" id="L200" title="All 2 branches covered.">        for (Region child = child_; child != null; child = child.next_) {</span>

<span class="fc" id="L202">            child.process(delta, minArea, maxArea, maxVariation);</span>

<span class="fc bfc" id="L204" title="All 4 branches covered.">            if (stable &amp;&amp; (variation_ &lt; child.variation_)) {</span>
<span class="fc" id="L205">                stable_ = true;</span>
            }
        }

        // The region can be stable even without any children
<span class="fc bfc" id="L210" title="All 4 branches covered.">        if ((child_ == null) &amp;&amp; stable) {</span>
<span class="fc" id="L211">            stable_ = true;</span>
        }
<span class="fc" id="L213">    }</span>

    private boolean check(double variation, int area) {

<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (area_ &lt;= area) {</span>
<span class="fc" id="L218">            return true;</span>
        }

<span class="fc bfc" id="L221" title="All 4 branches covered.">        if (stable_ &amp;&amp; (variation_ &lt; variation)) {</span>
<span class="fc" id="L222">            return false;</span>
        }

<span class="fc bfc" id="L225" title="All 2 branches covered.">        for (Region child = child_; child != null; child = child.next_) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (!child.check(variation, area)) {</span>
<span class="fc" id="L227">                return false;</span>
            }
        }

<span class="fc" id="L231">        return true;</span>
    }

    private void save(double minDiversity, List&lt;Region&gt; regions) {

<span class="fc" id="L236">        int minParentArea = 0;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (stable_) {</span>
<span class="fc" id="L238">            minParentArea = (int)(area_ / (1.0 - minDiversity) + 0.5);</span>
        }

<span class="fc" id="L241">        Region parent = this;</span>

<span class="fc bfc" id="L243" title="All 4 branches covered.">        while ((parent.parent_ != null)</span>
            &amp;&amp; (parent.parent_.area_ &lt; minParentArea)) {

<span class="fc" id="L246">            parent = parent.parent_;</span>

<span class="fc bfc" id="L248" title="All 4 branches covered.">            if (parent.stable_</span>
                &amp;&amp; (parent.variation_ &lt;= variation_)) {
<span class="fc" id="L250">                stable_ = false;</span>
<span class="fc" id="L251">                break;</span>
            }
        }

<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (stable_) {</span>
<span class="fc" id="L256">            int maxChildArea = (int)(area_ * (1.0 - minDiversity) + 0.5);</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">            if (!check(variation_, maxChildArea)) {</span>
<span class="fc" id="L259">                stable_ = false;</span>
            }
        }

<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (stable_) {</span>
<span class="fc" id="L264">            regions.add(this.copy());</span>
<span class="fc" id="L265">            Region last = regions.get(regions.size() - 1);</span>
<span class="fc" id="L266">            last.parent_ = null;</span>
<span class="fc" id="L267">            last.child_ = null;</span>
<span class="fc" id="L268">            last.next_ = null;</span>
        }

<span class="fc bfc" id="L271" title="All 2 branches covered.">        for (Region child = child_; child != null; child  = child.next_) {</span>
<span class="fc" id="L272">            child.save(minDiversity, regions);</span>
        }
<span class="fc" id="L274">    }</span>
    
    public static void drawEllipses(Image img, List&lt;List&lt;Region&gt;&gt; regions, int nExtraDot) {
        
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (regions.size() != 2) {</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(&quot;expecting the bright then&quot;</span>
                + &quot; dark msers in a list of size 2.&quot;);
        }
        
<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (int i = 0; i &lt; regions.get(0).size(); ++i) {</span>
<span class="fc" id="L284">            regions.get(0).get(i).drawEllipse(img, nExtraDot, </span>
                //127, 127, 127);
                255, 255, 255);
        }
        
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (int i = 0; i &lt; regions.get(1).size(); ++i) {</span>
<span class="fc" id="L290">            regions.get(1).get(i).drawEllipse(img, nExtraDot, </span>
                255, 255, 255);
        }
<span class="fc" id="L293">    }</span>
    
    /**
     * calculate the x,y centroid of the pixels within
     * this region.
     * @param imageWidth
     * @param imageHeight
     * @param outputXY 
     */
    public void calculateXYCentroid(int[] outputXY, int imageWidth, int imageHeight) {
                    
<span class="fc" id="L304">        outputXY[0] = (int)Math.round(moments_[0]/(double)area_);</span>
<span class="fc" id="L305">        outputXY[1] = (int)Math.round(moments_[1]/(double)area_);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (outputXY[0] == -1) {</span>
<span class="nc" id="L307">            outputXY[0] = 0;</span>
        }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (outputXY[1] == -1) {</span>
<span class="nc" id="L310">            outputXY[1] = 0;</span>
        }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (outputXY[0] == imageWidth) {</span>
<span class="nc" id="L313">            outputXY[0] = imageWidth - 1;</span>
        }
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">        if (outputXY[1] == imageHeight) {</span>
<span class="nc" id="L316">            outputXY[1] = imageHeight - 1;</span>
        }
<span class="fc" id="L318">    }</span>
    
    /**
     * calculate the intensity weighted centroid of the pixels within
     * this region.
     * @param greyscale
     * @param imageWidth
     * @param imageHeight
     * @param outputXY 
     */
    void calculateIntensityCentroid(int[] greyscale, int imageWidth, 
        int imageHeight, int[] outputXY) {
        
<span class="nc" id="L331">        TrioInt[] yXRanges = getEllipseRange(imageWidth, imageHeight);</span>
        
<span class="nc" id="L333">        double iSum = 0;</span>
        
<span class="nc" id="L335">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L337" title="All 2 branches missed.">        for (TrioInt yXminMax : yXRanges) {</span>
<span class="nc" id="L338">            int y = yXminMax.getX();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            for (int x = yXminMax.getY(); x &lt;= yXminMax.getZ(); ++x) {</span>
<span class="nc" id="L340">                PairInt p = new PairInt(x, y);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                if (visited.contains(p)) {</span>
<span class="nc" id="L342">                    continue;</span>
                }
<span class="nc" id="L344">                visited.add(p);</span>
<span class="nc" id="L345">                int idx = (y * imageWidth) + x;</span>
<span class="nc" id="L346">                int intensity = greyscale[idx];</span>
<span class="nc" id="L347">                iSum += intensity;</span>
            }
        }
        
<span class="nc" id="L351">        double xSum = 0;</span>
<span class="nc" id="L352">        double ySum = 0;</span>
        
        // for debugging only, assert sum of weights
<span class="nc" id="L355">        double wSum = 0;</span>
        
<span class="nc" id="L357">        visited.clear();</span>
        
<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (TrioInt yXminMax : yXRanges) {</span>
            
<span class="nc" id="L361">            int y = yXminMax.getX();</span>
            
<span class="nc bnc" id="L363" title="All 2 branches missed.">            for (int x = yXminMax.getY(); x &lt;= yXminMax.getZ(); ++x) {</span>
                
<span class="nc" id="L365">                PairInt p = new PairInt(x, y);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                if (visited.contains(p)) {</span>
<span class="nc" id="L367">                    continue;</span>
                }
<span class="nc" id="L369">                visited.add(p);</span>
                
<span class="nc" id="L371">                int idx = (y * imageWidth) + x;</span>
                
<span class="nc" id="L373">                double intensity = greyscale[idx];</span>
<span class="nc" id="L374">                double w = (intensity/iSum);</span>
                
<span class="nc" id="L376">                xSum += (x * w);</span>
<span class="nc" id="L377">                ySum += (y * w);</span>
                
<span class="nc" id="L379">                wSum += w;</span>
            }
        }
<span class="nc bnc" id="L382" title="All 4 branches missed.">        assert(Math.abs(wSum - 1) &lt; 0.01);</span>
                
<span class="nc" id="L384">        outputXY[0] = (int)Math.round(xSum);</span>
<span class="nc" id="L385">        outputXY[1] = (int)Math.round(ySum);</span>
<span class="nc" id="L386">    }</span>
    
    /**
     * calculate the intensity weighted centroid of pixels within
     * radius distance of center of region.
     * 
     * @param greyscale
     * @param imageWidth
     * @param imageHeight
     * @param outputXY
     * @param radius 
     */
    void calculateIntensityCentroid(int[] greyscale, int imageWidth, 
        int imageHeight, int[] outputXY, int radius) {
      
<span class="nc" id="L401">        int xC = (int)Math.round(moments_[0]/(double)area_);</span>
<span class="nc" id="L402">        int yC = (int)Math.round(moments_[1]/(double)area_);</span>
        
        //v0x, v1x, v0y, v1y
<span class="nc" id="L405">        double[] m = calcParamTransCoeff();</span>
        
        // semi-major and semi-minor axes:
<span class="nc" id="L408">        double major = 2. * m[4];</span>
<span class="nc" id="L409">        double minor = 2. * m[5];</span>
            
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (radius &gt; major) {</span>
<span class="nc" id="L412">            radius = (int)major; </span>
        }
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (radius &gt; minor) {</span>
<span class="nc" id="L415">            radius = (int)minor; </span>
        }
        
<span class="nc" id="L418">        int yStart = yC - radius;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (yStart &lt; 0) {</span>
<span class="nc" id="L420">            yStart = 0;</span>
        }
<span class="nc" id="L422">        int yStop = yC + radius;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (yStop &gt;= imageHeight) {</span>
<span class="nc" id="L424">            yStop = imageHeight - 1;</span>
        }
        
        /*
        x^2 + y^2 = radius^2
        x^2 =  radius^2 - y^2
        (x - xC) = sqrt(radius^2 - (y - yc)^2)
        */
<span class="nc" id="L432">        double rSq = radius * radius;</span>
        
<span class="nc" id="L434">        double iSum = 0;</span>
        
        // for uniqueness
<span class="nc" id="L437">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
        
<span class="nc bnc" id="L439" title="All 2 branches missed.">        for (int y = yStart; y &lt;= yStop; ++y) {</span>
            
<span class="nc" id="L441">            double ySq = y - yC;</span>
<span class="nc" id="L442">            ySq *= ySq;</span>
            
<span class="nc" id="L444">            double xH = Math.sqrt(rSq - ySq);</span>
            
<span class="nc" id="L446">            int xStart = (int)Math.round(xC - xH);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (xStart &lt; 0) {</span>
<span class="nc" id="L448">                xStart = 0;</span>
            }
<span class="nc" id="L450">            int xStop = (int)Math.round(xC + xH);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (xStop &gt;= imageWidth) {</span>
<span class="nc" id="L452">                xStop = imageWidth - 1;</span>
            }
            
<span class="nc bnc" id="L455" title="All 2 branches missed.">            for (int x = xStart; x &lt;= xStop; ++x) {</span>
                
<span class="nc" id="L457">                PairInt p = new PairInt(x, y);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (visited.contains(p)) {</span>
<span class="nc" id="L459">                    continue;</span>
                }
<span class="nc" id="L461">                visited.add(p);</span>
                
<span class="nc" id="L463">                int idx = (y * imageWidth) + x;</span>
<span class="nc" id="L464">                iSum += greyscale[idx];</span>
            }
        }
        
<span class="nc" id="L468">        double xSum = 0;</span>
<span class="nc" id="L469">        double ySum = 0;</span>
        
        // for debugging only, assert sum of weights
<span class="nc" id="L472">        double wSum = 0;</span>
        
<span class="nc" id="L474">        visited.clear();</span>
        
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (int y = yStart; y &lt;= yStop; ++y) {</span>
            
<span class="nc" id="L478">            double ySq = y - yC;</span>
<span class="nc" id="L479">            ySq *= ySq;</span>
            
<span class="nc" id="L481">            double xH = Math.sqrt(rSq - ySq);</span>
            
<span class="nc" id="L483">            int xStart = (int)Math.round(xC - xH);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (xStart &lt; 0) {</span>
<span class="nc" id="L485">                xStart = 0;</span>
            }
<span class="nc" id="L487">            int xStop = (int)Math.round(xC + xH);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            if (xStop &gt;= imageWidth) {</span>
<span class="nc" id="L489">                xStop = imageWidth - 1;</span>
            }
            
<span class="nc bnc" id="L492" title="All 2 branches missed.">            for (int x = xStart; x &lt;= xStop; ++x) {</span>
                
<span class="nc" id="L494">                PairInt p = new PairInt(x, y);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                if (visited.contains(p)) {</span>
<span class="nc" id="L496">                    continue;</span>
                }
<span class="nc" id="L498">                visited.add(p);</span>
                
<span class="nc" id="L500">                int idx = (y * imageWidth) + x;</span>
<span class="nc" id="L501">                double intensity = greyscale[idx];</span>
<span class="nc" id="L502">                double w = (intensity/iSum);</span>
                
<span class="nc" id="L504">                xSum += (x * w);</span>
<span class="nc" id="L505">                ySum += (y * w);</span>
                
<span class="nc" id="L507">                wSum += w;</span>
            }
        }
<span class="nc bnc" id="L510" title="All 4 branches missed.">        assert(Math.abs(wSum - 1) &lt; 0.01);</span>
                
<span class="nc" id="L512">        outputXY[0] = (int)Math.round(xSum);</span>
<span class="nc" id="L513">        outputXY[1] = (int)Math.round(ySum);</span>
<span class="nc" id="L514">    }</span>
    
    /**
     * using the region moments and area, calculates parameters needed
     * for a bounding ellipse.
     * 
       The equation for rotation of an ellipse by angle alpha:
        x(t) = xCenter + aParam*cos(alpha)*cos(t) − bParam*sin(alpha)*sin(t)
        y(t) = yCenter + aParam*sin(alpha)*cos(t) + bParam*cos(alpha)*sin(t)
        
        returns 
        v0x = aParam * cos(alpha);
        v1x = bParam * sin(alpha);
        v0y = aParam * sin(alpha);
        v1y = bParam * cos(alpha);
        e0 = first eigenvalue
        e1 = 2nd eigenvalue
     * @return 
     */
    public double[] calcParamTransCoeff() {
        
        /*
        moments_[0]  x;
        moments_[1]  y;
        moments_[2]  x * x;
        moments_[3]  x * y;
        moments_[4]  y * y;
        */
        
        // Centroid (mean)
<span class="fc" id="L544">        double x = moments_[0] / (double)area_;</span>
<span class="fc" id="L545">        double y = moments_[1] / (double)area_;</span>
        
        // a*x^2 + b*x*y + c*y^2 + d*x + e*y + f = 0
        
        // Covariance matrix [a b; b c]
<span class="fc" id="L550">        double a = moments_[2] / (double)area_ - x * x;</span>
<span class="fc" id="L551">        double b = moments_[3] / (double)area_ - x * y;</span>
<span class="fc" id="L552">        double c = moments_[4] / (double)area_ - y * y;</span>

        /*
        
        covariance matrix as a real 2X2 matrix 
        xx  xy
        yx  yy
        
        from Strang &quot;Linear Algebra&quot;, chap 10, have for real 2X2 matrix:
        
        | xx-eigenv   xy        |
        | yx          yy-eigenv | = eigenv^2 - (xx + yy)*eigenv 
                                      + ((xx yy) - (yx xy)) = 0 
        
        can solve for the zeroes with quardratic equation to
        get 2 eigenvalues:
        
        eigenv = (xx + yy +- sqrt( (xx + yy)^2 -4*(xx yy - xy yx) )) / 2
               = (d +- sqrt(d*d - 4*b*b))/2
        
        Looks like Dubout below uses orthogonal axes, replacing
        (xx, yy) with (yy, -xx).
        */
        // Eigenvalues of the covariance matrix
<span class="fc" id="L576">        double d  = a + c; // xx + yy</span>
<span class="fc" id="L577">        double e  = a - c; // xx - yy</span>
<span class="fc" id="L578">        double f  = Math.sqrt(4.0 * b * b + e * e);</span>
<span class="fc" id="L579">        double e0 = (d + f) / 2.0; // First eigenvalue</span>
<span class="fc" id="L580">        double e1 = (d - f) / 2.0; // Second eigenvalue</span>

        // Desired norm of the eigenvectors
<span class="fc" id="L583">        double e0sq = Math.sqrt(e0);</span>
<span class="fc" id="L584">        double e1sq = Math.sqrt(e1);</span>
 
        // Eigenvectors
<span class="fc" id="L587">        double v0x = e0sq;</span>
<span class="fc" id="L588">        double v0y = 0.0;</span>
<span class="fc" id="L589">        double v1x = 0.0;</span>
<span class="fc" id="L590">        double v1y = e1sq;</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (b != 0.) {</span>
<span class="fc" id="L593">            v0x = e0 - c;</span>
<span class="fc" id="L594">            v0y = b;</span>
<span class="fc" id="L595">            v1x = e1 - c;</span>
<span class="fc" id="L596">            v1y = b;</span>

            // Normalize the eigenvectors
<span class="fc" id="L599">            double n0 = e0sq / Math.sqrt(v0x * v0x + v0y * v0y);</span>
<span class="fc" id="L600">            v0x *= n0;</span>
<span class="fc" id="L601">            v0y *= n0;</span>

<span class="fc" id="L603">            double n1 = e1sq / Math.sqrt(v1x * v1x + v1y * v1y);</span>
<span class="fc" id="L604">            v1x *= n1;</span>
<span class="fc" id="L605">            v1y *= n1;</span>
        }
        
        /*
        rotation transformed ellipse:
        
        x(t) = xCenter + aParam*cos(alpha)*cos(t) − bParam*sin(alpha)*sin(t)
        y(t) = yCenter + aParam*sin(alpha)*cos(t) + bParam*cos(alpha)*sin(t)
        
        v0x = aParam * cos(alpha);  alpha = atan(v0x/v0y)
        v1x = bParam * sin(alpha);
        v0y = aParam * sin(alpha);
        v1y = bParam * cos(alpha);
        
        so the semi-major axis length = 2 * Math.max(v0x, v1x)
        
        and the semi-minor axis length = 2 * Math.min(v0y, v1y)
        */
        
<span class="fc" id="L624">        return new double[]{v0x, v1x, v0y, v1y, e0sq, e1sq};</span>
    }
    
    /**
     * following the creation of an ellipse from the moments and
     * area (see drawEllipse), this method orders the ellipse points by
     * y, then x then aggregates the x to form the range xmin, xmax
     * per row of y.  The return is the ranges ordered by increasing
     * y in formation [y, xmin for row y, xmax for row y]
     * @return 
     */
    public TrioInt[] getEllipseRange(int imageWidth, int imageHeight) {
        
<span class="nc" id="L637">        TIntList xs = new TIntArrayList();</span>
<span class="nc" id="L638">        TIntList ys = new TIntArrayList();</span>
    
        // Centroid (mean)
<span class="nc" id="L641">        double x = moments_[0] / (double)area_;</span>
<span class="nc" id="L642">        double y = moments_[1] / (double)area_;</span>
        
        //v0x, v1x, v0y, v1y
<span class="nc" id="L645">        double[] coeffs = calcParamTransCoeff();</span>
        
<span class="nc" id="L647">        double v0x = coeffs[0];</span>
<span class="nc" id="L648">        double v1x = coeffs[1];</span>
<span class="nc" id="L649">        double v0y = coeffs[2];</span>
<span class="nc" id="L650">        double v1y = coeffs[3];</span>

<span class="nc" id="L652">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>

<span class="nc bnc" id="L654" title="All 2 branches missed.">        for (double t = 0.0; t &lt; 2.0 * Math.PI; t += 0.001) {</span>
            
<span class="nc" id="L656">            double mc = Math.cos(t);</span>
<span class="nc" id="L657">            double ms = Math.sin(t);</span>
            
<span class="nc" id="L659">            int x2 = (int)Math.round(x + </span>
                (mc * v0x + ms * v1x) * 2.0 + 0.5);
<span class="nc" id="L661">            int y2 = (int)Math.round(y + (mc * v0y </span>
                + ms * v1y) * 2.0 + 0.5);

<span class="nc bnc" id="L664" title="All 8 branches missed.">            if ((x2 &gt;= 0) &amp;&amp; (x2 &lt; imageWidth) </span>
                &amp;&amp; (y2 &gt;= 0) &amp;&amp; (y2 &lt; imageHeight)) {
                
<span class="nc" id="L667">                PairInt pt = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if (visited.contains(pt)) {</span>
<span class="nc" id="L669">                    continue;</span>
                }
<span class="nc" id="L671">                visited.add(pt);</span>
                
<span class="nc" id="L673">                xs.add(x2);</span>
<span class="nc" id="L674">                ys.add(y2);</span>
            }
        }
        
<span class="nc" id="L678">        int[] x2s = xs.toArray(new int[xs.size()]);</span>
<span class="nc" id="L679">        int[] y2s = ys.toArray(new int[xs.size()]);</span>
        
<span class="nc" id="L681">        QuickSort.sortBy1stThen2nd(y2s, x2s);</span>
        
<span class="nc" id="L683">        int n = (new TIntHashSet(ys)).size();</span>
        
<span class="nc" id="L685">        TrioInt[] output = new TrioInt[n];</span>
<span class="nc" id="L686">        int count = 0;</span>
<span class="nc" id="L687">        int idx = 0;</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        for (idx = 0; idx &lt; x2s.length; ++idx) {</span>
<span class="nc" id="L689">            int yC = y2s[idx];</span>
<span class="nc" id="L690">            int minX = Integer.MAX_VALUE;</span>
<span class="nc" id="L691">            int maxX = Integer.MIN_VALUE;</span>
<span class="nc" id="L692">            int idx2 = idx;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            for (idx2 = idx; idx2 &lt; x2s.length; ++idx2) {</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                if (y2s[idx2] &gt; yC) {</span>
<span class="nc" id="L695">                    idx2--;</span>
<span class="nc" id="L696">                    break;</span>
                }
<span class="nc bnc" id="L698" title="All 2 branches missed.">                if (minX == Integer.MAX_VALUE) {</span>
<span class="nc" id="L699">                    minX = x2s[idx2];</span>
                }
<span class="nc" id="L701">                maxX = x2s[idx2];</span>
            }
<span class="nc" id="L703">            idx = idx2;</span>
<span class="nc" id="L704">            output[count] = new TrioInt(yC, minX, maxX);</span>
<span class="nc" id="L705">            count++;</span>
        }
<span class="nc bnc" id="L707" title="All 4 branches missed.">        assert(count == n);</span>
        
<span class="nc" id="L709">        return output;</span>
    }
    
    public void drawEllipse(Image img, int nExtraDot,
        int rClr, int gClr, int bClr) {

        // Centroid (mean)
<span class="fc" id="L716">        double x = moments_[0] / (double)area_;</span>
<span class="fc" id="L717">        double y = moments_[1] / (double)area_;</span>
        
        //v0x, v1x, v0y, v1y
<span class="fc" id="L720">        double[] coeffs = calcParamTransCoeff();</span>
        
<span class="fc" id="L722">        double v0x = coeffs[0];</span>
<span class="fc" id="L723">        double v1x = coeffs[1];</span>
<span class="fc" id="L724">        double v0y = coeffs[2];</span>
<span class="fc" id="L725">        double v1y = coeffs[3];</span>
        
<span class="fc bfc" id="L727" title="All 2 branches covered.">        for (double t = 0.0; t &lt; 2.0 * Math.PI; t += 0.001) {</span>
            
<span class="fc" id="L729">            double mc = Math.cos(t);</span>
<span class="fc" id="L730">            double ms = Math.sin(t);</span>
            
<span class="fc" id="L732">            int x2 = (int)Math.round(x + (mc * v0x + ms * v1x) * 2.0 + 0.5);</span>
<span class="fc" id="L733">            int y2 = (int)Math.round(y + (mc * v0y + ms * v1y) * 2.0 + 0.5);</span>

<span class="fc bfc" id="L735" title="All 6 branches covered.">            if ((x2 &gt;= 0) &amp;&amp; (x2 &lt; img.getWidth()) </span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">                &amp;&amp; (y2 &gt;= 0) &amp;&amp; (y2 &lt; img.getHeight())) {</span>
                
<span class="fc" id="L738">                ImageIOHelper.addPointToImage(x2, y2, img, </span>
                    nExtraDot, rClr, gClr, bClr);
            }
        }
<span class="fc" id="L742">    }</span>

    public void drawCircle(Image img, int nExtraDot,
        int rClr, int gClr, int bClr) {

        // Centroid (mean)
<span class="nc" id="L748">        double x = moments_[0] / (double)area_;</span>
<span class="nc" id="L749">        double y = moments_[1] / (double)area_;</span>
        
        //v0x, v1x, v0y, v1y
<span class="nc" id="L752">        double[] m = calcParamTransCoeff();</span>
        
<span class="nc" id="L754">        double major = 2. * m[4];</span>
<span class="nc" id="L755">        double minor = 2. * m[5];</span>
<span class="nc" id="L756">        double radius = minor;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (radius &lt; 4) {</span>
<span class="nc" id="L758">            radius = 4;</span>
        }
            
<span class="nc bnc" id="L761" title="All 2 branches missed.">        for (double t = 0.0; t &lt; 2.0 * Math.PI; t += 0.001) {</span>
            
<span class="nc" id="L763">            double mc = Math.cos(t);</span>
<span class="nc" id="L764">            double ms = Math.sin(t);</span>
            
<span class="nc" id="L766">            int x2 = (int)Math.round(x + (mc * radius));</span>
<span class="nc" id="L767">            int y2 = (int)Math.round(y + (ms * radius));</span>

<span class="nc bnc" id="L769" title="All 6 branches missed.">            if ((x2 &gt;= 0) &amp;&amp; (x2 &lt; img.getWidth()) </span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                &amp;&amp; (y2 &gt;= 0) &amp;&amp; (y2 &lt; img.getHeight())) {</span>
                
<span class="nc" id="L772">                ImageIOHelper.addPointToImage(x2, y2, img, </span>
                    nExtraDot, rClr, gClr, bClr);
            }
        }
<span class="nc" id="L776">    }</span>
    
    public Region copy() {
<span class="fc" id="L779">        Region region = new Region(this.level_, this.pixel_);</span>
<span class="fc" id="L780">        region.area_ = this.area_;</span>
<span class="fc" id="L781">        System.arraycopy(moments_, 0,region. moments_, 0, moments_.length);</span>
<span class="fc" id="L782">        region.variation_ = this.variation_;</span>
<span class="fc" id="L783">        region.stable_ = this.stable_;</span>
<span class="fc" id="L784">        region.parent_ = this.parent_;</span>
<span class="fc" id="L785">        region.child_ = this.child_;</span>
<span class="fc" id="L786">        region.next_ = this.next_;</span>
<span class="fc" id="L787">        region.accX.addAll(this.accX);</span>
<span class="fc" id="L788">        region.accY.addAll(this.accY);</span>
        
<span class="fc" id="L790">        return region;</span>
    }
    
    @Override
    public String toString() {
<span class="nc" id="L795">        StringBuilder sb = new StringBuilder(&quot;&quot;);</span>
<span class="nc" id="L796">        sb.append(&quot;  level_=&quot;).append(level_);</span>
<span class="nc" id="L797">        sb.append(&quot;\n  pixel_=&quot;).append(pixel_);</span>
<span class="nc" id="L798">        sb.append(&quot;\n  area_=&quot;).append(area_);</span>
<span class="nc" id="L799">        sb.append(&quot; moments_=&quot;).append(Arrays.toString(moments_));</span>
<span class="nc" id="L800">        sb.append(&quot; variation_=&quot;).append(variation_);</span>
<span class="nc" id="L801">        sb.append(&quot; stable=&quot;).append(stable_);</span>
<span class="nc" id="L802">        sb.append(&quot;\n  (x,y)=&quot;);</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">        for (int i = 0; i &lt; accX.size(); ++i) {</span>
<span class="nc" id="L804">            sb.append(accX.get(i)).append(&quot;,&quot;).append(accY.get(i)).append(&quot; &quot;);</span>
        }
<span class="nc" id="L806">        sb.append(&quot;\n  children=&quot;);</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">        for (Region child = child_; child != null; child = child.next_) {</span>
<span class="nc" id="L808">            toStringChildren(child, &quot;   &quot;);</span>
        }
<span class="nc" id="L810">        sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L811">        return sb.toString();</span>
    }
   
    private String toStringChildren(Region c, String indent) {
<span class="nc" id="L815">        StringBuilder sb = new StringBuilder(&quot;&quot;);</span>
<span class="nc" id="L816">        sb.append(indent).append(&quot;pixel=&quot;).append(c.pixel_)</span>
<span class="nc" id="L817">            .append(&quot;level=&quot;).append(c.level_);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">        for (Region child = c.child_; child != null; child = child.child_) {</span>
<span class="nc" id="L819">            toStringChildren(child, indent + &quot;  &quot;);</span>
        }
<span class="nc" id="L821">        sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L822">        return sb.toString();</span>
    }
    
   
    public Set&lt;PairInt&gt; getAcc() {
<span class="nc" id="L827">        Set&lt;PairInt&gt; out = new HashSet&lt;PairInt&gt;();</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        for (int i = 0; i &lt; accX.size(); ++i) {</span>
<span class="nc" id="L829">            out.add(new PairInt(accX.get(i), accY.get(i)));</span>
        }
<span class="nc" id="L831">        return out;</span>
    }
    
    public TIntSet getAcc(int imgWidth) {
        
<span class="fc" id="L836">        TIntSet out = new TIntHashSet();</span>
        
<span class="fc bfc" id="L838" title="All 2 branches covered.">        for (int i = 0; i &lt; accX.size(); ++i) {</span>
<span class="fc" id="L839">            int pixIdx = (accY.get(i) * imgWidth) + accX.get(i);</span>
<span class="fc" id="L840">            out.add(pixIdx);</span>
        }
        
<span class="fc" id="L843">        return out;</span>
    }
    
    /*
    public int level_;
    double variation_;
    
    int pixel_;
    int area_;
    double[] moments_; //(x, y, x^2, xy, y^2)
   */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        if (!(obj instanceof Region)) {</span>
<span class="nc" id="L857">            return false;</span>
        }
<span class="fc" id="L859">        Region other = (Region)obj;</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">        if (other.area_ != area_) {</span>
<span class="nc" id="L861">            return false;</span>
        }
<span class="fc" id="L863">        double eps = 0.1;</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (int i = 0; i &lt; moments_.length; ++i) {</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">            if (Math.abs(moments_[i] - other.moments_[i]) &gt; eps) {</span>
<span class="nc" id="L866">                return false;</span>
            }
        }
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">        if (pixel_ != other.pixel_) {</span>
<span class="nc" id="L870">            return false;</span>
        }
<span class="fc" id="L872">        return true;</span>
    }
    
    @Override
    public int hashCode() {
        
<span class="fc" id="L878">        int hash = fnvHashCode();</span>

<span class="fc" id="L880">        return hash;</span>
    }

<span class="fc" id="L883">    protected static int fnv321aInit = 0x811c9dc5;</span>
<span class="fc" id="L884">    protected static int fnv32Prime = 0x01000193;</span>

    protected int fnvHashCode() {

        /*
         * hash = offset_basis
         * for each octet_of_data to be hashed
         *     hash = hash xor octet_of_data
         *     hash = hash * FNV_prime
         * return hash
         *
         * Public domain:  http://www.isthe.com/chongo/src/fnv/hash_32a.c
         */
<span class="fc" id="L897">        int mask = (1 &lt;&lt; 31) - 1;</span>
<span class="fc" id="L898">        int shift = 32;</span>
<span class="fc" id="L899">        int sum = fnv321aInit;</span>
        long b0, b1;
        
<span class="fc" id="L902">        sum ^= pixel_;</span>
<span class="fc" id="L903">        sum *= fnv32Prime;</span>
<span class="fc" id="L904">        sum ^= area_;</span>
<span class="fc" id="L905">        sum *= fnv32Prime;</span>
        
<span class="fc bfc" id="L907" title="All 2 branches covered.">        for (int i = 0; i &lt; moments_.length; ++i) {</span>
<span class="fc" id="L908">            long a = Double.doubleToLongBits(moments_[i]); </span>
<span class="fc" id="L909">            b0 = a &amp; mask;</span>
<span class="fc" id="L910">            b1 = (a &gt;&gt; shift) &amp; mask;</span>
            
            // xor the bottom with the current octet.
<span class="fc" id="L913">            sum ^= b0;</span>
            // multiply by the 32 bit FNV magic prime mod 2^32
<span class="fc" id="L915">            sum *= fnv32Prime;</span>
            
<span class="fc" id="L917">            sum ^= b1;</span>
<span class="fc" id="L918">            sum *= fnv32Prime;</span>
        }
        
<span class="fc" id="L921">        return sum;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MSER.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.features.mser</a> &gt; <span class="el_source">MSER.java</span></div><h1>MSER.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.features.mser;

import algorithms.imageProcessing.GreyscaleImage;
import algorithms.VeryLongBitString;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import java.util.ArrayList;
import java.util.List;

/**
MSER.java and Region.java are java ports of the C++ MSER
implementation of MSER by Charles Dubout, charles.dubout@idiap.ch,
downloaded from https://github.com/idiap/mser
His C++ code is an implementation of  
&quot;Linear Time Maximally Stable Extremal Regions&quot;,
by D. Nistér and H. Stewénius, ECCV 2008.

...&quot;MSER is a blob detector [...that] extracts stable connected regions 
of some level sets from an image, and optionally fits ellipses to them&quot;

The C++ code has copyright:
--------------------------
GNU GENERAL PUBLIC LICENSE, Version 3

Copyright (c) 2011 Idiap Research Institute, http://www.idiap.ch/.
Written by Charles Dubout charles.dubout@idiap.ch.

MSER is free software: you can redistribute it and/or modify it under the terms of the GNU
General Public License version 3 as published by the Free Software Foundation.
 MSER is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.

You should have received a copy of the GNU General Public License along with MSER. If not, see
http://www.gnu.org/licenses/.
--------------------------

Linear time Maximally Stable Extremal Regions (MSER) implementation as described
in D. Nistér and H. Stewénius, &quot;Linear Time Maximally Stable Extremal Regions&quot;,
ECCV 2008.

MSER was originally described by  Matas el al 2002, &quot;Robust wide baseline stereo from
maximally stable extremal regions.&quot;,  British Machine Vision Conference, pp.  384–393

The MSER class extracts maximally stable extremal regions
from a grayscale (8 bits) image.
note The MSER class is not reentrant, so if you want to
extract regions in parallel, each
thread needs to have its own MSER class instance.
* 
* The java port of the C++ code just quoted is from this project is
* by Nichole King.
* 
* ---------
* details of the Nistér and H. Stewénius version of the MSER algorithm.
* 
* The authors use a flood fill style 
* traversal rather than a watershed (watershed is the pattern used by
* the original MSER authors, Matas et al.) to result in fewer computations and
* a shorter stack (max size being 256 rather than nPixels, excepting the 
* input itself).
* From any starting pixel, a region is created and the adjacent pixels are explored.
* Any adjacent pixel with a lower intensity gets immediate priority in processing
* while the current gets put onto a queue.
* No pixels are processed more than once and the exploration stops when
* the greyscale level increases to pass the maximum value of 255.
* 
* processing involves comparison of an accumulated region to 
* it's parent and child where the comparison is the fractional 
* difference in the areas (to determine whether the current
* region is a minimum in a small sample of the growth rate).
* 
* The worse case runtime complexity is
      O((n + e) log(m))
      where n is the number of pixels, 
      m the number of grey-levels == 256, 
      and e is the number of edges in the image graph 
      (where e ≈ 2n for four-connected images). 

* ------
* nichole king ported the C++ code of Charles Dubout to java 
* and added the use of bit vectors as 
* recommended by Nister and Stewénius.
* recently added the accumulated points also at the cost of space complexity
* in order for other classes to use the Regions for patch matching and edges.
*/
public class MSER {

    private int delta_;
    private double minArea_;
    private double maxArea_;
    private double maxVariation_;
    private double minDiversity_;
    private boolean eight_;
    
<span class="fc" id="L96">    private List&lt;Region&gt; regionStack = new ArrayList&lt;Region&gt;();</span>

    /**
    constructor w/ the following default values:
    param[in] delta DELTA parameter of the MSER algorithm.
               Roughly speaking, the stability of a
	       region is the relative variation of the region
               area when the intensity is changed by delta.
               (default delta = 2.0)
    param[in] minArea Minimum area of any stable region
               relative to the image domain area.
               (default minArea = 0.0001)
    param[in] maxArea Maximum area of any stable region
               relative to the image domain area.
               (default maxArea = 0.5)
    param[in] maxVariation Maximum variation (absolute
               stability score) of the regions.
               (default maxVariation = 0.5)
    param[in] minDiversity Minimum diversity of the regions.
               When the relative area of two
     	       nested regions is below this threshold,
               then only the most stable one is selected.
               (default minDiversity = 0.33)
    param[in] eight Use 8-connected pixels instead of 4-connected.
               (default eight = false).
    */
<span class="fc" id="L122">    public MSER() {</span>

<span class="fc" id="L124">        int delta = 2;</span>
<span class="fc" id="L125">        double minArea = 0.0001;</span>
<span class="fc" id="L126">        double maxArea = 0.5;</span>
<span class="fc" id="L127">        double maxVariation = 0.5;</span>
<span class="fc" id="L128">        double minDiversity = 0.33;</span>
<span class="fc" id="L129">        boolean eight = false;</span>

<span class="fc" id="L131">        init(delta, minArea, maxArea, maxVariation, minDiversity, eight);</span>
<span class="fc" id="L132">    }</span>

    /**
    @param delta DELTA parameter of the MSER algorithm.
               Roughly speaking, the stability of a
	       region is the relative variation of the region
               area when the intensity is changed by delta.
               (default delta = 2.0)
    @param minArea Minimum area of any stable region
               relative to the image domain area.
               (double minArea = 0.0001)
    @param maxArea Maximum area of any stable region
               relative to the image domain area.
               (double maxArea = 0.5)
    @param maxVariation Maximum variation (absolute
               stability score) of the regions.
               (double maxVariation = 0.5)
    @param minDiversity Minimum diversity of the regions.
               When the relative area of two
	       nested regions is below this threshold,
               then only the most stable one is selected.
               (double minDiversity = 0.33)
    @param eight Use 8-connected pixels instead of 4-connected.
    */
    public MSER(int delta, double minArea, double maxArea,
<span class="fc" id="L157">        double maxVariation, double minDiversity, boolean eight) {</span>

<span class="fc" id="L159">        init(delta, minArea, maxArea, maxVariation, minDiversity, eight);</span>
<span class="fc" id="L160">    }</span>

    private void init(int delta, double minArea, double maxArea,
        double maxVariation, double minDiversity,
        boolean eight) {

<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (delta &lt;= 0) {</span>
<span class="nc" id="L167">            throw new IllegalArgumentException(&quot;delta must be &gt; 0&quot;);</span>
        }
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (minArea &lt; 0.0) {</span>
<span class="nc" id="L170">            throw new IllegalArgumentException(&quot;minArea must be &gt;= 0&quot;);</span>
        }
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (maxArea &gt; 1.0) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;maxArea must be &lt;= 1&quot;);</span>
        }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (minArea &gt;= maxArea) {</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(&quot;minArea must be &lt; maxArea&quot;);</span>
        }
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (maxVariation &lt;= 0.0) {</span>
<span class="nc" id="L179">            throw new IllegalArgumentException(&quot;maxVariation must be &gt; 0&quot;);</span>
        }
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (minDiversity &lt; 0.0) {</span>
<span class="nc" id="L182">            throw new IllegalArgumentException(&quot;minDiversity must be &lt; 0&quot;);</span>
        }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (minDiversity &gt;= 1) {</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;minDiversity must be &lt; 1&quot;);</span>
        }
        
<span class="fc" id="L188">        this.eight_ = eight;</span>
<span class="fc" id="L189">        this.delta_ = delta;</span>
<span class="fc" id="L190">        this.minArea_ = minArea;</span>
<span class="fc" id="L191">        this.maxArea_ = maxArea;</span>
<span class="fc" id="L192">        this.maxVariation_ = maxVariation;</span>
<span class="fc" id="L193">        this.minDiversity_ = minDiversity;</span>
<span class="fc" id="L194">    }</span>

    /**
      Extracts maximally stable extremal regions from a
      greyscale (8 bits) image.
      @param bits array of 8 bit greyscale image values.  the maximum size
      of the array is currently 2^27 -1, due to
      internal data structures and encoding, but this may change.
          
      @param width input Width of the image.
      @param height input Height of the image.
      @param regions output Detected MSER.
    */
    public void operator(int[] bits, int width, int height,
        List&lt;Region&gt; regions) {

<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (bits.length &gt; ((1 &lt;&lt; 27) - 1)) {</span>
            
<span class="nc" id="L212">            throw new IllegalArgumentException(&quot;bits.length must be less than &quot;</span>
                + &quot; 2^27 currently.  just need to edit a variable to&quot;
                + &quot; use long instead.  upper limit to bits.length would then&quot;
                + &quot; be 31 bits - 1, limited by java language array length limit&quot;);
        }
        
        // 1. Clear the accessible pixel mask,
        //    the heap of boundary pixels and
        //    the component stack. Push
        //    a dummy-component onto the stack, with grey-level
        //    higher than any allowed in the image.
<span class="fc" id="L223">        VeryLongBitString accessible = new VeryLongBitString(width * height);</span>
        
        // priority queue of boundary pixels, priority = -greylevel
<span class="fc" id="L226">        TIntList[] boundaryPixels = new TIntArrayList[256];</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (int i = 0; i &lt; 256; ++i) {</span>
<span class="fc" id="L228">            boundaryPixels[i] = new TIntArrayList();</span>
        }
<span class="fc" id="L230">        VeryLongBitString boundaryPixelsIdx = new VeryLongBitString(256);</span>
        
<span class="fc" id="L232">        int priority = 256;</span>
        
        // stack of components (max size is number of grey levels, 256)
<span class="fc" id="L235">        List&lt;Region&gt; regionStack = new ArrayList&lt;Region&gt;(256);</span>
<span class="fc" id="L236">        regionStack.add(new Region());</span>

        // 2. Make the source pixel (with its first edge) the current pixel, 
        //    mark it as accessible and
        //    store the grey-level of it in the variable current level.
<span class="fc" id="L241">        int curPixel = 0;</span>
<span class="fc" id="L242">        int curEdge = 0;</span>
<span class="fc" id="L243">        int curLevel = bits[0];</span>
        // set bit 0
<span class="fc" id="L245">        accessible.setBit(0);</span>
        
        //System.out.println(&quot;curPixel &quot; + curPixel + &quot; level=&quot; + curLevel + &quot; priority=&quot; + priority);
        //System.out.println(&quot;accessible &quot; + 0);

        // 3. Push an empty component with current level onto the component stack.
        //step_3:
<span class="fc" id="L252">        regionStack.add(new Region(curLevel, curPixel));</span>

        // 4. Explore the remaining edges to the neighbors of the current pixel, 
        // in order, as follows:
        // For each neighbor, check if the neighbor is already accessible. 
        //   If it is not, mark it as accessible and retrieve its grey-level. 
        //     If the grey-level is not lower than the current one,
        //       push it onto the heap of boundary pixels. 
        //     else If the grey-level is lower than the current one, 
        //       enter the current pixel back into the queue of boundary pixels 
        //       for later processing (with the next edge number), 
        //       consider the new pixel and its grey-level and go to 3.
        while (true) {

<span class="fc" id="L266">            int x = curPixel % width;</span>
<span class="fc" id="L267">            int y = curPixel / width;</span>

<span class="fc" id="L269">            boolean s3 = false;</span>

<span class="fc bfc" id="L271" title="All 4 branches covered.">            for (; curEdge &lt; (eight_ ? 8 : 4); ++curEdge) {</span>

<span class="fc" id="L273">                int neighborPixel = curPixel;</span>

<span class="fc bfc" id="L275" title="All 2 branches covered.">                if (eight_) {</span>
                    //pix = (row * w) + col
<span class="fc bfc" id="L277" title="All 8 branches covered.">                    switch (curEdge) {</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                        case 0: if (x &lt; width - 1) neighborPixel = curPixel + 1; break; </span>
<span class="fc bfc" id="L279" title="All 4 branches covered.">                        case 1: if ((x &lt; width - 1) &amp;&amp; (y &gt; 0)) neighborPixel = curPixel - width + 1; break;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                        case 2: if (y &gt; 0) neighborPixel = curPixel - width; break; </span>
<span class="fc bfc" id="L281" title="All 4 branches covered.">                        case 3: if ((x &gt; 0) &amp;&amp; (y &gt; 0)) neighborPixel = curPixel - width - 1; break; </span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">                        case 4: if (x &gt; 0) neighborPixel = curPixel - 1; break; </span>
<span class="fc bfc" id="L283" title="All 4 branches covered.">                        case 5: if ((x &gt; 0) &amp;&amp; (y &lt; height - 1)) neighborPixel = curPixel + width - 1; break;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                        case 6: if (y &lt; height - 1) neighborPixel = curPixel + width; break; </span>
<span class="fc bfc" id="L285" title="All 4 branches covered.">                        default: if ((x &lt; width - 1) &amp;&amp; (y &lt; height - 1)) neighborPixel = curPixel + width + 1; break; </span>
                    }
                } else {
<span class="fc bfc" id="L288" title="All 4 branches covered.">                    switch (curEdge) {</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                        case 0: if (x &lt; width - 1) neighborPixel = curPixel + 1; break; </span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                        case 1: if (y &lt; height - 1) neighborPixel = curPixel + width; break; </span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                        case 2: if (x &gt; 0) neighborPixel = curPixel - 1; break; </span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">                        default: if (y &gt; 0) neighborPixel = curPixel - width; break; </span>
                    }
                }

<span class="fc bfc" id="L296" title="All 2 branches covered.">                if (neighborPixel != curPixel</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                    &amp;&amp; accessible.isNotSet(neighborPixel)) {</span>

<span class="fc" id="L299">                    int neighborLevel = bits[neighborPixel];</span>
<span class="fc" id="L300">                    accessible.setBit(neighborPixel);</span>
                    
                    //System.out.println(&quot; accessible nb=&quot; + neighborPixel + &quot; nblvl=&quot; + neighborLevel);
                    
<span class="fc bfc" id="L304" title="All 2 branches covered.">                    if (neighborLevel &gt;= curLevel) {</span>
             
                        // implicitly '|' with curEdge=-1, then implicity read
                        //   as next being 0
<span class="fc" id="L308">                        boundaryPixels[neighborLevel].add(neighborPixel &lt;&lt; 4);</span>
<span class="fc" id="L309">                        boundaryPixelsIdx.setBit(neighborLevel);</span>
               
<span class="fc bfc" id="L311" title="All 2 branches covered.">                        if (neighborLevel &lt; priority) {</span>
                            // always handle a smaller grey level next
<span class="fc" id="L313">                            priority = neighborLevel;</span>
                        }
                    } else {
                        
                        // always handle a smaller grey level next,
                        // so process neighbor and put current level as priority

<span class="fc" id="L320">                        boundaryPixels[curLevel].add((curPixel &lt;&lt; 4) | (curEdge + 1));</span>
<span class="fc" id="L321">                        boundaryPixelsIdx.setBit(curLevel);</span>
    
<span class="fc bfc" id="L323" title="All 2 branches covered.">                        if (curLevel &lt; priority) {</span>
<span class="fc" id="L324">                            priority = curLevel;</span>
                        }
<span class="fc" id="L326">                        curPixel = neighborPixel;</span>
<span class="fc" id="L327">                        curEdge = 0;</span>
<span class="fc" id="L328">                        curLevel = neighborLevel;</span>

                        //System.out.println(&quot;curPixel &quot; + curPixel + &quot; level=&quot; + curLevel + &quot; priority=&quot; + priority);
                        
                        //continue step_3;
<span class="fc" id="L333">                        s3 = true;</span>
                        
<span class="fc" id="L335">                        break;</span>
                    }
                }
            } // end for loop over curEdge

<span class="fc bfc" id="L340" title="All 2 branches covered.">            if (s3) {</span>

<span class="fc" id="L342">                regionStack.add(new Region(curLevel, curPixel));</span>

<span class="fc" id="L344">                continue;</span>
            }
            /*the above code outlined for quick look at major branches:
            while (true) {
                for (; curEdge &lt; (eight_ ? 8 : 4); ++curEdge) {
                    if (neighborPixel != curPixel &amp;&amp; accessible.isNotSet(neighborPixel)) {
                        if (neighborLevel &gt;= curLevel) {
                        } else {
                            s3 = true;
                            break;
                        }
                    }
                } // end for loop over curEdge
                if (s3) {
                    continue;
                }
                if (priority == 256) {
                    regionStack.get(regionStack.size() - 1)
                        .detect(...);
                    return;
                }
                if (newPixelGreyLevel != curLevel) {
                    processStack(newPixelGreyLevel, curPixel, regionStack);
                }
            }// end outer loop
            */

            // 5. Accumulate the current pixel to the component at the top of the stack (water
            // saturates the current pixel).
<span class="fc" id="L373">            regionStack.get(regionStack.size() - 1).accumulate(x, y);</span>

            // 6. Pop the heap of boundary pixels. If the heap is empty, 
            //    we are done. 
            //    If the returned pixel is at the same grey-level as the 
            //    previous, go to 4.
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (priority == 256) {</span>

<span class="fc" id="L381">                regionStack.get(regionStack.size() - 1)</span>
<span class="fc" id="L382">                    .detect(delta_, (int)(minArea_ * width * height),</span>
                        (int)(maxArea_ * width * height),
                        maxVariation_, minDiversity_, regions);

<span class="fc" id="L386">                return;</span>
            }

<span class="fc" id="L389">            int sz = boundaryPixels[priority].size();  </span>
<span class="fc" id="L390">            int highestPriorityBP = boundaryPixels[priority].removeAt(sz - 1);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if (boundaryPixels[priority].isEmpty()) {</span>
<span class="fc" id="L392">                boundaryPixelsIdx.clearBit(priority);</span>
            }
            // decode (curPixel &lt;&lt; 4) | (curEdge + 1):
<span class="fc" id="L395">            curPixel = highestPriorityBP &gt;&gt; 4;</span>
<span class="fc" id="L396">            curEdge = highestPriorityBP &amp; 15; // &lt;--- NOTE: +1 remains here as incrementation for next loop value</span>
           
<span class="pc bpc" id="L398" title="1 of 4 branches missed.">            if (priority &lt; 256 &amp;&amp; boundaryPixels[priority].isEmpty()) {</span>
<span class="fc" id="L399">                int prev = priority;</span>
<span class="fc" id="L400">                priority = boundaryPixelsIdx.nextHighestBitSet(priority - 1);</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">                if (priority == -1) {</span>
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">                    if (prev == 255 || accessible.getNSetBits() == bits.length) {</span>
<span class="fc" id="L404">                        priority = 256;</span>
                    } else {
<span class="nc" id="L406">                        priority = 255;</span>
                    }
                }             
            }
            //System.out.println(&quot;curPixel &quot; + curPixel + &quot; level=&quot; + curLevel + &quot; priority=&quot; + priority);

<span class="fc" id="L412">            int newPixelGreyLevel = bits[curPixel];</span>

<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (newPixelGreyLevel != curLevel) {</span>

<span class="fc" id="L416">                curLevel = newPixelGreyLevel;</span>
 
                // 7. The returned pixel is at a higher grey-level, so we must 
                // now process all components on the component stack until we 
                // reach the higher grey-level. This is done with the 
                // processStack sub-routine, see below.
                // Then go to 4.
<span class="fc" id="L423">                processStack(newPixelGreyLevel, curPixel, regionStack);</span>
            }
            /*System.out.println(&quot;Regions:&quot;);
            for (Region r : regionStack) {
                System.out.println(r.toString());
            }*/
<span class="fc" id="L429">        }// end outer while loop</span>
    }

    private void processStack(int newPixelGreyLevel, int pixel,
        List&lt;Region&gt; regionStack) {

        // 1. Process component on the top of the stack. The next grey-level
        // is the minimum of newPixelGreyLevel and the grey-level for the
        // second component on the stack.
        do {
            
<span class="fc" id="L440">            Region top = regionStack.remove(regionStack.size() - 1);</span>

            // 2. If newPixelGreyLevel is smaller than the grey-level on the 
            //    second component on the stack, set the top of stack 
            //    grey-level to newPixelGreyLevel and return from sub-routine
            //    (This occurs when the new pixel is at a grey-level for which 
            //    there is not yet a component instantiated, so we let the top 
            //    of stack be that level by just changing its grey-level.
<span class="fc" id="L448">            if (newPixelGreyLevel &lt; </span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">                regionStack.get(regionStack.size() - 1).level_) {</span>

                // NOTE, this slight change in methods used by Charles Dubout results
                // in the history of top being added to new node correclty
                // without additional logic
<span class="fc" id="L454">                regionStack.add(new Region(newPixelGreyLevel, pixel));</span>
            
<span class="fc" id="L456">                regionStack.get(regionStack.size() - 1).merge(top);</span>

<span class="fc" id="L458">                return;</span>
            }

            // 3. Remove the top of stack and merge it into the second component
            // on stack as follows:
            // Add the first and second moment accumulators together and/or
            // join the pixel lists.
            // Either merge the histories of the components, or take the history
            // from the winner. Note
            // here that the top of stack should be considered one ’time-step’
            // back, so its current
            // size is part of the history. Therefore the top of stack would
            // be the winner if its
            // current size is larger than the previous size of second on stack.
            
<span class="fc" id="L473">            regionStack.get(regionStack.size() - 1).merge(top);</span>
            
        } // 4. If(newPixelGreyLevel&gt;top of stack grey-level) go to 1.
<span class="fc" id="L476">        while (newPixelGreyLevel &gt; </span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">            regionStack.get(regionStack.size() - 1).level_);</span>
        
<span class="fc" id="L479">    }</span>

    /**
     * given 8 bit image, calculate the MSER regions using the default 
     * sensitivity Threshold (sets instance variables to
     * preset values for the threshold).
     * @param img
     * @return 
     */
    public List&lt;List&lt;Region&gt;&gt; findRegions(GreyscaleImage img) {

<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (img.getMax() &gt; ((1 &lt;&lt;8) - 1)) {</span>
<span class="nc" id="L491">            throw new IllegalArgumentException(&quot;img must be an 8 bit image&quot;);</span>
        }
        
<span class="nc" id="L494">        int width = img.getWidth();</span>
<span class="nc" id="L495">        int height = img.getHeight();</span>

<span class="nc" id="L497">        int[] greyscale = new int[width * height];</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L499">            greyscale[i] = img.getValue(i);</span>
        }
    
<span class="nc" id="L502">        return findRegions(greyscale, width, height);</span>
    }
    
    /**
     * given 8 bit image, calculate the MSER regions.
     * @param img
     * @param delta DELTA parameter of the MSER algorithm.
               Roughly speaking, the stability of a
	       region is the relative variation of the region
               area when the intensity is changed by delta.
        @param minArea Minimum area of any stable region
                   relative to the image domain area.
        @param maxArea Maximum area of any stable region
                   relative to the image domain area.
        @param maxVariation Maximum variation (absolute
                   stability score) of the regions.
        @param minDiversity Minimum diversity of the regions.
                   When the relative area of two
                   nested regions is below this threshold,
                   then only the most stable one is selected.
     * @return 
     */
    public List&lt;List&lt;Region&gt;&gt; findRegions(GreyscaleImage img,
        int delta, double minArea, double maxArea, double maxVariation,
        double minDiversity) {

<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (img.getMax() &gt; ((1 &lt;&lt;8) - 1)) {</span>
<span class="nc" id="L529">            throw new IllegalArgumentException(&quot;img must be an 8 bit image&quot;);</span>
        }
        
<span class="nc" id="L532">        int width = img.getWidth();</span>
<span class="nc" id="L533">        int height = img.getHeight();</span>

<span class="nc" id="L535">        int[] greyscale = new int[width * height];</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="nc" id="L537">            greyscale[i] = img.getValue(i);</span>
        }
    
<span class="nc" id="L540">        return findRegions(greyscale, width, height, delta, minArea, maxArea, </span>
            maxVariation, minDiversity);
    }
    
    public enum Threshold {
        LEAST_SENSITIVE, LESS_SENSITIVE, SLIGHTLY_LESS_SENSITIVE, DEFAULT
    }
    
    public static int[] readIntoArray(GreyscaleImage img) {
        
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (img.getMax() &gt; ((1 &lt;&lt;8) - 1)) {</span>
<span class="nc" id="L551">            throw new IllegalArgumentException(&quot;img must be an 8 bit image&quot;);</span>
        }
        
<span class="fc" id="L554">        int width = img.getWidth();</span>
<span class="fc" id="L555">        int height = img.getHeight();</span>

<span class="fc" id="L557">        int[] greyscale = new int[width * height];</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L559">            greyscale[i] = img.getValue(i);</span>
        }
        
<span class="fc" id="L562">        return greyscale;</span>
    }
    
    /**
     * given 8 bit image, calculate the MSER regions.
     * @param img
     * @param threshold sets the instance variables to preset values for sensitivity
     * categories.
     * @return 
     */
    public List&lt;List&lt;Region&gt;&gt; findRegions(GreyscaleImage img, Threshold 
        threshold) {
        
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        if (img.getMax() &gt; ((1 &lt;&lt;8) - 1)) {</span>
<span class="nc" id="L576">            throw new IllegalArgumentException(&quot;img must be an 8 bit image&quot;);</span>
        }

<span class="fc" id="L579">        int width = img.getWidth();</span>
<span class="fc" id="L580">        int height = img.getHeight();</span>

<span class="fc" id="L582">        int[] greyscale = new int[width * height];</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">        for (int i = 0; i &lt; img.getNPixels(); ++i) {</span>
<span class="fc" id="L584">            greyscale[i] = img.getValue(i);</span>
        }
    
<span class="fc" id="L587">        return findRegions(greyscale, width, height, threshold);</span>
    }
    
    /**
     * 
     * @param greyscale array of image pixels in order idx = (row * width) + col.
     * @param width
     * @param height
     * @return 
     */
    public List&lt;List&lt;Region&gt;&gt; findRegions(int[] greyscale, int width,
        int height) {
<span class="fc" id="L599">        return findRegions(greyscale, width, height, </span>
            Threshold.DEFAULT);
    }
    
     /**
     * given 8 bit image, calculate the MSER regions.
     * @param greyscale greyscale intensities of the image written so
     * that the array index is (row * imageWidth) + col.
     * @param width image width
     * @param height image height
     * @return 2 lists of mser regions, one created from a non-inverted
     * image and the other created from an inverted image.
     */
    public List&lt;List&lt;Region&gt;&gt; findRegions(int[] greyscale, int width,
        int height, Threshold threshold) {
        
<span class="fc" id="L615">        int delta = 2;</span>
        double minArea;
<span class="fc" id="L617">        double maxArea = 0.25;//0.1;</span>
<span class="fc" id="L618">        double maxVariation = 0.5;</span>
<span class="fc" id="L619">        double minDiversity = 0.5;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">        if (threshold.equals(Threshold.LEAST_SENSITIVE)) {</span>
<span class="fc" id="L621">            minArea = 0.1;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        } else if (threshold.equals(Threshold.LESS_SENSITIVE)) {</span>
<span class="fc" id="L623">            minArea = 0.01;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">        } else if (threshold.equals(Threshold.SLIGHTLY_LESS_SENSITIVE)) {</span>
<span class="fc" id="L625">            minArea = 0.001;</span>
        } else {
<span class="fc" id="L627">            minArea = 0.0005;</span>
        }

<span class="fc" id="L630">        return findRegions(greyscale, width, height, delta, minArea, maxArea, </span>
            maxVariation, minDiversity);
        
    }
    
    /**
     * given 8 bit image, calculate the MSER regions.
     * @param greyscale greyscale intensities of the image written so
     * that the array index is (row * imageWidth) + col.
     * @param width image width
     * @param height image height
     * @return  list of mser regions created from a non-inverted
     */
    public List&lt;Region&gt; findRegionsPos(int[] greyscale, int width,
        int height, Threshold threshold) {
        
<span class="nc" id="L646">        int delta = 2;</span>
        double minArea;
<span class="nc" id="L648">        double maxArea = 0.25;//0.1;</span>
<span class="nc" id="L649">        double maxVariation = 0.5;</span>
<span class="nc" id="L650">        double minDiversity = 0.5;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (threshold.equals(Threshold.LEAST_SENSITIVE)) {</span>
<span class="nc" id="L652">            minArea = 0.1;</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        } else if (threshold.equals(Threshold.LESS_SENSITIVE)) {</span>
<span class="nc" id="L654">            minArea = 0.01;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        } else if (threshold.equals(Threshold.SLIGHTLY_LESS_SENSITIVE)) {</span>
<span class="nc" id="L656">            minArea = 0.001;</span>
        } else {
<span class="nc" id="L658">            minArea = 0.0005;</span>
        }
        
<span class="nc" id="L661">        MSER mser8 = new MSER(delta, minArea, maxArea, maxVariation, </span>
            minDiversity, true);
        
<span class="nc" id="L664">        List&lt;Region&gt; regions = new ArrayList&lt;Region&gt;();</span>

<span class="nc" id="L666">        mser8.operator(greyscale, width, height, regions);</span>
        
<span class="nc" id="L668">        long stop = System.currentTimeMillis();</span>

        //System.out.println(
        //    &quot;Extracted &quot; + (regions.get(0).size() + regions.get(1).size())
        //    + &quot; regions  (&quot; + width + 'x' + height + &quot;) in &quot;
        //    + ((stop - start) / 1000) + &quot;s.&quot;);

<span class="nc" id="L675">        return regions;</span>
        
    }
    
    /**
     * given 8 bit image, calculate the MSER regions.  uses 4-connected regions
     * for the positive and negative image processing.
     * @param greyscale greyscale intensities of the image written so
     * that the array index is (row * imageWidth) + col.
     * Note, the input greyscale array is modified to invert it.
     * @param width image width
     * @param height image height
     * @return  list of mser regions created from a inverted
     */
    public List&lt;Region&gt; findRegionsNeg(int[] greyscale, int width,
        int height, Threshold threshold) {
        
<span class="fc" id="L692">        int delta = 2;</span>
        double minArea;
<span class="fc" id="L694">        double maxArea = 0.25;//0.1;</span>
<span class="fc" id="L695">        double maxVariation = 0.5;</span>
<span class="fc" id="L696">        double minDiversity = 0.5;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (threshold.equals(Threshold.LEAST_SENSITIVE)) {</span>
<span class="fc" id="L698">            minArea = 0.1;</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        } else if (threshold.equals(Threshold.LESS_SENSITIVE)) {</span>
<span class="nc" id="L700">            minArea = 0.01;</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        } else if (threshold.equals(Threshold.SLIGHTLY_LESS_SENSITIVE)) {</span>
<span class="fc" id="L702">            minArea = 0.001;</span>
            //NOTE: temporary edit...might change
<span class="fc" id="L704">            minDiversity = 0.995;</span>
        } else {
<span class="nc" id="L706">            minArea = 0.0005;</span>
        }
        
<span class="fc" id="L709">        MSER mser4 = new MSER(delta, minArea, maxArea, maxVariation, </span>
            minDiversity, false);

<span class="fc" id="L712">        List&lt;Region&gt; regions = new ArrayList&lt;Region&gt;();</span>
   
        // Invert the pixel values
<span class="fc bfc" id="L715" title="All 2 branches covered.">        for (int i = 0; i &lt; width * height; ++i) {</span>
<span class="fc" id="L716">            greyscale[i] = ~greyscale[i];</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if (greyscale[i] &lt; 0) {</span>
<span class="fc" id="L718">                greyscale[i] += 256;</span>
            }
        }

<span class="fc" id="L722">        mser4.operator(greyscale, width, height, regions);</span>

<span class="fc" id="L724">        long stop = System.currentTimeMillis();</span>

        //System.out.println(
        //    &quot;Extracted &quot; + (regions.get(0).size() + regions.get(1).size())
        //    + &quot; regions  (&quot; + width + 'x' + height + &quot;) in &quot;
        //    + ((stop - start) / 1000) + &quot;s.&quot;);

<span class="fc" id="L731">        return regions;</span>
    }
    
    /**
     * given 8 bit image, calculate the MSER regions.
     * uses 8-connected regions for the positive image processing and 
     * 4-connected regions for the negative image processing.
     * @param greyscale greyscale intensities of the image written so
     * that the array index is (row * imageWidth) + col.
     * @param width image width
     * @param height image height
     * @param delta DELTA parameter of the MSER algorithm.
               Roughly speaking, the stability of a
	       region is the relative variation of the region
               area when the intensity is changed by delta.
               (default delta = 2.0)
    @param minArea Minimum area of any stable region
               relative to the image domain area.
               (double minArea = 0.0001)
    @param maxArea Maximum area of any stable region
               relative to the image domain area.
               (double maxArea = 0.5)
    @param maxVariation Maximum variation (absolute
               stability score) of the regions.
               (double maxVariation = 0.5)
    @param minDiversity Minimum diversity of the regions.
               When the relative area of two
	       nested regions is below this threshold,
               then only the most stable one is selected.
               (double minDiversity = 0.33)
     * @return 2 lists of mser regions, one created from a non-inverted
     * image and the other created from an inverted image.
     */
    public List&lt;List&lt;Region&gt;&gt; findRegions(int[] greyscale, int width,
        int height, int delta, double minArea, double maxArea, double maxVariation,
        double minDiversity) {

        // Extract MSER
        //long start = System.currentTimeMillis();

<span class="fc" id="L771">        MSER mser8 = new MSER(delta, minArea, maxArea, maxVariation, </span>
            minDiversity, true);
<span class="fc" id="L773">        MSER mser4 = new MSER(delta, minArea, maxArea, maxVariation, </span>
            minDiversity, false);

<span class="fc" id="L776">        List&lt;List&lt;Region&gt;&gt; regions = new ArrayList&lt;List&lt;Region&gt;&gt;(2);</span>
<span class="fc" id="L777">        regions.add(new ArrayList&lt;Region&gt;());</span>
<span class="fc" id="L778">        regions.add(new ArrayList&lt;Region&gt;());</span>

<span class="fc" id="L780">        mser8.operator(greyscale, width, height, regions.get(0));</span>
   
        // Invert the pixel values
<span class="fc bfc" id="L783" title="All 2 branches covered.">        for (int i = 0; i &lt; width * height; ++i) {</span>
<span class="fc" id="L784">            greyscale[i] = ~greyscale[i];</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">            if (greyscale[i] &lt; 0) {</span>
<span class="fc" id="L786">                greyscale[i] += 256;</span>
            }
        }

<span class="fc" id="L790">        mser4.operator(greyscale, width, height, regions.get(1));</span>

        //long stop = System.currentTimeMillis();

        //System.out.println(
        //    &quot;Extracted &quot; + (regions.get(0).size() + regions.get(1).size())
        //    + &quot; regions  (&quot; + width + 'x' + height + &quot;) in &quot;
        //    + ((stop - start) / 1000) + &quot;s.&quot;);

<span class="fc" id="L799">        return regions;</span>
    }
}

//--------------------------------------------------------------------------------------------------
// Linear time Maximally Stable Extremal Regions implementation as described in D. Nistér and
// H. Stewénius. Linear Time Maximally Stable Extremal Regions. Proceedings of the European
// Conference on Computer Vision (ECCV), 2008.
//
// Copyright (c) 2011 Idiap Research Institute, http://www.idiap.ch/.
// Written by Charles Dubout &lt;charles.dubout@idiap.ch&gt;.
//
// MSER is free software: you can redistribute it and/or modify it under the terms of the GNU
// General Public License version 3 as published by the Free Software Foundation.
//
// MSER is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
// Public License for more details.
//
// You should have received a copy of the GNU General Public License along with MSER. If not, see
// &lt;http://www.gnu.org/licenses/&gt;.
//--------------------------------------------------------------------------------------------------

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
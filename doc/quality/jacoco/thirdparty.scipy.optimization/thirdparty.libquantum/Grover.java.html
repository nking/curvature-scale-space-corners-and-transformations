<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Grover.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">thirdparty.libquantum</a> &gt; <span class="el_source">Grover.java</span></div><h1>Grover.java</h1><pre class="source lang-java linenums">package thirdparty.libquantum;

import algorithms.misc.ComplexModifiable;
import algorithms.misc.Misc;
import algorithms.misc.MiscMath;
import java.util.Random;

/* 
An implementation of the grover search algorithm, 
ported here to java from the libquantum file grover.c.
The method calls have been adapted for re-use by
other algorithms and methods to accept a list of
numbers have been created and an alternate oracle
and diffuser have been implemented by this project.

The file grover.c has copyright:
Implementation of Grover's search algorithm

  Copyright 2003 Bjoern Butscher, Hendrik Weimer

  This file is a port to java from a c file in libquantum.

  libquantum is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation; either version 3 of the License,
  or (at your option) any later version.

  libquantum is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with libquantum; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  MA 02110-1301, USA

*/

<span class="fc" id="L40">public class Grover {</span>
    
<span class="fc" id="L42">    private boolean debug = false;</span>
    
<span class="fc" id="L44">    private int width0 = 0;</span>

    /*
            from wikipedia:

                           ------------------------
                          /   diffuser              \
                  _____   _____  ____________   _____
    |0&gt; -[H⊗n]---|     |--|H⊗n|--|2|0^n&gt; -I_n|--|H⊗n|---- ...measure
                 | U_w |  -----  ------------   ----
    |1&gt; -[H]-----|     |---------------------------------
                 ------|

                 Repeat U_w + diffuser O(sqrt(N)) times
     */
    
    /**
     * 
     * runtime complexity is O(reg.size * reg.width),
       (because decoherence lambda is 0.0).
     * 
     * @param state (f(x) == 1 when x == state, else f(x) == 0)
     * @param reg
     */
    private void oracle(int query, QuantumReg reg, Gates gates) {
        int i;
        
        //TODO: need to either double the number of bits used in
        //      initialization of the register to have those 
        //      available here or need to adjust the algorithm
        //      to have same results with closer to current number of bits.
        
        /*
         function f(x)
                == 1 when x satisifies search criteria, 
                   that is, x == w
                   |U_w|x&gt; = -|x&gt;
                == 0 else is 0, that is, x != w
                   |U_w|x&gt; = |x&gt;

        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt;        
        */
        
        /*
        -- for each query bit: 
              if query bit i is 0, flips that bit in all states
        -- for each node state,
              if bits 0 and 1 are set, 
                  it flips the bit reg-&gt;width + 1
        -- for each node state,
              if bit reg-&gt;width + i is set, 
                  it flips the bit reg-&gt;width
        -- for each node.state (in reversed order): 
               if bits i and reg-&gt;width + i are set, 
                   it flips the bit reg.width + 1 + i
        -- for each node state,
               if bits 0 and 1 are set, 
                  it flips the bit reg-&gt;width + 1
        -- for each query bit:
               if query bit i is 0, 
                   flip bit i in all node states
        */
             
        //DEBUG
<span class="fc" id="L108">        StringBuilder[] sbs = new StringBuilder[reg.size];</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L111">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L112">                sbs[ii] = sb;</span>
            }
<span class="nc bnc" id="L114" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L115">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L116">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L118">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L120">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //runtime complexity is O(reg.size * reg.width),
        // (because decoherence lambda is 0.0).
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L129">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
        
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L136">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L137">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L139">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L141">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }

        //for each node.state: 
        // if bits 0 and 1 are set, it flips the bit reg-&gt;width + 1
<span class="fc" id="L147">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>
        
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L151">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L152">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L154">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L156">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (i = 1; i &lt; width0; i++) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg-&gt;width + 1 + i
           
<span class="fc" id="L165">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L170">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L171">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L173">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L175">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bit reg-&gt;width + i is set, 
        // it flips the bit reg-&gt;width
<span class="fc" id="L182">        gates.quantum_cnot(width0 + i, width0, reg);</span>
        
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L186">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L187">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L189">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L191">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (i = width0 - 1; i &gt; 0; i--) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg.width + 1 + i
            
<span class="fc" id="L200">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L205">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L206">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L208">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L210">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bits 0 and 1 are set, 
        // it flips the bit reg-&gt;width + 1
<span class="fc" id="L217">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>

<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L221">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L222">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L224">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L226">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L230" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L233">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L239">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L240">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L242">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L244">                sb.append(str).append(&quot;  &quot;);</span>
            }
            
<span class="nc" id="L247">            System.out.println(&quot;END STATES&quot;);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L249">                System.out.println(sbs[ii]);</span>
            }
        }
<span class="fc" id="L252">    }   </span>
        
    /**
     * 
     * runtime complexity is O(reg.size * reg.width),
       (because decoherence lambda is 0.0).
     * 
     * @param state (f(x) == 1 when x == state, else f(x) == 0)
     * @param reg
     */
    private void oracle2(int query, QuantumReg reg, Gates gates) {
        int i;
        
        /*
        TODO: can this be done with purely NAND gates and query
        with fewer qubits?
        a lecture suggests only need unitary operations
        */

        /*
         function f(x)
                == 1 when x satisifies search criteria, 
                   that is, x == w
                   |U_w|x&gt; = -|x&gt;
                == 0 else is 0, that is, x != w
                   |U_w|x&gt; = |x&gt;

        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt;        
        */
             
        //DEBUG
<span class="fc" id="L283">        StringBuilder[] sbs = new StringBuilder[reg.size];</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L286">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L287">                sbs[ii] = sb;</span>
            }
<span class="nc bnc" id="L289" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L290">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L291">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L293">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L295">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //runtime complexity is O(reg.size * reg.width),
        // (because decoherence lambda is 0.0).
<span class="fc bfc" id="L301" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L304">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
        
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L311">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L312">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L314">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L316">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }

        //for each node.state: 
        // if bits 0 and 1 are set, it flips the bit reg-&gt;width + 1
<span class="fc" id="L322">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>
        
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L326">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L327">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L329">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L331">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (i = 1; i &lt; width0; i++) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg-&gt;width + 1 + i
           
<span class="fc" id="L340">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L345">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L346">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L348">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L350">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bit reg-&gt;width + i is set, 
        // it flips the bit reg-&gt;width
<span class="fc" id="L357">        gates.quantum_cnot(width0 + i, width0, reg);</span>
        
             
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L362">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L363">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L365">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L367">                sb.append(&quot;*&quot;).append(str).append(&quot;  &quot;);</span>
            }
        }
        
        
        // anything that is all 1's at this point is the found number.
        // (all 1's except the high bit)
        
        // not reversible
        // set high bit if all bits are set
<span class="fc" id="L377">        gates.quantum_ccand(0, 0, reg.width-1, reg);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        for (i = 1; i &lt; reg.width-2; i++) {</span>
<span class="fc" id="L379">            gates.quantum_ccand(i, reg.width-1, reg.width-1, reg);</span>
        }
        
        
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L385">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L386">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L388">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L390">                sb.append(&quot;*&quot;).append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (i = width0 - 1; i &gt; 0; i--) {</span>
            //for each node.state: 
            // if bits i and reg-&gt;width + i are set, 
            // it flips the bit reg.width + 1 + i
            
<span class="fc" id="L399">            gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
        }
        
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L404">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L405">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L407">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L409">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
        //for each node.state: 
        // if bits 0 and 1 are set, 
        // it flips the bit reg-&gt;width + 1
<span class="fc" id="L416">        gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>

<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L420">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L421">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L423">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L425">                sb.append(str).append(&quot;  &quot;);</span>
            }
        }
        
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
            //if query bit i is 0, flip bit i in all node states
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if ((query &amp; (1 &lt;&lt; i)) == 0) {</span>
<span class="fc" id="L432">                gates.quantum_sigma_x(i, reg);</span>
            }
        }
        
        
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L439">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L440">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L442">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L444">                sb.append(str).append(&quot;  &quot;);</span>
            }
            
        }
        
        
        // not reversible
        // unset the width0 bit
<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc" id="L453">            reg.node[i].state  &amp;= ~(1L &lt;&lt; width0);</span>
        }
       
        // rotate by pi if high bit is set
<span class="fc" id="L457">        gates.quantum_phase_kick(reg.width - 1, Math.PI, reg);</span>
        
        // unset the highest bit.
        // not reversible.
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc" id="L462">            reg.node[i].state  &amp;= ~(1L &lt;&lt; (reg.width - 1));</span>
        }
        
        
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L468">                StringBuilder sb = sbs[ii];</span>
<span class="nc" id="L469">                String str = Long.toBinaryString(reg.node[ii].state);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                while (str.length() &lt; reg.width) {</span>
<span class="nc" id="L471">                    str = &quot;0&quot; + str;</span>
                }
<span class="nc" id="L473">                sb.append(str).append(&quot;  &quot;);</span>
            }
            
<span class="nc" id="L476">            System.out.println(&quot;END STATES&quot;);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            for (int ii = 0; ii &lt; reg.size; ii++) {</span>
<span class="nc" id="L478">                System.out.println(sbs[ii]);</span>
            }
        }
<span class="fc" id="L481">    }</span>
    
    /**
      runtime complexity is O(reg.size * reg.width),
      (because decoherence lambda is 0.0).
     * @param reg
     */
    private void inversion(QuantumReg reg, Gates gates) {
        int i;

        //|2|0^n&gt; -I_n|
        
        //Flip the target bit of each basis state, i
<span class="fc bfc" id="L494" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L495">            gates.quantum_sigma_x(i, reg);</span>
        }
       
<span class="fc" id="L498">        gates.quantum_hadamard(width0 - 1, reg);</span>

<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if (width0 == 3) {</span>
        
<span class="fc" id="L502">            gates.quantum_toffoli(0, 1, 2, reg);</span>
        
        } else {
            
            //If bits 0 and 1 are set, it flips the target bit.
<span class="nc" id="L507">            gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>

<span class="nc bnc" id="L509" title="All 2 branches missed.">            for (i = 1; i &lt; width0 - 1; i++) {</span>
                //If bits i and reg.width+i are set, it flips the target bit.
<span class="nc" id="L511">                gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
            }

            //for each reg.state, 
            //   Flip the target bit of a basis state if 
            //   the control bit is set
<span class="nc" id="L517">            gates.quantum_cnot(width0 + i, width0 - 1, reg);</span>

<span class="nc bnc" id="L519" title="All 2 branches missed.">            for (i = width0 - 2; i &gt; 0; i--) {</span>
                //If bits i and reg.width+i are set, it flips the target bit.
<span class="nc" id="L521">                gates.quantum_toffoli(i, width0 + i, width0 + i + 1, reg);</span>
            }

            //If bits 0 and 1 are set, it flips the target bit.
<span class="nc" id="L525">            gates.quantum_toffoli(0, 1, width0 + 1, reg);</span>
        }

<span class="fc" id="L528">        gates.quantum_hadamard(width0 - 1, reg);</span>
        
        //Flip the target bit of each basis state, i
<span class="fc bfc" id="L531" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L532">            gates.quantum_sigma_x(i, reg);</span>
        }
        
<span class="fc" id="L535">    }</span>

    /**
     * runtime complexity is O(reg.size * reg.width)  (because decoherence lambda is 0.0).
     * 
     * @param target 
     *     (f(x) == 1 when x == target, else f(x) == 0)
     * @param reg
     */
    private void grover(int target, QuantumReg reg, Gates gates, QuReg qureg) {
        
        int i;  
        
        //unitary operator operating on two qubits, target and each i
        // |x&gt;|q&gt; ----&gt; (-1)^(f(x)) * |x&gt; 
        // (gives the found solutions negative signs)
<span class="fc" id="L551">        oracle(target, reg, gates);</span>

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L554">            System.out.format(</span>
                &quot;AFTER oracle target=%d  reg.size=%d  hash.length=%d\n&quot;, 
<span class="nc" id="L556">                target, reg.size, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L557">            qureg.quantum_print_qureg(reg);</span>
        }

        //   H⊗n   |2|0^n&gt; -I_n|  H⊗n

<span class="fc bfc" id="L562" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L563">            gates.quantum_hadamard(i, reg);</span>
        }

<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L567">            System.out.format(</span>
                &quot;AFTER hadamard target=%d hadamard reg.size=%d\n&quot;, 
<span class="nc" id="L569">                target, reg.size);</span>
<span class="nc" id="L570">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="fc" id="L573">        inversion(reg, gates);</span>

<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L576">            System.out.format(</span>
                &quot;AFTER target=%d inversion reg.size=%d\n&quot;, 
<span class="nc" id="L578">                target, reg.size);</span>
<span class="nc" id="L579">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="fc bfc" id="L582" title="All 2 branches covered.">        for (i = 0; i &lt; width0; i++) {</span>
<span class="fc" id="L583">            gates.quantum_hadamard(i, reg);</span>
        }

<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L587">            System.out.format(&quot;AFTER target=%d 2nd hadamard  reg.size=%d\n&quot;, </span>
<span class="nc" id="L588">                target, reg.size);</span>
<span class="nc" id="L589">            qureg.quantum_print_qureg(reg);</span>
        }
       
<span class="fc" id="L592">    }</span>
    
    /**
     * runtime complexity is O(reg.size * reg.width)  (because decoherence lambda is 0.0).
     * 
     * @param target 
     *     (f(x) == 1 when x == target, else f(x) == 0)
     * @param reg states with the high bit set are the found items
     */
    private void grover2(int target, QuantumReg reg, Gates gates, QuReg qureg) {
             
        int i;
        
        // matching state is rotated by PI
<span class="fc" id="L606">        oracle2(target, reg, gates);</span>

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L609">            System.out.format(</span>
                &quot;AFTER oracle2 target=%d  reg.size=%d  hash.length=%d\n&quot;, 
<span class="nc" id="L611">                target, reg.size, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L612">            qureg.quantum_print_qureg(reg);</span>
        }

        // amplify the state with high bit set       
                
        /*
        double avg = 0;
        for (int j = 0; j &lt; reg.size; ++j) {
            avg += reg.node[j].amplitude.re();
        }
        avg /= (double) reg.size;
        */
        
        // NOTE: not knowing the avg from quantum methods, assume it
        //       to be the normalization
        // NOTE: also, assuming that an amplifier is available and a
        //       beam splitter or the equivalent
<span class="fc" id="L629">        double avg = 1./Math.sqrt(reg.size);</span>

        // change amplitudes by their difference from avg
<span class="fc bfc" id="L632" title="All 2 branches covered.">        for (int j = 0; j &lt; reg.size; ++j) {</span>
<span class="fc" id="L633">            double a = reg.node[j].amplitude.re();</span>
            // a = 2*avg - a
<span class="fc" id="L635">            reg.node[j].amplitude.setReal(2. * avg - a);</span>
<span class="fc" id="L636">            reg.node[j].amplitude.times(1./Math.sqrt(2.));</span>
        }
        
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L640">            double sum = 0;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            for (i = 0; i &lt; reg.size; ++i) {</span>
<span class="nc" id="L642">                sum += reg.node[i].amplitude.squareSum();</span>
            }
<span class="nc" id="L644">            System.out.println(&quot;sum of squares=&quot; + sum);</span>
        }
        
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L648">            System.out.format(</span>
                &quot;AFTER grover target=%d reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L650">                target, reg.size, reg.width);</span>
<span class="nc" id="L651">            qureg.quantum_print_qureg(reg);</span>
        }
<span class="fc" id="L653">    }</span>

    /** runtime complexity is O(reg.size * reg.width) * nLoop
       (the runtime complexity of the preparation of the register 
     * is ignored.  it is O(2^width)).
     * Note that nLoop is (Math.PI / 4) * Math.sqrt(2^width)
     * where width is (the bit length of number) + 1
     * 
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^(number bit length + 1)
    */
    public int run(int number) {

<span class="nc" id="L666">        int width = MiscMath.numberOfBits(number + 1);</span>

<span class="nc" id="L668">        return run(number, width);</span>
    }

    /**
     * runtime complexity is O(reg.size * reg.width) * nLoop.
     * Note that nLoop is (Math.PI / 4) * Math.sqrt(2^width).
     * (the runtime complexity of the preparation of the register 
     * is ignored.  it is O(2^width)).
     * 
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^width.
     * @param width largest bit length to use in enumeration.
     * NOTE that if it is less than (the bit length of number) + 1,
     * it will be increased to that.
     * @return 
     */
    public int run(int number, int width) {

        int i;

<span class="fc" id="L688">        final int N = number;</span>

<span class="fc" id="L690">        Random rng = Misc.getSecureRandom();</span>

<span class="fc" id="L692">        Gates gates = new Gates(rng);</span>

<span class="fc" id="L694">        int tmp = MiscMath.numberOfBits(N + 1);</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if (width &lt; tmp) {</span>
<span class="nc" id="L696">            width = tmp;</span>
        }
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        if (width &lt; 2) {</span>
<span class="nc" id="L699">            width = 2;</span>
        }
<span class="fc" id="L701">        width0 = width;</span>

<span class="fc" id="L703">        QuReg qureg = new QuReg();</span>

<span class="fc" id="L705">        QuantumReg reg = qureg.quantum_new_qureg(0, width0);</span>

<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L708">            System.out.format(</span>
                &quot;AFTER construction  reg.size=%d reg.width=%d hash.length=%d\n&quot;, 
<span class="nc" id="L710">                reg.size, reg.width, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L711">            qureg.quantum_print_qureg(reg);</span>
        }
        
        //Flip the target bit of each basis state, reg.width
        //runtime complexity is O(reg.size) (because decoherence lambda is 0.0).
<span class="fc" id="L716">        qureg.quantum_addscratch(1, reg);</span>
<span class="fc" id="L717">        reg.width *= 2;</span>
<span class="fc" id="L718">        reg.width += 2;</span>
<span class="fc" id="L719">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
<span class="fc" id="L720">        gates.quantum_sigma_x(width0, reg);</span>
        
<span class="fc" id="L722">        System.out.format(&quot;N = %d, width0=%d reg.width=%d\n&quot;, N, width0,</span>
<span class="fc" id="L723">            reg.width);</span>

<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (debug) {</span>
            //DEBUG
<span class="nc" id="L727">            System.out.format(&quot;AFTER sigma_x  reg.size=%d reg.width=%d\n&quot;, </span>
<span class="nc" id="L728">                reg.size, reg.width);</span>
<span class="nc" id="L729">            qureg.quantum_print_qureg(reg);</span>
        }

        //runtime complexity is O(reg.size * reg.width)
<span class="fc bfc" id="L733" title="All 2 branches covered.">        for (i = 0; i &lt; width0 + 1; i++) {</span>
<span class="fc" id="L734">            gates.quantum_hadamard(i, reg);</span>
        }
        
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L738">            System.out.format(</span>
                &quot;AFTER 1st hadamard gates  reg.size=%d reg.width=%d hash.length=%d\n&quot;, 
<span class="nc" id="L740">                reg.size, reg.width, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L741">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="pc bpc" id="L744" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L745">            System.out.format(&quot;AFTER 2 1st hadamard gates  reg.size=%d reg.width=%d hash.length=%d\n&quot;, </span>
<span class="nc" id="L746">                reg.size, reg.width, 1 &lt;&lt; reg.hashw);</span>
<span class="nc" id="L747">            qureg.quantum_print_qureg(reg);</span>
        }

<span class="fc" id="L750">        return search(number, rng, gates, qureg, reg);</span>
    }
    
    private int search(int number, Random rng, Gates gates, QuReg qureg, 
        QuantumReg reg) {
        
        int i;
        
        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
<span class="fc" id="L760">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; width0));</span>

<span class="fc" id="L762">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="fc bfc" id="L765" title="All 2 branches covered.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L768">                System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            }
            
<span class="fc" id="L771">            grover(number, reg, gates, qureg);</span>
        }

<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (debug) { //DEBUG</span>
<span class="nc" id="L775">            System.out.format(</span>
                &quot;AFTER grover  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L777">                reg.size, reg.width);</span>
<span class="nc" id="L778">            qureg.quantum_print_qureg(reg);</span>
        }
        

<span class="fc" id="L782">        gates.quantum_hadamard(width0, reg);</span>


<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (debug) {//DEBUG//DEBUG</span>
<span class="nc" id="L786">            System.out.format(</span>
                &quot;AFTER last hadamard  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L788">                reg.size, reg.width);</span>
<span class="nc" id="L789">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="fc" id="L792">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="fc" id="L795">        measure.quantum_bmeasure(width0, reg, rng);</span>

        //DEBUG
<span class="fc" id="L798">        System.out.format(</span>
            &quot;AFTER bmeasure reg.size=%d reg.width=%d\n&quot;, 
<span class="fc" id="L800">            reg.size, reg.width);</span>
<span class="fc" id="L801">        qureg.quantum_print_qureg(reg);</span>


<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">            if (reg.node[i].state == number) {</span>
<span class="fc" id="L806">                System.out.format(</span>
<span class="fc" id="L807">                    &quot;\nFound %d with a probability of %f\n\n&quot;, number,</span>
<span class="fc" id="L808">                    reg.node[i].amplitude.squareSum());</span>
<span class="fc" id="L809">                return number;</span>
            }
        }

<span class="nc" id="L813">        return -1;</span>
    }
    
    // ---- adding ability to find number within a list of numbers for use 
    //      within the quantum min algorithm ----
    
    /**
     * runtime complexity for the search 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N), 
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * @param number a number to search for in the enumeration of numbers
     * from 0 to 2^width.
     * @param width largest bit length to use in enumeration.
     * NOTE that if it is less than (the bit length of number) + 1,
     * it will be increased to that.
     * @param list a list of unordered numbers to search for number within.
     * NOTE that the list must be valid input.
     * @return 
     */
    public int run(int number, int width, int[] list) {

<span class="fc" id="L840">        int N = number;</span>
        int i;
        
<span class="fc" id="L843">        int tmp = MiscMath.numberOfBits(N);</span>
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">        if (width &lt; tmp) {</span>
<span class="nc" id="L845">            width = tmp;</span>
        }
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        if (width &lt; 2) {</span>
<span class="nc" id="L848">            width = 2;</span>
        }
<span class="fc" id="L850">        width0 = width;</span>
        
<span class="fc" id="L852">        QuReg qureg = new QuReg();</span>

<span class="fc" id="L854">        Random rng = Misc.getSecureRandom();</span>
        
        int ret;
        
        if (false) {
            
            QuantumReg reg = initializeRegister(qureg, list);

            System.out.format(&quot;N = %d, list.length=%d, width0=%d reg.width=%d\n&quot;, N, 
                list.length, width0, reg.width);

            ret = processInitialized(number, reg, rng);

        } else {
            
<span class="fc" id="L869">            QuantumReg reg = initializeRegister2(qureg, list);</span>

<span class="fc" id="L871">            System.out.format(&quot;N = %d, list.length=%d, width0=%d reg.width=%d\n&quot;, N, </span>
<span class="fc" id="L872">                list.length, width0, reg.width);</span>

<span class="fc" id="L874">            ret = processInitialized2(number, reg, rng);</span>
        }
        
<span class="fc" id="L877">        return ret;</span>
    }
    
    public int run(int number, int width, int setQuBits) {
    
<span class="fc" id="L882">        width0 = width;</span>
        
<span class="fc" id="L884">        QuReg qureg = new QuReg();</span>
<span class="fc" id="L885">        QuantumReg reg = initializeRegister(qureg, setQuBits);</span>
        
<span class="fc" id="L887">        System.out.format(&quot;N = %d, width0=%d reg.width=%d\n&quot;, number, </span>
<span class="fc" id="L888">            width0, reg.width);</span>
        
<span class="fc" id="L890">        Random rng = Misc.getSecureRandom();</span>
        
<span class="fc" id="L892">        int ret = processInitialized2(number, reg, rng);</span>
        
<span class="fc" id="L894">        return ret;</span>
    }
    
    /**
     * Initialize the register with a list of numbers.
     * Note, that the register, as the possible states of superposition of
     * qubits, will have all possible permutation of the qubits up to the
     * power of 2 or next higher power of 2 in the list.
     * A continuous sequence of numbers from 0 up to a power of 2 is valid 
     * input for the current logic (can be unordered).
     * A continuous sequence of numbers from a power of 2 up to a power of 2.
     * is valid input.
     */
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param stateList
     * @param amplList amplitudes associated with the eigenstate at same index
     * in stateList
     * @return 
     */
    public QuantumReg initializeRegister(QuReg qureg, 
        ComplexModifiable[] amplList, int[] stateList) {
      
<span class="nc" id="L921">        final int initSize = 2 * amplList.length;</span>

<span class="nc" id="L923">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width0);</span>
<span class="nc" id="L924">        reg.width *= 2;</span>
<span class="nc" id="L925">        reg.width += 2;</span>
<span class="nc" id="L926">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
        //need to initialize a register to have the given states from list
        //and a set of the same numbers but with negative amplitude and
        //the next highest bit set, that is width + 1
        //    rest of the algorithm should proceed in same manner.
        
<span class="nc" id="L933">        int offset = 1 &lt;&lt; width0;</span>
        
        int i;
<span class="nc" id="L936">        double invSqrt = 1./Math.sqrt(2.);</span>
        
<span class="nc bnc" id="L938" title="All 2 branches missed.">        for (i = 0; i &lt; amplList.length; ++i) {</span>
<span class="nc" id="L939">            reg.node[i].state = stateList[i];</span>
<span class="nc" id="L940">            reg.node[i].state |= offset;</span>
<span class="nc" id="L941">            reg.node[i].amplitude.resetTo(amplList[i]);</span>
<span class="nc" id="L942">            reg.node[i].amplitude.times(-invSqrt);</span>
        }
        
<span class="nc" id="L945">        int idx = amplList.length;</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">        for (i = 0; i &lt; amplList.length; ++i) {</span>
<span class="nc" id="L947">            reg.node[idx].state = stateList[i];</span>
<span class="nc" id="L948">            reg.node[idx].amplitude.resetTo(amplList[i]);</span>
<span class="nc" id="L949">            reg.node[idx].amplitude.times(invSqrt);</span>
<span class="nc" id="L950">            idx++;</span>
        }
        
<span class="nc" id="L953">        return reg;</span>
    }
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param setBits
     * @return 
     */
    public QuantumReg initializeRegister(QuReg qureg, int setBits) {
       
<span class="fc" id="L966">        int nBits = MiscMath.numberOfBits(setBits);</span>
        
        int i;
        
<span class="fc" id="L970">        int nSetBits = 0;</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">        for (i = 0; i &lt; nBits; ++i) {</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">            if ((setBits &amp; (1 &lt;&lt; i)) != 0) {</span>
<span class="fc" id="L973">                nSetBits++;</span>
            }
        }
        
<span class="fc" id="L977">        QuantumReg reg = qureg.quantum_new_qureg_size(</span>
            nSetBits, width0);

<span class="fc" id="L980">        reg.width *= 2;</span>
<span class="fc" id="L981">        reg.width += 2;</span>
<span class="fc" id="L982">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
<span class="fc" id="L984">        double norm = 1./Math.sqrt(nSetBits);  </span>
<span class="fc" id="L985">        int ii = 0;</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">        for (i = 0; i &lt; nBits; ++i) {</span>
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">            if ((setBits &amp; (1 &lt;&lt; i)) != 0) {</span>
                //initializing with same state + highbit off of register
<span class="fc" id="L989">                reg.node[ii].state = (1 &lt;&lt; i);</span>
<span class="fc" id="L990">                reg.node[ii].amplitude.setReal(norm);</span>
<span class="fc" id="L991">                ++ii;</span>
            }
        }
                
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L996">            System.out.format(&quot;initialized  reg.size=%d reg.width=%d\n&quot;, </span>
<span class="nc" id="L997">                reg.size, reg.width);</span>
<span class="nc" id="L998">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="fc" id="L1001">        return reg;</span>
    }
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param setBits
     * @param width
     * @return 
     */
    private QuantumReg initializeRegister(QuReg qureg, int[] list) {
        
<span class="nc" id="L1015">        int listLen = list.length;</span>
        
<span class="nc" id="L1017">        final int initSize = 2 * listLen;</span>

<span class="nc" id="L1019">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width0);</span>

<span class="nc" id="L1021">        reg.width *= 2;</span>
<span class="nc" id="L1022">        reg.width += 2;</span>
<span class="nc" id="L1023">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
        //need to initialize a register to have the given states from list
        //and a set of the same numbers but with negative amplitude and
        //the next highest bit set, that is width + 1
        //    rest of the algorithm should proceed in same manner.
                
<span class="nc" id="L1030">        int offset = 1 &lt;&lt; width0;</span>
        
        int i;
        
<span class="nc" id="L1034">        double norm = 1./Math.sqrt(initSize);  </span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="nc" id="L1036">            reg.node[i].state = list[i] + offset;</span>
<span class="nc" id="L1037">            reg.node[i].amplitude.setReal(-norm);</span>
        }
<span class="nc" id="L1039">        int ii = list.length;</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="nc" id="L1041">            reg.node[ii].state = list[i];</span>
<span class="nc" id="L1042">            reg.node[ii].amplitude.setReal(norm);</span>
<span class="nc" id="L1043">            ii++;</span>
        }
        
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L1047">            System.out.format(&quot;AFTER init reg.size=%d &quot;</span>
<span class="nc" id="L1048">                + &quot; width0=%d reg.width=%d reg.hash.length=%d\n&quot;, reg.size,</span>
<span class="nc" id="L1049">                width0, reg.width, (1 &lt;&lt; reg.hashw));</span>
<span class="nc" id="L1050">            qureg.quantum_print_qureg(reg);</span>
        }
       
<span class="nc" id="L1053">        return reg;</span>
    }
    
    /**
     * Initialize the register with a list of numbers as the eigenstate,
     * superposition, and their amplitudes.
     *
     * @param qureg
     * @param setBits
     * @param width
     * @return 
     */
    private QuantumReg initializeRegister2(QuReg qureg, int[] list) {
        
<span class="fc" id="L1067">        int listLen = list.length;</span>
        
<span class="fc" id="L1069">        final int initSize = listLen;</span>

<span class="fc" id="L1071">        QuantumReg reg = qureg.quantum_new_qureg_size(initSize, width0);</span>

<span class="fc" id="L1073">        reg.width *= 2;</span>
<span class="fc" id="L1074">        reg.width += 2;</span>
<span class="fc" id="L1075">        qureg.quantum_expand_and_reconstruct_hash(reg);</span>
        
        //need to initialize a register to have the given states from list
        //and a set of the same numbers but with negative amplitude and
        //the next highest bit set, that is width + 1
        //    rest of the algorithm should proceed in same manner.
                
        int i;
        
<span class="fc" id="L1084">        double norm = 1./Math.sqrt(initSize);  </span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        for (i = 0; i &lt; list.length; ++i) {</span>
<span class="fc" id="L1086">            reg.node[i].state = list[i];</span>
<span class="fc" id="L1087">            reg.node[i].amplitude.setReal(norm);</span>
        }
        
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">        if (debug) {//DEBUG</span>
<span class="nc" id="L1091">            System.out.format(&quot;AFTER init reg.size=%d &quot;</span>
<span class="nc" id="L1092">                + &quot; width0=%d reg.width=%d reg.hash.length=%d\n&quot;, reg.size,</span>
<span class="nc" id="L1093">                width0, reg.width, (1 &lt;&lt; reg.hashw));</span>
<span class="nc" id="L1094">            qureg.quantum_print_qureg(reg);</span>
        }
       
<span class="fc" id="L1097">        return reg;</span>
    }
    
    /**
     * runtime complexity for the processing 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N),
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * NOTE that measurements of register reg are not taken.
     * @param number a number to search for within the initialized register reg
     * @param reg initialized register which holds nodes of state which are 
     * searched and have amplitudes which when squared and summed over register 
     * are equal to 1.
     * @param rng
     * @return
     */
    public int processInitialized(int number, QuantumReg reg, Random rng) {
        
        int i;

<span class="nc" id="L1122">        final int N = number;</span>

<span class="nc" id="L1124">        QuReg qureg = new QuReg();</span>
        
        //DEBUG
        //System.out.format(&quot;AFTER construction  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
        //  NOTE that if the number of times number will appear in list
        //     is known ahead of time,
        //     the term in the sqrt can be divided by that multiplicity.
<span class="nc" id="L1135">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; width0));</span>

<span class="nc" id="L1137">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

<span class="nc" id="L1139">        Gates gates = new Gates(rng);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="nc bnc" id="L1144" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L1145">                System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            }
            
<span class="nc" id="L1148">            grover(N, reg, gates, qureg);</span>
        }

<span class="nc bnc" id="L1151" title="All 2 branches missed.">        if (debug) { //DEBUG</span>
<span class="nc" id="L1152">            System.out.format(</span>
                &quot;AFTER grover  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1154">                reg.size, reg.width);</span>
<span class="nc" id="L1155">            qureg.quantum_print_qureg(reg);</span>
        }
        

<span class="nc" id="L1159">        gates.quantum_hadamard(width0, reg);</span>


<span class="nc bnc" id="L1162" title="All 2 branches missed.">        if (debug) {//DEBUG//DEBUG</span>
<span class="nc" id="L1163">            System.out.format(</span>
                &quot;AFTER last hadamard  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1165">                reg.size, reg.width);</span>
<span class="nc" id="L1166">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="nc" id="L1169">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="nc" id="L1172">        measure.quantum_bmeasure(width0, reg, rng);</span>

        //DEBUG
<span class="nc" id="L1175">        System.out.format(</span>
            &quot;AFTER bmeasure reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1177">            reg.size, reg.width);</span>
<span class="nc" id="L1178">        qureg.quantum_print_qureg(reg);</span>


<span class="nc bnc" id="L1181" title="All 2 branches missed.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (reg.node[i].state == N) {</span>
<span class="nc" id="L1183">                System.out.format(</span>
<span class="nc" id="L1184">                    &quot;\nFound %d with a probability of %f\n\n&quot;, N,</span>
<span class="nc" id="L1185">                    reg.node[i].amplitude.squareSum());</span>
<span class="nc" id="L1186">                return number;</span>
            }
        }

<span class="nc" id="L1190">        return -1;</span>
    }

    /**
     * runtime complexity for the processing 
     * is O(reg.size * reg.width) * nLoop
     * (the runtime complexity of the preparation of the register for the list, 
     * O(N),
     * is ignored just as in the enumerated run method).
     * NOTE that the width should be set to the most number of bits needed
     * for any number in list. 
     * NOTE also that the largest number in the list must be
     * .lte. integer.max_value - 2^width.
     * NOTE that measurements of register reg are not taken.
     * @param number a number to search for within the initialized register reg
     * @param reg initialized register which holds nodes of state which are 
     * searched and have amplitudes which when squared and summed over register 
     * are equal to 1.
     * @param rng
     * @return
     */
    public int processInitialized2(int number, QuantumReg reg, Random rng) {
        
        int i;

<span class="fc" id="L1215">        final int N = number;</span>

<span class="fc" id="L1217">        QuReg qureg = new QuReg();</span>
        
        //DEBUG
        //System.out.format(&quot;AFTER construction  reg.size=%d\n&quot;, reg.size);
        //qureg.quantum_print_qureg(reg);

        // upper limit to number of iterations from:
        //&quot;Tight Bounds on Quantum Searching&quot; by Boyer, Brassard, Hoyer, and Tapp 
        //  NOTE that if the number of times number will appear in list
        //     is known ahead of time,
        //     the term in the sqrt can be divided by that multiplicity.
<span class="fc" id="L1228">        int end = (int) (Math.PI / 4 * Math.sqrt(1 &lt;&lt; width0));</span>

<span class="fc" id="L1230">        System.out.format(&quot;Iterating %d times\n&quot;, end);</span>

<span class="fc" id="L1232">        Gates gates = new Gates(rng);</span>

        //runtime complexity is O(reg.size * reg.width) * nLoop
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        for (i = 1; i &lt;= end; i++) {</span>
            
<span class="pc bpc" id="L1237" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L1238">                System.out.format(&quot;Iteration #%d\n&quot;, i);</span>
            }
            
<span class="fc" id="L1241">            grover2(N, reg, gates, qureg);</span>
        }

<span class="pc bpc" id="L1244" title="1 of 2 branches missed.">        if (debug) { //DEBUG</span>
<span class="nc" id="L1245">            System.out.format(</span>
                &quot;AFTER grover  reg.size=%d reg.width=%d\n&quot;, 
<span class="nc" id="L1247">                reg.size, reg.width);</span>
<span class="nc" id="L1248">            qureg.quantum_print_qureg(reg);</span>
        }
        
<span class="fc" id="L1251">        Measure measure = new Measure();</span>

        // runtime complexity is O(reg.size)
<span class="fc" id="L1254">        measure.quantum_bmeasure(width0, reg, rng);</span>

        //DEBUG
<span class="fc" id="L1257">        System.out.format(</span>
            &quot;AFTER bmeasure reg.size=%d reg.width=%d\n&quot;, 
<span class="fc" id="L1259">            reg.size, reg.width);</span>
<span class="fc" id="L1260">        qureg.quantum_print_qureg(reg);</span>


<span class="fc bfc" id="L1263" title="All 2 branches covered.">        for (i = 0; i &lt; reg.size; i++) {</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">            if (reg.node[i].state == N) {</span>
<span class="fc" id="L1265">                System.out.format(</span>
<span class="fc" id="L1266">                    &quot;\nFound %d with a probability of %f\n\n&quot;, N,</span>
<span class="fc" id="L1267">                    reg.node[i].amplitude.squareSum());</span>
<span class="fc" id="L1268">                return number;</span>
            }
        }

<span class="fc" id="L1272">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
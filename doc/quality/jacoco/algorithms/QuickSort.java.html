<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QuickSort.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">QuickSort.java</span></div><h1>QuickSort.java</h1><pre class="source lang-java linenums">package algorithms;

import algorithms.util.IntIntDouble;
import algorithms.util.PairInt;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import java.util.List;

/**
 *
 * @author nichole
 */
<span class="nc" id="L14">public class QuickSort {</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * @param a
     */
    public static void sort(float[] a) {
<span class="fc" id="L21">        sort(a, 0, a.length - 1);</span>
<span class="fc" id="L22">    }</span>
    
    public static void descendingSort(int[] a, int[] b) {
        
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L27">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L29" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L30">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L33">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L36">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="fc" id="L37">    }</span>
    
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b) {
        
<span class="nc bnc" id="L41" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L42">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L44" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L45">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L47" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L48">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L51">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="nc" id="L52">    }</span>
    
    public static void descendingSort(TIntList a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L57">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L60">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L63">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L66">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L67">    }</span>
    
    public static void descendingSort(List&lt;? extends Number&gt; a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L72">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L75">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L78">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L81">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L82">    }</span>
    
    public static void descendingSort(double[] a) {
        
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L87">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
        
<span class="fc" id="L90">        descendingSort(a, 0, a.length - 1);</span>
<span class="fc" id="L91">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[][] b) {
        
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L96">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L99">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L105">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="nc" id="L106">    }</span>
    
    public static void sortBy1stArg(int[] a, int[] b) {
        
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L111">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L114">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L117">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L120">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L121">    }</span>
    
    public static void sortByA(IntIntDouble[] abc) {
        
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="fc" id="L129">        sortByA(abc, 0, abc.length - 1);</span>
<span class="fc" id="L130">    }</span>
    
    public static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b) {
    
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L135">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L138">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L141">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L144">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L145">    }</span>

    /**
     * sort a by ascending values and perform the same swap operation on b.
     * @param a
     * @param b 
     */
    public static void sortBy1stArg(float[] a, int[] b) {
        
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L155">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L158">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L161">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L164">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L165">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[] b) {
        
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L170">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L179">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L180">    }</span>
    
    public static void sortBy1stArg(float[] a, Object[] b) {
        
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L188">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L191">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L194">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L195">    }</span>
    
    public static void sortBy1stArg(TDoubleList a, int[] b) {
        
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L200">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L206">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L209">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L210">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b) {

<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L215">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L218">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L224">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="nc" id="L225">    }</span>
    
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b) {

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L233">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L236">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L239">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L240">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b, TIntList c) {

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L248">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L251">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L253" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L254">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L257">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L258">    }</span>
    
    public static void sortBy1stArg(TIntList a, TDoubleList b,
        TIntList c) {
        
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L264">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L267">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L270">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L273">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L276">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="fc" id="L279">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L280">    }</span>
    
    public static void sortBy1stArg(TIntList a, TIntList b) {
        
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L285">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L288">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L291">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L294">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L295">    }</span>
    
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
<span class="fc" id="L298">        sortBy1stArgDesc(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L299">    }</span>
    
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L305">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L308">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L317">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L321">            return;</span>
        }
        
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L326">            int x = a[idxLo];</span>
<span class="fc" id="L327">            int store = idxLo;</span>
<span class="fc" id="L328">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L332">                    store++;     </span>
<span class="fc bfc" id="L333" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt;= x));</span>
                do {
<span class="fc" id="L335">                    idxMid--;</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                } while (a[idxMid] &lt;= x);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L338">                    break;</span>
                }
<span class="fc" id="L340">                int swap = a[store];</span>
<span class="fc" id="L341">                a[store] = a[idxMid];</span>
<span class="fc" id="L342">                a[idxMid] = swap;</span>
                
<span class="fc" id="L344">                T swap2 = b.get(store);</span>
<span class="fc" id="L345">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L346">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L348">                S swap3 = c.get(store);</span>
<span class="fc" id="L349">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L350">                c.set(idxMid, swap3);</span>
                
<span class="fc" id="L352">            }</span>
            
<span class="fc" id="L354">            int swap = a[idxLo];</span>
<span class="fc" id="L355">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L356">            a[idxMid] = swap;</span>

<span class="fc" id="L358">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L359">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L360">            b.set(idxMid, swap2);</span>

<span class="fc" id="L362">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L363">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L364">            c.set(idxMid, swap3);</span>
         
<span class="fc" id="L366">            sortBy1stArgDesc(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L368">            sortBy1stArgDesc(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L370">    }</span>

    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L384">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L387">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L390">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L393">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L396">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L400">            return;</span>
        }
        
<span class="fc bfc" id="L403" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L405">            int x = a.get(idxLo);</span>
<span class="fc" id="L406">            int store = idxLo;</span>
<span class="fc" id="L407">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L411">                    store++;     </span>
<span class="fc bfc" id="L412" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L414">                    idxMid--;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L417">                    break;</span>
                }
<span class="nc" id="L419">                int swap = a.get(store);</span>
<span class="nc" id="L420">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L421">                a.set(idxMid, swap);</span>
<span class="nc" id="L422">                swap = c.get(store);</span>
<span class="nc" id="L423">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L424">                c.set(idxMid, swap);</span>
                
<span class="nc" id="L426">                double bSwap = b.get(store);</span>
<span class="nc" id="L427">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L428">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L429">            }</span>
<span class="fc" id="L430">            int swap = a.get(idxLo);</span>
<span class="fc" id="L431">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L432">            a.set(idxMid, swap);</span>
<span class="fc" id="L433">            swap = c.get(idxLo);</span>
<span class="fc" id="L434">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L435">            c.set(idxMid, swap);</span>
            
<span class="fc" id="L437">            double bSwap = b.get(idxLo);</span>
<span class="fc" id="L438">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L439">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L441">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L443">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L445">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b,  
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L459">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L462">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L465">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L468">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L471">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L475">            return;</span>
        }
        
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L480">            float x = a.get(idxLo);</span>
<span class="fc" id="L481">            int store = idxLo;</span>
<span class="fc" id="L482">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L486">                    store++;     </span>
<span class="fc bfc" id="L487" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L489">                    idxMid--;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L492">                    break;</span>
                }
<span class="nc" id="L494">                float swap = a.get(store);</span>
<span class="nc" id="L495">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L496">                a.set(idxMid, swap);</span>
<span class="nc" id="L497">                int swap2 = c.get(store);</span>
<span class="nc" id="L498">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L499">                c.set(idxMid, swap2);</span>
                
<span class="nc" id="L501">                swap2 = b.get(store);</span>
<span class="nc" id="L502">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L503">                b.set(idxMid, swap2);</span>
<span class="nc" id="L504">            }</span>
<span class="fc" id="L505">            float swap = a.get(idxLo);</span>
<span class="fc" id="L506">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L507">            a.set(idxMid, swap);</span>
<span class="fc" id="L508">            int swap2 = c.get(idxLo);</span>
<span class="fc" id="L509">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L510">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L512">            swap2 = b.get(idxLo);</span>
<span class="fc" id="L513">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L514">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L516">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L518">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L520">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, 
        int idxLo, int idxHi) {
        
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L534">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L537">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L540">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L544">            return;</span>
        }
        
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L549">            float x = a.get(idxLo);</span>
<span class="nc" id="L550">            int store = idxLo;</span>
<span class="nc" id="L551">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L555">                    store++;     </span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="nc" id="L558">                    idxMid--;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                } while (a.get(idxMid) &gt; x);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L561">                    break;</span>
                }
<span class="nc" id="L563">                float swap = a.get(store);</span>
<span class="nc" id="L564">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L565">                a.set(idxMid, swap);</span>
<span class="nc" id="L566">                int swap2 = b.get(store);</span>
<span class="nc" id="L567">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L568">                b.set(idxMid, swap2);</span>
                
<span class="nc" id="L570">            }</span>
<span class="nc" id="L571">            float swap = a.get(idxLo);</span>
<span class="nc" id="L572">            a.set(idxLo, a.get(idxMid));</span>
<span class="nc" id="L573">            a.set(idxMid, swap);</span>
<span class="nc" id="L574">            int bSwap = b.get(idxLo);</span>
<span class="nc" id="L575">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L576">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L578">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L580">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L582">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L596">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L599">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L602">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L606">            return;</span>
        }
        
<span class="fc bfc" id="L609" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L611">            float x = a.get(idxLo);</span>
<span class="fc" id="L612">            int store = idxLo;</span>
<span class="fc" id="L613">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L617">                    store++;     </span>
<span class="fc bfc" id="L618" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L620">                    idxMid--;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L623">                    break;</span>
                }
<span class="fc" id="L625">                float swap = a.get(store);</span>
<span class="fc" id="L626">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L627">                a.set(idxMid, swap);</span>
<span class="fc" id="L628">                T swap2 = b.get(store);</span>
<span class="fc" id="L629">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L630">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L632">            }</span>
<span class="fc" id="L633">            float swap = a.get(idxLo);</span>
<span class="fc" id="L634">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L635">            a.set(idxMid, swap);</span>
<span class="fc" id="L636">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L637">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L638">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L640">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L642">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L644">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TIntList b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L657">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L660">            throw new IllegalArgumentException(&quot;v cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L663">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L667">            return;</span>
        }
        
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L672">            int x = a.get(idxLo);</span>
<span class="fc" id="L673">            int store = idxLo;</span>
<span class="fc" id="L674">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L678">                    store++;     </span>
<span class="fc bfc" id="L679" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L681">                    idxMid--;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L684">                    break;</span>
                }
<span class="nc" id="L686">                int swap = a.get(store);</span>
<span class="nc" id="L687">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L688">                a.set(idxMid, swap);</span>
<span class="nc" id="L689">                swap = b.get(store);</span>
<span class="nc" id="L690">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L691">                b.set(idxMid, swap);</span>
<span class="nc" id="L692">            }</span>
<span class="fc" id="L693">            int swap = a.get(idxLo);</span>
<span class="fc" id="L694">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L695">            a.set(idxMid, swap);</span>
<span class="fc" id="L696">            swap = b.get(idxLo);</span>
<span class="fc" id="L697">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L698">            b.set(idxMid, swap);</span>
         
<span class="fc" id="L700">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L702">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L704">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortByA(IntIntDouble[] abc, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L718">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">        if (abc.length &lt; 2) {</span>
<span class="nc" id="L722">            return;</span>
        }
        
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L727">            int x = abc[idxLo].getA();</span>
<span class="fc" id="L728">            int store = idxLo;</span>
<span class="fc" id="L729">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L733">                    store++;     </span>
<span class="fc bfc" id="L734" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (abc[store].getA() &lt; x));</span>
                do {
<span class="fc" id="L736">                    idxMid--;</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">                } while (abc[idxMid].getA() &gt; x);</span>
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L739">                    break;</span>
                }
<span class="nc" id="L741">                IntIntDouble swap = abc[store];</span>
<span class="nc" id="L742">                abc[store] = abc[idxMid];</span>
<span class="nc" id="L743">                abc[idxMid] = swap;</span>
<span class="nc" id="L744">            }</span>
<span class="fc" id="L745">            IntIntDouble swap = abc[idxLo];</span>
<span class="fc" id="L746">            abc[idxLo] = abc[idxMid];</span>
<span class="fc" id="L747">            abc[idxMid] = swap;</span>
         
<span class="fc" id="L749">            sortByA(abc, idxLo, idxMid - 1);</span>

<span class="fc" id="L751">            sortByA(abc, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L753">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L765">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L768">            return;</span>
        }
<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L772">            float x = a[idxLo];</span>
<span class="fc" id="L773">            int store = idxLo;</span>
<span class="fc" id="L774">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L778">                    store++;     </span>
<span class="fc bfc" id="L779" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L781">                    idxMid--;</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L784">                    break;</span>
                }
<span class="fc" id="L786">                float swap = a[store];</span>
<span class="fc" id="L787">                a[store] = a[idxMid];</span>
<span class="fc" id="L788">                a[idxMid] = swap;</span>
<span class="fc" id="L789">            }</span>
<span class="fc" id="L790">            float swap = a[idxLo];</span>
<span class="fc" id="L791">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L792">            a[idxMid] = swap;</span>
         
<span class="fc" id="L794">            sort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L796">            sort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L798">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L812">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L815">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L818">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L821">            return;</span>
        }
        
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L826">            int x = a[idxLo];</span>
<span class="nc" id="L827">            int store = idxLo;</span>
<span class="nc" id="L828">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L832">                    store++;     </span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="nc" id="L835">                    idxMid--;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                } while (a[idxMid] &lt; x);</span>
                
<span class="nc bnc" id="L838" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L839">                    break;</span>
                }
<span class="nc" id="L841">                int swap = a[store];</span>
<span class="nc" id="L842">                a[store] = a[idxMid];</span>
<span class="nc" id="L843">                a[idxMid] = swap;</span>
<span class="nc" id="L844">                T swap2 = b[store];</span>
<span class="nc" id="L845">                b[store] = b[idxMid];</span>
<span class="nc" id="L846">                b[idxMid] = swap2;</span>
<span class="nc" id="L847">            }</span>
<span class="nc" id="L848">            int swap = a[idxLo];</span>
<span class="nc" id="L849">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L850">            a[idxMid] = swap;</span>
<span class="nc" id="L851">            T swap2 = b[idxLo];</span>
<span class="nc" id="L852">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L853">            b[idxMid] = swap2;</span>
         
<span class="nc" id="L855">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L857">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L859">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L872">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L875">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L878">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L881">            return;</span>
        }
        
<span class="fc bfc" id="L884" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L886">            int x = a[idxLo];</span>
<span class="fc" id="L887">            int store = idxLo;</span>
<span class="fc" id="L888">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L892">                    store++;     </span>
<span class="fc bfc" id="L893" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L895">                    idxMid--;</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L898" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L899">                    break;</span>
                }
<span class="fc" id="L901">                int swap = a[store];</span>
<span class="fc" id="L902">                a[store] = a[idxMid];</span>
<span class="fc" id="L903">                a[idxMid] = swap;</span>
<span class="fc" id="L904">                swap = b[store];</span>
<span class="fc" id="L905">                b[store] = b[idxMid];</span>
<span class="fc" id="L906">                b[idxMid] = swap;</span>
<span class="fc" id="L907">            }</span>
<span class="fc" id="L908">            int swap = a[idxLo];</span>
<span class="fc" id="L909">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L910">            a[idxMid] = swap;</span>
<span class="fc" id="L911">            swap = b[idxLo];</span>
<span class="fc" id="L912">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L913">            b[idxMid] = swap;</span>
         
<span class="fc" id="L915">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L917">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L919">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param &lt;T&gt;
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(
        TIntList a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L935">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L938">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L941">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L944">            return;</span>
        }
        
<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L949">            int x = a.get(idxLo);</span>
<span class="fc" id="L950">            int store = idxLo;</span>
<span class="fc" id="L951">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L955">                    store++;     </span>
<span class="pc bpc" id="L956" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &gt; x));</span>
                do {
<span class="fc" id="L958">                    idxMid--;</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">                } while (a.get(idxMid) &lt; x);</span>
                
<span class="fc bfc" id="L961" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L962">                    break;</span>
                }
<span class="fc" id="L964">                int swap = a.get(store);</span>
<span class="fc" id="L965">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L966">                a.set(idxMid, swap);</span>
<span class="fc" id="L967">                T swap2 = b.get(store);</span>
<span class="fc" id="L968">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L969">                b.set(idxMid, swap2);</span>
<span class="fc" id="L970">            }</span>
<span class="fc" id="L971">            int swap = a.get(idxLo);</span>
<span class="fc" id="L972">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L973">            a.set(idxMid, swap);</span>
<span class="fc" id="L974">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L975">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L976">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L978">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L980">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L982">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;S extends Number, T extends Object&gt; void descendingSort(
        List&lt;S&gt; a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L996">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L999">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1002">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1005">            return;</span>
        }
        
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1010">            float x = a.get(idxLo).floatValue();</span>
<span class="fc" id="L1011">            int store = idxLo;</span>
<span class="fc" id="L1012">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1016">                    store++;     </span>
<span class="fc bfc" id="L1017" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store).floatValue() &gt; x));</span>
                do {
<span class="fc" id="L1019">                    idxMid--;</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                } while (a.get(idxMid).floatValue() &lt; x);</span>
                
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1023">                    break;</span>
                }
<span class="fc" id="L1025">                S swap = a.get(store);</span>
<span class="fc" id="L1026">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1027">                a.set(idxMid, swap);</span>
<span class="fc" id="L1028">                T swap2 = b.get(store);</span>
<span class="fc" id="L1029">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1030">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1031">            }</span>
<span class="fc" id="L1032">            S swap = a.get(idxLo);</span>
<span class="fc" id="L1033">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1034">            a.set(idxMid, swap);</span>
<span class="fc" id="L1035">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1036">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1037">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1039">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1041">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1043">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(double[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1056">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1059">            return;</span>
        }
        
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1064">            double x = a[idxLo];</span>
<span class="fc" id="L1065">            int store = idxLo;</span>
<span class="fc" id="L1066">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1070">                    store++;     </span>
<span class="fc bfc" id="L1071" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1073">                    idxMid--;</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1077">                    break;</span>
                }
<span class="fc" id="L1079">                double swap = a[store];</span>
<span class="fc" id="L1080">                a[store] = a[idxMid];</span>
<span class="fc" id="L1081">                a[idxMid] = swap;</span>
<span class="fc" id="L1082">            }</span>
<span class="fc" id="L1083">            double swap = a[idxLo];</span>
<span class="fc" id="L1084">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1085">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1087">            descendingSort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1089">            descendingSort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1091">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1105">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1108">            return;</span>
        }
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1112">            float x = a[idxLo];</span>
<span class="fc" id="L1113">            int store = idxLo;</span>
<span class="fc" id="L1114">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1118">                    store++;     </span>
<span class="fc bfc" id="L1119" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1121">                    idxMid--;</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1124">                    break;</span>
                }
<span class="fc" id="L1126">                float swap = a[store];</span>
<span class="fc" id="L1127">                a[store] = a[idxMid];</span>
<span class="fc" id="L1128">                a[idxMid] = swap;</span>
<span class="fc" id="L1129">                int swap2 = b[store];</span>
<span class="fc" id="L1130">                b[store] = b[idxMid];</span>
<span class="fc" id="L1131">                b[idxMid] = swap2;</span>
<span class="fc" id="L1132">            }</span>
<span class="fc" id="L1133">            float swap = a[idxLo];</span>
<span class="fc" id="L1134">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1135">            a[idxMid] = swap;</span>
<span class="fc" id="L1136">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1137">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1138">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1140">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1142">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1144">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TDoubleList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1158">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1161">            return;</span>
        }
<span class="fc bfc" id="L1163" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1165">            double x = a.get(idxLo);</span>
<span class="fc" id="L1166">            int store = idxLo;</span>
<span class="fc" id="L1167">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1171">                    store++;     </span>
<span class="fc bfc" id="L1172" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L1174">                    idxMid--;</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1177">                    break;</span>
                }
<span class="fc" id="L1179">                double swap = a.get(store);</span>
<span class="fc" id="L1180">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1181">                a.set(idxMid, swap);</span>
<span class="fc" id="L1182">                int swap2 = b[store];</span>
<span class="fc" id="L1183">                b[store] = b[idxMid];</span>
<span class="fc" id="L1184">                b[idxMid] = swap2;</span>
<span class="fc" id="L1185">            }</span>
<span class="fc" id="L1186">            double swap = a.get(idxLo);</span>
<span class="fc" id="L1187">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1188">            a.set(idxMid, swap);</span>
<span class="fc" id="L1189">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1190">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1191">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1193">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1195">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1197">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1211">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1213" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1214">            return;</span>
        }
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1218">            int x = a[idxLo];</span>
<span class="fc" id="L1219">            int store = idxLo;</span>
<span class="fc" id="L1220">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1224">                    store++;     </span>
<span class="fc bfc" id="L1225" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1227">                    idxMid--;</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1230">                    break;</span>
                }
<span class="fc" id="L1232">                int swap = a[store];</span>
<span class="fc" id="L1233">                a[store] = a[idxMid];</span>
<span class="fc" id="L1234">                a[idxMid] = swap;</span>
<span class="fc" id="L1235">                int swap2 = b[store];</span>
<span class="fc" id="L1236">                b[store] = b[idxMid];</span>
<span class="fc" id="L1237">                b[idxMid] = swap2;</span>
<span class="fc" id="L1238">            }</span>
<span class="fc" id="L1239">            int swap = a[idxLo];</span>
<span class="fc" id="L1240">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1241">            a[idxMid] = swap;</span>
<span class="fc" id="L1242">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1243">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1244">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1246">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1248">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1250">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[][] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1263">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1266">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1269">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1272" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1273">            return;</span>
        }
        
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1278">            int x = a[idxLo];</span>
<span class="nc" id="L1279">            int store = idxLo;</span>
<span class="nc" id="L1280">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1284">                    store++;     </span>
<span class="nc bnc" id="L1285" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1287">                    idxMid--;</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1290">                    break;</span>
                }
<span class="nc" id="L1292">                int swap = a[store];</span>
<span class="nc" id="L1293">                a[store] = a[idxMid];</span>
<span class="nc" id="L1294">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1296">                Object[] bSwap = b[store];</span>
<span class="nc" id="L1297">                b[store] = b[idxMid];</span>
<span class="nc" id="L1298">                b[idxMid] = bSwap;</span>
<span class="nc" id="L1299">            }</span>
<span class="nc" id="L1300">            int swap = a[idxLo];</span>
<span class="nc" id="L1301">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1302">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1304">            Object[] bSwap = b[idxLo];</span>
<span class="nc" id="L1305">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1306">            b[idxMid] = bSwap;</span>
         
<span class="nc" id="L1308">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1310">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1312">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
        
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1323">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1325" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1326">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1329">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1332">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L1335">        sortBy1stArg(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L1336">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1349">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1351" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1352">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1355">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1358">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1362">            return;</span>
        }
        
<span class="fc bfc" id="L1365" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1367">            float x = a[idxLo];</span>
<span class="fc" id="L1368">            int store = idxLo;</span>
<span class="fc" id="L1369">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1373">                    store++;     </span>
<span class="fc bfc" id="L1374" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1376">                    idxMid--;</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1379">                    break;</span>
                }
<span class="fc" id="L1381">                float swap = a[store];</span>
<span class="fc" id="L1382">                a[store] = a[idxMid];</span>
<span class="fc" id="L1383">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1385">                T swap2 = b.get(store);</span>
<span class="fc" id="L1386">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1387">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L1389">                S swap3 = c.get(store);</span>
<span class="fc" id="L1390">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L1391">                c.set(idxMid, swap3);</span>
<span class="fc" id="L1392">            }</span>
<span class="fc" id="L1393">            float swap = a[idxLo];</span>
<span class="fc" id="L1394">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1395">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1397">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1398">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1399">            b.set(idxMid, swap2);</span>
               
<span class="fc" id="L1401">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L1402">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L1403">            c.set(idxMid, swap3);</span>
            
<span class="fc" id="L1405">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1407">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1409">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1422">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1425">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1428">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1432">            return;</span>
        }
        
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1437">            int x = a[idxLo];</span>
<span class="fc" id="L1438">            int store = idxLo;</span>
<span class="fc" id="L1439">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1443">                    store++;     </span>
<span class="fc bfc" id="L1444" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1446">                    idxMid--;</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1449">                    break;</span>
                }
<span class="fc" id="L1451">                int swap = a[store];</span>
<span class="fc" id="L1452">                a[store] = a[idxMid];</span>
<span class="fc" id="L1453">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1455">                Object bSwap = b[store];</span>
<span class="fc" id="L1456">                b[store] = b[idxMid];</span>
<span class="fc" id="L1457">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1458">            }</span>
<span class="fc" id="L1459">            int swap = a[idxLo];</span>
<span class="fc" id="L1460">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1461">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1463">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1464">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1465">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1467">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1469">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1471">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1484">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1487">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1490">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1493" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1494">            return;</span>
        }
        
<span class="fc bfc" id="L1497" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1499">            float x = a[idxLo];</span>
<span class="fc" id="L1500">            int store = idxLo;</span>
<span class="fc" id="L1501">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1505">                    store++;     </span>
<span class="fc bfc" id="L1506" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1508">                    idxMid--;</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1511">                    break;</span>
                }
<span class="fc" id="L1513">                float swap = a[store];</span>
<span class="fc" id="L1514">                a[store] = a[idxMid];</span>
<span class="fc" id="L1515">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1517">                T bSwap = b.get(store);</span>
<span class="fc" id="L1518">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1519">                b.set(idxMid, bSwap);</span>
<span class="fc" id="L1520">            }</span>
<span class="fc" id="L1521">            float swap = a[idxLo];</span>
<span class="fc" id="L1522">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1523">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1525">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L1526">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1527">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L1529">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1531">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1533">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1546">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1549">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1552">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc bfc" id="L1555" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1556">            return;</span>
        }
        
<span class="fc bfc" id="L1559" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1561">            float x = a[idxLo];</span>
<span class="fc" id="L1562">            int store = idxLo;</span>
<span class="fc" id="L1563">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1567">                    store++;     </span>
<span class="fc bfc" id="L1568" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1570">                    idxMid--;</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1573">                    break;</span>
                }
<span class="fc" id="L1575">                float swap = a[store];</span>
<span class="fc" id="L1576">                a[store] = a[idxMid];</span>
<span class="fc" id="L1577">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1579">                Object bSwap = b[store];</span>
<span class="fc" id="L1580">                b[store] = b[idxMid];</span>
<span class="fc" id="L1581">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1582">            }</span>
<span class="fc" id="L1583">            float swap = a[idxLo];</span>
<span class="fc" id="L1584">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1585">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1587">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1588">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1589">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1591">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1593">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1595">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * It's an adaption of the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b an array that will receive the same swap operations as are 
     * performed on a
     * @param c an array that will receive the same swap operations as are 
     * performed on a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int[] b, int[] c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1612">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1615">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1618">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1620" title="2 of 4 branches missed.">        if ((a.length != b.length) || (a.length != c.length)) {</span>
<span class="nc" id="L1621">            throw new IllegalArgumentException(&quot;array lengths must be the same&quot;);</span>
        }
        
<span class="fc bfc" id="L1624" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1626">            float x = a[idxLo];</span>
<span class="fc" id="L1627">            int store = idxLo;</span>
<span class="fc" id="L1628">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1632">                    store++;     </span>
<span class="fc bfc" id="L1633" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1635">                    idxMid--;</span>
<span class="fc bfc" id="L1636" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1638">                    break;</span>
                }
<span class="fc" id="L1640">                float swap = a[store];</span>
<span class="fc" id="L1641">                a[store] = a[idxMid];</span>
<span class="fc" id="L1642">                a[idxMid] = swap;</span>
<span class="fc" id="L1643">                int swap2 = b[store];</span>
<span class="fc" id="L1644">                b[store] = b[idxMid];</span>
<span class="fc" id="L1645">                b[idxMid] = swap2;</span>
<span class="fc" id="L1646">                swap2 = c[store];</span>
<span class="fc" id="L1647">                c[store] = c[idxMid];</span>
<span class="fc" id="L1648">                c[idxMid] = swap2;</span>
<span class="fc" id="L1649">            }</span>
<span class="fc" id="L1650">            float swap = a[idxLo];</span>
<span class="fc" id="L1651">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1652">            a[idxMid] = swap;</span>
<span class="fc" id="L1653">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1654">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1655">            b[idxMid] = swap2;</span>
<span class="fc" id="L1656">            swap2 = c[idxLo];</span>
<span class="fc" id="L1657">            c[idxLo] = c[idxMid];</span>
<span class="fc" id="L1658">            c[idxMid] = swap2;</span>
                     
<span class="fc" id="L1660">            sort(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1662">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1664">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecond(int[][] a) {
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1673">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1676">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1679">            return;</span>
        }
<span class="fc" id="L1681">        sortByDimension1FirstSecond(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1682">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecond(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1693">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1696">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1698" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1699">            return;</span>
        }
<span class="fc bfc" id="L1701" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1702">            int idxMid = partitionByDimension1FirstSecond(a, idxLo, idxHi);</span>
<span class="fc" id="L1703">            sortByDimension1FirstSecond(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1704">            sortByDimension1FirstSecond(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1706">    }</span>
    
    private static int partitionByDimension1FirstSecond(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1711">        int x = a[0][idxHi];</span>
<span class="fc" id="L1712">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1714" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1715">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1717">                doSwap = true;</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">                if (a[1][i] &lt;= a[1][idxHi]) {</span>
<span class="nc" id="L1720">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1723" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1724">                store++;</span>
<span class="fc" id="L1725">                int swap = a[0][store];</span>
<span class="fc" id="L1726">                a[0][store] = a[0][i];</span>
<span class="fc" id="L1727">                a[0][i] = swap;</span>
                
<span class="fc" id="L1729">                swap = a[1][store];</span>
<span class="fc" id="L1730">                a[1][store] = a[1][i];</span>
<span class="fc" id="L1731">                a[1][i] = swap;</span>
            }
        }
<span class="fc" id="L1734">        store++;</span>
<span class="fc" id="L1735">        int swap = a[0][store];</span>
<span class="fc" id="L1736">        a[0][store] = a[0][idxHi];</span>
<span class="fc" id="L1737">        a[0][idxHi] = swap;</span>
        
<span class="fc" id="L1739">        swap = a[1][store];</span>
<span class="fc" id="L1740">        a[1][store] = a[1][idxHi];</span>
<span class="fc" id="L1741">        a[1][idxHi] = swap;</span>
<span class="fc" id="L1742">        return store;</span>
    }
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecondThird(int[][] a) {
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1752">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1755">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1758">            return;</span>
        }
<span class="fc" id="L1760">        sortByDimension1FirstSecondThird(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1761">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecondThird(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1771" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1772">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1774" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1775">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1777" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1778">            return;</span>
        }
<span class="fc bfc" id="L1780" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1781">            int idxMid = partitionByDimension1FirstSecondThird(a, idxLo, idxHi);</span>
<span class="fc" id="L1782">            sortByDimension1FirstSecondThird(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1783">            sortByDimension1FirstSecondThird(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1785">    }</span>
    
    private static int partitionByDimension1FirstSecondThird(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1790">        int x = a[0][idxHi];</span>
<span class="fc" id="L1791">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1793" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1794">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1795" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1796">                doSwap = true;</span>
<span class="fc bfc" id="L1797" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1798" title="1 of 2 branches missed.">                if (a[1][i] &lt; a[1][idxHi]) {</span>
<span class="nc" id="L1799">                    doSwap = true;</span>
<span class="pc bpc" id="L1800" title="1 of 2 branches missed.">                } else if (a[1][i] == x) {</span>
<span class="pc bpc" id="L1801" title="1 of 2 branches missed.">                    if (a[2][i] &lt;= a[2][idxHi]) {</span>
<span class="nc" id="L1802">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1806" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1807">                store++;</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">                for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1809">                    int swap = a[k][store];</span>
<span class="fc" id="L1810">                    a[k][store] = a[k][i];</span>
<span class="fc" id="L1811">                    a[k][i] = swap;</span>
                }
            }
        }
<span class="fc" id="L1815">        store++;</span>
<span class="fc bfc" id="L1816" title="All 2 branches covered.">        for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1817">            int swap = a[k][store];</span>
<span class="fc" id="L1818">            a[k][store] = a[k][idxHi];</span>
<span class="fc" id="L1819">            a[k][idxHi] = swap;</span>
        }
<span class="fc" id="L1821">        return store;</span>
    }
   
      
    private static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1828" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1829">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1831" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1832">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1834" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1835">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1838">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1840" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L1841">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
       
<span class="fc bfc" id="L1844" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1845">            int idxMid = partitionBy1stThen2nd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L1846">            sortBy1stThen2nd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L1847">            sortBy1stThen2nd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1849">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d) {
    
<span class="pc bpc" id="L1854" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1855">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1857" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1859">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
        
<span class="fc" id="L1862">        sortBy1stThen2ndThen3rd(a, b, c, d, 0, a.length - 1);</span>
<span class="fc" id="L1863">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
    
<span class="pc bpc" id="L1868" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1869">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1871" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1873">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
<span class="pc bpc" id="L1875" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1876">            return;</span>
        }
<span class="fc bfc" id="L1878" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1879">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L1880">            sortBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L1881">            sortBy1stThen2ndThen3rd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1883">    }</span>
 
    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L1888">        float x = a[idxHi];</span>
<span class="fc" id="L1889">        float x2 = b[idxHi];</span>
<span class="fc" id="L1890">        float x3 = c[idxHi];</span>
<span class="fc" id="L1891">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1894">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1895" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L1896">                doSwap = true;</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L1898" title="1 of 2 branches missed.">                if (b[i] &lt; x2) {</span>
<span class="nc" id="L1899">                    doSwap = true;</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">                } else if (b[i] == x2) {</span>
<span class="pc bpc" id="L1901" title="1 of 2 branches missed.">                    if (c[i] &lt;= x3) {</span>
<span class="nc" id="L1902">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1906" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1907">                store++;</span>
<span class="fc" id="L1908">                float swap = a[store];</span>
<span class="fc" id="L1909">                a[store] = a[i];</span>
<span class="fc" id="L1910">                a[i] = swap;</span>
<span class="fc" id="L1911">                swap = b[store];</span>
<span class="fc" id="L1912">                b[store] = b[i];</span>
<span class="fc" id="L1913">                b[i] = swap;</span>
<span class="fc" id="L1914">                swap = c[store];</span>
<span class="fc" id="L1915">                c[store] = c[i];</span>
<span class="fc" id="L1916">                c[i] = swap;</span>
<span class="fc" id="L1917">                int swap3 = d[store];</span>
<span class="fc" id="L1918">                d[store] = d[i];</span>
<span class="fc" id="L1919">                d[i] = swap3;</span>
            }
        }
<span class="fc" id="L1922">        store++;</span>
<span class="fc" id="L1923">        float swap = a[store];</span>
<span class="fc" id="L1924">        a[store] = a[idxHi];</span>
<span class="fc" id="L1925">        a[idxHi] = swap;</span>
<span class="fc" id="L1926">        swap = b[store];</span>
<span class="fc" id="L1927">        b[store] = b[idxHi];</span>
<span class="fc" id="L1928">        b[idxHi] = swap;</span>
<span class="fc" id="L1929">        swap = c[store];</span>
<span class="fc" id="L1930">        c[store] = c[idxHi];</span>
<span class="fc" id="L1931">        c[idxHi] = swap;</span>
<span class="fc" id="L1932">        int swap3 = d[store];</span>
<span class="fc" id="L1933">        d[store] = d[idxHi];</span>
<span class="fc" id="L1934">        d[idxHi] = swap3;</span>
        
<span class="fc" id="L1936">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(
        TFloatList a, TFloatList b, TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L1942">        float x = a.get(idxHi);</span>
<span class="fc" id="L1943">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1945" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1946">            boolean doSwap = false;</span>
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L1948">                doSwap = true;</span>
<span class="fc bfc" id="L1949" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">                if (b.get(i) &lt;= b.get(idxHi)) {</span>
<span class="fc" id="L1951">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1954" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1955">                store++;</span>
<span class="fc" id="L1956">                float swap = a.get(store);</span>
<span class="fc" id="L1957">                a.set(store, a.get(i));</span>
<span class="fc" id="L1958">                a.set(i, swap);</span>
<span class="fc" id="L1959">                swap = b.get(store);</span>
<span class="fc" id="L1960">                b.set(store, b.get(i));</span>
<span class="fc" id="L1961">                b.set(i, swap);</span>
<span class="fc" id="L1962">                int swap2 = c.get(store);</span>
<span class="fc" id="L1963">                c.set(store, c.get(i));</span>
<span class="fc" id="L1964">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L1967">        store++;</span>
        
<span class="fc" id="L1969">        float swap = a.get(store);</span>
<span class="fc" id="L1970">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L1971">        a.set(idxHi, swap);</span>
        
<span class="fc" id="L1973">        swap = b.get(store);</span>
<span class="fc" id="L1974">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L1975">        b.set(idxHi, swap);</span>
        
<span class="fc" id="L1977">        int swap2 = c.get(store);</span>
<span class="fc" id="L1978">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L1979">        c.set(idxHi, swap2);</span>
        
<span class="fc" id="L1981">        return store;</span>
    }
   
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, float[] c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1996" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1997">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1999" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2000">            return;</span>
        }
<span class="pc bpc" id="L2002" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2003">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2005" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2006">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2008" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2009">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2012">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2014" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2015">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2016">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2017">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2019">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c) {
        
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2032">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2034" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2035">            return;</span>
        }
<span class="pc bpc" id="L2037" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2038">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2040" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2041">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2044">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2046" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2047">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc" id="L2049">        sortBy1stThen2ndThen3rd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2050">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2065" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2066">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2069">            return;</span>
        }
<span class="pc bpc" id="L2071" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2072">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2075">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2077" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2078">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2081">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2084" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2085">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2086">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2087">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2089">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b) {
<span class="nc bnc" id="L2092" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2093">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2095" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2096">            return;</span>
        }
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2099">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2101" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2102">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc" id="L2104">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2105">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b) {
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2109">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2112">            return;</span>
        }
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2115">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2118">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc" id="L2120">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2121">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a) {
<span class="pc bpc" id="L2124" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2125">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2127" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2128">            return;</span>
        }
<span class="fc" id="L2130">        sortByYThenX(a, 0, a.length - 1);</span>
<span class="fc" id="L2131">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b) {
        
<span class="pc bpc" id="L2136" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2137">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2140">            return;</span>
        }
<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2143">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc" id="L2146">        sortByDecrYThenIncrX(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2147">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2152" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2153">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2156">            return;</span>
        }
<span class="pc bpc" id="L2158" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2159">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2162" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2163">            int idxMid = partitionByDecrYThenIncrX(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2164">            sortByDecrYThenIncrX(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2165">            sortByDecrYThenIncrX(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2167">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2172">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2175">            return;</span>
        }
        
<span class="fc bfc" id="L2178" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2179">            int idxMid = partitionByYThenX(a, idxLo, idxHi);</span>
<span class="fc" id="L2180">            sortByYThenX(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L2181">            sortByYThenX(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2183">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2186" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2187">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2189" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2190">            return;</span>
        }
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2193">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2195" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2196">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2198" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2199">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2200">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2201">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2203">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2207">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2210">            return;</span>
        }
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2213">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2215" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2216">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2218" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2219">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2220">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2221">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2223">    }</span>
    
    public static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c) {
        
<span class="pc bpc" id="L2228" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2229">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2232">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2234" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L2235">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L2238">        sortBy1stThen2nd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2239">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with ties sorted by b
     * and all swap operations performed on all arrays. The sorts are
     * ascending.
     * @param a
     * @param b
     * @param c
     * @param d
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2nd(double[] a, double[] b, int[] c, int[] d, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2255" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2256">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2258" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2259">            return;</span>
        }
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2262">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2264" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2265">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L2268">            throw new IllegalArgumentException(&quot;d cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2271">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2273" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2274">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">        if (a.length != d.length) {</span>
<span class="nc" id="L2277">            throw new IllegalArgumentException(&quot;a and d must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2279" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2280">            int idxMid = partitionBy1stThen2nd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2281">            sortBy1stThen2nd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2282">            sortBy1stThen2nd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2284">    }</span>

    private static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
    
<span class="fc bfc" id="L2288" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2289">            int idxMid = partitionBy1stArg(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2290">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2291">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2293">    }</span>
    
    public static void sort(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc bfc" id="L2298" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2299">            int idxMid = partition(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2300">            sort(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2301">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2303">    }</span>

    private static int partition(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L2308">        float x = a[idxHi];</span>
<span class="fc" id="L2309">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2311" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L2312" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2313">                store++;</span>
<span class="fc" id="L2314">                float swap = a[store];</span>
<span class="fc" id="L2315">                a[store] = a[i];</span>
<span class="fc" id="L2316">                a[i] = swap;</span>
<span class="fc" id="L2317">                float swap2 = b[store];</span>
<span class="fc" id="L2318">                b[store] = b[i];</span>
<span class="fc" id="L2319">                b[i] = swap2;</span>
<span class="fc" id="L2320">                swap2 = c[store];</span>
<span class="fc" id="L2321">                c[store] = c[i];</span>
<span class="fc" id="L2322">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2325">        store++;</span>
<span class="fc" id="L2326">        float swap = a[store];</span>
<span class="fc" id="L2327">        a[store] = a[idxHi];</span>
<span class="fc" id="L2328">        a[idxHi] = swap;</span>
<span class="fc" id="L2329">        float swap2 = b[store];</span>
<span class="fc" id="L2330">        b[store] = b[idxHi];</span>
<span class="fc" id="L2331">        b[idxHi] = swap2;</span>
<span class="fc" id="L2332">        swap2 = c[store];</span>
<span class="fc" id="L2333">        c[store] = c[idxHi];</span>
<span class="fc" id="L2334">        c[idxHi] = swap2;</span>
<span class="fc" id="L2335">        return store;</span>
    }

    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int idxLo, int idxHi) {
        
<span class="fc" id="L2341">        float x = a[idxHi];</span>
<span class="fc" id="L2342">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2344" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2345">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2346" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2347">                doSwap = true;</span>
<span class="fc bfc" id="L2348" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2349" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2350">                    doSwap = true;</span>
<span class="pc bpc" id="L2351" title="1 of 2 branches missed.">                } else if (b[i] == b[idxHi]) {</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">                    if (c[i] &lt;= c[idxHi]) {</span>
<span class="nc" id="L2353">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2357" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2358">                store++;</span>
<span class="fc" id="L2359">                float swap = a[store];</span>
<span class="fc" id="L2360">                a[store] = a[i];</span>
<span class="fc" id="L2361">                a[i] = swap;</span>
<span class="fc" id="L2362">                float swap2 = b[store];</span>
<span class="fc" id="L2363">                b[store] = b[i];</span>
<span class="fc" id="L2364">                b[i] = swap2;</span>
<span class="fc" id="L2365">                swap2 = c[store];</span>
<span class="fc" id="L2366">                c[store] = c[i];</span>
<span class="fc" id="L2367">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2370">        store++;</span>
<span class="fc" id="L2371">        float swap = a[store];</span>
<span class="fc" id="L2372">        a[store] = a[idxHi];</span>
<span class="fc" id="L2373">        a[idxHi] = swap;</span>
<span class="fc" id="L2374">        float swap2 = b[store];</span>
<span class="fc" id="L2375">        b[store] = b[idxHi];</span>
<span class="fc" id="L2376">        b[idxHi] = swap2;</span>
<span class="fc" id="L2377">        swap2 = c[store];</span>
<span class="fc" id="L2378">        c[store] = c[idxHi];</span>
<span class="fc" id="L2379">        c[idxHi] = swap2;</span>
<span class="fc" id="L2380">        return store;</span>
    }
    
    private static &lt;T&gt; int partitionBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="fc" id="L2385">        int x = a[idxHi];</span>
<span class="fc" id="L2386">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2388" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2389">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2390" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2391">                doSwap = true;</span>
            }
<span class="fc bfc" id="L2393" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2394">                store++;</span>
<span class="fc" id="L2395">                int swap = a[store];</span>
<span class="fc" id="L2396">                a[store] = a[i];</span>
<span class="fc" id="L2397">                a[i] = swap;</span>
<span class="fc" id="L2398">                T swap2 = b.get(store);</span>
<span class="fc" id="L2399">                b.set(store, b.get(i));</span>
<span class="fc" id="L2400">                b.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2403">        store++;</span>
<span class="fc" id="L2404">        int swap = a[store];</span>
<span class="fc" id="L2405">        a[store] = a[idxHi];</span>
<span class="fc" id="L2406">        a[idxHi] = swap;</span>
<span class="fc" id="L2407">        T swap2 = b.get(store);</span>
<span class="fc" id="L2408">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2409">        b.set(idxHi, swap2);</span>
        
<span class="fc" id="L2411">        return store;</span>
    }
    
    private static int partitionBy1stThen2ndThen3rd(
        TIntList a, TIntList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2418">        int x = a.get(idxHi);</span>
<span class="fc" id="L2419">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2421" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2422">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2423" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2424">                doSwap = true;</span>
<span class="fc bfc" id="L2425" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2426" title="All 2 branches covered.">                if (b.get(i) &lt; b.get(idxHi)) {</span>
<span class="fc" id="L2427">                    doSwap = true;</span>
<span class="fc bfc" id="L2428" title="All 2 branches covered.">                } else if (b.get(i) == b.get(idxHi)) {</span>
<span class="pc bpc" id="L2429" title="1 of 2 branches missed.">                    if (c.get(i) &lt;= c.get(idxHi)) {</span>
<span class="nc" id="L2430">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2434" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2435">                store++;</span>
<span class="fc" id="L2436">                int swap = a.get(store);</span>
<span class="fc" id="L2437">                a.set(store, a.get(i));</span>
<span class="fc" id="L2438">                a.set(i, swap);</span>
<span class="fc" id="L2439">                int swap2 = b.get(store);</span>
<span class="fc" id="L2440">                b.set(store, b.get(i));</span>
<span class="fc" id="L2441">                b.set(i, swap2);</span>
<span class="fc" id="L2442">                swap2 = c.get(store);</span>
<span class="fc" id="L2443">                c.set(store, c.get(i));</span>
<span class="fc" id="L2444">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2447">        store++;</span>
<span class="fc" id="L2448">        int swap = a.get(store);</span>
<span class="fc" id="L2449">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2450">        a.set(idxHi, swap);</span>
<span class="fc" id="L2451">        int swap2 = b.get(store);</span>
<span class="fc" id="L2452">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2453">        b.set(idxHi, swap2);</span>
<span class="fc" id="L2454">        swap2 = c.get(store);</span>
<span class="fc" id="L2455">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2456">        c.set(idxHi, swap2);</span>
<span class="fc" id="L2457">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(float[] a, float[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2463">        float x = a[idxHi];</span>
<span class="fc" id="L2464">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2466" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2467">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2468" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2469">                doSwap = true;</span>
<span class="fc bfc" id="L2470" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2471" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2472">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2475" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2476">                store++;</span>
<span class="fc" id="L2477">                float swap = a[store];</span>
<span class="fc" id="L2478">                a[store] = a[i];</span>
<span class="fc" id="L2479">                a[i] = swap;</span>
<span class="fc" id="L2480">                float swap2 = b[store];</span>
<span class="fc" id="L2481">                b[store] = b[i];</span>
<span class="fc" id="L2482">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2485">        store++;</span>
<span class="fc" id="L2486">        float swap = a[store];</span>
<span class="fc" id="L2487">        a[store] = a[idxHi];</span>
<span class="fc" id="L2488">        a[idxHi] = swap;</span>
<span class="fc" id="L2489">        float swap2 = b[store];</span>
<span class="fc" id="L2490">        b[store] = b[idxHi];</span>
<span class="fc" id="L2491">        b[idxHi] = swap2;</span>
<span class="fc" id="L2492">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(int[] a, int[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2498">        int x = a[idxHi];</span>
<span class="fc" id="L2499">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2501" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2502">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2503" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2504">                doSwap = true;</span>
<span class="fc bfc" id="L2505" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2506" title="1 of 2 branches missed.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="nc" id="L2507">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2510" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2511">                store++;</span>
<span class="fc" id="L2512">                int swap = a[store];</span>
<span class="fc" id="L2513">                a[store] = a[i];</span>
<span class="fc" id="L2514">                a[i] = swap;</span>
<span class="fc" id="L2515">                int swap2 = b[store];</span>
<span class="fc" id="L2516">                b[store] = b[i];</span>
<span class="fc" id="L2517">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2520">        store++;</span>
<span class="fc" id="L2521">        int swap = a[store];</span>
<span class="fc" id="L2522">        a[store] = a[idxHi];</span>
<span class="fc" id="L2523">        a[idxHi] = swap;</span>
<span class="fc" id="L2524">        int swap2 = b[store];</span>
<span class="fc" id="L2525">        b[store] = b[idxHi];</span>
<span class="fc" id="L2526">        b[idxHi] = swap2;</span>
        
<span class="fc" id="L2528">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int partitionByYThenX(T[] a, int idxLo, 
        int idxHi) {
     
<span class="fc" id="L2534">        T x = a[idxHi];</span>
<span class="fc" id="L2535">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2537" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2538">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2539" title="All 2 branches covered.">            if (a[i].getY() &lt; x.getY()) {</span>
<span class="fc" id="L2540">                doSwap = true;</span>
<span class="fc bfc" id="L2541" title="All 2 branches covered.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="fc bfc" id="L2542" title="All 2 branches covered.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="fc" id="L2543">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2546" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2547">                store++;</span>
<span class="fc" id="L2548">                T swap = a[store];</span>
<span class="fc" id="L2549">                a[store] = a[i];</span>
<span class="fc" id="L2550">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L2553">        store++;</span>
<span class="fc" id="L2554">        T swap = a[store];</span>
<span class="fc" id="L2555">        a[store] = a[idxHi];</span>
<span class="fc" id="L2556">        a[idxHi] = swap;</span>
<span class="fc" id="L2557">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int 
    partitionByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
     
<span class="fc" id="L2563">        T x = a[idxHi];</span>
<span class="fc" id="L2564">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2566" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2567">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">            if (a[i].getY() &gt; x.getY()) {</span>
<span class="fc" id="L2569">                doSwap = true;</span>
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="nc" id="L2572">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2575" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2576">                store++;</span>
<span class="fc" id="L2577">                T swap = a[store];</span>
<span class="fc" id="L2578">                a[store] = a[i];</span>
<span class="fc" id="L2579">                a[i] = swap;</span>
<span class="fc" id="L2580">                int swap2 = b[store];</span>
<span class="fc" id="L2581">                b[store] = b[i];</span>
<span class="fc" id="L2582">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2585">        store++;</span>
<span class="fc" id="L2586">        T swap = a[store];</span>
<span class="fc" id="L2587">        a[store] = a[idxHi];</span>
<span class="fc" id="L2588">        a[idxHi] = swap;</span>
<span class="fc" id="L2589">        int swap2 = b[store];</span>
<span class="fc" id="L2590">        b[store] = b[idxHi];</span>
<span class="fc" id="L2591">        b[idxHi] = swap2;</span>
<span class="fc" id="L2592">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(double[] a, double[] b, int[] c,
        int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2598">        double x = a[idxHi];</span>
<span class="fc" id="L2599">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2601" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2602">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2603" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2604">                doSwap = true;</span>
<span class="fc bfc" id="L2605" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2606" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2607">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2610" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2611">                store++;</span>
<span class="fc" id="L2612">                double swap = a[store];</span>
<span class="fc" id="L2613">                a[store] = a[i];</span>
<span class="fc" id="L2614">                a[i] = swap;</span>
<span class="fc" id="L2615">                swap = b[store];</span>
<span class="fc" id="L2616">                b[store] = b[i];</span>
<span class="fc" id="L2617">                b[i] = swap;</span>
<span class="fc" id="L2618">                int swap2 = c[store];</span>
<span class="fc" id="L2619">                c[store] = c[i];</span>
<span class="fc" id="L2620">                c[i] = swap2;</span>
<span class="fc" id="L2621">                swap2 = d[store];</span>
<span class="fc" id="L2622">                d[store] = d[i];</span>
<span class="fc" id="L2623">                d[i] = swap2;</span>
            }
        }
<span class="fc" id="L2626">        store++;</span>
<span class="fc" id="L2627">        double swap = a[store];</span>
<span class="fc" id="L2628">        a[store] = a[idxHi];</span>
<span class="fc" id="L2629">        a[idxHi] = swap;</span>
<span class="fc" id="L2630">        swap = b[store];</span>
<span class="fc" id="L2631">        b[store] = b[idxHi];</span>
<span class="fc" id="L2632">        b[idxHi] = swap;</span>
<span class="fc" id="L2633">        int swap2 = c[store];</span>
<span class="fc" id="L2634">        c[store] = c[idxHi];</span>
<span class="fc" id="L2635">        c[idxHi] = swap2;</span>
<span class="fc" id="L2636">        swap2 = d[store];</span>
<span class="fc" id="L2637">        d[store] = d[idxHi];</span>
<span class="fc" id="L2638">        d[idxHi] = swap2;        </span>
<span class="fc" id="L2639">        return store;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
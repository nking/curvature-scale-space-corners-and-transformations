<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QuickSort.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">QuickSort.java</span></div><h1>QuickSort.java</h1><pre class="source lang-java linenums">package algorithms;

import algorithms.util.IntIntDouble;
import algorithms.util.PairInt;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import java.util.List;
import java.util.Set;

/**
 *
 * @author nichole
 */
<span class="nc" id="L15">public class QuickSort {</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * @param a
     */
    public static void sort(float[] a) {
<span class="fc" id="L22">        sort(a, 0, a.length - 1);</span>
<span class="fc" id="L23">    }</span>
    
    public static void descendingSort(int[] a, int[] b) {
        
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L28">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L31">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L33" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L34">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L37">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="fc" id="L38">    }</span>
    
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b) {
        
<span class="nc bnc" id="L42" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L43">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L45" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L46">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L49">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L52">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="nc" id="L53">    }</span>
    
    public static void descendingSort(TIntList a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L61">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L64">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L67">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L68">    }</span>
    
    public static void descendingSort(List&lt;? extends Number&gt; a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L73">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L76">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L79">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L82">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L83">    }</span>
    
    public static void descendingSort(double[] a) {
        
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
        
<span class="fc" id="L91">        descendingSort(a, 0, a.length - 1);</span>
<span class="fc" id="L92">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[][] b) {
        
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L106">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="nc" id="L107">    }</span>
    
    public static void sortBy1stArg(int[] a, int[] b) {
        
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L112">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L115">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L118">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L121">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L122">    }</span>
    
    public static void sortByA(IntIntDouble[] abc) {
        
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L127">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="fc" id="L130">        sortByA(abc, 0, abc.length - 1);</span>
<span class="fc" id="L131">    }</span>
    
    public static void sortBy1stArg(int[] a, List b) {
    
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L136">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L145">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L146">    }</span>

    /**
     * sort a by ascending values and perform the same swap operation on b.
     * @param a
     * @param b 
     */
    public static void sortBy1stArg(float[] a, int[] b) {
        
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L156">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L159">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L162">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L165">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L166">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[] b) {
        
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L171">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L174">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L177">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L180">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L181">    }</span>
    
    public static void sortBy1stArg(float[] a, Object[] b) {
        
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L186">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L189">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L192">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L195">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L196">    }</span>
    
    public static void sortBy1stArg(TDoubleList a, int[] b) {
        
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L201">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L204">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L207">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L210">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L211">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b) {

<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L216">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L219">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L222">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L225">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="nc" id="L226">    }</span>
    
    public static void sortBy1stArg(TFloatList a, List b) {

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L231">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L234">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L237">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L240">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L241">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b, TIntList c) {

<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L246">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L249">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L252">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L255">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L258">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L259">    }</span>
    
    public static void sortBy1stArg(TIntList a, TDoubleList b,
        TIntList c) {
        
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L265">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L268">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L271">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L274">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="fc" id="L280">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L281">    }</span>
    
    public static void sortBy1stArg(TIntList a, TIntList b) {
        
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L289">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L292">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L295">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L296">    }</span>
    
    public static void sortBy1stArgDesc(int[] a, List b, List c) {
<span class="fc" id="L299">        sortBy1stArgDesc(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L300">    }</span>
    
    public static void sortBy1stArgDesc(int[] a, List b, List c, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L306">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L309">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L312">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L315">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L318">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L322">            return;</span>
        }
        
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L327">            int x = a[idxLo];</span>
<span class="fc" id="L328">            int store = idxLo;</span>
<span class="fc" id="L329">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L333">                    store++;     </span>
<span class="fc bfc" id="L334" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt;= x));</span>
                do {
<span class="fc" id="L336">                    idxMid--;</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                } while (a[idxMid] &lt;= x);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L339">                    break;</span>
                }
<span class="fc" id="L341">                int swap = a[store];</span>
<span class="fc" id="L342">                a[store] = a[idxMid];</span>
<span class="fc" id="L343">                a[idxMid] = swap;</span>
                
<span class="fc" id="L345">                Object swap2 = b.get(store);</span>
<span class="fc" id="L346">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L347">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L349">                swap2 = c.get(store);</span>
<span class="fc" id="L350">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L351">                c.set(idxMid, swap2);</span>
                
<span class="fc" id="L353">            }</span>
            
<span class="fc" id="L355">            int swap = a[idxLo];</span>
<span class="fc" id="L356">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L357">            a[idxMid] = swap;</span>

<span class="fc" id="L359">            Object swap2 = b.get(idxLo);</span>
<span class="fc" id="L360">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L361">            b.set(idxMid, swap2);</span>

<span class="fc" id="L363">            swap2 = c.get(idxLo);</span>
<span class="fc" id="L364">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L365">            c.set(idxMid, swap2);</span>
         
<span class="fc" id="L367">            sortBy1stArgDesc(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L369">            sortBy1stArgDesc(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L371">    }</span>

    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L385">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L391">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L394">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L397">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L401">            return;</span>
        }
        
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L406">            int x = a.get(idxLo);</span>
<span class="fc" id="L407">            int store = idxLo;</span>
<span class="fc" id="L408">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L412">                    store++;     </span>
<span class="fc bfc" id="L413" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L415">                    idxMid--;</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L418">                    break;</span>
                }
<span class="nc" id="L420">                int swap = a.get(store);</span>
<span class="nc" id="L421">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L422">                a.set(idxMid, swap);</span>
<span class="nc" id="L423">                swap = c.get(store);</span>
<span class="nc" id="L424">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L425">                c.set(idxMid, swap);</span>
                
<span class="nc" id="L427">                double bSwap = b.get(store);</span>
<span class="nc" id="L428">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L429">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L430">            }</span>
<span class="fc" id="L431">            int swap = a.get(idxLo);</span>
<span class="fc" id="L432">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L433">            a.set(idxMid, swap);</span>
<span class="fc" id="L434">            swap = c.get(idxLo);</span>
<span class="fc" id="L435">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L436">            c.set(idxMid, swap);</span>
            
<span class="fc" id="L438">            double bSwap = b.get(idxLo);</span>
<span class="fc" id="L439">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L440">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L442">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L444">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L446">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b,  
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L460">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L463">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L466">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L469">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L472">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L476">            return;</span>
        }
        
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L481">            float x = a.get(idxLo);</span>
<span class="fc" id="L482">            int store = idxLo;</span>
<span class="fc" id="L483">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L487">                    store++;     </span>
<span class="fc bfc" id="L488" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L490">                    idxMid--;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L493">                    break;</span>
                }
<span class="nc" id="L495">                float swap = a.get(store);</span>
<span class="nc" id="L496">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L497">                a.set(idxMid, swap);</span>
<span class="nc" id="L498">                int swap2 = c.get(store);</span>
<span class="nc" id="L499">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L500">                c.set(idxMid, swap2);</span>
                
<span class="nc" id="L502">                swap2 = b.get(store);</span>
<span class="nc" id="L503">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L504">                b.set(idxMid, swap2);</span>
<span class="nc" id="L505">            }</span>
<span class="fc" id="L506">            float swap = a.get(idxLo);</span>
<span class="fc" id="L507">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L508">            a.set(idxMid, swap);</span>
<span class="fc" id="L509">            int swap2 = c.get(idxLo);</span>
<span class="fc" id="L510">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L511">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L513">            swap2 = b.get(idxLo);</span>
<span class="fc" id="L514">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L515">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L517">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L519">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L521">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, 
        int idxLo, int idxHi) {
        
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L535">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L538">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L541">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L545">            return;</span>
        }
        
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L550">            float x = a.get(idxLo);</span>
<span class="nc" id="L551">            int store = idxLo;</span>
<span class="nc" id="L552">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L556">                    store++;     </span>
<span class="nc bnc" id="L557" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="nc" id="L559">                    idxMid--;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                } while (a.get(idxMid) &gt; x);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L562">                    break;</span>
                }
<span class="nc" id="L564">                float swap = a.get(store);</span>
<span class="nc" id="L565">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L566">                a.set(idxMid, swap);</span>
<span class="nc" id="L567">                int swap2 = b.get(store);</span>
<span class="nc" id="L568">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L569">                b.set(idxMid, swap2);</span>
                
<span class="nc" id="L571">            }</span>
<span class="nc" id="L572">            float swap = a.get(idxLo);</span>
<span class="nc" id="L573">            a.set(idxLo, a.get(idxMid));</span>
<span class="nc" id="L574">            a.set(idxMid, swap);</span>
<span class="nc" id="L575">            int bSwap = b.get(idxLo);</span>
<span class="nc" id="L576">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L577">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L579">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L581">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L583">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, List b, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L597">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L600">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L603">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L607">            return;</span>
        }
        
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L612">            float x = a.get(idxLo);</span>
<span class="fc" id="L613">            int store = idxLo;</span>
<span class="fc" id="L614">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L618">                    store++;     </span>
<span class="fc bfc" id="L619" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L621">                    idxMid--;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L624">                    break;</span>
                }
<span class="fc" id="L626">                float swap = a.get(store);</span>
<span class="fc" id="L627">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L628">                a.set(idxMid, swap);</span>
<span class="fc" id="L629">                Object swap2 = b.get(store);</span>
<span class="fc" id="L630">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L631">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L633">            }</span>
<span class="fc" id="L634">            float swap = a.get(idxLo);</span>
<span class="fc" id="L635">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L636">            a.set(idxMid, swap);</span>
<span class="fc" id="L637">            Object bSwap = b.get(idxLo);</span>
<span class="fc" id="L638">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L639">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L641">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L643">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L645">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TIntList b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L658">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L661">            throw new IllegalArgumentException(&quot;v cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L664">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L668">            return;</span>
        }
        
<span class="fc bfc" id="L671" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L673">            int x = a.get(idxLo);</span>
<span class="fc" id="L674">            int store = idxLo;</span>
<span class="fc" id="L675">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L679">                    store++;     </span>
<span class="fc bfc" id="L680" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L682">                    idxMid--;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L685">                    break;</span>
                }
<span class="nc" id="L687">                int swap = a.get(store);</span>
<span class="nc" id="L688">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L689">                a.set(idxMid, swap);</span>
<span class="nc" id="L690">                swap = b.get(store);</span>
<span class="nc" id="L691">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L692">                b.set(idxMid, swap);</span>
<span class="nc" id="L693">            }</span>
<span class="fc" id="L694">            int swap = a.get(idxLo);</span>
<span class="fc" id="L695">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L696">            a.set(idxMid, swap);</span>
<span class="fc" id="L697">            swap = b.get(idxLo);</span>
<span class="fc" id="L698">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L699">            b.set(idxMid, swap);</span>
         
<span class="fc" id="L701">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L703">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L705">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortByA(IntIntDouble[] abc, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L719">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (abc.length &lt; 2) {</span>
<span class="nc" id="L723">            return;</span>
        }
        
<span class="fc bfc" id="L726" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L728">            int x = abc[idxLo].getA();</span>
<span class="fc" id="L729">            int store = idxLo;</span>
<span class="fc" id="L730">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L734">                    store++;     </span>
<span class="fc bfc" id="L735" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (abc[store].getA() &lt; x));</span>
                do {
<span class="fc" id="L737">                    idxMid--;</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                } while (abc[idxMid].getA() &gt; x);</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L740">                    break;</span>
                }
<span class="nc" id="L742">                IntIntDouble swap = abc[store];</span>
<span class="nc" id="L743">                abc[store] = abc[idxMid];</span>
<span class="nc" id="L744">                abc[idxMid] = swap;</span>
<span class="nc" id="L745">            }</span>
<span class="fc" id="L746">            IntIntDouble swap = abc[idxLo];</span>
<span class="fc" id="L747">            abc[idxLo] = abc[idxMid];</span>
<span class="fc" id="L748">            abc[idxMid] = swap;</span>
         
<span class="fc" id="L750">            sortByA(abc, idxLo, idxMid - 1);</span>

<span class="fc" id="L752">            sortByA(abc, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L754">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L766">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L769">            return;</span>
        }
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L773">            float x = a[idxLo];</span>
<span class="fc" id="L774">            int store = idxLo;</span>
<span class="fc" id="L775">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L779">                    store++;     </span>
<span class="fc bfc" id="L780" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L782">                    idxMid--;</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L785">                    break;</span>
                }
<span class="fc" id="L787">                float swap = a[store];</span>
<span class="fc" id="L788">                a[store] = a[idxMid];</span>
<span class="fc" id="L789">                a[idxMid] = swap;</span>
<span class="fc" id="L790">            }</span>
<span class="fc" id="L791">            float swap = a[idxLo];</span>
<span class="fc" id="L792">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L793">            a[idxMid] = swap;</span>
         
<span class="fc" id="L795">            sort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L797">            sort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L799">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L813">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L816">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L819">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L822">            return;</span>
        }
        
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L827">            int x = a[idxLo];</span>
<span class="nc" id="L828">            int store = idxLo;</span>
<span class="nc" id="L829">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L833">                    store++;     </span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="nc" id="L836">                    idxMid--;</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                } while (a[idxMid] &lt; x);</span>
                
<span class="nc bnc" id="L839" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L840">                    break;</span>
                }
<span class="nc" id="L842">                int swap = a[store];</span>
<span class="nc" id="L843">                a[store] = a[idxMid];</span>
<span class="nc" id="L844">                a[idxMid] = swap;</span>
<span class="nc" id="L845">                T swap2 = b[store];</span>
<span class="nc" id="L846">                b[store] = b[idxMid];</span>
<span class="nc" id="L847">                b[idxMid] = swap2;</span>
<span class="nc" id="L848">            }</span>
<span class="nc" id="L849">            int swap = a[idxLo];</span>
<span class="nc" id="L850">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L851">            a[idxMid] = swap;</span>
<span class="nc" id="L852">            T swap2 = b[idxLo];</span>
<span class="nc" id="L853">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L854">            b[idxMid] = swap2;</span>
         
<span class="nc" id="L856">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L858">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L860">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L873">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L876">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L879">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L882">            return;</span>
        }
        
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L887">            int x = a[idxLo];</span>
<span class="fc" id="L888">            int store = idxLo;</span>
<span class="fc" id="L889">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L893">                    store++;     </span>
<span class="fc bfc" id="L894" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L896">                    idxMid--;</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L899" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L900">                    break;</span>
                }
<span class="fc" id="L902">                int swap = a[store];</span>
<span class="fc" id="L903">                a[store] = a[idxMid];</span>
<span class="fc" id="L904">                a[idxMid] = swap;</span>
<span class="fc" id="L905">                swap = b[store];</span>
<span class="fc" id="L906">                b[store] = b[idxMid];</span>
<span class="fc" id="L907">                b[idxMid] = swap;</span>
<span class="fc" id="L908">            }</span>
<span class="fc" id="L909">            int swap = a[idxLo];</span>
<span class="fc" id="L910">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L911">            a[idxMid] = swap;</span>
<span class="fc" id="L912">            swap = b[idxLo];</span>
<span class="fc" id="L913">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L914">            b[idxMid] = swap;</span>
         
<span class="fc" id="L916">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L918">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L920">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param &lt;T&gt;
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(
        TIntList a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L936">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L939">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L942">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L945">            return;</span>
        }
        
<span class="fc bfc" id="L948" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L950">            int x = a.get(idxLo);</span>
<span class="fc" id="L951">            int store = idxLo;</span>
<span class="fc" id="L952">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L956">                    store++;     </span>
<span class="pc bpc" id="L957" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &gt; x));</span>
                do {
<span class="fc" id="L959">                    idxMid--;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">                } while (a.get(idxMid) &lt; x);</span>
                
<span class="fc bfc" id="L962" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L963">                    break;</span>
                }
<span class="fc" id="L965">                int swap = a.get(store);</span>
<span class="fc" id="L966">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L967">                a.set(idxMid, swap);</span>
<span class="fc" id="L968">                T swap2 = b.get(store);</span>
<span class="fc" id="L969">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L970">                b.set(idxMid, swap2);</span>
<span class="fc" id="L971">            }</span>
<span class="fc" id="L972">            int swap = a.get(idxLo);</span>
<span class="fc" id="L973">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L974">            a.set(idxMid, swap);</span>
<span class="fc" id="L975">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L976">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L977">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L979">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L981">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L983">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;S extends Number, T extends Object&gt; void descendingSort(
        List&lt;S&gt; a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L997">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1000">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1003">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        if (a.size() &lt; 2) {</span>
<span class="fc" id="L1006">            return;</span>
        }
        
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1011">            float x = a.get(idxLo).floatValue();</span>
<span class="fc" id="L1012">            int store = idxLo;</span>
<span class="fc" id="L1013">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1017">                    store++;     </span>
<span class="fc bfc" id="L1018" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store).floatValue() &gt; x));</span>
                do {
<span class="fc" id="L1020">                    idxMid--;</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">                } while (a.get(idxMid).floatValue() &lt; x);</span>
                
<span class="fc bfc" id="L1023" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1024">                    break;</span>
                }
<span class="fc" id="L1026">                S swap = a.get(store);</span>
<span class="fc" id="L1027">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1028">                a.set(idxMid, swap);</span>
<span class="fc" id="L1029">                T swap2 = b.get(store);</span>
<span class="fc" id="L1030">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1031">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1032">            }</span>
<span class="fc" id="L1033">            S swap = a.get(idxLo);</span>
<span class="fc" id="L1034">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1035">            a.set(idxMid, swap);</span>
<span class="fc" id="L1036">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1037">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1038">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1040">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1042">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1044">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(double[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1057">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1060">            return;</span>
        }
        
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1065">            double x = a[idxLo];</span>
<span class="fc" id="L1066">            int store = idxLo;</span>
<span class="fc" id="L1067">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1071">                    store++;     </span>
<span class="fc bfc" id="L1072" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1074">                    idxMid--;</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1077" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1078">                    break;</span>
                }
<span class="fc" id="L1080">                double swap = a[store];</span>
<span class="fc" id="L1081">                a[store] = a[idxMid];</span>
<span class="fc" id="L1082">                a[idxMid] = swap;</span>
<span class="fc" id="L1083">            }</span>
<span class="fc" id="L1084">            double swap = a[idxLo];</span>
<span class="fc" id="L1085">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1086">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1088">            descendingSort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1090">            descendingSort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1092">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1106">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1109">            return;</span>
        }
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1113">            float x = a[idxLo];</span>
<span class="fc" id="L1114">            int store = idxLo;</span>
<span class="fc" id="L1115">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1119">                    store++;     </span>
<span class="fc bfc" id="L1120" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1122">                    idxMid--;</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1125">                    break;</span>
                }
<span class="fc" id="L1127">                float swap = a[store];</span>
<span class="fc" id="L1128">                a[store] = a[idxMid];</span>
<span class="fc" id="L1129">                a[idxMid] = swap;</span>
<span class="fc" id="L1130">                int swap2 = b[store];</span>
<span class="fc" id="L1131">                b[store] = b[idxMid];</span>
<span class="fc" id="L1132">                b[idxMid] = swap2;</span>
<span class="fc" id="L1133">            }</span>
<span class="fc" id="L1134">            float swap = a[idxLo];</span>
<span class="fc" id="L1135">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1136">            a[idxMid] = swap;</span>
<span class="fc" id="L1137">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1138">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1139">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1141">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1143">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1145">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TDoubleList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1159">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1162">            return;</span>
        }
<span class="fc bfc" id="L1164" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1166">            double x = a.get(idxLo);</span>
<span class="fc" id="L1167">            int store = idxLo;</span>
<span class="fc" id="L1168">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1172">                    store++;     </span>
<span class="fc bfc" id="L1173" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L1175">                    idxMid--;</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1178">                    break;</span>
                }
<span class="fc" id="L1180">                double swap = a.get(store);</span>
<span class="fc" id="L1181">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1182">                a.set(idxMid, swap);</span>
<span class="fc" id="L1183">                int swap2 = b[store];</span>
<span class="fc" id="L1184">                b[store] = b[idxMid];</span>
<span class="fc" id="L1185">                b[idxMid] = swap2;</span>
<span class="fc" id="L1186">            }</span>
<span class="fc" id="L1187">            double swap = a.get(idxLo);</span>
<span class="fc" id="L1188">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1189">            a.set(idxMid, swap);</span>
<span class="fc" id="L1190">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1191">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1192">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1194">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1196">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1198">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1212">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1214" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1215">            return;</span>
        }
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1219">            int x = a[idxLo];</span>
<span class="fc" id="L1220">            int store = idxLo;</span>
<span class="fc" id="L1221">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1225">                    store++;     </span>
<span class="fc bfc" id="L1226" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1228">                    idxMid--;</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1231">                    break;</span>
                }
<span class="fc" id="L1233">                int swap = a[store];</span>
<span class="fc" id="L1234">                a[store] = a[idxMid];</span>
<span class="fc" id="L1235">                a[idxMid] = swap;</span>
<span class="fc" id="L1236">                int swap2 = b[store];</span>
<span class="fc" id="L1237">                b[store] = b[idxMid];</span>
<span class="fc" id="L1238">                b[idxMid] = swap2;</span>
<span class="fc" id="L1239">            }</span>
<span class="fc" id="L1240">            int swap = a[idxLo];</span>
<span class="fc" id="L1241">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1242">            a[idxMid] = swap;</span>
<span class="fc" id="L1243">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1244">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1245">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1247">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1249">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1251">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[][] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1263" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1264">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1266" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1267">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1269" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1270">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1273" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1274">            return;</span>
        }
        
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1279">            int x = a[idxLo];</span>
<span class="nc" id="L1280">            int store = idxLo;</span>
<span class="nc" id="L1281">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1285">                    store++;     </span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1288">                    idxMid--;</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1291">                    break;</span>
                }
<span class="nc" id="L1293">                int swap = a[store];</span>
<span class="nc" id="L1294">                a[store] = a[idxMid];</span>
<span class="nc" id="L1295">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1297">                Object[] bSwap = b[store];</span>
<span class="nc" id="L1298">                b[store] = b[idxMid];</span>
<span class="nc" id="L1299">                b[idxMid] = bSwap;</span>
<span class="nc" id="L1300">            }</span>
<span class="nc" id="L1301">            int swap = a[idxLo];</span>
<span class="nc" id="L1302">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1303">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1305">            Object[] bSwap = b[idxLo];</span>
<span class="nc" id="L1306">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1307">            b[idxMid] = bSwap;</span>
         
<span class="nc" id="L1309">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1311">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1313">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     */
    public static void sortBy1stArg(float[] a, List b, List c) {
        
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1324">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1327">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1330">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1333">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L1336">        sortBy1stArg(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L1337">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, List b, List c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1350">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1353">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1355" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1356">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1359">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1363">            return;</span>
        }
        
<span class="fc bfc" id="L1366" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1368">            float x = a[idxLo];</span>
<span class="fc" id="L1369">            int store = idxLo;</span>
<span class="fc" id="L1370">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1374">                    store++;     </span>
<span class="fc bfc" id="L1375" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1377">                    idxMid--;</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1379" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1380">                    break;</span>
                }
<span class="fc" id="L1382">                float swap = a[store];</span>
<span class="fc" id="L1383">                a[store] = a[idxMid];</span>
<span class="fc" id="L1384">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1386">                Object swap2 = b.get(store);</span>
<span class="fc" id="L1387">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1388">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L1390">                swap2 = c.get(store);</span>
<span class="fc" id="L1391">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L1392">                c.set(idxMid, swap2);</span>
<span class="fc" id="L1393">            }</span>
<span class="fc" id="L1394">            float swap = a[idxLo];</span>
<span class="fc" id="L1395">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1396">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1398">            Object swap2 = b.get(idxLo);</span>
<span class="fc" id="L1399">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1400">            b.set(idxMid, swap2);</span>
               
<span class="fc" id="L1402">            swap2 = c.get(idxLo);</span>
<span class="fc" id="L1403">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L1404">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L1406">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1408">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1410">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1423">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1426">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1429">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1433">            return;</span>
        }
        
<span class="fc bfc" id="L1436" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1438">            int x = a[idxLo];</span>
<span class="fc" id="L1439">            int store = idxLo;</span>
<span class="fc" id="L1440">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1444">                    store++;     </span>
<span class="fc bfc" id="L1445" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1447">                    idxMid--;</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1450">                    break;</span>
                }
<span class="fc" id="L1452">                int swap = a[store];</span>
<span class="fc" id="L1453">                a[store] = a[idxMid];</span>
<span class="fc" id="L1454">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1456">                Object bSwap = b[store];</span>
<span class="fc" id="L1457">                b[store] = b[idxMid];</span>
<span class="fc" id="L1458">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1459">            }</span>
<span class="fc" id="L1460">            int swap = a[idxLo];</span>
<span class="fc" id="L1461">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1462">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1464">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1465">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1466">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1468">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1470">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1472">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, List b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1484" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1485">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1487" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1488">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1491">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1495">            return;</span>
        }
        
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1500">            float x = a[idxLo];</span>
<span class="fc" id="L1501">            int store = idxLo;</span>
<span class="fc" id="L1502">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1506">                    store++;     </span>
<span class="fc bfc" id="L1507" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1509">                    idxMid--;</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1512">                    break;</span>
                }
<span class="fc" id="L1514">                float swap = a[store];</span>
<span class="fc" id="L1515">                a[store] = a[idxMid];</span>
<span class="fc" id="L1516">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1518">                Object bSwap = b.get(store);</span>
<span class="fc" id="L1519">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1520">                b.set(idxMid, bSwap);</span>
<span class="fc" id="L1521">            }</span>
<span class="fc" id="L1522">            float swap = a[idxLo];</span>
<span class="fc" id="L1523">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1524">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1526">            Object bSwap = b.get(idxLo);</span>
<span class="fc" id="L1527">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1528">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L1530">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1532">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1534">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1546" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1547">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1550">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1553">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1557">            return;</span>
        }
        
<span class="fc bfc" id="L1560" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1562">            float x = a[idxLo];</span>
<span class="fc" id="L1563">            int store = idxLo;</span>
<span class="fc" id="L1564">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1568">                    store++;     </span>
<span class="fc bfc" id="L1569" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1571">                    idxMid--;</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1574">                    break;</span>
                }
<span class="fc" id="L1576">                float swap = a[store];</span>
<span class="fc" id="L1577">                a[store] = a[idxMid];</span>
<span class="fc" id="L1578">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1580">                Object bSwap = b[store];</span>
<span class="fc" id="L1581">                b[store] = b[idxMid];</span>
<span class="fc" id="L1582">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1583">            }</span>
<span class="fc" id="L1584">            float swap = a[idxLo];</span>
<span class="fc" id="L1585">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1586">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1588">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1589">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1590">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1592">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1594">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1596">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * It's an adaption of the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b an array that will receive the same swap operations as are 
     * performed on a
     * @param c an array that will receive the same swap operations as are 
     * performed on a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int[] b, int[] c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1613">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1615" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1616">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1618" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1619">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1621" title="2 of 4 branches missed.">        if ((a.length != b.length) || (a.length != c.length)) {</span>
<span class="nc" id="L1622">            throw new IllegalArgumentException(&quot;array lengths must be the same&quot;);</span>
        }
        
<span class="fc bfc" id="L1625" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1627">            float x = a[idxLo];</span>
<span class="fc" id="L1628">            int store = idxLo;</span>
<span class="fc" id="L1629">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1633">                    store++;     </span>
<span class="fc bfc" id="L1634" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1636">                    idxMid--;</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1639">                    break;</span>
                }
<span class="fc" id="L1641">                float swap = a[store];</span>
<span class="fc" id="L1642">                a[store] = a[idxMid];</span>
<span class="fc" id="L1643">                a[idxMid] = swap;</span>
<span class="fc" id="L1644">                int swap2 = b[store];</span>
<span class="fc" id="L1645">                b[store] = b[idxMid];</span>
<span class="fc" id="L1646">                b[idxMid] = swap2;</span>
<span class="fc" id="L1647">                swap2 = c[store];</span>
<span class="fc" id="L1648">                c[store] = c[idxMid];</span>
<span class="fc" id="L1649">                c[idxMid] = swap2;</span>
<span class="fc" id="L1650">            }</span>
<span class="fc" id="L1651">            float swap = a[idxLo];</span>
<span class="fc" id="L1652">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1653">            a[idxMid] = swap;</span>
<span class="fc" id="L1654">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1655">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1656">            b[idxMid] = swap2;</span>
<span class="fc" id="L1657">            swap2 = c[idxLo];</span>
<span class="fc" id="L1658">            c[idxLo] = c[idxMid];</span>
<span class="fc" id="L1659">            c[idxMid] = swap2;</span>
                     
<span class="fc" id="L1661">            sort(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1663">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1665">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecond(int[][] a) {
<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1674">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1677">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1680">            return;</span>
        }
<span class="fc" id="L1682">        sortByDimension1FirstSecond(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1683">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecond(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1694">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1697">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1700">            return;</span>
        }
<span class="fc bfc" id="L1702" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1703">            int idxMid = partitionByDimension1FirstSecond(a, idxLo, idxHi);</span>
<span class="fc" id="L1704">            sortByDimension1FirstSecond(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1705">            sortByDimension1FirstSecond(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1707">    }</span>
    
    private static int partitionByDimension1FirstSecond(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1712">        int x = a[0][idxHi];</span>
<span class="fc" id="L1713">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1715" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1716">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1718">                doSwap = true;</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">                if (a[1][i] &lt;= a[1][idxHi]) {</span>
<span class="nc" id="L1721">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1724" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1725">                store++;</span>
<span class="fc" id="L1726">                int swap = a[0][store];</span>
<span class="fc" id="L1727">                a[0][store] = a[0][i];</span>
<span class="fc" id="L1728">                a[0][i] = swap;</span>
                
<span class="fc" id="L1730">                swap = a[1][store];</span>
<span class="fc" id="L1731">                a[1][store] = a[1][i];</span>
<span class="fc" id="L1732">                a[1][i] = swap;</span>
            }
        }
<span class="fc" id="L1735">        store++;</span>
<span class="fc" id="L1736">        int swap = a[0][store];</span>
<span class="fc" id="L1737">        a[0][store] = a[0][idxHi];</span>
<span class="fc" id="L1738">        a[0][idxHi] = swap;</span>
        
<span class="fc" id="L1740">        swap = a[1][store];</span>
<span class="fc" id="L1741">        a[1][store] = a[1][idxHi];</span>
<span class="fc" id="L1742">        a[1][idxHi] = swap;</span>
<span class="fc" id="L1743">        return store;</span>
    }
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecondThird(int[][] a) {
<span class="pc bpc" id="L1752" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1753">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1756">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1759">            return;</span>
        }
<span class="fc" id="L1761">        sortByDimension1FirstSecondThird(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1762">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecondThird(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1773">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1776">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1779">            return;</span>
        }
<span class="fc bfc" id="L1781" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1782">            int idxMid = partitionByDimension1FirstSecondThird(a, idxLo, idxHi);</span>
<span class="fc" id="L1783">            sortByDimension1FirstSecondThird(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1784">            sortByDimension1FirstSecondThird(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1786">    }</span>
    
    private static int partitionByDimension1FirstSecondThird(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1791">        int x = a[0][idxHi];</span>
<span class="fc" id="L1792">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1794" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1795">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1797">                doSwap = true;</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1799" title="1 of 2 branches missed.">                if (a[1][i] &lt; a[1][idxHi]) {</span>
<span class="nc" id="L1800">                    doSwap = true;</span>
<span class="pc bpc" id="L1801" title="1 of 2 branches missed.">                } else if (a[1][i] == x) {</span>
<span class="pc bpc" id="L1802" title="1 of 2 branches missed.">                    if (a[2][i] &lt;= a[2][idxHi]) {</span>
<span class="nc" id="L1803">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1808">                store++;</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">                for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1810">                    int swap = a[k][store];</span>
<span class="fc" id="L1811">                    a[k][store] = a[k][i];</span>
<span class="fc" id="L1812">                    a[k][i] = swap;</span>
                }
            }
        }
<span class="fc" id="L1816">        store++;</span>
<span class="fc bfc" id="L1817" title="All 2 branches covered.">        for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1818">            int swap = a[k][store];</span>
<span class="fc" id="L1819">            a[k][store] = a[k][idxHi];</span>
<span class="fc" id="L1820">            a[k][idxHi] = swap;</span>
        }
<span class="fc" id="L1822">        return store;</span>
    }
   
      
    private static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1829" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1830">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1832" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1833">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1835" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1836">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1838" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1839">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L1842">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
       
<span class="fc bfc" id="L1845" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1846">            int idxMid = partitionBy1stThen2nd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L1847">            sortBy1stThen2nd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L1848">            sortBy1stThen2nd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1850">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d) {
    
<span class="pc bpc" id="L1855" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1856">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1858" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1860">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
        
<span class="fc" id="L1863">        sortBy1stThen2ndThen3rd(a, b, c, d, 0, a.length - 1);</span>
<span class="fc" id="L1864">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
    
<span class="pc bpc" id="L1869" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1870">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1872" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1874">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1877">            return;</span>
        }
<span class="fc bfc" id="L1879" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1880">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L1881">            sortBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L1882">            sortBy1stThen2ndThen3rd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1884">    }</span>
 
    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L1889">        float x = a[idxHi];</span>
<span class="fc" id="L1890">        float x2 = b[idxHi];</span>
<span class="fc" id="L1891">        float x3 = c[idxHi];</span>
<span class="fc" id="L1892">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1894" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1895">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1896" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L1897">                doSwap = true;</span>
<span class="fc bfc" id="L1898" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L1899" title="1 of 2 branches missed.">                if (b[i] &lt; x2) {</span>
<span class="nc" id="L1900">                    doSwap = true;</span>
<span class="fc bfc" id="L1901" title="All 2 branches covered.">                } else if (b[i] == x2) {</span>
<span class="pc bpc" id="L1902" title="1 of 2 branches missed.">                    if (c[i] &lt;= x3) {</span>
<span class="nc" id="L1903">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1907" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1908">                store++;</span>
<span class="fc" id="L1909">                float swap = a[store];</span>
<span class="fc" id="L1910">                a[store] = a[i];</span>
<span class="fc" id="L1911">                a[i] = swap;</span>
<span class="fc" id="L1912">                swap = b[store];</span>
<span class="fc" id="L1913">                b[store] = b[i];</span>
<span class="fc" id="L1914">                b[i] = swap;</span>
<span class="fc" id="L1915">                swap = c[store];</span>
<span class="fc" id="L1916">                c[store] = c[i];</span>
<span class="fc" id="L1917">                c[i] = swap;</span>
<span class="fc" id="L1918">                int swap3 = d[store];</span>
<span class="fc" id="L1919">                d[store] = d[i];</span>
<span class="fc" id="L1920">                d[i] = swap3;</span>
            }
        }
<span class="fc" id="L1923">        store++;</span>
<span class="fc" id="L1924">        float swap = a[store];</span>
<span class="fc" id="L1925">        a[store] = a[idxHi];</span>
<span class="fc" id="L1926">        a[idxHi] = swap;</span>
<span class="fc" id="L1927">        swap = b[store];</span>
<span class="fc" id="L1928">        b[store] = b[idxHi];</span>
<span class="fc" id="L1929">        b[idxHi] = swap;</span>
<span class="fc" id="L1930">        swap = c[store];</span>
<span class="fc" id="L1931">        c[store] = c[idxHi];</span>
<span class="fc" id="L1932">        c[idxHi] = swap;</span>
<span class="fc" id="L1933">        int swap3 = d[store];</span>
<span class="fc" id="L1934">        d[store] = d[idxHi];</span>
<span class="fc" id="L1935">        d[idxHi] = swap3;</span>
        
<span class="fc" id="L1937">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(
        TFloatList a, TFloatList b, TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L1943">        float x = a.get(idxHi);</span>
<span class="fc" id="L1944">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1946" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1947">            boolean doSwap = false;</span>
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L1949">                doSwap = true;</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L1951" title="All 2 branches covered.">                if (b.get(i) &lt;= b.get(idxHi)) {</span>
<span class="fc" id="L1952">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1955" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1956">                store++;</span>
<span class="fc" id="L1957">                float swap = a.get(store);</span>
<span class="fc" id="L1958">                a.set(store, a.get(i));</span>
<span class="fc" id="L1959">                a.set(i, swap);</span>
<span class="fc" id="L1960">                swap = b.get(store);</span>
<span class="fc" id="L1961">                b.set(store, b.get(i));</span>
<span class="fc" id="L1962">                b.set(i, swap);</span>
<span class="fc" id="L1963">                int swap2 = c.get(store);</span>
<span class="fc" id="L1964">                c.set(store, c.get(i));</span>
<span class="fc" id="L1965">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L1968">        store++;</span>
        
<span class="fc" id="L1970">        float swap = a.get(store);</span>
<span class="fc" id="L1971">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L1972">        a.set(idxHi, swap);</span>
        
<span class="fc" id="L1974">        swap = b.get(store);</span>
<span class="fc" id="L1975">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L1976">        b.set(idxHi, swap);</span>
        
<span class="fc" id="L1978">        int swap2 = c.get(store);</span>
<span class="fc" id="L1979">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L1980">        c.set(idxHi, swap2);</span>
        
<span class="fc" id="L1982">        return store;</span>
    }
   
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, float[] c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1997" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1998">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2001">            return;</span>
        }
<span class="pc bpc" id="L2003" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2004">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2007">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2009" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2010">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2012" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2013">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2015" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2016">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2017">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2018">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2020">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c) {
        
<span class="pc bpc" id="L2034" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2035">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2037" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2038">            return;</span>
        }
<span class="pc bpc" id="L2040" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2041">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2044">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2046" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2047">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2050">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc" id="L2052">        sortBy1stThen2ndThen3rd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2053">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2069">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2071" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2072">            return;</span>
        }
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2075">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2077" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2078">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2081">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2084">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2087" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2088">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2089">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2090">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2092">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b) {
<span class="nc bnc" id="L2095" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2096">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2099">            return;</span>
        }
<span class="nc bnc" id="L2101" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2102">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2104" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2105">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc" id="L2107">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2108">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b) {
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2112">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2115">            return;</span>
        }
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2118">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2120" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2121">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc" id="L2123">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2124">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a) {
<span class="pc bpc" id="L2127" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2128">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2130" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2131">            return;</span>
        }
<span class="fc" id="L2133">        sortByYThenX(a, 0, a.length - 1);</span>
<span class="fc" id="L2134">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b) {
        
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2140">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2143">            return;</span>
        }
<span class="pc bpc" id="L2145" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2146">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc" id="L2149">        sortByDecrYThenIncrX(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2150">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2156">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2158" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2159">            return;</span>
        }
<span class="pc bpc" id="L2161" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2162">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2166">            int idxMid = partitionByDecrYThenIncrX(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2167">            sortByDecrYThenIncrX(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2168">            sortByDecrYThenIncrX(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2170">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2175">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2177" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2178">            return;</span>
        }
        
<span class="fc bfc" id="L2181" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2182">            int idxMid = partitionByYThenX(a, idxLo, idxHi);</span>
<span class="fc" id="L2183">            sortByYThenX(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L2184">            sortByYThenX(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2186">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2189" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2190">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2193">            return;</span>
        }
<span class="pc bpc" id="L2195" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2196">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2198" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2199">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2201" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2202">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2203">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2204">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2206">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2210">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2213">            return;</span>
        }
<span class="pc bpc" id="L2215" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2216">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2219">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2221" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2222">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2223">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2224">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2226">    }</span>
    
    public static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c) {
        
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2232">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2234" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2235">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2237" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L2238">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L2241">        sortBy1stThen2nd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2242">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with ties sorted by b
     * and all swap operations performed on all arrays. The sorts are
     * ascending.
     * @param a
     * @param b
     * @param c
     * @param d
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2nd(double[] a, double[] b, int[] c, int[] d, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2258" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2259">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2262">            return;</span>
        }
<span class="pc bpc" id="L2264" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2265">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2268">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L2271">            throw new IllegalArgumentException(&quot;d cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2273" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2274">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2277">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">        if (a.length != d.length) {</span>
<span class="nc" id="L2280">            throw new IllegalArgumentException(&quot;a and d must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2283">            int idxMid = partitionBy1stThen2nd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2284">            sortBy1stThen2nd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2285">            sortBy1stThen2nd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2287">    }</span>

    private static void sortBy1stArg(int[] a, List b, int idxLo, int idxHi) {
    
<span class="fc bfc" id="L2291" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2292">            int idxMid = partitionBy1stArg(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2293">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2294">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2296">    }</span>
    
    public static void sort(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2302">            int idxMid = partition(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2303">            sort(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2304">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2306">    }</span>

    private static int partition(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L2311">        float x = a[idxHi];</span>
<span class="fc" id="L2312">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2314" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L2315" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2316">                store++;</span>
<span class="fc" id="L2317">                float swap = a[store];</span>
<span class="fc" id="L2318">                a[store] = a[i];</span>
<span class="fc" id="L2319">                a[i] = swap;</span>
<span class="fc" id="L2320">                float swap2 = b[store];</span>
<span class="fc" id="L2321">                b[store] = b[i];</span>
<span class="fc" id="L2322">                b[i] = swap2;</span>
<span class="fc" id="L2323">                swap2 = c[store];</span>
<span class="fc" id="L2324">                c[store] = c[i];</span>
<span class="fc" id="L2325">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2328">        store++;</span>
<span class="fc" id="L2329">        float swap = a[store];</span>
<span class="fc" id="L2330">        a[store] = a[idxHi];</span>
<span class="fc" id="L2331">        a[idxHi] = swap;</span>
<span class="fc" id="L2332">        float swap2 = b[store];</span>
<span class="fc" id="L2333">        b[store] = b[idxHi];</span>
<span class="fc" id="L2334">        b[idxHi] = swap2;</span>
<span class="fc" id="L2335">        swap2 = c[store];</span>
<span class="fc" id="L2336">        c[store] = c[idxHi];</span>
<span class="fc" id="L2337">        c[idxHi] = swap2;</span>
<span class="fc" id="L2338">        return store;</span>
    }

    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int idxLo, int idxHi) {
        
<span class="fc" id="L2344">        float x = a[idxHi];</span>
<span class="fc" id="L2345">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2347" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2348">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2349" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2350">                doSwap = true;</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2353">                    doSwap = true;</span>
<span class="pc bpc" id="L2354" title="1 of 2 branches missed.">                } else if (b[i] == b[idxHi]) {</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">                    if (c[i] &lt;= c[idxHi]) {</span>
<span class="nc" id="L2356">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2360" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2361">                store++;</span>
<span class="fc" id="L2362">                float swap = a[store];</span>
<span class="fc" id="L2363">                a[store] = a[i];</span>
<span class="fc" id="L2364">                a[i] = swap;</span>
<span class="fc" id="L2365">                float swap2 = b[store];</span>
<span class="fc" id="L2366">                b[store] = b[i];</span>
<span class="fc" id="L2367">                b[i] = swap2;</span>
<span class="fc" id="L2368">                swap2 = c[store];</span>
<span class="fc" id="L2369">                c[store] = c[i];</span>
<span class="fc" id="L2370">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2373">        store++;</span>
<span class="fc" id="L2374">        float swap = a[store];</span>
<span class="fc" id="L2375">        a[store] = a[idxHi];</span>
<span class="fc" id="L2376">        a[idxHi] = swap;</span>
<span class="fc" id="L2377">        float swap2 = b[store];</span>
<span class="fc" id="L2378">        b[store] = b[idxHi];</span>
<span class="fc" id="L2379">        b[idxHi] = swap2;</span>
<span class="fc" id="L2380">        swap2 = c[store];</span>
<span class="fc" id="L2381">        c[store] = c[idxHi];</span>
<span class="fc" id="L2382">        c[idxHi] = swap2;</span>
<span class="fc" id="L2383">        return store;</span>
    }
    
    private static int partitionBy1stArg(int[] a, List b, int idxLo, int idxHi) {
        
<span class="fc" id="L2388">        int x = a[idxHi];</span>
<span class="fc" id="L2389">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2391" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2392">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2393" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2394">                doSwap = true;</span>
            }
<span class="fc bfc" id="L2396" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2397">                store++;</span>
<span class="fc" id="L2398">                int swap = a[store];</span>
<span class="fc" id="L2399">                a[store] = a[i];</span>
<span class="fc" id="L2400">                a[i] = swap;</span>
<span class="fc" id="L2401">                Object swap2 = b.get(store);</span>
<span class="fc" id="L2402">                b.set(store, b.get(i));</span>
<span class="fc" id="L2403">                b.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2406">        store++;</span>
<span class="fc" id="L2407">        int swap = a[store];</span>
<span class="fc" id="L2408">        a[store] = a[idxHi];</span>
<span class="fc" id="L2409">        a[idxHi] = swap;</span>
<span class="fc" id="L2410">        Object swap2 = b.get(store);</span>
<span class="fc" id="L2411">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2412">        b.set(idxHi, swap2);</span>
        
<span class="fc" id="L2414">        return store;</span>
    }
    
    private static int partitionBy1stThen2ndThen3rd(
        TIntList a, TIntList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2421">        int x = a.get(idxHi);</span>
<span class="fc" id="L2422">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2424" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2425">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2426" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2427">                doSwap = true;</span>
<span class="fc bfc" id="L2428" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2429" title="All 2 branches covered.">                if (b.get(i) &lt; b.get(idxHi)) {</span>
<span class="fc" id="L2430">                    doSwap = true;</span>
<span class="fc bfc" id="L2431" title="All 2 branches covered.">                } else if (b.get(i) == b.get(idxHi)) {</span>
<span class="pc bpc" id="L2432" title="1 of 2 branches missed.">                    if (c.get(i) &lt;= c.get(idxHi)) {</span>
<span class="nc" id="L2433">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2437" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2438">                store++;</span>
<span class="fc" id="L2439">                int swap = a.get(store);</span>
<span class="fc" id="L2440">                a.set(store, a.get(i));</span>
<span class="fc" id="L2441">                a.set(i, swap);</span>
<span class="fc" id="L2442">                int swap2 = b.get(store);</span>
<span class="fc" id="L2443">                b.set(store, b.get(i));</span>
<span class="fc" id="L2444">                b.set(i, swap2);</span>
<span class="fc" id="L2445">                swap2 = c.get(store);</span>
<span class="fc" id="L2446">                c.set(store, c.get(i));</span>
<span class="fc" id="L2447">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2450">        store++;</span>
<span class="fc" id="L2451">        int swap = a.get(store);</span>
<span class="fc" id="L2452">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2453">        a.set(idxHi, swap);</span>
<span class="fc" id="L2454">        int swap2 = b.get(store);</span>
<span class="fc" id="L2455">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2456">        b.set(idxHi, swap2);</span>
<span class="fc" id="L2457">        swap2 = c.get(store);</span>
<span class="fc" id="L2458">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2459">        c.set(idxHi, swap2);</span>
<span class="fc" id="L2460">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(float[] a, float[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2466">        float x = a[idxHi];</span>
<span class="fc" id="L2467">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2469" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2470">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2471" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2472">                doSwap = true;</span>
<span class="fc bfc" id="L2473" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2474" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2475">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2478" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2479">                store++;</span>
<span class="fc" id="L2480">                float swap = a[store];</span>
<span class="fc" id="L2481">                a[store] = a[i];</span>
<span class="fc" id="L2482">                a[i] = swap;</span>
<span class="fc" id="L2483">                float swap2 = b[store];</span>
<span class="fc" id="L2484">                b[store] = b[i];</span>
<span class="fc" id="L2485">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2488">        store++;</span>
<span class="fc" id="L2489">        float swap = a[store];</span>
<span class="fc" id="L2490">        a[store] = a[idxHi];</span>
<span class="fc" id="L2491">        a[idxHi] = swap;</span>
<span class="fc" id="L2492">        float swap2 = b[store];</span>
<span class="fc" id="L2493">        b[store] = b[idxHi];</span>
<span class="fc" id="L2494">        b[idxHi] = swap2;</span>
<span class="fc" id="L2495">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(int[] a, int[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2501">        int x = a[idxHi];</span>
<span class="fc" id="L2502">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2504" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2505">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2506" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2507">                doSwap = true;</span>
<span class="fc bfc" id="L2508" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2509" title="1 of 2 branches missed.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="nc" id="L2510">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2513" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2514">                store++;</span>
<span class="fc" id="L2515">                int swap = a[store];</span>
<span class="fc" id="L2516">                a[store] = a[i];</span>
<span class="fc" id="L2517">                a[i] = swap;</span>
<span class="fc" id="L2518">                int swap2 = b[store];</span>
<span class="fc" id="L2519">                b[store] = b[i];</span>
<span class="fc" id="L2520">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2523">        store++;</span>
<span class="fc" id="L2524">        int swap = a[store];</span>
<span class="fc" id="L2525">        a[store] = a[idxHi];</span>
<span class="fc" id="L2526">        a[idxHi] = swap;</span>
<span class="fc" id="L2527">        int swap2 = b[store];</span>
<span class="fc" id="L2528">        b[store] = b[idxHi];</span>
<span class="fc" id="L2529">        b[idxHi] = swap2;</span>
        
<span class="fc" id="L2531">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int partitionByYThenX(T[] a, int idxLo, 
        int idxHi) {
     
<span class="fc" id="L2537">        T x = a[idxHi];</span>
<span class="fc" id="L2538">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2540" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2541">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2542" title="All 2 branches covered.">            if (a[i].getY() &lt; x.getY()) {</span>
<span class="fc" id="L2543">                doSwap = true;</span>
<span class="fc bfc" id="L2544" title="All 2 branches covered.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="fc bfc" id="L2545" title="All 2 branches covered.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="fc" id="L2546">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2549" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2550">                store++;</span>
<span class="fc" id="L2551">                T swap = a[store];</span>
<span class="fc" id="L2552">                a[store] = a[i];</span>
<span class="fc" id="L2553">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L2556">        store++;</span>
<span class="fc" id="L2557">        T swap = a[store];</span>
<span class="fc" id="L2558">        a[store] = a[idxHi];</span>
<span class="fc" id="L2559">        a[idxHi] = swap;</span>
<span class="fc" id="L2560">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int 
    partitionByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
     
<span class="fc" id="L2566">        T x = a[idxHi];</span>
<span class="fc" id="L2567">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2569" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2570">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">            if (a[i].getY() &gt; x.getY()) {</span>
<span class="fc" id="L2572">                doSwap = true;</span>
<span class="pc bpc" id="L2573" title="1 of 2 branches missed.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="nc bnc" id="L2574" title="All 2 branches missed.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="nc" id="L2575">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2578" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2579">                store++;</span>
<span class="fc" id="L2580">                T swap = a[store];</span>
<span class="fc" id="L2581">                a[store] = a[i];</span>
<span class="fc" id="L2582">                a[i] = swap;</span>
<span class="fc" id="L2583">                int swap2 = b[store];</span>
<span class="fc" id="L2584">                b[store] = b[i];</span>
<span class="fc" id="L2585">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2588">        store++;</span>
<span class="fc" id="L2589">        T swap = a[store];</span>
<span class="fc" id="L2590">        a[store] = a[idxHi];</span>
<span class="fc" id="L2591">        a[idxHi] = swap;</span>
<span class="fc" id="L2592">        int swap2 = b[store];</span>
<span class="fc" id="L2593">        b[store] = b[idxHi];</span>
<span class="fc" id="L2594">        b[idxHi] = swap2;</span>
<span class="fc" id="L2595">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(double[] a, double[] b, int[] c,
        int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2601">        double x = a[idxHi];</span>
<span class="fc" id="L2602">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2604" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2605">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2606" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2607">                doSwap = true;</span>
<span class="fc bfc" id="L2608" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2609" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2610">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2613" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2614">                store++;</span>
<span class="fc" id="L2615">                double swap = a[store];</span>
<span class="fc" id="L2616">                a[store] = a[i];</span>
<span class="fc" id="L2617">                a[i] = swap;</span>
<span class="fc" id="L2618">                swap = b[store];</span>
<span class="fc" id="L2619">                b[store] = b[i];</span>
<span class="fc" id="L2620">                b[i] = swap;</span>
<span class="fc" id="L2621">                int swap2 = c[store];</span>
<span class="fc" id="L2622">                c[store] = c[i];</span>
<span class="fc" id="L2623">                c[i] = swap2;</span>
<span class="fc" id="L2624">                swap2 = d[store];</span>
<span class="fc" id="L2625">                d[store] = d[i];</span>
<span class="fc" id="L2626">                d[i] = swap2;</span>
            }
        }
<span class="fc" id="L2629">        store++;</span>
<span class="fc" id="L2630">        double swap = a[store];</span>
<span class="fc" id="L2631">        a[store] = a[idxHi];</span>
<span class="fc" id="L2632">        a[idxHi] = swap;</span>
<span class="fc" id="L2633">        swap = b[store];</span>
<span class="fc" id="L2634">        b[store] = b[idxHi];</span>
<span class="fc" id="L2635">        b[idxHi] = swap;</span>
<span class="fc" id="L2636">        int swap2 = c[store];</span>
<span class="fc" id="L2637">        c[store] = c[idxHi];</span>
<span class="fc" id="L2638">        c[idxHi] = swap2;</span>
<span class="fc" id="L2639">        swap2 = d[store];</span>
<span class="fc" id="L2640">        d[store] = d[idxHi];</span>
<span class="fc" id="L2641">        d[idxHi] = swap2;        </span>
<span class="fc" id="L2642">        return store;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
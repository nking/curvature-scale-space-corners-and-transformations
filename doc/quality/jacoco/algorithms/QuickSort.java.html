<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuickSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">QuickSort.java</span></div><h1>QuickSort.java</h1><pre class="source lang-java linenums">package algorithms;

import algorithms.misc.MiscSorter;
import algorithms.util.IntIntDouble;
import algorithms.util.PairInt;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import java.util.List;

/**
 *
 * @author nichole
 */
<span class="nc" id="L15">public class QuickSort {</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * @param a
     */
    public static void sort(float[] a) {
<span class="fc" id="L22">        sort(a, 0, a.length - 1);</span>
<span class="fc" id="L23">    }</span>
    
    public static void descendingSort(int[] a, int[] b) {
        
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L28">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L31">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L33" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L34">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L37">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="fc" id="L38">    }</span>
    
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b) {
        
<span class="nc bnc" id="L42" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L43">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L45" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L46">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L49">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L52">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="nc" id="L53">    }</span>
    
    public static void descendingSort(TIntList a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L61">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L64">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L67">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L68">    }</span>
    
    public static void descendingSort(List&lt;? extends Number&gt; a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L73">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L76">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L79">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L82">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L83">    }</span>
    
    public static void descendingSort(double[] a) {
        
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
        
<span class="fc" id="L91">        descendingSort(a, 0, a.length - 1);</span>
<span class="fc" id="L92">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[][] b) {
        
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L106">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="nc" id="L107">    }</span>
    
    public static void sortBy1stArg(int[] a, int[] b) {
<span class="fc" id="L110">        MiscSorter.sortBy1stArg(a, b);    </span>
<span class="fc" id="L111">    }</span>
    
    public static void sortByA(IntIntDouble[] abc) {
        
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L116">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="fc" id="L119">        sortByA(abc, 0, abc.length - 1);</span>
<span class="fc" id="L120">    }</span>
    
    public static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b) {
    
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L125">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L128">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L131">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L134">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L135">    }</span>

    /**
     * sort a by ascending values and perform the same swap operation on b.
     * @param a
     * @param b 
     */
    public static void sortBy1stArg(float[] a, int[] b) {
        
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L148">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L151">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L154">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L155">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[] b) {
        
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L160">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L163">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L166">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L169">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L170">    }</span>
    
    public static void sortBy1stArg(float[] a, Object[] b) {
        
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L175">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L181">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L184">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L185">    }</span>
    
    public static void sortBy1stArg(TDoubleList a, int[] b) {
        
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L190">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L193">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L196">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L199">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L200">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b) {

<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L205">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L208">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L211">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L214">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="nc" id="L215">    }</span>
    
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b) {

<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L220">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L223">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L229">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L230">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b, TIntList c) {

<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L235">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L238">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L241">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L243" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L244">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L247">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L248">    }</span>
    
    public static void sortBy1stArg(TIntList a, TDoubleList b,
        TIntList c) {
        
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L254">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L257">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L260">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L263">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L266">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="fc" id="L269">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L270">    }</span>
    
    public static void sortBy1stArg(TIntList a, TIntList b) {
        
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L275">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L281">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L284">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L285">    }</span>
    
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
<span class="fc" id="L288">        sortBy1stArgDesc(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L289">    }</span>
    
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L295">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L298">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L301">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L304">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L311">            return;</span>
        }
        
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L316">            int x = a[idxLo];</span>
<span class="fc" id="L317">            int store = idxLo;</span>
<span class="fc" id="L318">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L322">                    store++;     </span>
<span class="fc bfc" id="L323" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt;= x));</span>
                do {
<span class="fc" id="L325">                    idxMid--;</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                } while (a[idxMid] &lt;= x);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L328">                    break;</span>
                }
<span class="fc" id="L330">                int swap = a[store];</span>
<span class="fc" id="L331">                a[store] = a[idxMid];</span>
<span class="fc" id="L332">                a[idxMid] = swap;</span>
                
<span class="fc" id="L334">                T swap2 = b.get(store);</span>
<span class="fc" id="L335">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L336">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L338">                S swap3 = c.get(store);</span>
<span class="fc" id="L339">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L340">                c.set(idxMid, swap3);</span>
                
<span class="fc" id="L342">            }</span>
            
<span class="fc" id="L344">            int swap = a[idxLo];</span>
<span class="fc" id="L345">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L346">            a[idxMid] = swap;</span>

<span class="fc" id="L348">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L349">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L350">            b.set(idxMid, swap2);</span>

<span class="fc" id="L352">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L353">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L354">            c.set(idxMid, swap3);</span>
         
<span class="fc" id="L356">            sortBy1stArgDesc(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L358">            sortBy1stArgDesc(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L360">    }</span>

    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L374">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L377">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L380">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L383">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L386">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L390">            return;</span>
        }
        
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L395">            int x = a.get(idxLo);</span>
<span class="fc" id="L396">            int store = idxLo;</span>
<span class="fc" id="L397">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L401">                    store++;     </span>
<span class="fc bfc" id="L402" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L404">                    idxMid--;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L407">                    break;</span>
                }
<span class="nc" id="L409">                int swap = a.get(store);</span>
<span class="nc" id="L410">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L411">                a.set(idxMid, swap);</span>
<span class="nc" id="L412">                swap = c.get(store);</span>
<span class="nc" id="L413">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L414">                c.set(idxMid, swap);</span>
                
<span class="nc" id="L416">                double bSwap = b.get(store);</span>
<span class="nc" id="L417">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L418">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L419">            }</span>
<span class="fc" id="L420">            int swap = a.get(idxLo);</span>
<span class="fc" id="L421">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L422">            a.set(idxMid, swap);</span>
<span class="fc" id="L423">            swap = c.get(idxLo);</span>
<span class="fc" id="L424">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L425">            c.set(idxMid, swap);</span>
            
<span class="fc" id="L427">            double bSwap = b.get(idxLo);</span>
<span class="fc" id="L428">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L429">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L431">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L433">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L435">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b,  
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L449">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L452">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L455">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L458">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L461">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L465">            return;</span>
        }
        
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L470">            float x = a.get(idxLo);</span>
<span class="fc" id="L471">            int store = idxLo;</span>
<span class="fc" id="L472">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L476">                    store++;     </span>
<span class="fc bfc" id="L477" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L479">                    idxMid--;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L482">                    break;</span>
                }
<span class="nc" id="L484">                float swap = a.get(store);</span>
<span class="nc" id="L485">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L486">                a.set(idxMid, swap);</span>
<span class="nc" id="L487">                int swap2 = c.get(store);</span>
<span class="nc" id="L488">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L489">                c.set(idxMid, swap2);</span>
                
<span class="nc" id="L491">                swap2 = b.get(store);</span>
<span class="nc" id="L492">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L493">                b.set(idxMid, swap2);</span>
<span class="nc" id="L494">            }</span>
<span class="fc" id="L495">            float swap = a.get(idxLo);</span>
<span class="fc" id="L496">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L497">            a.set(idxMid, swap);</span>
<span class="fc" id="L498">            int swap2 = c.get(idxLo);</span>
<span class="fc" id="L499">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L500">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L502">            swap2 = b.get(idxLo);</span>
<span class="fc" id="L503">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L504">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L506">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L508">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L510">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, 
        int idxLo, int idxHi) {
        
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L524">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L527">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L530">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L534">            return;</span>
        }
        
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L539">            float x = a.get(idxLo);</span>
<span class="nc" id="L540">            int store = idxLo;</span>
<span class="nc" id="L541">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L545">                    store++;     </span>
<span class="nc bnc" id="L546" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="nc" id="L548">                    idxMid--;</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                } while (a.get(idxMid) &gt; x);</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L551">                    break;</span>
                }
<span class="nc" id="L553">                float swap = a.get(store);</span>
<span class="nc" id="L554">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L555">                a.set(idxMid, swap);</span>
<span class="nc" id="L556">                int swap2 = b.get(store);</span>
<span class="nc" id="L557">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L558">                b.set(idxMid, swap2);</span>
                
<span class="nc" id="L560">            }</span>
<span class="nc" id="L561">            float swap = a.get(idxLo);</span>
<span class="nc" id="L562">            a.set(idxLo, a.get(idxMid));</span>
<span class="nc" id="L563">            a.set(idxMid, swap);</span>
<span class="nc" id="L564">            int bSwap = b.get(idxLo);</span>
<span class="nc" id="L565">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L566">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L568">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L570">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L572">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L586">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L589">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L592">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L596">            return;</span>
        }
        
<span class="fc bfc" id="L599" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L601">            float x = a.get(idxLo);</span>
<span class="fc" id="L602">            int store = idxLo;</span>
<span class="fc" id="L603">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L607">                    store++;     </span>
<span class="fc bfc" id="L608" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L610">                    idxMid--;</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L613">                    break;</span>
                }
<span class="fc" id="L615">                float swap = a.get(store);</span>
<span class="fc" id="L616">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L617">                a.set(idxMid, swap);</span>
<span class="fc" id="L618">                T swap2 = b.get(store);</span>
<span class="fc" id="L619">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L620">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L622">            }</span>
<span class="fc" id="L623">            float swap = a.get(idxLo);</span>
<span class="fc" id="L624">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L625">            a.set(idxMid, swap);</span>
<span class="fc" id="L626">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L627">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L628">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L630">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L632">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L634">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TIntList b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L647">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L650">            throw new IllegalArgumentException(&quot;v cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L653">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L657">            return;</span>
        }
        
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L662">            int x = a.get(idxLo);</span>
<span class="fc" id="L663">            int store = idxLo;</span>
<span class="fc" id="L664">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L668">                    store++;     </span>
<span class="fc bfc" id="L669" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L671">                    idxMid--;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L674">                    break;</span>
                }
<span class="nc" id="L676">                int swap = a.get(store);</span>
<span class="nc" id="L677">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L678">                a.set(idxMid, swap);</span>
<span class="nc" id="L679">                swap = b.get(store);</span>
<span class="nc" id="L680">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L681">                b.set(idxMid, swap);</span>
<span class="nc" id="L682">            }</span>
<span class="fc" id="L683">            int swap = a.get(idxLo);</span>
<span class="fc" id="L684">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L685">            a.set(idxMid, swap);</span>
<span class="fc" id="L686">            swap = b.get(idxLo);</span>
<span class="fc" id="L687">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L688">            b.set(idxMid, swap);</span>
         
<span class="fc" id="L690">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L692">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L694">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortByA(IntIntDouble[] abc, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L708">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if (abc.length &lt; 2) {</span>
<span class="nc" id="L712">            return;</span>
        }
        
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L717">            int x = abc[idxLo].getA();</span>
<span class="fc" id="L718">            int store = idxLo;</span>
<span class="fc" id="L719">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L723">                    store++;     </span>
<span class="fc bfc" id="L724" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (abc[store].getA() &lt; x));</span>
                do {
<span class="fc" id="L726">                    idxMid--;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                } while (abc[idxMid].getA() &gt; x);</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L729">                    break;</span>
                }
<span class="nc" id="L731">                IntIntDouble swap = abc[store];</span>
<span class="nc" id="L732">                abc[store] = abc[idxMid];</span>
<span class="nc" id="L733">                abc[idxMid] = swap;</span>
<span class="nc" id="L734">            }</span>
<span class="fc" id="L735">            IntIntDouble swap = abc[idxLo];</span>
<span class="fc" id="L736">            abc[idxLo] = abc[idxMid];</span>
<span class="fc" id="L737">            abc[idxMid] = swap;</span>
         
<span class="fc" id="L739">            sortByA(abc, idxLo, idxMid - 1);</span>

<span class="fc" id="L741">            sortByA(abc, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L743">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L755">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L758">            return;</span>
        }
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L762">            float x = a[idxLo];</span>
<span class="fc" id="L763">            int store = idxLo;</span>
<span class="fc" id="L764">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L768">                    store++;     </span>
<span class="fc bfc" id="L769" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L771">                    idxMid--;</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L774">                    break;</span>
                }
<span class="fc" id="L776">                float swap = a[store];</span>
<span class="fc" id="L777">                a[store] = a[idxMid];</span>
<span class="fc" id="L778">                a[idxMid] = swap;</span>
<span class="fc" id="L779">            }</span>
<span class="fc" id="L780">            float swap = a[idxLo];</span>
<span class="fc" id="L781">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L782">            a[idxMid] = swap;</span>
         
<span class="fc" id="L784">            sort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L786">            sort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L788">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L802">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L805">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L807" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L808">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc bnc" id="L810" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L811">            return;</span>
        }
        
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L816">            int x = a[idxLo];</span>
<span class="nc" id="L817">            int store = idxLo;</span>
<span class="nc" id="L818">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L822">                    store++;     </span>
<span class="nc bnc" id="L823" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="nc" id="L825">                    idxMid--;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                } while (a[idxMid] &lt; x);</span>
                
<span class="nc bnc" id="L828" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L829">                    break;</span>
                }
<span class="nc" id="L831">                int swap = a[store];</span>
<span class="nc" id="L832">                a[store] = a[idxMid];</span>
<span class="nc" id="L833">                a[idxMid] = swap;</span>
<span class="nc" id="L834">                T swap2 = b[store];</span>
<span class="nc" id="L835">                b[store] = b[idxMid];</span>
<span class="nc" id="L836">                b[idxMid] = swap2;</span>
<span class="nc" id="L837">            }</span>
<span class="nc" id="L838">            int swap = a[idxLo];</span>
<span class="nc" id="L839">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L840">            a[idxMid] = swap;</span>
<span class="nc" id="L841">            T swap2 = b[idxLo];</span>
<span class="nc" id="L842">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L843">            b[idxMid] = swap2;</span>
         
<span class="nc" id="L845">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L847">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L849">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L862">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L865">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L868">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L870" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L871">            return;</span>
        }
        
<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L876">            int x = a[idxLo];</span>
<span class="fc" id="L877">            int store = idxLo;</span>
<span class="fc" id="L878">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L882">                    store++;     </span>
<span class="pc bpc" id="L883" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L885">                    idxMid--;</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L888" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L889">                    break;</span>
                }
<span class="fc" id="L891">                int swap = a[store];</span>
<span class="fc" id="L892">                a[store] = a[idxMid];</span>
<span class="fc" id="L893">                a[idxMid] = swap;</span>
<span class="fc" id="L894">                swap = b[store];</span>
<span class="fc" id="L895">                b[store] = b[idxMid];</span>
<span class="fc" id="L896">                b[idxMid] = swap;</span>
<span class="fc" id="L897">            }</span>
<span class="fc" id="L898">            int swap = a[idxLo];</span>
<span class="fc" id="L899">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L900">            a[idxMid] = swap;</span>
<span class="fc" id="L901">            swap = b[idxLo];</span>
<span class="fc" id="L902">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L903">            b[idxMid] = swap;</span>
         
<span class="fc" id="L905">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L907">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L909">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param &lt;T&gt;
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(
        TIntList a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L925">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L928">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L931">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L934">            return;</span>
        }
        
<span class="fc bfc" id="L937" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L939">            int x = a.get(idxLo);</span>
<span class="fc" id="L940">            int store = idxLo;</span>
<span class="fc" id="L941">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L945">                    store++;     </span>
<span class="pc bpc" id="L946" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &gt; x));</span>
                do {
<span class="fc" id="L948">                    idxMid--;</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">                } while (a.get(idxMid) &lt; x);</span>
                
<span class="fc bfc" id="L951" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L952">                    break;</span>
                }
<span class="fc" id="L954">                int swap = a.get(store);</span>
<span class="fc" id="L955">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L956">                a.set(idxMid, swap);</span>
<span class="fc" id="L957">                T swap2 = b.get(store);</span>
<span class="fc" id="L958">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L959">                b.set(idxMid, swap2);</span>
<span class="fc" id="L960">            }</span>
<span class="fc" id="L961">            int swap = a.get(idxLo);</span>
<span class="fc" id="L962">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L963">            a.set(idxMid, swap);</span>
<span class="fc" id="L964">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L965">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L966">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L968">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L970">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L972">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;S extends Number, T extends Object&gt; void descendingSort(
        List&lt;S&gt; a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L986">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L989">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L992">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (a.size() &lt; 2) {</span>
<span class="fc" id="L995">            return;</span>
        }
        
<span class="fc bfc" id="L998" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1000">            float x = a.get(idxLo).floatValue();</span>
<span class="fc" id="L1001">            int store = idxLo;</span>
<span class="fc" id="L1002">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1006">                    store++;     </span>
<span class="fc bfc" id="L1007" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store).floatValue() &gt; x));</span>
                do {
<span class="fc" id="L1009">                    idxMid--;</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">                } while (a.get(idxMid).floatValue() &lt; x);</span>
                
<span class="fc bfc" id="L1012" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1013">                    break;</span>
                }
<span class="fc" id="L1015">                S swap = a.get(store);</span>
<span class="fc" id="L1016">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1017">                a.set(idxMid, swap);</span>
<span class="fc" id="L1018">                T swap2 = b.get(store);</span>
<span class="fc" id="L1019">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1020">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1021">            }</span>
<span class="fc" id="L1022">            S swap = a.get(idxLo);</span>
<span class="fc" id="L1023">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1024">            a.set(idxMid, swap);</span>
<span class="fc" id="L1025">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1026">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1027">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1029">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1031">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1033">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(double[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1046">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1048" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1049">            return;</span>
        }
        
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1054">            double x = a[idxLo];</span>
<span class="fc" id="L1055">            int store = idxLo;</span>
<span class="fc" id="L1056">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1060">                    store++;     </span>
<span class="fc bfc" id="L1061" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1063">                    idxMid--;</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1066" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1067">                    break;</span>
                }
<span class="fc" id="L1069">                double swap = a[store];</span>
<span class="fc" id="L1070">                a[store] = a[idxMid];</span>
<span class="fc" id="L1071">                a[idxMid] = swap;</span>
<span class="fc" id="L1072">            }</span>
<span class="fc" id="L1073">            double swap = a[idxLo];</span>
<span class="fc" id="L1074">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1075">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1077">            descendingSort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1079">            descendingSort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1081">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1095">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1097" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1098">            return;</span>
        }
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1102">            float x = a[idxLo];</span>
<span class="fc" id="L1103">            int store = idxLo;</span>
<span class="fc" id="L1104">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1108">                    store++;     </span>
<span class="fc bfc" id="L1109" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1111">                    idxMid--;</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1114">                    break;</span>
                }
<span class="fc" id="L1116">                float swap = a[store];</span>
<span class="fc" id="L1117">                a[store] = a[idxMid];</span>
<span class="fc" id="L1118">                a[idxMid] = swap;</span>
<span class="fc" id="L1119">                int swap2 = b[store];</span>
<span class="fc" id="L1120">                b[store] = b[idxMid];</span>
<span class="fc" id="L1121">                b[idxMid] = swap2;</span>
<span class="fc" id="L1122">            }</span>
<span class="fc" id="L1123">            float swap = a[idxLo];</span>
<span class="fc" id="L1124">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1125">            a[idxMid] = swap;</span>
<span class="fc" id="L1126">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1127">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1128">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1130">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1132">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1134">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TDoubleList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1148">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1151">            return;</span>
        }
<span class="fc bfc" id="L1153" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1155">            double x = a.get(idxLo);</span>
<span class="fc" id="L1156">            int store = idxLo;</span>
<span class="fc" id="L1157">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1161">                    store++;     </span>
<span class="fc bfc" id="L1162" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L1164">                    idxMid--;</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1167">                    break;</span>
                }
<span class="fc" id="L1169">                double swap = a.get(store);</span>
<span class="fc" id="L1170">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1171">                a.set(idxMid, swap);</span>
<span class="fc" id="L1172">                int swap2 = b[store];</span>
<span class="fc" id="L1173">                b[store] = b[idxMid];</span>
<span class="fc" id="L1174">                b[idxMid] = swap2;</span>
<span class="fc" id="L1175">            }</span>
<span class="fc" id="L1176">            double swap = a.get(idxLo);</span>
<span class="fc" id="L1177">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1178">            a.set(idxMid, swap);</span>
<span class="fc" id="L1179">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1180">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1181">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1183">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1185">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1187">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
<span class="nc" id="L1199">        MiscSorter.sortBy1stArg(a, b, idxLo, idxHi); </span>
<span class="nc" id="L1200">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[][] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1212" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1213">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1216">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1219">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1223">            return;</span>
        }
        
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1228">            int x = a[idxLo];</span>
<span class="nc" id="L1229">            int store = idxLo;</span>
<span class="nc" id="L1230">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1234">                    store++;     </span>
<span class="nc bnc" id="L1235" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1237">                    idxMid--;</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1240">                    break;</span>
                }
<span class="nc" id="L1242">                int swap = a[store];</span>
<span class="nc" id="L1243">                a[store] = a[idxMid];</span>
<span class="nc" id="L1244">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1246">                Object[] bSwap = b[store];</span>
<span class="nc" id="L1247">                b[store] = b[idxMid];</span>
<span class="nc" id="L1248">                b[idxMid] = bSwap;</span>
<span class="nc" id="L1249">            }</span>
<span class="nc" id="L1250">            int swap = a[idxLo];</span>
<span class="nc" id="L1251">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1252">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1254">            Object[] bSwap = b[idxLo];</span>
<span class="nc" id="L1255">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1256">            b[idxMid] = bSwap;</span>
         
<span class="nc" id="L1258">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1260">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1262">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
        
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1273">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1276">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1279">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1282">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L1285">        sortBy1stArg(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L1286">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1299">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1302">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1305">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1308">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1311" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1312">            return;</span>
        }
        
<span class="fc bfc" id="L1315" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1317">            float x = a[idxLo];</span>
<span class="fc" id="L1318">            int store = idxLo;</span>
<span class="fc" id="L1319">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1323">                    store++;     </span>
<span class="fc bfc" id="L1324" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1326">                    idxMid--;</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1329">                    break;</span>
                }
<span class="fc" id="L1331">                float swap = a[store];</span>
<span class="fc" id="L1332">                a[store] = a[idxMid];</span>
<span class="fc" id="L1333">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1335">                T swap2 = b.get(store);</span>
<span class="fc" id="L1336">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1337">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L1339">                S swap3 = c.get(store);</span>
<span class="fc" id="L1340">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L1341">                c.set(idxMid, swap3);</span>
<span class="fc" id="L1342">            }</span>
<span class="fc" id="L1343">            float swap = a[idxLo];</span>
<span class="fc" id="L1344">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1345">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1347">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1348">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1349">            b.set(idxMid, swap2);</span>
               
<span class="fc" id="L1351">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L1352">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L1353">            c.set(idxMid, swap3);</span>
            
<span class="fc" id="L1355">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1357">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1359">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1372">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1375">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1377" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1378">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1382">            return;</span>
        }
        
<span class="fc bfc" id="L1385" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1387">            int x = a[idxLo];</span>
<span class="fc" id="L1388">            int store = idxLo;</span>
<span class="fc" id="L1389">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1393">                    store++;     </span>
<span class="fc bfc" id="L1394" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1396">                    idxMid--;</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1399">                    break;</span>
                }
<span class="fc" id="L1401">                int swap = a[store];</span>
<span class="fc" id="L1402">                a[store] = a[idxMid];</span>
<span class="fc" id="L1403">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1405">                Object bSwap = b[store];</span>
<span class="fc" id="L1406">                b[store] = b[idxMid];</span>
<span class="fc" id="L1407">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1408">            }</span>
<span class="fc" id="L1409">            int swap = a[idxLo];</span>
<span class="fc" id="L1410">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1411">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1413">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1414">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1415">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1417">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1419">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1421">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1434">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1437">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1440">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1443" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1444">            return;</span>
        }
        
<span class="fc bfc" id="L1447" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1449">            float x = a[idxLo];</span>
<span class="fc" id="L1450">            int store = idxLo;</span>
<span class="fc" id="L1451">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1455">                    store++;     </span>
<span class="fc bfc" id="L1456" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1458">                    idxMid--;</span>
<span class="fc bfc" id="L1459" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1460" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1461">                    break;</span>
                }
<span class="fc" id="L1463">                float swap = a[store];</span>
<span class="fc" id="L1464">                a[store] = a[idxMid];</span>
<span class="fc" id="L1465">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1467">                T bSwap = b.get(store);</span>
<span class="fc" id="L1468">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1469">                b.set(idxMid, bSwap);</span>
<span class="fc" id="L1470">            }</span>
<span class="fc" id="L1471">            float swap = a[idxLo];</span>
<span class="fc" id="L1472">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1473">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1475">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L1476">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1477">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L1479">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1481">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1483">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1496">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1498" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1499">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1502">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc bfc" id="L1505" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1506">            return;</span>
        }
        
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1511">            float x = a[idxLo];</span>
<span class="fc" id="L1512">            int store = idxLo;</span>
<span class="fc" id="L1513">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1517">                    store++;     </span>
<span class="fc bfc" id="L1518" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1520">                    idxMid--;</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1523">                    break;</span>
                }
<span class="fc" id="L1525">                float swap = a[store];</span>
<span class="fc" id="L1526">                a[store] = a[idxMid];</span>
<span class="fc" id="L1527">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1529">                Object bSwap = b[store];</span>
<span class="fc" id="L1530">                b[store] = b[idxMid];</span>
<span class="fc" id="L1531">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1532">            }</span>
<span class="fc" id="L1533">            float swap = a[idxLo];</span>
<span class="fc" id="L1534">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1535">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1537">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1538">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1539">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1541">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1543">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1545">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * It's an adaption of the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b an array that will receive the same swap operations as are 
     * performed on a
     * @param c an array that will receive the same swap operations as are 
     * performed on a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int[] b, int[] c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1561" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1562">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1564" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1565">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1567" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1568">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1570" title="2 of 4 branches missed.">        if ((a.length != b.length) || (a.length != c.length)) {</span>
<span class="nc" id="L1571">            throw new IllegalArgumentException(&quot;array lengths must be the same&quot;);</span>
        }
        
<span class="fc bfc" id="L1574" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1576">            float x = a[idxLo];</span>
<span class="fc" id="L1577">            int store = idxLo;</span>
<span class="fc" id="L1578">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1582">                    store++;     </span>
<span class="fc bfc" id="L1583" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1585">                    idxMid--;</span>
<span class="fc bfc" id="L1586" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1588">                    break;</span>
                }
<span class="fc" id="L1590">                float swap = a[store];</span>
<span class="fc" id="L1591">                a[store] = a[idxMid];</span>
<span class="fc" id="L1592">                a[idxMid] = swap;</span>
<span class="fc" id="L1593">                int swap2 = b[store];</span>
<span class="fc" id="L1594">                b[store] = b[idxMid];</span>
<span class="fc" id="L1595">                b[idxMid] = swap2;</span>
<span class="fc" id="L1596">                swap2 = c[store];</span>
<span class="fc" id="L1597">                c[store] = c[idxMid];</span>
<span class="fc" id="L1598">                c[idxMid] = swap2;</span>
<span class="fc" id="L1599">            }</span>
<span class="fc" id="L1600">            float swap = a[idxLo];</span>
<span class="fc" id="L1601">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1602">            a[idxMid] = swap;</span>
<span class="fc" id="L1603">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1604">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1605">            b[idxMid] = swap2;</span>
<span class="fc" id="L1606">            swap2 = c[idxLo];</span>
<span class="fc" id="L1607">            c[idxLo] = c[idxMid];</span>
<span class="fc" id="L1608">            c[idxMid] = swap2;</span>
                     
<span class="fc" id="L1610">            sort(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1612">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1614">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecond(int[][] a) {
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1623">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1625" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1626">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1629">            return;</span>
        }
<span class="fc" id="L1631">        sortByDimension1FirstSecond(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1632">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecond(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1643">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1646">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1649">            return;</span>
        }
<span class="fc bfc" id="L1651" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1652">            int idxMid = partitionByDimension1FirstSecond(a, idxLo, idxHi);</span>
<span class="fc" id="L1653">            sortByDimension1FirstSecond(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1654">            sortByDimension1FirstSecond(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1656">    }</span>
    
    private static int partitionByDimension1FirstSecond(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1661">        int x = a[0][idxHi];</span>
<span class="fc" id="L1662">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1664" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1665">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1667">                doSwap = true;</span>
<span class="fc bfc" id="L1668" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1669" title="1 of 2 branches missed.">                if (a[1][i] &lt;= a[1][idxHi]) {</span>
<span class="nc" id="L1670">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1673" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1674">                store++;</span>
<span class="fc" id="L1675">                int swap = a[0][store];</span>
<span class="fc" id="L1676">                a[0][store] = a[0][i];</span>
<span class="fc" id="L1677">                a[0][i] = swap;</span>
                
<span class="fc" id="L1679">                swap = a[1][store];</span>
<span class="fc" id="L1680">                a[1][store] = a[1][i];</span>
<span class="fc" id="L1681">                a[1][i] = swap;</span>
            }
        }
<span class="fc" id="L1684">        store++;</span>
<span class="fc" id="L1685">        int swap = a[0][store];</span>
<span class="fc" id="L1686">        a[0][store] = a[0][idxHi];</span>
<span class="fc" id="L1687">        a[0][idxHi] = swap;</span>
        
<span class="fc" id="L1689">        swap = a[1][store];</span>
<span class="fc" id="L1690">        a[1][store] = a[1][idxHi];</span>
<span class="fc" id="L1691">        a[1][idxHi] = swap;</span>
<span class="fc" id="L1692">        return store;</span>
    }
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecondThird(int[][] a) {
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1702">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1704" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1705">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1707" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1708">            return;</span>
        }
<span class="fc" id="L1710">        sortByDimension1FirstSecondThird(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1711">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecondThird(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1722">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1725">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1728">            return;</span>
        }
<span class="fc bfc" id="L1730" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1731">            int idxMid = partitionByDimension1FirstSecondThird(a, idxLo, idxHi);</span>
<span class="fc" id="L1732">            sortByDimension1FirstSecondThird(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1733">            sortByDimension1FirstSecondThird(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1735">    }</span>
    
    private static int partitionByDimension1FirstSecondThird(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1740">        int x = a[0][idxHi];</span>
<span class="fc" id="L1741">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1743" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1744">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1745" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1746">                doSwap = true;</span>
<span class="fc bfc" id="L1747" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">                if (a[1][i] &lt; a[1][idxHi]) {</span>
<span class="nc" id="L1749">                    doSwap = true;</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">                } else if (a[1][i] == x) {</span>
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">                    if (a[2][i] &lt;= a[2][idxHi]) {</span>
<span class="nc" id="L1752">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1756" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1757">                store++;</span>
<span class="fc bfc" id="L1758" title="All 2 branches covered.">                for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1759">                    int swap = a[k][store];</span>
<span class="fc" id="L1760">                    a[k][store] = a[k][i];</span>
<span class="fc" id="L1761">                    a[k][i] = swap;</span>
                }
            }
        }
<span class="fc" id="L1765">        store++;</span>
<span class="fc bfc" id="L1766" title="All 2 branches covered.">        for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1767">            int swap = a[k][store];</span>
<span class="fc" id="L1768">            a[k][store] = a[k][idxHi];</span>
<span class="fc" id="L1769">            a[k][idxHi] = swap;</span>
        }
<span class="fc" id="L1771">        return store;</span>
    }
   
      
    private static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1779">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1782">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1784" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1785">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1787" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1788">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L1791">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
       
<span class="fc bfc" id="L1794" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1795">            int idxMid = partitionBy1stThen2nd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L1796">            sortBy1stThen2nd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L1797">            sortBy1stThen2nd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1799">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d) {
    
<span class="pc bpc" id="L1804" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1805">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1807" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1809">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
        
<span class="fc" id="L1812">        sortBy1stThen2ndThen3rd(a, b, c, d, 0, a.length - 1);</span>
<span class="fc" id="L1813">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
    
<span class="pc bpc" id="L1818" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1819">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1821" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1823">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1826">            return;</span>
        }
<span class="fc bfc" id="L1828" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1829">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L1830">            sortBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L1831">            sortBy1stThen2ndThen3rd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1833">    }</span>
 
    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L1838">        float x = a[idxHi];</span>
<span class="fc" id="L1839">        float x2 = b[idxHi];</span>
<span class="fc" id="L1840">        float x3 = c[idxHi];</span>
<span class="fc" id="L1841">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1843" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1844">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1845" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L1846">                doSwap = true;</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">                if (b[i] &lt; x2) {</span>
<span class="nc" id="L1849">                    doSwap = true;</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">                } else if (b[i] == x2) {</span>
<span class="pc bpc" id="L1851" title="1 of 2 branches missed.">                    if (c[i] &lt;= x3) {</span>
<span class="nc" id="L1852">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1856" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1857">                store++;</span>
<span class="fc" id="L1858">                float swap = a[store];</span>
<span class="fc" id="L1859">                a[store] = a[i];</span>
<span class="fc" id="L1860">                a[i] = swap;</span>
<span class="fc" id="L1861">                swap = b[store];</span>
<span class="fc" id="L1862">                b[store] = b[i];</span>
<span class="fc" id="L1863">                b[i] = swap;</span>
<span class="fc" id="L1864">                swap = c[store];</span>
<span class="fc" id="L1865">                c[store] = c[i];</span>
<span class="fc" id="L1866">                c[i] = swap;</span>
<span class="fc" id="L1867">                int swap3 = d[store];</span>
<span class="fc" id="L1868">                d[store] = d[i];</span>
<span class="fc" id="L1869">                d[i] = swap3;</span>
            }
        }
<span class="fc" id="L1872">        store++;</span>
<span class="fc" id="L1873">        float swap = a[store];</span>
<span class="fc" id="L1874">        a[store] = a[idxHi];</span>
<span class="fc" id="L1875">        a[idxHi] = swap;</span>
<span class="fc" id="L1876">        swap = b[store];</span>
<span class="fc" id="L1877">        b[store] = b[idxHi];</span>
<span class="fc" id="L1878">        b[idxHi] = swap;</span>
<span class="fc" id="L1879">        swap = c[store];</span>
<span class="fc" id="L1880">        c[store] = c[idxHi];</span>
<span class="fc" id="L1881">        c[idxHi] = swap;</span>
<span class="fc" id="L1882">        int swap3 = d[store];</span>
<span class="fc" id="L1883">        d[store] = d[idxHi];</span>
<span class="fc" id="L1884">        d[idxHi] = swap3;</span>
        
<span class="fc" id="L1886">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(
        TFloatList a, TFloatList b, TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L1892">        float x = a.get(idxHi);</span>
<span class="fc" id="L1893">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1895" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1896">            boolean doSwap = false;</span>
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L1898">                doSwap = true;</span>
<span class="fc bfc" id="L1899" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">                if (b.get(i) &lt;= b.get(idxHi)) {</span>
<span class="fc" id="L1901">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1904" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1905">                store++;</span>
<span class="fc" id="L1906">                float swap = a.get(store);</span>
<span class="fc" id="L1907">                a.set(store, a.get(i));</span>
<span class="fc" id="L1908">                a.set(i, swap);</span>
<span class="fc" id="L1909">                swap = b.get(store);</span>
<span class="fc" id="L1910">                b.set(store, b.get(i));</span>
<span class="fc" id="L1911">                b.set(i, swap);</span>
<span class="fc" id="L1912">                int swap2 = c.get(store);</span>
<span class="fc" id="L1913">                c.set(store, c.get(i));</span>
<span class="fc" id="L1914">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L1917">        store++;</span>
        
<span class="fc" id="L1919">        float swap = a.get(store);</span>
<span class="fc" id="L1920">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L1921">        a.set(idxHi, swap);</span>
        
<span class="fc" id="L1923">        swap = b.get(store);</span>
<span class="fc" id="L1924">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L1925">        b.set(idxHi, swap);</span>
        
<span class="fc" id="L1927">        int swap2 = c.get(store);</span>
<span class="fc" id="L1928">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L1929">        c.set(idxHi, swap2);</span>
        
<span class="fc" id="L1931">        return store;</span>
    }
   
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, float[] c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1947">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1949" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1950">            return;</span>
        }
<span class="pc bpc" id="L1952" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1953">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1956">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1959">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L1962">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc bfc" id="L1964" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1965">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L1966">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L1967">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1969">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c) {
        
<span class="pc bpc" id="L1981" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1982">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1985">            return;</span>
        }
<span class="pc bpc" id="L1987" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1988">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1991">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1993" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1994">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1996" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L1997">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc" id="L1999">        sortBy1stThen2ndThen3rd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2000">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2015" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2016">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2018" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2019">            return;</span>
        }
<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2022">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2024" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2025">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2027" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2028">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2030" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2031">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2034" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2035">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2036">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2037">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2039">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b) {
<span class="nc bnc" id="L2042" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2043">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2045" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2046">            return;</span>
        }
<span class="nc bnc" id="L2048" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2049">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2052">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc" id="L2054">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2055">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b) {
<span class="pc bpc" id="L2058" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2059">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2061" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2062">            return;</span>
        }
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2065">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2067" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2068">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc" id="L2070">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2071">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a) {
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2075">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2077" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2078">            return;</span>
        }
<span class="fc" id="L2080">        sortByYThenX(a, 0, a.length - 1);</span>
<span class="fc" id="L2081">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b) {
        
<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2087">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2090">            return;</span>
        }
<span class="pc bpc" id="L2092" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2093">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc" id="L2096">        sortByDecrYThenIncrX(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2097">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2102" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2103">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2106">            return;</span>
        }
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2109">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2112" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2113">            int idxMid = partitionByDecrYThenIncrX(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2114">            sortByDecrYThenIncrX(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2115">            sortByDecrYThenIncrX(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2117">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2121" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2122">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2124" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2125">            return;</span>
        }
        
<span class="fc bfc" id="L2128" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2129">            int idxMid = partitionByYThenX(a, idxLo, idxHi);</span>
<span class="fc" id="L2130">            sortByYThenX(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L2131">            sortByYThenX(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2133">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2136" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2137">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2140">            return;</span>
        }
<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2143">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2145" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2146">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2148" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2149">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2150">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2151">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2153">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2157">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2159" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2160">            return;</span>
        }
<span class="pc bpc" id="L2162" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2163">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2166">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2168" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2169">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2170">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2171">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2173">    }</span>
    
    public static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c) {
        
<span class="pc bpc" id="L2178" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2179">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2181" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2182">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2184" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L2185">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L2188">        sortBy1stThen2nd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2189">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with ties sorted by b
     * and all swap operations performed on all arrays. The sorts are
     * ascending.
     * @param a
     * @param b
     * @param c
     * @param d
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2nd(double[] a, double[] b, int[] c, int[] d, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2206">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2209">            return;</span>
        }
<span class="pc bpc" id="L2211" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2212">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2215">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L2218">            throw new IllegalArgumentException(&quot;d cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2220" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2221">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2223" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2224">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">        if (a.length != d.length) {</span>
<span class="nc" id="L2227">            throw new IllegalArgumentException(&quot;a and d must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2229" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2230">            int idxMid = partitionBy1stThen2nd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2231">            sortBy1stThen2nd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2232">            sortBy1stThen2nd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2234">    }</span>

    private static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
    
<span class="fc bfc" id="L2238" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2239">            int idxMid = partitionBy1stArg(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2240">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2241">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2243">    }</span>
    
    public static void sort(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc bfc" id="L2248" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2249">            int idxMid = partition(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2250">            sort(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2251">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2253">    }</span>

    private static int partition(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L2258">        float x = a[idxHi];</span>
<span class="fc" id="L2259">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2261" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2263">                store++;</span>
<span class="fc" id="L2264">                float swap = a[store];</span>
<span class="fc" id="L2265">                a[store] = a[i];</span>
<span class="fc" id="L2266">                a[i] = swap;</span>
<span class="fc" id="L2267">                float swap2 = b[store];</span>
<span class="fc" id="L2268">                b[store] = b[i];</span>
<span class="fc" id="L2269">                b[i] = swap2;</span>
<span class="fc" id="L2270">                swap2 = c[store];</span>
<span class="fc" id="L2271">                c[store] = c[i];</span>
<span class="fc" id="L2272">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2275">        store++;</span>
<span class="fc" id="L2276">        float swap = a[store];</span>
<span class="fc" id="L2277">        a[store] = a[idxHi];</span>
<span class="fc" id="L2278">        a[idxHi] = swap;</span>
<span class="fc" id="L2279">        float swap2 = b[store];</span>
<span class="fc" id="L2280">        b[store] = b[idxHi];</span>
<span class="fc" id="L2281">        b[idxHi] = swap2;</span>
<span class="fc" id="L2282">        swap2 = c[store];</span>
<span class="fc" id="L2283">        c[store] = c[idxHi];</span>
<span class="fc" id="L2284">        c[idxHi] = swap2;</span>
<span class="fc" id="L2285">        return store;</span>
    }

    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int idxLo, int idxHi) {
        
<span class="fc" id="L2291">        float x = a[idxHi];</span>
<span class="fc" id="L2292">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2294" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2295">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2296" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2297">                doSwap = true;</span>
<span class="fc bfc" id="L2298" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2300">                    doSwap = true;</span>
<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">                } else if (b[i] == b[idxHi]) {</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">                    if (c[i] &lt;= c[idxHi]) {</span>
<span class="nc" id="L2303">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2307" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2308">                store++;</span>
<span class="fc" id="L2309">                float swap = a[store];</span>
<span class="fc" id="L2310">                a[store] = a[i];</span>
<span class="fc" id="L2311">                a[i] = swap;</span>
<span class="fc" id="L2312">                float swap2 = b[store];</span>
<span class="fc" id="L2313">                b[store] = b[i];</span>
<span class="fc" id="L2314">                b[i] = swap2;</span>
<span class="fc" id="L2315">                swap2 = c[store];</span>
<span class="fc" id="L2316">                c[store] = c[i];</span>
<span class="fc" id="L2317">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2320">        store++;</span>
<span class="fc" id="L2321">        float swap = a[store];</span>
<span class="fc" id="L2322">        a[store] = a[idxHi];</span>
<span class="fc" id="L2323">        a[idxHi] = swap;</span>
<span class="fc" id="L2324">        float swap2 = b[store];</span>
<span class="fc" id="L2325">        b[store] = b[idxHi];</span>
<span class="fc" id="L2326">        b[idxHi] = swap2;</span>
<span class="fc" id="L2327">        swap2 = c[store];</span>
<span class="fc" id="L2328">        c[store] = c[idxHi];</span>
<span class="fc" id="L2329">        c[idxHi] = swap2;</span>
<span class="fc" id="L2330">        return store;</span>
    }
    
    private static &lt;T&gt; int partitionBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="fc" id="L2335">        int x = a[idxHi];</span>
<span class="fc" id="L2336">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2338" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2339">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2340" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2341">                doSwap = true;</span>
            }
<span class="fc bfc" id="L2343" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2344">                store++;</span>
<span class="fc" id="L2345">                int swap = a[store];</span>
<span class="fc" id="L2346">                a[store] = a[i];</span>
<span class="fc" id="L2347">                a[i] = swap;</span>
<span class="fc" id="L2348">                T swap2 = b.get(store);</span>
<span class="fc" id="L2349">                b.set(store, b.get(i));</span>
<span class="fc" id="L2350">                b.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2353">        store++;</span>
<span class="fc" id="L2354">        int swap = a[store];</span>
<span class="fc" id="L2355">        a[store] = a[idxHi];</span>
<span class="fc" id="L2356">        a[idxHi] = swap;</span>
<span class="fc" id="L2357">        T swap2 = b.get(store);</span>
<span class="fc" id="L2358">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2359">        b.set(idxHi, swap2);</span>
        
<span class="fc" id="L2361">        return store;</span>
    }
    
    private static int partitionBy1stThen2ndThen3rd(
        TIntList a, TIntList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2368">        int x = a.get(idxHi);</span>
<span class="fc" id="L2369">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2371" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2372">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2373" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2374">                doSwap = true;</span>
<span class="fc bfc" id="L2375" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2376" title="All 2 branches covered.">                if (b.get(i) &lt; b.get(idxHi)) {</span>
<span class="fc" id="L2377">                    doSwap = true;</span>
<span class="fc bfc" id="L2378" title="All 2 branches covered.">                } else if (b.get(i) == b.get(idxHi)) {</span>
<span class="pc bpc" id="L2379" title="1 of 2 branches missed.">                    if (c.get(i) &lt;= c.get(idxHi)) {</span>
<span class="nc" id="L2380">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2384" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2385">                store++;</span>
<span class="fc" id="L2386">                int swap = a.get(store);</span>
<span class="fc" id="L2387">                a.set(store, a.get(i));</span>
<span class="fc" id="L2388">                a.set(i, swap);</span>
<span class="fc" id="L2389">                int swap2 = b.get(store);</span>
<span class="fc" id="L2390">                b.set(store, b.get(i));</span>
<span class="fc" id="L2391">                b.set(i, swap2);</span>
<span class="fc" id="L2392">                swap2 = c.get(store);</span>
<span class="fc" id="L2393">                c.set(store, c.get(i));</span>
<span class="fc" id="L2394">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2397">        store++;</span>
<span class="fc" id="L2398">        int swap = a.get(store);</span>
<span class="fc" id="L2399">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2400">        a.set(idxHi, swap);</span>
<span class="fc" id="L2401">        int swap2 = b.get(store);</span>
<span class="fc" id="L2402">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2403">        b.set(idxHi, swap2);</span>
<span class="fc" id="L2404">        swap2 = c.get(store);</span>
<span class="fc" id="L2405">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2406">        c.set(idxHi, swap2);</span>
<span class="fc" id="L2407">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(float[] a, float[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2413">        float x = a[idxHi];</span>
<span class="fc" id="L2414">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2416" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2417">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2419">                doSwap = true;</span>
<span class="fc bfc" id="L2420" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2421" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2422">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2425" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2426">                store++;</span>
<span class="fc" id="L2427">                float swap = a[store];</span>
<span class="fc" id="L2428">                a[store] = a[i];</span>
<span class="fc" id="L2429">                a[i] = swap;</span>
<span class="fc" id="L2430">                float swap2 = b[store];</span>
<span class="fc" id="L2431">                b[store] = b[i];</span>
<span class="fc" id="L2432">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2435">        store++;</span>
<span class="fc" id="L2436">        float swap = a[store];</span>
<span class="fc" id="L2437">        a[store] = a[idxHi];</span>
<span class="fc" id="L2438">        a[idxHi] = swap;</span>
<span class="fc" id="L2439">        float swap2 = b[store];</span>
<span class="fc" id="L2440">        b[store] = b[idxHi];</span>
<span class="fc" id="L2441">        b[idxHi] = swap2;</span>
<span class="fc" id="L2442">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(int[] a, int[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2448">        int x = a[idxHi];</span>
<span class="fc" id="L2449">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2451" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2452">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2453" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2454">                doSwap = true;</span>
<span class="fc bfc" id="L2455" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2456" title="1 of 2 branches missed.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="nc" id="L2457">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2460" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2461">                store++;</span>
<span class="fc" id="L2462">                int swap = a[store];</span>
<span class="fc" id="L2463">                a[store] = a[i];</span>
<span class="fc" id="L2464">                a[i] = swap;</span>
<span class="fc" id="L2465">                int swap2 = b[store];</span>
<span class="fc" id="L2466">                b[store] = b[i];</span>
<span class="fc" id="L2467">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2470">        store++;</span>
<span class="fc" id="L2471">        int swap = a[store];</span>
<span class="fc" id="L2472">        a[store] = a[idxHi];</span>
<span class="fc" id="L2473">        a[idxHi] = swap;</span>
<span class="fc" id="L2474">        int swap2 = b[store];</span>
<span class="fc" id="L2475">        b[store] = b[idxHi];</span>
<span class="fc" id="L2476">        b[idxHi] = swap2;</span>
        
<span class="fc" id="L2478">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int partitionByYThenX(T[] a, int idxLo, 
        int idxHi) {
     
<span class="fc" id="L2484">        T x = a[idxHi];</span>
<span class="fc" id="L2485">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2487" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2488">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2489" title="All 2 branches covered.">            if (a[i].getY() &lt; x.getY()) {</span>
<span class="fc" id="L2490">                doSwap = true;</span>
<span class="fc bfc" id="L2491" title="All 2 branches covered.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="fc bfc" id="L2492" title="All 2 branches covered.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="fc" id="L2493">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2496" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2497">                store++;</span>
<span class="fc" id="L2498">                T swap = a[store];</span>
<span class="fc" id="L2499">                a[store] = a[i];</span>
<span class="fc" id="L2500">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L2503">        store++;</span>
<span class="fc" id="L2504">        T swap = a[store];</span>
<span class="fc" id="L2505">        a[store] = a[idxHi];</span>
<span class="fc" id="L2506">        a[idxHi] = swap;</span>
<span class="fc" id="L2507">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int 
    partitionByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
     
<span class="fc" id="L2513">        T x = a[idxHi];</span>
<span class="fc" id="L2514">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2516" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2517">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2518" title="All 2 branches covered.">            if (a[i].getY() &gt; x.getY()) {</span>
<span class="fc" id="L2519">                doSwap = true;</span>
<span class="pc bpc" id="L2520" title="1 of 2 branches missed.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="nc bnc" id="L2521" title="All 2 branches missed.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="nc" id="L2522">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2525" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2526">                store++;</span>
<span class="fc" id="L2527">                T swap = a[store];</span>
<span class="fc" id="L2528">                a[store] = a[i];</span>
<span class="fc" id="L2529">                a[i] = swap;</span>
<span class="fc" id="L2530">                int swap2 = b[store];</span>
<span class="fc" id="L2531">                b[store] = b[i];</span>
<span class="fc" id="L2532">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2535">        store++;</span>
<span class="fc" id="L2536">        T swap = a[store];</span>
<span class="fc" id="L2537">        a[store] = a[idxHi];</span>
<span class="fc" id="L2538">        a[idxHi] = swap;</span>
<span class="fc" id="L2539">        int swap2 = b[store];</span>
<span class="fc" id="L2540">        b[store] = b[idxHi];</span>
<span class="fc" id="L2541">        b[idxHi] = swap2;</span>
<span class="fc" id="L2542">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(double[] a, double[] b, int[] c,
        int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2548">        double x = a[idxHi];</span>
<span class="fc" id="L2549">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2551" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2552">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2553" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2554">                doSwap = true;</span>
<span class="fc bfc" id="L2555" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2556" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2557">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2560" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2561">                store++;</span>
<span class="fc" id="L2562">                double swap = a[store];</span>
<span class="fc" id="L2563">                a[store] = a[i];</span>
<span class="fc" id="L2564">                a[i] = swap;</span>
<span class="fc" id="L2565">                swap = b[store];</span>
<span class="fc" id="L2566">                b[store] = b[i];</span>
<span class="fc" id="L2567">                b[i] = swap;</span>
<span class="fc" id="L2568">                int swap2 = c[store];</span>
<span class="fc" id="L2569">                c[store] = c[i];</span>
<span class="fc" id="L2570">                c[i] = swap2;</span>
<span class="fc" id="L2571">                swap2 = d[store];</span>
<span class="fc" id="L2572">                d[store] = d[i];</span>
<span class="fc" id="L2573">                d[i] = swap2;</span>
            }
        }
<span class="fc" id="L2576">        store++;</span>
<span class="fc" id="L2577">        double swap = a[store];</span>
<span class="fc" id="L2578">        a[store] = a[idxHi];</span>
<span class="fc" id="L2579">        a[idxHi] = swap;</span>
<span class="fc" id="L2580">        swap = b[store];</span>
<span class="fc" id="L2581">        b[store] = b[idxHi];</span>
<span class="fc" id="L2582">        b[idxHi] = swap;</span>
<span class="fc" id="L2583">        int swap2 = c[store];</span>
<span class="fc" id="L2584">        c[store] = c[idxHi];</span>
<span class="fc" id="L2585">        c[idxHi] = swap2;</span>
<span class="fc" id="L2586">        swap2 = d[store];</span>
<span class="fc" id="L2587">        d[store] = d[idxHi];</span>
<span class="fc" id="L2588">        d[idxHi] = swap2;        </span>
<span class="fc" id="L2589">        return store;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
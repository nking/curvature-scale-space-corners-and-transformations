<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuickSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms</a> &gt; <span class="el_source">QuickSort.java</span></div><h1>QuickSort.java</h1><pre class="source lang-java linenums">package algorithms;

import algorithms.sort.MiscSorter;
import algorithms.util.IntIntDouble;
import algorithms.util.PairInt;
import gnu.trove.list.TDoubleList;
import gnu.trove.list.TFloatList;
import gnu.trove.list.TIntList;
import java.util.List;

/**
 *
 * @author nichole
 */
<span class="nc" id="L15">public class QuickSort {</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * @param a
     */
    public static void sort(float[] a) {
<span class="fc" id="L22">        sort(a, 0, a.length - 1);</span>
<span class="fc" id="L23">    }</span>
    
    public static void descendingSort(int[] a, int[] b) {
        
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L28">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L31">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L33" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L34">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L37">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="fc" id="L38">    }</span>
    
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b) {
        
<span class="nc bnc" id="L42" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L43">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L45" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L46">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L49">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L52">        descendingSort(a, b, 0, a.length - 1);</span>
<span class="nc" id="L53">    }</span>
    
    public static void descendingSort(TIntList a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L61">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L64">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L67">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L68">    }</span>
    
    public static void descendingSort(List&lt;? extends Number&gt; a, List&lt;? extends Object&gt; b) {
        
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L73">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L76">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L79">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L82">        descendingSort(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L83">    }</span>
    
    public static void descendingSort(double[] a) {
        
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
        
<span class="fc" id="L91">        descendingSort(a, 0, a.length - 1);</span>
<span class="fc" id="L92">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[][] b) {
        
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L106">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="nc" id="L107">    }</span>
    
    public static void sortBy1stArg(int[] a, int[] b) {
<span class="fc" id="L110">        MiscSorter.sortBy1stArg(a, b);    </span>
<span class="fc" id="L111">    }</span>
    
    public static void sortBy1stArg(TFloatList a, int[] b) {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (b.length != a.size()) {</span>
<span class="nc" id="L115">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="fc" id="L117">        sortBy1stArg(a, b, 0, a.size() - 1);    </span>
<span class="fc" id="L118">    }</span>
    
    public static void sortByA(IntIntDouble[] abc) {
        
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L123">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="fc" id="L126">        sortByA(abc, 0, abc.length - 1);</span>
<span class="fc" id="L127">    }</span>
    
    public static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b) {
    
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L132">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L135">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L138">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L141">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L142">    }</span>

    /**
     * sort a by ascending values and perform the same swap operation on b.
     * @param a
     * @param b 
     */
    public static void sortBy1stArg(float[] a, int[] b) {
        
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L152">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L155">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L158">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L161">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L162">    }</span>
    
    public static void sortBy1stArg(int[] a, Object[] b) {
        
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L167">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L170">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L176">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L177">    }</span>
    
    public static void sortBy1stArg(float[] a, Object[] b) {
        
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L182">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L188">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L191">        sortBy1stArg(a, b, 0, a.length - 1);</span>
<span class="fc" id="L192">    }</span>
    
    public static void sortBy1stArg(TDoubleList a, int[] b) {
        
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L197">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L200">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L206">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L207">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b) {

<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L212">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L215">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L218">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc" id="L221">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="nc" id="L222">    }</span>
    
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b) {

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L233">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L236">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L237">    }</span>
    
    public static void sortBy1stArg(TFloatList a, TIntList b, TIntList c) {

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L242">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L248">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L250" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L251">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L254">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L255">    }</span>
    
    public static void sortBy1stArg(TIntList a, TDoubleList b,
        TIntList c) {
        
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L261">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L264">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L267">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L270">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L273">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="fc" id="L276">        sortBy1stArg(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L277">    }</span>
    
    public static void sortBy1stArg(TIntList a, TIntList b) {
        
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L285">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L288">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="fc" id="L291">        sortBy1stArg(a, b, 0, a.size() - 1);</span>
<span class="fc" id="L292">    }</span>
    
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
<span class="fc" id="L295">        sortBy1stArgDesc(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L296">    }</span>
    
    public static &lt;T, S&gt; void sortBy1stArgDesc(int[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L302">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L305">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L308">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L318">            return;</span>
        }
        
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L323">            int x = a[idxLo];</span>
<span class="fc" id="L324">            int store = idxLo;</span>
<span class="fc" id="L325">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L329">                    store++;     </span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt;= x));</span>
                do {
<span class="fc" id="L332">                    idxMid--;</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                } while (a[idxMid] &lt;= x);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L335">                    break;</span>
                }
<span class="fc" id="L337">                int swap = a[store];</span>
<span class="fc" id="L338">                a[store] = a[idxMid];</span>
<span class="fc" id="L339">                a[idxMid] = swap;</span>
                
<span class="fc" id="L341">                T swap2 = b.get(store);</span>
<span class="fc" id="L342">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L343">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L345">                S swap3 = c.get(store);</span>
<span class="fc" id="L346">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L347">                c.set(idxMid, swap3);</span>
                
<span class="fc" id="L349">            }</span>
            
<span class="fc" id="L351">            int swap = a[idxLo];</span>
<span class="fc" id="L352">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L353">            a[idxMid] = swap;</span>

<span class="fc" id="L355">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L356">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L357">            b.set(idxMid, swap2);</span>

<span class="fc" id="L359">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L360">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L361">            c.set(idxMid, swap3);</span>
         
<span class="fc" id="L363">            sortBy1stArgDesc(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L365">            sortBy1stArgDesc(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L367">    }</span>

    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TDoubleList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L381">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L384">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L387">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L390">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L393">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L397">            return;</span>
        }
        
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L402">            int x = a.get(idxLo);</span>
<span class="fc" id="L403">            int store = idxLo;</span>
<span class="fc" id="L404">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L408">                    store++;     </span>
<span class="fc bfc" id="L409" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L411">                    idxMid--;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L414">                    break;</span>
                }
<span class="nc" id="L416">                int swap = a.get(store);</span>
<span class="nc" id="L417">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L418">                a.set(idxMid, swap);</span>
<span class="nc" id="L419">                swap = c.get(store);</span>
<span class="nc" id="L420">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L421">                c.set(idxMid, swap);</span>
                
<span class="nc" id="L423">                double bSwap = b.get(store);</span>
<span class="nc" id="L424">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L425">                b.set(idxMid, bSwap);</span>
<span class="nc" id="L426">            }</span>
<span class="fc" id="L427">            int swap = a.get(idxLo);</span>
<span class="fc" id="L428">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L429">            a.set(idxMid, swap);</span>
<span class="fc" id="L430">            swap = c.get(idxLo);</span>
<span class="fc" id="L431">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L432">            c.set(idxMid, swap);</span>
            
<span class="fc" id="L434">            double bSwap = b.get(idxLo);</span>
<span class="fc" id="L435">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L436">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L438">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L440">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L442">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b,  
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L456">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L459">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L462">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L465">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L468">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L472">            return;</span>
        }
        
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L477">            float x = a.get(idxLo);</span>
<span class="fc" id="L478">            int store = idxLo;</span>
<span class="fc" id="L479">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L483">                    store++;     </span>
<span class="fc bfc" id="L484" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L486">                    idxMid--;</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L489">                    break;</span>
                }
<span class="nc" id="L491">                float swap = a.get(store);</span>
<span class="nc" id="L492">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L493">                a.set(idxMid, swap);</span>
<span class="nc" id="L494">                int swap2 = c.get(store);</span>
<span class="nc" id="L495">                c.set(store, c.get(idxMid));</span>
<span class="nc" id="L496">                c.set(idxMid, swap2);</span>
                
<span class="nc" id="L498">                swap2 = b.get(store);</span>
<span class="nc" id="L499">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L500">                b.set(idxMid, swap2);</span>
<span class="nc" id="L501">            }</span>
<span class="fc" id="L502">            float swap = a.get(idxLo);</span>
<span class="fc" id="L503">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L504">            a.set(idxMid, swap);</span>
<span class="fc" id="L505">            int swap2 = c.get(idxLo);</span>
<span class="fc" id="L506">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L507">            c.set(idxMid, swap2);</span>
            
<span class="fc" id="L509">            swap2 = b.get(idxLo);</span>
<span class="fc" id="L510">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L511">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L513">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L515">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L517">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L530">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L533">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        if (a.size() != b.length) {</span>
<span class="nc" id="L536">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L540">            return;</span>
        }
        
        float swap;
        int swap2;
<span class="fc bfc" id="L545" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L547">            float x = a.get(idxLo);</span>
<span class="fc" id="L548">            int store = idxLo;</span>
<span class="fc" id="L549">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L553">                    store++;     </span>
<span class="fc bfc" id="L554" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L556">                    idxMid--;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L559">                    break;</span>
                }
<span class="fc" id="L561">                swap = a.get(store);</span>
<span class="fc" id="L562">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L563">                a.set(idxMid, swap);</span>
                
<span class="fc" id="L565">                swap2 = b[store];</span>
<span class="fc" id="L566">                b[store] = b[idxMid];</span>
<span class="fc" id="L567">                b[idxMid] = swap2;</span>
            }
<span class="fc" id="L569">            swap = a.get(idxLo);</span>
<span class="fc" id="L570">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L571">            a.set(idxMid, swap);</span>
            
<span class="fc" id="L573">            swap2 = b[idxLo];</span>
<span class="fc" id="L574">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L575">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L577">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L579">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L581">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TFloatList a, TIntList b, 
        int idxLo, int idxHi) {
        
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L595">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L598">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L601">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L605">            return;</span>
        }
        
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L610">            float x = a.get(idxLo);</span>
<span class="nc" id="L611">            int store = idxLo;</span>
<span class="nc" id="L612">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L616">                    store++;     </span>
<span class="nc bnc" id="L617" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="nc" id="L619">                    idxMid--;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                } while (a.get(idxMid) &gt; x);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L622">                    break;</span>
                }
<span class="nc" id="L624">                float swap = a.get(store);</span>
<span class="nc" id="L625">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L626">                a.set(idxMid, swap);</span>
<span class="nc" id="L627">                int swap2 = b.get(store);</span>
<span class="nc" id="L628">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L629">                b.set(idxMid, swap2);</span>
                
<span class="nc" id="L631">            }</span>
<span class="nc" id="L632">            float swap = a.get(idxLo);</span>
<span class="nc" id="L633">            a.set(idxLo, a.get(idxMid));</span>
<span class="nc" id="L634">            a.set(idxMid, swap);</span>
<span class="nc" id="L635">            int bSwap = b.get(idxLo);</span>
<span class="nc" id="L636">            b.set(idxLo, b.get(idxMid));</span>
<span class="nc" id="L637">            b.set(idxMid, bSwap);</span>
         
<span class="nc" id="L639">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L641">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L643">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T&gt; void sortBy1stArg(TFloatList a, List&lt;T&gt; b, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L657">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L660">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L663">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L667">            return;</span>
        }
        
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L672">            float x = a.get(idxLo);</span>
<span class="fc" id="L673">            int store = idxLo;</span>
<span class="fc" id="L674">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L678">                    store++;     </span>
<span class="fc bfc" id="L679" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L681">                    idxMid--;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L684">                    break;</span>
                }
<span class="fc" id="L686">                float swap = a.get(store);</span>
<span class="fc" id="L687">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L688">                a.set(idxMid, swap);</span>
<span class="fc" id="L689">                T swap2 = b.get(store);</span>
<span class="fc" id="L690">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L691">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L693">            }</span>
<span class="fc" id="L694">            float swap = a.get(idxLo);</span>
<span class="fc" id="L695">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L696">            a.set(idxMid, swap);</span>
<span class="fc" id="L697">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L698">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L699">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L701">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L703">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L705">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TIntList a, TIntList b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L718">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L721">            throw new IllegalArgumentException(&quot;v cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L724">            throw new IllegalArgumentException(&quot;a and v must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L728">            return;</span>
        }
        
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L733">            int x = a.get(idxLo);</span>
<span class="fc" id="L734">            int store = idxLo;</span>
<span class="fc" id="L735">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L739">                    store++;     </span>
<span class="fc bfc" id="L740" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L742">                    idxMid--;</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L745">                    break;</span>
                }
<span class="nc" id="L747">                int swap = a.get(store);</span>
<span class="nc" id="L748">                a.set(store, a.get(idxMid));</span>
<span class="nc" id="L749">                a.set(idxMid, swap);</span>
<span class="nc" id="L750">                swap = b.get(store);</span>
<span class="nc" id="L751">                b.set(store, b.get(idxMid));</span>
<span class="nc" id="L752">                b.set(idxMid, swap);</span>
<span class="nc" id="L753">            }</span>
<span class="fc" id="L754">            int swap = a.get(idxLo);</span>
<span class="fc" id="L755">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L756">            a.set(idxMid, swap);</span>
<span class="fc" id="L757">            swap = b.get(idxLo);</span>
<span class="fc" id="L758">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L759">            b.set(idxMid, swap);</span>
         
<span class="fc" id="L761">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L763">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L765">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortByA(IntIntDouble[] abc, int idxLo, 
        int idxHi) {
        
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        if (abc == null) {</span>
<span class="nc" id="L779">            throw new IllegalArgumentException(&quot;abc cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        if (abc.length &lt; 2) {</span>
<span class="nc" id="L783">            return;</span>
        }
        
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L788">            int x = abc[idxLo].getA();</span>
<span class="fc" id="L789">            int store = idxLo;</span>
<span class="fc" id="L790">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L794">                    store++;     </span>
<span class="fc bfc" id="L795" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (abc[store].getA() &lt; x));</span>
                do {
<span class="fc" id="L797">                    idxMid--;</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">                } while (abc[idxMid].getA() &gt; x);</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L800">                    break;</span>
                }
<span class="nc" id="L802">                IntIntDouble swap = abc[store];</span>
<span class="nc" id="L803">                abc[store] = abc[idxMid];</span>
<span class="nc" id="L804">                abc[idxMid] = swap;</span>
<span class="nc" id="L805">            }</span>
<span class="fc" id="L806">            IntIntDouble swap = abc[idxLo];</span>
<span class="fc" id="L807">            abc[idxLo] = abc[idxMid];</span>
<span class="fc" id="L808">            abc[idxMid] = swap;</span>
         
<span class="fc" id="L810">            sortByA(abc, idxLo, idxMid - 1);</span>

<span class="fc" id="L812">            sortByA(abc, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L814">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L826">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L829">            return;</span>
        }
<span class="fc bfc" id="L831" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L833">            float x = a[idxLo];</span>
<span class="fc" id="L834">            int store = idxLo;</span>
<span class="fc" id="L835">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L839">                    store++;     </span>
<span class="fc bfc" id="L840" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L842">                    idxMid--;</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L845">                    break;</span>
                }
<span class="fc" id="L847">                float swap = a[store];</span>
<span class="fc" id="L848">                a[store] = a[idxMid];</span>
<span class="fc" id="L849">                a[idxMid] = swap;</span>
<span class="fc" id="L850">            }</span>
<span class="fc" id="L851">            float swap = a[idxLo];</span>
<span class="fc" id="L852">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L853">            a[idxMid] = swap;</span>
         
<span class="fc" id="L855">            sort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L857">            sort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L859">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(int[] a, T[] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L873">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L875" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L876">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L879">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc bnc" id="L881" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L882">            return;</span>
        }
        
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L887">            int x = a[idxLo];</span>
<span class="nc" id="L888">            int store = idxLo;</span>
<span class="nc" id="L889">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L893">                    store++;     </span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="nc" id="L896">                    idxMid--;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">                } while (a[idxMid] &lt; x);</span>
                
<span class="nc bnc" id="L899" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L900">                    break;</span>
                }
<span class="nc" id="L902">                int swap = a[store];</span>
<span class="nc" id="L903">                a[store] = a[idxMid];</span>
<span class="nc" id="L904">                a[idxMid] = swap;</span>
<span class="nc" id="L905">                T swap2 = b[store];</span>
<span class="nc" id="L906">                b[store] = b[idxMid];</span>
<span class="nc" id="L907">                b[idxMid] = swap2;</span>
<span class="nc" id="L908">            }</span>
<span class="nc" id="L909">            int swap = a[idxLo];</span>
<span class="nc" id="L910">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L911">            a[idxMid] = swap;</span>
<span class="nc" id="L912">            T swap2 = b[idxLo];</span>
<span class="nc" id="L913">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L914">            b[idxMid] = swap2;</span>
         
<span class="nc" id="L916">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L918">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L920">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(int[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L933">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L936">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L939">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L941" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L942">            return;</span>
        }
        
<span class="fc bfc" id="L945" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L947">            int x = a[idxLo];</span>
<span class="fc" id="L948">            int store = idxLo;</span>
<span class="fc" id="L949">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L953">                    store++;     </span>
<span class="pc bpc" id="L954" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L956">                    idxMid--;</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L959" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L960">                    break;</span>
                }
<span class="fc" id="L962">                int swap = a[store];</span>
<span class="fc" id="L963">                a[store] = a[idxMid];</span>
<span class="fc" id="L964">                a[idxMid] = swap;</span>
<span class="fc" id="L965">                swap = b[store];</span>
<span class="fc" id="L966">                b[store] = b[idxMid];</span>
<span class="fc" id="L967">                b[idxMid] = swap;</span>
<span class="fc" id="L968">            }</span>
<span class="fc" id="L969">            int swap = a[idxLo];</span>
<span class="fc" id="L970">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L971">            a[idxMid] = swap;</span>
<span class="fc" id="L972">            swap = b[idxLo];</span>
<span class="fc" id="L973">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L974">            b[idxMid] = swap;</span>
         
<span class="fc" id="L976">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L978">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L980">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param &lt;T&gt;
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T extends Object&gt; void descendingSort(
        TIntList a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L996">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L999">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1002">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1005">            return;</span>
        }
        
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1010">            int x = a.get(idxLo);</span>
<span class="fc" id="L1011">            int store = idxLo;</span>
<span class="fc" id="L1012">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1016">                    store++;     </span>
<span class="pc bpc" id="L1017" title="1 of 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &gt; x));</span>
                do {
<span class="fc" id="L1019">                    idxMid--;</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                } while (a.get(idxMid) &lt; x);</span>
                
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1023">                    break;</span>
                }
<span class="fc" id="L1025">                int swap = a.get(store);</span>
<span class="fc" id="L1026">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1027">                a.set(idxMid, swap);</span>
<span class="fc" id="L1028">                T swap2 = b.get(store);</span>
<span class="fc" id="L1029">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1030">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1031">            }</span>
<span class="fc" id="L1032">            int swap = a.get(idxLo);</span>
<span class="fc" id="L1033">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1034">            a.set(idxMid, swap);</span>
<span class="fc" id="L1035">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1036">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1037">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1039">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1041">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1043">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;S extends Number, T extends Object&gt; void descendingSort(
        List&lt;S&gt; a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1057">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1060">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1063">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (a.size() &lt; 2) {</span>
<span class="fc" id="L1066">            return;</span>
        }
        
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1071">            float x = a.get(idxLo).floatValue();</span>
<span class="fc" id="L1072">            int store = idxLo;</span>
<span class="fc" id="L1073">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1077">                    store++;     </span>
<span class="fc bfc" id="L1078" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store).floatValue() &gt; x));</span>
                do {
<span class="fc" id="L1080">                    idxMid--;</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">                } while (a.get(idxMid).floatValue() &lt; x);</span>
                
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1084">                    break;</span>
                }
<span class="fc" id="L1086">                S swap = a.get(store);</span>
<span class="fc" id="L1087">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1088">                a.set(idxMid, swap);</span>
<span class="fc" id="L1089">                T swap2 = b.get(store);</span>
<span class="fc" id="L1090">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1091">                b.set(idxMid, swap2);</span>
<span class="fc" id="L1092">            }</span>
<span class="fc" id="L1093">            S swap = a.get(idxLo);</span>
<span class="fc" id="L1094">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1095">            a.set(idxMid, swap);</span>
<span class="fc" id="L1096">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1097">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1098">            b.set(idxMid, swap2);</span>
         
<span class="fc" id="L1100">            descendingSort(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1102">            descendingSort(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1104">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive and by descending values.  
     * The swap operations performed on a are performed on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param idxLo
     * @param idxHi 
     */
    public static void descendingSort(double[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1117">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1120">            return;</span>
        }
        
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1125">            double x = a[idxLo];</span>
<span class="fc" id="L1126">            int store = idxLo;</span>
<span class="fc" id="L1127">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1131">                    store++;     </span>
<span class="fc bfc" id="L1132" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &gt; x));</span>
                do {
<span class="fc" id="L1134">                    idxMid--;</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">                } while (a[idxMid] &lt; x);</span>
                
<span class="fc bfc" id="L1137" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1138">                    break;</span>
                }
<span class="fc" id="L1140">                double swap = a[store];</span>
<span class="fc" id="L1141">                a[store] = a[idxMid];</span>
<span class="fc" id="L1142">                a[idxMid] = swap;</span>
<span class="fc" id="L1143">            }</span>
<span class="fc" id="L1144">            double swap = a[idxLo];</span>
<span class="fc" id="L1145">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1146">            a[idxMid] = swap;</span>
         
<span class="fc" id="L1148">            descendingSort(a, idxLo, idxMid - 1);</span>

<span class="fc" id="L1150">            descendingSort(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1152">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1166">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        if (a.length &lt; 2) {</span>
<span class="fc" id="L1169">            return;</span>
        }
<span class="fc bfc" id="L1171" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1173">            float x = a[idxLo];</span>
<span class="fc" id="L1174">            int store = idxLo;</span>
<span class="fc" id="L1175">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1179">                    store++;     </span>
<span class="fc bfc" id="L1180" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1182">                    idxMid--;</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1185">                    break;</span>
                }
<span class="fc" id="L1187">                float swap = a[store];</span>
<span class="fc" id="L1188">                a[store] = a[idxMid];</span>
<span class="fc" id="L1189">                a[idxMid] = swap;</span>
<span class="fc" id="L1190">                int swap2 = b[store];</span>
<span class="fc" id="L1191">                b[store] = b[idxMid];</span>
<span class="fc" id="L1192">                b[idxMid] = swap2;</span>
<span class="fc" id="L1193">            }</span>
<span class="fc" id="L1194">            float swap = a[idxLo];</span>
<span class="fc" id="L1195">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1196">            a[idxMid] = swap;</span>
<span class="fc" id="L1197">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1198">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1199">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1201">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1203">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1205">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(TDoubleList a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1219">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L1222">            return;</span>
        }
<span class="fc bfc" id="L1224" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1226">            double x = a.get(idxLo);</span>
<span class="fc" id="L1227">            int store = idxLo;</span>
<span class="fc" id="L1228">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1232">                    store++;     </span>
<span class="fc bfc" id="L1233" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a.get(store) &lt; x));</span>
                do {
<span class="fc" id="L1235">                    idxMid--;</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">                } while (a.get(idxMid) &gt; x);</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1238">                    break;</span>
                }
<span class="fc" id="L1240">                double swap = a.get(store);</span>
<span class="fc" id="L1241">                a.set(store, a.get(idxMid));</span>
<span class="fc" id="L1242">                a.set(idxMid, swap);</span>
<span class="fc" id="L1243">                int swap2 = b[store];</span>
<span class="fc" id="L1244">                b[store] = b[idxMid];</span>
<span class="fc" id="L1245">                b[idxMid] = swap2;</span>
<span class="fc" id="L1246">            }</span>
<span class="fc" id="L1247">            double swap = a.get(idxLo);</span>
<span class="fc" id="L1248">            a.set(idxLo, a.get(idxMid));</span>
<span class="fc" id="L1249">            a.set(idxMid, swap);</span>
<span class="fc" id="L1250">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1251">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1252">            b[idxMid] = swap2;</span>
         
<span class="fc" id="L1254">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1256">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1258">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, by ascending values and
     * perform the same operations on b.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, int[] b, int idxLo, int idxHi) {
<span class="nc" id="L1270">        MiscSorter.sortBy1stArg(a, b, idxLo, idxHi); </span>
<span class="nc" id="L1271">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[][] b, int idxLo, int idxHi) {
        
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1284">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1287">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1290">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1294">            return;</span>
        }
        
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        if (idxLo &lt; idxHi) {</span>

<span class="nc" id="L1299">            int x = a[idxLo];</span>
<span class="nc" id="L1300">            int store = idxLo;</span>
<span class="nc" id="L1301">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="nc" id="L1305">                    store++;     </span>
<span class="nc bnc" id="L1306" title="All 4 branches missed.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="nc" id="L1308">                    idxMid--;</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                } while (a[idxMid] &gt; x);</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">                if (store &gt; idxMid) {</span>
<span class="nc" id="L1311">                    break;</span>
                }
<span class="nc" id="L1313">                int swap = a[store];</span>
<span class="nc" id="L1314">                a[store] = a[idxMid];</span>
<span class="nc" id="L1315">                a[idxMid] = swap;</span>
                
<span class="nc" id="L1317">                Object[] bSwap = b[store];</span>
<span class="nc" id="L1318">                b[store] = b[idxMid];</span>
<span class="nc" id="L1319">                b[idxMid] = bSwap;</span>
<span class="nc" id="L1320">            }</span>
<span class="nc" id="L1321">            int swap = a[idxLo];</span>
<span class="nc" id="L1322">            a[idxLo] = a[idxMid];</span>
<span class="nc" id="L1323">            a[idxMid] = swap;</span>
            
<span class="nc" id="L1325">            Object[] bSwap = b[idxLo];</span>
<span class="nc" id="L1326">            b[idxLo] = b[idxMid];</span>
<span class="nc" id="L1327">            b[idxMid] = bSwap;</span>
         
<span class="nc" id="L1329">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="nc" id="L1331">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="nc" id="L1333">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c) {
        
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1344">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1347">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1350">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1353">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L1356">        sortBy1stArg(a, b, c, 0, a.length - 1);</span>
<span class="fc" id="L1357">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T, S&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, List&lt;S&gt; c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1369" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1370">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1373">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1376">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">        if (a.length != c.size()) {</span>
<span class="nc" id="L1379">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1383">            return;</span>
        }
        
<span class="fc bfc" id="L1386" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1388">            float x = a[idxLo];</span>
<span class="fc" id="L1389">            int store = idxLo;</span>
<span class="fc" id="L1390">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1394">                    store++;     </span>
<span class="fc bfc" id="L1395" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1397">                    idxMid--;</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1400">                    break;</span>
                }
<span class="fc" id="L1402">                float swap = a[store];</span>
<span class="fc" id="L1403">                a[store] = a[idxMid];</span>
<span class="fc" id="L1404">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1406">                T swap2 = b.get(store);</span>
<span class="fc" id="L1407">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1408">                b.set(idxMid, swap2);</span>
                
<span class="fc" id="L1410">                S swap3 = c.get(store);</span>
<span class="fc" id="L1411">                c.set(store, c.get(idxMid));</span>
<span class="fc" id="L1412">                c.set(idxMid, swap3);</span>
<span class="fc" id="L1413">            }</span>
<span class="fc" id="L1414">            float swap = a[idxLo];</span>
<span class="fc" id="L1415">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1416">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1418">            T swap2 = b.get(idxLo);</span>
<span class="fc" id="L1419">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1420">            b.set(idxMid, swap2);</span>
               
<span class="fc" id="L1422">            S swap3 = c.get(idxLo);</span>
<span class="fc" id="L1423">            c.set(idxLo, c.get(idxMid));</span>
<span class="fc" id="L1424">            c.set(idxMid, swap3);</span>
            
<span class="fc" id="L1426">            sortBy1stArg(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1428">            sortBy1stArg(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1430">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(int[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1443">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1446">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1449">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1453">            return;</span>
        }
        
<span class="fc bfc" id="L1456" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1458">            int x = a[idxLo];</span>
<span class="fc" id="L1459">            int store = idxLo;</span>
<span class="fc" id="L1460">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1464">                    store++;     </span>
<span class="fc bfc" id="L1465" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1467">                    idxMid--;</span>
<span class="fc bfc" id="L1468" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1470">                    break;</span>
                }
<span class="fc" id="L1472">                int swap = a[store];</span>
<span class="fc" id="L1473">                a[store] = a[idxMid];</span>
<span class="fc" id="L1474">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1476">                Object bSwap = b[store];</span>
<span class="fc" id="L1477">                b[store] = b[idxMid];</span>
<span class="fc" id="L1478">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1479">            }</span>
<span class="fc" id="L1480">            int swap = a[idxLo];</span>
<span class="fc" id="L1481">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1482">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1484">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1485">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1486">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1488">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1490">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1492">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static &lt;T&gt; void sortBy1stArg(float[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1505">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1507" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1508">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">        if (a.length != b.size()) {</span>
<span class="nc" id="L1511">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1515">            return;</span>
        }
        
<span class="fc bfc" id="L1518" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1520">            float x = a[idxLo];</span>
<span class="fc" id="L1521">            int store = idxLo;</span>
<span class="fc" id="L1522">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1526">                    store++;     </span>
<span class="fc bfc" id="L1527" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1529">                    idxMid--;</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1531" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1532">                    break;</span>
                }
<span class="fc" id="L1534">                float swap = a[store];</span>
<span class="fc" id="L1535">                a[store] = a[idxMid];</span>
<span class="fc" id="L1536">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1538">                T bSwap = b.get(store);</span>
<span class="fc" id="L1539">                b.set(store, b.get(idxMid));</span>
<span class="fc" id="L1540">                b.set(idxMid, bSwap);</span>
<span class="fc" id="L1541">            }</span>
<span class="fc" id="L1542">            float swap = a[idxLo];</span>
<span class="fc" id="L1543">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1544">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1546">            T bSwap = b.get(idxLo);</span>
<span class="fc" id="L1547">            b.set(idxLo, b.get(idxMid));</span>
<span class="fc" id="L1548">            b.set(idxMid, bSwap);</span>
         
<span class="fc" id="L1550">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1552">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1554">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.  Uses the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stArg(float[] a, Object[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1567">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1570">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L1573">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
        
<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1577">            return;</span>
        }
        
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1582">            float x = a[idxLo];</span>
<span class="fc" id="L1583">            int store = idxLo;</span>
<span class="fc" id="L1584">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1588">                    store++;     </span>
<span class="fc bfc" id="L1589" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1591">                    idxMid--;</span>
<span class="fc bfc" id="L1592" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1594">                    break;</span>
                }
<span class="fc" id="L1596">                float swap = a[store];</span>
<span class="fc" id="L1597">                a[store] = a[idxMid];</span>
<span class="fc" id="L1598">                a[idxMid] = swap;</span>
                
<span class="fc" id="L1600">                Object bSwap = b[store];</span>
<span class="fc" id="L1601">                b[store] = b[idxMid];</span>
<span class="fc" id="L1602">                b[idxMid] = bSwap;</span>
<span class="fc" id="L1603">            }</span>
<span class="fc" id="L1604">            float swap = a[idxLo];</span>
<span class="fc" id="L1605">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1606">            a[idxMid] = swap;</span>
            
<span class="fc" id="L1608">            Object bSwap = b[idxLo];</span>
<span class="fc" id="L1609">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1610">            b[idxMid] = bSwap;</span>
         
<span class="fc" id="L1612">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>

<span class="fc" id="L1614">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1616">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive.
     * It's an adaption of the optimized
     * qsort3 from the book &quot;Programming in Pearls&quot; by Jon Bentley.
     * @param a
     * @param b an array that will receive the same swap operations as are 
     * performed on a
     * @param c an array that will receive the same swap operations as are 
     * performed on a
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, int[] b, int[] c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1633">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1636">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1638" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1639">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1641" title="2 of 4 branches missed.">        if ((a.length != b.length) || (a.length != c.length)) {</span>
<span class="nc" id="L1642">            throw new IllegalArgumentException(&quot;array lengths must be the same&quot;);</span>
        }
        
<span class="fc bfc" id="L1645" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>

<span class="fc" id="L1647">            float x = a[idxLo];</span>
<span class="fc" id="L1648">            int store = idxLo;</span>
<span class="fc" id="L1649">            int idxMid = idxHi + 1;</span>

            while (true) {
                do {
<span class="fc" id="L1653">                    store++;     </span>
<span class="fc bfc" id="L1654" title="All 4 branches covered.">                } while ((store &lt;= idxHi) &amp;&amp; (a[store] &lt; x));</span>
                do {
<span class="fc" id="L1656">                    idxMid--;</span>
<span class="fc bfc" id="L1657" title="All 2 branches covered.">                } while (a[idxMid] &gt; x);</span>
<span class="fc bfc" id="L1658" title="All 2 branches covered.">                if (store &gt; idxMid) {</span>
<span class="fc" id="L1659">                    break;</span>
                }
<span class="fc" id="L1661">                float swap = a[store];</span>
<span class="fc" id="L1662">                a[store] = a[idxMid];</span>
<span class="fc" id="L1663">                a[idxMid] = swap;</span>
<span class="fc" id="L1664">                int swap2 = b[store];</span>
<span class="fc" id="L1665">                b[store] = b[idxMid];</span>
<span class="fc" id="L1666">                b[idxMid] = swap2;</span>
<span class="fc" id="L1667">                swap2 = c[store];</span>
<span class="fc" id="L1668">                c[store] = c[idxMid];</span>
<span class="fc" id="L1669">                c[idxMid] = swap2;</span>
<span class="fc" id="L1670">            }</span>
<span class="fc" id="L1671">            float swap = a[idxLo];</span>
<span class="fc" id="L1672">            a[idxLo] = a[idxMid];</span>
<span class="fc" id="L1673">            a[idxMid] = swap;</span>
<span class="fc" id="L1674">            int swap2 = b[idxLo];</span>
<span class="fc" id="L1675">            b[idxLo] = b[idxMid];</span>
<span class="fc" id="L1676">            b[idxMid] = swap2;</span>
<span class="fc" id="L1677">            swap2 = c[idxLo];</span>
<span class="fc" id="L1678">            c[idxLo] = c[idxMid];</span>
<span class="fc" id="L1679">            c[idxMid] = swap2;</span>
                     
<span class="fc" id="L1681">            sort(a, b, c, idxLo, idxMid - 1);</span>

<span class="fc" id="L1683">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1685">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecond(int[][] a) {
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1694">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1697">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1700">            return;</span>
        }
<span class="fc" id="L1702">        sortByDimension1FirstSecond(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1703">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecond(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1713" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1714">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1716" title="1 of 2 branches missed.">        if (a.length != 2) {</span>
<span class="nc" id="L1717">            throw new IllegalArgumentException(&quot;a first dimension length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1720">            return;</span>
        }
<span class="fc bfc" id="L1722" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1723">            int idxMid = partitionByDimension1FirstSecond(a, idxLo, idxHi);</span>
<span class="fc" id="L1724">            sortByDimension1FirstSecond(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1725">            sortByDimension1FirstSecond(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1727">    }</span>
    
    private static int partitionByDimension1FirstSecond(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1732">        int x = a[0][idxHi];</span>
<span class="fc" id="L1733">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1736">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1738">                doSwap = true;</span>
<span class="fc bfc" id="L1739" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1740" title="1 of 2 branches missed.">                if (a[1][i] &lt;= a[1][idxHi]) {</span>
<span class="nc" id="L1741">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1744" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1745">                store++;</span>
<span class="fc" id="L1746">                int swap = a[0][store];</span>
<span class="fc" id="L1747">                a[0][store] = a[0][i];</span>
<span class="fc" id="L1748">                a[0][i] = swap;</span>
                
<span class="fc" id="L1750">                swap = a[1][store];</span>
<span class="fc" id="L1751">                a[1][store] = a[1][i];</span>
<span class="fc" id="L1752">                a[1][i] = swap;</span>
            }
        }
<span class="fc" id="L1755">        store++;</span>
<span class="fc" id="L1756">        int swap = a[0][store];</span>
<span class="fc" id="L1757">        a[0][store] = a[0][idxHi];</span>
<span class="fc" id="L1758">        a[0][idxHi] = swap;</span>
        
<span class="fc" id="L1760">        swap = a[1][store];</span>
<span class="fc" id="L1761">        a[1][store] = a[1][idxHi];</span>
<span class="fc" id="L1762">        a[1][idxHi] = swap;</span>
<span class="fc" id="L1763">        return store;</span>
    }
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     */
    public static void sortByDimension1FirstSecondThird(int[][] a) {
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1773">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1776">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1779">            return;</span>
        }
<span class="fc" id="L1781">        sortByDimension1FirstSecondThird(a, 0, a[0].length - 1);</span>
<span class="fc" id="L1782">    }</span>
    
    /**
     * sorts along [0][index] and if there is a tie the value [1][index] is
     * used to decide order.
     * @param a 
     * @param idxLo the first index in [0][index] to sort
     * @param idxHi the last index in [0][index] to sort, inclusive
     */
    public static void sortByDimension1FirstSecondThird(int[][] a, int idxLo, int idxHi) {
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1793">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">        if (a.length != 3) {</span>
<span class="nc" id="L1796">            throw new IllegalArgumentException(&quot;a first dimension length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1798" title="1 of 2 branches missed.">        if (a[0].length &lt; 2) {</span>
<span class="nc" id="L1799">            return;</span>
        }
<span class="fc bfc" id="L1801" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1802">            int idxMid = partitionByDimension1FirstSecondThird(a, idxLo, idxHi);</span>
<span class="fc" id="L1803">            sortByDimension1FirstSecondThird(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L1804">            sortByDimension1FirstSecondThird(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1806">    }</span>
    
    private static int partitionByDimension1FirstSecondThird(int[][] a, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L1811">        int x = a[0][idxHi];</span>
<span class="fc" id="L1812">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1814" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1815">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1816" title="All 2 branches covered.">            if (a[0][i] &lt; x) {</span>
<span class="fc" id="L1817">                doSwap = true;</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">            } else if (a[0][i] == x) {</span>
<span class="pc bpc" id="L1819" title="1 of 2 branches missed.">                if (a[1][i] &lt; a[1][idxHi]) {</span>
<span class="nc" id="L1820">                    doSwap = true;</span>
<span class="pc bpc" id="L1821" title="1 of 2 branches missed.">                } else if (a[1][i] == x) {</span>
<span class="pc bpc" id="L1822" title="1 of 2 branches missed.">                    if (a[2][i] &lt;= a[2][idxHi]) {</span>
<span class="nc" id="L1823">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1827" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1828">                store++;</span>
<span class="fc bfc" id="L1829" title="All 2 branches covered.">                for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1830">                    int swap = a[k][store];</span>
<span class="fc" id="L1831">                    a[k][store] = a[k][i];</span>
<span class="fc" id="L1832">                    a[k][i] = swap;</span>
                }
            }
        }
<span class="fc" id="L1836">        store++;</span>
<span class="fc bfc" id="L1837" title="All 2 branches covered.">        for (int k = 0; k &lt; 3; ++k) {</span>
<span class="fc" id="L1838">            int swap = a[k][store];</span>
<span class="fc" id="L1839">            a[k][store] = a[k][idxHi];</span>
<span class="fc" id="L1840">            a[k][idxHi] = swap;</span>
        }
<span class="fc" id="L1842">        return store;</span>
    }
   
      
    private static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L1849" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1850">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1852" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L1853">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1855" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1856">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L1859">            throw new IllegalArgumentException(&quot;a and b must be the same length&quot;);</span>
        }
<span class="pc bpc" id="L1861" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L1862">            throw new IllegalArgumentException(&quot;a and c must be the same length&quot;);</span>
        }
       
<span class="fc bfc" id="L1865" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1866">            int idxMid = partitionBy1stThen2nd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L1867">            sortBy1stThen2nd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L1868">            sortBy1stThen2nd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1870">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d) {
    
<span class="pc bpc" id="L1875" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1876">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1878" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1880">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
        
<span class="fc" id="L1883">        sortBy1stThen2ndThen3rd(a, b, c, d, 0, a.length - 1);</span>
<span class="fc" id="L1884">    }</span>
    
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
    
<span class="pc bpc" id="L1889" title="4 of 8 branches missed.">        if (a == null || b == null || c == null || d == null) {</span>
<span class="nc" id="L1890">            throw new IllegalArgumentException(&quot;arrays cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1892" title="3 of 6 branches missed.">        if ((a.length != b.length) || (a.length != c.length) ||</span>
            (a.length != d.length)) {
<span class="nc" id="L1894">            throw new IllegalArgumentException(&quot;attay lengths must be same&quot;);</span>
        }
<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L1897">            return;</span>
        }
<span class="fc bfc" id="L1899" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L1900">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L1901">            sortBy1stThen2ndThen3rd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L1902">            sortBy1stThen2ndThen3rd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L1904">    }</span>
 
    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L1909">        float x = a[idxHi];</span>
<span class="fc" id="L1910">        float x2 = b[idxHi];</span>
<span class="fc" id="L1911">        float x3 = c[idxHi];</span>
<span class="fc" id="L1912">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1914" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1915">            boolean doSwap = false;</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L1917">                doSwap = true;</span>
<span class="fc bfc" id="L1918" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L1919" title="1 of 2 branches missed.">                if (b[i] &lt; x2) {</span>
<span class="nc" id="L1920">                    doSwap = true;</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">                } else if (b[i] == x2) {</span>
<span class="pc bpc" id="L1922" title="1 of 2 branches missed.">                    if (c[i] &lt;= x3) {</span>
<span class="nc" id="L1923">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L1927" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1928">                store++;</span>
<span class="fc" id="L1929">                float swap = a[store];</span>
<span class="fc" id="L1930">                a[store] = a[i];</span>
<span class="fc" id="L1931">                a[i] = swap;</span>
<span class="fc" id="L1932">                swap = b[store];</span>
<span class="fc" id="L1933">                b[store] = b[i];</span>
<span class="fc" id="L1934">                b[i] = swap;</span>
<span class="fc" id="L1935">                swap = c[store];</span>
<span class="fc" id="L1936">                c[store] = c[i];</span>
<span class="fc" id="L1937">                c[i] = swap;</span>
<span class="fc" id="L1938">                int swap3 = d[store];</span>
<span class="fc" id="L1939">                d[store] = d[i];</span>
<span class="fc" id="L1940">                d[i] = swap3;</span>
            }
        }
<span class="fc" id="L1943">        store++;</span>
<span class="fc" id="L1944">        float swap = a[store];</span>
<span class="fc" id="L1945">        a[store] = a[idxHi];</span>
<span class="fc" id="L1946">        a[idxHi] = swap;</span>
<span class="fc" id="L1947">        swap = b[store];</span>
<span class="fc" id="L1948">        b[store] = b[idxHi];</span>
<span class="fc" id="L1949">        b[idxHi] = swap;</span>
<span class="fc" id="L1950">        swap = c[store];</span>
<span class="fc" id="L1951">        c[store] = c[idxHi];</span>
<span class="fc" id="L1952">        c[idxHi] = swap;</span>
<span class="fc" id="L1953">        int swap3 = d[store];</span>
<span class="fc" id="L1954">        d[store] = d[idxHi];</span>
<span class="fc" id="L1955">        d[idxHi] = swap3;</span>
        
<span class="fc" id="L1957">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(
        TFloatList a, TFloatList b, TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L1963">        float x = a.get(idxHi);</span>
<span class="fc" id="L1964">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L1966" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L1967">            boolean doSwap = false;</span>
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L1969">                doSwap = true;</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">                if (b.get(i) &lt;= b.get(idxHi)) {</span>
<span class="fc" id="L1972">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L1975" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L1976">                store++;</span>
<span class="fc" id="L1977">                float swap = a.get(store);</span>
<span class="fc" id="L1978">                a.set(store, a.get(i));</span>
<span class="fc" id="L1979">                a.set(i, swap);</span>
<span class="fc" id="L1980">                swap = b.get(store);</span>
<span class="fc" id="L1981">                b.set(store, b.get(i));</span>
<span class="fc" id="L1982">                b.set(i, swap);</span>
<span class="fc" id="L1983">                int swap2 = c.get(store);</span>
<span class="fc" id="L1984">                c.set(store, c.get(i));</span>
<span class="fc" id="L1985">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L1988">        store++;</span>
        
<span class="fc" id="L1990">        float swap = a.get(store);</span>
<span class="fc" id="L1991">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L1992">        a.set(idxHi, swap);</span>
        
<span class="fc" id="L1994">        swap = b.get(store);</span>
<span class="fc" id="L1995">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L1996">        b.set(idxHi, swap);</span>
        
<span class="fc" id="L1998">        int swap2 = c.get(store);</span>
<span class="fc" id="L1999">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2000">        c.set(idxHi, swap2);</span>
        
<span class="fc" id="L2002">        return store;</span>
    }
   
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(float[] a, float[] b, float[] c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2017" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2018">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2021">            return;</span>
        }
<span class="pc bpc" id="L2023" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2024">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2026" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2027">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2029" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2030">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2032" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2033">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2035" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2036">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2037">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2038">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2040">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c) {
        
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2053">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2055" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2056">            return;</span>
        }
<span class="pc bpc" id="L2058" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2059">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2061" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2062">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2065">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2067" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2068">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="fc" id="L2070">        sortBy1stThen2ndThen3rd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2071">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with next sorting by b and c
     * and all swap operations performed on all 3 arrays.  
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2ndThen3rd(
        TIntList a, TIntList b, TIntList c, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2087">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">        if (a.size() &lt; 2) {</span>
<span class="nc" id="L2090">            return;</span>
        }
<span class="pc bpc" id="L2092" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2093">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2096">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">        if (a.size() != b.size()) {</span>
<span class="nc" id="L2099">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">        if (a.size() != c.size()) {</span>
<span class="nc" id="L2102">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2105" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2106">            int idxMid = partitionBy1stThen2ndThen3rd(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2107">            sortBy1stThen2ndThen3rd(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2108">            sortBy1stThen2ndThen3rd(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2110">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b) {
<span class="nc bnc" id="L2113" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2114">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2116" title="All 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2117">            return;</span>
        }
<span class="nc bnc" id="L2119" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2120">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L2122" title="All 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2123">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="nc" id="L2125">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="nc" id="L2126">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b) {
<span class="pc bpc" id="L2129" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2130">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2132" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2133">            return;</span>
        }
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2136">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2138" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2139">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc" id="L2141">        sortBy1stThen2nd(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2142">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a) {
<span class="pc bpc" id="L2145" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2146">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2148" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2149">            return;</span>
        }
<span class="fc" id="L2151">        sortByYThenX(a, 0, a.length - 1);</span>
<span class="fc" id="L2152">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b) {
        
<span class="pc bpc" id="L2157" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2158">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2161">            return;</span>
        }
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2164">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc" id="L2167">        sortByDecrYThenIncrX(a, b, 0, a.length - 1);</span>
<span class="fc" id="L2168">    }</span>
    
    public static &lt;T extends PairInt&gt; void 
    sortByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2173" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2174">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2176" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2177">            return;</span>
        }
<span class="pc bpc" id="L2179" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2180">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
        
<span class="fc bfc" id="L2183" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2184">            int idxMid = partitionByDecrYThenIncrX(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2185">            sortByDecrYThenIncrX(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2186">            sortByDecrYThenIncrX(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2188">    }</span>
    
    public static &lt;T extends PairInt&gt; void sortByYThenX(T[] a, int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2193">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2195" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2196">            return;</span>
        }
        
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2200">            int idxMid = partitionByYThenX(a, idxLo, idxHi);</span>
<span class="fc" id="L2201">            sortByYThenX(a, idxLo, idxMid - 1);</span>
<span class="fc" id="L2202">            sortByYThenX(a, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2204">    }</span>
    
    public static void sortBy1stThen2nd(float[] a, float[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2208">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2211">            return;</span>
        }
<span class="pc bpc" id="L2213" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2214">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2216" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2217">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2219" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2220">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2221">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2222">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2224">    }</span>
    
    public static void sortBy1stThen2nd(int[] a, int[] b, int idxLo, int idxHi) {
<span class="pc bpc" id="L2227" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2228">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2231">            return;</span>
        }
<span class="pc bpc" id="L2233" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2234">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2237">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2239" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2240">            int idxMid = partitionBy1stThen2nd(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2241">            sortBy1stThen2nd(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2242">            sortBy1stThen2nd(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2244">    }</span>
    
    public static void sortBy1stThen2nd(TFloatList a, TFloatList b, 
        TIntList c) {
        
<span class="pc bpc" id="L2249" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2250">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2253">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2255" title="2 of 4 branches missed.">        if (a.size() != b.size() || a.size() != c.size()) {</span>
<span class="nc" id="L2256">            throw new IllegalArgumentException(&quot;a and b and c must be the same length&quot;);</span>
        }
        
<span class="fc" id="L2259">        sortBy1stThen2nd(a, b, c, 0, a.size() - 1);</span>
<span class="fc" id="L2260">    }</span>
    
    /**
     * sort a from index idxLo to idxHi, inclusive, with ties sorted by b
     * and all swap operations performed on all arrays. The sorts are
     * ascending.
     * @param a
     * @param b
     * @param c
     * @param d
     * @param idxLo
     * @param idxHi 
     */
    public static void sortBy1stThen2nd(double[] a, double[] b, int[] c, int[] d, 
        int idxLo, int idxHi) {
        
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L2277">            throw new IllegalArgumentException(&quot;a cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">        if (a.length &lt; 2) {</span>
<span class="nc" id="L2280">            return;</span>
        }
<span class="pc bpc" id="L2282" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L2283">            throw new IllegalArgumentException(&quot;b cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2285" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2286">            throw new IllegalArgumentException(&quot;c cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2288" title="1 of 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L2289">            throw new IllegalArgumentException(&quot;d cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L2291" title="1 of 2 branches missed.">        if (a.length != b.length) {</span>
<span class="nc" id="L2292">            throw new IllegalArgumentException(&quot;a and b must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2294" title="1 of 2 branches missed.">        if (a.length != c.length) {</span>
<span class="nc" id="L2295">            throw new IllegalArgumentException(&quot;a and c must be same length&quot;);</span>
        }
<span class="pc bpc" id="L2297" title="1 of 2 branches missed.">        if (a.length != d.length) {</span>
<span class="nc" id="L2298">            throw new IllegalArgumentException(&quot;a and d must be same length&quot;);</span>
        }
<span class="fc bfc" id="L2300" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2301">            int idxMid = partitionBy1stThen2nd(a, b, c, d, idxLo, idxHi);</span>
<span class="fc" id="L2302">            sortBy1stThen2nd(a, b, c, d, idxLo, idxMid - 1);</span>
<span class="fc" id="L2303">            sortBy1stThen2nd(a, b, c, d, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2305">    }</span>

    private static &lt;T&gt; void sortBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
    
<span class="fc bfc" id="L2309" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2310">            int idxMid = partitionBy1stArg(a, b, idxLo, idxHi);</span>
<span class="fc" id="L2311">            sortBy1stArg(a, b, idxLo, idxMid - 1);</span>
<span class="fc" id="L2312">            sortBy1stArg(a, b, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2314">    }</span>
    
    /**
     * sorts a, b, and c by the values of a only
     * @param a
     * @param b
     * @param c
     * @param idxLo
     * @param idxHi 
     */
    public static void sort(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc bfc" id="L2327" title="All 2 branches covered.">        if (idxLo &lt; idxHi) {</span>
<span class="fc" id="L2328">            int idxMid = partition(a, b, c, idxLo, idxHi);</span>
<span class="fc" id="L2329">            sort(a, b, c, idxLo, idxMid - 1);</span>
<span class="fc" id="L2330">            sort(a, b, c, idxMid + 1, idxHi);</span>
        }
<span class="fc" id="L2332">    }</span>

    private static int partition(float[] a, float[] b, float[] c, int idxLo, 
        int idxHi) {
        
<span class="fc" id="L2337">        float x = a[idxHi];</span>
<span class="fc" id="L2338">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2340" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2342">                store++;</span>
<span class="fc" id="L2343">                float swap = a[store];</span>
<span class="fc" id="L2344">                a[store] = a[i];</span>
<span class="fc" id="L2345">                a[i] = swap;</span>
<span class="fc" id="L2346">                float swap2 = b[store];</span>
<span class="fc" id="L2347">                b[store] = b[i];</span>
<span class="fc" id="L2348">                b[i] = swap2;</span>
<span class="fc" id="L2349">                swap2 = c[store];</span>
<span class="fc" id="L2350">                c[store] = c[i];</span>
<span class="fc" id="L2351">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2354">        store++;</span>
<span class="fc" id="L2355">        float swap = a[store];</span>
<span class="fc" id="L2356">        a[store] = a[idxHi];</span>
<span class="fc" id="L2357">        a[idxHi] = swap;</span>
<span class="fc" id="L2358">        float swap2 = b[store];</span>
<span class="fc" id="L2359">        b[store] = b[idxHi];</span>
<span class="fc" id="L2360">        b[idxHi] = swap2;</span>
<span class="fc" id="L2361">        swap2 = c[store];</span>
<span class="fc" id="L2362">        c[store] = c[idxHi];</span>
<span class="fc" id="L2363">        c[idxHi] = swap2;</span>
<span class="fc" id="L2364">        return store;</span>
    }

    private static int partitionBy1stThen2ndThen3rd(float[] a, float[] b, 
        float[] c, int idxLo, int idxHi) {
        
<span class="fc" id="L2370">        float x = a[idxHi];</span>
<span class="fc" id="L2371">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2373" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2374">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2375" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2376">                doSwap = true;</span>
<span class="fc bfc" id="L2377" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2378" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2379">                    doSwap = true;</span>
<span class="pc bpc" id="L2380" title="1 of 2 branches missed.">                } else if (b[i] == b[idxHi]) {</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">                    if (c[i] &lt;= c[idxHi]) {</span>
<span class="nc" id="L2382">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2386" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2387">                store++;</span>
<span class="fc" id="L2388">                float swap = a[store];</span>
<span class="fc" id="L2389">                a[store] = a[i];</span>
<span class="fc" id="L2390">                a[i] = swap;</span>
<span class="fc" id="L2391">                float swap2 = b[store];</span>
<span class="fc" id="L2392">                b[store] = b[i];</span>
<span class="fc" id="L2393">                b[i] = swap2;</span>
<span class="fc" id="L2394">                swap2 = c[store];</span>
<span class="fc" id="L2395">                c[store] = c[i];</span>
<span class="fc" id="L2396">                c[i] = swap2;</span>
            }
        }
<span class="fc" id="L2399">        store++;</span>
<span class="fc" id="L2400">        float swap = a[store];</span>
<span class="fc" id="L2401">        a[store] = a[idxHi];</span>
<span class="fc" id="L2402">        a[idxHi] = swap;</span>
<span class="fc" id="L2403">        float swap2 = b[store];</span>
<span class="fc" id="L2404">        b[store] = b[idxHi];</span>
<span class="fc" id="L2405">        b[idxHi] = swap2;</span>
<span class="fc" id="L2406">        swap2 = c[store];</span>
<span class="fc" id="L2407">        c[store] = c[idxHi];</span>
<span class="fc" id="L2408">        c[idxHi] = swap2;</span>
<span class="fc" id="L2409">        return store;</span>
    }
    
    private static &lt;T&gt; int partitionBy1stArg(int[] a, List&lt;T&gt; b, int idxLo, int idxHi) {
        
<span class="fc" id="L2414">        int x = a[idxHi];</span>
<span class="fc" id="L2415">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2417" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2418">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2419" title="All 2 branches covered.">            if (a[i] &lt;= x) {</span>
<span class="fc" id="L2420">                doSwap = true;</span>
            }
<span class="fc bfc" id="L2422" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2423">                store++;</span>
<span class="fc" id="L2424">                int swap = a[store];</span>
<span class="fc" id="L2425">                a[store] = a[i];</span>
<span class="fc" id="L2426">                a[i] = swap;</span>
<span class="fc" id="L2427">                T swap2 = b.get(store);</span>
<span class="fc" id="L2428">                b.set(store, b.get(i));</span>
<span class="fc" id="L2429">                b.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2432">        store++;</span>
<span class="fc" id="L2433">        int swap = a[store];</span>
<span class="fc" id="L2434">        a[store] = a[idxHi];</span>
<span class="fc" id="L2435">        a[idxHi] = swap;</span>
<span class="fc" id="L2436">        T swap2 = b.get(store);</span>
<span class="fc" id="L2437">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2438">        b.set(idxHi, swap2);</span>
        
<span class="fc" id="L2440">        return store;</span>
    }
    
    private static int partitionBy1stThen2ndThen3rd(
        TIntList a, TIntList b, 
        TIntList c, int idxLo, int idxHi) {
        
<span class="fc" id="L2447">        int x = a.get(idxHi);</span>
<span class="fc" id="L2448">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2450" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2451">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2452" title="1 of 2 branches missed.">            if (a.get(i) &lt; x) {</span>
<span class="nc" id="L2453">                doSwap = true;</span>
<span class="fc bfc" id="L2454" title="All 2 branches covered.">            } else if (a.get(i) == x) {</span>
<span class="fc bfc" id="L2455" title="All 2 branches covered.">                if (b.get(i) &lt; b.get(idxHi)) {</span>
<span class="fc" id="L2456">                    doSwap = true;</span>
<span class="fc bfc" id="L2457" title="All 2 branches covered.">                } else if (b.get(i) == b.get(idxHi)) {</span>
<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">                    if (c.get(i) &lt;= c.get(idxHi)) {</span>
<span class="nc" id="L2459">                        doSwap = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L2463" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2464">                store++;</span>
<span class="fc" id="L2465">                int swap = a.get(store);</span>
<span class="fc" id="L2466">                a.set(store, a.get(i));</span>
<span class="fc" id="L2467">                a.set(i, swap);</span>
<span class="fc" id="L2468">                int swap2 = b.get(store);</span>
<span class="fc" id="L2469">                b.set(store, b.get(i));</span>
<span class="fc" id="L2470">                b.set(i, swap2);</span>
<span class="fc" id="L2471">                swap2 = c.get(store);</span>
<span class="fc" id="L2472">                c.set(store, c.get(i));</span>
<span class="fc" id="L2473">                c.set(i, swap2);</span>
            }
        }
<span class="fc" id="L2476">        store++;</span>
<span class="fc" id="L2477">        int swap = a.get(store);</span>
<span class="fc" id="L2478">        a.set(store, a.get(idxHi));</span>
<span class="fc" id="L2479">        a.set(idxHi, swap);</span>
<span class="fc" id="L2480">        int swap2 = b.get(store);</span>
<span class="fc" id="L2481">        b.set(store, b.get(idxHi));</span>
<span class="fc" id="L2482">        b.set(idxHi, swap2);</span>
<span class="fc" id="L2483">        swap2 = c.get(store);</span>
<span class="fc" id="L2484">        c.set(store, c.get(idxHi));</span>
<span class="fc" id="L2485">        c.set(idxHi, swap2);</span>
<span class="fc" id="L2486">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(float[] a, float[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2492">        float x = a[idxHi];</span>
<span class="fc" id="L2493">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2495" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2496">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2497" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2498">                doSwap = true;</span>
<span class="fc bfc" id="L2499" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2500" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2501">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2504" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2505">                store++;</span>
<span class="fc" id="L2506">                float swap = a[store];</span>
<span class="fc" id="L2507">                a[store] = a[i];</span>
<span class="fc" id="L2508">                a[i] = swap;</span>
<span class="fc" id="L2509">                float swap2 = b[store];</span>
<span class="fc" id="L2510">                b[store] = b[i];</span>
<span class="fc" id="L2511">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2514">        store++;</span>
<span class="fc" id="L2515">        float swap = a[store];</span>
<span class="fc" id="L2516">        a[store] = a[idxHi];</span>
<span class="fc" id="L2517">        a[idxHi] = swap;</span>
<span class="fc" id="L2518">        float swap2 = b[store];</span>
<span class="fc" id="L2519">        b[store] = b[idxHi];</span>
<span class="fc" id="L2520">        b[idxHi] = swap2;</span>
<span class="fc" id="L2521">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(int[] a, int[] b,
        int idxLo, int idxHi) {
        
<span class="fc" id="L2527">        int x = a[idxHi];</span>
<span class="fc" id="L2528">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2530" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2531">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2532" title="All 2 branches covered.">            if (a[i] &lt; x) {</span>
<span class="fc" id="L2533">                doSwap = true;</span>
<span class="fc bfc" id="L2534" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="pc bpc" id="L2535" title="1 of 2 branches missed.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="nc" id="L2536">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2539" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2540">                store++;</span>
<span class="fc" id="L2541">                int swap = a[store];</span>
<span class="fc" id="L2542">                a[store] = a[i];</span>
<span class="fc" id="L2543">                a[i] = swap;</span>
<span class="fc" id="L2544">                int swap2 = b[store];</span>
<span class="fc" id="L2545">                b[store] = b[i];</span>
<span class="fc" id="L2546">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2549">        store++;</span>
<span class="fc" id="L2550">        int swap = a[store];</span>
<span class="fc" id="L2551">        a[store] = a[idxHi];</span>
<span class="fc" id="L2552">        a[idxHi] = swap;</span>
<span class="fc" id="L2553">        int swap2 = b[store];</span>
<span class="fc" id="L2554">        b[store] = b[idxHi];</span>
<span class="fc" id="L2555">        b[idxHi] = swap2;</span>
        
<span class="fc" id="L2557">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int partitionByYThenX(T[] a, int idxLo, 
        int idxHi) {
     
<span class="fc" id="L2563">        T x = a[idxHi];</span>
<span class="fc" id="L2564">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2566" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2567">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">            if (a[i].getY() &lt; x.getY()) {</span>
<span class="fc" id="L2569">                doSwap = true;</span>
<span class="fc bfc" id="L2570" title="All 2 branches covered.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="fc" id="L2572">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2575" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2576">                store++;</span>
<span class="fc" id="L2577">                T swap = a[store];</span>
<span class="fc" id="L2578">                a[store] = a[i];</span>
<span class="fc" id="L2579">                a[i] = swap;</span>
            }
        }
<span class="fc" id="L2582">        store++;</span>
<span class="fc" id="L2583">        T swap = a[store];</span>
<span class="fc" id="L2584">        a[store] = a[idxHi];</span>
<span class="fc" id="L2585">        a[idxHi] = swap;</span>
<span class="fc" id="L2586">        return store;</span>
    }
    
    private static &lt;T extends PairInt&gt; int 
    partitionByDecrYThenIncrX(T[] a, int[] b, int idxLo, int idxHi) {
     
<span class="fc" id="L2592">        T x = a[idxHi];</span>
<span class="fc" id="L2593">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2595" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2596">            boolean doSwap = false;</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">            if (a[i].getY() &gt; x.getY()) {</span>
<span class="fc" id="L2598">                doSwap = true;</span>
<span class="pc bpc" id="L2599" title="1 of 2 branches missed.">            } else if (a[i].getY() == x.getY()) {</span>
<span class="nc bnc" id="L2600" title="All 2 branches missed.">                if (a[i].getX() &lt; x.getX()) {</span>
<span class="nc" id="L2601">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2604" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2605">                store++;</span>
<span class="fc" id="L2606">                T swap = a[store];</span>
<span class="fc" id="L2607">                a[store] = a[i];</span>
<span class="fc" id="L2608">                a[i] = swap;</span>
<span class="fc" id="L2609">                int swap2 = b[store];</span>
<span class="fc" id="L2610">                b[store] = b[i];</span>
<span class="fc" id="L2611">                b[i] = swap2;</span>
            }
        }
<span class="fc" id="L2614">        store++;</span>
<span class="fc" id="L2615">        T swap = a[store];</span>
<span class="fc" id="L2616">        a[store] = a[idxHi];</span>
<span class="fc" id="L2617">        a[idxHi] = swap;</span>
<span class="fc" id="L2618">        int swap2 = b[store];</span>
<span class="fc" id="L2619">        b[store] = b[idxHi];</span>
<span class="fc" id="L2620">        b[idxHi] = swap2;</span>
<span class="fc" id="L2621">        return store;</span>
    }
    
    private static int partitionBy1stThen2nd(double[] a, double[] b, int[] c,
        int[] d, int idxLo, int idxHi) {
        
<span class="fc" id="L2627">        double x = a[idxHi];</span>
<span class="fc" id="L2628">        int store = idxLo - 1;</span>
        
<span class="fc bfc" id="L2630" title="All 2 branches covered.">        for (int i = idxLo; i &lt; idxHi; i++) {</span>
<span class="fc" id="L2631">            boolean doSwap = false;</span>
<span class="pc bpc" id="L2632" title="1 of 2 branches missed.">            if (a[i] &lt; x) {</span>
<span class="nc" id="L2633">                doSwap = true;</span>
<span class="fc bfc" id="L2634" title="All 2 branches covered.">            } else if (a[i] == x) {</span>
<span class="fc bfc" id="L2635" title="All 2 branches covered.">                if (b[i] &lt; b[idxHi]) {</span>
<span class="fc" id="L2636">                    doSwap = true;</span>
                }
            }
<span class="fc bfc" id="L2639" title="All 2 branches covered.">            if (doSwap) {</span>
<span class="fc" id="L2640">                store++;</span>
<span class="fc" id="L2641">                double swap = a[store];</span>
<span class="fc" id="L2642">                a[store] = a[i];</span>
<span class="fc" id="L2643">                a[i] = swap;</span>
<span class="fc" id="L2644">                swap = b[store];</span>
<span class="fc" id="L2645">                b[store] = b[i];</span>
<span class="fc" id="L2646">                b[i] = swap;</span>
<span class="fc" id="L2647">                int swap2 = c[store];</span>
<span class="fc" id="L2648">                c[store] = c[i];</span>
<span class="fc" id="L2649">                c[i] = swap2;</span>
<span class="fc" id="L2650">                swap2 = d[store];</span>
<span class="fc" id="L2651">                d[store] = d[i];</span>
<span class="fc" id="L2652">                d[i] = swap2;</span>
            }
        }
<span class="fc" id="L2655">        store++;</span>
<span class="fc" id="L2656">        double swap = a[store];</span>
<span class="fc" id="L2657">        a[store] = a[idxHi];</span>
<span class="fc" id="L2658">        a[idxHi] = swap;</span>
<span class="fc" id="L2659">        swap = b[store];</span>
<span class="fc" id="L2660">        b[store] = b[idxHi];</span>
<span class="fc" id="L2661">        b[idxHi] = swap;</span>
<span class="fc" id="L2662">        int swap2 = c[store];</span>
<span class="fc" id="L2663">        c[store] = c[idxHi];</span>
<span class="fc" id="L2664">        c[idxHi] = swap2;</span>
<span class="fc" id="L2665">        swap2 = d[store];</span>
<span class="fc" id="L2666">        d[store] = d[idxHi];</span>
<span class="fc" id="L2667">        d[idxHi] = swap2;        </span>
<span class="fc" id="L2668">        return store;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
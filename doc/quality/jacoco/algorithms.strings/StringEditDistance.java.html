<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringEditDistance.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.strings</a> &gt; <span class="el_source">StringEditDistance.java</span></div><h1>StringEditDistance.java</h1><pre class="source lang-java linenums">package algorithms.strings;

import algorithms.util.PairIntArray;
import gnu.trove.list.TIntList;
import java.util.Arrays;

/**
 * find the number of insert, delete, and substitution operations to change
 * one string into another.

   note, may add a method for normalized edit distance in future:
     &quot;An Efficient Uniform-Cost Normalized Edit Distance Algorithm&quot;
      by Arslan and Egecioglu, 1999
      https://www.researchgate.net/publication/3820090_An_Efficient_Uniform-Cost_Normalized_Edit_Distance_Algorithm
 * 
 * @author nichole
 */
<span class="fc" id="L18">public class StringEditDistance {</span>
   
    /**
     * calculate the number of insert, delete, and substitution operations to change
     * one string into another following Wagner and Fischer 1954 
     * &quot;The String-to-String Correction Problem&quot;.
     * This uses dynamic programming with time O(a.length * b.length)
     * and space O(a.length * b.length).
     * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.367.5281&amp;rep=rep1&amp;type=pdf
     * 
     * Also, see Levenshtein Distance:
     * https://en.wikipedia.org/wiki/Levenshtein_distance
     * 
     * @param a string to edit
     * @param b target string to change a into.
     * 
     * @param outIndexes a and b indexes of the solution in pairs (a_i, b_j)
     * @return 
     */
    public int calculateWithWagnerFischer(String a, String b,
        PairIntArray outIndexes) {
        
<span class="fc" id="L40">        final int cDel = 1;</span>
<span class="fc" id="L41">        final int cIns = 1;</span>

<span class="fc" id="L43">        int cChangeUnequal = 1;</span>
<span class="fc" id="L44">        int m = a.length();</span>
<span class="fc" id="L45">        int n = b.length();</span>
        // (m+1) X (n+1)
<span class="fc" id="L47">        int[][] d = new int[m + 1][];</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        for (int i = 0; i &lt;= m; ++i) {</span>
<span class="fc" id="L49">            d[i] = new int[n + 1];</span>
        }
        
        //Theorem 2
        //D (i, j) is the cost of the least cost trace from A (i) to B (j).
        //D(i, j) = min( 
        //               D(i - 1, j - 1) + cost(A(i) -&gt; B(j)), 
        //               D(i- 1,j) + cost(A(i) deleted),
        //               D(i,j -- 1) + cost(insert a character that is  B(j}) )
        //          for all i, j, where 1 &lt;= i &lt;= [A|, 1 &lt;= j &lt;= [B|

        //Theorem 3
        //D(0, 0) = 0; D(i, 0) = summation_over_r=1_to_i(delete of A(r)); 
        //         and D(O, j) = summation_over_r=1_to_j(insert of a character that is B(r))
        // where 1 &lt;= i &lt;= [A|, 1 &lt;= j &lt;= [B|
        
        //Algorithm X
        //D[0,0] := 0;
        //for i := 1 to |A| do D[i, 0] := D[i - 1, 0] + cost_rm(A(i));
        //for j := 1 to |B| do D[O, j] := D[O,j - 1] + cost_insert(B(j));
        //for i := 1 to |A| do
        //  for j := 1 to |B| do begin
        //    m1 := D[i - 1, j - 1] + cost_change(A(i), B(j));
        //    m2 := D[i - 1, j] + cost_rm(A(i));
        //    m3 := D[i, j - 1] + cost_ins(B(j));
        //    D[i, j] := min(m1, m2, m3);
        //    end;
        
        /*
        NOTE: this algorithm is like the LongestCommonSubsequences except that
        for string edit: cIns=cDel=1 and cEqual=0, and the cost is minimized
        for LCS:         cIns=cDel=0 and cEqual=1, and the cost is maximized
        */
        
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int i = 1; i &lt;= m; ++i) {</span>
<span class="fc" id="L84">            d[i][0] = i; //i*cDel</span>
        }
<span class="fc bfc" id="L86" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; ++i) {</span>
<span class="fc" id="L87">            d[0][i] = i; //i*cIns</span>
        }
        
        int i, j;
<span class="fc" id="L91">        int c = 0;</span>
        
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (j = 1; j &lt;= n; ++j) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            for (i = 1; i &lt;= m; ++i) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                if (a.charAt(i-1) == b.charAt(j-1)) {</span>
<span class="fc" id="L96">                    c = 0;</span>
                } else {
<span class="fc" id="L98">                    c = cChangeUnequal;</span>
                }
<span class="fc" id="L100">                d[i][j] = minimum(d[i-1][j-1] + c, d[i-1][j] + cDel, d[i][j-1] + cIns);</span>
            }
        }
        
        // Algorithm Y: print results
        // i := |A|;j := |B|;
        // while(i != 0 &amp;&amp; j != 0) do
        //    if D[i, j] = D[i - 1, j] + cost_rm(A(i)) then i := i - 1;
        //    else if D[i, j] = D[i,j - 1] + cost_insert(B(j)) then j :=j- 1;
        //    else begin
        //       print((i, j));
        //       i:=i- 1;j:=j-1;
        //       end;
<span class="fc" id="L113">        i = m;</span>
<span class="fc" id="L114">        j = n;</span>
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">        while (i != 0 &amp;&amp; j != 0){</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (d[i][j] == d[i-1][j] + cDel) {</span>
<span class="fc" id="L117">                i--;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            } else if (d[i][j] == d[i][j-1] + cIns) {</span>
<span class="fc" id="L119">                j--;</span>
            } else {
<span class="fc" id="L121">                outIndexes.add(i, j);</span>
<span class="fc" id="L122">                i--;</span>
<span class="fc" id="L123">                j--;</span>
            }
        }
<span class="fc" id="L126">        return d[m][n];</span>
    }
    
    private int minimum(int a, int b, int c) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (a &lt;= b) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (a &lt;= c) {</span>
<span class="fc" id="L132">                return a;</span>
            } else {
<span class="fc" id="L134">                return c;</span>
            }
        } else {
            // b &lt; a
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if (b &lt;= c) {</span>
<span class="fc" id="L139">                return b;</span>
            } else {
<span class="nc" id="L141">                return c;</span>
            }
        } 
    }
   
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
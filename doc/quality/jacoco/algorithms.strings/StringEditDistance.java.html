<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringEditDistance.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.strings</a> &gt; <span class="el_source">StringEditDistance.java</span></div><h1>StringEditDistance.java</h1><pre class="source lang-java linenums">package algorithms.strings;

/**
 * find the number of insert, delete, and substitution operations to change
 * one string into another.

   note, may add a method for normalized edit distance in future:
     &quot;An Efficient Uniform-Cost Normalized Edit Distance Algorithm&quot;
      by Arslan and Egecioglu, 1999
      https://www.researchgate.net/publication/3820090_An_Efficient_Uniform-Cost_Normalized_Edit_Distance_Algorithm
 * 
 * @author nichole
 */
<span class="fc" id="L14">public class StringEditDistance {</span>
 
    /**
     * calculate the number of insert, delete, and substitution operations to change
     * one string into another following Wagner and Fischer 1954 
     * &quot;The String-to-String Correction Problem&quot;.
     * This uses dynamic programming with time O(a.length * b.length)
     * and space O(a.length * b.length).
     * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.367.5281&amp;rep=rep1&amp;type=pdf
     * 
     * Also, see Levenshtein Distance:
     * https://en.wikipedia.org/wiki/Levenshtein_distance
     * 
     * @param a string to edit
     * @param b target string to change a into.
     * @return 
     */
    public int calculateWithWagnerFischer(String a, String b, boolean printToStdOut) {
<span class="fc" id="L32">        int m = a.length();</span>
<span class="fc" id="L33">        int n = b.length();</span>
<span class="fc" id="L34">        int[][] d = new int[m + 1][];</span>
<span class="fc bfc" id="L35" title="All 2 branches covered.">        for (int i = 0; i &lt;= m; ++i) {</span>
<span class="fc" id="L36">            d[i] = new int[n + 1];</span>
        }

        //Algorithm X
        //for i := 1 to |A| do D[i, 0] := D[i - 1, 0] + cost_rm(A(i));
        //for j := 1 to |B| do D[O, j] := D[O,j - 1] + cost_insert(B(j));
        //for i := 1 to |A| do
        //  for j := 1 to |B| do begin
        //    m1 := D[i - 1, j - 1] + cost_change(A(i), B(j));
        //    m2 := D[i - 1, j] + cost_rm(A(i));
        //    m3 := D[i, j - 1] + cost_ins(B(j));
        //    D[i, j] := min(m1, m2, m3);
        //    end;
        
<span class="fc bfc" id="L50" title="All 2 branches covered.">        for (int i = 1; i &lt;= m; ++i) {</span>
<span class="fc" id="L51">            d[i][0] = i;</span>
        }
<span class="fc bfc" id="L53" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; ++i) {</span>
<span class="fc" id="L54">            d[0][i] = i;</span>
        }
        
        int i, j;
<span class="fc" id="L58">        int c = 0;</span>
<span class="fc" id="L59">        int cDel = 1;</span>
<span class="fc" id="L60">        int cIns = 1;</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        for (j = 1; j &lt;= n; ++j) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">            for (i = 1; i &lt;= m; ++i) {</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">                if (a.charAt(i-1) == b.charAt(j-1)) {</span>
<span class="fc" id="L64">                    c = 0;</span>
                } else {
<span class="fc" id="L66">                    c = 1;</span>
                }
<span class="fc" id="L68">                d[i][j] = minimum(d[i-1][j-1] + c, d[i-1][j] + cDel, d[i][j-1] + cIns);</span>
            }
        }
        
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (!printToStdOut) {</span>
<span class="nc" id="L73">            return d[m][n];</span>
        }
        
        // Algorithm Y: print results
        // i := |A|;j := |B|;
        // while(i != 0 &amp;&amp; j != 0) do
        //    if D[i, j] = D[i - 1, j] + cost_rm(A(i)) then i := i - 1;
        //    else if D[i, j] = D[i,j - 1] + cost_insert(B(j)) then j :=j- 1;
        //    else begin
        //       print((i, j));
        //       i:=i- 1;j:=j-1;
        //       end;
<span class="fc" id="L85">        i = m;</span>
<span class="fc" id="L86">        j = n;</span>
<span class="pc bpc" id="L87" title="1 of 4 branches missed.">        while (i != 0 &amp;&amp; j != 0){</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            if (d[i][j] == d[i-1][j] + cDel) {</span>
<span class="fc" id="L89">                i--;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            } else if (d[i][j] == d[i][j-1] + cIns) {</span>
<span class="fc" id="L91">                j--;</span>
            } else {
<span class="fc" id="L93">                System.out.printf(&quot;(%d,%d)\n&quot;, i, j);</span>
<span class="fc" id="L94">                i--;</span>
<span class="fc" id="L95">                j--;</span>
            }
        }
<span class="fc" id="L98">        return d[m][n];</span>
    }
    
    private int minimum(int a, int b, int c) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (a &lt;= b) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            if (a &lt;= c) {</span>
<span class="fc" id="L104">                return a;</span>
            } else {
<span class="fc" id="L106">                return c;</span>
            }
        } else {
            // b &lt; a
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if (b &lt;= c) {</span>
<span class="fc" id="L111">                return b;</span>
            } else {
<span class="nc" id="L113">                return c;</span>
            }
        } 
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
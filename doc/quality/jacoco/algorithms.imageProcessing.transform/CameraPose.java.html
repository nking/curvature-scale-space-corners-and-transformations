<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CameraPose.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">CameraPose.java</span></div><h1>CameraPose.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters;
import algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters;
import algorithms.imageProcessing.transform.Camera.CameraPoseParameters;
import algorithms.matrix.MatrixUtil;
import algorithms.misc.MiscMath0;
import algorithms.util.FormatArray;
import no.uib.cipr.matrix.*;

import java.io.IOException;
import java.util.Arrays;

/**
 given a set of features in 1 image in image coordinates and world coordinate space,
 estimate the intrinsic and extrinsic camera parameters.
 This is also called &quot;geometric camera calibration&quot;.

 TODO: write overloaded methods to use quaternion rotation.
 see
 T. Barfoot, et al., Pose estimation using linearized rotations and quaternion algebra,
 Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
 
 * TODO: consider solving with M-estimators.
 * see http://research.microsoft.com/en- us/um/people/zhang/INRIA/Publis/Tutorial-Estim/node24.html
   or robust MM-estimator, or Least trimmed squares (LTS)
 * 
 * From Tumurbaatar, and Kim 2019, Sensors (Basel). 2019 Apr; 19(8): 1905.
 * &quot;Comparative Study of Relative-Pose Estimations from a Monocular Image 
 * Sequence in Computer Vision and Photogrammetry&quot;
 * We show that homography-based approaches are more accurate than essential-matrix 
 * or relative orientationâ€“based approaches under noisy conditions.
 *
 * @author nichole
 */
<span class="nc" id="L36">public class CameraPose {</span>
    
<span class="fc" id="L38">    public static double eps = 1e-7;</span>
    
    /**
     * given an image and matched image features coordinates with real world coordinates, estimate the
     * camera matrix intrinsic and extrinsic parameters using a pin-hole camera model.
     *
     * This is also known as estimating the Motion.
     * This method uses DLT and should be followed by non-linear optimization
     * to improve the parameter estimates.
     &lt;pre&gt;
      references:
        https://www.ipb.uni-bonn.de/html/teaching/msr2-2020/sse2-13-DLT.pdf
        slides from a lecture titled &quot;Photogrammetry &amp; Robotics Lab,
         Camera Calibration: Direct Linear Transform&quot; by Cyrill Stachniss
     see also http://www.ipb.uni-bonn.de/photogrammetry-i-ii/
     and
       Kitani lecture notes http://www.cs.cmu.edu/~16385/s17/Slides/11.3_Pose_Estimation.pdf
     &lt;/pre&gt;
     &lt;pre&gt;

     Regarding translation, p3 is included in the results.  p3 is the last column in the projection
     matrix calculated internally.  (2) and (4) outlined below are what you should consider using
     to estimate the translation, depending upon your system's use of translate then rotate or vice versa.
         If the user is assuming translate then rotate: X_c = R * (X_wcs - t).
             (1) The projection matrix constructed would be [R | -R*t]
             where the last column is -R*t, R is rotation, t is translation,
             XW is object in real world coordinate frame, X_c is the object location seen in
             the camera reference frame.
             In this case, one would extract the translation
             using t = -1*(R^-1)*p3.  Note that when properly formed, R^-1 = R^T because rotation is orthogonal and unitary.
             (2) For the context of X_im = K * X_c, we have P = [K*R | -K*R*t]
             where K is the intrinsic parameter matrix for the camera.
             In this case, one would extract the translation
             using t = -1 * R^-1 * K^-1 * p3.
         If the user is assuming rotate then translate, X_c = R * X_wcs + t.
             (3) The projection matrix constructed would be [R | t].
             In this case, one would extract the translation
             using t = p3.
             (4) For the context of X_im = K * X_c, we have P = [K*R | K*t].
             In this case, one would extract the translation
             using t = K^-1 * p3.

     This method returns case (2) translation in the CameraExtrinsics field and assumes that x are given
     in image coordinates.

     see also CameraCalibration.solveForHomography(...)
     &lt;/pre&gt;
     * @param x the image coordinates of the features in pixels in format 3 X N where
     * 3 is for x, y, 1 rows, and N columns is the number of features.  At least 6 features are needed.
     * NOTE x and X should both be distortion-free or both should be distorted.
     * @param X the world coordinates of the features in format 3 X N where
     * 3 is for x, y, 1 rows, and N columns is the number of features.  At least 6 features are needed.
     * NOTE x and X should both be distortion-free or both should be distorted.
     * @return 
     */
    public static CameraPoseParameters calculatePoseFromXXW(double[][] x, double[][] X)
        throws NotConvergedException {

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (x.length != 3) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;x.length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (X.length != 3) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;X.length must be 3&quot;);</span>
        }
<span class="fc" id="L102">        int n = x[0].length;</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (n &lt; 6) {</span>
<span class="nc" id="L104">            throw new IllegalArgumentException(&quot;x must have at least 6 correspondences&quot;);</span>
        }
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (X[0].length != n) {</span>
<span class="nc" id="L107">            throw new IllegalArgumentException(&quot;the number of columns in X must be the same as in x&quot;);</span>
        }

        // from x = P * X.
<span class="fc" id="L111">        double[][] p = calculatePFromXXW(x, X);</span>

        //TODO: refine p to minimize the reproduction error ||x - P*X||^2

<span class="fc" id="L115">        return calculatePoseFromP(p);</span>
    }

    /**
     * given the camera projection matrix (i.e. K*[R|t]), estimate the
     * camera matrix intrinsic and extrinsic parameters using a pin-hole camera model.
     *
     * This is also known as estimating the Motion.
     * This method uses DLT and should be followed by non-linear optimization
     * to improve the parameter estimates.
     &lt;pre&gt;
     references:
     https://www.ipb.uni-bonn.de/html/teaching/msr2-2020/sse2-13-DLT.pdf
     slides from a lecture titled &quot;Photogrammetry &amp; Robotics Lab,
     Camera Calibration: Direct Linear Transform&quot; by Cyrill Stachniss
     see also http://www.ipb.uni-bonn.de/photogrammetry-i-ii/
     and
     Kitani lecture notes http://www.cs.cmu.edu/~16385/s17/Slides/11.3_Pose_Estimation.pdf

     Zhang, chap 2 of camera calibration book:
     https://people.cs.rutgers.edu/~elgammal/classes/cs534/lectures/CameraCalibration-book-chapter.pdf
     &lt;/pre&gt;
     &lt;pre&gt;

     Regarding translation, p3 is included in the results.  p3 is the last column in the projection
     matrix calculated internally.  (2) and (4) outlined below are what you should consider using
     to estimate the translation, depending upon your system's use of translate then rotate or vice versa.
     If the user is assuming translate then rotate: X_c = R * (X_wcs - t).
     (1) The projection matrix constructed would be [R | -R*t]
     where the last column is -R*t, R is rotation, t is translation,
     XW is object in real world coordinate frame, X_c is the object location seen in
     the camera reference frame.
     In this case, one would extract the translation
     using t = -1*(R^-1)*p3.  Note that when properly formed, R^-1 = R^T because rotation is orthogonal and unitary.
     (2) For the context of X_im = K * X_c, we have P = [K*R | -K*R*t]
     where K is the intrinsic parameter matrix for the camera.
     In this case, one would extract the translation
     using t = -1 * R^-1 * K^-1 * p3.
     If the user is assuming rotate then translate, X_c = R * X_wcs + t.
     (3) The projection matrix constructed would be [R | t].
     In this case, one would extract the translation
     using t = p3.
     (4) For the context of X_im = K * X_c, we have P = [K*R | K*t].
     In this case, one would extract the translation
     using t = K^-1 * p3.

     This method returns case (2) translation in the CameraExtrinsics field and assumes that x are given
     in image coordinates.

     &lt;/pre&gt;
     * @param p the camera projection matrix, i.e. K*[R|t] where K is the intrinsic camera matrix, R is rotation,
     *          matrix, t is translation vector.
     * @return
     */
    public static CameraPoseParameters calculatePoseFromP(double[][] p)
            throws NotConvergedException {

<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (p.length != 3) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;p.length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (p[0].length != 4) {</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(&quot;p[0].length must be 4&quot;);</span>
        }

        // P = K * [ R | t ] = [K*R | K*t]  = [K*R | -K*R*C] where t=-R*C
        // let M = K*R
        // P = [M | M*C]

<span class="fc" id="L183">        double[] p3 = MatrixUtil.extractColumn(p, 3);</span>

<span class="fc" id="L185">        double[][] M = MatrixUtil.copySubMatrix(p, 0, 2, 0, 2);</span>

<span class="fc" id="L187">        double detM = MatrixUtil.determinant(M);</span>
<span class="fc" id="L188">        detM = Math.round(detM * 1E11)/1E11;</span>
        /*if (detM == 0) {
            System.out.println(&quot;camera center is at infinity&quot;);
        } else {
            System.out.println(&quot;finite projective camera&quot;);
        }*/

        // method from zhang chap2 of camera calibration book
        /* K2 = M*M^T = K*K^T
              = [ ku=(alpha^2 + gamma^2 + u0^2)  kc=(u0*v0 + c+alpha)     u0 ]
                [ kc=(u0*v0 + c+alpha)           kv=(alphav^2 + v0^2)     v0 ]
                [ u0                              v0                      1  ]
           normalize K2 so that K2[2][2]=1

          u0 = k2[0][2]
          v0 = k2[1][2]
          beta = sqrt(kv - v0^2)
          gamma = (kc - u0*v0)/beta
          alpha = sqrt(ku - u0^2 - gamma^2)

          alpha, beta &gt; 0

          then form K from those
          R = K^-1 * M
          t = K^-1 * (last column of P)
         */
<span class="fc" id="L214">        double[][] k2 = MatrixUtil.multiply(M, MatrixUtil.transpose(M));</span>
<span class="fc" id="L215">        MatrixUtil.multiply(k2, 1./k2[2][2]);</span>

<span class="fc" id="L217">        double u0 = k2[0][2];</span>
<span class="fc" id="L218">        double v0 = k2[1][2];</span>
<span class="fc" id="L219">        double beta = Math.sqrt(k2[1][1] - v0*v0);</span>
<span class="fc" id="L220">        double gamma = (k2[0][1] - u0*v0)/beta;</span>
<span class="fc" id="L221">        double alpha = Math.sqrt(k2[0][0] - u0*u0 - gamma*gamma);</span>
<span class="fc" id="L222">        double[][] kEst1 = new double[][]{</span>
                {alpha, gamma, u0}, {0, beta, v0}, {0, 0, 1}
        };
<span class="fc" id="L225">        double[][] kEst1Inv = Camera.createIntrinsicCameraMatrixInverse(kEst1);</span>
<span class="fc" id="L226">        double[][] rEst1 = MatrixUtil.multiply(kEst1Inv, M);</span>
<span class="fc" id="L227">        double[] tEst1 = MatrixUtil.multiplyMatrixByColumnVector(kEst1Inv, p3);</span>

        // scale _t and _r by:
<span class="fc" id="L230">        double lambda1_1 = 1./MatrixUtil.lPSum(MatrixUtil.extractColumn(rEst1, 0), 2);</span>
<span class="fc" id="L231">        double lambda1_2 = 1./MatrixUtil.lPSum(MatrixUtil.extractColumn(rEst1, 1), 2);</span>
<span class="fc" id="L232">        MatrixUtil.multiply(tEst1, lambda1_1);</span>
<span class="fc" id="L233">        MatrixUtil.multiply(rEst1, lambda1_1);</span>

        // because the intrinsic camera matrix K has a positive diagonal, we can rewrite K*R as:
        //  (K * D) * (D^-1 * R)
        // to enforce the positive diagonal, though this should be checked above when constructing kEst1
<span class="fc" id="L238">        double[] d = new double[3];</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            d[i] = (kEst1[i][i] &gt; 0) ? 1 : -1;</span>
        }
<span class="fc" id="L242">        kEst1 = MatrixUtil.multiplyByDiagonal(kEst1, d);</span>
<span class="fc" id="L243">        rEst1 = MatrixUtil.multiplyDiagonalByMatrix(d, rEst1);</span>

        /*
        // ==========================
        //(1) method from kitani lecture
        RQ rqDecomp = RQ.factorize(new DenseMatrix(M));
        double[][] kEst = MatrixUtil.convertToRowMajor(rqDecomp.getR());
        double[][] rEst = MatrixUtil.convertToRowMajor(rqDecomp.getQ());

        // because the intrinsic camera matrix K has a positive diagonal, we can rewrite K*R as:
        //  (K * D) * (D^-1 * R)
        // to enforce the positive diagonal:
        d = new double[3];
        for (int i = 0; i &lt; 3; ++i) {
            d[i] = (kEst[i][i] &gt; 0) ? 1 : -1;
        }
        kEst = MatrixUtil.multiplyByDiagonal(kEst, d);
        rEst = MatrixUtil.multiplyDiagonalByMatrix(d, rEst);
        MatrixUtil.multiply(kEst, 1./kEst[2][2]);

        //(2) estimate the camera position C
        // use assumption P*C=0 to solve for the null space of P, but we lose scale
        MatrixUtil.SVDProducts svdP = MatrixUtil.performSVD(p);
        double[] C = Arrays.copyOf(svdP.vT[svdP.vT.length - 1], 3);
        MatrixUtil.multiply(C, 1./C[2]);

        // t = -R*C
        double[] tEst = MatrixUtil.multiplyMatrixByColumnVector(rEst, C);
        MatrixUtil.multiply(tEst, -1);
        */// ===========================

<span class="fc" id="L274">        CameraExtrinsicParameters extrinsics = new CameraExtrinsicParameters();</span>
<span class="fc" id="L275">        extrinsics.setRotation(rEst1);</span>
<span class="fc" id="L276">        extrinsics.setTranslation(tEst1);</span>

<span class="fc" id="L278">        CameraIntrinsicParameters intrinsics = new CameraIntrinsicParameters();</span>
<span class="fc" id="L279">        intrinsics.setIntrinsic(kEst1);</span>

<span class="fc" id="L281">        CameraPoseParameters camera = new CameraPoseParameters(intrinsics, extrinsics, p3);</span>

<span class="fc" id="L283">        return camera;</span>
    }

    private static double meanOfAbs(double[] a) {
<span class="nc" id="L287">        double sum = 0;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc" id="L289">            sum += Math.abs(a[i]);</span>
        }
<span class="nc" id="L291">        return sum/a.length;</span>
    }

    /**
     * given a single image which has matched image positions x with real world positions X,
     * estimate the camera matrix P using a camera model x = P * X and DLT.
     * @param x
     * @param X
     * @return
     * @throws NotConvergedException
     */
    public static double[][] calculatePFromXXW(double[][] x, double[][] X) throws NotConvergedException {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (x.length != 3) {</span>
<span class="nc" id="L304">            throw new IllegalArgumentException(&quot;x.length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L306" title="3 of 4 branches missed.">        if (X.length != 3 &amp;&amp; X.length != 4) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;X.length must be 3 or 4&quot;);</span>
        }
<span class="fc" id="L309">        int n = x[0].length;</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (n &lt; 6) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(&quot;x must have at least 6 correspondences&quot;);</span>
        }
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (X[0].length != n) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;the number of columns in X must be the same as in x&quot;);</span>
        }

<span class="fc" id="L317">        boolean useNormConditioning = true;</span>

<span class="fc" id="L319">        double[][] tx = null;</span>
<span class="fc" id="L320">        double[][] tX = null;</span>
<span class="fc" id="L321">        double[][] txInv = null;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (useNormConditioning) {</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if (X.length != 4) {</span>
<span class="fc" id="L324">                double[][] tmp = new double[4][X[0].length];</span>
<span class="fc" id="L325">                Arrays.fill(tmp[3], 1);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">                for (int i = 0; i &lt; X.length; ++i) {</span>
<span class="fc" id="L327">                    System.arraycopy(X[i], 0, tmp[i], 0, X[i].length);</span>
                }
<span class="fc" id="L329">                X = tmp;</span>
<span class="fc" id="L330">            } else {</span>
<span class="nc" id="L331">                X = MatrixUtil.copy(X);</span>
            }
<span class="fc" id="L333">            x = MatrixUtil.copy(x);</span>
<span class="fc" id="L334">            tx = EpipolarNormalizationHelper.unitStandardNormalize(x);</span>
<span class="fc" id="L335">            txInv = EpipolarNormalizationHelper.inverseT(tx);</span>
<span class="fc" id="L336">            tX = EpipolarNormalizationHelper.unitStandardNormalize(X);</span>
        }

        int i, j;

        // 2*n X 12
        double xi, yi, Xi, Yi, Zi;
<span class="fc" id="L343">        double[][] ell = new double[2*n][12];</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L345">            xi = x[0][i];</span>
<span class="fc" id="L346">            yi = x[1][i];</span>
<span class="fc" id="L347">            Xi = X[0][i];</span>
<span class="fc" id="L348">            Yi = X[1][i];</span>
<span class="fc" id="L349">            Zi = X[2][i];</span>
<span class="fc" id="L350">            ell[2*i]     = new double[]{Xi, Yi, Zi, 1, 0, 0, 0, 0, -xi*Xi, -xi*Yi, -xi*Zi, -xi};</span>
<span class="fc" id="L351">            ell[2*i + 1] = new double[]{0, 0, 0, 0, Xi, Yi, Zi, 1, -yi*Xi, -yi*Yi, -yi*Zi, -yi};</span>
            //ell[2*i]     = new double[]{Xi, Yi, Zi, 1, 0, 0, 0, 0, xi*Xi, xi*Yi, xi*Zi, xi};
            //ell[2*i + 1] = new double[]{0, 0, 0, 0, Xi, Yi, Zi, 1, yi*Xi, yi*Yi, yi*Zi, yi};
        }

        // SVD(ell).V is 12 X 12.  SVD(ell).U is 2n X 2n
<span class="fc" id="L357">        MatrixUtil.SVDProducts svd = MatrixUtil.performSVD(MatrixUtil.createATransposedTimesA(ell));</span>

        // vT is 12X12.  last row in vT is the eigenvector for the smallest eigenvalue
        // it is also the epipole e1, defined as the right nullspace
<span class="fc" id="L361">        double[] xOrth = svd.vT[svd.vT.length - 1];</span>

        // subject to ||x|| = 1
<span class="fc" id="L364">        xOrth = MatrixUtil.normalizeLP(xOrth, 2);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (xOrth[xOrth.length - 1] &lt; 0) {</span>
<span class="fc" id="L366">            MatrixUtil.multiply(xOrth, -1);</span>
        }

        // assert that ell * xOrth ~ 0
        //double[] chk = MatrixUtil.multiplyMatrixByColumnVector(ell, xOrth);
        //System.out.printf(&quot;check that A*x=0:%s\n&quot;, FormatArray.toString(chk, &quot;%.3e&quot;));

        // reshape into 3 X 4
<span class="fc" id="L374">        double[][] P2 = MatrixUtil.zeros(3,4);</span>
<span class="fc" id="L375">        System.arraycopy(xOrth, 0, P2[0], 0, 4);</span>
<span class="fc" id="L376">        System.arraycopy(xOrth, 4, P2[1], 0, 4);</span>
<span class="fc" id="L377">        System.arraycopy(xOrth, 8, P2[2], 0, 4);</span>

        // enforce det(R) &gt; 0
<span class="fc" id="L380">        double detR = MatrixUtil.determinant(MatrixUtil.copySubMatrix(P2, 0,2, 0, 2));</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        detR = (detR&gt;0) ? 1 : -1;</span>
<span class="fc" id="L382">        MatrixUtil.multiply(P2, detR);</span>

<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (useNormConditioning) {</span>
<span class="fc" id="L385">            P2 = MatrixUtil.multiply(txInv, P2);</span>
<span class="fc" id="L386">            P2 = MatrixUtil.multiply(P2, tX);</span>
        }

<span class="fc" id="L389">        return P2;</span>
    }

    /**
     * calculate the camera extrinsic parameters R and T, given a list of coordinates of objects in the world reference frame
     * corresponding to a list of their coordinates in an image frame and given the camera intrinsic parameters.
     * The method is ported from github repositories holding the Bouguet Matlab Toolbox code.
     &lt;pre&gt;
     The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     and states that the source code is freely available.
     The github repositories with forked Bouguet Matlab code do not have license
     information.  Those references are
     https://github.com/fragofer/TOOLBOX_calib
     and
     https://github.com/hunt0r/Bouguet_cam_cal_toolbox
     and the methods adapted from are
     compute_extrinsic_init.m, normalize_pixel.m, compute_homography.m,
     compute_extrinsic_refine.m,  project_points2.m, rigid_motion.m
     &lt;/pre&gt;
     * @param intrinsics
     * @param x objects in image coordinate reference frame.  size [3Xn].  if given [2Xn], will stack a row of 1's onto it
     *          internally.
     * @param X objects in world coordinate reference frame.  size [3Xn]
     * @param useBouguetForRodrigues if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors
     * @return
     * @throws NotConvergedException
     * @throws IOException
     */
    public static CameraExtrinsicParameters calculatePoseUsingBouguet(
            Camera.CameraIntrinsicParameters intrinsics, double[][] x,
            double[][] X, boolean refine, boolean useBouguetForRodrigues) throws NotConvergedException, IOException {

<span class="pc bpc" id="L421" title="2 of 4 branches missed.">        if (x.length != 2 &amp;&amp; x.length != 3) {</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;x.length must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (X.length != 3) {</span>
<span class="nc" id="L425">            throw new IllegalArgumentException(&quot;X.length must be 3&quot;);</span>
        }
<span class="fc" id="L427">        int n = x[0].length;</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (n &lt; 4) {</span>
<span class="nc" id="L429">            throw new IllegalArgumentException(&quot;x must have at least 4 correspondences&quot;);</span>
        }
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (X[0].length != n) {</span>
<span class="nc" id="L432">            throw new IllegalArgumentException(&quot;the number of columns in X must be the same as in x&quot;);</span>
        }

        int i, j;

<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        if (x.length == 3) {</span>
<span class="fc" id="L438">            x = MatrixUtil.copy(x);</span>
        } else {
<span class="nc" id="L440">            double[][] x2 = MatrixUtil.zeros(3, n);</span>
<span class="nc" id="L441">            System.arraycopy(x[0], 0, x2[0], 0, n);</span>
<span class="nc" id="L442">            System.arraycopy(x[1], 0, x2[1], 0, n);</span>
<span class="nc" id="L443">            Arrays.fill(x2[2], 1);</span>
<span class="nc" id="L444">            x = x2;</span>
        }
<span class="fc" id="L446">        X = MatrixUtil.copy(X);</span>

        //xn = normalize_pixel(x_kk,fc,cc,kc,alpha_c);
<span class="fc" id="L449">        double[][] xc = Camera.pixelToCameraCoordinates(x, intrinsics);</span>

        // x = x_kk
        // X = X_kk
        //X_mean = mean(X_kk')';  [3 X 1]
<span class="fc" id="L454">        double[] XMean = new double[X.length];</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        for (i = 0; i &lt; X.length; ++i) {</span>
<span class="fc" id="L456">            XMean[i] = MiscMath0.getAvgAndStDev(X[i])[0];</span>
        }

        //Y = X_kk - (X_mean*ones(1,Np));  [3Xn]
<span class="fc" id="L460">        double[][] Y = new double[X.length][];</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (i = 0; i &lt; X.length; ++i) {</span>
<span class="fc" id="L462">            Y[i] = MatrixUtil.subtract(X[i], XMean[i]);</span>
        }

        //YY = Y*Y';  [3 X n][n X 3] = [3X3]
<span class="fc" id="L466">        double[][] YY = MatrixUtil.multiply(Y, MatrixUtil.transpose(Y));</span>

        //[U,S,V] = svd(YY); [3X3] for U and V
<span class="fc" id="L469">        SVD svd = SVD.factorize(new DenseMatrix(YY));</span>

        //r = S(3,3)/S(2,2);
<span class="fc" id="L472">        double r = svd.getS()[2]/svd.getS()[1];</span>

        CameraExtrinsicParameters soln;

<span class="pc bpc" id="L476" title="2 of 4 branches missed.">        if ((r &lt; 1e-3)|| (n &lt; 5)) { // test of planarity</span>
            // planar structure
            //Transform the plane to bring it in the Z=0 plane:
<span class="nc" id="L479">            soln = bouguetPoseInitPlanar(intrinsics, xc, X, svd.getVt(), XMean, useBouguetForRodrigues);</span>
        } else {
            //%fprintf(1,'Non planar structure detected: r=%f\n',r);
<span class="fc" id="L482">            soln = bouguetPoseInitNonPlanar(xc, X, useBouguetForRodrigues);</span>
        }

<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (refine) {</span>
            // could return more intermediate arrays such as JJ
            //this needs image coordinates because internally it is projecting X to camera then image and comparing that to x
<span class="fc" id="L488">            soln = bouguetPoseRefine(soln, intrinsics, x, X, useBouguetForRodrigues);</span>
        }

        //computation of the homography (not useful in the end)
        if (true) {
            //H = [Rckk(:,1:2)Tckk];  // [3X2][3X1]
<span class="fc" id="L494">            double[][] H = new double[3][];</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L496">                H[i] = new double[]{soln.getRotation()[i][0], soln.getRotation()[i][1], soln.getTranslation()[i]};</span>
            }
            //% Computes the reprojection error in pixels:
            //x = project_points2(X_kk, omckk, Tckk, fc, cc, kc, alpha_c);
<span class="fc" id="L500">            ProjectedPoints pp = bouguetProjectPoints2(X, soln.getRodriguesVector(), soln.getTranslation(),</span>
                    intrinsics, useBouguetForRodrigues);

            //ex = x_kk - x;
<span class="fc" id="L504">            double[][] ex = MatrixUtil.pointwiseSubtract(x, pp.getXEstAs3XN());</span>

<span class="fc" id="L506">            double[][] err = MatrixUtil.copySubMatrix(ex, 0, 1, 0, ex[0].length - 1);</span>
<span class="fc" id="L507">            double[] xMeanStdv = MiscMath0.getAvgAndStDev(err[0]);</span>
<span class="fc" id="L508">            double[] yMeanStdv = MiscMath0.getAvgAndStDev(err[1]);</span>
<span class="fc" id="L509">            System.out.printf(&quot;x err=%s\n&quot;, FormatArray.toString(xMeanStdv, &quot;%.4e&quot;));</span>
<span class="fc" id="L510">            System.out.printf(&quot;y err=%s\n&quot;, FormatArray.toString(yMeanStdv, &quot;%.4e&quot;));</span>

            //% Converts the homography in pixel units:
            //KK = [fc(1) alpha_c * fc(1) cc(1);
            //0 fc(2) cc(2);
            //0 0 1];
            //H = KK * H;
<span class="fc" id="L517">            H = MatrixUtil.multiply(intrinsics.getIntrinsic(), H);</span>
<span class="fc" id="L518">            System.out.printf(&quot;H from [R_3X2 | t]=\n%s\n&quot;, FormatArray.toString(H, &quot;%.3e&quot;));</span>
        }

        //can return [omckk,Tckk,Rckk,H,x,ex,JJ] if return JJ from refine
<span class="fc" id="L522">        return soln;</span>
    }

    public static class ProjectedPoints {

        /**
         * [2 X n] projected points xEst = R*X+T, where R = rodrigues(om), X is world coordinates of object, and T is translation
         */
        public double[][] xEst;

        /**
         * [2*n X 3] derivatives of XP w.r.t. rotation vector om
         */
        public double[][] dxdom;

        /**
         * [2*n X 3] derivatives of XP w.r.t. translation vector
         */
        public double[][] dxdT;

        public double[][] getXEstAs3XN() {
            double[][] x2 = new double[3][];
            x2[0] = Arrays.copyOf(xEst[0], xEst[0].length);
            x2[1] = Arrays.copyOf(xEst[1], xEst[1].length);
            x2[2] = new double[xEst[0].length];
            Arrays.fill(x2[2], 1);
            return x2;
        }

        /**
         * [2*n X 2] derivatives of XP w.r.t. camera focal length
         */
        public double[][] dxdF;

        /**
         * [2*n X 2] derivatives of XP w.r.t. camera principal point.
         * Not all methods produce output for this.
         */
        public double[][] dxdC = null;

        /**
         * [2*n X 4] derivatives of XP w.r.t. camera distortion coefficients
         */
        public double[][] dxdK;

        /**
         * [2*n X 1] derivatives of XP w.r.t. camera skew coefficient between x and y pixel
         * (alpha = 0 &lt;=&gt; square pixels results in derivative of 0 also).
         * Not all methods produce output for this.
         */
        public double[] dxdAlpha = null;

        /**
         * [2*n X 3] derivatives of XP w.r.t. the real world point.
         * Not all methods produce output for this.
         */
        public double[][] dxdX = null;
    }

    /**
     * Projects a 3D structure onto the image plane.
     * Bouguet toolbox code project_points2.m
     *
     * @param X 3D structure in the world coordinate frame (3xN matrix for N points)
     * @param om rotation vector (3x1 vector) between world coordinate frame and camera reference frame.
     * @param t translation vector (3x1 vector) between world coordinate frame and camera reference frame.
     * @param intrinsics camera intrinsic parameters
*    @param useBouguetForRodrigues if true, uses only the Bouguet algorithms for Rodrigues rotation matrices and vectors
     * @return [xp, dxpdom, dxpdT] where xp are the Projected pixel coordinates (2xN matrix for N points)
     * dxpdom are the Derivatives of xp with respect to om ((2N)x3 matrix), and
     * dxpdT are the derivatives of xp with respect to T ((2N)x3 matrix).
     */
    @SuppressWarnings({&quot;fallthrough&quot;})
    public static ProjectedPoints bouguetProjectPoints2(double[][] X, double[] om, double[] t,
         CameraIntrinsicParameters intrinsics, boolean useBouguetForRodrigues) {

        //[m,n] = size(X);
<span class="fc" id="L599">        int m = X.length;</span>
<span class="fc" id="L600">        int n = X[0].length;</span>

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (m != 3) {</span>
<span class="nc" id="L603">            throw new IllegalArgumentException(&quot;X.length should be 3&quot;);</span>
        }
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if (om.length != 3) {</span>
<span class="nc" id="L606">            throw new IllegalArgumentException(&quot;om.length should be 3&quot;);</span>
        }
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (t.length != 3) {</span>
<span class="nc" id="L609">            throw new IllegalArgumentException(&quot;t.length should be 3&quot;);</span>
        }

        /*
        %Definitions:
            %Let P be a point in 3D of coordinates X in the world reference frame (stored in the matrix X)
            %The coordinate vector of P in the camera reference frame is:
                Xc = R*X + T
                    %where R is the rotation matrix corresponding to the rotation vector om:
                    R = rodrigues(om);
            %call x, y and z the 3 coordinates of Xc: x = Xc(1); y = Xc(2); z = Xc(3);
            %The pinehole projection coordinates of
                P is [a;b] where a=x/z and b=y/z.
            %call r^2 = a^2 + b^2.
            %The distorted point coordinates are:
                xd = [xx;yy] where:
            %
            %xx = a * (1 + kc(1)*r^2 + kc(2)*r^4 + kc(5)*r^6)      +      2*kc(3)*a*b + kc(4)*(r^2 + 2*a^2);
            %yy = b * (1 + kc(1)*r^2 + kc(2)*r^4 + kc(5)*r^6)      +      kc(3)*(r^2 + 2*b^2) + 2*kc(4)*a*b;
            %
            %The left terms correspond to radial distortion (6th degree), the right terms correspond to tangential distortion
            %
            %Finally, conversion into pixel coordinates: The final pixel coordinates vector xp=[xxp;yyp] where:
            %
            %xxp = f(1)*(xx + alpha*yy) + c(1)
            %yyp = f(2)*yy + c(2)
            %
            %
            %NOTE: About 90 percent of the code takes care of computing the Jacobian matrices
            %
            %
            %Important function called within that program:
            %
            %rodrigues.m: Computes the rotation matrix corresponding to a rotation vector
            %
            %rigid_motion.m: Computes the rigid motion transformation of a given structure
         */

        //[Y,dYdom,dYdT] = rigid_motion(X,om,T);
<span class="fc" id="L648">        ProjectedPoints pRM = bouguetRigidMotion(X, om, t, useBouguetForRodrigues); // in camera reference frame</span>
<span class="fc" id="L649">        double[][] Y = pRM.xEst; // [3 X n]</span>
<span class="fc" id="L650">        double[][] dYdom = pRM.dxdom; // [3*n X 3]</span>
<span class="fc" id="L651">        double[][] dYdT = pRM.dxdT;   // [3*n X 3]</span>

        //inv_Z = 1./Y(3,:);  [1Xn]
<span class="fc" id="L654">        double[] invZ = new double[n];</span>
        int i, j;
<span class="fc bfc" id="L656" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L657">            invZ[i] = 1./Y[2][i];</span>
        }

        //x = (Y(1:2,:) .* (ones(2,1) * inv_Z)) ;
<span class="fc" id="L661">        double[][] x = new double[2][];</span>
<span class="fc" id="L662">        x[0] = MatrixUtil.pointwiseMultiplication(Y[0], invZ);</span>
<span class="fc" id="L663">        x[1] = MatrixUtil.pointwiseMultiplication(Y[1], invZ);</span>

        //     ([1Xn] dot [1Xn])^T. [nX1] * [1X3] = [nX3]
        //bb = (-x(1,:) .* inv_Z)'*ones(1,3);
        //cc = (-x(2,:) .* inv_Z)'*ones(1,3);
<span class="fc" id="L668">        double[] tmp1 = new double[n];</span>
<span class="fc" id="L669">        double[] tmp2 = new double[n];</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L671">            tmp1[i] = -x[0][i] * invZ[i];</span>
<span class="fc" id="L672">            tmp2[i] = -x[1][i] * invZ[i];</span>
        }
        // [n X 3]
<span class="fc" id="L675">        double[][] bb = MatrixUtil.outerProduct(tmp1, new double[]{1, 1, 1});</span>
<span class="fc" id="L676">        double[][] cc = MatrixUtil.outerProduct(tmp2, new double[]{1, 1, 1});</span>

        //dxdom = zeros(2*n,3);
        //                       [nX1][1X3]       . [3*n-&gt;n  X 3]       [nX3] . [[3*n-&gt;n  X 3]
        //dxdom(1:2:end,:) = ((inv_Z')*ones(1,3)) .* dYdom(1:3:end,:) + bb .* dYdom(3:3:end,:);
        //dxdom(2:2:end,:) = ((inv_Z')*ones(1,3)) .* dYdom(2:3:end,:) + cc .* dYdom(3:3:end,:);

        // [nX3]
<span class="fc" id="L684">        double[][] d0 = MatrixUtil.outerProduct(invZ, new double[]{1, 1, 1});  //((inv_Z')*ones(1,3))</span>
<span class="fc" id="L685">        double[][] d1 = new double[n][]; // dYdom(1:3:end,:)</span>
<span class="fc" id="L686">        double[][] d2 = new double[n][]; // dYdom(2:3:end,:)</span>
<span class="fc" id="L687">        double[][] d3 = new double[n][]; // dYdom(3:3:end,:)</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L689">            d1[i] = Arrays.copyOf(dYdom[i*3], 3);</span>
<span class="fc" id="L690">            d2[i] = Arrays.copyOf(dYdom[i*3 + 1], 3);</span>
<span class="fc" id="L691">            d3[i] = Arrays.copyOf(dYdom[i*3 + 2], 3);</span>
        }
        // [nX3]
<span class="fc" id="L694">        double[][] dd1a = MatrixUtil.pointwiseMultiplication(d0, d1);//((inv_Z')*ones(1,3)) .* dYdom(1:3:end,:)</span>
<span class="fc" id="L695">        double[][] dd1b = MatrixUtil.pointwiseMultiplication(bb, d3);//bb .* dYdom(3:3:end,:);</span>
<span class="fc" id="L696">        double[][] dd1 = MatrixUtil.pointwiseAdd(dd1a, dd1b);</span>

<span class="fc" id="L698">        double[][] dd2a = MatrixUtil.pointwiseMultiplication(d0, d2);//((inv_Z')*ones(1,3)) .* dYdom(2:3:end,:)</span>
<span class="fc" id="L699">        double[][] dd2b = MatrixUtil.pointwiseMultiplication(cc, d3);//cc .* dYdom(3:3:end,:);</span>
<span class="fc" id="L700">        double[][] dd2 = MatrixUtil.pointwiseAdd(dd2a, dd2b);</span>

        // [2*n X 3]
<span class="fc" id="L703">        double[][] dxdom = new double[2*n][];</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L705">            dxdom[2*i] = Arrays.copyOf(dd1[i], dd1[i].length);</span>
<span class="fc" id="L706">            dxdom[2*i + 1] = Arrays.copyOf(dd2[i], dd2[i].length);</span>
        }

        // dYdT is [3*n X 3]
        //dxdT = zeros(2*n,3);
        //dxdT(1:2:end,:) = ((inv_Z')*ones(1,3)) .* dYdT(1:3:end,:) + bb .* dYdT(3:3:end,:);
        //dxdT(2:2:end,:) = ((inv_Z')*ones(1,3)) .* dYdT(2:3:end,:) + cc .* dYdT(3:3:end,:);
<span class="fc" id="L713">        d1 = new double[n][]; // dYdT(1:3:end,:)</span>
<span class="fc" id="L714">        d2 = new double[n][]; // dYdT(2:3:end,:)</span>
<span class="fc" id="L715">        d3 = new double[n][]; // dYdT(3:3:end,:)</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L717">            d1[i] = Arrays.copyOf(dYdT[i*3], 3);</span>
<span class="fc" id="L718">            d2[i] = Arrays.copyOf(dYdT[i*3 + 1], 3);</span>
<span class="fc" id="L719">            d3[i] = Arrays.copyOf(dYdT[i*3 + 2], 3);</span>
        }
        // [nX3]
<span class="fc" id="L722">        dd1a = MatrixUtil.pointwiseMultiplication(d0, d1);//((inv_Z')*ones(1,3)) .* dYdT(1:3:end,:)</span>
<span class="fc" id="L723">        dd1b = MatrixUtil.pointwiseMultiplication(bb, d3);//bb .* dYdT(3:3:end,:)</span>
<span class="fc" id="L724">        dd1 = MatrixUtil.pointwiseAdd(dd1a, dd1b);</span>

<span class="fc" id="L726">        dd2a = MatrixUtil.pointwiseMultiplication(d0, d2);//((inv_Z')*ones(1,3)) .* dYdT(2:3:end,:)</span>
<span class="fc" id="L727">        dd2b = MatrixUtil.pointwiseMultiplication(cc, d3);//cc .* dYdT(3:3:end,:)</span>
<span class="fc" id="L728">        dd2 = MatrixUtil.pointwiseAdd(dd2a, dd2b);</span>

        //[2*n X 3]
<span class="fc" id="L731">        double[][] dxdT = new double[2*n][];</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L733">            dxdT[2*i] = Arrays.copyOf(dd1[i], dd1[i].length);</span>
<span class="fc" id="L734">            dxdT[2*i + 1] = Arrays.copyOf(dd2[i], dd2[i].length);</span>
        }

<span class="fc" id="L737">        double[] k = intrinsics.getRadialDistortionCoeffs();</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (k == null) {</span>
<span class="fc" id="L739">            k = new double[]{0, 0};</span>
        }

        //% Add distortion:
        //r2 = x(1,:).^2 + x(2,:).^2;
<span class="fc" id="L744">        double[] r2 = new double[n];</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">        for (i = 0;i &lt; n; ++i) {</span>
<span class="fc" id="L746">            r2[i] = x[0][i]*x[0][i] + x[1][i]*x[1][i];</span>
        }

        //dxdom is [2*n X 3]
        //        [nX3]
        //dr2dom = 2*((x(1,:)')*ones(1,3)) .* dxdom(1:2:end,:) + 2*((x(2,:)')*ones(1,3)) .* dxdom(2:2:end,:);
<span class="fc" id="L752">        double[][] d01 = MatrixUtil.outerProduct(x[0], new double[]{1, 1, 1});//2*((x(1,:)')*ones(1,3))</span>
<span class="fc" id="L753">        double[][] d02 = MatrixUtil.outerProduct(x[1], new double[]{1, 1, 1});//2*((x(2,:)')*ones(1,3))</span>
<span class="fc" id="L754">        MatrixUtil.multiply(d01, 2);</span>
<span class="fc" id="L755">        MatrixUtil.multiply(d02, 2);</span>
<span class="fc" id="L756">        d1 = new double[n][]; // dxdom(1:2:end,:)   [nX3]</span>
<span class="fc" id="L757">        d2 = new double[n][]; // dxdom(2:2:end,:)   [nX3]</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L759">            d1[i] = Arrays.copyOf(dxdom[i*2], 3);</span>
<span class="fc" id="L760">            d2[i] = Arrays.copyOf(dxdom[i*2 + 1], 3);</span>
        }
        // [nX3]
<span class="fc" id="L763">        dd1a = MatrixUtil.pointwiseMultiplication(d01, d1);//2*((x(1,:)')*ones(1,3)) .* dxdom(1:2:end,:)</span>
<span class="fc" id="L764">        dd1b = MatrixUtil.pointwiseMultiplication(d02, d2);//2*((x(2,:)')*ones(1,3)) .* dxdom(2:2:end,:)</span>
<span class="fc" id="L765">        double[][] dr2dom = MatrixUtil.pointwiseAdd(dd1a, dd1b);</span>

        // dxdT is [2*n X 3]
        //dr2dT = 2*((x(1,:)')*ones(1,3)) .* dxdT(1:2:end,:) + 2*((x(2,:)')*ones(1,3)) .* dxdT(2:2:end,:);
<span class="fc bfc" id="L769" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L770">            d1[i] = Arrays.copyOf(dxdT[i*2], 3);</span>
<span class="fc" id="L771">            d2[i] = Arrays.copyOf(dxdT[i*2 + 1], 3);</span>
        }
<span class="fc" id="L773">        dd1a = MatrixUtil.pointwiseMultiplication(d01, d1);//2*((x(1,:)')*ones(1,3)) .* dxdom(1:2:end,:)</span>
<span class="fc" id="L774">        dd1b = MatrixUtil.pointwiseMultiplication(d02, d2);//2*((x(2,:)')*ones(1,3)) .* dxdom(2:2:end,:)</span>
<span class="fc" id="L775">        double[][] dr2dT = MatrixUtil.pointwiseAdd(dd1a, dd1b);</span>

        //r4 = r2.^2;
<span class="fc" id="L778">        double[] r4 = new double[r2.length];</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (i = 0;i &lt; r2.length; ++i) {</span>
<span class="fc" id="L780">            r4[i] = r2[i]*r2[i];</span>
        }

        // [nX1][1X3]  . [nX3]
        //dr4dom = 2*((r2')*ones(1,3)) .* dr2dom;
        //dr4dT = 2*((r2')*ones(1,3)) .* dr2dT;
<span class="fc" id="L786">        d0 = MatrixUtil.outerProduct(r2, new double[]{1, 1, 1});</span>
<span class="fc" id="L787">        MatrixUtil.multiply(d0, 2);</span>
<span class="fc" id="L788">        double[][] dr4dom = MatrixUtil.pointwiseAdd(d0, dr2dom);</span>
<span class="fc" id="L789">        double[][] dr4dT = MatrixUtil.pointwiseAdd(d0, dr2dT);</span>

        //r6 = r2.^3;
<span class="fc" id="L792">        double[] r6 = new double[r2.length];</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">        for (i = 0;i &lt; r2.length; ++i) {</span>
<span class="fc" id="L794">            r4[i] = r2[i]*r4[i];</span>
        }

        //dr6dom = 3*((r2'.^2)*ones(1,3)) .* dr2dom;
        //dr6dT = 3*((r2'.^2)*ones(1,3)) .* dr2dT;
<span class="fc" id="L799">        d0 = MatrixUtil.outerProduct(r4, new double[]{1, 1, 1});</span>
<span class="fc" id="L800">        MatrixUtil.multiply(d0, 3);</span>
<span class="fc" id="L801">        double[][] dr6dom = MatrixUtil.pointwiseAdd(d0, dr2dom);</span>
<span class="fc" id="L802">        double[][] dr6dT = MatrixUtil.pointwiseAdd(d0, dr2dT);</span>

         //% Radial distortion:
        //cdist = 1   + k(1) * r2   + k(2) * r4   + k(5) * r6;
        //dcdistdom = k(1) * dr2dom + k(2) * dr4dom + k(5) * dr6dom; // [nX3]
        //dcdistdT  = k(1) * dr2dT  + k(2) * dr4dT  + k(5) * dr6dT;  // [nX3]
<span class="fc" id="L808">        double[] cdist = new double[n];</span>
<span class="fc" id="L809">        Arrays.fill(cdist, 1);</span>
<span class="fc" id="L810">        double[][] dcdistdom = null;</span>
<span class="fc" id="L811">        double[][] dcdistdT = null;</span>

<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if (k != null) {</span>
<span class="fc" id="L814">            dcdistdom = MatrixUtil.zeros(n, 3);</span>
<span class="fc" id="L815">            dcdistdT = MatrixUtil.zeros(n, 3);</span>
            double[] tmp;
            double[][] tmp3;
<span class="pc bpc" id="L818" title="3 of 4 branches missed.">            switch(k.length) {</span>
                case 5 : {
<span class="nc" id="L820">                    tmp = Arrays.copyOf(r6, r6.length);</span>
<span class="nc" id="L821">                    MatrixUtil.multiply(tmp, k[4]);</span>
<span class="nc" id="L822">                    cdist = MatrixUtil.add(cdist, tmp);</span>

<span class="nc" id="L824">                    tmp3 = MatrixUtil.copy(dr6dom);</span>
<span class="nc" id="L825">                    MatrixUtil.multiply(tmp3, k[4]);</span>
<span class="nc" id="L826">                    dcdistdom = MatrixUtil.pointwiseAdd(dcdistdom, tmp3);</span>

<span class="nc" id="L828">                    tmp3 = MatrixUtil.copy(dr6dT);</span>
<span class="nc" id="L829">                    MatrixUtil.multiply(tmp3, k[4]);</span>
<span class="nc" id="L830">                    dcdistdT = MatrixUtil.pointwiseAdd(dcdistdT, tmp3);</span>
                    // fall through
                }
                case 2 : {
<span class="fc" id="L834">                    tmp = Arrays.copyOf(r4, r4.length);</span>
<span class="fc" id="L835">                    MatrixUtil.multiply(tmp, k[1]);</span>
<span class="fc" id="L836">                    cdist = MatrixUtil.add(cdist, tmp);</span>

<span class="fc" id="L838">                    tmp3 = MatrixUtil.copy(dr4dom);</span>
<span class="fc" id="L839">                    MatrixUtil.multiply(tmp3, k[1]);</span>
<span class="fc" id="L840">                    dcdistdom = MatrixUtil.pointwiseAdd(dcdistdom, tmp3);</span>

<span class="fc" id="L842">                    tmp3 = MatrixUtil.copy(dr4dT);</span>
<span class="fc" id="L843">                    MatrixUtil.multiply(tmp3, k[1]);</span>
<span class="fc" id="L844">                    dcdistdT = MatrixUtil.pointwiseAdd(dcdistdT, tmp3);</span>
                    // fall through
                }
                case 1 : {
<span class="fc" id="L848">                    tmp = Arrays.copyOf(r2, r2.length);</span>
<span class="fc" id="L849">                    MatrixUtil.multiply(tmp, k[0]);</span>
<span class="fc" id="L850">                    cdist = MatrixUtil.add(cdist, tmp);</span>

<span class="fc" id="L852">                    tmp3 = MatrixUtil.copy(dr2dom);</span>
<span class="fc" id="L853">                    MatrixUtil.multiply(tmp3, k[0]);</span>
<span class="fc" id="L854">                    dcdistdom = MatrixUtil.pointwiseAdd(dcdistdom, tmp3);</span>

<span class="fc" id="L856">                    tmp3 = MatrixUtil.copy(dr2dT);</span>
<span class="fc" id="L857">                    MatrixUtil.multiply(tmp3, k[0]);</span>
<span class="fc" id="L858">                    dcdistdT = MatrixUtil.pointwiseAdd(dcdistdT, tmp3);</span>
<span class="fc" id="L859">                    break;</span>
                }
                default :
<span class="nc" id="L862">                    throw new IllegalStateException(&quot;k.length not handled for &quot; + k.length);</span>
            }
        }

        //[n X 5]
        //dcdistdk = [ r2' r4' zeros(n,2) r6'];
<span class="fc" id="L868">        double[][] dcdistdk = new double[5][];</span>
<span class="fc" id="L869">        dcdistdk[0] = Arrays.copyOf(r2, r2.length);</span>
<span class="fc" id="L870">        dcdistdk[1] = Arrays.copyOf(r4, r4.length);</span>
<span class="fc" id="L871">        dcdistdk[2] = new double[n];</span>
<span class="fc" id="L872">        dcdistdk[3] = new double[n];</span>
<span class="fc" id="L873">        dcdistdk[4] = Arrays.copyOf(r6, r6.length);</span>
<span class="fc" id="L874">        dcdistdk = MatrixUtil.transpose(dcdistdk);</span>

        // [2Xn] . [ [2x1]*[1Xn] ]
        //xd1 = x .* (ones(2,1)*cdist);
<span class="fc" id="L878">        double[][] tmp3 = MatrixUtil.outerProduct(new double[]{1, 1}, cdist);</span>
<span class="fc" id="L879">        double[][] xd1 = MatrixUtil.pointwiseMultiplication(x, tmp3);</span>

        //dxd1dom = zeros(2*n,3);
        //dxd1dom(1:2:end,:) = (x(1,:)'*ones(1,3)) .* dcdistdom; // [nX1][1X3] . [nX3]
        //dxd1dom(2:2:end,:) = (x(2,:)'*ones(1,3)) .* dcdistdom;
<span class="fc" id="L884">        d01 = MatrixUtil.outerProduct(x[0], new double[]{1, 1, 1});//(x(1,:)'*ones(1,3)) // [nX1][1X3]=nX3</span>
<span class="fc" id="L885">        d02 = MatrixUtil.outerProduct(x[1], new double[]{1, 1, 1});//(x(2,:)'*ones(1,3))</span>
<span class="fc" id="L886">        d1 = MatrixUtil.pointwiseMultiplication(d01, dcdistdom); // [nX3]</span>
<span class="fc" id="L887">        d2 = MatrixUtil.pointwiseMultiplication(d01, dcdistdom);</span>
<span class="fc" id="L888">        double[][] dxd1dom = new double[2*n][]; // [2nX3]</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L890">            dxd1dom[2*i] = Arrays.copyOf(d1[i], d1[i].length);</span>
<span class="fc" id="L891">            dxd1dom[2*i + 1] = Arrays.copyOf(d2[i], d2[i].length);</span>
        }
        //coeff = (reshape([cdist;cdist],2*n,1)*ones(1,3)); // cdist is [1Xn]
        //dxd1dom = dxd1dom + coeff.* dxdom;
<span class="fc" id="L895">        tmp1 = new double[2*n];</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L897">            tmp1[i] = cdist[i];</span>
<span class="fc" id="L898">            tmp1[i + n] = cdist[i];</span>
        }
        //[2*n X 3]
<span class="fc" id="L901">        double[][] coeff = MatrixUtil.outerProduct(tmp1, new double[]{1, 1, 1});</span>
<span class="fc" id="L902">        tmp3 = MatrixUtil.pointwiseMultiplication(coeff, dxdom);</span>
<span class="fc" id="L903">        dxd1dom = MatrixUtil.pointwiseAdd(dxd1dom, tmp3);</span>

        //dxd1dT = zeros(2*n,3);
        //dxd1dT(1:2:end,:) = (x(1,:)'*ones(1,3)) .* dcdistdT; // [nX3] .* [nX3]
        //dxd1dT(2:2:end,:) = (x(2,:)'*ones(1,3)) .* dcdistdT;
        //dxd1dT = dxd1dT + coeff.* dxdT;
<span class="fc" id="L909">        d1 = MatrixUtil.pointwiseMultiplication(d01, dcdistdT); // [nX3]</span>
<span class="fc" id="L910">        d2 = MatrixUtil.pointwiseMultiplication(d02, dcdistdT);</span>
<span class="fc" id="L911">        double[][] dxd1dT = MatrixUtil.zeros(2*n, 3); // [2nX3]</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L913">            dxd1dT[2*i] = d1[i];</span>
<span class="fc" id="L914">            dxd1dT[2*i + 1] = d2[i];</span>
        }
<span class="fc" id="L916">        tmp3 = MatrixUtil.pointwiseMultiplication(coeff, dxdT);</span>
<span class="fc" id="L917">        dxd1dT = MatrixUtil.pointwiseAdd(dxd1dT, tmp3);</span>

        //dxd1dk = zeros(2*n,5);
        //dxd1dk(1:2:end,:) = (x(1,:)'*ones(1,5)) .* dcdistdk;
        //dxd1dk(2:2:end,:) = (x(2,:)'*ones(1,5)) .* dcdistdk;
<span class="fc" id="L922">        d01 = MatrixUtil.outerProduct(x[0], new double[]{1, 1, 1, 1, 1});</span>
<span class="fc" id="L923">        d02 = MatrixUtil.outerProduct(x[1], new double[]{1, 1, 1, 1, 1});</span>
<span class="fc" id="L924">        d1 = MatrixUtil.pointwiseMultiplication(d01, dcdistdk); // [nX5] [nX5]</span>
<span class="fc" id="L925">        d2 = MatrixUtil.pointwiseMultiplication(d02, dcdistdk);</span>
<span class="fc" id="L926">        double[][] dxd1dk = new double[2*n][]; // [2nX3]</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L928">            dxd1dk[2*i] = Arrays.copyOf(d1[i], d1[i].length);</span>
<span class="fc" id="L929">            dxd1dk[2*i + 1] = Arrays.copyOf(d2[i], d2[i].length);</span>
        }

        // excluding tangential distortion.  lines 161 - 191

<span class="fc" id="L934">        double[] deltaX = new double[2];</span>

        //xd2 = xd1 + delta_x;
        //[2Xn]
<span class="fc" id="L938">        double[][] xd2 = MatrixUtil.copy(xd1);</span>
<span class="fc" id="L939">        double[][] dxd2dom = MatrixUtil.copy(dxd1dom);// + ddelta_xdom ;</span>
<span class="fc" id="L940">        double[][] dxd2dT = MatrixUtil.copy(dxd1dT);//+ ddelta_xdT;</span>
<span class="fc" id="L941">        double[][] dxd2dk = MatrixUtil.copy(dxd1dk);// + ddelta_xdk ;</span>

        //% Add Skew:
<span class="fc" id="L944">        double alpha = intrinsics.getIntrinsic()[0][1];</span>

        //xd3 = [xd2(1,:) + alpha*xd2(2,:);xd2(2,:)];
<span class="fc" id="L947">        tmp1 = Arrays.copyOf(xd2[1], xd2[1].length);</span>
<span class="fc" id="L948">        MatrixUtil.multiply(tmp1, alpha);</span>
<span class="fc" id="L949">        double[][] xd3 = new double[2][]; // [2Xn]</span>
<span class="fc" id="L950">        xd3[0] = MatrixUtil.add(xd2[0], tmp1);</span>
<span class="fc" id="L951">        xd3[1] = Arrays.copyOf(xd2[1], xd2[1].length);</span>

        //% Compute: dxd3dom, dxd3dT, dxd3dk, dxd3dalpha
        //dxd3dom = zeros(2*n,3);
        //dxd3dom(1:2:2*n,:) = dxd2dom(1:2:2*n,:) + alpha*dxd2dom(2:2:2*n,:);
        //dxd3dom(2:2:2*n,:) = dxd2dom(2:2:2*n,:);
        // dxd2dom is [2*n X 3]
<span class="fc" id="L958">        double[][] dxd3dom = new double[2*n][];</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L960">            tmp1 = Arrays.copyOf(dxd2dom[2*i + 1], dxd2dom[2*i + 1].length);</span>
<span class="fc" id="L961">            MatrixUtil.multiply(tmp1, alpha);</span>
<span class="fc" id="L962">            dxd3dom[2*i] = MatrixUtil.add(dxd2dom[2*i + 0], tmp1);</span>
<span class="fc" id="L963">            dxd3dom[2*i + 1] = Arrays.copyOf(dxd2dom[2*i + 1], dxd2dom[2*i + 1].length);</span>
        }

        //dxd3dT = zeros(2*n,3);
        //dxd3dT(1:2:2*n,:) = dxd2dT(1:2:2*n,:) + alpha*dxd2dT(2:2:2*n,:);
        //dxd3dT(2:2:2*n,:) = dxd2dT(2:2:2*n,:);
<span class="fc" id="L969">        double[][] dxd3dT = new double[2*n][];</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L971">            tmp1 = Arrays.copyOf(dxd2dT[2*i + 1], dxd2dT[2*i + 1].length);</span>
<span class="fc" id="L972">            MatrixUtil.multiply(tmp1, alpha);</span>
<span class="fc" id="L973">            dxd3dT[2*i] = MatrixUtil.add(dxd2dT[2*i + 0], tmp1);</span>
<span class="fc" id="L974">            dxd3dT[2*i + 1] = Arrays.copyOf(dxd2dT[2*i + 1], dxd2dT[2*i + 1].length);</span>
        }

        //dxd3dk = zeros(2*n,5);
        //dxd3dk(1:2:2*n,:) = dxd2dk(1:2:2*n,:) + alpha*dxd2dk(2:2:2*n,:);
        //dxd3dk(2:2:2*n,:) = dxd2dk(2:2:2*n,:);
<span class="fc" id="L980">        double[][] dxd3dk = new double[2*n][];</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L982">            tmp1 = Arrays.copyOf(dxd2dk[2*i + 1], dxd2dk[2*i + 1].length);</span>
<span class="fc" id="L983">            MatrixUtil.multiply(tmp1, alpha);</span>
<span class="fc" id="L984">            dxd3dk[2*i] = MatrixUtil.add(dxd2dk[2*i + 0], tmp1);</span>
<span class="fc" id="L985">            dxd3dk[2*i + 1] = Arrays.copyOf(dxd2dk[2*i + 1], dxd2dk[2*i + 1].length);</span>
        }

        //dxd3dalpha = zeros(2*n,1);
        //dxd3dalpha(1:2:2*n,:) = xd2(2,:)';
        // xd2 is [2*n X 1]
<span class="fc" id="L991">        double[] dxd3dalpha = new double[2*n];</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L993">            dxd3dalpha[i*2] = xd2[1][i];</span>
        }

        //% Pixel coordinates:
        //if length(f)&gt;1,
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        boolean focalXYSame = Math.abs(intrinsics.getIntrinsic()[0][0] - intrinsics.getIntrinsic()[1][1]) &lt; 1e-3;</span>

<span class="fc" id="L1000">        double[] c = new double[]{intrinsics.getIntrinsic()[0][2], intrinsics.getIntrinsic()[1][2]};</span>

        double[][] xp;
        double[][] dxpdom, dxpdT, dxpdk, dxpdf;
        double[] dxpdalpha;

<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">        if (!focalXYSame) {</span>
<span class="fc" id="L1007">            double[] f = new double[]{intrinsics.getIntrinsic()[0][0], intrinsics.getIntrinsic()[1][1]};</span>
            //xp = xd3. * (f(:) *ones(1, n))+c(:)*ones(1, n);
<span class="fc" id="L1009">            tmp1 = new double[n];</span>
<span class="fc" id="L1010">            Arrays.fill(tmp1, 1);</span>
<span class="fc" id="L1011">            tmp3 = MatrixUtil.outerProduct(f, tmp1);</span>
<span class="fc" id="L1012">            double[][] tmp4 = MatrixUtil.outerProduct(c, tmp1);</span>
<span class="fc" id="L1013">            xp = MatrixUtil.pointwiseAdd(MatrixUtil.pointwiseMultiplication(xd3, tmp3), tmp4);</span>

            //coeff = reshape(f(:)*ones(1, n), 2 * n, 1);
<span class="fc" id="L1016">            double[] coeff2 = MatrixUtil.stack(tmp3);  //[2*n X 1]</span>
            //dxpdom = (coeff * ones(1, 3)). * dxd3dom;
<span class="fc" id="L1018">            dxpdom = MatrixUtil.outerProduct(coeff2, new double[]{1, 1, 1}); // [2*n X 3]</span>
<span class="fc" id="L1019">            dxpdom = MatrixUtil.pointwiseMultiplication(dxpdom, dxd3dom);</span>

            //dxpdT = (coeff * ones(1, 3)). * dxd3dT;
<span class="fc" id="L1022">            dxpdT = MatrixUtil.outerProduct(coeff2, new double[]{1, 1, 1});</span>
<span class="fc" id="L1023">            dxpdT = MatrixUtil.pointwiseMultiplication(dxpdT, dxd3dT); // [2*n X 3]</span>

            //dxpdk = (coeff * ones(1, 5)). * dxd3dk;  [2*n X 5]
<span class="fc" id="L1026">            dxpdk = MatrixUtil.outerProduct(coeff2, new double[]{1, 1, 1, 1, 1});</span>
<span class="fc" id="L1027">            dxpdk = MatrixUtil.pointwiseMultiplication(dxpdk, dxd3dk);</span>

            //dxpdalpha = (coeff). * dxd3dalpha;  //[2*n X 1] [2*n X 1]
<span class="fc" id="L1030">            dxpdalpha = MatrixUtil.pointwiseMultiplication(coeff2, dxd3dalpha);</span>
            //dxpdf = zeros(2 * n, 2);
            //dxpdf(1:2:end, 1) =xd3(1,:)';
            //dxpdf(2:2:end, 2) =xd3(2,:)';
<span class="fc" id="L1034">            dxpdf = MatrixUtil.zeros(2*n, 2); //[2*nX2] for f as an array</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1036">                dxpdf[2*i][0] = xd3[0][i];</span>
<span class="fc" id="L1037">                dxpdf[2*i + 1][1] = xd3[1][i];</span>
            }

<span class="fc" id="L1040">        } else {</span>

            //xp = f * xd3 + c * ones(1, n); // [2Xn]
<span class="nc" id="L1043">            double f = intrinsics.getIntrinsic()[0][0];</span>
<span class="nc" id="L1044">            tmp1 = new double[n];</span>
<span class="nc" id="L1045">            Arrays.fill(tmp1, 1);</span>
<span class="nc" id="L1046">            tmp3 = MatrixUtil.outerProduct(c, tmp1);</span>
<span class="nc" id="L1047">            xp = MatrixUtil.copy(xd3);</span>
<span class="nc" id="L1048">            MatrixUtil.multiply(xp, f);</span>
<span class="nc" id="L1049">            xp = MatrixUtil.pointwiseAdd(xp, tmp3);</span>

            //dxpdom = f * dxd3dom;  [2*n X 3]
<span class="nc" id="L1052">            dxpdom = MatrixUtil.copy(dxd3dom);</span>
<span class="nc" id="L1053">            MatrixUtil.multiply(dxpdom, f);</span>

            //dxpdT = f * dxd3dT;  [2*n X 3]
<span class="nc" id="L1056">            dxpdT = MatrixUtil.copy(dxd3dT);</span>
<span class="nc" id="L1057">            MatrixUtil.multiply(dxpdT, f);</span>

            //dxpdk = f * dxd3dk;  [2*n X 5]
<span class="nc" id="L1060">            dxpdk = MatrixUtil.copy(dxd3dk);</span>
<span class="nc" id="L1061">            MatrixUtil.multiply(dxpdk, f);</span>

            //dxpdalpha = f. * dxd3dalpha;
<span class="nc" id="L1064">            dxpdalpha = Arrays.copyOf(dxd3dalpha, dxd3dalpha.length);</span>
<span class="nc" id="L1065">            MatrixUtil.multiply(dxpdalpha, f);</span>

            // xd3 is [2Xn].  dxpdf for scalar f is [2*n X 1]
            //dxpdf = xd3(:);
<span class="nc" id="L1069">            dxpdf = new double[1][];</span>
<span class="nc" id="L1070">            dxpdf[0] = MatrixUtil.stack(xd3);</span>
<span class="nc" id="L1071">            dxpdf = MatrixUtil.transpose(dxpdf);</span>
        }

        //dxpdc = zeros(2*n,2);
        //dxpdc(1:2:end,1) = ones(n,1);
        //dxpdc(2:2:end,2) = ones(n,1);
<span class="fc" id="L1077">        double[][] dxpdc = MatrixUtil.zeros(2*n, 2);</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1079">            dxpdc[2*i][0] = 1;</span>
<span class="fc" id="L1080">            dxpdc[2*i + 1][1] = 1;</span>
        }

        // arrays that could be returned:
        // arrays xp,dxpdom,dxpdT,dxpdf,dxpdc,dxpdk,dxpdalpha

<span class="fc" id="L1086">        ProjectedPoints pp = new ProjectedPoints();</span>
<span class="fc" id="L1087">        pp.xEst = xp;</span>
<span class="fc" id="L1088">        pp.dxdom = dxpdom;</span>
<span class="fc" id="L1089">        pp.dxdT = dxpdT;</span>
<span class="fc" id="L1090">        pp.dxdF = dxpdf;</span>
<span class="fc" id="L1091">        pp.dxdC = dxpdc;</span>
<span class="fc" id="L1092">        pp.dxdK = dxpdk;</span>
<span class="fc" id="L1093">        pp.dxdAlpha = dxpdalpha;</span>

<span class="fc" id="L1095">        return pp;</span>
    }

    /**
     * Computes the rigid motion transformation Y = R*X+T, where R = rodrigues(om).
     * &lt;pre&gt;
     *     rigid_motion.m
     *     TODO: put other Bouguet toolbox references here
     * &lt;/pre&gt;
     * @param X
     * @param om
     * @param T
     * @param useBouguetForRodrigues if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors
     * @return Y = R*X+T, where R = rodrigues(om).  returns
     * Y: 3D coordinates of the structure points in the camera reference frame (3xN matrix for N points)
     * %        dYdom: Derivative of Y with respect to om ((3N)x3 matrix)
     * %        dYdT: Derivative of Y with respect to T ((3N)x3 matrix)
     */
    static ProjectedPoints bouguetRigidMotion(double[][] X, double[] om, double[] T, boolean useBouguetForRodrigues) {

<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">        if (X.length != 3) {</span>
<span class="nc" id="L1116">            throw new IllegalArgumentException(&quot;X.length should be 3&quot;);</span>
        }
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">        if (om.length != 3) {</span>
<span class="nc" id="L1119">            throw new IllegalArgumentException(&quot;om.length should be 3&quot;);</span>
        }
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        if (T.length != 3) {</span>
<span class="nc" id="L1122">            throw new IllegalArgumentException(&quot;T.length should be 3&quot;);</span>
        }

<span class="fc" id="L1125">        boolean passive = true;</span>

        //[R, dRdom] = rodrigues(om);
<span class="fc" id="L1128">        Rotation.RodriguesRotation rRot = Rotation.createRotationRodriguesBouguet(om, passive);</span>
        double[][] r;
<span class="fc bfc" id="L1130" title="All 2 branches covered.">        if (useBouguetForRodrigues) {</span>
<span class="fc" id="L1131">            r = rRot.r;</span>
        } else {
<span class="fc" id="L1133">            r = Rotation.createRotationRodriguesFormula(om, passive);</span>
        }

        //[m,n] = size(X);
<span class="fc" id="L1137">        int m = X.length;</span>
<span class="fc" id="L1138">        int n = X[0].length;</span>

        //Y = R*X + repmat(T,[1 n]);
<span class="fc" id="L1141">        double[][] Y = MatrixUtil.multiply(r, X);</span>
        int i, j;
        double tmp;
<span class="fc bfc" id="L1144" title="All 2 branches covered.">        for (j = 0; j &lt; m; ++j) {</span>
<span class="fc" id="L1145">            tmp = T[j];</span>
<span class="fc bfc" id="L1146" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1147">                Y[j][i] += tmp;</span>
            }
        }

        //if nargout &gt; 1
        //dYdR = zeros(3 * n, 9);
        //dYdT = zeros(3 * n, 3);
<span class="fc" id="L1154">        double[][] dYdR = MatrixUtil.zeros(3*n, 9);</span>
<span class="fc" id="L1155">        double[][] dYdT = MatrixUtil.zeros(3*n, 3);</span>

        //dYdR(1:3:end, 1:3:end) =X';  //dYdR[i*3]     cols 0, 3, 6
        //dYdR(2:3:end, 2:3:end) =X';  //dYdR[i*3 + 1] cols 1, 4, 7
        //dYdR(3:3:end, 3:3:end) =X';  //dYdR[i*3 + 2] cols 2, 5, 8
        int ii;
<span class="fc" id="L1161">        int[] c0 = new int[]{0, 3, 6};</span>
<span class="fc" id="L1162">        int[] c1 = new int[]{1, 4, 7};</span>
<span class="fc" id="L1163">        int[] c2 = new int[]{2, 5, 8};</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">            for (ii = 0; ii &lt; 3; ++ii) {</span>
<span class="fc" id="L1166">                dYdR[i * 3][c0[ii]] = X[ii][i];</span>
<span class="fc" id="L1167">                dYdR[i*3 + 1][c1[ii]] = X[ii][i];</span>
<span class="fc" id="L1168">                dYdR[i*3 + 2][c2[ii]] = X[ii][i];</span>
            }
        }

        //dYdT(1:3:end, 1) =ones(n, 1);
        //dYdT(2:3:end, 2) =ones(n, 1);
        //dYdT(3:3:end, 3) =ones(n, 1);
<span class="fc bfc" id="L1175" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1176">            dYdT[i * 3][0] = 1;</span>
<span class="fc" id="L1177">            dYdT[i * 3 + 1][1] = 1;</span>
<span class="fc" id="L1178">            dYdT[i * 3 + 2][2] = 1;</span>
        }

        //dYdom = dYdR * dRdom;
        //        [3*n X 9] [9X3] = [3*n X 3]
<span class="fc" id="L1183">        double[][] dYdom = MatrixUtil.multiply(dYdR, rRot.dRdR);</span>

<span class="fc" id="L1185">        ProjectedPoints pp = new ProjectedPoints();</span>
<span class="fc" id="L1186">        pp.xEst = Y; //[3 X n]</span>
<span class="fc" id="L1187">        pp.dxdom = dYdom; //[3*n X 3]</span>
<span class="fc" id="L1188">        pp.dxdT = dYdT;  // [3*n X 3]</span>

<span class="fc" id="L1190">        return pp;</span>
    }

    /**
     *
     * @param init
     * @param intrinsics
     * @param xi
     * @param X
     * @param useBouguetsRodrigues if true,uses the Bouguet algorithms for Rodrigues Rotation matrix and vector,
     *                             else, uses the other Rotation.java Rodrigues methods.
     *                             Recommend using false at this time.
     * @return
     * @throws NotConvergedException
     */
    public static CameraExtrinsicParameters bouguetPoseRefine(CameraExtrinsicParameters init,
          CameraIntrinsicParameters intrinsics, double[][] xi, double[][] X,
          boolean useBouguetsRodrigues) throws NotConvergedException {

<span class="pc bpc" id="L1209" title="2 of 4 branches missed.">        if (xi.length != 2 &amp;&amp; xi.length != 3) {</span>
<span class="nc" id="L1210">            throw new IllegalArgumentException(&quot;xi length must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">        if (X.length != 3) {</span>
<span class="nc" id="L1213">            throw new IllegalArgumentException(&quot;X length must be3&quot;);</span>
        }

<span class="pc bpc" id="L1216" title="3 of 6 branches missed.">        if (init == null || init.getRodriguesVector() == null || init.getTranslation() == null) {</span>
<span class="nc" id="L1217">            throw new IllegalArgumentException(&quot;inital solution must have the Rodrigues rotation vector&quot; +</span>
                    &quot; and translation&quot;);
        }

        int i, j;

        //if size(m,1)&lt;3,
        //    m = [m;ones(1,Np)];
        //end;
        //if size(M,1)&lt;3,
        //    M = [M;ones(1,Np)];
        //end;
        //m = m ./ (ones(3,1)*m(3,:));
        //M = M ./ (ones(3,1)*M(3,:));

        //TODO: make this an argument or consider if it should be less than infinity
<span class="fc" id="L1233">        double threshCond = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1234">        int MaxIter = 20;</span>

        //% Initialization:
        //omckk = omc_init;
        //Tckk = Tc_init;
<span class="fc" id="L1239">        double[] omckk = Arrays.copyOf(init.getRodriguesVector(), init.getRodriguesVector().length);</span>
<span class="fc" id="L1240">        double[] Tckk = Arrays.copyOf(init.getTranslation(), init.getTranslation().length);</span>

<span class="fc" id="L1242">        int n = xi[0].length;</span>

        //[2 X n]
<span class="fc" id="L1245">        double[][] xkk = MatrixUtil.copySubMatrix(xi, 0, 1, 0, n - 1);</span>

        //% Final optimization (minimize the reprojection error in pixel):
        //% through Gradient Descent:

        //param = [omckk;Tckk];  [6X1]
<span class="fc" id="L1251">        double[] param = new double[6];</span>
<span class="fc" id="L1252">        System.arraycopy(omckk, 0, param, 0, 3);</span>
<span class="fc" id="L1253">        System.arraycopy(Tckk, 0, param, 3, 3);</span>

        //change = 1;
        //iter = 0;
<span class="fc" id="L1257">        double change = 1;</span>
<span class="fc" id="L1258">        int iter = 0;</span>

        //%keyboard;
        //%fprintf(1,'Gradient descent iterations: ');

        ProjectedPoints pp;

<span class="fc" id="L1265">        double[][] JJ = MatrixUtil.zeros(2*n, 6);</span>

<span class="fc bfc" id="L1267" title="All 4 branches covered.">        while ((change &gt; 1e-10) &amp;&amp; (iter &lt; MaxIter)) {</span>

            //%fprintf(1,'%d...',iter+1);
            //[x,dxdom,dxdT] = project_points2(X_kk,omckk,Tckk,fc,cc,kc,alpha_c);
<span class="fc" id="L1271">            pp = bouguetProjectPoints2(X, omckk, Tckk, intrinsics, useBouguetsRodrigues); // these are in image reference frame</span>
<span class="fc" id="L1272">            double[][] x = pp.xEst;  //[2 X n]</span>
<span class="fc" id="L1273">            double[][] dxdom = pp.dxdom; // [2*n X 3]</span>
<span class="fc" id="L1274">            double[][] dxdT = pp.dxdT; // [2*n X 3]</span>

            //ex = x_kk - x; //both are [2Xn]
<span class="fc" id="L1277">            double[][] ex = MatrixUtil.pointwiseSubtract(xkk, x);</span>

            //%keyboard;

            //JJ = [dxdom dxdT];  // [2*n X 3]  [2*n X 3] = [2*n X 6]
<span class="fc bfc" id="L1282" title="All 2 branches covered.">            for (i = 0; i &lt; 2*n; ++i) {</span>
<span class="fc" id="L1283">                System.arraycopy(dxdom[i], 0, JJ[i], 0, dxdom[i].length);</span>
<span class="fc" id="L1284">                System.arraycopy(dxdT[i], 0, JJ[i], dxdom[i].length, dxdT[i].length);</span>
            }

            //Condition number of a matrix is the ratio of the largest singular value of that matrix to the smallest singular value.
            //if cond(JJ) &gt; thresh_cond,
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">            if (MatrixUtil.conditionNumber(JJ) &gt; threshCond) {</span>
<span class="nc" id="L1290">                change = 0;</span>
            } else {
                //JJ2 = JJ'*JJ;  //[6 X 2*n][2*n X 6] = [6X6]
<span class="fc" id="L1293">                double[][] JJ2 = MatrixUtil.createATransposedTimesA(JJ);</span>

                //param_innov = inv(JJ2)*(JJ')*ex(:); //  [6X6][6 X 2*n] * [2*nX1] = [6 X 1]
<span class="fc" id="L1296">                double[] paramInnov = MatrixUtil.multiplyMatrixByColumnVector(</span>
<span class="fc" id="L1297">                        MatrixUtil.multiply(MatrixUtil.pseudoinverseFullColumnRank(JJ2), MatrixUtil.transpose(JJ)),</span>
<span class="fc" id="L1298">                        MatrixUtil.stack(ex)</span>
                );

                //           [6X1] + [6X1]
                //param_up = param + param_innov;
<span class="fc" id="L1303">                double[] paramUp = MatrixUtil.add(param, paramInnov);</span>

                //change = norm(param_innov)/norm(param_up);
<span class="fc" id="L1306">                change = MatrixUtil.lPSum(paramInnov, 2) / MatrixUtil.lPSum(paramUp, 2);</span>

                //param = param_up;
<span class="fc" id="L1309">                System.arraycopy(paramUp, 0, param, 0, paramUp.length);</span>
                //iter = iter + 1;
<span class="fc" id="L1311">                ++iter;</span>

                //omckk = param(1:3);
<span class="fc" id="L1314">                System.arraycopy(param, 0, omckk, 0, omckk.length);</span>

                //Tckk = param(4:6);
<span class="fc" id="L1317">                System.arraycopy(param, 3, Tckk, 0, Tckk.length);</span>

            }// end if
<span class="fc" id="L1320">        } // end while</span>

<span class="fc" id="L1322">        System.out.printf(&quot;bouguet refine iter=%d\n&quot;, iter);</span>
        //%fprintf(1,'\n');

<span class="fc" id="L1325">        boolean passive = true;</span>

        //Rckk = rodrigues(omckk);
        double[][] r;
<span class="fc bfc" id="L1329" title="All 2 branches covered.">        if (useBouguetsRodrigues) {</span>
<span class="fc" id="L1330">            r = Rotation.createRotationRodriguesBouguet(omckk, passive).r;</span>
        } else {
<span class="fc" id="L1332">            r = Rotation.createRotationRodriguesFormula(omckk, passive);</span>
        }

        //can return [omckk,Tckk,Rckk,JJ]
<span class="fc" id="L1336">        CameraExtrinsicParameters extr = new CameraExtrinsicParameters(r, omckk, Tckk);</span>
<span class="fc" id="L1337">        return extr;</span>
    }

    /**
     * calc a rotation (ambiguous) and translation between the measurements of a point in the real world.
     * the lists xC and X are correspondences of image and object.
     *
     * https://github.com/fragofer/TOOLBOX_calib/
     * compute_extrinsic_init.m
     * @param intrinsics
     * @param xc objects in camera coordinates
     * @param X objects in real world coordinates
     * @param vT formed from the SVD of X (hence, the last column is orthogonal to X)
     * @param XMean
     * @param useBouguetForRodrigues if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors
     * @return
     * @throws NotConvergedException
     * @throws IOException
     */
    static CameraExtrinsicParameters bouguetPoseInitPlanar(
            Camera.CameraIntrinsicParameters intrinsics, double[][] xc,
            double[][] X, DenseMatrix vT, double[] XMean, boolean useBouguetForRodrigues) throws NotConvergedException, IOException {

<span class="nc bnc" id="L1360" title="All 4 branches missed.">        if (xc.length != 2 &amp;&amp; xc.length != 3) {</span>
<span class="nc" id="L1361">            throw new IllegalArgumentException(&quot;xc length must be 3 or 2&quot;);</span>
        }
<span class="nc bnc" id="L1363" title="All 6 branches missed.">        if (X.length != 2 &amp;&amp; X.length != 3 &amp;&amp; X.length != 4) {</span>
<span class="nc" id="L1364">            throw new IllegalArgumentException(&quot;X length must be 2, 3, or 4&quot;);</span>
        }

<span class="nc" id="L1367">        boolean passive = true;</span>

        int i, j;

        //if size(m,1)&lt;3,
        //    m = [m;ones(1,Np)];
        //end;
        //if size(M,1)&lt;3,
        //    M = [M;ones(1,Np)];
        //end;
        //m = m ./ (ones(3,1)*m(3,:));
        //M = M ./ (ones(3,1)*M(3,:));

<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (xc.length == 2) {</span>
<span class="nc" id="L1381">            double[][] x2 = new double[3][];</span>
<span class="nc" id="L1382">            x2[0] = Arrays.copyOf(xc[0], xc[0].length);</span>
<span class="nc" id="L1383">            x2[1] = Arrays.copyOf(xc[1], xc[1].length);</span>
<span class="nc" id="L1384">            x2[2] = new double[xc[0].length];</span>
<span class="nc" id="L1385">            Arrays.fill(x2[2], 1);</span>
<span class="nc" id="L1386">            xc = x2;</span>
<span class="nc" id="L1387">        } else {</span>
<span class="nc" id="L1388">            xc = MatrixUtil.copy(xc);</span>
            // normalize by last coordinate just in case not performed already:
<span class="nc bnc" id="L1390" title="All 2 branches missed.">            for (i = 0; i &lt; xc[0].length; ++i) {</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">                for (j = 0; j &lt; xc.length; ++j) {</span>
<span class="nc" id="L1392">                    xc[j][i] /= xc[xc.length - 1][i];</span>
                }
            }
        }

<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (X.length == 2) {</span>
<span class="nc" id="L1398">            double[][] x2 = new double[3][];</span>
<span class="nc" id="L1399">            x2[0] = Arrays.copyOf(X[0], X[0].length);</span>
<span class="nc" id="L1400">            x2[1] = Arrays.copyOf(X[1], X[1].length);</span>
<span class="nc" id="L1401">            x2[2] = new double[X[0].length];</span>
<span class="nc" id="L1402">            Arrays.fill(x2[2], 1);</span>
<span class="nc" id="L1403">            X = x2;</span>
        }

<span class="nc bnc" id="L1406" title="All 2 branches missed.">        if (X.length == 4) {</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">            for (i = 0; i &lt; X[0].length; ++i) {</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">                for (j = 0; j &lt; X.length; ++j) {</span>
<span class="nc" id="L1409">                    X[j][i] /= X[X.length - 1][i];</span>
                }
            }
        }

        // planar structure
        //Transform the plane to bring it in the Z=0 plane:

<span class="nc" id="L1417">        int n = xc[0].length;</span>

        //R_transform = V';  [3X3]
<span class="nc" id="L1420">        double[][] Rtransform = MatrixUtil.convertToRowMajor(vT); // orthogonal to X...</span>
        //%norm(R_transform(1:2,3))

        //if norm(R_transform(1:2,3)) &lt; 1e-6,
        //    R_transform = eye(3);
        //end;
<span class="nc" id="L1426">        double norm0 = MatrixUtil.lPSum(new double[]{Rtransform[0][2], Rtransform[1][2]},2);</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">        if (norm0 &lt; 1e-6) {</span>
<span class="nc" id="L1428">            Rtransform = MatrixUtil.createIdentityMatrix(3);</span>
        }

        //if det(R_transform) &lt; 0, R_transform = -R_transform; end;
<span class="nc bnc" id="L1432" title="All 2 branches missed.">        if (MatrixUtil.determinant(Rtransform) &lt; 0) {</span>
<span class="nc" id="L1433">            MatrixUtil.multiply(Rtransform, -1);</span>
        }

        // [3X3][3 X 1] = [3 X 1]
        //T_transform = -(R_transform)*X_mean;
<span class="nc" id="L1438">        double[] Ttransform = MatrixUtil.multiplyMatrixByColumnVector(Rtransform, XMean);</span>
<span class="nc" id="L1439">        MatrixUtil.multiply(Ttransform, -1);</span>

        //   [3X3] [3Xn] = [3Xn];   [3X1][1Xn] = 3Xn
        //X_new = R_transform*X_kk + T_transform*ones(1,Np);
<span class="nc" id="L1443">        double[] ones = new double[n];</span>
<span class="nc" id="L1444">        Arrays.fill(ones, 1);</span>
<span class="nc" id="L1445">        double[][] t2 = MatrixUtil.outerProduct(Ttransform, ones);</span>
<span class="nc" id="L1446">        double[][] Xnew = MatrixUtil.multiply(Rtransform, X);</span>
<span class="nc" id="L1447">        Xnew = MatrixUtil.pointwiseAdd(Xnew, t2);</span>

        //% Compute the planar homography:

        //H = compute_homography(xn,X_new(1:2,:));
        //NLK: replace Xnew[2] with 1's because we are giving the method only the first
        // 2 rows of Xnew, then compute_homography.m when receiving Xnew of length 2,
        // appends a row of 1's in the Matlab code.
<span class="nc" id="L1455">        Arrays.fill(Xnew[2], 1);</span>
<span class="nc" id="L1456">        double[][] H = CameraCalibration.solveForHomographyBouget(xc, Xnew);</span>

        //% De-embed the motion parameters from the homography:
        // Matlab norm of a vector is a euclidean norm
        //sc = mean([norm(H(:,1));norm(H(:,2))]);
<span class="nc" id="L1461">        norm0 = MatrixUtil.lPSum(MatrixUtil.extractColumn(H, 0), 2);</span>
<span class="nc" id="L1462">        double norm1 = MatrixUtil.lPSum(MatrixUtil.extractColumn(H, 1), 2);</span>
<span class="nc" id="L1463">        double sc = (norm0 + norm1)/2.;</span>

        //H = H/sc;
<span class="nc" id="L1466">        MatrixUtil.multiply(H, 1./sc);</span>

        //u1 = H(:,1);
        //u1 = u1 / norm(u1);
<span class="nc" id="L1470">        double[] u1 = MatrixUtil.extractColumn(H, 0);</span>
<span class="nc" id="L1471">        MatrixUtil.multiply(u1, 1./MatrixUtil.lPSum(u1, 2));</span>

        //u2 = H(:,2) - dot(u1,H(:,2)) * u1;
        //u2 = u2 / norm(u2);
<span class="nc" id="L1475">        double[] tu2 = MatrixUtil.extractColumn(H, 1);</span>
<span class="nc" id="L1476">        double d = MatrixUtil.dot(u1, tu2);</span>
<span class="nc" id="L1477">        double[] tu1 = Arrays.copyOf(u1, u1.length);</span>
<span class="nc" id="L1478">        MatrixUtil.multiply(tu1, d);</span>
<span class="nc" id="L1479">        double[] u2 = new double[u1.length];</span>
<span class="nc" id="L1480">        MatrixUtil.pointwiseSubtract(tu2, tu1, u2);</span>

        //u3 = cross(u1,u2);
<span class="nc" id="L1483">        double[] u3 = MatrixUtil.crossProduct(u1, u2);</span>
        //RRR = [u1 u2 u3];
<span class="nc" id="L1485">        double[][] RRR = new double[3][];</span>
<span class="nc" id="L1486">        RRR[0] = u1;</span>
<span class="nc" id="L1487">        RRR[1] = u2;</span>
<span class="nc" id="L1488">        RRR[2] = u3;</span>
<span class="nc" id="L1489">        RRR = MatrixUtil.transpose(RRR);</span>
<span class="nc" id="L1490">        RRR = Rotation.orthonormalizeUsingSVD(RRR);</span>

        //omckk = rodrigues(RRR);
        double[] omckk;
<span class="nc bnc" id="L1494" title="All 2 branches missed.">        if (useBouguetForRodrigues) {</span>
<span class="nc" id="L1495">            Rotation.RodriguesRotation rRot = Rotation.extractRotationVectorRodriguesBouguet(RRR);</span>
<span class="nc" id="L1496">            omckk = rRot.rotVec;</span>
<span class="nc" id="L1497">        } else {</span>
<span class="nc" id="L1498">            omckk = Rotation.extractRotationVectorRodrigues(RRR);</span>
        }

        //%omckk = rodrigues([H(:,1:2) cross(H(:,1),H(:,2))]);
        //Rckk = rodrigues(omckk);
        double[][] Rckk;
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        if (useBouguetForRodrigues) {</span>
<span class="nc" id="L1505">            Rotation.RodriguesRotation rRot2 = Rotation.createRotationRodriguesBouguet(omckk, passive);</span>
<span class="nc" id="L1506">            Rckk = rRot2.r;</span>
<span class="nc" id="L1507">        } else {</span>
<span class="nc" id="L1508">            Rckk = Rotation.createRotationRodriguesFormula(omckk, passive);</span>
        }

        //Tckk = H(:,3);
<span class="nc" id="L1512">        double[] Tckk = MatrixUtil.extractColumn(H, 2);</span>
<span class="nc" id="L1513">        System.out.printf(&quot;T_transform of X from its origin=\n%s\n&quot;, FormatArray.toString(Ttransform, &quot;%.4e&quot;));</span>
<span class="nc" id="L1514">        System.out.printf(&quot;Tckk derived from homography between x and X_origin =\n%s\n&quot;, FormatArray.toString(Tckk, &quot;%.4e&quot;));</span>

        //%If Xc = Rckk * X_new + Tckk, then Xc = Rckk * R_transform * X_kk + Tckk + T_transform
        //NLK: Xc = Rckk * (R_transform * X_kk + T_transform) + Tckk
        //Tckk = Tckk + Rckk* T_transform;
<span class="nc" id="L1519">        Tckk = MatrixUtil.add(Tckk, MatrixUtil.multiplyMatrixByColumnVector(Rckk, Ttransform));</span>
<span class="nc" id="L1520">        System.out.printf(&quot;Tckk += Rckk* T_transform = \n%s\n&quot;, FormatArray.toString(Tckk, &quot;%.4e&quot;));</span>
        //Rckk = Rckk * R_transform;
<span class="nc" id="L1522">        Rckk = MatrixUtil.multiply(Rckk, Rtransform);</span>
        //omckk = rodrigues(Rckk);
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        if (useBouguetForRodrigues) {</span>
<span class="nc" id="L1525">            omckk = Rotation.extractRotationVectorRodriguesBouguet(Rckk).rotVec;</span>
            //Rckk = rodrigues(omckk);
<span class="nc" id="L1527">            Rckk = Rotation.createRotationRodriguesBouguet(omckk, passive).r;</span>
        } else {
<span class="nc" id="L1529">            omckk = Rotation.extractRotationVectorRodrigues(Rckk);</span>
            // this should be the same.  TODO: follow up on simplifying this method w.o. losing accuracy though
<span class="nc" id="L1531">            Rckk = Rotation.createRotationRodriguesFormula(omckk, passive);</span>
        }

<span class="nc" id="L1534">        return new CameraExtrinsicParameters(Rckk, omckk, Tckk);</span>
    }

    /**
     *
     * @param xc
     * @param X
     * @param useBouguetForRodrigues if true, uses only the Bouguet algoirthms for Rodrigues rotation matrices and vectors
     * @return
     * @throws NotConvergedException
     */
    static CameraExtrinsicParameters bouguetPoseInitNonPlanar(double[][] xc,
            double[][] X, boolean useBouguetForRodrigues) throws NotConvergedException {

<span class="pc bpc" id="L1548" title="2 of 4 branches missed.">        if (xc.length != 2 &amp;&amp; xc.length != 3) {</span>
<span class="nc" id="L1549">            throw new IllegalArgumentException(&quot;xc length must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L1551" title="4 of 6 branches missed.">        if (X.length != 2 &amp;&amp; X.length != 3 &amp;&amp; X.length != 4) {</span>
<span class="nc" id="L1552">            throw new IllegalArgumentException(&quot;X length must be 2, 3, or 4&quot;);</span>
        }

        int i, j;

        //if size(m,1)&lt;3,
        //    m = [m;ones(1,Np)];
        //end;
        //if size(M,1)&lt;3,
        //    M = [M;ones(1,Np)];
        //end;
        //m = m ./ (ones(3,1)*m(3,:));
        //M = M ./ (ones(3,1)*M(3,:));

<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">        if (xc.length == 2) {</span>
<span class="nc" id="L1567">            double[][] x2 = new double[3][];</span>
<span class="nc" id="L1568">            x2[0] = Arrays.copyOf(xc[0], xc[0].length);</span>
<span class="nc" id="L1569">            x2[1] = Arrays.copyOf(xc[1], xc[1].length);</span>
<span class="nc" id="L1570">            x2[2] = new double[xc[0].length];</span>
<span class="nc" id="L1571">            Arrays.fill(x2[2], 1);</span>
<span class="nc" id="L1572">            xc = x2;</span>
<span class="nc" id="L1573">        } else {</span>
<span class="fc" id="L1574">            xc = MatrixUtil.copy(xc);</span>
            // normalize by last coordinate just in case not performed already:
<span class="fc bfc" id="L1576" title="All 2 branches covered.">            for (i = 0; i &lt; xc[0].length; ++i) {</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">                for (j = 0; j &lt; xc.length; ++j) {</span>
<span class="fc" id="L1578">                    xc[j][i] /= xc[xc.length - 1][i];</span>
                }
            }
        }

<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">        if (X.length == 2) {</span>
<span class="nc" id="L1584">            double[][] x2 = new double[3][];</span>
<span class="nc" id="L1585">            x2[0] = Arrays.copyOf(X[0], X[0].length);</span>
<span class="nc" id="L1586">            x2[1] = Arrays.copyOf(X[1], X[1].length);</span>
<span class="nc" id="L1587">            x2[2] = new double[X[0].length];</span>
<span class="nc" id="L1588">            Arrays.fill(x2[2], 1);</span>
<span class="nc" id="L1589">            X = x2;</span>
        }

<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">        if (X.length == 4) {</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            for (i = 0; i &lt; X[0].length; ++i) {</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                for (j = 0; j &lt; X.length; ++j) {</span>
<span class="nc" id="L1595">                    X[j][i] /= X[X.length - 1][i];</span>
                }
            }
        }

        //% Computes an initial guess for extrinsic parameters (works for general 3d structure, not planar!!!):
        //% The DLT method is applied here!!

<span class="fc" id="L1603">        int n = xc[0].length;</span>

        //J = zeros(2*Np,12);
<span class="fc" id="L1606">        double[][] J = new double[2*n][];</span>

        //xX = (ones(3,1)*xn(1,:)).*X_kk;
        //yX = (ones(3,1)*xn(2,:)).*X_kk;
        //J(1:2:end,[1 4 7]) = -X_kk';
        //J(2:2:end,[2 5 8]) = X_kk';
        //J(1:2:end,[3 6 9]) = xX';
        //J(2:2:end,[3 6 9]) = -yX';
        //J(1:2:end,12) = xn(1,:)';
        //J(2:2:end,12) = -xn(2,:)';
        //J(1:2:end,10) = -ones(Np,1);
        //J(2:2:end,11) = ones(Np,1);

<span class="fc bfc" id="L1619" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1620">            J[i * 2] = new double[]{-X[0][i], 0, (xc[0][i] * X[0][i]), -X[1][i],</span>
                    0, xc[0][i] * X[1][i], -X[2][i], 0, xc[0][i] * X[2][i], -1, 0, xc[0][i]};
<span class="fc" id="L1622">            J[i * 2 + 1] = new double[]{0, X[0][i], -xc[1][i] * X[0][i], 0, X[1][i],</span>
                    -xc[1][i] * X[1][i], 0, X[2][i],
                    -xc[1][i] * X[2][i], 0, 1, -xc[1][i]};
        }

        //JJ = J'*J; [12 X 12]
<span class="fc" id="L1628">        double[][] JTJ = MatrixUtil.createATransposedTimesA(J);</span>
        //[U,S,V] = svd(JJ);
<span class="fc" id="L1630">        SVD svd = SVD.factorize(new DenseMatrix(JTJ));</span>

        //RR = reshape(V(1:9,12),3,3);
<span class="fc" id="L1633">        double[][] Vt = MatrixUtil.convertToRowMajor(svd.getVt()); //[12 X 12]</span>
<span class="fc" id="L1634">        double[] orth = Vt[11];</span>
        // reshape fills each column first, then next column, etc, so will fill by rows then transpose
<span class="fc" id="L1636">        double[][] RR = new double[3][];</span>
<span class="fc" id="L1637">        RR[0] = Arrays.copyOfRange(orth, 0, 3);</span>
<span class="fc" id="L1638">        RR[1] = Arrays.copyOfRange(orth, 3, 6);</span>
<span class="fc" id="L1639">        RR[2] = Arrays.copyOfRange(orth, 6, 9);</span>
<span class="fc" id="L1640">        RR = MatrixUtil.transpose(RR);</span>

        //if det(RR) &lt; 0,
        //        V(:,12) = -V(:,12);
        //RR = -RR;
        //end;
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">        if (MatrixUtil.determinant(RR) &lt; 0) {</span>
<span class="fc" id="L1647">            MatrixUtil.multiply(orth, -1);</span>
<span class="fc" id="L1648">            MatrixUtil.multiply(RR, -1);</span>
        }

        //[Ur,Sr,Vr] = svd(RR);
<span class="fc" id="L1652">        svd = SVD.factorize(new DenseMatrix(RR));</span>
<span class="fc" id="L1653">        double[][] Ur = MatrixUtil.convertToRowMajor(svd.getU());</span>
<span class="fc" id="L1654">        double[][] Vrt = MatrixUtil.convertToRowMajor(svd.getVt());</span>

        //Rckk = Ur*Vr';
<span class="fc" id="L1657">        double[][] Rckk = MatrixUtil.multiply(Ur, Vrt);</span>

        //sc = norm(V(1:9,12)) / norm(Rckk(:));
<span class="fc" id="L1660">        double norm0 = MatrixUtil.lPSum(Arrays.copyOfRange(orth, 0, 9), 2);</span>
<span class="fc" id="L1661">        double norm1 = MatrixUtil.lPSum(MatrixUtil.stack(Rckk), 2);</span>
<span class="fc" id="L1662">        double sc = norm0/norm1;</span>

<span class="fc" id="L1664">        boolean passive = true;</span>

        //Tckk = V(10:12,12)/sc;
<span class="fc" id="L1667">        double[] Tckk = Arrays.copyOfRange(orth, 9, 12);</span>
<span class="fc" id="L1668">        MatrixUtil.multiply(Tckk, 1./sc);</span>
        //omckk = rodrigues(Rckk);
        double[] omckk;
        //TODO: revisit this for passive, active consistencies
<span class="fc bfc" id="L1672" title="All 2 branches covered.">        if (useBouguetForRodrigues) {</span>
<span class="fc" id="L1673">            omckk = Rotation.extractRotationVectorRodriguesBouguet(Rckk).rotVec;</span>
            //Rckk = rodrigues(omckk);
<span class="fc" id="L1675">            Rckk = Rotation.createRotationRodriguesBouguet(omckk, passive).r;</span>
        } else {
<span class="fc" id="L1677">            omckk = Rotation.extractRotationVectorRodrigues(Rckk);</span>
<span class="fc" id="L1678">            Rckk = Rotation.createRotationRodriguesFormula(omckk, passive);</span>
        }

<span class="fc" id="L1681">        return new CameraExtrinsicParameters(Rckk, omckk, Tckk);</span>
    }
    
    /**
     * NOT YET IMPLEMENTED.
     * given n 3D-to-2D point correspondences, estimates the pose 
     * of a calibrated camera (a.k.a. P-n-P) with computational complexity O(n)
     * using the Moreno-Noguer et al. 2007 non-iterative algorithm.
     * This could be followed by non-linear optimization
     * to improve the parameter estimates.
     * &lt;pre&gt;
     * references:
     * Moreno-Noguer, Lepetite, &amp; Fua 2007, &quot;Accurate Non-Iterative O(n) Solution to the PnP Problem&quot;
     * Szeliski 2010 draft of &quot;Computer Vision: Algorithms and Applications&quot;
     * &lt;/pre&gt;
     * @param intrinsics
     * @param x the image coordinates of the features in format 3 X N where
     * 3 is for x, y, 1 rows, and N columns is the number of features.  At least 3 features are needed to 
     * calculate the extrinsic parameters.
     * NOTE x and X should both be distortion-free or both should be distorted.
     * @param X the world coordinates of the features in format 3 X N where
     * 3 is for x, y, 1 rows, and N columns is the number of features.  At least 3features are needed to 
     * calculate the extrinsic parameters.
     * NOTE x and X should both be distortion-free or both should be distorted.
     @return 
     */
    /*public static CameraExtrinsicParameters calculatePoseUsingPNP(
        Camera.CameraIntrinsicParameters intrinsics, double[][] x,
        double[][] X) throws NotConvergedException {
                
        if (x.length != 3) {
            throw new IllegalArgumentException(&quot;x.length must be 3&quot;);
        }
        if (X.length != 3) {
            throw new IllegalArgumentException(&quot;X.length must be 3&quot;);
        }
        int n = x[0].length;
        
        if (n &lt; 4) {
            throw new IllegalArgumentException(&quot;x must have at least 4 correspondences&quot;);
        }
        if (X[0].length != n) {
            throw new IllegalArgumentException(&quot;the number of columns in X must be the same as in x&quot;);
        }
        
        // Szeliski 2010 refers to perspective-n-point-problem (PnP) references  
        //   (Haralick, Lee, Ottenberg et al. 1994; Quan and Lan 1999; Moreno-Noguer, Lepetit, and Fua 2007)
        
        //port the c++ impl of  Moreno-Noguer, Lepetit, and Fua (2007)  here?
        //https://github.com/cvlab-epfl/EPnP/tree/master/cpp   
        
        throw new UnsupportedOperationException(&quot;not yet implemented&quot;);
    }
    */


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
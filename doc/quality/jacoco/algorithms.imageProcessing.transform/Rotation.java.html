<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rotation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Rotation.java</span></div><h1>Rotation.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.matrix.MatrixUtil;

import java.util.Arrays;
import java.lang.Math;

import algorithms.misc.MiscMath;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.NotConvergedException;
import no.uib.cipr.matrix.SVD;

/**
 * a utility class holding rotations associated with euler angles,
 * quaternions, and angle-axis representations (using rodrigues formula for the later).
 *
 Note that this class focus is intrinsic and passive transformations.
 If one needs extrinsic operations, there are notes here, but it might be best to implement
 methods using Direct Cosine matrices.
 * 
 * a rotation matrix describes a transformation in euclidean space.  it is a
 * member of  special orthogonal group SO(n) where n is usually 3, but can
 * be 4 for quaternion rotation matrix.  It has the properties R^T = R^−1 and det(R) = +-1.
 &lt;pre&gt;
   det(R)=1 is a proper rotation matrix.  rotation angles are counterclockwise.
       it's a special orthogonal matrix and provides the
       defining matrix representation of the group of proper n-dimensional rotations, denoted
       by SO(n). http://scipp.ucsc.edu/~haber/ph251/rotreflect_17.pdf
   det(R)=-1 is an improper rotation matrix representing rotations that
       require mirrors.
       The most general improper rotation matrix is a product of a proper rotation by an
       angle θ about some axis nˆ and a mirror reflection through a plane that passes through
       the origin and is perpendicular to nˆ.  NOTE: nˆ is determined by
       the right hand rule.
 &lt;/pre&gt;
 * This Rotation.java class uses &quot;passive&quot; Euler rotations of vectors counterclockwise in a right-handed
 * coordinate system (y counterclockwise from x) by pre-multiplication 
 * (R on the left) unless otherwise specified.
 * If any one of these is changed (such as rotating axes
 * instead of vectors, a &quot;active&quot; transformation), then the inverse of the
 * example matrix should be used, which coincides with its transpose.
 * e.g. (A*B*C)^-1 = (C^-1) * (B^-1) * (A^-1).

 see wikipedia article &quot;Active and Passive Transformations&quot;

 active rotations (a.k.a. alibi transformations):
     the reference frame stays fixed and the object of interest moves. The rotation is of the object being described.
     These are clockwise rotations (left hand system) of the object of interest about the fixed reference system origin .
     active rotations are the historical system used.

 passive rotations (a.k.a. alias transformations):
     the reference frame (coordinate system) is rotated and the object of interest stays fixed.
     These are counterclockwise rotations (right hand system) of the reference frame about its own
     origin while the object of interest says fixed.
     An example use is that from the perspective of being inside a plane - the inertial reference frame appears to move
     with the opposite rotation.  This system is used when we are describing the motion of the object we are in and
     controlling.

 an active rotation R(theta) is equivalent to the passive rotation R(-theta) which is R^T.

 active transformations are often used for multiple maneuvers of a body.

 * &lt;b&gt;&lt;ul&gt;RIGHT HAND SYSTEM&lt;/ul&gt;&lt;/b&gt;
 * The equations in this section use a right hand system (== passive transformations, CCW rotations of the object while
 * reference frame is fixed).
 * The right hand system is consistent with methods in physics, engineering,
 * and computer science in general.  The &lt;b&gt;Hamilton quaternion&lt;/b&gt; is consistent
 * with the right hand system and has format [scalar vector].
 * The NASA 1977 publication and Szeliski 2010
 *    define a quaternion as (qw, qx, qy, qz) where qw is a scalar and
 * [qx, qy, qz] is a vector.   That is the Hamilton Quaternion format.
 * 
 * In contrast, Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
 * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.)
 * define a quaternion as (qx, qy, qz, qw), scalar last.
 * One might need to transform some properties to quaternions and then modify 
 * the placement of the scalar term in order
 * to compare results with other &quot;Hamilton&quot; &quot;Right hand&quot; system results with scalar first format.
 * The Barfoot equations use active left-hand rule system and a &quot;scalar last&quot; format.
 *         
 &lt;pre&gt;
 R(q) = | (w^2 + x^2 - y^2 - z^2)  2(xy - wz)               2(xz + wy)               |
        | 2(xy + wz)               w^2 - x^2 + y^2 - z^2)   2(yz - wx)               |
        | 2(xz - wy)               2(yz + wx)               (w^2 - x^2 - y^2  + z^2) |
 rewritten 
 R(q) = | 1-2*(y^2 + z^2)   2(xy - zw)       2(xz + yw)      |
        | 2(xy + zw)        1-2(x^2 + z^2)   2(yz - xw)      |
        | 2(xz - yw)        2(yz + xw)       1-2(x^2 + y^2)  |
 &lt;/pre&gt;
 Quaternions can be derived from the axis/angle representation through the 
 formula q = (v, w) = (sin(theta)*n_hat,cos(theta)),
 where n_hat and theta are the rotation axis and angle.

 passive, CCW rotations (right hand system) of the reference frame about its own
 origin while the object of interest says fixed.
     rotation about z-axis (yaw):    about the y-axis (pitch):     about x-axis (roll):
                | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |
                | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |
                |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |
     Note that in the java methods below, the documentation should specify whether active or passive are used.

 applications of quaternions are intrinsic or extrinsic.

 intrinsic:
    apply transformation to the axis of the rotated coordinate reference frame (a.k.a. body frame).
    expresses F_w relative to F_b (F_b-&gt;F_w).
    vec_c = R_{b-&gt;c} * (R_{a-&gt;b} * vec_a) = R_{a-&gt;c} * vec_a
    The Barfoot et al. paper and book uses intrinsic.

 extrinsic:
    apply transformation to the axis in the World Coordinate reference frame.
    expresses F_b relative to F_w (F_w-&gt;F_b).
    Direct Cosine Matrices (DCM) used in extrinsic operations...

 The skew symmetric matrix (implemented in MatrixUtil.skewSymmetric(), is:
 [v]_x = |  0  -z   y |
         |  z   0  -x |
         | -y   x   0 |

 Its opposite is the anti-symmetric matrix and is equal to -1 * skewSymmetric:
 [[v]] = |  0   z  -y |
         | -z   0   x |
         |  y  -x   0 |

 From Shuster we have properties of the skew symmetric matrix (as -1 * anti-sym matrix [[v]]).
 &lt;pre&gt;
 let [u]_x be the skew symmetric of u and [v]_x be the skew-symmetric of v.
     where u and v are column vectors.

     -[u]_x * v = [v]_x * u

     -[u]_x * u = 0

     [u]_x = [ -[u]_x ]^T

     -[u]_x * -[v]_x = (u dot v) * I + v * u^T where '*' is matrix multiplication as usual.
     [u]_x * [v]_x = (u dot v) * I + v * u^T

     [u]_x * [v]_x - [v]_x * [u]_x = v * u^T - u*v^T = [u cross v]]_x

     u * v^T * -[w]_x + -[w]_x * v * u^T = -[u cross (v cross w)]_x
           where the later, triple cross product is used in making the Fundamental Matrix
           of photogrammetry, for example.
            implemented in MatrixUtil.tripleProduct() using a shorter form from Boas.
 &lt;/pre&gt;
 
 * Eigen, ROS, and Google Ceres use Hamilton convention (active, LH, CCW rotations of object in fixed reference frame).
*  Also  Wolfram Mathematica, Matlab’s aerospace(!) and robotics toolbox, 
*  Boost, GNU Octave, NASA’s SPICE.

Note that Shuster 1993 use the active, LH, CW rotations of the object while reference frame is fixed.
        about z-axis (yaw):           about the y-axis (pitch):    about x-axis (roll): 
            | cos φ    sin φ    0 |    |  cos ψ    0 -sin ψ |      |    1       0       0 |  
            |-sin φ    cos φ    0 |    |      0    1      0 |      |    0   cos θ   sin θ |  
            |     0        0    1 |    |  sin ψ    0  cos ψ |      |    0  -sin θ   cos θ |
 Note that in the java methods below, the documentation should specify whether active or passive are used.


 &lt;pre&gt;
 Some references in the right hand systems:
 
 &quot;Euler Angles and Quaternions and Transformations&quot;, NASA Mission Planning
  and Analysis Division, 1977, Shuttle Program.

  Szeleski 2010
  
  Shuster 1993, &quot;A Survey of Attitude Representations&quot;
    Journal of Astronautical Sciences, Vol 41, No. 4, Oct-Dec 1993, pp 439-517
    http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf
  
  &quot;Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors&quot;
   James Diebel, 2006
 &lt;/pre&gt;
* 
 * &lt;pre&gt;&lt;b&gt;&lt;ul&gt;LEFT HAND SYSTEM&lt;/ul&gt;&lt;/b&gt;&lt;/pre&gt;
 * A left hand system, in contrast, is used by aerospace engineering and
 * aerospace medicine to describe the z-axis as pointing downwards (in the 
 * direction of gravity w.r.t. a geo-centric system.)
 * 
 * Chapter 4, &quot;Human Response to Acceleration&quot; by Banks, Brinkly, Allnut, and Harding
    in &quot;Fundamentals of Aerospace Medicine&quot;
    Excerpt:
    &quot;For example, the Advisory Group for Aerospace
    Research and Development (AGARD) standard for human
    acceleration differs from the AGARD standard for aircraft
    design (in which the z-acceleration axis is reversed and
    positive downward).
        ...consistent with the AGARD standard (1), the
    Table of Equivalents for Acceleration Terminology (2), the
    Aviation Space and Environmental Medicine Standard (3),
    and the majority of the Aerospace Medicine literature, the
    positive direction of each of these axes is here described by
    ‘‘the left-hand rule.’’   That is, the x-axis dimension is an arrow
     with the positive direction forward, the y-axis dimension has
    the positive direction rightward, and&quot;
  
  &lt;pre&gt;

 Rotations about the same axis are additive.
 
* Regarding rotation axes and perspectives:
*     https://en.wikipedia.org/wiki/Rotation_matrix#Ambiguities
*     The coordinates of a point P may change due to either a rotation of the 
*     coordinate system CS (alias), or a rotation of the point P (alibi). 
*     In the latter case, the rotation of P also produces a rotation of the 
*     vector v representing P. In other words, either P and v are fixed while 
*     CS rotates (alias), or CS is fixed while P and v rotate (alibi). Any 
*     given rotation can be legitimately described both ways, as vectors and 
*     coordinate systems actually rotate with respect to each other, about the 
*     same axis but in opposite directions. Throughout this article, we chose the 
*     alibi approach to describe rotations. For instance, 
*        R(theta)= | cos(theta)  -sin(theta) |
*                  | sin(theta)   cos(theta) |
*     represents a counterclockwise rotation of a vector v by an angle θ, or a 
*     rotation of the coordinate system (CS) by the same angle but in the opposite direction 
*     (i.e. clockwise). Alibi and alias transformations are also known as active 
*     and passive transformations, respectively.
* 
*     Pre-multiplication or post-multiplication
         The same point P can be represented either by a column vector v or a 
         row vector w. Rotation matrices can either pre-multiply column vectors 
         (Rv), or post-multiply row vectors (wR). However, Rv produces a 
         rotation in the opposite direction with respect to wR. 
         Throughout this article, rotations produced on column vectors are 
         described by means of a pre-multiplication. To obtain exactly the same 
         rotation (i.e. the same final coordinates of point P), the equivalent 
         row vector must be post-multiplied by the transpose of R (i.e. wR^T).
 
 skew symmetric of vector v is [v]_x:
       |    0   -v[2]  v[1]  |
       |  v[2]    0    -v[0] |
       | -v[1]  v[0]    0    |
    
    e^(i*theta) = cos(theta) + i*sin(theta)
    
    exponential of a matrix is expanded via power series:  e^A = I + A + (higher order terms AA/2! + AAA/3!...)
    
    for A = | 0  -1 |
            | 1   0 |
    
    e^(A*t) = |  cos(t)  -sin(t)  |  through diagonalizing A
              |  sin(t)   cos(t)  |
    
    for A being skew symmetric: |  0  -z  y |
                                |  z   0 -x |
                                | -y   x  0 |
    e^(A*theta) = I + A*sin(theta) +A^2*(1 - cos(theta))
    
    
    R_axis = exp(-[e_axis]_x*theta_axis)
    
    R_x = exp(-[1,0,0]_x * theta_x) = exp( 0  0  0 )*theta_x )
                                           0  0  1
                                           0 -1  0
      
   terms used describing axes of rotation, attitude or orientation:
        heading, attitude, bank,
        pitch, yaw, roll,
        pan, tilt, roll
        
   A rotation can be represented by a rotation axis nˆ and an angle ω,
   or equivalently by a 3D vector ω = θ*nˆ
   to project vector v onto the axis nˆ:
      v_parallel = nˆ*(nˆ· v) = (nˆ*nˆ^T)*v and this is not affected by rotation
      v_perpendicular = v - v_parallel
                      = (I - nˆ*nˆ^T)*v
   can rotate v by 90 degrees using the cross product:
      nˆ cross v = [nˆ]_x * v
      where [nˆ]_x is the skew-symmetric matrix of nˆ

   can rotate v by 180 degrees:
      nˆ cross (nˆ cross v) = ([nˆ]_x)^2 * v = -v_perpendicular
   which shows that can also write
      v_parallel = (I + ([nˆ]_x)^2 * v)

 examples transforming sequences:
     passive A(a)*B(b)*C(c)
     active A(-a)*B(-b)*C(-c)
                   = A(a)^T * B(b)^T * C(c)^T
                   = (C(c) * B(b) * C(c))^T

     intrinsic ABC = extrinsic CBA

     example:
        from scipy.spatial.transform import Rotation as R
        R.from_euler('XYZ', [-0.1, -0.2, -0.3]).as_matrix()
        array([[ 0.93629336,  0.28962948, -0.19866933],
               [-0.27509585,  0.95642509,  0.0978434 ],
               [ 0.21835066, -0.03695701,  0.97517033]])
        R.from_euler('xyz', [0.1, 0.2, 0.3]).inv().as_matrix()
        array([[ 0.93629336,  0.28962948, -0.19866933],
               [-0.27509585,  0.95642509,  0.0978434 ],
               [ 0.21835066, -0.03695701,  0.97517033]])
 &lt;/pre&gt;

 * see Barfoot et al.
 * see http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
 **
 * &lt;pre&gt;
  also note that for optimization of rotation :
      prefer to update the rotation vectors and/or the rotation matrices.
      do not update the euler angles because eqn (28) of Barfoot et al. shows that an inverse term
      is not defined at singularities.
      do not extract euler angles or vector from a rotation matrix unless unavoidable because the
      extraction is ambiguous.
      the create rotation matrix from rotation vector or from euler angles is fine.
 * &lt;/pre&gt;
 *
 * @author nichole
 */
<span class="pc" id="L311">public class Rotation {</span>

    /**
     * types of Euler rotation sequences implemented in this class for the Barfoot quaternion
     * equations.
     * Note:
     * passive A(a)*B(b)*C(c)
     * active A(-a)*B(-b)*C(-c)
     *         = A(a)^T * B(b)^T * C(c)^T
     *         = (C(c) * B(b) * C(c))^T
     */
    public static enum EulerSequence {
        XYZ_ACTIVE /*1-2-3*/, ZYX_ACTIVE /*3-2-1*/
    };

    public abstract static class RotationPerturbation {
        /**
         * dPhi is the rotation vector defined near eqn (26) of Barfoot et al.
         * Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
         * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.)
         */
        double[] dPhi;

        final EulerSequence seq;

        public RotationPerturbation(double[] dPhi, EulerSequence seq) {
            this.dPhi = dPhi;
            this.seq = seq;
        }
        public abstract RotationPerturbation copy();
    }
    public static class RotationPerturbationMatrix extends RotationPerturbation{
        /**
         * the current updated rotation
         */
        double[][] rotation;
        public RotationPerturbationMatrix(double[] dPhi, EulerSequence seq) {
            super(dPhi, seq);
        }
        public RotationPerturbationMatrix(double[] dPhi, EulerSequence seq, double[][] rotation) {
            super(dPhi, seq);
            this.rotation = rotation;
        }
        public RotationPerturbationMatrix copy() {
            return new RotationPerturbationMatrix(Arrays.copyOf(this.dPhi, dPhi.length), this.seq,
                    MatrixUtil.copy(rotation));
        }
    }
    public static class RotationPerturbationQuaternion extends RotationPerturbation{
        /**
         * the current updated quaternion
         */
        double[] quaternion;
        public RotationPerturbationQuaternion(double[] dPhi, EulerSequence seq) {
            super(dPhi, seq);
        }
        public RotationPerturbationQuaternion(double[] dPhi, EulerSequence seq, double[] quaternion) {
            super(dPhi, seq);
            this.quaternion = quaternion;
        }
        public RotationPerturbationQuaternion copy() {
            return new RotationPerturbationQuaternion(Arrays.copyOf(this.dPhi, dPhi.length), this.seq,
                    Arrays.copyOf(quaternion, quaternion.length));
        }
    }

    /**
     * calculate R(angle_z, angle_y, angle_x) = R_x(angle_x)*R_y(angle_y)*R_z(angle_z).
     * The internal composition follows passive (right hand), CCW rotations
     * with order of operations ((R(X) * R(Y)) * R(Z)), that is left to right,
     * intrinsic composition.
     *
     * If the context is aeronautical, you may want to use createRotationZYX instead.
     *
     * &lt;pre&gt;
     This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
      &lt;/pre&gt;
     * @param angleX angle of rotation about x-axis (roll) in units of radians.
     * @param angleY angle of rotation about y-axis (pitch) in units of radians.
     * @param angleZ angle of rotation about z-axis (yaw) in units of radians.
     * @return 
     */
    public static double[][] createRotationXYZ(double angleX, double angleY, double angleZ) {
<span class="fc" id="L398">        double[][] rX = Rotation.createRotationRoll(angleX);</span>
<span class="fc" id="L399">        double[][] rY = Rotation.createRotationPitch(angleY);</span>
<span class="fc" id="L400">        double[][] rZ = Rotation.createRotationYaw(angleZ);</span>

<span class="fc" id="L402">        return MatrixUtil.multiply(MatrixUtil.multiply(rX, rY), rZ);</span>
    }

    public static double[][] createRotationXYZ(double angleX, double angleY, double angleZ, boolean passive) {
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (passive) {</span>
<span class="fc" id="L407">            return createRotationXYZ(angleX, angleY, angleZ);</span>
        }
<span class="fc" id="L409">        return createRotationXYZ(-angleX, -angleY, -angleZ);</span>
    }

    public static double[][] createRotationZYX(double angleX, double angleY, double angleZ, boolean passive) {
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (passive) {</span>
<span class="nc" id="L414">            return createRotationZYX(angleX, angleY, angleZ);</span>
        }
<span class="fc" id="L416">        return createRotationZYX(-angleX, -angleY, -angleZ);</span>
    }

    /**
     * create matrix for rotation about the X-axis, a.k.a. roll in passive system (right-hand system, CCW).
       &lt;pre&gt;
       about x-axis (roll):       
       |    1       0       0 |  
       |    0   cos θ  -sin θ |  
       |    0   sin θ   cos θ | 
       &lt;/pre&gt;
     * @param angle angle of rotation about x-axis (roll) in units of radians.
     * @return 
     */
    public static double[][] createRotationRoll(double angle) {
        
<span class="fc" id="L432">        double[][] rot = MatrixUtil.zeros(3, 3);</span>
        
<span class="fc" id="L434">        double c = Math.cos(angle);</span>
<span class="fc" id="L435">        double s = Math.sin(angle);</span>
        
<span class="fc" id="L437">        rot[0][0] = 1;</span>
<span class="fc" id="L438">        rot[1][1] = c;</span>
<span class="fc" id="L439">        rot[1][2] = -s;</span>
<span class="fc" id="L440">        rot[2][1] = s;</span>
<span class="fc" id="L441">        rot[2][2] = c;</span>
        
<span class="fc" id="L443">        return rot;</span>
    }

    public static double[][] createRotationRoll(double angle, boolean passive) {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (passive) {</span>
<span class="nc" id="L448">            return createRotationRoll(angle);</span>
        }
<span class="nc" id="L450">        return createRotationRoll(-angle);</span>
    }
    
    /**
     * create matrix for rotation about the X-axis, a.k.a. roll.
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
       &lt;pre&gt;
       about x-axis (roll):       
       |    1       0       0 |  
       |    0   cos θ  -sin θ |  
       |    0   sin θ   cos θ | 
       &lt;/pre&gt;
     * @param angle angle of rotation about x-axis (roll) in units of radians.
     * @param out holds values for rotation matrix for roll. 
     */
    public static void createRotationRoll(double angle, double[][] out) {

<span class="nc bnc" id="L467" title="All 4 branches missed.">        if (out.length != 3 || out[0].length != 3) {</span>
<span class="nc" id="L468">            throw new IllegalArgumentException(&quot;out must be 3x3&quot;);</span>
        }
        
        
<span class="nc" id="L472">        double c = Math.cos(angle);</span>
<span class="nc" id="L473">        double s = Math.sin(angle);</span>
        
<span class="nc" id="L475">        out[0][0] = 1;</span>
<span class="nc" id="L476">        out[0][1] = 0;</span>
<span class="nc" id="L477">        out[0][2] = 0;</span>
<span class="nc" id="L478">        out[1][0] = 0;</span>
<span class="nc" id="L479">        out[1][1] = c;</span>
<span class="nc" id="L480">        out[1][2] = -s;</span>
<span class="nc" id="L481">        out[2][0] = 0;</span>
<span class="nc" id="L482">        out[2][1] = s;</span>
<span class="nc" id="L483">        out[2][2] = c;        </span>
<span class="nc" id="L484">    }        </span>
    
    /**
    create matrix for rotation about the Y-axis, a.k.a. pitch in passive system (right-hand, CCW).
      &lt;pre&gt;
      about the y-axis (pitch):
      |  cos ψ    0  sin ψ |
      |      0    1      0 |
      | -sin ψ    0  cos ψ |
      &lt;/pre&gt;
     * @param angle angle of rotation about y-axis (pitch) in units of radians.  Euler notation
     *              uses the right-hand rule for rotations.
     * @return 
    */
    public static double[][] createRotationPitch(double angle) {
        
<span class="fc" id="L500">        double[][] rot = MatrixUtil.zeros(3, 3);</span>
        
<span class="fc" id="L502">        double c = Math.cos(angle);</span>
<span class="fc" id="L503">        double s = Math.sin(angle);</span>
        
<span class="fc" id="L505">        rot[0][0] = c;</span>
<span class="fc" id="L506">        rot[0][2] = s;</span>
<span class="fc" id="L507">        rot[1][1] = 1;</span>
<span class="fc" id="L508">        rot[2][0] = -s;</span>
<span class="fc" id="L509">        rot[2][2] = c;</span>
        
<span class="fc" id="L511">        return rot;</span>
    }

    public static double[][] createRotationPitch(double angle, boolean passive) {
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">        if (passive) {</span>
<span class="fc" id="L516">            return createRotationPitch(angle);</span>
        }
<span class="nc" id="L518">        return createRotationPitch(-angle);</span>
    }
    
    /**
    create matrix for rotation about the Y-axis, a.k.a. pitch.
     This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
      &lt;pre&gt;
      about the y-axis (pitch):
      |  cos ψ    0  sin ψ |
      |      0    1      0 |
      | -sin ψ    0  cos ψ |
      &lt;/pre&gt;
     * @param angle angle of rotation about y-axis (pitch) in units of radians.
     * @param out holds values for rotation matrix for pitch 
    */
    public static void createRotationPitch(double angle,
                                           double[][] out) {

<span class="nc bnc" id="L536" title="All 4 branches missed.">        if (out.length != 3 || out[0].length != 3) {</span>
<span class="nc" id="L537">            throw new IllegalArgumentException(&quot;out must be 3x3&quot;);</span>
        }
        
<span class="nc" id="L540">        double c = Math.cos(angle);</span>
<span class="nc" id="L541">        double s = Math.sin(angle);</span>
        
<span class="nc" id="L543">        out[0][0] = c;</span>
<span class="nc" id="L544">        out[0][1] = 0;</span>
<span class="nc" id="L545">        out[0][2] = s;</span>
<span class="nc" id="L546">        out[1][0] = 0;</span>
<span class="nc" id="L547">        out[1][1] = 1;</span>
<span class="nc" id="L548">        out[1][2] = 0;</span>
<span class="nc" id="L549">        out[2][0] = -s;</span>
<span class="nc" id="L550">        out[2][1] = 0;</span>
<span class="nc" id="L551">        out[2][2] = c;        </span>
<span class="nc" id="L552">    }</span>
    
    /**
    create matrix for rotation about the Z-axis, a.k.a. yaw in passive system (right-hand system, CCW).
      &lt;pre&gt;
        about z-axis (yaw):          
            | cos φ   -sin φ    0 | 
            | sin φ    cos φ    0 | 
            |     0        0    1 | 
      &lt;/pre&gt;
     * @param angle angle of rotation about z-axis (yaw) in units of radians.
     * @return 
    */
    public static double[][] createRotationYaw(double angle) {
        
<span class="fc" id="L567">        double[][] rot = MatrixUtil.zeros(3, 3);</span>
        
<span class="fc" id="L569">        double c = Math.cos(angle);</span>
<span class="fc" id="L570">        double s = Math.sin(angle);</span>
        
<span class="fc" id="L572">        rot[0][0] = c;</span>
<span class="fc" id="L573">        rot[0][1] = -s;</span>
<span class="fc" id="L574">        rot[1][0] = s;</span>
<span class="fc" id="L575">        rot[1][1] = c;</span>
<span class="fc" id="L576">        rot[2][2] = 1;</span>
        
<span class="fc" id="L578">        return rot;</span>
    }

    public static double[][] createRotationYaw(double angle, boolean passive) {
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (passive) {</span>
<span class="nc" id="L583">            return createRotationYaw(angle);</span>
        }
<span class="nc" id="L585">        return createRotationYaw(-angle);</span>
    }
    
    /**
    create matrix for rotation about the Z-axis, a.k.a. yaw.
     This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
      &lt;pre&gt;
        about z-axis (yaw):          
            | cos φ   -sin φ    0 | 
            | sin φ    cos φ    0 | 
            |     0        0    1 | 
      &lt;/pre&gt;
     * @param angle angle of rotation about z-axis (yaw) in units of radians.
     * @param out results for a rotation matrix for yaw.  size given to method 
     * must be 3X3.
    */
    public static void createRotationYaw(double angle, double[][] out) {

<span class="nc bnc" id="L603" title="All 4 branches missed.">        if (out.length != 3 || out[0].length != 3) {</span>
<span class="nc" id="L604">            throw new IllegalArgumentException(&quot;out must be 3x3&quot;);</span>
        }        
        
<span class="nc" id="L607">        double c = Math.cos(angle);</span>
<span class="nc" id="L608">        double s = Math.sin(angle);</span>
        
<span class="nc" id="L610">        out[0][0] = c;</span>
<span class="nc" id="L611">        out[0][1] = -s;</span>
<span class="nc" id="L612">        out[0][2] = 0;</span>
<span class="nc" id="L613">        out[1][0] = s;</span>
<span class="nc" id="L614">        out[1][1] = c;</span>
<span class="nc" id="L615">        out[1][2] = 0;</span>
<span class="nc" id="L616">        out[2][0] = 0;</span>
<span class="nc" id="L617">        out[2][1] = 0;</span>
<span class="nc" id="L618">        out[2][2] = 1;</span>
        
<span class="nc" id="L620">    }</span>

    /**
     * calculate the rotation needed to transform direction v1 to direction v2 using
     * a quaternion.
     * @param v1
     * @param v2
     * @return
     */
    public static double[] rotationBetweenTwoDirections0(double[] v1, double[] v2, boolean passive) {
<span class="fc" id="L630">        double[] n1 = MatrixUtil.normalizeL2(v1);</span>
<span class="fc" id="L631">        double[] n2 = MatrixUtil.normalizeL2(v2);</span>
<span class="fc" id="L632">        double angle = -Math.acos(n1[0]*n2[0] + n1[1]*n2[1] + n1[2]*n2[2]);</span>
<span class="fc" id="L633">        double[] axis = MatrixUtil.crossProduct(n1, n2);</span>
<span class="fc" id="L634">        double[] qH = Rotation.createQuaternionHamiltonFromAngleAxis(angle, axis);</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (passive) {</span>
<span class="fc" id="L636">            return qH;</span>
        }
<span class="nc" id="L638">        return Rotation.createQuaternionBarfootFromHamilton(qH);</span>
    }

    public static double createAngleAxisFromRotationVector(double[] rV, double[] outRAxis) {
<span class="fc" id="L642">        double theta = MatrixUtil.lPSum(rV, 2);</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        for (int i = 0; i &lt; rV.length; ++i) {</span>
<span class="fc" id="L644">            outRAxis[i] = rV[i]/theta;</span>
        }
<span class="fc" id="L646">        return theta;</span>
    }

    /**
     * create rotation vector, given angle axis after making the angle axis.
     * NOTE: for best results, make the angle axis pair unit length first, by using&quot;
     * angle = Rotation.makeUnitLengthAngleAxis(angle, axis);
     * @param axis
     * @param angle
     * @return
     */
    public static double[] createRotationVectorFromAngleAxis(double[] axis, double angle) {
<span class="fc" id="L658">        double[] rVec = Arrays.copyOf(axis, axis.length);</span>
<span class="fc" id="L659">        MatrixUtil.multiply(rVec, angle);</span>
<span class="fc" id="L660">        return rVec;</span>
    }

    /**
     * convert the euler angles to angle axis representation.
     * NOTE that the resulting vector is the angle axis times the angle, so you can calculate:
     &lt;pre&gt;
     angle = ||result||
     and
     axis = result//angle
     &lt;/pre&gt;
     *
     * @param euler euler angles for [x, y, z]
     * @return
     */
    public static double[] createRotationVectorFromEulerAnglesXYZ(double[] euler) throws NotConvergedException {
<span class="fc" id="L676">        double[][] r = createRotationXYZ(euler[0], euler[1], euler[2]);</span>
<span class="fc" id="L677">        return Rotation.extractRotationVectorRodrigues(r);</span>
    }

    public static double[][] createRotationFromEulerAngles(double[] eulerXYZ, EulerSequence seq) {
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">        if (seq.equals(EulerSequence.XYZ_ACTIVE)) {</span>
            // intrinsic and active
<span class="fc" id="L683">            return createRotationXYZ(-eulerXYZ[0], -eulerXYZ[1], -eulerXYZ[2]);</span>
        } else {
            // ZYX active
<span class="nc" id="L686">            return createRotationZYX(-eulerXYZ[0], -eulerXYZ[1], -eulerXYZ[2]);</span>
        }
    }

    public static double[] createRotationVectorFromEulerAngles(double[] eulerXYZ, EulerSequence seq) throws NotConvergedException {
<span class="fc" id="L691">        double[][] r = createRotationFromEulerAngles(eulerXYZ, seq);</span>
<span class="fc" id="L692">        return Rotation.extractRotationVectorRodrigues(r);</span>
    }

    /**
     * convert the eulerXYZ angles to angle axis representation.
     * NOTE that the resulting vector is the angle axis times the angle, so you can calculate:
     &lt;pre&gt;
     angle = ||result||
     and
     axis = result//angle
     &lt;/pre&gt;
     *
     * @param eulerXYZ eulerXYZ angles for [x, y, z]
     * @return
     */
    public static double createAngleAxisFromEulerAnglesXYZ(double[] eulerXYZ, double[] outAxis) throws NotConvergedException {
<span class="fc" id="L708">        double[][] r = createRotationXYZ(eulerXYZ[0], eulerXYZ[1], eulerXYZ[2]);</span>
<span class="fc" id="L709">        double[] rotVec = Rotation.extractRotationVectorRodrigues(r);</span>
<span class="fc" id="L710">        return Rotation.createAngleAxisFromRotationVector(rotVec, outAxis);</span>
    }

    /**
     * create a rotation axis using the Rodrigues formula.  Note that internally,
     * the unit-length angle axis pair is first calculated and then used in the Rodrigues formula.
     * @param axis
     * @param angle
     * @param passive
     * @return
     */
    public static double[][] createRotationRodriguesFormula(double[] axis, double angle, boolean passive) {
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (axis.length != 3) {</span>
<span class="nc" id="L723">            throw new IllegalArgumentException(&quot;axis length must be 3&quot;);</span>
        }
<span class="fc" id="L725">        axis = Arrays.copyOf(axis, 3);</span>
<span class="fc" id="L726">        angle = Rotation.makeUnitLengthAngleAxis(angle, axis);</span>
<span class="fc" id="L727">        double[] rotVec = createRotationVectorFromAngleAxis(axis, angle);</span>
<span class="fc" id="L728">        return createRotationRodriguesFormula(rotVec, passive);</span>
    }
    
    /**
     * given rotVec as an array of rotations about x, y, and z, calculate the
     * rotation matrix.  
     * essentially, excepting a small angle correction:
     *     R^⊤ = cosθ*I + sinθ*[rotVec]_× + (1−cosθ)*rotVec*rotVec^⊤
     *
     * NOTE: if computing the partial derivative of Rotation elsewhere, 
     * can use d(R(ω)*rotVec)/d(ω^T) = -[rotVec]_x (see Equation (2.35) of Szeliski 2010).
     * Also note that a + sign in front of the sine(θ) term is used for the
     * &quot;passive&quot; system of rotations.
     * &lt;pre&gt;
     * references:
     *    Dmitry Berenson https://github.com/robEllenberg/comps-plugins/blob/master/python/rodrigues.py
     *    Szeliski 2010 draft &quot;Computer Vision: Algorithms and Applications&quot;
     *    Rodriguez’s formula (Ayache 1989)
     * &lt;/pre&gt;
     * @param rotVec [1x3] array of rotVec of rotations about x, y, and z
     * @param passive if true uses passive right-hand system of CCW rotation, else uses active left-hand CW rotations
     * @return rotation matrix [3X3]
     */
    public static double[][] createRotationRodriguesFormula(double[] rotVec, boolean passive) {
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">        if (rotVec.length != 3) {</span>
<span class="nc" id="L753">            throw new IllegalArgumentException(&quot;rotVec length must be 3&quot;);</span>
        }

        /*
        https://github.com/robEllenberg/comps-plugins/blob/master/python/rodrigues.py

        Copyright (c) 2010 Carnegie Mellon University and Intel Corporation
        #   Author: Dmitry Berenson &lt;dberenso@cs.cmu.edu&gt;
        #
        #   Redistribution and use in source and binary forms, with or without
        #   modification, are permitted provided that the following conditions are met:
        #
        #     * Redistributions of source code must retain the above copyright
        #       notice, this list of conditions and the following disclaimer.
        #     * Redistributions in binary form must reproduce the above copyright
        #       notice, this list of conditions and the following disclaimer in the
        #       documentation and/or other materials provided with the distribution.
        #     * Neither the name of Intel Corporation nor Carnegie Mellon University,
        #       nor the names of their contributors, may be used to endorse or
        #       promote products derived from this software without specific prior
        #       written permission.
        #
        #   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
        #   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        #   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        #   ARE DISCLAIMED. IN NO EVENT SHALL INTEL CORPORATION OR CARNEGIE MELLON
        #   UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        #   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
        #   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
        #   OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
        #   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        #   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
        #   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

        # -*- coding: utf-8 -*-
        '''Rodrigues formula
        Input: 1x3 array of rotations about x, y, and z
        Output: 3x3 rotation matrix'''
        from numpy import array,mat,sin,cos,dot,eye
        from numpy.linalg import norm

        def rodrigues(r):
            def S(n):
                Sn = array([[0,-n[2],n[1]],[n[2],0,-n[0]],[-n[1],n[0],0]])
                return Sn
            theta = norm(r)
            if theta &gt; 1e-30:
                n = r/theta
                Sn = S(n)
                R = eye(3) + sin(theta)*Sn + (1-cos(theta))*dot(Sn,Sn)
            else:
                Sr = S(r)
                theta2 = theta**2
                R = eye(3) + (1-theta2/6.)*Sr + (.5-theta2/24.)*dot(Sr,Sr)
            return mat(R)
        */

<span class="fc" id="L810">        double theta = MatrixUtil.lPSum(rotVec, 2);</span>

        double[][] tmp1, tmp2;

<span class="fc bfc" id="L814" title="All 2 branches covered.">        if (theta &gt; 1e-30) {</span>

<span class="fc" id="L816">            double[] n = Arrays.copyOf(rotVec, rotVec.length);</span>
<span class="fc" id="L817">            MatrixUtil.multiply(n, 1./theta);</span>
            // [3X3]
<span class="fc" id="L819">            double[][] sn = MatrixUtil.skewSymmetric(n);</span>

            //R = eye(3) + sin(theta)*Sn + (1-cos(theta))*dot(Sn,Sn)
<span class="fc" id="L822">            tmp1 = MatrixUtil.copy(sn);</span>
            //[3X3]
<span class="fc" id="L824">            double sa = Math.sin(theta);</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">            if (!passive) {</span>
<span class="fc" id="L826">                sa *= -1;</span>
            }
<span class="fc" id="L828">            MatrixUtil.multiply(tmp1, sa);</span>

            //[3X3]
<span class="fc" id="L831">            tmp2 = MatrixUtil.multiply(sn, sn);</span>
<span class="fc" id="L832">            MatrixUtil.multiply(tmp2, 1. - Math.cos(theta));</span>

<span class="fc" id="L834">        } else {</span>

<span class="fc" id="L836">            double[][] sr = MatrixUtil.skewSymmetric(rotVec);</span>
<span class="fc" id="L837">            double theta2 = theta*theta;</span>

            //R = eye(3) + (1-theta2/6.)*Sr + (.5-theta2/24.)*dot(Sr,Sr)
<span class="fc" id="L840">            tmp1 = MatrixUtil.copy(sr);</span>
<span class="fc" id="L841">            MatrixUtil.multiply(tmp1, (1. - theta2)/6.);</span>

<span class="fc" id="L843">            tmp2 = MatrixUtil.multiply(sr, sr);</span>
<span class="fc" id="L844">            MatrixUtil.multiply(tmp2, 0.5 - theta2/24.);</span>

        }

<span class="fc" id="L848">        double[][] r = MatrixUtil.createIdentityMatrix(3);</span>

        int j;
<span class="fc bfc" id="L851" title="All 2 branches covered.">        for (int i = 0; i &lt; tmp1.length; ++i) {</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">            for (j = 0; j &lt; tmp1[i].length; ++j) {</span>
<span class="fc" id="L853">                r[i][j] += (tmp1[i][j] + tmp2[i][j]);</span>
            }
        }

<span class="fc" id="L857">        return r;</span>
    }

    public static class RodriguesRotation {
        /**
         * [3X3]
         */
        public double[][] r;

        /**
         * [9X3] or [3X9]
         * 9X3 returned for vector, else 3X9 for matrix
         */
        public double[][] dRdR;

        /**
         * [3X1]
         */
        public double[] rotVec;
    }

    /**
     * calculate the Rodrigues rotation vector from the given rotation matrix.
     * The method is ported from github repositories holding the Bouguet Matlab Toolbox code, rodrigues.m.
     *
     *      &lt;pre&gt;
     *      The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     *      and states that the source code is freely available.
     *      The github repositories with the forked Bouguet Matlab code do not have license
     *      information.
     *
     *      https://github.com/fragofer/TOOLBOX_calib
     *      and
     *      https://github.com/hunt0r/Bouguet_cam_cal_toolbox
     *
     *      rodrigues.m includes the comment: Copyright (c) March 1993 -- Pietro Perona, CalTech, before a brief
     *      changelist by Bouguet.
     *      &lt;/pre&gt;
     *      Note that this is an ambiguous task.
     * @param rotation [3X3] rotation matrix
     * @return
     */
    public static RodriguesRotation extractRotationVectorRodriguesBouguet(double[][] rotation) throws NotConvergedException {

        //[m,n] = size(rotation);
<span class="fc" id="L902">        int m = rotation.length;</span>
<span class="fc" id="L903">        int n = rotation[0].length;</span>

<span class="pc bpc" id="L905" title="2 of 4 branches missed.">        if (m != 3 || n != 3) {</span>
<span class="nc" id="L906">            throw new IllegalArgumentException(&quot;rotation dimensions must be 3 X 3&quot;);</span>
        }

<span class="fc" id="L909">        final double eps = 2.2204e-16;</span>

        //%bigeps = 10e+4*eps;
        //bigeps = 10e+20*eps;
<span class="fc" id="L913">        double bigeps = 10e20 * eps;</span>

        //norm(rotation' * rotation - eye(3)) &lt; bigeps)...
        //                &amp; (abs(det(rotation)-1) &lt; bigeps))
<span class="fc" id="L917">        double check1 = MatrixUtil.spectralNorm(</span>
<span class="fc" id="L918">                MatrixUtil.pointwiseSubtract(MatrixUtil.createATransposedTimesA(rotation),</span>
<span class="fc" id="L919">                        MatrixUtil.createIdentityMatrix(3)));</span>
<span class="fc" id="L920">        double check2 = Math.abs(MatrixUtil.determinant(rotation) - 1);</span>
<span class="pc bpc" id="L921" title="2 of 4 branches missed.">        if ((check1 &gt;= bigeps) || check2 &gt;= bigeps){</span>
<span class="nc" id="L922">            throw new IllegalArgumentException(&quot;rotation does not appear to be a rotation matrix&quot;);</span>
        }

        //R = rotation;
<span class="fc" id="L926">        double[][] R = rotation;</span>

<span class="fc" id="L928">        double det = MatrixUtil.determinant(R);</span>
        // numerical precision
<span class="fc" id="L930">        det = Math.round(det * 1E11)/1E11;</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">        if (Math.abs(det - 1) &gt; 1E-7) {</span>
            ///% project the rotation matrix to SO(3);
            //[U,S,V] = svd(R);
            //R = U*V';
<span class="nc" id="L935">            R = Rotation.orthonormalizeUsingSVD(R);</span>
<span class="nc" id="L936">            System.out.println(&quot;WARNING: expecting det(r) = 1 for proper rotation matrix&quot;);</span>
        }

        //tr = (trace(R)-1)/2;
<span class="fc" id="L940">        double tr = (MatrixUtil.trace(R) - 1)/2.;</span>
        //dtrdR = [1 0 0 0 1 0 0 0 1]/2; // [1X9]
<span class="fc" id="L942">        double[] dtrdR = new double[]{1/2., 0, 0, 0, 1/2., 0, 0, 0, 1/2.};</span>
        //theta = real(acos(tr));
<span class="fc" id="L944">        double theta = Math.acos(tr);</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        if (Double.isNaN(theta)) {</span>
<span class="nc" id="L946">            throw new IllegalArgumentException(&quot;the rotation 'rotation' is not proper?&quot;);</span>
        }

<span class="fc" id="L949">        double[] out = null;</span>
<span class="fc" id="L950">        double[][] dout = null;</span>

        //if sin(theta) &gt;= 1e-4,
<span class="fc bfc" id="L953" title="All 2 branches covered.">        if (Math.sin(theta) &gt;= 1e-4) {</span>
            //dthetadtr = -1 / sqrt(1 - tr ^ 2);
<span class="fc" id="L955">            double dthetadtr = -1./Math.sqrt(1. - tr*tr);</span>

            //dthetadR = dthetadtr * dtrdR; [1X9]
<span class="fc" id="L958">            double[] dthetadR = Arrays.copyOf(dtrdR, dtrdR.length);</span>
<span class="fc" id="L959">            MatrixUtil.multiply(dthetadR, dthetadtr);</span>

            //%var1 = [vth; theta];
            //vth = 1 / (2 * sin(theta));
<span class="fc" id="L963">            double vth = 1./(2.*Math.sin(theta));</span>
            //dvthdtheta = -vth * cos(theta) / sin(theta);
<span class="fc" id="L965">            double dvthdtheta = -vth * Math.cos(theta) / Math.sin(theta);</span>
            //dvar1dtheta = [dvthdtheta; 1]; //[2X1]  column vector
<span class="fc" id="L967">            double[] dvar1dtheta = new double[]{dvthdtheta, 1};</span>

            //dvar1dR = dvar1dtheta * dthetadR;  //[2X1][1X9] = [2X9]
<span class="fc" id="L970">            double[][] dvar1dR = MatrixUtil.outerProduct(dvar1dtheta, dthetadR);</span>

            //om1 = [R(3, 2) - R(2, 3), R(1, 3) - R(3, 1), R(2, 1) - R(1, 2)]'; // [3X1]
<span class="fc" id="L973">            double[] om1 = new double[]{R[2][1] - R[1][2], R[0][2] - R[2][0], R[1][0] - R[0][1]};</span>

            //          0 1   2  3 4 5 6  7 8
            //dom1dR = [0 0   0  0 0 1 0 -1 0; //[3 X 9]
            //          0 0  -1  0 0 0 1  0 0;
            //          0 1   0 -1 0 0 0  0 0];
<span class="fc" id="L979">            double[][] dom1dR = MatrixUtil.zeros(3, 9);</span>
<span class="fc" id="L980">            dom1dR[0][5] = 1;</span>
<span class="fc" id="L981">            dom1dR[0][7] = -1;</span>
<span class="fc" id="L982">            dom1dR[1][2] = -1;</span>
<span class="fc" id="L983">            dom1dR[1][6] = 1;</span>
<span class="fc" id="L984">            dom1dR[2][1] = 1;</span>
<span class="fc" id="L985">            dom1dR[2][3] = -1;</span>

            //%var = [om1; vth; theta];
            //dvardR = [dom1dR; dvar1dR]; //[3X9] ; [2X9] =&gt; [5X9]
<span class="fc" id="L989">            double[][] dvardR = new double[5][];</span>
<span class="fc" id="L990">            dvardR[0] = Arrays.copyOf(dom1dR[0], dom1dR[0].length);</span>
<span class="fc" id="L991">            dvardR[1] = Arrays.copyOf(dom1dR[1], dom1dR[1].length);</span>
<span class="fc" id="L992">            dvardR[2] = Arrays.copyOf(dom1dR[2], dom1dR[2].length);</span>
<span class="fc" id="L993">            dvardR[3] = Arrays.copyOf(dvar1dR[0], dvar1dR[0].length);</span>
<span class="fc" id="L994">            dvardR[4] = Arrays.copyOf(dvar1dR[1], dvar1dR[1].length);</span>

            int i;
            //%var2 = [om; theta];
            //om = vth * om1; // vth*[3X1] = [3X1]
<span class="fc" id="L999">            double[] om = Arrays.copyOf(om1, om1.length);</span>
<span class="fc" id="L1000">            MatrixUtil.multiply(om, vth);</span>
            //domdvar = [vth * eye(3) om1 zeros(3, 1)]; // [3X3] | [3X1] | [3X1] = [3 X 5]
<span class="fc" id="L1002">            double[][] tmp = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L1003">            MatrixUtil.multiply(tmp, vth);</span>
<span class="fc" id="L1004">            double[][] domdvar = MatrixUtil.zeros(3, 5);</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1006">                System.arraycopy(tmp[i], 0, domdvar[i], 0, tmp[i].length);</span>
<span class="fc" id="L1007">                domdvar[i][tmp[i].length] = om1[i];</span>
            }
            //dthetadvar = [0 0 0 0 1]; // [1X5]
<span class="fc" id="L1010">            double[] dthetadvar = new double[]{0, 0, 0, 0, 1};</span>
            //dvar2dvar = [domdvar; dthetadvar];  // [3X5] ; [1X5] =&gt; [4 X 5]
<span class="fc" id="L1012">            double[][] dvar2dvar = MatrixUtil.zeros(4, 5);</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1014">                System.arraycopy(domdvar[i], 0, dvar2dvar[i], 0, domdvar[i].length);</span>
            }
<span class="fc" id="L1016">            System.arraycopy(dthetadvar, 0, dvar2dvar[3], 0, dthetadvar.length);</span>

            //out = om * theta;
<span class="fc" id="L1019">            out = Arrays.copyOf(om, om.length);</span>
<span class="fc" id="L1020">            MatrixUtil.multiply(out, theta);</span>

            //domegadvar2 = [theta * eye(3) om]; // [3X3 | [3X1] ==&gt; [3 X 4]
<span class="fc" id="L1023">            double[][] domegadvar2 = MatrixUtil.zeros(3, 4);</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1025">                domegadvar2[i][i] = theta;</span>
<span class="fc" id="L1026">                domegadvar2[i][3] = om[i];</span>
            }

            //dout = domegadvar2 * dvar2dvar * dvardR; // [3X4] [4X5] [5X9] = [3X9]
<span class="fc" id="L1030">            dout = MatrixUtil.multiply(MatrixUtil.multiply(domegadvar2, dvar2dvar), dvardR);</span>

<span class="fc" id="L1032">        } else {</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">            if (tr &gt; 0) {</span>
                //out = [0 0 0]'; [3x1]
<span class="nc" id="L1035">                out = new double[3];</span>

                //         0 1     2    3 4   5   6    7    8
                // dout = [0 0     0    0 0  1/2   0  -1/2  0;
                //         0 0  -1/2    0 0    0 1/2     0  0;
                //         0 1/2   0 -1/2 0    0   0     0  0];

<span class="nc" id="L1042">                dout = MatrixUtil.zeros(3, 9);</span>
<span class="nc" id="L1043">                dout[0][5] = 0.5;</span>
<span class="nc" id="L1044">                dout[0][7] = -0.5;</span>
<span class="nc" id="L1045">                dout[1][2] = -0.5;</span>
<span class="nc" id="L1046">                dout[1][6] = 0.5;</span>
<span class="nc" id="L1047">                dout[2][1] = 0.5;</span>
<span class="nc" id="L1048">                dout[2][3] = -0.5;</span>

            } else {

                //% Solution by Mike Burl on Feb 27, 2007
                //% This is a better way to determine the signs of the
                //% entries of the rotation vector using a hash table on all
                //% the combinations of signs of a pairs of products (rotation the
                //% rotation matrix)

                //% Define hashvec and Smat
                //           0   1   2  3   4  5  6   7  8   9   10
                //hashvec = [0; -1; -3; -9; 9; 3; 1; 13; 5; -7; -11]; // [11 X 1]
                //            0       1       2       3      4      5      6      7      8
                //Smat = [1,1,1; 1,0,-1; 0,1,-1; 1,-1,0; 1,1,0; 0,1,1; 1,0,1; 1,1,1; 1,1,-1; //[11X 3]
                //1,-1,-1; 1,-1,1];
                //      9       10
                //      [11X1]
<span class="fc" id="L1066">                double[] hashvec = new double[]{0, -1, -3, -9, 9, 3, 1, 13, 5, -7, -11};</span>
                //      [11 X 3]
<span class="fc" id="L1068">                double[][] Smat = new double[11][];</span>
<span class="fc" id="L1069">                Smat[0] = new double[]{1, 1, 1};</span>
<span class="fc" id="L1070">                Smat[1] = new double[]{1, 0, -1};</span>
<span class="fc" id="L1071">                Smat[2] = new double[]{0, 1, -1};</span>
<span class="fc" id="L1072">                Smat[3] = new double[]{1, -1, 0};</span>
<span class="fc" id="L1073">                Smat[4] = new double[]{1, 1, 0};</span>
<span class="fc" id="L1074">                Smat[5] = new double[]{0, 1, 1};</span>
<span class="fc" id="L1075">                Smat[6] = new double[]{1, 0, 1};</span>
<span class="fc" id="L1076">                Smat[7] = new double[]{1, 1, 1};</span>
<span class="fc" id="L1077">                Smat[8] = new double[]{1, 1, -1};</span>
<span class="fc" id="L1078">                Smat[9] = new double[]{1, -1, -1};</span>
<span class="fc" id="L1079">                Smat[10] = new double[]{1, -1, 1};</span>

                // M = (R+eye(3,3))/2;
<span class="fc" id="L1082">                double[][] M = MatrixUtil.pointwiseAdd(R, MatrixUtil.createIdentityMatrix(3));</span>
<span class="fc" id="L1083">                MatrixUtil.multiply(M, 0.5);</span>

                //uabs = sqrt(M(1,1));
                //vabs = sqrt(M(2,2));
                //wabs = sqrt(M(3,3));
<span class="fc" id="L1088">                double uabs = Math.sqrt(M[0][0]);</span>
<span class="fc" id="L1089">                double vabs = Math.sqrt(M[1][1]);</span>
<span class="fc" id="L1090">                double wabs = Math.sqrt(M[2][2]);</span>

                //mvec = ([M(1,2), M(2,3), M(1,3)] + [M(2,1), M(3,2), M(3,1)])/2;
<span class="fc" id="L1093">                double[] mvec0 = new double[]{M[0][1], M[1][2], M[0][2]};</span>
<span class="fc" id="L1094">                double[] mvec1 = new double[]{M[1][0], M[2][1], M[2][0]};</span>
<span class="fc" id="L1095">                double[] mvec = MatrixUtil.add(mvec0, mvec1);</span>
<span class="fc" id="L1096">                MatrixUtil.multiply(mvec, 0.5);</span>

                //syn  = ((mvec &gt; eps) - (mvec &lt; -eps)); % robust sign() function
<span class="fc" id="L1099">                double[] syn = new double[mvec.length]; //[1X3]</span>
                double t0, t1;
                int i;
<span class="fc bfc" id="L1102" title="All 2 branches covered.">                for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">                    t0 = (mvec[i] &gt; eps) ? 1 : 0;</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">                    t1 = (mvec[i] &lt; -eps) ? 1 : 0;</span>
<span class="fc" id="L1105">                    syn[i] = t0 - t1;</span>
                }
                //hash = syn * [9; 3; 1];  [1X3][3X1]=[1X1]
<span class="fc" id="L1108">                double hash = MatrixUtil.innerProduct(syn, new double[]{9, 3, 1});</span>

                //idx = find(hash == hashvec);
                // should not need to apply an offset of 1 as they are consistent use of indexes
<span class="fc" id="L1112">                int idx = -1;</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">                for (i = 0; i &lt; hashvec.length; ++i) {</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">                    if (hash == hashvec[i]) {</span>
<span class="fc" id="L1115">                        idx = i;</span>
                    }
                }
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">                if (idx == -1) {</span>
<span class="nc" id="L1119">                    throw new IllegalStateException(&quot;ERROR: no solution found&quot;);</span>
                }
                //svec = Smat(idx,:)';
<span class="fc" id="L1122">                double[] svec = Smat[idx];</span>

                //out = theta * [uabs; vabs; wabs] .* svec; // [3X1] .* [3X1] = [3X1]
<span class="fc" id="L1125">                out = MatrixUtil.pointwiseMultiplication(new double[]{theta*uabs, theta*vabs, theta*wabs}, svec);</span>
            }
        }

<span class="fc" id="L1129">        RodriguesRotation rRot = new RodriguesRotation();</span>
<span class="fc" id="L1130">        rRot.rotVec = out;</span>
<span class="fc" id="L1131">        rRot.r = MatrixUtil.copy(rotation);</span>
<span class="fc" id="L1132">        rRot.dRdR = dout;</span>

<span class="fc" id="L1134">        return rRot;</span>
    }

    /**
     * calculate the rotation matrix given the Rodrigues rotation vector.
     * The method is ported from github repositories holding the Bouguet Matlab Toolbox code, rodrigues.m.
     *
     * this is using passive transformations.
     *
     *      &lt;pre&gt;
     *      The Bouguet toolbox webpage is currently at http://robots.stanford.edu/cs223b04/JeanYvesCalib/
     *      and states that the source code is freely available.
     *      The github repositories with the forked Bouguet Matlab code do not have license
     *      information.
     *
     *      https://github.com/fragofer/TOOLBOX_calib
     *      and
     *      https://github.com/hunt0r/Bouguet_cam_cal_toolbox
     *
     *      rodrigues.m includes the comment: Copyright (c) March 1993 -- Pietro Perona, CalTech, before a brief
     *      changelist by Bouguet.
     *
     *      &lt;/pre&gt;
     * @param rotVec [3X1] rotation vector
     * @return
     */
    public static RodriguesRotation createRotationRodriguesBouguet(double[] rotVec, boolean passive) {

<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">        if (rotVec.length != 3) {</span>
<span class="nc" id="L1163">            throw new IllegalArgumentException(&quot;rotVec length must be 3&quot;);</span>
        }

<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">        if (!passive) {</span>
<span class="nc" id="L1167">            rotVec = Arrays.copyOf(rotVec, rotVec.length);</span>
<span class="nc" id="L1168">            MatrixUtil.multiply(rotVec, -1);</span>
        }

<span class="fc" id="L1171">        final double eps = 2.2204e-16;</span>

        //[m,n] = size(rotVec);
<span class="fc" id="L1174">        int m = rotVec.length;</span>
        //int n = 1;
        //%bigeps = 10e+4*eps;
        //bigeps = 10e+20*eps;

<span class="fc" id="L1179">        double bigeps = 10e20 * eps;</span>

        double[][] R;
        double[][] dRdin;
        //theta = norm(rotVec);
<span class="fc" id="L1184">        double theta = MatrixUtil.lPSum(rotVec, 2);</span>
        //if theta &lt; eps
<span class="fc bfc" id="L1186" title="All 2 branches covered.">        if (theta &lt; eps) {</span>
            //R = eye(3);
<span class="fc" id="L1188">            R = MatrixUtil.createIdentityMatrix(3);</span>
            //dRdin = [0 0 0;
            //0 0 1;
            //0 -1 0;
            //0 0 -1;
            //0 0 0;
            //1 0 0;
            //0 1 0;
            //-1 0 0;
            //0 0 0];
<span class="fc" id="L1198">            dRdin = new double[9][];</span>
<span class="fc" id="L1199">            dRdin[0] = new double[]{0, 0, 0};</span>
<span class="fc" id="L1200">            dRdin[1] = new double[]{0, 0, 1};</span>
<span class="fc" id="L1201">            dRdin[2] = new double[]{0, -1, 0};</span>
<span class="fc" id="L1202">            dRdin[3] = new double[]{0, 0, -1};</span>
<span class="fc" id="L1203">            dRdin[4] = new double[]{0, 0, 0};</span>
<span class="fc" id="L1204">            dRdin[5] = new double[]{1, 0, 0};</span>
<span class="fc" id="L1205">            dRdin[6] = new double[]{0, 1, 0};</span>
<span class="fc" id="L1206">            dRdin[7] = new double[]{-1, 0, 0};</span>
<span class="fc" id="L1207">            dRdin[8] = new double[]{0, 0, 0};</span>

            //out = R;
            //dout = dRdin;
<span class="fc" id="L1211">            RodriguesRotation rRot = new RodriguesRotation();</span>
<span class="fc" id="L1212">            rRot.r = R;</span>
<span class="fc" id="L1213">            rRot.dRdR = dRdin;</span>
<span class="fc" id="L1214">            rRot.rotVec = Arrays.copyOf(rotVec, rotVec.length);</span>

<span class="fc" id="L1216">            return rRot;</span>
        }

        //%m3 = [rotVec,theta]

        //dm3din = [eye(3);rotVec'/theta];
<span class="fc" id="L1222">        double[][] dm3din = new double[4][]; // [4X3]</span>
<span class="fc" id="L1223">        dm3din[0] = new double[]{1, 0, 0};</span>
<span class="fc" id="L1224">        dm3din[1] = new double[]{0, 1, 0};</span>
<span class="fc" id="L1225">        dm3din[2] = new double[]{0, 0, 1};</span>
<span class="fc" id="L1226">        dm3din[3] = Arrays.copyOf(rotVec, rotVec.length);</span>
<span class="fc" id="L1227">        MatrixUtil.multiply(dm3din[3], 1./theta);</span>

        //omega = rotVec/theta;
<span class="fc" id="L1230">        double[] omega = Arrays.copyOf(dm3din[3], dm3din[3].length); // [3X1]</span>

        //%m2 = [omega;theta]

<span class="fc" id="L1234">        double invTheta = 1./theta;</span>
<span class="fc" id="L1235">        double invTheta2 = invTheta*invTheta;</span>
        //dm2dm3 = [eye(3)/theta -rotVec/theta^2; zeros(1,3) 1];// [3X3] | [3X1] ;
<span class="fc" id="L1237">        double[][] dm2dm3 = new double[4][];</span>
<span class="fc" id="L1238">        dm2dm3[0] = new double[]{1*invTheta, 0, 0, rotVec[0]*-invTheta2};</span>
<span class="fc" id="L1239">        dm2dm3[1] = new double[]{0, 1*invTheta, 0, rotVec[1]*-invTheta2};</span>
<span class="fc" id="L1240">        dm2dm3[2] = new double[]{0, 0, 1*invTheta, rotVec[2]*-invTheta2};</span>
<span class="fc" id="L1241">        dm2dm3[3] = new double[]{0, 0, 0, 1};</span>

        //alpha = cos(theta);
        //beta = sin(theta);
        //gamma = 1-cos(theta);
        //omegav=[[0 -omega(3) omega(2)];[omega(3) 0 -omega(1)];[-omega(2) omega(1) 0 ]];
        //A = omega*omega';
<span class="fc" id="L1248">        double alpha = Math.cos(theta);</span>
<span class="fc" id="L1249">        double beta = Math.sin(theta);</span>
<span class="fc" id="L1250">        double gamma = 1. - alpha;</span>
<span class="fc" id="L1251">        double[][] omegav = MatrixUtil.skewSymmetric(omega);</span>
<span class="fc" id="L1252">        double[][] A = MatrixUtil.outerProduct(omega, omega); //[3X3]</span>

        //%m1 = [alpha;beta;gamma;omegav;A];

        //dm1dm2 = zeros(21,4);
        //dm1dm2(1,4) = -sin(theta);
        //dm1dm2(2,4) = cos(theta);
        //dm1dm2(3,4) = sin(theta);
        //dm1dm2(4:12,1:3) = [0 0 0  0 0 1 0 -1 0;
        //                    0 0 -1 0 0 0 1 0 0;
        //                    0 1 0 -1 0 0 0 0 0]';
<span class="fc" id="L1263">        double[][] dm1dm2 = MatrixUtil.zeros(21, 4);</span>
<span class="fc" id="L1264">        dm1dm2[0][3] = -beta;</span>
<span class="fc" id="L1265">        dm1dm2[1][3] = alpha;</span>
<span class="fc" id="L1266">        dm1dm2[2][3] = beta;</span>
<span class="fc" id="L1267">        System.arraycopy(new double[]{0,0,0}, 0, dm1dm2[3], 0, 3);</span>
<span class="fc" id="L1268">        System.arraycopy(new double[]{0,0,1}, 0, dm1dm2[4], 0, 3);</span>
<span class="fc" id="L1269">        System.arraycopy(new double[]{0,-1,0}, 0, dm1dm2[5], 0, 3);</span>
<span class="fc" id="L1270">        System.arraycopy(new double[]{0,0,-1}, 0, dm1dm2[6], 0, 3);</span>
<span class="fc" id="L1271">        System.arraycopy(new double[]{0,0,0}, 0, dm1dm2[7], 0, 3);</span>
<span class="fc" id="L1272">        System.arraycopy(new double[]{1,0,0}, 0, dm1dm2[8], 0, 3);</span>
<span class="fc" id="L1273">        System.arraycopy(new double[]{0,1,0}, 0, dm1dm2[9], 0, 3);</span>
<span class="fc" id="L1274">        System.arraycopy(new double[]{-1,0,0}, 0, dm1dm2[10], 0, 3);</span>
<span class="fc" id="L1275">        System.arraycopy(new double[]{0,0,0}, 0, dm1dm2[11], 0, 3);</span>

        //w1 = omega(1);
        //w2 = omega(2);
        //w3 = omega(3);
<span class="fc" id="L1280">        double w1 = omega[0];</span>
<span class="fc" id="L1281">        double w2 = omega[1];</span>
<span class="fc" id="L1282">        double w3 = omega[2];</span>
        //dm1dm2(13:21,1) = [2*w1;w2;w3;w2;0;0;w3;0;0];
        //dm1dm2(13: 21,2) = [0;w1;0;w1;2*w2;w3;0;w3;0];
        //dm1dm2(13:21,3) = [0;0;w1;0;0;w2;w1;w2;2*w3];
        int i;
<span class="fc" id="L1287">        double[] c0 = new double[]{2*w1,w2,w3,w2,0,0,w3,0,0};</span>
<span class="fc" id="L1288">        double[] c1 = new double[]{0,w1,0,w1,2*w2,w3,0,w3,0};</span>
<span class="fc" id="L1289">        double[] c2 = new double[]{0,0,w1,0,0,w2,w1,w2,2*w3};</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">        for (i = 12; i &lt;= 20; ++i) {</span>
<span class="fc" id="L1291">            dm1dm2[i][0] = c0[i - 12];</span>
<span class="fc" id="L1292">            dm1dm2[i][1] = c1[i - 12];</span>
<span class="fc" id="L1293">            dm1dm2[i][2] = c2[i - 12];</span>
        }

        //R = eye(3)*alpha + omegav*beta + A*gamma; // [3X3] + [3X3] + [3X3]
<span class="fc" id="L1297">        R = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L1298">        MatrixUtil.multiply(R, alpha);</span>
<span class="fc" id="L1299">        double[][] t1 = MatrixUtil.copy(omegav);</span>
<span class="fc" id="L1300">        MatrixUtil.multiply(t1, beta);</span>
<span class="fc" id="L1301">        double[][] t2 = MatrixUtil.copy(A);</span>
<span class="fc" id="L1302">        MatrixUtil.multiply(t2, gamma);</span>
<span class="fc" id="L1303">        R = MatrixUtil.pointwiseAdd(R, t1);</span>
<span class="fc" id="L1304">        R = MatrixUtil.pointwiseAdd(R, t2);</span>

        //dRdm1 = zeros(9,21);
        //dRdm1([1 5 9],1) = ones(3,1);
        //dRdm1(:,2) = omegav(:);
        //dRdm1(:,4:12) = beta*eye(9);
        //dRdm1(:,3) = A(:);
        //dRdm1(:,13:21) = gamma*eye(9);
<span class="fc" id="L1312">        double[][] dRdm1 = MatrixUtil.zeros(9, 21);</span>
<span class="fc" id="L1313">        dRdm1[0][0] = 1;</span>
<span class="fc" id="L1314">        dRdm1[4][0] = 1;</span>
<span class="fc" id="L1315">        dRdm1[8][0] = 1;</span>
<span class="fc" id="L1316">        double[] omegavStack = MatrixUtil.stack(omegav);</span>
<span class="fc" id="L1317">        double[][] iB = MatrixUtil.createIdentityMatrix(9);</span>
<span class="fc" id="L1318">        MatrixUtil.multiply(iB, beta);</span>
<span class="fc" id="L1319">        double[] AStack = MatrixUtil.stack(A);</span>
<span class="fc" id="L1320">        double[][] iG = MatrixUtil.createIdentityMatrix(9);</span>
<span class="fc" id="L1321">        MatrixUtil.multiply(iG, gamma);</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        for (i = 0; i &lt; dRdm1.length; ++i) {</span>
<span class="fc" id="L1323">            dRdm1[i][1] = omegavStack[i];</span>
<span class="fc" id="L1324">            dRdm1[i][2] = AStack[i];</span>
<span class="fc" id="L1325">            System.arraycopy(iB[i], 0, dRdm1[i], 3, iB[i].length);</span>
<span class="fc" id="L1326">            System.arraycopy(iG[i], 0, dRdm1[i], 12, iG[i].length);</span>
        }

        //dRdin = dRdm1 * dm1dm2 * dm2dm3 * dm3din;
        //        [9X21]  [21X4]  [4X4]     [4X3] = [9X3]
<span class="fc" id="L1331">        dRdin = MatrixUtil.multiply(dRdm1, dm1dm2);</span>
<span class="fc" id="L1332">        dRdin = MatrixUtil.multiply(dRdin, dm2dm3);</span>
<span class="fc" id="L1333">        dRdin = MatrixUtil.multiply(dRdin, dm3din);</span>

<span class="fc" id="L1335">        RodriguesRotation rRot = new RodriguesRotation();</span>
<span class="fc" id="L1336">        rRot.r = R;</span>
<span class="fc" id="L1337">        rRot.dRdR = dRdin;</span>
<span class="fc" id="L1338">        rRot.rotVec = Arrays.copyOf(rotVec, rotVec.length);</span>

<span class="fc" id="L1340">        return rRot;</span>
    }
    
    /**
     * determine the rotation between measurements x1 and x2 when both datasets
     * have the same center, that is, there is no translation between them,
     * only rotation.
     * (see Golub &amp; van Loan &quot;Matrix Computations&quot; 11.12.4,
     * Szeliski 2010, Sect 6.1.5).
     * @param x1 a set of measurements having same center as x2, that is,
     * there is no translation between them, only rotation.
     * the expected format is nData X nDimensions.
     * @param x2 another set of measurements having same center as x1, that is,
     * there is no translation between them, only rotation.
     * the expected format is nData X nDimensions.
     * @return difference in rotation between x2 and x1.  this will be ~ the identity matrix for no difference.
     * @throws no.uib.cipr.matrix.NotConvergedException
    */
    public static double[][] procrustesAlgorithmForRotation(double[][] x1, double[][] x2) 
        throws NotConvergedException {
<span class="fc" id="L1360">        int m = x1.length;</span>
<span class="fc" id="L1361">        int p = x1[0].length;</span>
<span class="pc bpc" id="L1362" title="2 of 4 branches missed.">        if (x2.length != m || x2[0].length != p) {</span>
<span class="nc" id="L1363">            throw new IllegalArgumentException(&quot;x1 and x2 must have same sizes&quot;);</span>
        }
        // minimize || x1 - x2*Q ||_F
        //    subject to Q^T * Q = I_P
<span class="fc" id="L1367">        double[][] c = MatrixUtil.multiply(MatrixUtil.transpose(x2), x1);</span>
<span class="fc" id="L1368">        MatrixUtil.SVDProducts svdC = MatrixUtil.performSVD(c);</span>

<span class="fc" id="L1370">        double[][] q = MatrixUtil.multiply(svdC.u, svdC.vT);</span>
<span class="fc" id="L1371">        return q;</span>
    }
    
    /**
     * extract the euler rotation angles from the given rotation matrix assumed
     * to be a result of R_yxz = R_z(theta_z) * R_x(theta_x) * R_y(theta_y)
     * (aka 2-1-3 angle set?).
     * Note, this way of extracting of the angles is 
     * ambiguous (there are more than one angle combination sets that will
       result in the same matrix).
     &lt;pre&gt;
     the method is from equation (37) from 
     lecture notes of Gordon Wetzstein at Stanford University,
     EE 267 Virtual Reality, &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
     https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf

     It uses the passive, right-hand, CCW transformations system.

     &lt;/pre&gt;
     * @param r  rotation matrix assumed
     * to be a result of R_yxz = R_z(theta_z)  * R_x(theta_x) * R_y(theta_y).
     * @return theta_x, theta_y, theta_z
     * which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]
     */
    public static double[] extractRotationAxisFromZXY(double[][] r) {
<span class="pc bpc" id="L1396" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1397">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }
<span class="fc" id="L1399">        double thetaX = Math.asin(r[2][1]);</span>
<span class="fc" id="L1400">        double thetaY = Math.atan2(-r[2][0], r[2][2]);</span>
<span class="fc" id="L1401">        double thetaZ = Math.atan2(-r[0][1], r[1][1]);</span>
<span class="fc" id="L1402">        return new double[]{thetaX, thetaY, thetaZ};</span>
    }
    
    /**
     * extract euler rotation angles from a rotation matrix which has been built following
     * the convention of R_xyz =  R(theta_Z) * R(theta_Y) * R(theta_X)
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     * @param r ZYX rotation matrix
     * @return array of theta_x, theta_y, theta_z
     * which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]
     */
    public static double[] extractThetaFromZYX(double[][] r) {
<span class="pc bpc" id="L1414" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1415">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }
<span class="fc" id="L1417">        double[] out = new double[3];</span>
<span class="fc" id="L1418">        extractThetaFromZYX(r, out);</span>
<span class="fc" id="L1419">        return out;</span>
    }

    /**
     *
     * @param r ZYX rotation matrix
     * @param passive
     @return array of theta_x, theta_y, theta_z
     which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]

     */
    public static double[] extractThetaFromZYX(double[][] r, boolean passive) {
<span class="fc" id="L1431">        double[] thetas = extractThetaFromZYX(r);</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">        if (!passive) MatrixUtil.multiply(thetas, -1);</span>
<span class="fc" id="L1433">        return thetas;</span>
    }
    
    /**
     * extract euler rotation angles from a rotation matrix which has been built following
     * the convention of R(theta_Z) * R(theta_Y) * R(theta_X).
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     * @param r
     * @param out output variable to hold theta_x, theta_y, and theta_z,
     * which, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]
     */
    public static void extractThetaFromZYX(double[][] r, double[] out) {
<span class="pc bpc" id="L1445" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1446">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }
        /*
        using euler angles
          cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  

        = | (cos φ * cos ψ)   (-sin φ)   (cos φ * sin ψ) |  * | 1       0       0 |
          | (sin φ * cos ψ)   ( cos φ)   (sin φ * sin ψ) |    | 0   cos θ   sin θ |
          | (-sin ψ)          (   0  )   (   cos ψ )     |    | 0  -sin θ   cos θ |

        = | (cos Z * cos Y)   (-sin Z * cos X + cos Z * sin Y * sin X)   ( sin Z * sin X + cos Z * sin Y * cos X) |
          | (sin Z * cos Y)   ( cos Z * cos X + sin Z * sin Y * sin X)   (-cos Z * sin X + sin Z * sin Y * cos X)  |
          | (-sin Y)          ( cos Y * sin X )                          (cos Y * cos X)                          |

        r20 = -sin ψ  ==&gt; ψ = theta_y = -Math.asin(r20)
        r21/r22 = ( cos ψ * sin θ )/(cos ψ * cos θ) = (sin θ)/(cos θ) = tan(θ) ==&gt; θ = theta_x = Math.atan2(r21, r22)
        r10/r00 = (sin φ * cos ψ) / (cos φ * cos ψ) = Math.atan2(r10, r00)
        */
        
        //        θ      ψ       φ
        double thetaX, thetaY, thetaZ;
        
        //ψ
<span class="fc" id="L1472">        double d = r[2][1]*r[2][1] + r[2][2]*r[2][2];</span>
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">        if (d == 0) {</span>
<span class="nc" id="L1474">            thetaY = -Math.asin(r[2][0]);</span>
        } else {
            // Y = atan( -r[2][0] / sqrt(r[2][1]*r[2][1] + r[2][2]*r[2][2]) )
            //         (  +sin Y  / sqrt( (cosY)^2 * (sinX)^2 + (cosY)^2 * (cosX)^2 )
            //         (  +sin Y  / sqrt( (cosY)^2 * 1 )
<span class="fc" id="L1479">            thetaY = Math.atan2(-r[2][0], Math.sqrt(d));</span>
        }
        
        //θ
<span class="fc" id="L1483">        thetaZ = Double.NEGATIVE_INFINITY;</span>
<span class="pc bpc" id="L1484" title="1 of 2 branches missed.">        if (r[2][2] != 0) {</span>
<span class="fc" id="L1485">            thetaX = Math.atan2(r[2][1], r[2][2]);</span>
        } else {
            // cos ψ==0 or/and cos θ==0
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            if (r[2][1] != 0) {</span>
                // then cos ψ != 0  and cos θ==0
<span class="nc" id="L1490">                thetaX = Math.asin(r[2][1]/Math.cos(thetaY));</span>
            } else {
                // else cos ψ == 0 and possibly cos θ==0
                // need thetaZ solved
<span class="nc bnc" id="L1494" title="All 2 branches missed.">                if (r[0][0] != 0) {</span>
<span class="nc" id="L1495">                    thetaZ = Math.atan2(r[1][0], r[0][0]);</span>
                    //CALC θ(thetaX), knowing φ(thetaZ) and ψ(thetaY)
<span class="nc" id="L1497">                    double cPsi = Math.cos(thetaY);</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">                    if (cPsi != 0) {</span>
                        // can use r[2][1] or r[2][2] for simplest:
<span class="nc" id="L1500">                        thetaX = Math.asin(r[2][1]/cPsi);</span>
                    } else {
                        // can use r[0][1], r[0][2], r[1][1], or r[1][2] or combination
                        /*r[0][1] = (-sφ * cos θ + cφ * sψ * sin θ)
                          r[0][2] =  (sφ * sin θ + cφ * sψ * cos θ)
                          r[1][1] = ( cφ * cos θ + sφ * sψ * sin θ)
                          r[1][2] = (-cφ * sin θ + sφ * sψ * cos θ)
                        
                        looking for ways to factor one or more of the 4 equations for the 1 unknown θ
                        rewritten:
                        r[0][1] = cos θ * -sφ      +  sin θ * cφ * sψ 
                        r[0][2] = cos θ * cφ * sψ  +  sin θ * sφ
                        r[1][1] = cos θ * cφ       +  sin θ * sφ * sψ 
                        r[1][2] = cos θ * sφ * sψ  +  sin θ * -cφ
                        add all   : cos θ * (-sφ + cφ * sψ + cφ + sφ * sψ) + sin θ * (cφ * sψ + sφ + sφ * sψ + -cφ)
                        rewritten : cos θ * (cφ - sφ + (cφ * sψ) + (sφ * sψ)) + sin θ * (-cφ + sφ + (cφ * sψ) + (sφ * sψ))
                                  : cos θ * (cφ - sφ + (cφ * sψ) + (sφ * sψ)) + sin θ * (-cφ + sφ + (cφ * sψ) + (sφ * sψ))
                        let a1 = (cφ * sψ) + (sφ * sψ)
                        let a0 = cφ - sφ
                                  : cos θ * (a0 + a1) + sin θ * (-a0 + a1)
                                  : a0*(cos θ - sin θ) + a1*(cos θ + sin θ)
                                  : a0*cosθ - a0*sinθ + a1*cosθ + a1*sinθ
                        
                        squared:  (a0*cosθ - a0*sinθ + a1*cosθ + a1*sinθ)*(a0*cosθ - a0*sinθ + a1*cosθ + a1*sinθ)
                                  = a0^2*(cosθ)^2 - a0^2*cosθ*sinθ + a0*a1*(cosθ)^2 + a0*a1*cosθ*sinθ
                                    - a0^2*cosθ*sinθ + a0^2*(sinθ)^2 - a0*a1*cosθ*sinθ - a0*a1*(sinθ)^2
                                    + aθ*a1*(cosθ)^2 - a0*a1*cosθ*sinθ + a1^2*(cosθ)^2 + a1^2*cosθ*sinθ
                                    + a0*a1*cosθ*sinθ - a0*a1*(sinθ)^2 + a1^2*cosθ*sinθ + a1^2*(sinθ)^2
                                  = a0^2*(cosθ)^2 + a0^2*(sinθ)^2
                                    + a1^2*(cosθ)^2 + a1^2*(sinθ)^2
                                    - a0^2*cosθ*sinθ - a0^2*cosθ*sinθ
                                    + a0*a1*(cosθ)^2 + aθ*a1*(cosθ)^2 - a0*a1*(sinθ)^2 - a0*a1*(sinθ)^2
                                    + a0*a1*cosθ*sinθ - a0*a1*cosθ*sinθ + a0*a1*cosθ*sinθ - a0*a1*cosθ*sinθ 
                                    + a1^2*cosθ*sinθ + a1^2*cosθ*sinθ
                                  = a0^2 + a1^2
                                    - 2*a0^2*( cosθ*sinθ )               &lt;==== sin(2x) = 2 sin(x) cos(x)
                                    + 2*a0*a1*( (cosθ)^2 - (sinθ)^2 )    &lt;==== cos(2x) = cos2(x) – sin2(x)
                                    + 2*a1^2*( cosθ*sinθ )
                                  = a0^2 + a1^2
                                     - a0^2*sin(2θ) + a1^2*sin(2θ) + 2*a0*a1*cos(2θ)
                                  = a0^2 + a1^2 - sin(2θ)*( a0^2 - a1^2 ) + cos(2θ) * ( 2*a0*a1 )
                        */
<span class="nc" id="L1542">                        throw new UnsupportedOperationException(&quot;There are &quot;</span>
                                + &quot;0's in the rotation matrix, so factoring of &quot;
                                + &quot;more than one exponential variable is needed.&quot;
                                + &quot;This case is not yet implemented.&quot;);
                    }
<span class="nc" id="L1547">                } else {</span>
                    /*
                    need φ, missing θ, knowing ψ
                    r[0][1] : (-sin φ * cos θ + cos φ * sψ * sin θ)
                    r[0][2] : ( sin φ * sin θ + cos φ * sψ * cos θ)
                    r[1][2] : (-cos φ * sin θ + sin φ * sψ * cos θ)
                    ==&gt; 2 unknowns and 3 equations.
                    */
<span class="nc" id="L1555">                    throw new UnsupportedOperationException(&quot;There are &quot;</span>
                                + &quot;0's in the rotation matrix, so factoring of &quot;
                                + &quot;more than one exponential variable is needed.&quot;
                                + &quot;This case is not yet implemented.&quot;);
                }
            }
        }
        
        //φ
<span class="pc bpc" id="L1564" title="1 of 2 branches missed.">        if (thetaZ == Double.NEGATIVE_INFINITY) {</span>
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">            if (r[0][0] != 0) {</span>
<span class="fc" id="L1566">                thetaZ = Math.atan2(r[1][0], r[0][0]);</span>
            } else {
                /* if r[0][0]==0, then so are r[1][0], r[2][1], r[2][2].
                 have θ and ψ
                r[0][1] : (-sin φ * cθ + cos φ * sψ * sθ)
                r[0][2] : ( sin φ * sθ + cos φ * sψ * cθ)
                r[1][2] : (-cos φ * sθ + sin φ * sψ * cθ)
                ==&gt; 1 unknown and 3 equations
                */
<span class="nc" id="L1575">                throw new UnsupportedOperationException(&quot;There are &quot;</span>
                                + &quot;0's in the rotation matrix, so factoring of &quot;
                                + &quot;more than one exponential variable is needed.&quot;
                                + &quot;This case is not yet implemented.&quot;);
            }
        }
        
<span class="fc" id="L1582">        out[0] = thetaX;</span>
<span class="fc" id="L1583">        out[1] = thetaY;</span>
<span class="fc" id="L1584">        out[2] = thetaZ;</span>
<span class="fc" id="L1585">    }</span>
    
    /**
     * extract euler rotation angles from a rotation matrix which has been built following
     * the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     * @param r
     * @return euler [theta_X, theta_Y, theta_Z] angles extracted from the rotation matrix under assumption
     * that the rotation matrix was constructed with multiplication order
     * R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
     * theta_x, theta_y, and theta_z, respectively have ranges [0, 2*pi], [0, pi], and [0, 2*pi]
     */
    public static double[] extractThetaFromXYZ(double[][] r) {
<span class="pc bpc" id="L1598" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1599">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }
<span class="fc" id="L1601">        double[] out = new double[3];</span>
<span class="fc" id="L1602">        extractThetaFromXYZ(r, out);</span>
<span class="fc" id="L1603">        return out;</span>
    }

    /**
     * extract the euler angles from the XYZ rotation matrix
     * @param r
     * @param passive
     * @return Euler angles in order X, Y, Z
     */
    public static double[] extractThetaFromXYZ(double[][] r, boolean passive) {
<span class="pc bpc" id="L1613" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1614">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }
<span class="fc" id="L1616">        double[] thetas = extractThetaFromXYZ(r);</span>
<span class="fc bfc" id="L1617" title="All 2 branches covered.">        if (!passive) MatrixUtil.multiply(thetas, -1);</span>
<span class="fc" id="L1618">        return thetas;</span>
    }


    
    /**
     * extract euler rotation angles from a rotation matrix which has been built following
     * the convention of R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     * @param r
     * @param out output array of size 3 used to place euler angles extracted 
     * from the rotation matrix under assumption
     * that the rotation matrix was constructed with multiplication order
     * R_X(theta_X) * R_Y(theta_Y) * R_Z(theta_Z).
     */
    public static void extractThetaFromXYZ(double[][] r, double[] out) {
<span class="pc bpc" id="L1634" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1635">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }
        /*
        using euler angles and passive (RH) system
          cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  

        from Appendix A of 
        &quot;Euler Angles and Quaternions and Transformations&quot;, NASA Mission Planning
         and Analysis Division, 1977, Shuttle Program.
        
        R_X(theta_X)*R_Y(theta_Y)*R_Z(theta_Z) 
        = |  cosY*cosZ                      -cosY*sinZ                    sinY       |
          |  sinX*sinY*cosZ + cosX*sinZ     -sinX*sinY*sinZ + cosX*cosZ   -sinX*cosY |
          |  -cosX*sinY*cosZ + sinX*sinZ     cosX*sinY*sinZ + sinX*cosZ   cosX*cosY  |
        
        q1 = -sin(X/2)*sin(Y/2)*sin(Z/2) + cos(X/2)*cos(Y/2)*cos(Z/2)
        q2 =  sin(X/2)*cos(Y/2)*cos(Z/2) + sin(Y/2)*sin(Z/2)*cos(X/2)
        q3 = -sin(X/2)*sin(Z/2)*cos(Y/2) + sin(Y/2)*cos(X/2)*cos(Z/2)
        q4 =  sin(X/2)*sin(Y/2)*cos(Z/2) + sin(Z/2)*cos(X/2)*cos(Y/2)
        
        X = theta1 = math.atan2(-r[1][2], r[2][2])
        Y = theta2 = math.atan2( r[0][2], sqrt(1 - r[0][2]*r[0][2]) )
        Z = theta3 = math.atan2(-r[0][1], r[0][0])        
        */
        //        θ      ψ       φ
        double thetaX, thetaY, thetaZ;
        
<span class="pc bpc" id="L1665" title="1 of 2 branches missed.">        if (r[2][2] != 0) {</span>
<span class="fc" id="L1666">            thetaX = Math.atan2(-r[1][2], r[2][2]);</span>
        } else {
<span class="nc" id="L1668">            throw new UnsupportedOperationException(&quot;There are &quot;</span>
                                + &quot;0's in the rotation matrix, so factoring of &quot;
                                + &quot;more than one exponential variable is needed.&quot;
                                + &quot;This case is not yet implemented.&quot;);
        }
        
<span class="fc" id="L1674">        double d = 1. - r[0][2]*r[0][2];</span>
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">        if (d != 0) {</span>
<span class="fc" id="L1676">            thetaY = Math.atan2( r[0][2], Math.sqrt(1. - r[0][2]*r[0][2]) );</span>
        } else {
<span class="nc" id="L1678">            throw new UnsupportedOperationException(&quot;There are &quot;</span>
                                + &quot;0's in the rotation matrix, so factoring of &quot;
                                + &quot;more than one exponential variable is needed.&quot;
                                + &quot;This case is not yet implemented.&quot;);
        }
    
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">        if (r[0][0] != 0) {</span>
<span class="fc" id="L1685">            thetaZ = Math.atan2(-r[0][1], r[0][0]);</span>
        } else {
<span class="nc" id="L1687">            throw new UnsupportedOperationException(&quot;There are &quot;</span>
                                + &quot;0's in the rotation matrix, so factoring of &quot;
                                + &quot;more than one exponential variable is needed.&quot;
                                + &quot;This case is not yet implemented.&quot;);
        }
    
<span class="fc" id="L1693">        out[0] = thetaX;</span>
<span class="fc" id="L1694">        out[1] = thetaY;</span>
<span class="fc" id="L1695">        out[2] = thetaZ;</span>
        
<span class="fc" id="L1697">    }</span>

    /**
     * another method to extract the Rodrigues vector (angle and axis)
     * from the given
     * rotation matrix.  it's an ambiguous task.
     *
     * The rotations are by default passive transformations.

     &lt;pre&gt;
     the method is from  
     lecture notes of Pradit Mittrapiyanuruk at Perdue University,
     ECE 661 Robot Vision Laboratory,
     https://engineering.purdue.edu/kak/computervision/ECE661_Fall2012/homework/hw5_LM_handout.pdf
     &lt;/pre&gt;
     * @param r rotation matrix
     * @return Rodriques vector.  the axis and angle representation from this
     * can be constructed as angle of rotation = r_vec/||r_vec|| and angle = ||r_vec||
     * where r_vec is the rodrigues vector.
     */
    public static double[] extractRotationVectorRodrigues(double[][] r) throws NotConvergedException {
<span class="pc bpc" id="L1718" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L1719">            throw new IllegalArgumentException(&quot;r must be 3x3&quot;);</span>
        }

<span class="fc" id="L1722">        double det = MatrixUtil.determinant(r);</span>
        // numerical precision
<span class="fc" id="L1724">        det = Math.round(det * 1E11)/1E11;</span>
<span class="fc bfc" id="L1725" title="All 2 branches covered.">        if (Math.abs(det - 1) &gt; 1E-7) {</span>
            //% project the rotation matrix to SO(3);
            //[U,S,V] = svd(R);
            //R = U*V';
<span class="fc" id="L1729">            r = Rotation.orthonormalizeUsingSVD(r);</span>
<span class="fc" id="L1730">            System.out.println(&quot;WARNING: expecting det(r) = 1 for proper rotation matrix&quot;);</span>
        }

        /*
        https://github.com/robEllenberg/comps-plugins/blob/master/python/rodrigues.py
        compare to:
        def rodrigues(r):
            def S(n):
                Sn = array([[0,-n[2],n[1]],[n[2],0,-n[0]],[-n[1],n[0],0]])
                return Sn
            theta = norm(r)
            if theta &gt; 1e-30:
                n = r/theta
                Sn = S(n)
                R = eye(3) + sin(theta)*Sn + (1-cos(theta))*dot(Sn,Sn)
            else:
                Sr = S(r)
                theta2 = theta**2
                R = eye(3) + (1-theta2/6.)*Sr + (.5-theta2/24.)*dot(Sr,Sr)
            return mat(R)
        */

<span class="fc" id="L1752">        double tol = 1.e-7;</span>
        
<span class="fc" id="L1754">        double traceR = MatrixUtil.trace(r);</span>
<span class="fc" id="L1755">        System.out.printf(&quot;trace(R)=%.3e\n&quot;, traceR);</span>
        
        int i;
        
<span class="fc bfc" id="L1759" title="All 2 branches covered.">        if ((traceR + 1) &lt; tol ) {</span>
            // trace(R) == -1, and theta = Math.PI
            /*
            http://www2.ece.ohio-state.edu/~zhang/RoboticsClass/docs/LN3_RotationalMotion.pdf
            
            w is the unit vector representing the axis of rotation.
            w is one of the following 3:
            
                (1./Math.sqrt(2.*(1.+r[2][2]))) * [r[0][2], r[1][2], 1 + r[2][2]]
            or  (1./Math.sqrt(2.*(1.+r[1][1]))) * [r[0][1], 1 + r[1][1], r[2][1]]
            or  (1./Math.sqrt(2.*(1.+r[0][0]))) * [1 + r[0][0], r[1][0], r[2][0]]
            */
<span class="fc" id="L1771">            double t1 = (1./Math.sqrt(2.*(1.+r[2][2])));</span>
<span class="fc" id="L1772">            double[] w = new double[3];</span>
<span class="fc" id="L1773">            w[0] = t1 * r[0][2];</span>
<span class="fc" id="L1774">            w[1] = t1 * r[1][2];</span>
<span class="fc" id="L1775">            w[2] = t1 * (1. + r[2][2]);</span>
<span class="fc" id="L1776">            return w;</span>
        }
        
        /*
        theta=acos((trace(R)-1)/2);
        w=(theta/(2*sin(theta)))*[R(3,2)-R(2,3); R(1,3)-R(3,1); R(2,1)-R(1,2)];
        wx=w(1);
        wy=w(2);
        wz=w(3);
        */
        
        // theta in range [0, Math.PI)
        // Math.acos argument must be &gt;= 0 and &lt;= 1
        // precision errors possibly result in &gt; 1 so rounding here assuming machine precision 1E-11
<span class="fc" id="L1790">        double arg = Math.round(0.5*(traceR - 1.)*1E11)/1E11;</span>
<span class="fc" id="L1791">        double theta = Math.acos(arg);</span>
        
        // but // http://www2.ece.ohio-state.edu/~zhang/RoboticsClass/docs/LN3_RotationalMotion.pdf
        // use t1 without theta factor:
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">        double t1 = (theta == 0) ? 1 : 0.5*theta/Math.sin(theta);</span>
<span class="fc" id="L1796">        double[] w = new double[3];</span>
<span class="fc" id="L1797">        w[0] = t1*(r[2][1] - r[1][2]);</span>
<span class="fc" id="L1798">        w[1] = t1*(r[0][2] - r[2][0]);</span>
<span class="fc" id="L1799">        w[2] = t1*(r[1][0] - r[0][1]);</span>

<span class="fc" id="L1801">        return w;</span>
    }
    
    /**
    calculate the distance metric between quaternions, using vector inner product
    &lt;pre&gt;
    eqn (19) of J Math Imaging Vis (2009) 35: 155–164 DOI 10.1007/s10851-009-0161-2
    Metrics for 3D Rotations: Comparison and Analysis Du Q. Huynh
    &lt;/pre&gt;
     * @param q1 a quaternion
     * @param q2 another quaternion
     * @return distance metric between 2 quaternions.  the range of 
     * values will be [0,π/2] (radians).
     */
    public static double distanceBetweenQuaternions(double[] q1, double[] q2) {
<span class="nc" id="L1816">        double p = Math.abs(MatrixUtil.innerProduct(q1, q2));</span>
<span class="nc" id="L1817">        double d = Math.acos(p);</span>
<span class="nc" id="L1818">        return d;</span>
    }

    /**
     * estimate the
     * &lt;pre&gt;
     *     reference:
     *     Huynh 2009, J Math Imaging Vis, 35, 155-164, eqn (21)
     * &lt;/pre&gt;
     * @param r1 a 3X3 rotation matrix
     * @param r2 a 3X3 rotation matrix
     * @param useFrobenius if true, uses Frobenius norm internally, else uses the spectral norm.
     * @return return the distance defined as ∥ I − r1 * r2 ∥_F if useFrobenius is true.
     * In that case the distance is within the range [0, 2sqrt(2)].
     * If useFrobenius is false, the result is spectralNorm(I − r1 * r2) which results in a distance in the range [0, 2].
     */
    public static double distanceUsingRigidBodyDisplacements(double[][] r1, double[][] r2, boolean useFrobenius) throws NotConvergedException {

<span class="nc bnc" id="L1836" title="All 4 branches missed.">        if (r1.length != 3 || r1[0].length != 3) {</span>
<span class="nc" id="L1837">            throw new IllegalArgumentException(&quot;r1 must be 3X3&quot;);</span>
        }
<span class="nc bnc" id="L1839" title="All 4 branches missed.">        if (r2.length != 3 || r2[0].length != 3) {</span>
<span class="nc" id="L1840">            throw new IllegalArgumentException(&quot;r2 must be 3X3&quot;);</span>
        }
        //Φ5(R1,R2)= ∥I−R1R2∥F,
<span class="nc" id="L1843">        double[][] t = MatrixUtil.multiply(r1, r2);</span>
<span class="nc" id="L1844">        t = MatrixUtil.pointwiseSubtract(MatrixUtil.createIdentityMatrix(3), t);</span>
<span class="nc bnc" id="L1845" title="All 2 branches missed.">        if (useFrobenius) {</span>
<span class="nc" id="L1846">            return MatrixUtil.frobeniusNorm(t);</span>
        }
<span class="nc" id="L1848">        return MatrixUtil.spectralNorm(t);</span>
    }
    
    /*
    calculate the distance measure between 2 Euclidean transformations of the
    given quaternions, using vector inner product.
    &lt;pre&gt;
    eqn (20) of J Math Imaging Vis (2009) 35: 155–164 DOI 10.1007/s10851-009-0161-2
    Metrics for 3D Rotations: Comparison and Analysis Du Q. Huynh
    &lt;/pre&gt;
     * @param q1 a quaternion
     * @param q2 another quaternion
     * @return the distance measure between two Euclidean transformations.  the range of 
     * values will be [0, 1] (radians).
     */
    /*public static double distanceBetweenQuaternionEuclideanTransformations(double[] q1, double[] q2) {
        double p = Math.abs(MatrixUtil.innerProduct(q1, q2));
        return 1 - p;
    }*/
    
    /**
     * given a quaternion of Barfoot format [vector scalar], form the left-hand compound operator
     * (symbol is superscript +)
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (2):
     * given q = 4X1 column vector of [eps eta] where eta is the scalar,
     * and &quot;1&quot; is a 3X3 identity matrix, also written as I_3.
     * and [eps]_x is the skew-symetric matrix for vector eps.
     * 
     * The left-hand compound operator is a 4X4 matrix:
     * 
     * q^+ = [ eta*I_3-[eps]_x   eps ]  // | [3X3]  [3X1] |
     *       [ -eps^T           eta ]   // | [1X3]  [1X1] |
     * 
     * multiplication of quaternions, u and v, which is typically written 
     * as u ⊗ v may be written equivalently as either
         u^+ v or v^⨁ u,
     * &lt;/pre&gt;
     * @param quaternion 4X1 column vector of [eps eta] where eta is the scalar
     * @return 
     */
    public static double[][] quaternionLefthandCompoundOperator(double[] quaternion) {
<span class="pc bpc" id="L1893" title="1 of 2 branches missed.">        if (quaternion.length != 4) {</span>
<span class="nc" id="L1894">            throw new IllegalArgumentException(&quot;quaternion must be length 4&quot;);</span>
        }
<span class="fc" id="L1896">        double[] eps = Arrays.copyOfRange(quaternion, 0, 3);</span>
<span class="pc bnc" id="L1897" title="All 2 branches missed.">        assert(eps.length == 3);</span>
<span class="fc" id="L1898">        double eta = quaternion[3];</span>
        
<span class="fc" id="L1900">        double[][] minusSkewEps = MatrixUtil.skewSymmetric(eps);</span>
<span class="fc" id="L1901">        MatrixUtil.multiply(minusSkewEps, -1);</span>
        
<span class="fc" id="L1903">        double[][] i3Eta = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L1904">        MatrixUtil.multiply(i3Eta, eta);</span>
        
        // 3X3
<span class="fc" id="L1907">        double[][] block00 = MatrixUtil.pointwiseAdd(i3Eta, minusSkewEps);</span>
        
<span class="fc" id="L1909">        double[][] lhc = MatrixUtil.zeros(4, 4);</span>
        int i;
<span class="fc bfc" id="L1911" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1912">            System.arraycopy(block00[i], 0, lhc[i], 0, 3);</span>
<span class="fc" id="L1913">            lhc[i][3] = eps[i];</span>
        }
<span class="fc bfc" id="L1915" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1916">            lhc[3][i] = -eps[i];</span>
        }
<span class="fc" id="L1918">        lhc[3][3] = eta;</span>
        
<span class="fc" id="L1920">        return lhc;</span>
    }
    
    /**
     * given a quaternion, form the right-hand compound operator:
     * (symbol is superscript ⨁)
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (2):
     * given q = 4X1 column vector of [eps eta] where eta is the scalar,
     * and &quot;1&quot; is a 3X3 identity matrix, also written as I_3.
     * and [q]_x is the skew-symetric matrix for q.
     * 
     * The right-hand compound operator is a 4X4 matrix:
     * 
     * q^⨁ = [ eta*I_3+[q]_x   eps ]
     *        [ -eps^T          eta ]
     * 
     * multiplication of quaternions, u and v, which is typically written 
     * as u ⊗ v may be written equivalently as either
         u^+ v or v^⨁ u,
     * &lt;/pre&gt;
     * @param quaternion 4X1 column vector of [eps eta] where eta is the scalar
     * @return [4X4]
     */
    public static double[][] quaternionRighthandCompoundOperator(double[] quaternion) {
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">        if (quaternion.length != 4) {</span>
<span class="nc" id="L1949">            throw new IllegalArgumentException(&quot;quaternion must be length 4&quot;);</span>
        }
<span class="fc" id="L1951">        double[] eps = Arrays.copyOfRange(quaternion, 0, 3);</span>
<span class="pc bnc" id="L1952" title="All 2 branches missed.">        assert(eps.length == 3);</span>
<span class="fc" id="L1953">        double eta = quaternion[3];</span>
        
<span class="fc" id="L1955">        double[][] skewEps = MatrixUtil.skewSymmetric(eps);</span>
        
<span class="fc" id="L1957">        double[][] i3Eta = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L1958">        MatrixUtil.multiply(i3Eta, eta);</span>
        
        // 3X3
<span class="fc" id="L1961">        double[][] block00 = MatrixUtil.pointwiseAdd(i3Eta, skewEps);</span>
        
<span class="fc" id="L1963">        double[][] lhc = MatrixUtil.zeros(4, 4);</span>
        int i;
<span class="fc bfc" id="L1965" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1966">            System.arraycopy(block00[i], 0, lhc[i], 0, 3);</span>
<span class="fc" id="L1967">            lhc[i][3] = eps[i];</span>
        }
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L1970">            lhc[3][i] = -eps[i];</span>
        }
<span class="fc" id="L1972">        lhc[3][3] = eta;</span>
        
<span class="fc" id="L1974">        return lhc;</span>
    }

    /**
     * calculate q1 divided by q2 for quaternions.
     * The method implements q1 * q2.conjugate().
     * Note that for the Barfoot system use passive = false;
     * @param q1
     * @param q2
     * @param passive
     * @return
     */
    public static double[] _quaternionDivide(double[] q1, double[] q2, boolean passive) {
<span class="pc bpc" id="L1987" title="1 of 2 branches missed.">        if (q1.length != 4) {</span>
<span class="nc" id="L1988">            throw new IllegalArgumentException(&quot;q1 length must be 4&quot;);</span>
        }
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">        if (q2.length != 4) {</span>
<span class="nc" id="L1991">            throw new IllegalArgumentException(&quot;q2 length must be 4&quot;);</span>
        }
<span class="fc" id="L1993">        return quaternionMultiply(q1, inverseQuaternionBarfoot(q2), passive);</span>
    }

    /**
     * calculate the rotation that is angleFraction of the distance between q0 and q1 using spherical linear
     * interpolation (slerp).
     &lt;pre&gt;
     References:
     Szeliski, 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Algorithm 2.1
     &lt;/pre&gt;
     * @param q0
     * @param q1
     * @param angleFraction
     * @return
     */
    public static double[] quaternionSlerp(double[] q0, double[] q1, double angleFraction, boolean passive) {
<span class="pc bpc" id="L2009" title="1 of 2 branches missed.">        if (q0.length != 4) {</span>
<span class="nc" id="L2010">            throw new IllegalArgumentException(&quot;q0 length must be 4&quot;);</span>
        }
<span class="pc bpc" id="L2012" title="1 of 2 branches missed.">        if (q1.length != 4) {</span>
<span class="nc" id="L2013">            throw new IllegalArgumentException(&quot;q1 length must be 4&quot;);</span>
        }
<span class="pc bpc" id="L2015" title="2 of 4 branches missed.">        if (angleFraction &gt; 1 || angleFraction &lt; 0) {</span>
<span class="nc" id="L2016">            throw new IllegalArgumentException(&quot;angleFraction is outside of range [0, 1].&quot;);</span>
        }

<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">        if (!passive) { // Szeliski algorithm is for passive</span>
<span class="nc" id="L2020">            double[] t = q0;</span>
<span class="nc" id="L2021">            q0 = q1;</span>
<span class="nc" id="L2022">            q1 = t;</span>
<span class="nc" id="L2023">            angleFraction = 1. - angleFraction;</span>
        }

        // now we are in passive frame
<span class="fc" id="L2027">        double[] qr = _quaternionDivide(q1, q0, true);</span>
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">        if (qr[3] &lt; 0) {</span>
<span class="nc" id="L2029">            MatrixUtil.multiply(qr, -1);</span>
        }
<span class="fc" id="L2031">        double[] vr = (Arrays.copyOf(qr, 3));</span>
<span class="fc" id="L2032">        double norm = MatrixUtil.lPSum(vr, 2);</span>
<span class="fc" id="L2033">        double thetaR = 2 * Math.atan(norm/qr[3]);</span>

        // direction n^.  reusing vr for n^
<span class="fc" id="L2036">        MatrixUtil.multiply(vr, 1./norm);</span>
        
<span class="fc" id="L2038">        double thetaA = angleFraction * thetaR;</span>
<span class="fc" id="L2039">        double[] qFraction = Arrays.copyOf(vr, 4);</span>
<span class="fc" id="L2040">        MatrixUtil.multiply(qFraction, Math.sin(thetaA/2.));</span>
<span class="fc" id="L2041">        qFraction[3] =  Math.cos(thetaA/2.);</span>
<span class="fc" id="L2042">        double[] result = quaternionMultiply(qFraction, q0, true);</span>

<span class="fc" id="L2044">        return result;</span>
    }

    /**
     * calc geodesic distance (shortest path along a great arc) between 2 unit-length quaternions.
     * == half the angle subtended by q0 and q1 along a great arc of the S3 sphere
     &lt;pre&gt;
     references
     http://en.wikipedia.org/wiki/Quaternion

     https://github.com/KieranWynn/pyquaternion/blob/master/pyquaternion/quaternion.py#L800
     who use MIT license:
     https://github.com/KieranWynn/pyquaternion/blob/master/LICENSE.txt
     &lt;/pre&gt;
     * @param q0 a unit-length quaternion with scalar last term (Barfoot quaternion)
     * @param q1 a unit length quaternion with scalar last term (Barfoot quaternion)
     * @return
     */
    public static double quaternionGeodesicNorm(double[] q0, double[] q1) {
<span class="fc" id="L2063">        double[] q0InvQ1 = Rotation.quaternionMultiply(inverseQuaternionBarfoot(q0), q1, true);</span>
<span class="fc" id="L2064">        double[] qLogMap = _log(q0InvQ1);</span>
<span class="fc" id="L2065">        double norm = MatrixUtil.lPSum(qLogMap, 2);</span>
<span class="fc" id="L2066">        return norm;</span>
    }

    /**
     * calculate the quaternion logarithm in scalar last fomat and return result in scala last format.
     &lt;pre&gt;
     reference:
     adapted from the pyquaternion project which uses MIT license.
     https://github.com/KieranWynn/pyquaternion/blob/master/LICENSE.txt
     who reference:
      [Source](https://math.stackexchange.com/questions/2552/the-logarithm-of-quaternion/2554#2554) for more details.
     &lt;/pre&gt;
     @param q a quaternion in scalar last format
     @return  A quaternion amount representing log(q) := (log(|q|), v/|v|acos(w/|q|))
     */
    public static double[] _log(double[] q) {
<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">        if (q.length !=  4) {</span>
<span class="nc" id="L2083">            throw new IllegalArgumentException(&quot;q length must be 4&quot;);</span>
        }
<span class="fc" id="L2085">        double vNorm = MatrixUtil.lPSum(Arrays.copyOf(q, 3), 2);</span>
<span class="fc" id="L2086">        double qNorm = MatrixUtil.lPSum(q, 2);</span>
<span class="fc" id="L2087">        double tol = 1E-17;</span>
<span class="pc bpc" id="L2088" title="1 of 2 branches missed.">        if (qNorm &lt; tol) {</span>
            // undefined
<span class="nc" id="L2090">            return new double[]{Double.NaN, Double.NaN, Double.NaN, Double.POSITIVE_INFINITY};</span>
        }
<span class="fc bfc" id="L2092" title="All 2 branches covered.">        if (vNorm &lt; tol) {</span>
            // a real quaternion, no imaginary part
<span class="fc" id="L2094">            return new double[]{0, 0, 0, Math.log(qNorm)};</span>
        }
<span class="fc" id="L2096">        double qN = (Math.acos(q[3]/qNorm))/vNorm;</span>
<span class="fc" id="L2097">        double[] vec = new double[4];</span>
<span class="fc bfc" id="L2098" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L2099">            vec[i] = q[i]*qN;</span>
        }
<span class="fc" id="L2101">        vec[3] = Math.log(qNorm);</span>
<span class="fc" id="L2102">        return vec;</span>
    }

    /*
    method computes the logarithm of general quaternions.
        &quot;

        vec = q.vector / v_norm
        return Quaternion(scalar=log(q_norm), vector=acos(q.scalar/q_norm)*vec)

     */
    
    /**
     * given a quaternion, return the inverse
     * (symbol is superscript -1).
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (5):
     * given q = 4X1 column vector of [eps eta] where eta is the scalar,
     * 
     * the inverse is the column vector:
     * 
     * q^-1 = [ -eps  eta ]
     * 
     * &lt;/pre&gt;
     * &lt;em&gt;NOTE that if the quaternion is a unit-length quaternion, the conjugate
     * operation is usually called the inverse operation.&lt;/em&gt;
     * @param quaternion 4X1 column vector of [eps eta] where eta is the scalar
     * @return 
     */
    public static double[] quaternionConjugateOperator(double[] quaternion) {
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">        if (quaternion.length != 4) {</span>
<span class="nc" id="L2136">            throw new IllegalArgumentException(&quot;quaternion must be length 4&quot;);</span>
        }
<span class="fc" id="L2138">        double[] inv = Arrays.copyOf(quaternion, 4);</span>
        
        int i;
<span class="fc bfc" id="L2141" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L2142">            inv[i] *= -1;</span>
        }
        
<span class="fc" id="L2145">        return inv;</span>
    }

    /**
     * rotate a point x to a new frame
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     *
     * eqn (11):
     *
     * v3 = [ p ]
     *      [ 0 ]
     *
     *  rotated = q^+ * q^(-1)^⨁ * v3 = R*v3
     *
     *  where R is the canonical 3X3 rotation matrix.
      *
     * @param q
     * @param x
     * @return
     */
    public static double[] rotateAPointByQuaternionBarfoot(double[] q, double[] x) {
<span class="pc bpc" id="L2168" title="1 of 2 branches missed.">        if (x.length != 3) {</span>
<span class="nc" id="L2169">            throw new IllegalArgumentException(&quot;x length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">        if (q.length != 4) {</span>
<span class="nc" id="L2172">            throw new IllegalArgumentException(&quot;q length must be 4&quot;);</span>
        }
        // (eqn 11) of Barfoot
<span class="fc" id="L2175">        double[][] r = createRotation4FromQuaternion(q);</span>
        //double[] x = createQuaternionBarfootFromAPoint(x);
<span class="fc" id="L2177">        r = MatrixUtil.copySubMatrix(r, 0, 2, 0, 2);</span>
<span class="fc" id="L2178">        return MatrixUtil.multiplyMatrixByColumnVector(r, x);</span>
    }

    /**
     * multiply quaternions.  Note for the Barfoot system, use passive = false
     * @param q1
     * @param q2
     * @return
     */
    public static double[] quaternionMultiply(double[] q1, double[] q2, boolean passive) {
<span class="pc bpc" id="L2188" title="1 of 2 branches missed.">        if (q1.length != 4) {</span>
<span class="nc" id="L2189">            throw new IllegalArgumentException(&quot;q1 length must be 4&quot;);</span>
        }
<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">        if (q2.length != 4) {</span>
<span class="nc" id="L2192">            throw new IllegalArgumentException(&quot;q2 length must be 4&quot;);</span>
        }
<span class="fc bfc" id="L2194" title="All 2 branches covered.">        if (passive) {</span>
<span class="fc" id="L2195">            double[] t = q1;</span>
<span class="fc" id="L2196">            q1 = q2;</span>
<span class="fc" id="L2197">            q2 = t;</span>
        }
<span class="fc" id="L2199">        double[][] lh1 = quaternionLefthandCompoundOperator(q1);</span>
<span class="fc" id="L2200">        return MatrixUtil.multiplyMatrixByColumnVector(lh1, q2);</span>
    }

    public static double[] createQuaternionBarfootFromAPoint(double[] x) {
<span class="nc bnc" id="L2204" title="All 2 branches missed.">        if (x.length != 3) {</span>
<span class="nc" id="L2205">            throw new IllegalArgumentException(&quot;x length must be 3&quot;);</span>
        }
<span class="nc" id="L2207">        return Arrays.copyOf(x, 4);</span>
    }

    /**
     * return the inverse of the quaternion (multiplies the vector portion by -1).
     * Note that for unit-length quaternions,Barfoot et al. refer to the conjugate as the inverse.
     * @param q
     * @return
     */
    public static double[] inverseQuaternionBarfoot(double[] q) {
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">        if (q.length != 4) {</span>
<span class="nc" id="L2218">            throw new IllegalArgumentException(&quot;q length must be 4&quot;);</span>
        }
        // eqn(5) -1*vector portion
<span class="fc" id="L2221">        double[] inv = new double[4];</span>
<span class="fc bfc" id="L2222" title="All 2 branches covered.">        for (int i =0; i &lt; 3; ++i) {</span>
<span class="fc" id="L2223">            inv[i] = -q[i];</span>
        }
<span class="fc" id="L2225">        inv[3] = q[3];</span>
<span class="fc" id="L2226">        return inv;</span>
    }
    
    /**
     * return the identity quaternion
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049,
     * near eqn (8): 
     * 
     * creates identity element: [0 0 0 1]
     * 
     * &lt;/pre&gt;
     * @return 4X1 column vector of [eps eta] where eta is the scalar, specifically
     * [0, 0, 0, 1]
     */
    public static double[] createIdentityQuaternion() {
        
<span class="fc" id="L2244">        double[] i4 = new double[4];</span>
<span class="fc" id="L2245">        i4[3] = 1;</span>
        
<span class="fc" id="L2247">        return i4;</span>
    }
    
     /**
     * create a [4x4] rotation matrix from the given quaternion.
     &lt;pre&gt;
       Note, the first [3X3] block is transposed compared to results 
           from Rotation.createRotationZYX(eulerAngles)
       where 
       double[] qHamilton = Rotation.createQuaternionHamiltonFromAngleAxis(eulerAngles);
       double[] quaternion = Rotation.createQuaternionBarfootFromHamilton(qHamilton);

      Note that the Hamilton systems uses passive (right-hand) transformations and the Barfoot system uses active
      (left-hand) transformations, so this method uses active transformations.
      
     This method's results are consistent with Shuster 1993.
     * The method follows Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     *
     * eqn (12):
     * 
     *  R = q^+ * q^(-1)^⨁ = q^(-1)^⨁ * q^+ = q^(⨁)^T * q^+
     *    
     *    = [ C   0 ]
     *      [ 0^T 1 ]
     * where C is the canonical 3X3 rotation matrix.
     * &lt;/pre&gt;
     * @param quaternion rotation as a [4X1] column vector of [eps eta] where eta is the scalar
      *                   (i.e. Barfoot format)
     * @return a 4x4 rotation matrix whose 3X3 block at [0:2, 0:2] is the rotation matrix.
     */
    public static double[][] createRotation4FromQuaternion(double[] quaternion) {
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">        if (quaternion.length != 4) {</span>
<span class="nc" id="L2280">            throw new IllegalArgumentException(&quot;quaternion must be length 4&quot;);</span>
        }
        // eqn (12)
<span class="fc" id="L2283">        double[][] lh = quaternionLefthandCompoundOperator(quaternion);</span>
<span class="fc" id="L2284">        double[][] lhT = MatrixUtil.transpose(lh);</span>
<span class="fc" id="L2285">        double[][] rh = quaternionRighthandCompoundOperator(quaternion);</span>
<span class="fc" id="L2286">        return MatrixUtil.multiply(lhT, rh);</span>
    }
    
     /**
     * rotate point p by the given quaternion.
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (11):
     * 
     * v3 = [ p ]
     *      [ 0 ]
     * 
     *  rotated = q^+ * q^(-1)^⨁ * v3 = R*v3
     * 
     * &lt;/pre&gt;
     * @param quaternion 4X1 column vector of [eps eta] where eta is the scalar
     * @param p the vector as a 3 element array followed by a 0, = [4X1].
     * @return 
     */
    public static double[] rotateVectorByQuaternion4(double[] quaternion, double[] p) {
<span class="fc" id="L2308">        return rotateAPointByQuaternionBarfoot(quaternion, p);</span>
    }

    /**
     * calculate S_theta which is the matrix relating angular velocity to
     * rotation angle rates.
     *
     The method uses intrinsic, active transformations.
     *
     * TODO: consider overloading for more rotation sequences.
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     *
     * eqn (21):
     * calc C = 3X3 rotation matrix (often written as R)
     * given array of euler rotation angles alpha, beta, gamma
     *
     * s_theta column 0 = C_gamma(eulerAngles[2]) * C_beta(eulerAngles[1]) * [1, 0, 0]^T
     *         column 1 = C_gamma(eulerAngles[2]) * [0, 1, 0]^T
     *         column 2 = [0, 0, 1]^T
     *
             C_gamma                        C_beta                            C_alpha
      cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |
     *  eulerAngles[0] = angleX angle of rotation about x-axis (roll) in units of radians.
     *             can use createRotationRoll(eulerAngles[0])
     *  eulerAngles[1] = angleY angle of rotation about y-axis (pitch) in units of radians.
     *             can use createRotationPitch(eulerAngles[1])
     *  eulerAngles[2] = angleZ angle of rotation about z-axis (yaw) in units of radians.
     *             can use createRotationYaw(eulerAngles[2])
     *
     * see also, pp 479-480, eqn (285) of Shuster 1993, &quot;A Survey of AttitudeRepresentations&quot;
     * http://www.ladispe.polito.it/corsi/Meccatronica/02JHCOR/2011-12/Slides/Shuster_Pub_1993h_J_Repsurv_scan.pdf
     * though the sign conventions of the sine terms are different
     *
     * &lt;/pre&gt;
     * This method uses active (left-hand system) transformations.
     *
     * @param eulerAngles euler X,Y,Z angles as representation of rotation matrix
     * @param seq Euler sequence in use
     * @return [3X3]
     */
    public static double[][] sTheta(double[] eulerAngles, EulerSequence seq) {
<span class="pc bpc" id="L2354" title="1 of 2 branches missed.">        if (eulerAngles.length != 3) {</span>
<span class="nc" id="L2355">            throw new IllegalArgumentException(&quot;eulerAngles length must be 3&quot;);</span>
        }
<span class="fc" id="L2357">        double[][] sTheta = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L2358">        sTheta(eulerAngles, sTheta, seq);</span>

<span class="fc" id="L2360">        return sTheta;</span>
    }
    
    /**
     * calculate S_theta which is the matrix relating angular velocity to 
     * rotation angle rates.
     * The method uses intrinsic, active transformations.
     *
     * TODO: consider overloading for more rotation sequences.
     *
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
       eqn (21)

     the book &quot;State Estimation for Robotics&quot;, 2nd edition, by Barfoot
     page 271, eqn (7.51), (7.52):
     * 
     * &lt;/pre&gt;
     *
     * @param eulerAngles euler angles as representation of rotation matrix
     * @param seq euler sequence in use
     * @param output
     */
    public static void sTheta(double[] eulerAngles, double[][] output, EulerSequence seq) {
<span class="pc bpc" id="L2385" title="1 of 2 branches missed.">        if (eulerAngles.length != 3) {</span>
<span class="nc" id="L2386">            throw new IllegalArgumentException(&quot;eulerAngles length must be 3&quot;);</span>
        }

        /*
        the book &quot;State Estimation for Robotics&quot;, 2nd edition, by Barfoot
        page 271, eqn 7.52 for 1-2-3 sequence (active)  as naming for active euler sequence 3-2-1
        S(theta2, theta3)
            [ cos(th2) * cos(th3)   sin(th3)   0 ]
            [ -cos(th2)*sin(th3)    cos(th3)   0 ]
            [ sin(th2)              0          1 ]

        Barfoot uses intrinsic active transformations.
         */

        /*
        column 0:
         C_gamma(eulerAngles[2]) * C_beta(eulerAngles[1]) * [1, 0, 0]^T
        
        = | cos φ   -sin φ    0 |    *  |  cos ψ    0  sin ψ | * [1, 0, 0]^T
          | sin φ    cos φ    0 |    *  |      0    1      0 |
          |     0        0    1 |    *  | -sin ψ    0  cos ψ |
        = |  cos t2 * cos t1    -sin t2   cos t2 * sin t1 | * [1]
          |  sin t2 * cos t1     cos t2   sin t2 * sin t1 |   [0]
          | -sin t1              0        cos t1          |   [0]
        = | cos t2 * cos t1 |
          | sin t2 * cos t1 |
          | -sin t1         |

        column 1:
        | cos φ   -sin φ    0 |  * [0] = [-sin t2]
        | sin φ    cos φ    0 |    [1]   [cos t2 ]
        |     0        0    1 |    [0]   [0 ]

        column 3: [0 0 1]^T
        */
        
<span class="fc" id="L2422">        double[] i0 = new double[]{1, 0, 0};</span>
<span class="fc" id="L2423">        double[] i1 = new double[]{0, 1, 0};</span>
<span class="fc" id="L2424">        double[] i2 = new double[]{0, 0, 1};</span>

        // Barfoot uses euler active transformations.  we use the positive angles given, but later, if extracting
        //   angles, they should be considered negative in a passive context.

<span class="fc" id="L2429">        double[][] cBeta = Rotation.createRotationPitch(-eulerAngles[1]);</span>

        double[] col0, col1, col2;
        // intrinsic
<span class="pc bpc" id="L2433" title="1 of 2 branches missed.">        if (!seq.equals(EulerSequence.XYZ_ACTIVE)) {</span>
            // eqn (21) of Barfoot et al. for a 1-2-3 sequence
<span class="fc" id="L2435">            double[][] cGamma = Rotation.createRotationYaw(-eulerAngles[2]);</span>
<span class="fc" id="L2436">            col0 = MatrixUtil.multiplyMatrixByColumnVector(MatrixUtil.multiply(cGamma, cBeta), i0);</span>
<span class="fc" id="L2437">            col1 = MatrixUtil.multiplyMatrixByColumnVector(cGamma, i1);</span>
<span class="fc" id="L2438">            col2 = i2;</span>
<span class="fc" id="L2439">        } else {</span>
            // eqn (58) of Barfoot et al. for a 3-2-1 sequence, but he means 1-2-3 w.r.t. euler notation...
<span class="nc" id="L2441">            double[][] cAlpha = Rotation.createRotationRoll(-eulerAngles[0]);</span>
<span class="nc" id="L2442">            col0 = MatrixUtil.multiplyMatrixByColumnVector(MatrixUtil.multiply(cAlpha, cBeta), i2);</span>
<span class="nc" id="L2443">            col1 = MatrixUtil.multiplyMatrixByColumnVector(cAlpha, i1);</span>
<span class="nc" id="L2444">            col2 = i0;</span>
        }

        int row;
<span class="fc bfc" id="L2448" title="All 2 branches covered.">        for (row = 0; row &lt; 3; ++row) {</span>
<span class="fc" id="L2449">            output[row][0] = col0[row];</span>
<span class="fc" id="L2450">            output[row][1] = col1[row];</span>
<span class="fc" id="L2451">            output[row][2] = col2[row];</span>
        }
<span class="fc" id="L2453">    }</span>

    /**
     * calculate inv S_theta which is the matrix relating angular velocity to
     * rotation angle rates.
     * This method fails for eulerAngles[1]=0, so consider using the singularity safe methods instead.
     * The method uses intrinsic, active transformations.
     *
     * &lt;pre&gt;
     the book &quot;State Estimation for Robotics&quot;, 2nd edition, by Barfoot
     eqn (7.53):
     *
     * &lt;/pre&gt;
     *
     * @param eulerAngles euler angles as representation of rotation matrix
     * @result inverse of s(eulerAngles)
     */
    private static double[][] invSTheta(double[] eulerAngles) {
<span class="nc bnc" id="L2471" title="All 2 branches missed.">        if (eulerAngles.length != 3) {</span>
<span class="nc" id="L2472">            throw new IllegalArgumentException(&quot;eulerAngles length must be 3&quot;);</span>
        }
<span class="nc bnc" id="L2474" title="All 2 branches missed.">        if (eulerAngles[1] == 0) {</span>
<span class="nc" id="L2475">            throw new IllegalArgumentException(&quot;eulerAngles[1] cannot be 0&quot;);</span>
        }

<span class="nc" id="L2478">        double sec2 = 1./Math.cos(eulerAngles[1]);</span>
<span class="nc" id="L2479">        double cos3 = Math.cos(eulerAngles[2]);</span>
<span class="nc" id="L2480">        double sin3 = Math.sin(eulerAngles[2]);</span>
<span class="nc" id="L2481">        double tan2 = Math.tan(eulerAngles[1]);</span>

<span class="nc" id="L2483">        double[][] sInv = new double[][] {</span>
                {sec2 * cos3, -sec2*sin3, 0},
                {sin3, cos3, 0},
                {-tan2*cos3, tan2*sin3, 1}
        };

<span class="nc" id="L2489">        return sInv;</span>
    }
    
    /**
     * calculate  R_zyx = (R_z(theta_x)*R_y(theta_y))*R_x(theta_z)
     * where theta_x = eulerZYX[0], theta_y=eulerZYX[1], theta_z=eulerZYX[2].
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     * This method uses &quot;intrinsic&quot; composition.
     *
     * @return R_zyx intrinsic
     */
    public static double[][] createRotationZYX(double eulerX, double eulerY, double eulerZ) {

<span class="fc" id="L2502">        double[][] rX = Rotation.createRotationRoll(eulerX);</span>
<span class="fc" id="L2503">        double[][] rY = Rotation.createRotationPitch(eulerY);</span>
<span class="fc" id="L2504">        double[][] rZ = Rotation.createRotationYaw(eulerZ);</span>

<span class="fc" id="L2506">        return MatrixUtil.multiply(MatrixUtil.multiply(rZ, rY), rX);</span>
    }

    /**
     * calculate  R_zyx = (R_z(theta_x)*R_y(theta_y))*R_x(theta_z)
     * where theta_x = thetas[0], theta_y=thetas[1], theta_z=thetas[2].
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     * This method uses &quot;intrinsic&quot; composition.
     *
     * @param aa auxiliary arrays to use as space for intermediate calculations
     * @out gets populated with R_zyx intrinsic
     */
    public static void createRotationZYX(double eulerX, double eulerY, double eulerZ,
                                         AuxiliaryArrays aa, double[][] out) {
<span class="nc bnc" id="L2520" title="All 4 branches missed.">        if (out.length != 3 || out[0].length != 3) {</span>
<span class="nc" id="L2521">            throw new IllegalArgumentException(&quot;out must be 3 x 3&quot;);</span>
        }

        //ZYX = transpose of xyz(-1*thetas)
        
<span class="nc" id="L2526">        double[][] rZ = aa.a3X3;</span>
<span class="nc" id="L2527">        Rotation.createRotationYaw(eulerZ, rZ);</span>
        
<span class="nc" id="L2529">        double[][] rY = aa.b3X3;</span>
<span class="nc" id="L2530">        Rotation.createRotationPitch(eulerY, rY);</span>
        
<span class="nc" id="L2532">        double[][] rX = aa.c3X3;</span>
<span class="nc" id="L2533">        Rotation.createRotationRoll(eulerX, rX);</span>

<span class="nc" id="L2535">        MatrixUtil.multiply(MatrixUtil.multiply(rZ, rY), rX, out);</span>
<span class="nc" id="L2536">    }</span>
    
    /**
     * calculate  the Hamilton unit-length quaternion which would be extracted from the
     * rotation matrix created by R_xyz = R_z(theta_z)*R_y(theta_y)*R_z(theta_z).
     *
     * This method uses a passive (right-hand) rotation system with CCW (=CC) rotations.
     *
     * from https://en.wikipedia.org/wiki/Davenport_chained_rotations
     * &quot;Any extrinsic rotation is equivalent to an intrinsic rotation by the 
     * same angles but with inverted order of elemental rotations, and vice 
     * versa. For instance, the intrinsic rotations x-y’-z″ by angles α, β, γ 
     * are equivalent to the extrinsic rotations z-y-x by angles γ, β, α.&quot;
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (18)
     * 
     * where  
       cc rotation about z-axis (yaw):   cc about the y-axis (pitch):    cc about x-axis (roll):    
            | cos φ   -sin φ    0 |          |  cos ψ    0  sin ψ |         |    1       0       0 |  
            | sin φ    cos φ    0 |          |      0    1      0 |         |    0   cos θ  -sin θ |  
            |     0        0    1 |          | -sin ψ    0  cos ψ |         |    0   sin θ   cos θ |  
            * 

        = | (cos φ * cos ψ)   (-sin φ * cos θ + cos φ * sin ψ * sin θ)   (sin φ * sin θ + cos φ * sin ψ * cos θ)   |
          | (sin φ * cos ψ)   ( cos φ * cos θ + sin φ * sin ψ * sin θ)   (-cos φ * sin θ + sin φ * sin ψ * cos θ)  |
          | (-sin ψ)          ( cos ψ * sin θ )                          (cos ψ * cos θ)                           |
          
       =  | (cosZ * cosY)   (-sinZ * cosX + cosZ * sinY * sinX)   (sinZ * sinX + cosZ * sinY * cosX)   |
          | (sinZ * cosY)   ( cosZ * cosX + sinZ * sinY * sinX)   (-cosZ * sinX + sinZ * sinY * cosX)  |
          | (-sinY)          ( cosY * sinX )                       (cosY * cosX)                       |
           
     given angle theta and axis n:
         q = [scalar, vector] = 
             [cos(theta/2), nx*sin(theta/2), ny*sin(theta/2), nz*sin(theta/2)];
          
     given euler angles:
         q1 =  sin(z/2)*sin(y/2)*sin(x/2) + cos(z/2)*cos(y/2)*cos(x/2)
         q2 = -sin(z/2)*sin(y/2)*cos(x/2) + sin(x/2)*cos(z/2)*cos(y/2)
         q3 =  sin(z/2)*sin(x/2)*cos(y/2) + sin(y/2)*cos(z/2)*cos(x/2)
         q4 =  sin(z/2)*cos(y/2)*cos(x/2) - sin(y/2)*sin(x/2)*cos(z/2)

     This is what is used in eqn (2.40) of &quot;An Invitation to 3-D Vision&quot;,
     Ma, Soatto, Kosecka, and Sastry (MASKS).

     It is an intrinsic 'XYZ' format.
     * &lt;/pre&gt;
     * @param angle
     * @param axis
     * @return the quaternion in format scalar as first term.
     */
    public static double[] createQuaternionHamiltonFromAngleAxis(double angle, double[] axis) {
<span class="pc bpc" id="L2590" title="1 of 2 branches missed.">        if (axis.length != 3) {</span>
<span class="nc" id="L2591">            throw new IllegalArgumentException(&quot;axis must be length 3&quot;);</span>
        }
<span class="fc" id="L2593">        double d = MatrixUtil.lPSum(axis, 2);</span>
<span class="fc" id="L2594">        double nx = axis[0]/d;</span>
<span class="fc" id="L2595">        double ny = axis[1]/d;</span>
<span class="fc" id="L2596">        double nz = axis[2]/d;</span>
<span class="fc" id="L2597">        double ca = Math.cos(angle/2);</span>
<span class="fc" id="L2598">        double sa = Math.sin(angle/2);</span>

<span class="fc" id="L2600">        double[] q = new double[]{ca, nx*sa, ny*sa, nz*sa};</span>
        
<span class="fc" id="L2602">        return q;</span>
    }
    
    /**
     * convert the quaternion from [scalar vector] to [vector scalar].
     * Barfoot uses intrinsic, active transformations with scalar last format.
     * Hamilton uses intrinsic with scalar first format.
     * @param qHamilton quaternion of format [scalar  vector]
     * @return convert the quaternion from [scalar vector] to [vector scalar]
     */
    public static double[] createQuaternionBarfootFromHamilton(double[] qHamilton) {
<span class="pc bpc" id="L2613" title="1 of 2 branches missed.">        if (qHamilton.length != 4) {</span>
<span class="nc" id="L2614">            throw new IllegalArgumentException(&quot;qHamilton length must be 4&quot;);</span>
        }
<span class="fc" id="L2616">        double[] out = Arrays.copyOf(qHamilton, 4);</span>
<span class="fc" id="L2617">        convertQuaternionHamiltonToBarfoot(out);</span>
<span class="fc" id="L2618">        return out;</span>
    }

    /**
     * convert the quaternion from [scalar vector] to [vector scalar].
     * Barfoot uses intrinsic, active transformations with scalar last format.
     * Hamilton uses intrinsic with scalar first format.
     * @param qHamilton quaternion in Hamilton format that is converted to Barfoot format in place (modifying array)
     */
    public static void convertQuaternionHamiltonToBarfoot(double[] qHamilton) {
<span class="fc" id="L2628">        double scalar = qHamilton[0];</span>
<span class="fc bfc" id="L2629" title="All 2 branches covered.">        for (int i = 1; i &lt; qHamilton.length; ++i) {</span>
<span class="fc" id="L2630">            qHamilton[i-1] = qHamilton[i];</span>
        }
<span class="fc" id="L2632">        qHamilton[3] = scalar;</span>
<span class="fc" id="L2633">    }</span>
    /**
     * convert the quaternion from [scalar vector] to [vector scalar].
     * Barfoot uses intrinsic, active transformations with scalar last format.
     * Hamilton uses intrinsic with scalar first format.
     * @param qBarfoot quaternion in Barfoot format to be converted to Hamilton format in place (modifies array)
     */
    public static void convertQuaternionBarfootToHamilton(double[] qBarfoot) {
<span class="nc" id="L2641">        double scalar = qBarfoot[3];</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">        for (int i = 2; i &gt;= 0; --i) {</span>
<span class="nc" id="L2643">            qBarfoot[i+1] = qBarfoot[i];</span>
        }
<span class="nc" id="L2645">        qBarfoot[0] = scalar;</span>
<span class="nc" id="L2646">    }</span>

    /**
     * convert the quaternion from [scalar vector] to [vector scalar].
     * Barfoot uses intrinsic, active transformations with scalar last format.
     * Hamilton uses intrinsic with scalar first format.
     * @param qBarfoot quaternion of format [scalar  vector]
     * @return convert the quaternion from [scalar vector] to [vector scalar]
     */
    public static double[] createQuaternionHamiltonFromBarfoot(double[] qBarfoot) {
<span class="nc bnc" id="L2656" title="All 2 branches missed.">        if (qBarfoot.length != 4) {</span>
<span class="nc" id="L2657">            throw new IllegalArgumentException(&quot;qHamilton length must be 4&quot;);</span>
        }
<span class="nc" id="L2659">        double[] out = Arrays.copyOf(qBarfoot, 4);</span>
<span class="nc" id="L2660">        convertQuaternionBarfootToHamilton(out);</span>
<span class="nc" id="L2661">        return out;</span>
    }

    /*
    create a quaternion 4X1 column vector of [vector scalar] from the given
    angle and axis representation of rotation.
    Barfoot et al. place the scalar as the last item in the quaternion.
    Barfoot uses intrinsic, active transformations.
    &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (32)
    
    satisfies unit-length constraint q^T*q = 1  (size [1X4]*[4X1]=[1X1].
    q^T*q = q_1^2 + q_2^2 + q_3^2 + q_4^2.
    &lt;/pre&gt;
    @param unitLengthAxis axis of rotation normalized to unit length
    @param angle rotation about axis in radians
    */
    public static double[] createQuaternionUnitLengthBarfoot(double angle, double[] unitLengthAxis) {
<span class="pc bpc" id="L2682" title="1 of 2 branches missed.">        if (unitLengthAxis.length != 3) {</span>
<span class="nc" id="L2683">            throw new IllegalArgumentException(&quot;unitLengthAxis.length must be 3&quot;);</span>
        }

        /*if (Math.abs(angle) &gt; Math.PI) {
            unitLengthAxis = Arrays.copyOf(unitLengthAxis, 3);
            angle = Rotation.makeUnitLengthAngleAxis(angle, unitLengthAxis);
        }*/

<span class="fc" id="L2691">        double sumSq = MatrixUtil.lPSum(unitLengthAxis, 2);</span>
<span class="fc" id="L2692">        sumSq *= sumSq;</span>

        //TODO: revisit tolerance here:
<span class="pc bpc" id="L2695" title="1 of 2 branches missed.">        if (Math.abs(sumSq - 1.) &gt; 1E-5) {</span>
            // can provide same normalization for all, by using rotation vector as an intermediary
<span class="nc" id="L2697">            angle = Rotation.makeUnitLengthAngleAxis(angle, unitLengthAxis);</span>
<span class="nc" id="L2698">            sumSq = MatrixUtil.lPSum(unitLengthAxis, 2);</span>
<span class="nc" id="L2699">            sumSq *= sumSq;</span>
        }

        // follows from sum of squares of each element in unitLengthAxis should be == 1
        //cos(theta)^2 + sin(theta)^2 = 1
        // scalar term = cos(theta)^2
        // vector portion = |sin(theta)|^2
        /// u = q // ||q|| vector portion
        // q2 = q0 + q = cos(theta) + u*sin(theta) ...

<span class="fc" id="L2709">        double cPhi2 = Math.cos(angle/2.);</span>
<span class="fc" id="L2710">        double sPhi2 = Math.sin(angle/2.);</span>
<span class="fc" id="L2711">        double[] out = Arrays.copyOf(unitLengthAxis, 4);</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L2713">            out[i] *= sPhi2;</span>
        }
<span class="fc" id="L2715">        out[3] = cPhi2;</span>
<span class="fc" id="L2716">        return out;</span>
    }

    /*
    create a quaternion 4X1 column vector of [vector scalar] from the given
    angle and axis representation of rotation.
    Barfoot et al. place the scalar as the last item in the quaternion.
    Barfoot uses intrinsic, active transformations.
    &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     *
     * eqn (32) w/ conversion from eulerAngles to axis angle representation

    satisfies unit-length constraint q^T*q = 1  (size [1X4]*[4X1]=[1X1].
    q^T*q = q_1^2 + q_2^2 + q_3^2 + q_4^2.
    &lt;/pre&gt;
    @param eulerAngles eulerAngles
    */
    public static double[] createQuaternionUnitLengthBarfootFromEulerXYZ(double[] eulerAngles) throws NotConvergedException {
<span class="pc bpc" id="L2736" title="1 of 2 branches missed.">        if (eulerAngles.length != 3) {</span>
<span class="nc" id="L2737">            throw new IllegalArgumentException(&quot;unitLengthAxis.length must be 3&quot;);</span>
        }
<span class="fc" id="L2739">        double[] rotVec = createRotationVectorFromEulerAnglesXYZ(eulerAngles);</span>
<span class="fc" id="L2740">        double[] axis = new double[3];</span>
<span class="fc" id="L2741">        double angle = createAngleAxisFromRotationVector(rotVec, axis);</span>
<span class="fc" id="L2742">        return createQuaternionUnitLengthBarfoot(angle, axis);</span>
    }

    public static double[] createQuaternionUnitLengthBarfootFromEuler(double[] eulerAnglesXYZ, EulerSequence seq) throws NotConvergedException {
<span class="pc bpc" id="L2746" title="1 of 2 branches missed.">        if (eulerAnglesXYZ.length != 3) {</span>
<span class="nc" id="L2747">            throw new IllegalArgumentException(&quot;unitLengthAxis.length must be 3&quot;);</span>
        }
<span class="fc" id="L2749">        double[] rotVec = createRotationVectorFromEulerAngles(eulerAnglesXYZ, seq);</span>
<span class="fc" id="L2750">        double[] axis = new double[3];</span>
<span class="fc" id="L2751">        double angle = createAngleAxisFromRotationVector(rotVec, axis);</span>
<span class="fc" id="L2752">        return createQuaternionUnitLengthBarfoot(angle, axis);</span>
    }

    public static double[] createQuaternionUnitLengthBarfootFromRotationVector(double[] rotVec) {
<span class="pc bpc" id="L2756" title="1 of 2 branches missed.">        if (rotVec.length != 3) {</span>
<span class="nc" id="L2757">            throw new IllegalArgumentException(&quot;rotVec.length must be 3&quot;);</span>
        }
<span class="fc" id="L2759">        double[] axis = new double[3];</span>
<span class="fc" id="L2760">        double angle = createAngleAxisFromRotationVector(rotVec, axis);</span>
<span class="fc" id="L2761">        return createQuaternionUnitLengthBarfoot(angle, axis);</span>
    }

    /*
    &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (35)
    
    &lt;/pre&gt;
    @param principalAxis the axis of rotation, that is x, y, or z.
    (rotation about x is roll, y is pitch, and z is yaw).
    */
    public static double[] quaternionPrincipalAxisRotation(double angle, int principalAxis) {
<span class="pc bpc" id="L2776" title="2 of 4 branches missed.">        if (principalAxis &lt; 0 || principalAxis &gt; 2) {</span>
<span class="nc" id="L2777">            throw new IllegalArgumentException(&quot;principalAxis must be 0, 1, or 2&quot;);</span>
        }
<span class="fc" id="L2779">        double sa = Math.sin(angle/2.);</span>
<span class="fc" id="L2780">        double ca = Math.cos(angle/2.);</span>
<span class="fc" id="L2781">        double[] q = new double[4];</span>
        // two 0's and a 1 for principal axis:
<span class="fc" id="L2783">        q[principalAxis] = sa;</span>
<span class="fc" id="L2784">        q[3] = ca;</span>
<span class="fc" id="L2785">        return q;</span>
    }
    
    /**
     * create a rotation quaternion from Euler x, y, z angles.
     * note that the rotation order of multiplication operations is z, y, x.
     * 
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * eqn (37)
     *     q(euler) = q_z(euler_z)^+ * q_y(euler_y)^+ + q_x(euler_x) 
     * 
     *     and principal axis rotations in eqn (35)
     * &lt;/pre&gt;
     * @param eulerXYZ
     * @return [4X1] quaternion rotation vector.
     */
    public static double[] createQuaternionBarfootFromEuler(double[] eulerXYZ, EulerSequence seq) {
<span class="pc bpc" id="L2805" title="1 of 2 branches missed.">        if (eulerXYZ.length != 3) {</span>
<span class="nc" id="L2806">            throw new IllegalArgumentException(&quot;eulerXYZ.length must be 3&quot;);</span>
        }

        // length is 4
<span class="fc" id="L2810">        double[] q0 = quaternionPrincipalAxisRotation(-eulerXYZ[0], 0);</span>
<span class="fc" id="L2811">        double[] q1 = quaternionPrincipalAxisRotation(-eulerXYZ[1], 1);</span>
<span class="fc" id="L2812">        double[] q2 = quaternionPrincipalAxisRotation(-eulerXYZ[2], 2);</span>

        // XYZ active == XYZ passive, but with negative angles
        // Barfoot et al. use intrinsic active transformations.
        // so Barfoot et al XYZ_ACTIVE is intrinsic ZYX ACTIVE
        // eqn (21) of Barfoot et al. for a 1-2-3 sequence

        double[][] q1m, q2m;
        double[] q3v;
<span class="pc bpc" id="L2821" title="1 of 2 branches missed.">        if (!seq.equals(EulerSequence.XYZ_ACTIVE)) {</span>
            // [4X4]  Barfoot et al XYZ_ACTIVE is intrinsic ZYX ACTIVE
<span class="fc" id="L2823">            q1m = quaternionLefthandCompoundOperator(q2);</span>
<span class="fc" id="L2824">            q2m = quaternionLefthandCompoundOperator(q1);</span>
<span class="fc" id="L2825">            q3v = q0;</span>
        } else {
            // Barfoot et al ZYX_ACTIVE is intrinsic XYZ ACTIVE
            // [4X4]
<span class="nc" id="L2829">            q1m = quaternionLefthandCompoundOperator(q0);</span>
<span class="nc" id="L2830">            q2m = quaternionLefthandCompoundOperator(q1);</span>
<span class="nc" id="L2831">            q3v = q2;</span>
        }

        // q2m times q1m times q0 = [4X1]
        // [4X4]
<span class="fc" id="L2836">        double[][] t1 = MatrixUtil.multiply(q2m, q1m);</span>
        // 4X1
<span class="fc" id="L2838">        double[] q = MatrixUtil.multiplyMatrixByColumnVector(t1, q3v);</span>

<span class="fc" id="L2840">        return q;</span>
    }
    
    /**
     * create the rotation vector dPhi = S(eulerAngles) * dTheta
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized 
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     * 
     * text under eqn (26)
     *    dPhi= S(eulerAngles) * dTheta
     * 
     * &lt;/pre&gt;
     * @param eulerAngles euler rotation angles
     * @param dTheta perturbation to apply to rotation
     * @param seq Euler sequence in use
     * @return dPhi= S(eulerAngles) * dTheta.  length is 3.
     */
    public static double[] createRotationVectorBarfoot(double[] eulerAngles, double[] dTheta, EulerSequence seq) {
        
<span class="fc" id="L2860">        double[][] sTheta = sTheta(eulerAngles, seq);</span>
        
        // length 3
<span class="fc" id="L2863">        double[] dPhi = MatrixUtil.multiplyMatrixByColumnVector(sTheta, dTheta);</span>
        
<span class="fc" id="L2865">        return dPhi;</span>
    }

    /**
     * Apply a perturbation dTheta to the rotation matrix represented by euler angles theta0
     * and return the result as a quaternion in Barfoot format or as a rotation matrix.  The result also contains
     * dPhi, the rotation vector, which can be used as an updatable state structure for future
     * use that avoids the need to extract euler angles from a rotation quaternion or matrix.
     *
     * The scalar is the last term in the quaternion.  The rotation transformations are active and intrinsic.
     &lt;pre&gt;
     from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
     rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

     rotation vector:
         dPhi = S(theta0) * dTheta

     eqn (29c)
          C(thetaResult) ~ C(theta0 + dTheta) ~ (I_3 - [dPhi]_x) * C(theta0)

     eqn (49)
        q(thetaResult) = q(theta0 + perturbation) = q(dPhi)^⨁ * q(theta0)

     &quot;This update approach allows us to store and update the rotation as a
     unit-length quaternion, thereby avoiding singularities and the need to
     restore the constraint afterwards (i.e., constraint restoration is
     built in).&quot;

     &lt;/pre&gt;
     * @param theta0 euler rotation angles used to define the rotation matrix that will
     *              be perturbed by dTheta.  The order of the angles in the array is X,Y,Z even
     *               if the seq used is not.
     *               In Barfoot paper eqn 26, this is theta with a bar over it.
     * @param dTheta the perturbation to apply to the rotation matrix as euler rotation angles
     *    must be small (cosine(dTheta[i]) ~ 1, sine(dTheta[i] ~ 0 or sine(dTheta[i])/i ~ 1).
     *     The order of the angles in the array is X,Y,Z even if the seq used is not.
     *
     * @param seq Euler sequence
     * @param returnQuaternion if true, calculates the rotation quaternion and returns a datastructure holding it,
     *                         else if false, calculates the rotation matrix and returns a datastructure holding it.
     *
     * @return a data structure holding the resulting rotation matrix or quaternion, the EulerSequence, and the
     * updatable rotation vector dPhi.  This returned data structure can be used in the overloaded
     * applySingularitySafeRotationPerturbation.
     */
    public static RotationPerturbation applySingularitySafeRotationPerturbation(double[] theta0, double[] dTheta,
        EulerSequence seq, boolean returnQuaternion) throws NotConvergedException {

        //TODO: add consistency checks like allowed range values

<span class="pc bpc" id="L2915" title="1 of 2 branches missed.">        if (theta0.length != 3) {</span>
<span class="nc" id="L2916">            throw new IllegalArgumentException(&quot;theta0 length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L2918" title="1 of 2 branches missed.">        if (dTheta.length != 3) {</span>
<span class="nc" id="L2919">            throw new IllegalArgumentException(&quot;theta0 must be length 3&quot;);</span>
        }

        //let dPhi = S(theta0)*dTheta

        //length 3
<span class="fc" id="L2925">        double[] dPhi = createRotationVectorBarfoot(theta0, dTheta, seq);</span>

<span class="fc bfc" id="L2927" title="All 2 branches covered.">        if (returnQuaternion) {</span>

<span class="fc" id="L2929">            double[] qTheta = createQuaternionBarfootFromEuler(theta0, seq);</span>

            // eqn (48c)
<span class="fc" id="L2932">            double[] qdPhi = Arrays.copyOf(dPhi, 4);</span>
            //MatrixUtil.multiply(qdPhi, 0.5);
            //NOTE:  comparing (30b) to (47c), it may be that we need a subtraction here instead
<span class="fc" id="L2935">            MatrixUtil.multiply(qdPhi, -0.5);</span>
<span class="fc" id="L2936">            qdPhi[3] = 1;// add identity quaternion</span>

<span class="fc" id="L2938">            double[][] qLH = quaternionLefthandCompoundOperator(qdPhi);</span>

<span class="fc" id="L2940">            double[] q2 = MatrixUtil.multiplyMatrixByColumnVector(qLH, qTheta);</span>

<span class="fc" id="L2942">            RotationPerturbationQuaternion result = new RotationPerturbationQuaternion(dPhi, seq, q2);</span>

<span class="fc" id="L2944">            return result;</span>
        }

        // eqn (25) Barfoot et al.
        // infinitesimally small rotation matrix for the perturbation
<span class="fc" id="L2949">        double[][] rPerturb = MatrixUtil.skewSymmetric(dPhi);</span>
<span class="fc" id="L2950">        double[][] eye = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L2951">        rPerturb = MatrixUtil.pointwiseSubtract(eye, rPerturb);</span>

        // XYZ active == XYZ passive, but with negative angles
        // Barfoot et al. use intrinsic active transformations.
        // so Barfoot et al XYZ_ACTIVE is intrinsic ZYX ACTIVE
        // eqn (21) of Barfoot et al. for a 1-2-3 sequence

        //from theta0 create r0
        double[][] r0;
<span class="pc bpc" id="L2960" title="1 of 2 branches missed.">        if (seq.equals(EulerSequence.XYZ_ACTIVE)) {</span>
<span class="nc" id="L2961">            r0 = createRotationXYZ(theta0[0], theta0[1], theta0[2], false);</span>
        } else {
<span class="fc" id="L2963">            r0 = createRotationZYX(theta0[0], theta0[1], theta0[2], false);</span>
        }

<span class="fc" id="L2966">        double[][] r2 = MatrixUtil.multiply(rPerturb, r0);</span>

<span class="fc" id="L2968">        RotationPerturbationMatrix result = new RotationPerturbationMatrix(dPhi, seq, r2);</span>

<span class="fc" id="L2970">        return result;</span>
    }

    /**
     * Apply a perturbation dTheta to the given rotation matrix or quaternion and return the updated perturbed data
     * structure.
     *
     &lt;pre&gt;
     from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
     rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.

     rotation vector:
         dPhi = S(theta0) * dTheta

     eqn (29c)
          C(thetaResult) ~ C(theta0 + dTheta) ~ (I_3 - [dPhi]_x) * C(theta0)

     eqn (49)
        q(thetaResult) = q(theta0 + perturbation) = q(dPhi)^⨁ * q(theta0)

     &quot;This update approach allows us to store and update the rotation as a
     unit-length quaternion, thereby avoiding singularities and the need to
     restore the constraint afterwards (i.e., constraint restoration is
     built in).&quot;

     &lt;/pre&gt;
     * @param state data structure holding the current state rotation matrix or quaternion, the EulerSequence, and the
     * current state updatable rotation vector dPhi.
     @param dTheta the perturbation to apply to the rotation matrix as euler rotation angles
     *    must be small (cosine(dTheta[i]) ~ 1, sine(dTheta[i] ~ 0 or sine(dTheta[i])/i ~ 1).
     *     The order of the angles in the array is X,Y,Z even if the seq used is not.
     *     if the seq used is not.
     * @return a data structure holding the resulting rotation matrix or quaternion, the EulerSequence, and the
     * updatable rotation vector dPhi.
     */
    public static RotationPerturbation applySingularitySafeRotationPerturbation(RotationPerturbation state,
                                                                                double[] dTheta) {
<span class="pc bpc" id="L3007" title="1 of 2 branches missed.">        if (dTheta.length != 3) {</span>
<span class="nc" id="L3008">            throw new IllegalArgumentException(&quot;theta0 must be length 3&quot;);</span>
        }

        /*
        let dPhi = S(theta0)*dTheta
        C(theta)
                ~ C(theta0 + dTheta)
                ~ (I_3 - [dPhi]_x) * C(theta0)
         */

        //length 3
<span class="fc" id="L3019">        double[] dPhi = state.dPhi;</span>

<span class="fc bfc" id="L3021" title="All 2 branches covered.">        if (state instanceof RotationPerturbationQuaternion) {</span>

            // eqn (48c)
<span class="fc" id="L3024">            double[] qdPhi = Arrays.copyOf(dPhi, 4);</span>
            //MatrixUtil.multiply(qdPhi, 0.5);
            //NOTE:  comparing (30b) to (47c), it may be that we need a subtraction here instead
<span class="fc" id="L3027">            MatrixUtil.multiply(qdPhi, -0.5);</span>
<span class="fc" id="L3028">            qdPhi[3] = 1;// add identity quaternion</span>

<span class="fc" id="L3030">            double[][] qLH = quaternionLefthandCompoundOperator(qdPhi);</span>

<span class="fc" id="L3032">            double[] qTheta = ((RotationPerturbationQuaternion) state).quaternion;</span>

<span class="fc" id="L3034">            double[] q2 = MatrixUtil.multiplyMatrixByColumnVector(qLH, qTheta);</span>

<span class="fc" id="L3036">            RotationPerturbationQuaternion result = new RotationPerturbationQuaternion(dPhi, state.seq, q2);</span>

<span class="fc" id="L3038">            return result;</span>
        }

        // infinitesimally small rotation matrix for the perturbation
        // eqn (25) Barfoot et al.
        // infinitesimally small rotation matrix for the perturbation
<span class="fc" id="L3044">        double[][] rPerturb = MatrixUtil.skewSymmetric(dPhi);</span>
<span class="fc" id="L3045">        double[][] eye = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L3046">        rPerturb = MatrixUtil.pointwiseSubtract(eye, rPerturb);</span>

<span class="fc" id="L3048">        double[][] r0 = ((RotationPerturbationMatrix)state).rotation;</span>

<span class="fc" id="L3050">        double[][] r2 = MatrixUtil.multiply(rPerturb, r0);</span>

<span class="fc" id="L3052">        RotationPerturbationMatrix result = new RotationPerturbationMatrix(dPhi, state.seq, r2);</span>

<span class="fc" id="L3054">        return result;</span>
    }

    /**
     * first term in RHS of eqn (30b) in Barfoot et al. paper.
     * @param theta0 euler angles representing current state.
     *  The order of the angles in the array is X,Y,Z even if the seq used is not.
     * @param dTheta euler angle perturbations.  The order of the angles in the array is X,Y,Z even if the seq used is not.
     * @param seq
     * @return
     */
    protected static double[][] createRotationInfSmallPerturbation(double[] theta0, double[] dTheta, EulerSequence seq) {

        //dPhi = S(theta) * dTheta
<span class="nc" id="L3068">        double[] dPhi = createRotationVectorBarfoot(theta0, dTheta, seq);</span>

        // infinitesimally small rotation matrix:
<span class="nc" id="L3071">        double[][] qPhiX = MatrixUtil.skewSymmetric(dPhi);</span>
<span class="nc bnc" id="L3072" title="All 2 branches missed.">        for (int i = 0; i &lt; qPhiX.length; ++i) {</span>
<span class="nc" id="L3073">            qPhiX[i][i] = 1. - qPhiX[i][i];</span>
        }
<span class="nc" id="L3075">        return qPhiX;</span>
    }

    /**
     * Apply the perturbation dTheta to rotation matrix theta and
     * return the perturbed rotation.
     * The rotation transformations are active and intrinsic.
     * &lt;pre&gt;
     * from Barfoot, Forbes, &amp; Furgale 2010, &quot;Pose estimation using linearized
     * rotations and quaternion algebra&quot;, Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049.
     *
     * eqn (26)
     *    C(theta2) ~ C(theta + dTheta) ~ (I_3 - [dPhi]_x) * C(theta)
     *    where C is for rotation matrix.
     *
     *    (I_3 - [dPhi]_x) is effectively a rotation matrix, but is infinitesimally small.
     *
     * &quot;This update approach allows us to store and update the rotation as a
     * unit-length quaternion, thereby avoiding singularities and the need to
     * restore the constraint afterwards (i.e., constraint restoration is
     * built in).&quot;
     *
     * &lt;/pre&gt;
     * NOTE: this method is not efficient, but is kept for use in tests.
     *
     * @param rTheta the current rotation matrix.  note that it should have been formed using intrinsic active ZYX.
     * @param dTheta the perturbation to apply to the rotation matrix as euler rotation angles
     * must be small (cosine(dTheta[i]) ~ 1, sine(dTheta[i] ~ 0 or sine(dTheta[i])/i ~ 1).
     *               The order of the angles in the array is X,Y,Z even if the seq used is not.
     * @return resulting quaternion from perturbation applied to quaternion
     * formed from theta euler angles.
     */
    protected static double[][] _applySingularitySafeRotationPerturbation(double[][] rTheta, double[] dTheta,
                                                                      EulerSequence seq) {
<span class="nc bnc" id="L3109" title="All 2 branches missed.">        if (dTheta.length != 3) {</span>
<span class="nc" id="L3110">            throw new IllegalArgumentException(&quot;dTheta length must be 3&quot;);</span>
        }
<span class="nc bnc" id="L3112" title="All 4 branches missed.">        if (rTheta.length != 3 || rTheta[0].length != 3) {</span>
<span class="nc" id="L3113">            throw new IllegalArgumentException(&quot;rTheta must be 3 X 3&quot;);</span>
        }

        // eqn (26)
        //C(theta2) ~ C(theta + dTheta) ~ (I_3 - [dPhi]_x) * C(theta)

        double[] theta0;
<span class="nc bnc" id="L3120" title="All 2 branches missed.">        if (seq.equals(EulerSequence.ZYX_ACTIVE)) {</span>
<span class="nc" id="L3121">            theta0 = extractThetaFromZYX(rTheta, false);</span>
        } else {
<span class="nc" id="L3123">            theta0 = extractThetaFromXYZ(rTheta, false);</span>
        }

<span class="nc" id="L3126">        double[][] qPhiX = createRotationInfSmallPerturbation(theta0, dTheta, seq);</span>

<span class="nc" id="L3128">        return MatrixUtil.multiply(qPhiX, rTheta);</span>
    }

    static double[] _extractRotationVectorFromQuaternionBarfoot(double[] q) {
<span class="pc bpc" id="L3132" title="1 of 2 branches missed.">        if (q.length != 4) {</span>
<span class="nc" id="L3133">            throw new IllegalArgumentException(&quot;q must be length 4&quot;);</span>
        }
        // extracting from eqn (7.14) of Barfoot book
        // scalar term = cos(angle/2);  acos(q[3])= angle/2
<span class="fc" id="L3137">        double[] axis = new double[3];</span>
<span class="fc" id="L3138">        double angle = extractAngleAxisFromBarfootQuaternion(q, axis);</span>
<span class="fc bfc" id="L3139" title="All 2 branches covered.">        if (angle == 0) {</span>
<span class="fc" id="L3140">            return new double[]{0, 0, 0};</span>
        }
<span class="fc" id="L3142">        return createRotationVectorFromAngleAxis(axis, angle);</span>
    }
    private static double extractAngleAxisFromBarfootQuaternion(double[] q, double[] outAxis) {
<span class="pc bpc" id="L3145" title="1 of 2 branches missed.">        if (q.length != 4) {</span>
<span class="nc" id="L3146">            throw new IllegalArgumentException(&quot;q must be length 4&quot;);</span>
        }
<span class="pc bpc" id="L3148" title="1 of 2 branches missed.">        if (outAxis.length != 3) {</span>
<span class="nc" id="L3149">            throw new IllegalArgumentException(&quot;outAxis must be length 3&quot;);</span>
        }
        // extracting from eqn (7.14) of Barfoot book
        // scalar term = cos(angle/2);  acos(q[3])= angle/2
        double angle;
<span class="fc" id="L3154">        angle = 2 * Math.acos(q[3]);</span>
        // wikipedia states it is more mathematically stable to use:
        //angle = 2 * Math.atan2(MatrixUtil.lPSum(Arrays.copyOf(q, 3), 2), q[3]);
<span class="fc" id="L3157">        System.arraycopy(q, 0, outAxis, 0, 3);</span>
<span class="fc bfc" id="L3158" title="All 2 branches covered.">        if (angle == 0) {</span>
<span class="fc" id="L3159">            return 0;</span>
        }
<span class="fc" id="L3161">        double s = Math.sin(angle/2);</span>
<span class="fc bfc" id="L3162" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3163">            outAxis[i] /= s;</span>
        }
<span class="fc" id="L3165">        return angle;</span>
    }
        
    public static class AuxiliaryArrays {
        final double[][] a3X3;
        final double[][] b3X3;
        final double[][] c3X3;
        final double[][] d3X3;
        public AuxiliaryArrays() {
            a3X3 = MatrixUtil.zeros(3, 3);
            b3X3 = MatrixUtil.zeros(3, 3);
            c3X3 = MatrixUtil.zeros(3, 3);
            d3X3 = MatrixUtil.zeros(3, 3);
        }
    }

    public static double[][] orthonormalizeUsingSVD(double[][] r) throws NotConvergedException {
<span class="fc" id="L3182">        SVD svd = SVD.factorize(new DenseMatrix(r));</span>
<span class="fc" id="L3183">        DenseMatrix r2 = (DenseMatrix) svd.getU().mult(svd.getU(), svd.getVt());</span>
<span class="fc" id="L3184">        return MatrixUtil.convertToRowMajor(r2);</span>
    }
    public static double[][] orthonormalizeUsingSkewCayley(double[][] r) throws NotConvergedException {
<span class="nc" id="L3187">        r = cay(r);</span>
<span class="nc" id="L3188">        double[][] skew = MatrixUtil.pointwiseSubtract(</span>
<span class="nc" id="L3189">                r, MatrixUtil.transpose(r));</span>
<span class="nc" id="L3190">        MatrixUtil.multiply(skew, 0.5);</span>
<span class="nc" id="L3191">        r = cay(skew);</span>
<span class="nc" id="L3192">        return r;</span>
    }

    /**
     * orthogonalize matrix R using skew parameters via Cayley's formula.
     * (I - A)*(I + A)^-1
     * @param r  a rotation matrix (i.e. a skew symmetric matrix A^T = A^-1)
     * @return
     * @throws NotConvergedException
     */
    public static double[][] cay(double[][] r) throws NotConvergedException {
<span class="nc bnc" id="L3203" title="All 2 branches missed.">        if (r.length != r[0].length) {</span>
<span class="nc" id="L3204">            throw new IllegalArgumentException(&quot;r must be a square rotation matrix&quot;);</span>
        }
<span class="nc" id="L3206">        double[][] identity = MatrixUtil.createIdentityMatrix(r.length);</span>
<span class="nc" id="L3207">        double[][] t1 = MatrixUtil.pseudoinverseFullColumnRank(</span>
<span class="nc" id="L3208">                MatrixUtil.pointwiseAdd(identity, r));</span>
<span class="nc" id="L3209">        double[][] t2 = MatrixUtil.pointwiseSubtract(identity, r);</span>
<span class="nc" id="L3210">        return MatrixUtil.multiply(t1, t2);</span>
    }

    /**
     * convert the axis, angle pair into unit length axis, angle pair.
     * @param angle
     * @param axis input axis and output axis
     * @return the angle
     */
    public static double makeUnitLengthAngleAxis(double angle, double[] axis) {
<span class="pc bpc" id="L3220" title="1 of 2 branches missed.">        if (axis.length != 3) {</span>
<span class="nc" id="L3221">            throw new IllegalArgumentException(&quot;axis length must be 3&quot;);</span>
        }
<span class="fc" id="L3223">        double[] rotVec = Rotation.createRotationVectorFromAngleAxis(axis, angle);</span>
<span class="fc" id="L3224">        double[] _axis = new double[3];</span>
<span class="fc" id="L3225">        angle = Rotation.createAngleAxisFromRotationVector(rotVec, _axis);</span>
<span class="fc" id="L3226">        System.arraycopy(_axis, 0, axis, 0, 3);</span>
<span class="pc bpc" id="L3227" title="1 of 2 branches missed.">        double sign = (angle &lt; 0) ? -1 : 1;</span>
<span class="fc" id="L3228">        angle *= sign;</span>
<span class="fc" id="L3229">        angle %= Math.PI;</span>
<span class="fc" id="L3230">        angle *= sign;</span>
<span class="fc" id="L3231">        return angle;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
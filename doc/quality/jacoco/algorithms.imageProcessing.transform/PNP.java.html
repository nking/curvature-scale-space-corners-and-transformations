<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PNP.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">PNP.java</span></div><h1>PNP.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters;
import algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters;
import algorithms.matrix.MatrixUtil;
import algorithms.util.FormatArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import no.uib.cipr.matrix.NotConvergedException;

/**
 * iterative non-linear optimization using Levenberg-Marquardt algorithm
 * to minimize the re-projection error of perspective projection
 * in &quot;perspective-n-point&quot;.
 * 
 * L-M is guaranteed to converge to eventually find an improvement, 
 * because an update with a sufficiently small magnitude and a negative scalar 
 * product with the gradient is guaranteed to do so.
 * 
 * TODO: consider implementing the Szeliski 2010 chapter 6 equations (6.44)-(6.47)
 * 
 * NOTE: this implementation uses euler rotation angles and singularity safe
 * updates, but future versions could consider using quaternions.
 * This from Szeliski 2010:
   ...&quot;Quaternions, on the other hand, are better if you want to keep track of 
   a smoothly moving camera, since there are no discontinuities in the 
   representation. It is also easier to interpolate between rotations and to 
   chain rigid transformations (Murray, Li, and Sastry 1994; Bregler and Malik 1998).
   My usual preference is to use quaternions, but to update their estimates 
   using an incremental rotation, as described in Section 6.2.2.&quot;
 * @author nichole
 */
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">public class PNP {</span>
    
    /**
     * NOT YET TESTED.
     * given the fixed intrinsic camera calibration for the single camera
     * used in all images,
     * and given the initial estimates
     * of extrinsic camera parameters for each image, use the 
     * Levenberg-Marquardt algorithm to improve the extrinsic camera parameters rotation and translation 
     * by minimizing the re-projection error using feature 
     * measurements and their world coordinates.
     * NOTE: this is a dense Hessian matrix solver, not the sparse Hessian
     * matrix bundle adjustment which is in BundleAdjustment.java.
     * &lt;pre&gt;
     References:
     
     Gordon Wetzstein lecture notes, Stanford University, EE 267 Virtual Reality, 
     &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
       https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     Danping Zou lecture notes, Shanghai Jiao Tong University,
     EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
     http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

     Szeliski 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Chapter 6
     
     * &lt;/pre&gt;
     * @param imageC observed features in one image followed by the same observed
     * features in the next image, etc. format of double array with
     * first dimension length 3 (for x, y, z) and the second dimension length
     * of nFeatures * mImages. 
     * @param worldC world scene features in format of double array with
     * first dimension length 3 (for x, y, z) and the second dimension length
     * of nFeatures.
     * @param kIntr
     * @param kExtrs
     * @param kRadial
     * @param nMaxIter
     * @param useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4 if true,
        else use model #3 f(r) = 1 +k1*r + k2*r^2.
        note that if rCoeffs is null or empty, no radial distortion is removed.
     * @throws Exception if there is an error in use of MPSolver during the
     * removal of radial distortion, a generic exception is thrown with the
     * error message from the MPSolve documentation.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static List&lt;CameraExtrinsicParameters&gt; solveForPose(double[][] imageC, double[][] worldC, 
        CameraIntrinsicParameters kIntr, 
        List&lt;CameraExtrinsicParameters&gt; kExtrs, 
        double[] kRadial, final int nMaxIter, boolean useR2R4) 
        throws NotConvergedException, Exception {
        
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        if (imageC.length != 3) {</span>
<span class="nc" id="L89">            throw new IllegalArgumentException(&quot;imageC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (worldC.length != 3) {</span>
<span class="nc" id="L92">            throw new IllegalArgumentException(&quot;worldC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
        
<span class="fc" id="L95">        int nFeatures = worldC[0].length;</span>
        
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (nFeatures &lt; 4) {</span>
<span class="nc" id="L98">            throw new IllegalArgumentException(&quot;worldC[0].length must be at least 4&quot;);</span>
        }
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if ((imageC[0].length % nFeatures) != 0) {</span>
<span class="nc" id="L101">            throw new IllegalArgumentException(&quot;imageC[0].length must be an integer multiple of worldC[0].length&quot;);</span>
        }
        
<span class="fc" id="L104">        int nImages = imageC[0].length/nFeatures;</span>
        
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (kExtrs.size() != nImages) {</span>
<span class="nc" id="L107">            throw new IllegalArgumentException(&quot;from imageC[0].length, &quot;</span>
               + &quot;nImages is expected to be &quot; + nImages
               + &quot; therefore kExtrs.size() should be &quot; + nImages + &quot; also.&quot;);
        }

<span class="fc" id="L112">        List&lt;CameraExtrinsicParameters&gt; refined = new ArrayList&lt;CameraExtrinsicParameters&gt;();</span>
        
<span class="fc" id="L114">        double[][] imageCI = MatrixUtil.zeros(3, nFeatures);</span>
        
        CameraExtrinsicParameters r;
        
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (int i = 0; i &lt; nImages; ++i) {</span>
            
<span class="fc" id="L120">            MatrixUtil.copySubMatrix(imageC, 0, 2, i*nFeatures, i*nFeatures+nFeatures-1, imageCI);</span>
            
<span class="fc" id="L122">            r = solveForPose(imageCI, worldC, kIntr, kExtrs.get(i), kRadial, nMaxIter, useR2R4);</span>
            
<span class="fc" id="L124">            refined.add(r);</span>
        }
<span class="fc" id="L126">        return refined;</span>
    }
    
    /**
     * NOT YET TESTED.
     * given the fixed intrinsic camera calibration and the initial estimates
     * of extrinsic camera parameters as lists of the same size, each item being
     * for a single image, use the 
     * Levenberg-Marquardt algorithm to improve the extrinsic camera parameters rotation and translation 
     * by minimizing the re-projection error using feature 
     * measurements and their world coordinates.
     * NOTE: this is a dense Hessian matrix solver, not the sparse Hessian
     * matrix bundle adjustment which is in BundleAdjustment.java.
     * &lt;pre&gt;
     References:
     
     Gordon Wetzstein lecture notes, Stanford University, EE 267 Virtual Reality, 
     &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
       https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     Danping Zou lecture notes, Shanghai Jiao Tong University,
     EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
     http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

     Szeliski 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Chapter 6
     
     * &lt;/pre&gt;
     * @param imageC
     * @param worldC
     * @param kIntrs
     * @param kExtrs
     * @param kRadial
     * @param nMaxIter
     * @param useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4 if true,
        else use model #3 f(r) = 1 +k1*r + k2*r^2.
        note that if rCoeffs is null or empty, no radial distortion is removed.
     * @throws Exception if there is an error in use of MPSolver during the
     * removal of radial distortion, a generic exception is thrown with the
     * error message from the MPSolve documentation.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static List&lt;CameraExtrinsicParameters&gt; solveForPose(double[][] imageC, double[][] worldC, 
        List&lt;CameraIntrinsicParameters&gt; kIntrs, 
        List&lt;CameraExtrinsicParameters&gt; kExtrs, 
        double[] kRadial, final int nMaxIter, boolean useR2R4) 
        throws NotConvergedException, Exception {
        
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (kIntrs.size() != kExtrs.size()) {</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(&quot;the sizes of Kintrs and kExtrs must be the same&quot;);</span>
        }
        
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (imageC.length != 3) {</span>
<span class="nc" id="L180">            throw new IllegalArgumentException(&quot;imageC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (worldC.length != 3) {</span>
<span class="nc" id="L183">            throw new IllegalArgumentException(&quot;worldC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
        
<span class="nc" id="L186">        int nFeatures = worldC[0].length;</span>
        
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (nFeatures &lt; 4) {</span>
<span class="nc" id="L189">            throw new IllegalArgumentException(&quot;worldC[0].length must be at least 4&quot;);</span>
        }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if ((imageC[0].length % nFeatures) != 0) {</span>
<span class="nc" id="L192">            throw new IllegalArgumentException(&quot;imageC[0].length must be an integer multiple of worldC[0].length&quot;);</span>
        }
        
<span class="nc" id="L195">        int nImages = imageC[0].length/nFeatures;</span>
        
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (kExtrs.size() != nImages) {</span>
<span class="nc" id="L198">            throw new IllegalArgumentException(&quot;from imageC[0].length, &quot;</span>
               + &quot;nImages is expected to be &quot; + nImages
               + &quot; therefore kExtrs.size() should be &quot; + nImages + &quot; also.&quot;);
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (kIntrs.size() != nImages) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;from imageC[0].length, &quot;</span>
               + &quot;nImages is expected to be &quot; + nImages
               + &quot; therefore kIntrs.size() should be &quot; + nImages + &quot; also.&quot;);
        }

<span class="nc" id="L208">        List&lt;CameraExtrinsicParameters&gt; refined = new ArrayList&lt;CameraExtrinsicParameters&gt;();</span>
        
<span class="nc" id="L210">        double[][] imageCI = MatrixUtil.zeros(3, nFeatures);</span>
        
        CameraExtrinsicParameters r;
        
<span class="nc bnc" id="L214" title="All 2 branches missed.">        for (int i = 0; i &lt; nImages; ++i) {</span>
            
<span class="nc" id="L216">            MatrixUtil.copySubMatrix(imageC, 0, 2, i*nFeatures, i*nFeatures+nFeatures-1, imageCI);</span>
            
<span class="nc" id="L218">            r = solveForPose(imageCI, worldC, kIntrs.get(i), kExtrs.get(i), kRadial, nMaxIter, useR2R4);</span>
            
<span class="nc" id="L220">            refined.add(r);</span>
        }
<span class="nc" id="L222">        return refined;</span>
    }
    
    /**
     * NOT YET TESTED.
     * given the camera intrinsic calibration  
     * and initial estimates for extrinsic camera parameters for an image, use the 
     * Levenberg-Marquardt algorithm to improve the extrinsic camera parameters rotation and translation 
     * estimates by minimizing the re-projection error using feature 
     * measurements and their world coordinates.
     * NOTE: this is a dense Hessian matrix solver, not the sparse Hessian
     * matrix bundle adjustment which is in BundleAdjustment.java.
     * &lt;pre&gt;
     References:
     
     Gordon Wetzstein lecture notes, Stanford University, EE 267 Virtual Reality, 
     &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
       https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     Danping Zou lecture notes, Shanghai Jiao Tong University,
     EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
     http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

     Szeliski 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Chapter 6
     
     * &lt;/pre&gt;
     * @param imageC
     * @param worldC
     * @param kIntr
     * @param kExtr
     * @param kRadial
     * @param nMaxIter
     * @param useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4 if true,
        else use model #3 f(r) = 1 +k1*r + k2*r^2.
        note that if rCoeffs is null or empty, no radial distortion is removed.
     * @throws Exception if there is an error in use of MPSolver during the
     * removal of radial distortion, a generic exception is thrown with the
     * error message from the MPSolve documentation.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static CameraExtrinsicParameters solveForPose(double[][] imageC, double[][] worldC, 
        CameraIntrinsicParameters kIntr, 
        CameraExtrinsicParameters kExtr, 
        double[] kRadial, final int nMaxIter, boolean useR2R4) 
        throws NotConvergedException, Exception {
        
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (imageC.length != 3) {</span>
<span class="nc" id="L271">            throw new IllegalArgumentException(&quot;imageC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (worldC.length != 3) {</span>
<span class="nc" id="L274">            throw new IllegalArgumentException(&quot;worldC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
        
        // number of features
<span class="fc" id="L278">        int n = worldC[0].length;</span>
        
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (n &lt; 4) {</span>
<span class="nc" id="L281">            throw new IllegalArgumentException(&quot;worldC[0].length must be at least 4&quot;);</span>
        }
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (imageC[0].length != n) {</span>
<span class="nc" id="L284">            throw new IllegalArgumentException(&quot;imageC[0].length must equal worldC[0].length&quot;);</span>
        }
        
<span class="fc" id="L287">        double[] b = new double[2*n];</span>
<span class="fc" id="L288">        final double[][] xn = Camera.pixelToCameraCoordinates(imageC, kIntr, </span>
            kRadial, useR2R4);
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L291">            xn[0][i] /= xn[2][i];</span>
<span class="fc" id="L292">            xn[1][i] /= xn[2][i];</span>
            //TODO: follow up on signs from pixelToCameraCoordinates.
<span class="fc" id="L294">            b[2*i] = xn[0][i];</span>
<span class="fc" id="L295">            b[2*i + 1] = xn[1][i];</span>
        }
                
        //TODO: consider adding constraints suggested in Seliski 2010:
        // u_0 and v_0 are close to half the image lengths and widths, respectively.
        // the angle between 2 image axes is close to 90.
        // the focal lengths along both axes are greater than 0.
      
        // ==========  initialize ===================
        
        // extract pose as (theta_x, theta_y, theta_z, t_x, t_y, t_z)
<span class="fc" id="L306">        double[][] rTest = MatrixUtil.copy(kExtr.getRotation());</span>
<span class="fc" id="L307">        double[] thetasTest = Rotation.extractThetaFromZYX(rTest);</span>
<span class="fc" id="L308">        double[] tTest = Arrays.copyOf(kExtr.getTranslation(), 4);</span>
        
<span class="fc" id="L310">        CameraExtrinsicParameters outExtr = new CameraExtrinsicParameters();</span>
<span class="fc" id="L311">        outExtr.setRotation(MatrixUtil.copy(kExtr.getRotation()));</span>
<span class="fc" id="L312">        outExtr.setTranslation(Arrays.copyOf(kExtr.getTranslation(), 4));</span>
        
//TODO: check the signs of the last row.  wetzsteinuses a convention of looking down
//the negative z-axis.
        
        // equation (19).  size is 1 X 9
<span class="fc" id="L318">        double[] h = new double[9];</span>
<span class="fc" id="L319">        populateHWithRT(h, rTest, tTest);</span>
        
        // eqn (20) of Wetzstein.  length is 2*N
        // project the world coordinates to the camera coord frame, using R and T in h:
<span class="fc" id="L323">        double[] fgp = transformToCamera(worldC, h);</span>
        
        // in camera reference frame, subtract the projected world points from the observations:
        // length is 2*N
<span class="fc" id="L327">        double[] bMinusFGP = MatrixUtil.subtract(b, fgp);   </span>
                
// the projected x and y have opposite signs than they should      
<span class="fc" id="L330">        System.out.printf(&quot;observed in camera ref frame=\n%s\n&quot;,</span>
<span class="fc" id="L331">            FormatArray.toString(b, &quot;%.3e&quot;));</span>
<span class="fc" id="L332">        System.out.printf(&quot;world feature projected to camera ref frame=\n%s\n&quot;,</span>
<span class="fc" id="L333">            FormatArray.toString(fgp, &quot;%.3e&quot;));</span>
<span class="fc" id="L334">        System.out.printf(&quot;(observed-projected) in camera ref frame=\n%s\n&quot;,</span>
<span class="fc" id="L335">            FormatArray.toString(bMinusFGP, &quot;%.3e&quot;));</span>
        
        // sum the squares to evalute the re-projection error:
<span class="fc" id="L338">        double fPrev = evaluateObjective(bMinusFGP);</span>
<span class="fc" id="L339">        double fTest = Double.POSITIVE_INFINITY;</span>
        
        // size is (2N) X 6
<span class="fc" id="L342">        double[][] j = calculateJ(worldC, h, thetasTest);</span>
        
        // size is 6 X (2N)
<span class="fc" id="L345">        double[][] jT = MatrixUtil.transpose(j);</span>
        // size is 6 X 6
<span class="fc" id="L347">        double[][] jTJ = MatrixUtil.multiply(jT, j);</span>
        
<span class="fc" id="L349">        double lambda = maxDiag(jTJ);</span>
<span class="fc" id="L350">        System.out.printf(&quot;max diag of Hessian lambda=%.7e\n&quot;, lambda);</span>

        //factor to raise or lower lambda.  
        //   consider using the eigenvalue spacing of J^T*J (Transtrum &amp; Sethna, &quot;Improvements to the Levenberg-Marquardt algorithm for nonlinear least-squares minimization&quot;)
<span class="fc" id="L354">        final double lambdaF = 2;</span>
                
        // deltaP is the array of length 6 holding the steps of change for theta and translation.
<span class="fc" id="L357">        double[] deltaP = new double[6];</span>
        
        // deltaTheta is used to extract the 1st 3 elements of deltaPM 
<span class="fc" id="L360">        double[] deltaTheta = new double[3];</span>
        // deltaT is used to extract the last 3 elements of deltaPLM
<span class="fc" id="L362">        double[] deltaT = new double[3];</span>
                
<span class="fc" id="L364">        double eps = 1E-12;</span>
        
        double gainRatio;
        
<span class="fc" id="L368">        double[] gradient = MatrixUtil.multiplyMatrixByColumnVector(jT, bMinusFGP);</span>
        
<span class="fc" id="L370">        final double tolP = 1.e-3;</span>
<span class="fc" id="L371">        final double tolG = 1.e-3;</span>
        
<span class="fc" id="L373">        int nIter = 0;</span>
        //begin loop of tentative changes
<span class="pc bpc" id="L375" title="2 of 4 branches missed.">        while ((nIter &lt; nMaxIter) &amp;&amp; (Math.abs(fPrev - fTest) &gt;= eps)) {</span>
            
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (nIter == 0) {</span>
<span class="fc" id="L378">                initDeltaPWithQu(deltaP);</span>
            } else {
<span class="fc" id="L380">                calculateDeltaPLMSzeliski(jTJ, lambda, gradient, deltaP);</span>
            }

<span class="fc" id="L383">            nIter++;</span>
            
            // p is (theta_x, theta_y, theta_z, t_x, t_y, t_z)
<span class="fc" id="L386">            System.arraycopy(deltaP, 0, deltaTheta, 0, 3);</span>
<span class="fc" id="L387">            System.arraycopy(deltaP, 3, deltaT, 0, 3);</span>
<span class="fc" id="L388">            updateT(tTest, deltaT);</span>
<span class="fc" id="L389">            updateRTheta(rTest, thetasTest, deltaTheta);</span>

<span class="fc" id="L391">            populateHWithRT(h, rTest, tTest);</span>
            
            // eqn (20) of Wetzstein.  length is 2*N
            // project the world coordinates to the camera coord frame, using R and T in h:
<span class="fc" id="L395">            fgp = transformToCamera(worldC, h);</span>
            // in camera reference frame, subtract the projected world points from the observations:
<span class="fc" id="L397">            bMinusFGP = MatrixUtil.subtract(b, fgp);   </span>
            // sum the squares:
<span class="fc" id="L399">            fTest = evaluateObjective(bMinusFGP);</span>
            
<span class="fc" id="L401">            System.out.printf(&quot;nIter=%d) fPrev=%.11e, fTest=%.11e  diff=%.11e\n&quot;, nIter, fPrev, fTest,</span>
<span class="fc" id="L402">                (fPrev-fTest));</span>
<span class="fc" id="L403">            System.out.flush();</span>

            // ===== calculate step ========
            // eqns (24-34) of Wetzstein
<span class="fc" id="L407">            j = calculateJ(worldC, h, thetasTest); // 2NX6</span>
<span class="fc" id="L408">            jT = MatrixUtil.transpose(j); // 6X2N</span>
<span class="fc" id="L409">            jTJ = MatrixUtil.multiply(jT, j); // 6X6</span>
           
            //gradient is the local direction of steepest ascent
            // 6X1
<span class="fc" id="L413">            gradient = MatrixUtil.multiplyMatrixByColumnVector(jT, bMinusFGP);</span>
            
<span class="fc" id="L415">            System.out.printf(&quot;\nj^T*(b-fgp)=%s\n&quot;, FormatArray.toString(gradient, &quot;%.3e&quot;));</span>
<span class="fc" id="L416">            System.out.printf(&quot;deltaP=%s\n&quot;, FormatArray.toString(deltaP, &quot;%.3e&quot;));</span>
        
<span class="fc" id="L418">            gainRatio = calculateGainRatio(fTest, fPrev, deltaP, lambda, </span>
                gradient, eps);
            
<span class="fc bfc" id="L421" title="All 2 branches covered.">            if (gainRatio &lt;= Double.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L422">                break;</span>
            }
            
<span class="fc" id="L425">            System.out.printf(&quot;lambda=%.6e\ngainRatio=%.6e\nfPrev=%.11e, fTest=%.11e\n&quot;, </span>
<span class="fc" id="L426">                lambda, gainRatio, fPrev, fTest);</span>
<span class="fc" id="L427">            System.out.flush();</span>

            /*
            for large values of lambda, the update is a very steep descent and
            deltaP is very small.
            If the damping term is small the approach is a nearly linear problem.
            
            NOTE: the damping term is used like a factor in the perturbation
            of a symmetric matrix.  see:
                https://nhigham.com/2021/02/16/diagonally-perturbing-a-symmetric-matrix-to-make-it-positive-definite/
            */
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (gainRatio &gt; 0) {</span>
                // near the minimimum, which is good.
                // decrease lambda
<span class="fc" id="L441">                lambda /= lambdaF;</span>
<span class="pc bpc" id="L442" title="3 of 4 branches missed.">                assert(fTest &lt; fPrev);</span>
<span class="fc" id="L443">                fPrev = fTest;</span>
                
<span class="fc" id="L445">                System.out.printf(&quot;fPrev updated to fTest: fPrev=%.11e fTest=%.11e\n&quot;, fPrev, fTest);</span>
<span class="fc" id="L446">                System.out.flush();</span>
                
<span class="fc" id="L448">                System.out.printf(&quot;elementwise diff in rotation:\n%s\n&quot;, </span>
<span class="fc" id="L449">                    FormatArray.toString(MatrixUtil.elementwiseSubtract(outExtr.getRotation(), rTest),</span>
                    &quot;%.11e&quot;));
            
<span class="fc" id="L452">                outExtr.setRotation(MatrixUtil.copy(rTest));</span>
<span class="fc" id="L453">                outExtr.setTranslation(Arrays.copyOf(tTest, 3));</span>
                
                // ======= stopping conditions ============
                //   step length vanishes:  deltaPLM --&gt; 0
                //   gradient of f(x) vanishes: -J^T * (b - fgp) --&gt; 0
                //MatrixUtil.multiply(gradientCheck, -1.);            
<span class="pc bpc" id="L459" title="3 of 4 branches missed.">                if (isNegligible(deltaP, tolP) || isNegligible(gradient, tolG)) {</span>
<span class="nc" id="L460">                    break;</span>
                }
                
            } else {
                // increase lambda to reduce step length and get closer to 
                // steepest descent direction
<span class="fc" id="L466">                lambda *= lambdaF;</span>
            }
<span class="fc" id="L468">            System.out.printf(&quot;new lambda=%.6e\n&quot;, lambda);    </span>
        }
        
<span class="fc" id="L471">        return outExtr;</span>
         
        /*
        Initialization: A = J^T*J, lambda=max{a_i_i}
        • Repeat until the step length vanishes, || delta x_LM || --&gt; 0, 
          or the gradient of f(x) vanishes, del f = -J^T * r --&gt; 0
          a) Solve (A + lambda*I)*(delta x) = J^T*r to get delta x_LM
          b) x = x + (delta x_LM)
          c) Adjust the damping parameter by checking the gain ratio
             1. gain &gt; 0 Good approximation, decrease the damping parameter
             2. gain &lt;= 0 Bad approximation, increase the damping parameter
        
        where r_i(x) = y_i - h_i(x) where y_i are the measurements
           and h_i(x) are the projections.
        where delta x_LM = = (J^T*J + lambda*I)^-1 * J^T * r
        where f(x) = (1/2) * || r(x) ||^2
        where rho = (f(x + (delta x_LM)) - f(x)) / (ell(delta x_LM))
        
        where the incremental of the objective function predicted by the 
           linear model is given by
              ell(delta x) = - (delta x)^T * J^T * J * (delta x) - 2*(delta x)^T * J^T * r
        where the incremental predicted by the LM step is computed as
              ell(delta x_LM) = - (delta x)^T * (lambda * (delta x_LM) + J^T*r)
        */
    }
    
    /**
     * use the homography matrix to the project the world reference points
     * to 2D point coordinates in the camera frame.  eqn (20).
     * @param worldC
     * @param h
     * @return 
     */
    static double[] transformToCamera(double[][] worldC, double[] h) {
        
<span class="fc" id="L506">        int n = worldC[0].length;</span>
        
<span class="fc" id="L508">        double[] f = new double[2*n];</span>
        
        int i, j;
        double X, Y, s;
<span class="fc bfc" id="L512" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L513">            X = worldC[0][i];</span>
<span class="fc" id="L514">            Y = worldC[1][i];</span>
<span class="fc" id="L515">            s = h[6]*X + h[7]*Y + h[8];</span>
            
<span class="fc" id="L517">            f[2*i] = (h[0]*X + h[1]*Y + h[2])/s;</span>
<span class="fc" id="L518">            f[2*i+1] = ((h[3]*X + h[4]*Y + h[5])/s); </span>
        }
        
<span class="fc" id="L521">        return f;</span>
    }
    
    /**
     * evaluate the objective (|| b − f (g (p)) ||_2)^2
     * eqn (21)
     * @param bMinusFGP array b - f(g(p))
     * @return 
     */
    static double evaluateObjective(double[] bMinusFGP) {
        
<span class="fc" id="L532">        int n = bMinusFGP.length;</span>
        
<span class="fc" id="L534">        double sum = 0;</span>
        int i;
<span class="fc bfc" id="L536" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L537">            sum += (bMinusFGP[i] * bMinusFGP[i]);</span>
        }
        
<span class="fc" id="L540">        return sum;</span>
    }
    
    /**
     * calculate J for extrinsic parameters in solving pose
     &lt;pre&gt; 
     Sect 6.1 of George Wetzstein Stanford Course Notes 
     for EE 267 Virtual Reality, 6-DOF Pose Tracking with the VRduino  
     &lt;/pre&gt;
     &lt;pre&gt;
     J = J_f * J_g where p is the parameter vector [thetas, translations]
                   where J_g = dh/dp 
                         where h is the 2-D projection matrix of size 3x3 as
                         2 columns of rotation and last column is translation
                   and 
                   where J_f = df/dh 
                         where f is the world point transformed by the homography h.
         J = df/dp
     &lt;/pre&gt;
     * @param worldC
     * @param h
     * @param thetas
     * @return matrix size (2N) X 6
     */
    static double[][] calculateJ(double[][] worldC, double[] h, double[] thetas) {
        //(2N) X 9
<span class="fc" id="L566">        double[][] jF = calculateJF(worldC, h);</span>
        //9 X 6
<span class="fc" id="L568">        double[][] jG = calculateJG(thetas);</span>
        // (2N)X6)
<span class="fc" id="L570">        double[][] j = MatrixUtil.multiply(jF, jG);</span>
<span class="fc" id="L571">        return j;</span>
    }
    
    /**
     &lt;pre&gt;
     J_f = df/dh 
         where f is the world point transformed by the homography h.
     &lt;/pre&gt;
     &lt;pre&gt; 
     Sect 6.1 of George Wetzstein Stanford Course Notes 
     for EE 267 Virtual Reality, 6-DOF Pose Tracking with the VRduino  
     &lt;/pre&gt;
     * @param worldC
     * @param h
     * @return a (2*n)X9 matrix
     */
    static double[][] calculateJF(double[][] worldC, double[] h) {
        
<span class="fc" id="L589">        int n = worldC[0].length;</span>
        
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (n &lt; 4) {</span>
<span class="nc" id="L592">            throw new IllegalArgumentException(&quot;need at least 4 features in worldC&quot;);</span>
        }
        
        //TODO: assert worldC[2][*] = 1 for local device frame
<span class="pc bpc" id="L596" title="3 of 4 branches missed.">        assert(Math.abs(worldC[2][0] - 1.) &lt; 1e-5);</span>
        
        // (2*n) X 9
<span class="fc" id="L599">        double[][] jF = MatrixUtil.zeros(2*n, 9);</span>
        int i, j;
        double x, y, s1, s2, d, dsq;
<span class="fc bfc" id="L602" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L603">            x = worldC[0][i];</span>
<span class="fc" id="L604">            y = worldC[1][i];</span>
<span class="fc" id="L605">            d = h[6] * x + h[7] * y + h[8];</span>
<span class="fc" id="L606">            s1 = h[0] * x + h[1] * y + h[2];</span>
<span class="fc" id="L607">            s2 = h[3] * x + h[4] * y + h[5];</span>
<span class="fc" id="L608">            dsq = s1*s1;</span>
            
<span class="fc" id="L610">            jF[2*i][0] = x/d;</span>
<span class="fc" id="L611">            jF[2*i][1] = y/d;</span>
<span class="fc" id="L612">            jF[2*i][2] = 1./d;</span>
<span class="fc" id="L613">            jF[2*i][6] = -(s1/dsq)*x;</span>
<span class="fc" id="L614">            jF[2*i][7] = -(s1/dsq)*y;</span>
<span class="fc" id="L615">            jF[2*i][8] = -(s1/dsq);</span>
            
<span class="fc" id="L617">            jF[2*i + 1][3] = x/d;</span>
<span class="fc" id="L618">            jF[2*i + 1][4] = y/d;</span>
<span class="fc" id="L619">            jF[2*i + 1][5] = 1./d;</span>
<span class="fc" id="L620">            jF[2*i + 1][6] = -(s2/dsq)*x;</span>
<span class="fc" id="L621">            jF[2*i + 1][7] = -(s2/dsq)*y;</span>
<span class="fc" id="L622">            jF[2*i + 1][8] = -(s2/dsq);</span>
        }
<span class="fc" id="L624">        return jF;</span>
    }
    
    static void calculateJF(double[] worldC, double[] h, double[][] outJF) {
        
        //TODO: assert worldC[2] = 1 for local device frame
        //assert(Math.abs(worldC[2] - 1.) &lt; 1e-5);
        
<span class="nc bnc" id="L632" title="All 4 branches missed.">        assert(outJF.length == 2);</span>
<span class="nc bnc" id="L633" title="All 4 branches missed.">        assert(outJF[0].length == 9);</span>
        
        int i, j;
        double x, y, s1, s2, d, dsq;
<span class="nc" id="L637">        x = worldC[0];</span>
<span class="nc" id="L638">        y = worldC[1];</span>
<span class="nc" id="L639">        d = h[6] * x + h[7] * y + h[8];</span>
<span class="nc" id="L640">        s1 = h[0] * x + h[1] * y + h[2];</span>
<span class="nc" id="L641">        s2 = h[3] * x + h[4] * y + h[5];</span>
<span class="nc" id="L642">        dsq = s1*s1;</span>

<span class="nc" id="L644">        outJF[0][0] = x/d;</span>
<span class="nc" id="L645">        outJF[0][1] = y/d;</span>
<span class="nc" id="L646">        outJF[0][2] = 1./d;</span>
<span class="nc" id="L647">        outJF[0][6] = -(s1/dsq)*x;</span>
<span class="nc" id="L648">        outJF[0][7] = -(s1/dsq)*y;</span>
<span class="nc" id="L649">        outJF[0][8] = -(s1/dsq);</span>

<span class="nc" id="L651">        outJF[1][3] = x/d;</span>
<span class="nc" id="L652">        outJF[1][4] = y/d;</span>
<span class="nc" id="L653">        outJF[1][5] = 1./d;</span>
<span class="nc" id="L654">        outJF[1][6] = -(s2/dsq)*x;</span>
<span class="nc" id="L655">        outJF[1][7] = -(s2/dsq)*y;</span>
<span class="nc" id="L656">        outJF[1][8] = -(s2/dsq);</span>
<span class="nc" id="L657">    }</span>
    
    /**
    &lt;pre&gt;
     J_g = dh/dp 
         where h is the 2-D projection matrix of size 3x3 as
         2 columns of rotation and last column is translation
    &lt;/pre&gt;
    &lt;pre&gt; 
     Sect 6.1 of George Wetzstein Stanford Course Notes 
     for EE 267 Virtual Reality, 6-DOF Pose Tracking with the VRduino  
     &lt;/pre&gt;
     * @param thetas
     * @return 9X6 matrix
     */
    static double[][] calculateJG(double[] thetas) {
                        
        // 9 X 6
<span class="fc" id="L675">        double[][] jG = new double[9][6];//MatrixUtil.zeros(9, 6);</span>
        double cx, cy, cz, sx, sy, sz;
<span class="fc" id="L677">        cx = Math.cos(thetas[0]);</span>
<span class="fc" id="L678">        cy = Math.cos(thetas[1]);</span>
<span class="fc" id="L679">        cz = Math.cos(thetas[2]);</span>
<span class="fc" id="L680">        sx = Math.sin(thetas[0]);</span>
<span class="fc" id="L681">        sy = Math.sin(thetas[1]);</span>
<span class="fc" id="L682">        sz = Math.sin(thetas[2]);</span>
        
<span class="fc" id="L684">        jG[0] = new double[]{-cx*sy*sz, -sy*cz-sx*cy*sz, -cy*sz-sx*sy*cz,</span>
           0, 0, 0};
        
<span class="fc" id="L687">        jG[1] = new double[]{sx*sz, 0, -cx*cz, 0, 0, 0};</span>
        
<span class="fc" id="L689">        jG[2] = new double[]{0, 0, 0, 1, 0, 0};</span>
        
<span class="fc" id="L691">        jG[3] = new double[]{cx*sy*cz, -sy*sz+sx*cy*cz, cy*cz-sx*sy*sz, 0, 0, 0};</span>
        
<span class="fc" id="L693">        jG[4] = new double[]{-sx*cz, 0, -cx*sz, 0, 0, 0};</span>
        
<span class="fc" id="L695">        jG[5] = new double[]{0, 0, 0, 0, 1, 0};</span>
        
<span class="fc" id="L697">        jG[6] = new double[]{-sx*sy, cx*cy, 0, 0, 0, 0};</span>
        
<span class="fc" id="L699">        jG[7] = new double[]{-cx, 0, 0, 0, 0, 0};</span>
        
<span class="fc" id="L701">        jG[8] = new double[]{0, 0, 0, 0, 0, -1};</span>
        
<span class="fc" id="L703">        return jG;</span>
    }
    
    /**
     * following Szeliski 2010, Chap 6, eqn (6.18)
     * @param jTJ J^T * J.  size is 6X6.
     * @param lambda
     * @param jTBFG J^T * (B-F(g(p))). size is 6X1
     * @param outDeltaP calculated step length
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    private static void calculateDeltaPLMSzeliski(double[][] jTJ, 
        double lambda, double[] jTBFG, double[] outDeltaP) throws NotConvergedException {
                
        //                        [6X6]                   * [6X1] = [6X1]
        //delta p = pseudoInv(J^T*J + lambda*diag(J^T*J)) * J^T*BFG
        
        int i, j;
        // J^T J + λ diag(J^TJ)     
        // [6X6]
<span class="fc" id="L723">        double[][] a = MatrixUtil.copy(jTJ);</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        for (i = 0; i &lt; 6; ++i) {</span>
<span class="fc" id="L725">            a[i][i] += (lambda*(jTJ[i][i]));</span>
        }
        //[6X6]
<span class="fc" id="L728">        double[][] aInv = MatrixUtil.pseudoinverseRankDeficient(a);</span>
                
        //[6X6] * [6X1] = [6X1]
<span class="fc" id="L731">        MatrixUtil.multiplyMatrixByColumnVector(aInv, jTBFG, outDeltaP);        </span>
<span class="fc" id="L732">    }</span>
        
    /**
     * from lecture notes of Danping Zou
     * http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf
     *                          6X6  * (6 * (2N)) * (2NX1) = 6 X (2N) * (2NX1) = 6X1
     * calculate the step as (J^T*J + lambda*I)^-1 * J^T * (b-f(g(p))
     * @param jTJ 
     * @param lambda
     * @param jTBF
     * @return an array of length 6 
     * @throws NotConvergedException 
     */
    private static double[] calculateDeltaPLM(double[][] jTJ, 
        double lambda, double[] jTBF) throws NotConvergedException {
        
        // (J^T*J + lambda*I)^-1 * J^T * (b-f(g(p))
<span class="nc" id="L749">        double[][] identity = MatrixUtil.createIdentityMatrix(6);</span>
<span class="nc" id="L750">        MatrixUtil.multiply(identity, lambda);</span>
        // 6 X 6
<span class="nc" id="L752">        double[][] a = MatrixUtil.elementwiseAdd(jTJ, identity);</span>
<span class="nc" id="L753">        double[][] aInv = MatrixUtil.pseudoinverseFullColumnRank(a);</span>
        
<span class="nc" id="L755">        double[] step = MatrixUtil.multiplyMatrixByColumnVector(aInv, jTBF);</span>
        
<span class="nc" id="L757">        return step;</span>
    }
    
    /**
     * gain = (f(p) - f(p + delta p)) / ell(delta p)
             where ell(delta p) is (delta p)^T * (lambda * (delta p)) + J^T * ( b - fgp))
       gain = (f - fPrev) / ( (delta p)^T * (lambda * (delta p) + J^T * ( b - fgp)) )
     * @param fNew
     * @param fPrev
     * @param deltaP
     * @param lambda
     * @param jTBFG j^T*(b-f(g(p))). size is 6X1
     * @return 
     */
    private static double calculateGainRatio(double fNew, double fPrev, 
        double[] deltaP, double lambda, double[] jTBFG,
        double eps) {
        
        // (M. Lourakis, A. Argyros: SBA: A Software Package For Generic
        // Sparse Bundle Adjustment. ACM Trans. Math. Softw. 36(1): (2009))
        //  gain ratio = ( fPrev - fNew) / ( deltaP^T * (lambda * deltaP + J^T*fPrev) )
        
        
        //   1X6         *    ([1X1]*[6X1]         + [6X1])           = [1X1]
        //(delta p LM)^T *  (lambda * (delta p LM) + J^T * (b - fgp))
        
             
        //      1X6          *            ( 6X1   +   6 X (2N) * (2NX1) )
        //      1X6                        6X1 
        //  1X1
        //(delta p LM)^T * (lambda * (delta p LM) + J^T * (b - fgp))
<span class="fc" id="L788">        double[] denom = Arrays.copyOf(deltaP, deltaP.length);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        for (int i = 0; i &lt; denom.length; ++i) {</span>
<span class="fc" id="L790">            denom[i] *= lambda;</span>
        }
        
<span class="fc" id="L793">        denom = MatrixUtil.add(denom, jTBFG);</span>
        
<span class="fc" id="L795">        double d = MatrixUtil.innerProduct(deltaP, denom);</span>
        
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (Math.abs(d) &lt; eps) {</span>
<span class="fc" id="L798">            return Double.NEGATIVE_INFINITY;</span>
        }
        
<span class="fc" id="L801">        double gain = (fPrev - fNew)/d;</span>
        
<span class="fc" id="L803">        return gain;</span>
    }

    private static boolean isNegligible(double[] c, double eps) {
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">            if (Math.abs(c[i]) &gt; eps) {</span>
<span class="nc" id="L809">                return false;</span>
            }
        }
<span class="fc" id="L812">        return true;</span>
    }

    private static void populateHWithRT(double[] h, double[][] r, double[] t) {
<span class="fc" id="L816">        h[0] = r[0][0];</span>
<span class="fc" id="L817">        h[1] = r[0][1];</span>
<span class="fc" id="L818">        h[2] = t[0];</span>
<span class="fc" id="L819">        h[3] = r[1][0];</span>
<span class="fc" id="L820">        h[4] = r[1][1];</span>
<span class="fc" id="L821">        h[5] = t[1];</span>
        // TODO: review the code for right-handedness vs left-handedness.
        //    Wetzstein convention looks down the negative z-axis.
        //    (see Rotation.java notes). may need transposition...
        //h[6] = -r[2][0];
        //h[7] = -r[2][1];
        //h[8] = -t[2];
<span class="fc" id="L828">        h[6] = r[2][0];</span>
<span class="fc" id="L829">        h[7] = r[2][1];</span>
<span class="fc" id="L830">        h[8] = t[2];</span>
<span class="fc" id="L831">    }</span>
    
    /**
     * 
     * @param h input and output variable homography to be updated with given
     * rotation angles and translations.
     * @param thetas
     * @param t 
     */
    private static void updateHWithThetaT(double[] h, double[] thetas, double[] t) {
        // equation (19).  size is 1 X 9
        
<span class="nc" id="L843">        double cx = Math.cos(thetas[0]);</span>
<span class="nc" id="L844">        double cy = Math.cos(thetas[1]);</span>
<span class="nc" id="L845">        double cz = Math.cos(thetas[2]);</span>
<span class="nc" id="L846">        double sx = Math.sin(thetas[0]);</span>
<span class="nc" id="L847">        double sy = Math.sin(thetas[1]);</span>
<span class="nc" id="L848">        double sz = Math.sin(thetas[2]);</span>
        
<span class="nc" id="L850">        h[0] = cy*cz - sx*sy*sz;</span>
<span class="nc" id="L851">        h[1] = -cx*sz;</span>
<span class="nc" id="L852">        h[2] = t[0];</span>
<span class="nc" id="L853">        h[3] = cy*sz + sx*sy*cz;</span>
<span class="nc" id="L854">        h[4] = cx*cz;</span>
<span class="nc" id="L855">        h[5] = t[1];</span>
<span class="nc" id="L856">        h[6] = cx*sy;</span>
<span class="nc" id="L857">        h[7] = -sx;</span>
<span class="nc" id="L858">        h[9] = -t[2];</span>
<span class="nc" id="L859">    }</span>

    /**
     * update translation t by deltaT
     */
    private static void updateT(double[] t, double[] deltaT) {
        // from Danping Zou lecture notes, Shanghai Jiao Tong University,
        // EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
        // http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

        // parameter perturbations for a vector are 
        //     x + delta x
        int i;
        
        // vector perturbation for translation:
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L875">            t[i] += deltaT[i];</span>
        }
<span class="fc" id="L877">    }</span>
    
    private static void updateT(double[] t, double[] deltaT, double[][] r) {
        // t_local(t + deltaT) = t + r*deltaT
        int i;
        
<span class="nc" id="L883">        double[] rdt = MatrixUtil.multiplyMatrixByColumnVector(r, deltaT);</span>
        
        // vector perturbation for translation:
<span class="nc bnc" id="L886" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L887">            t[i] += rdt[i];</span>
        }
<span class="nc" id="L889">    }</span>
    
    /**
     * update rotation matrix r with deltaTheta.
     * the approach used avoids singularities and the need to restore 
     * the constraint afterwards (i.e., constraint restoration is built in).
     * 
     * @param r
     * @param thetas input and output array holding euler rotation angles 
     *    theta_x, theta_y, theta_
     * @param deltaTheta
     */
    private static void updateRTheta(double[][] r, double[] thetas, double[] deltaTheta) {
        // from Danping Zou lecture notes, Shanghai Jiao Tong University,
        // EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
        // http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf
        // parameter perturbations for a Lie group such as rotation are:
        //     R * (I - [delta x]_x) where [delta x]_x is the skew-symetric matrix of delta_x 
        
        // T. Barfoot, et al. 2010, 
        // Pose estimation using linearized rotations and quaternion algebra, 
        // Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
        // eqn (31) for updating rotation:
        // C(theta) = C(deltaPhi) * previous C
        //     where C is rotation matrix r
        //           calculated as C(theta) = 
        //     and deltaPhi = sTheta * deltaTheta
        
        //double[][] out;// = MatrixUtil.zeros(3, 3);
<span class="fc" id="L918">        double[] qUpdated = Rotation.applySingularitySafeRotationPerturbationQuaternion(thetas, deltaTheta);</span>
        
        // [4X4]
<span class="fc" id="L921">        double[][] qR = Rotation.createRotationMatrixFromQuaternion4(qUpdated);</span>
<span class="fc" id="L922">        qR = MatrixUtil.transpose(qR);</span>
        
        // rotation is [0:2, 0:2] of qR  
                
        // update in-out variable r
<span class="fc bfc" id="L927" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L928">            System.arraycopy(qR[i], 0, r[i], 0, 3);</span>
        }

        // ---- update theta ----        
        //extracting theta from the updated rotation would keep the theta
        //    vector consistent with the rotation matrix,
        //    but the value is a little different that updating theta with delta theta
        //    by addition.
<span class="fc" id="L936">        double[] thetaExtracted = Rotation.extractThetaFromZYX(r);</span>
<span class="fc" id="L937">        System.arraycopy(thetaExtracted, 0, thetas, 0, thetas.length);</span>
        
        /*
        for (int i = 0; i &lt; 3; ++i) {
            thetas[i] += deltaTheta[i];
        }*/
        
<span class="fc" id="L944">    }</span>

    /**
     * initialize the first parameter steps with small values suggested
     * by Qu.
     * @param deltaP 
     */
    private static void initDeltaPWithQu(double[] deltaP) {
        /*Qu thesis eqn (3.38)
        
        delta thetas ~ 1e-8
        delta translation ~1e-5
        delta focus ~ 1
        delta kRadial ~ 1e-3
        delta x ~ 1e-8
        */
        int i;
<span class="fc bfc" id="L961" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
            // delta theta
<span class="fc" id="L963">            deltaP[i] = 1e-8;</span>
        }
<span class="fc bfc" id="L965" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
            // delta translation
<span class="fc" id="L967">            deltaP[3+i] = 1e-5;</span>
        }
        
<span class="fc" id="L970">    }</span>

    private static double maxDiag(double[][] jTJ) {
<span class="fc" id="L973">        double max = Double.NEGATIVE_INFINITY;</span>
        //Arrays.fill(max, Double.NEGATIVE_INFINITY);
<span class="fc bfc" id="L975" title="All 2 branches covered.">        for (int i = 0; i &lt; jTJ.length; ++i) {</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">            if (jTJ[i][i] &gt; max) {</span>
<span class="fc" id="L977">                max = jTJ[i][i];</span>
            }
        }
<span class="fc" id="L980">        return max;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
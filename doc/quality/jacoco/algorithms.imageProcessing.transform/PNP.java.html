<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PNP.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">PNP.java</span></div><h1>PNP.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters;
import algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters;
import algorithms.matrix.MatrixUtil;
import algorithms.util.FormatArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import no.uib.cipr.matrix.NotConvergedException;

/**
 * NOT READY FOR USE.
 * iterative non-linear optimization using Levenberg-Marquardt algorithm
 * to minimize the re-projection error of perspective projection
 * in &quot;perspective-n-point&quot;.
 * 
 * L-M is guaranteed to converge to eventually find an improvement, 
 * because an update with a sufficiently small magnitude and a negative scalar 
 * product with the gradient is guaranteed to do so.
 * 
 * TODO: consider implementing the Szeliski 2010 chapter 6 equations (6.44)-(6.47)
 * 
 * NOTE: this implementation uses euler rotation angles and singularity safe
 * updates, but future versions could consider using quaternions.
 * This from Szeliski 2010:
   ...&quot;Quaternions, on the other hand, are better if you want to keep track of 
   a smoothly moving camera, since there are no discontinuities in the 
   representation. It is also easier to interpolate between rotations and to 
   chain rigid transformations (Murray, Li, and Sastry 1994; Bregler and Malik 1998).
   My usual preference is to use quaternions, but to update their estimates 
   using an incremental rotation, as described in Section 6.2.2.&quot;
 * @author nichole
 */
<span class="pc" id="L35">public class PNP {</span>
    
    /**
     * NOT YET TESTED.
     * given the fixed intrinsic camera calibration for the single camera
     * used in all images,
     * and given the initial estimates
     * of extrinsic camera parameters for each image, use the 
     * Levenberg-Marquardt algorithm to improve the extrinsic camera parameters rotation and translation 
     * by minimizing the re-projection error using feature 
     * measurements and their world coordinates.
     * NOTE: this is a dense Hessian matrix solver, not the sparse Hessian
     * matrix bundle adjustment which is in BundleAdjustment.java.
     * &lt;pre&gt;
     References:
     
     Gordon Wetzstein lecture notes, Stanford University, EE 267 Virtual Reality, 
     &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
       https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     Danping Zou lecture notes, Shanghai Jiao Tong University,
     EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
     http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

     Szeliski 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Chapter 6
     
     * &lt;/pre&gt;
     * @param imageC observed features in one image followed by the same observed
     * features in the next image, etc. format of double array with
     * first dimension length 3 (for x, y, z) and the second dimension length
     * of nFeatures * mImages. 
     * @param worldC world scene features in format of double array with
     * first dimension length 3 (for x, y, z) and the second dimension length
     * of nFeatures.
     * @param kIntr
     * @param kExtrs
     * @param nMaxIter
     *
     * @throws Exception if there is an error in use of MPSolver during the
     * removal of radial distortion, a generic exception is thrown with the
     * error message from the MPSolve documentation.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static List&lt;CameraExtrinsicParameters&gt; solveForPose(double[][] imageC, double[][] worldC, 
        CameraIntrinsicParameters kIntr, 
        List&lt;CameraExtrinsicParameters&gt; kExtrs, final int nMaxIter)
        throws NotConvergedException, Exception {
        
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (imageC.length != 3) {</span>
<span class="nc" id="L85">            throw new IllegalArgumentException(&quot;imageC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (worldC.length != 3) {</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;worldC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
        
<span class="fc" id="L91">        int nFeatures = worldC[0].length;</span>
        
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (nFeatures &lt; 4) {</span>
<span class="nc" id="L94">            throw new IllegalArgumentException(&quot;worldC[0].length must be at least 4&quot;);</span>
        }
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if ((imageC[0].length % nFeatures) != 0) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;imageC[0].length must be an integer multiple of worldC[0].length&quot;);</span>
        }
        
<span class="fc" id="L100">        int nImages = imageC[0].length/nFeatures;</span>
        
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (kExtrs.size() != nImages) {</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;from imageC[0].length, &quot;</span>
               + &quot;nImages is expected to be &quot; + nImages
               + &quot; therefore kExtrs.size() should be &quot; + nImages + &quot; also.&quot;);
        }

<span class="fc" id="L108">        List&lt;CameraExtrinsicParameters&gt; refined = new ArrayList&lt;CameraExtrinsicParameters&gt;();</span>
        
<span class="fc" id="L110">        double[][] imageCI = MatrixUtil.zeros(3, nFeatures);</span>
        
        CameraExtrinsicParameters r;
        
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (int i = 0; i &lt; nImages; ++i) {</span>
            
<span class="fc" id="L116">            MatrixUtil.copySubMatrix(imageC, 0, 2, i*nFeatures, i*nFeatures+nFeatures-1, imageCI);</span>
            
<span class="fc" id="L118">            r = solveForPose(imageCI, worldC, kIntr, kExtrs.get(i), nMaxIter);</span>
            
<span class="fc" id="L120">            refined.add(r);</span>
        }
<span class="fc" id="L122">        return refined;</span>
    }
    
    /**
     * NOT YET TESTED.
     * given the fixed intrinsic camera calibration and the initial estimates
     * of extrinsic camera parameters as lists of the same size, each item being
     * for a single image, use the 
     * Levenberg-Marquardt algorithm to improve the extrinsic camera parameters rotation and translation 
     * by minimizing the re-projection error using feature 
     * measurements and their world coordinates.
     * NOTE: this is a dense Hessian matrix solver, not the sparse Hessian
     * matrix bundle adjustment which is in BundleAdjustment.java.
     * &lt;pre&gt;
     References:
     
     Gordon Wetzstein lecture notes, Stanford University, EE 267 Virtual Reality, 
     &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
       https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     Danping Zou lecture notes, Shanghai Jiao Tong University,
     EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
     http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

     Szeliski 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Chapter 6
     
     * &lt;/pre&gt;
     * @param imageC
     * @param worldC
     * @param kIntrs
     * @param kExtrs
     * @param nMaxIter
     * @throws Exception if there is an error in use of MPSolver during the
     * removal of radial distortion, a generic exception is thrown with the
     * error message from the MPSolve documentation.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static List&lt;CameraExtrinsicParameters&gt; solveForPose(double[][] imageC, double[][] worldC, 
        List&lt;CameraIntrinsicParameters&gt; kIntrs, 
        List&lt;CameraExtrinsicParameters&gt; kExtrs, final int nMaxIter)
        throws NotConvergedException, Exception {
        
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (kIntrs.size() != kExtrs.size()) {</span>
<span class="nc" id="L166">            throw new IllegalArgumentException(&quot;the sizes of Kintrs and kExtrs must be the same&quot;);</span>
        }
        
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (imageC.length != 3) {</span>
<span class="nc" id="L170">            throw new IllegalArgumentException(&quot;imageC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (worldC.length != 3) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;worldC.length must be 3 for the x,y,z dimensions&quot;);</span>
        }
        
<span class="nc" id="L176">        int nFeatures = worldC[0].length;</span>
        
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (nFeatures &lt; 4) {</span>
<span class="nc" id="L179">            throw new IllegalArgumentException(&quot;worldC[0].length must be at least 4&quot;);</span>
        }
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if ((imageC[0].length % nFeatures) != 0) {</span>
<span class="nc" id="L182">            throw new IllegalArgumentException(&quot;imageC[0].length must be an integer multiple of worldC[0].length&quot;);</span>
        }
        
<span class="nc" id="L185">        int nImages = imageC[0].length/nFeatures;</span>
        
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (kExtrs.size() != nImages) {</span>
<span class="nc" id="L188">            throw new IllegalArgumentException(&quot;from imageC[0].length, &quot;</span>
               + &quot;nImages is expected to be &quot; + nImages
               + &quot; therefore kExtrs.size() should be &quot; + nImages + &quot; also.&quot;);
        }
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (kIntrs.size() != nImages) {</span>
<span class="nc" id="L193">            throw new IllegalArgumentException(&quot;from imageC[0].length, &quot;</span>
               + &quot;nImages is expected to be &quot; + nImages
               + &quot; therefore kIntrs.size() should be &quot; + nImages + &quot; also.&quot;);
        }

<span class="nc" id="L198">        List&lt;CameraExtrinsicParameters&gt; refined = new ArrayList&lt;CameraExtrinsicParameters&gt;();</span>
        
<span class="nc" id="L200">        double[][] imageCI = MatrixUtil.zeros(3, nFeatures);</span>
        
        CameraExtrinsicParameters r;
        
<span class="nc bnc" id="L204" title="All 2 branches missed.">        for (int i = 0; i &lt; nImages; ++i) {</span>
            
<span class="nc" id="L206">            MatrixUtil.copySubMatrix(imageC, 0, 2, i*nFeatures, i*nFeatures+nFeatures-1, imageCI);</span>
            
<span class="nc" id="L208">            r = solveForPose(imageCI, worldC, kIntrs.get(i), kExtrs.get(i), nMaxIter);</span>
            
<span class="nc" id="L210">            refined.add(r);</span>
        }
<span class="nc" id="L212">        return refined;</span>
    }
    
    /**
     * NOT YET TESTED.
     * given the camera intrinsic calibration  
     * and initial estimates for extrinsic camera parameters for an image, use the 
     * Levenberg-Marquardt algorithm to improve the extrinsic camera parameters rotation and translation 
     * estimates by minimizing the re-projection error using feature 
     * measurements and their world coordinates.
     * NOTE: this is a dense Hessian matrix solver, not the sparse Hessian
     * matrix bundle adjustment which is in BundleAdjustment.java.
     * &lt;pre&gt;
     References:
     
     Gordon Wetzstein lecture notes, Stanford University, EE 267 Virtual Reality, 
     &quot;Course Notes: 6-DOF Pose Tracking with the VRduino&quot;,
       https://stanford.edu/class/ee267/notes/ee267_notes_tracking.pdf
     
     Danping Zou lecture notes, Shanghai Jiao Tong University,
     EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
     http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

     Szeliski 2010, &quot;Computer Vision: Algorithms and Applications&quot;, Chapter 6
     
     * &lt;/pre&gt;
     * @param imageC
     * @param worldC
     * @param kIntr
     * @param kExtr
     * @param nMaxIter
     * @throws Exception if there is an error in use of MPSolver during the
     * removal of radial distortion, a generic exception is thrown with the
     * error message from the MPSolve documentation.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static CameraExtrinsicParameters solveForPose(double[][] imageC, double[][] worldC, 
        CameraIntrinsicParameters kIntr, 
        CameraExtrinsicParameters kExtr, final int nMaxIter)
        throws NotConvergedException, Exception {

<span class="fc" id="L254">        boolean useBouguetsRodrigues = false;</span>
        if (true) {
<span class="fc" id="L256">            return CameraPose.bouguetPoseRefine(kExtr, kIntr, imageC, worldC, useBouguetsRodrigues);</span>
        }

        if (imageC.length != 3) {
            throw new IllegalArgumentException(&quot;imageC.length must be 3 for the x,y,z dimensions&quot;);
        }
        if (worldC.length != 3) {
            throw new IllegalArgumentException(&quot;worldC.length must be 3 for the x,y,z dimensions&quot;);
        }
        
        // number of features
        int n = worldC[0].length;
        
        if (n &lt; 4) {
            throw new IllegalArgumentException(&quot;worldC[0].length must be at least 4&quot;);
        }
        if (imageC[0].length != n) {
            throw new IllegalArgumentException(&quot;imageC[0].length must equal worldC[0].length&quot;);
        }
        
        double[] b = new double[2*n];
        final double[][] xn = Camera.pixelToCameraCoordinates(imageC, kIntr);
        for (int i = 0; i &lt; n; ++i) {
            xn[0][i] /= xn[2][i];
            xn[1][i] /= xn[2][i];
            //TODO: follow up on signs from pixelToCameraCoordinates.
            b[2*i] = xn[0][i];
            b[2*i + 1] = xn[1][i];
        }
                
        //TODO: consider adding constraints suggested in Seliski 2010:
        // u_0 and v_0 are close to half the image lengths and widths, respectively.
        // the angle between 2 image axes is close to 90.
        // the focal lengths along both axes are greater than 0.
      
        // ==========  initialize ===================
        
        // extract pose as (theta_x, theta_y, theta_z, t_x, t_y, t_z)
        double[][] rTest = MatrixUtil.copy(kExtr.getRotation());
        double[] thetasTest = Rotation.extractThetaFromZYX(rTest);
        double[] tTest = Arrays.copyOf(kExtr.getTranslation(), 4);
        
        CameraExtrinsicParameters outExtr = new CameraExtrinsicParameters();
        outExtr.setRotation(MatrixUtil.copy(kExtr.getRotation()));
        outExtr.setTranslation(Arrays.copyOf(kExtr.getTranslation(), 4));
        
//TODO: check the signs of the last row.  wetzstein uses a convention of looking down
//the negative z-axis.
        
        // equation (19).  size is 1 X 9
        double[] h = new double[9];
        populateHWithRT(h, rTest, tTest);
        
        // eqn (20) of Wetzstein.  length is 2*N
        // project the world coordinates to the camera coord frame, using R and T in h:
        double[] fgp = transformToCamera(worldC, h);
        
        // in camera reference frame, subtract the projected world points from the observations:
        // length is 2*N
        double[] bMinusFGP = MatrixUtil.subtract(b, fgp);   
                
// the projected x and y have opposite signs than they should      
        System.out.printf(&quot;observed in camera ref frame=\n%s\n&quot;,
            FormatArray.toString(b, &quot;%.3e&quot;));
        System.out.printf(&quot;world feature projected to camera ref frame=\n%s\n&quot;,
            FormatArray.toString(fgp, &quot;%.3e&quot;));
        System.out.printf(&quot;(observed-projected) in camera ref frame=\n%s\n&quot;,
            FormatArray.toString(bMinusFGP, &quot;%.3e&quot;));
        
        // sum the squares to evaluate the re-projection error:
        double fPrev = evaluateObjective(bMinusFGP);
        double fTest = Double.POSITIVE_INFINITY;
        
        // size is (2N) X 6
        double[][] j = calculateJ(worldC, h, thetasTest);
        
        // size is 6 X (2N)
        double[][] jT = MatrixUtil.transpose(j);
        // size is 6 X 6
        double[][] jTJ = MatrixUtil.multiply(jT, j);
        
        double lambda = maxDiag(jTJ);
        System.out.printf(&quot;max diag of Hessian lambda=%.7e\n&quot;, lambda);

        //factor to raise or lower lambda.  
        //   consider using the eigenvalue spacing of J^T*J (Transtrum &amp; Sethna, &quot;Improvements to the Levenberg-Marquardt algorithm for nonlinear least-squares minimization&quot;)
        final double lambdaF = 2;
                
        // deltaP is the array of length 6 holding the steps of change for theta and translation.
        double[] deltaP = new double[6];
        
        // deltaTheta is used to extract the 1st 3 elements of deltaPM 
        double[] deltaTheta = new double[3];
        // deltaT is used to extract the last 3 elements of deltaPLM
        double[] deltaT = new double[3];
                
        double eps = 1E-12;
        
        double gainRatio;
        
        double[] gradient = MatrixUtil.multiplyMatrixByColumnVector(jT, bMinusFGP);
        
        final double tolP = 1.e-3;
        final double tolG = 1.e-3;
        
        int nIter = 0;
        //begin loop of tentative changes
        while ((nIter &lt; nMaxIter) &amp;&amp; (Math.abs(fPrev - fTest) &gt;= eps)) {
            
            if (nIter == 0) {
                initDeltaPWithQu(deltaP);
            } else {
                calculateDeltaPLMSzeliski(jTJ, lambda, gradient, deltaP);
            }

            nIter++;
            
            // p is (theta_x, theta_y, theta_z, t_x, t_y, t_z)
            System.arraycopy(deltaP, 0, deltaTheta, 0, 3);
            System.arraycopy(deltaP, 3, deltaT, 0, 3);
            updateT(tTest, deltaT);
            updateRTheta(rTest, thetasTest, deltaTheta);

            populateHWithRT(h, rTest, tTest);
            
            // eqn (20) of Wetzstein.  length is 2*N
            // project the world coordinates to the camera coord frame, using R and T in h:
            fgp = transformToCamera(worldC, h);
            // in camera reference frame, subtract the projected world points from the observations:
            bMinusFGP = MatrixUtil.subtract(b, fgp);   
            // sum the squares:
            fTest = evaluateObjective(bMinusFGP);
            
            System.out.printf(&quot;nIter=%d) fPrev=%.11e, fTest=%.11e  diff=%.11e\n&quot;, nIter, fPrev, fTest,
                (fPrev-fTest));
            System.out.flush();

            // ===== calculate step ========
            // eqns (24-34) of Wetzstein
            j = calculateJ(worldC, h, thetasTest); // 2NX6
            jT = MatrixUtil.transpose(j); // 6X2N
            jTJ = MatrixUtil.multiply(jT, j); // 6X6
           
            //gradient is the local direction of steepest ascent
            // 6X1
            gradient = MatrixUtil.multiplyMatrixByColumnVector(jT, bMinusFGP);
            
            System.out.printf(&quot;\nj^T*(b-fgp)=%s\n&quot;, FormatArray.toString(gradient, &quot;%.3e&quot;));
            System.out.printf(&quot;deltaP=%s\n&quot;, FormatArray.toString(deltaP, &quot;%.3e&quot;));
        
            gainRatio = calculateGainRatio(fTest, fPrev, deltaP, lambda, 
                gradient, eps);
            
            if (gainRatio &lt;= Double.NEGATIVE_INFINITY) {
                break;
            }
            
            System.out.printf(&quot;lambda=%.6e\ngainRatio=%.6e\nfPrev=%.11e, fTest=%.11e\n&quot;, 
                lambda, gainRatio, fPrev, fTest);
            System.out.flush();

            /*
            for large values of lambda, the update is a very steep descent and
            deltaP is very small.
            If the damping term is small the approach is a nearly linear problem.
            
            NOTE: the damping term is used like a factor in the perturbation
            of a symmetric matrix.  see:
                https://nhigham.com/2021/02/16/diagonally-perturbing-a-symmetric-matrix-to-make-it-positive-definite/
            */
            if (gainRatio &gt; 0) {
                // near the minimimum, which is good.
                // decrease lambda
                lambda /= lambdaF;
                assert(fTest &lt; fPrev);
                fPrev = fTest;
                
                System.out.printf(&quot;fPrev updated to fTest: fPrev=%.11e fTest=%.11e\n&quot;, fPrev, fTest);
                System.out.flush();
                
                System.out.printf(&quot;pointwise diff in rotation:\n%s\n&quot;, 
                    FormatArray.toString(MatrixUtil.pointwiseSubtract(outExtr.getRotation(), rTest),
                    &quot;%.11e&quot;));
            
                outExtr.setRotation(MatrixUtil.copy(rTest));
                outExtr.setTranslation(Arrays.copyOf(tTest, 3));
                
                // ======= stopping conditions ============
                //   step length vanishes:  deltaPLM --&gt; 0
                //   gradient of f(x) vanishes: -J^T * (b - fgp) --&gt; 0
                //MatrixUtil.multiply(gradientCheck, -1.);            
                if (isNegligible(deltaP, tolP) || isNegligible(gradient, tolG)) {
                    break;
                }
                
            } else {
                // increase lambda to reduce step length and get closer to 
                // steepest descent direction
                lambda *= lambdaF;
            }
            System.out.printf(&quot;new lambda=%.6e\n&quot;, lambda);    
        }
        
        return outExtr;
         
        /*
        Initialization: A = J^T*J, lambda=max{a_i_i}
        • Repeat until the step length vanishes, || delta x_LM || --&gt; 0, 
          or the gradient of f(x) vanishes, del f = -J^T * r --&gt; 0
          a) Solve (A + lambda*I)*(delta x) = J^T*r to get delta x_LM
          b) x = x + (delta x_LM)
          c) Adjust the damping parameter by checking the gain ratio
             1. gain &gt; 0 Good approximation, decrease the damping parameter
             2. gain &lt;= 0 Bad approximation, increase the damping parameter
        
        where r_i(x) = y_i - h_i(x) where y_i are the measurements
           and h_i(x) are the projections.
        where delta x_LM = = (J^T*J + lambda*I)^-1 * J^T * r
        where f(x) = (1/2) * || r(x) ||^2
        where rho = (f(x + (delta x_LM)) - f(x)) / (ell(delta x_LM))
        
        where the incremental of the objective function predicted by the 
           linear model is given by
              ell(delta x) = - (delta x)^T * J^T * J * (delta x) - 2*(delta x)^T * J^T * r
        where the incremental predicted by the LM step is computed as
              ell(delta x_LM) = - (delta x)^T * (lambda * (delta x_LM) + J^T*r)
        */
    }
    
    /**
     * use the homography matrix to the project the world reference points
     * to 2D point coordinates in the camera frame.  eqn (20).
     * @param worldC
     * @param h
     * @return 
     */
    static double[] transformToCamera(double[][] worldC, double[] h) {
        
<span class="nc" id="L494">        int n = worldC[0].length;</span>
        
<span class="nc" id="L496">        double[] f = new double[2*n];</span>
        
        int i, j;
        double X, Y, s;
<span class="nc bnc" id="L500" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L501">            X = worldC[0][i];</span>
<span class="nc" id="L502">            Y = worldC[1][i];</span>
<span class="nc" id="L503">            s = h[6]*X + h[7]*Y + h[8];</span>
            
<span class="nc" id="L505">            f[2*i] = (h[0]*X + h[1]*Y + h[2])/s;</span>
<span class="nc" id="L506">            f[2*i+1] = ((h[3]*X + h[4]*Y + h[5])/s); </span>
        }
        
<span class="nc" id="L509">        return f;</span>
    }
    
    /**
     * evaluate the objective (|| b − f (g (p)) ||_2)^2
     * eqn (21)
     * @param bMinusFGP array b - f(g(p))
     * @return 
     */
    static double evaluateObjective(double[] bMinusFGP) {
        
<span class="nc" id="L520">        int n = bMinusFGP.length;</span>
        
<span class="nc" id="L522">        double sum = 0;</span>
        int i;
<span class="nc bnc" id="L524" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L525">            sum += (bMinusFGP[i] * bMinusFGP[i]);</span>
        }
        
<span class="nc" id="L528">        return sum;</span>
    }
    
    /**
     * calculate J for extrinsic parameters in solving pose
     &lt;pre&gt; 
     Sect 6.1 of George Wetzstein Stanford Course Notes 
     for EE 267 Virtual Reality, 6-DOF Pose Tracking with the VRduino  
     &lt;/pre&gt;
     &lt;pre&gt;
     J = J_f * J_g where p is the parameter vector [thetas, translations]
                   where J_g = dh/dp 
                         where h is the 2-D projection matrix of size 3x3 as
                         2 columns of rotation and last column is translation
                   and 
                   where J_f = df/dh 
                         where f is the world point transformed by the homography h.
         J = df/dp
     &lt;/pre&gt;
     * @param worldC
     * @param h
     * @param thetas
     * @return matrix size (2N) X 6
     */
    static double[][] calculateJ(double[][] worldC, double[] h, double[] thetas) {
        //(2N) X 9
<span class="nc" id="L554">        double[][] jF = calculateJF(worldC, h);</span>
        //9 X 6
<span class="nc" id="L556">        double[][] jG = calculateJG(thetas);</span>
        // (2N)X6)
<span class="nc" id="L558">        double[][] j = MatrixUtil.multiply(jF, jG);</span>
<span class="nc" id="L559">        return j;</span>
    }
    
    /**
     &lt;pre&gt;
     J_f = df/dh 
         where f is the world point transformed by the homography h.
     &lt;/pre&gt;
     &lt;pre&gt; 
     Sect 6.1 of George Wetzstein Stanford Course Notes 
     for EE 267 Virtual Reality, 6-DOF Pose Tracking with the VRduino  
     &lt;/pre&gt;
     * @param worldC
     * @param h
     * @return a (2*n)X9 matrix
     */
    static double[][] calculateJF(double[][] worldC, double[] h) {
        
<span class="nc" id="L577">        int n = worldC[0].length;</span>
        
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (n &lt; 4) {</span>
<span class="nc" id="L580">            throw new IllegalArgumentException(&quot;need at least 4 features in worldC&quot;);</span>
        }
        
        //TODO: assert worldC[2][*] = 1 for local device frame
<span class="nc bnc" id="L584" title="All 2 branches missed.">        assert(Math.abs(worldC[2][0] - 1.) &lt; 1e-5);</span>
        
        // (2*n) X 9
<span class="nc" id="L587">        double[][] jF = MatrixUtil.zeros(2*n, 9);</span>
        int i, j;
        double x, y, s1, s2, d, dsq;
<span class="nc bnc" id="L590" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L591">            x = worldC[0][i];</span>
<span class="nc" id="L592">            y = worldC[1][i];</span>
<span class="nc" id="L593">            d = h[6] * x + h[7] * y + h[8];</span>
<span class="nc" id="L594">            s1 = h[0] * x + h[1] * y + h[2];</span>
<span class="nc" id="L595">            s2 = h[3] * x + h[4] * y + h[5];</span>
<span class="nc" id="L596">            dsq = s1*s1;</span>
            
<span class="nc" id="L598">            jF[2*i][0] = x/d;</span>
<span class="nc" id="L599">            jF[2*i][1] = y/d;</span>
<span class="nc" id="L600">            jF[2*i][2] = 1./d;</span>
<span class="nc" id="L601">            jF[2*i][6] = -(s1/dsq)*x;</span>
<span class="nc" id="L602">            jF[2*i][7] = -(s1/dsq)*y;</span>
<span class="nc" id="L603">            jF[2*i][8] = -(s1/dsq);</span>
            
<span class="nc" id="L605">            jF[2*i + 1][3] = x/d;</span>
<span class="nc" id="L606">            jF[2*i + 1][4] = y/d;</span>
<span class="nc" id="L607">            jF[2*i + 1][5] = 1./d;</span>
<span class="nc" id="L608">            jF[2*i + 1][6] = -(s2/dsq)*x;</span>
<span class="nc" id="L609">            jF[2*i + 1][7] = -(s2/dsq)*y;</span>
<span class="nc" id="L610">            jF[2*i + 1][8] = -(s2/dsq);</span>
        }
<span class="nc" id="L612">        return jF;</span>
    }
    
    static void calculateJF(double[] worldC, double[] h, double[][] outJF) {
        
        //TODO: assert worldC[2] = 1 for local device frame
        //assert(Math.abs(worldC[2] - 1.) &lt; 1e-5);
        
<span class="nc bnc" id="L620" title="All 2 branches missed.">        assert(outJF.length == 2);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        assert(outJF[0].length == 9);</span>
        
        int i, j;
        double x, y, s1, s2, d, dsq;
<span class="nc" id="L625">        x = worldC[0];</span>
<span class="nc" id="L626">        y = worldC[1];</span>
<span class="nc" id="L627">        d = h[6] * x + h[7] * y + h[8];</span>
<span class="nc" id="L628">        s1 = h[0] * x + h[1] * y + h[2];</span>
<span class="nc" id="L629">        s2 = h[3] * x + h[4] * y + h[5];</span>
<span class="nc" id="L630">        dsq = s1*s1;</span>

<span class="nc" id="L632">        outJF[0][0] = x/d;</span>
<span class="nc" id="L633">        outJF[0][1] = y/d;</span>
<span class="nc" id="L634">        outJF[0][2] = 1./d;</span>
<span class="nc" id="L635">        outJF[0][6] = -(s1/dsq)*x;</span>
<span class="nc" id="L636">        outJF[0][7] = -(s1/dsq)*y;</span>
<span class="nc" id="L637">        outJF[0][8] = -(s1/dsq);</span>

<span class="nc" id="L639">        outJF[1][3] = x/d;</span>
<span class="nc" id="L640">        outJF[1][4] = y/d;</span>
<span class="nc" id="L641">        outJF[1][5] = 1./d;</span>
<span class="nc" id="L642">        outJF[1][6] = -(s2/dsq)*x;</span>
<span class="nc" id="L643">        outJF[1][7] = -(s2/dsq)*y;</span>
<span class="nc" id="L644">        outJF[1][8] = -(s2/dsq);</span>
<span class="nc" id="L645">    }</span>
    
    /**
    &lt;pre&gt;
     J_g = dh/dp 
         where h is the 2-D projection matrix of size 3x3 as
         2 columns of rotation and last column is translation
    &lt;/pre&gt;
    &lt;pre&gt; 
     Sect 6.1 of George Wetzstein Stanford Course Notes 
     for EE 267 Virtual Reality, 6-DOF Pose Tracking with the VRduino  
     &lt;/pre&gt;
     * @param thetas
     * @return 9X6 matrix
     */
    static double[][] calculateJG(double[] thetas) {
                        
        // 9 X 6
<span class="nc" id="L663">        double[][] jG = new double[9][6];//MatrixUtil.zeros(9, 6);</span>
        double cx, cy, cz, sx, sy, sz;
<span class="nc" id="L665">        cx = Math.cos(thetas[0]);</span>
<span class="nc" id="L666">        cy = Math.cos(thetas[1]);</span>
<span class="nc" id="L667">        cz = Math.cos(thetas[2]);</span>
<span class="nc" id="L668">        sx = Math.sin(thetas[0]);</span>
<span class="nc" id="L669">        sy = Math.sin(thetas[1]);</span>
<span class="nc" id="L670">        sz = Math.sin(thetas[2]);</span>
        
<span class="nc" id="L672">        jG[0] = new double[]{-cx*sy*sz, -sy*cz-sx*cy*sz, -cy*sz-sx*sy*cz,</span>
           0, 0, 0};
        
<span class="nc" id="L675">        jG[1] = new double[]{sx*sz, 0, -cx*cz, 0, 0, 0};</span>
        
<span class="nc" id="L677">        jG[2] = new double[]{0, 0, 0, 1, 0, 0};</span>
        
<span class="nc" id="L679">        jG[3] = new double[]{cx*sy*cz, -sy*sz+sx*cy*cz, cy*cz-sx*sy*sz, 0, 0, 0};</span>
        
<span class="nc" id="L681">        jG[4] = new double[]{-sx*cz, 0, -cx*sz, 0, 0, 0};</span>
        
<span class="nc" id="L683">        jG[5] = new double[]{0, 0, 0, 0, 1, 0};</span>
        
<span class="nc" id="L685">        jG[6] = new double[]{-sx*sy, cx*cy, 0, 0, 0, 0};</span>
        
<span class="nc" id="L687">        jG[7] = new double[]{-cx, 0, 0, 0, 0, 0};</span>
        
<span class="nc" id="L689">        jG[8] = new double[]{0, 0, 0, 0, 0, -1};</span>
        
<span class="nc" id="L691">        return jG;</span>
    }
    
    /**
     * following Szeliski 2010, Chap 6, eqn (6.18)
     * @param jTJ J^T * J.  size is 6X6.
     * @param lambda
     * @param jTBFG J^T * (B-F(g(p))). size is 6X1
     * @param outDeltaP calculated step length
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    private static void calculateDeltaPLMSzeliski(double[][] jTJ, 
        double lambda, double[] jTBFG, double[] outDeltaP) throws NotConvergedException {
                
        //                        [6X6]                   * [6X1] = [6X1]
        //delta p = pseudoInv(J^T*J + lambda*diag(J^T*J)) * J^T*BFG
        
        int i, j;
        // J^T J + λ diag(J^TJ)     
        // [6X6]
<span class="nc" id="L711">        double[][] a = MatrixUtil.copy(jTJ);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        for (i = 0; i &lt; 6; ++i) {</span>
<span class="nc" id="L713">            a[i][i] += (lambda*(jTJ[i][i]));</span>
        }
        //[6X6]
<span class="nc" id="L716">        double[][] aInv = MatrixUtil.pseudoinverseRankDeficient(a);</span>
                
        //[6X6] * [6X1] = [6X1]
<span class="nc" id="L719">        MatrixUtil.multiplyMatrixByColumnVector(aInv, jTBFG, outDeltaP);        </span>
<span class="nc" id="L720">    }</span>
        
    /**
     * from lecture notes of Danping Zou
     * http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf
     *                          6X6  * (6 * (2N)) * (2NX1) = 6 X (2N) * (2NX1) = 6X1
     * calculate the step as (J^T*J + lambda*I)^-1 * J^T * (b-f(g(p))
     * @param jTJ 
     * @param lambda
     * @param jTBF
     * @return an array of length 6 
     * @throws NotConvergedException 
     */
    private static double[] calculateDeltaPLM(double[][] jTJ, 
        double lambda, double[] jTBF) throws NotConvergedException {
        
        // (J^T*J + lambda*I)^-1 * J^T * (b-f(g(p))
<span class="nc" id="L737">        double[][] identity = MatrixUtil.createIdentityMatrix(6);</span>
<span class="nc" id="L738">        MatrixUtil.multiply(identity, lambda);</span>
        // 6 X 6
<span class="nc" id="L740">        double[][] a = MatrixUtil.pointwiseAdd(jTJ, identity);</span>
<span class="nc" id="L741">        double[][] aInv = MatrixUtil.pseudoinverseFullColumnRank(a);</span>
        
<span class="nc" id="L743">        double[] step = MatrixUtil.multiplyMatrixByColumnVector(aInv, jTBF);</span>
        
<span class="nc" id="L745">        return step;</span>
    }
    
    /**
     * gain = (f(p) - f(p + delta p)) / ell(delta p)
             where ell(delta p) is (delta p)^T * (lambda * (delta p)) + J^T * ( b - fgp))
       gain = (f - fPrev) / ( (delta p)^T * (lambda * (delta p) + J^T * ( b - fgp)) )
     * @param fNew
     * @param fPrev
     * @param deltaP
     * @param lambda
     * @param jTBFG j^T*(b-f(g(p))). size is 6X1
     * @return 
     */
    private static double calculateGainRatio(double fNew, double fPrev, 
        double[] deltaP, double lambda, double[] jTBFG,
        double eps) {
        
        // (M. Lourakis, A. Argyros: SBA: A Software Package For Generic
        // Sparse Bundle Adjustment. ACM Trans. Math. Softw. 36(1): (2009))
        //  gain ratio = ( fPrev - fNew) / ( deltaP^T * (lambda * deltaP + J^T*fPrev) )
        
        
        //   1X6         *    ([1X1]*[6X1]         + [6X1])           = [1X1]
        //(delta p LM)^T *  (lambda * (delta p LM) + J^T * (b - fgp))
        
             
        //      1X6          *            ( 6X1   +   6 X (2N) * (2NX1) )
        //      1X6                        6X1 
        //  1X1
        //(delta p LM)^T * (lambda * (delta p LM) + J^T * (b - fgp))
<span class="nc" id="L776">        double[] denom = Arrays.copyOf(deltaP, deltaP.length);</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">        for (int i = 0; i &lt; denom.length; ++i) {</span>
<span class="nc" id="L778">            denom[i] *= lambda;</span>
        }
        
<span class="nc" id="L781">        denom = MatrixUtil.add(denom, jTBFG);</span>
        
<span class="nc" id="L783">        double d = MatrixUtil.innerProduct(deltaP, denom);</span>
        
<span class="nc bnc" id="L785" title="All 2 branches missed.">        if (Math.abs(d) &lt; eps) {</span>
<span class="nc" id="L786">            return Double.NEGATIVE_INFINITY;</span>
        }
        
<span class="nc" id="L789">        double gain = (fPrev - fNew)/d;</span>
        
<span class="nc" id="L791">        return gain;</span>
    }

    private static boolean isNegligible(double[] c, double eps) {
<span class="nc bnc" id="L795" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; ++i) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (Math.abs(c[i]) &gt; eps) {</span>
<span class="nc" id="L797">                return false;</span>
            }
        }
<span class="nc" id="L800">        return true;</span>
    }

    private static void populateHWithRT(double[] h, double[][] r, double[] t) {
<span class="nc" id="L804">        h[0] = r[0][0];</span>
<span class="nc" id="L805">        h[1] = r[0][1];</span>
<span class="nc" id="L806">        h[2] = t[0];</span>
<span class="nc" id="L807">        h[3] = r[1][0];</span>
<span class="nc" id="L808">        h[4] = r[1][1];</span>
<span class="nc" id="L809">        h[5] = t[1];</span>
        // TODO: review the code for right-handedness vs left-handedness.
        //    Wetzstein convention looks down the negative z-axis.
        //    (see Rotation.java notes). may need transposition...
        //h[6] = -r[2][0];
        //h[7] = -r[2][1];
        //h[8] = -t[2];
<span class="nc" id="L816">        h[6] = r[2][0];</span>
<span class="nc" id="L817">        h[7] = r[2][1];</span>
<span class="nc" id="L818">        h[8] = t[2];</span>
<span class="nc" id="L819">    }</span>
    
    /**
     * 
     * @param h input and output variable homography to be updated with given
     * rotation angles and translations.
     * @param thetas
     * @param t 
     */
    private static void updateHWithThetaT(double[] h, double[] thetas, double[] t) {
        // equation (19).  size is 1 X 9
        
<span class="nc" id="L831">        double cx = Math.cos(thetas[0]);</span>
<span class="nc" id="L832">        double cy = Math.cos(thetas[1]);</span>
<span class="nc" id="L833">        double cz = Math.cos(thetas[2]);</span>
<span class="nc" id="L834">        double sx = Math.sin(thetas[0]);</span>
<span class="nc" id="L835">        double sy = Math.sin(thetas[1]);</span>
<span class="nc" id="L836">        double sz = Math.sin(thetas[2]);</span>
        
<span class="nc" id="L838">        h[0] = cy*cz - sx*sy*sz;</span>
<span class="nc" id="L839">        h[1] = -cx*sz;</span>
<span class="nc" id="L840">        h[2] = t[0];</span>
<span class="nc" id="L841">        h[3] = cy*sz + sx*sy*cz;</span>
<span class="nc" id="L842">        h[4] = cx*cz;</span>
<span class="nc" id="L843">        h[5] = t[1];</span>
<span class="nc" id="L844">        h[6] = cx*sy;</span>
<span class="nc" id="L845">        h[7] = -sx;</span>
<span class="nc" id="L846">        h[9] = -t[2];</span>
<span class="nc" id="L847">    }</span>

    /**
     * update translation t by deltaT
     */
    private static void updateT(double[] t, double[] deltaT) {
        // from Danping Zou lecture notes, Shanghai Jiao Tong University,
        // EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
        // http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf

        // parameter perturbations for a vector are 
        //     x + delta x
        int i;
        
        // vector perturbation for translation:
<span class="nc bnc" id="L862" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L863">            t[i] += deltaT[i];</span>
        }
<span class="nc" id="L865">    }</span>
    
    private static void updateT(double[] t, double[] deltaT, double[][] r) {
        // t_local(t + deltaT) = t + r*deltaT
        int i;
        
<span class="nc" id="L871">        double[] rdt = MatrixUtil.multiplyMatrixByColumnVector(r, deltaT);</span>
        
        // vector perturbation for translation:
<span class="nc bnc" id="L874" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L875">            t[i] += rdt[i];</span>
        }
<span class="nc" id="L877">    }</span>
    
    /**
     * update rotation matrix r with deltaTheta.
     * the approach used avoids singularities and the need to restore 
     * the constraint afterwards (i.e., constraint restoration is built in).
     * 
     * @param r
     * @param thetas input and output array holding euler rotation angles 
     *    theta_x, theta_y, theta_
     * @param deltaTheta
     */
    private static void updateRTheta(double[][] r, double[] thetas, double[] deltaTheta) {
        // from Danping Zou lecture notes, Shanghai Jiao Tong University,
        // EE382-Visual localization &amp; Perception, “Lecture 08- Nonlinear least square &amp; RANSAC”
        // http://drone.sjtu.edu.cn/dpzou/teaching/course/lecture07-08-nonlinear_least_square_ransac.pdf
        // parameter perturbations for a Lie group such as rotation are:
        //     R * (I - [delta x]_x) where [delta x]_x is the skew-symetric matrix of delta_x 
        
        // T. Barfoot, et al. 2010, 
        // Pose estimation using linearized rotations and quaternion algebra, 
        // Acta Astronautica (2010), doi:10.1016/j.actaastro.2010.06.049
        // eqn (31) for updating rotation:
        // C(theta) = C(deltaPhi) * previous C
        //     where C is rotation matrix r
        //           calculated as C(theta) = 
        //     and deltaPhi = sTheta * deltaTheta
        
        //double[][] out;// = MatrixUtil.zeros(3, 3);
<span class="nc" id="L906">        double[] qUpdated = Rotation.applySingularitySafeRotationPerturbationQuaternion(thetas, deltaTheta);</span>
        
        // [4X4]
<span class="nc" id="L909">        double[][] qR = Rotation.createRotationMatrixFromQuaternion4(qUpdated);</span>
<span class="nc" id="L910">        qR = MatrixUtil.transpose(qR);</span>
        
        // rotation is [0:2, 0:2] of qR  
                
        // update in-out variable r
<span class="nc bnc" id="L915" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L916">            System.arraycopy(qR[i], 0, r[i], 0, 3);</span>
        }

        // ---- update theta ----        
        //extracting theta from the updated rotation would keep the theta
        //    vector consistent with the rotation matrix,
        //    but the value is a little different that updating theta with delta theta
        //    by addition.
<span class="nc" id="L924">        double[] thetaExtracted = Rotation.extractThetaFromZYX(r);</span>
<span class="nc" id="L925">        System.arraycopy(thetaExtracted, 0, thetas, 0, thetas.length);</span>
        
        /*
        for (int i = 0; i &lt; 3; ++i) {
            thetas[i] += deltaTheta[i];
        }*/
        
<span class="nc" id="L932">    }</span>

    /**
     * initialize the first parameter steps with small values suggested
     * by Qu.
     * @param deltaP 
     */
    private static void initDeltaPWithQu(double[] deltaP) {
        /*Qu thesis eqn (3.38)
        
        delta thetas ~ 1e-8
        delta translation ~1e-5
        delta focus ~ 1
        delta kRadial ~ 1e-3
        delta x ~ 1e-8
        */
        int i;
<span class="nc bnc" id="L949" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
            // delta theta
<span class="nc" id="L951">            deltaP[i] = 1e-8;</span>
        }
<span class="nc bnc" id="L953" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
            // delta translation
<span class="nc" id="L955">            deltaP[3+i] = 1e-5;</span>
        }
        
<span class="nc" id="L958">    }</span>

    private static double maxDiag(double[][] jTJ) {
<span class="nc" id="L961">        double max = Double.NEGATIVE_INFINITY;</span>
        //Arrays.fill(max, Double.NEGATIVE_INFINITY);
<span class="nc bnc" id="L963" title="All 2 branches missed.">        for (int i = 0; i &lt; jTJ.length; ++i) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (jTJ[i][i] &gt; max) {</span>
<span class="nc" id="L965">                max = jTJ[i][i];</span>
            }
        }
<span class="nc" id="L968">        return max;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
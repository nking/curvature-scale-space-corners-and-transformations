<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Camera.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Camera.java</span></div><h1>Camera.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.matrix.MatrixUtil;
import algorithms.util.FormatArray;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import no.uib.cipr.matrix.NotConvergedException;

/**
 * utility methods for camera intrinsic and extrinsic matrices.
 * 
 * KIntrinsic is the camera intrinsic parameters
 * KExtrinsic is the camera extrinsic parameters, specifically, the camera
 * position and orientation in world coordinates.
 * 
 * to project the world coordinate system point into the camera frame
 * canonical form,
 * multiply it by the extrinsic matrix (which will translate the
 * coordinates and rotate them).
 * 
 * to project the camera frame coordinate system into the image frame,
 * multiply it by the intrinsic matrix.
 * 
 * TODO: consider implementing tangential distortion.  
 * see Heikkila, Janne, and Olli Silven 1997. &quot;A four-step camera calibration 
 * procedure with implicit image correction.&quot; 
 * Computer Vision and Pattern Recognition, 1997. 
 * Proceedings., 1997 IEEE Computer Society Conference on. IEEE, 1997.
 * @author nichole
 */
<span class="nc" id="L33">public class Camera {</span>
   
<span class="fc" id="L35">    public static double eps = 1e-7;</span>
    
    /**
     *  create camera intrinsic matrix k with assumptions of square pixels
     * and no skew.  the focal length and optical centers should be in units of pixels.
     * NOTE that given the field of view (FOV) and the image dimensions,
     * one can roughly estimate the focal length as (image width/2) / tan(FOV/2).
     * @param focalLength focal length of camera in units of pixels.  NOTE that
     * the sign of the focal length remains the same as is given, so if you
     * want to use a right-hand coordinate system, you should give a negative
     * focal length.
     * @param centerX x coordinate of principal point in pixels, usually image center.
     * @param centerY y coordinate of principal point in pixels, usually image center.
     * @return intrinsic camera matrix in units of pixels.
     */
    public static double[][] createIntrinsicCameraMatrix(double focalLength,
        double centerX, double centerY) {
        
<span class="fc" id="L53">        double[][] k = new double[3][3];</span>
<span class="fc" id="L54">        k[0] = new double[]{focalLength, 0, centerX};</span>
<span class="fc" id="L55">        k[1] = new double[]{0, focalLength, centerY};</span>
<span class="fc" id="L56">        k[2]= new double[]{0, 0, 1};</span>
        
<span class="fc" id="L58">        return k;</span>
    }
    
    /**
     *  create camera intrinsic matrix k.  the focal length and optical centers should be in units of pixels.
     * NOTE that given the field of view (FOV) and the image dimensions,
     * one can roughly estimate the focal length as (image width/2) / tan(FOV/2).
     * @param focalLengthX focal length of camera in units of pixels along x axis.
     * NOTE that
     * the sign of the focal length remains the same as is given, so if you
     * want to use a right-hand coordinate system, you should give a negative
     * focal length.
     * @param focalLengthY focal length of camera in units of pixels along y axis.
     * NOTE that
     * the sign of the focal length remains the same as is given, so if you
     * want to use a right-hand coordinate system, you should give a negative
     * focal length.
     * @param centerX x coordinate of principal point in pixels, usually image center.
     * @param centerY y coordinate of principal point in pixels, usually image center.
     * @param skew camera skew
     * @return intrinsic camera matrix in units of pixels.
     */
    public static double[][] createIntrinsicCameraMatrix(double focalLengthX,
        double focalLengthY, double centerX, double centerY, double skew) {
        
<span class="fc" id="L83">        double[][] k = new double[3][3];</span>
<span class="fc" id="L84">        k[0] = new double[]{focalLengthX, skew, centerX};</span>
<span class="fc" id="L85">        k[1] = new double[]{0, focalLengthY, centerY};</span>
<span class="fc" id="L86">        k[2]= new double[]{0, 0, 1};</span>
        
<span class="fc" id="L88">        return k;</span>
    }
    
    /**
     *create the inverse of camera intrinsic matrix k with assumptions of square pixels
     * and no skew.  the focal length and optical centers should be in units of pixels.
     * NOTE that given the field of view (FOV) and the image dimensions,
     * one can roughly estimate the focal length as (image width/2) / tan(FOV/2).
     * @param focalLength focal length of camera in units of pixels.
     * NOTE that
     * the sign of the focal length remains the same as is given, so if you
     * want to use a right-hand coordinate system, you should give a negative
     * focal length.
     * @param centerX x coordinate of principal point in pixels, usually image center.
     * @param centerY y coordinate of principal point in pixels, usually image center.
     * @return intrinsic camera matrix in units of pixels.
     */
    public static double[][] createIntrinsicCameraMatrixInverse(double focalLength,
        double centerX, double centerY) {
        
<span class="nc" id="L108">        double[][] k = new double[3][3];</span>
<span class="nc" id="L109">        k[0] = new double[]{1./focalLength, 0, -centerX/focalLength};</span>
<span class="nc" id="L110">        k[1] = new double[]{0, 1./focalLength, -centerY/focalLength};</span>
<span class="nc" id="L111">        k[2] = new double[]{0, 0, 1};</span>
        
<span class="nc" id="L113">        return k;</span>
    }
    
    /**
     *  create the inverse of camera intrinsic matrix k.
     * @param kIntr intrinsic camera matrix.
     * @return intrinsic camera matrix inverse.
     */
    public static double[][] createIntrinsicCameraMatrixInverse(double[][] kIntr) {
        
        /*
        translation matrix: inverse changes the signs of the translation elements, but not the diagonal.
        rotation matrix: inverse is the transpose of rotation matrix.
        scaling matrix: inverse is performed on each element, that is, the reciprocal.
        
        skew is a translation term, so will put it in its own matrix
        
             | 1  0  xc |   | fx  0   0 |   | 1  g/fx   0 | 
         K = | 0  1  yc | * | 0  fy   0 | * | 0  1      0 | 
             | 0  0   1 |   | 0   0   1 |   | 0  0      1 | 
            
             | fx  0  xc |   | 1  g/fx   0 |   | fx  g  xc |
           = | 0  fy  yc | * | 0  1      0 | = | 0  fy  yc |
             | 0  0   1  |   | 0  0      1 |   | 0  0   1  |
        
        let z = the inverse term for g/fx = -g/fx
        
               | 1  z       0 |   | 1/fx  0      0   |   | 1  0 -xc | 
        K^-1 = | 0  1       0 | * | 0     1/fy   0   | * | 0  1 -yc | 
               | 0  0       1 |   | 0     0      1/1 |   | 0  0   1 |
        
               | 1/fx   z/fy  0 |   | 1  0 -xc |   | 1/fx   z/fy    -xc/fx -yc*z/fy |
             = |  0     1/fy  0 | * | 0  1 -yc | = |  0     1/fy    -yc/fy          |
               |  0     0     1 |   | 0  0   1 |   |  0     0       1               |
        
               | 1/fx   -g/(fx*fy)   -xc/fx + g*yc/(fx*fy) |
             = | 0       1/fy        -yc/fy                |
               | 0       0           1                     |
        
        validation here:
        https://www.imatest.com/support/docs/pre-5-2/geometric-calibration-deprecated/projective-camera/
        */
        
<span class="fc" id="L156">        double[][] kInv = MatrixUtil.zeros(3, 3);</span>
        
                
<span class="fc" id="L159">        double fx = kIntr[0][0];</span>
<span class="fc" id="L160">        double fy = kIntr[1][1];</span>
<span class="fc" id="L161">        double fxfy = fx*fy;</span>
<span class="fc" id="L162">        double g = kIntr[0][1];</span>
<span class="fc" id="L163">        double xc = kIntr[0][2];</span>
<span class="fc" id="L164">        double yc = kIntr[1][2];</span>
        
<span class="fc" id="L166">        kInv[0][0] = 1./fx;</span>
<span class="fc" id="L167">        kInv[0][1] = -g/fxfy;</span>
<span class="fc" id="L168">        kInv[0][2] = (-xc/fx) + (g*yc/fxfy);</span>
<span class="fc" id="L169">        kInv[1][1] = 1./fy;</span>
<span class="fc" id="L170">        kInv[1][2] = -yc/fy;</span>
<span class="fc" id="L171">        kInv[2][2] = 1;</span>
        
<span class="fc" id="L173">        return kInv;</span>
    }
   
    /**
     * create the camera projection matrix as P = K * [R | t].
     * @param k camera intrinsics matrix of size 3 x 3.
     * @param r camera extrinsic rotation matrix of size 3 x 3.
     * @param t camera extrinsic translation vector of length 3 in homogeneous coordinates (z-axis has value 1).
     * @return the camera matrix resulting from intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     */
    public static double[][] createCamera(double[][] k, double[][] r, double[] t) {
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">        if (k.length != 3 || k[0].length != 3) {</span>
<span class="nc" id="L186">            throw new IllegalArgumentException(&quot;k must be 3 x 3&quot;);</span>
        }
<span class="pc bpc" id="L188" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L189">            throw new IllegalArgumentException(&quot;r must be 3 x 3&quot;);</span>
        }
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (t.length != 3) {</span>
<span class="nc" id="L192">            throw new IllegalArgumentException(&quot;t must be length 3&quot;);</span>
        }

<span class="fc" id="L195">        double[][] rt = createExtrinsicCameraMatrix(r, t);</span>

<span class="fc" id="L197">        double[][] p = MatrixUtil.multiply(k, rt);</span>
        
<span class="fc" id="L199">        return p;</span>
    }

    /**
     * create extrinsic camera matrix assuming the relation x = R * XW + t.
     * the resulting matrix is [R | t]
     * @param r camera extrinsic rotation matrix of size 3 x 3.
     * @param t camera extrinsic translation vector of length 3 in homogenous coordinates (the
     *          z-axis holds value 1).
     * @return the extrinsic camera matrix. the size is 3 x 4.
     */
    public static double[][] createExtrinsicCameraMatrix(double[][] r, double[] t) {

<span class="pc bpc" id="L212" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L213">            throw new IllegalArgumentException(&quot;r must be 3 x 3&quot;);</span>
        }
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (t.length != 3) {</span>
<span class="nc" id="L216">            throw new IllegalArgumentException(&quot;t must be length 3&quot;);</span>
        }

        //P = [R | t]
<span class="fc" id="L220">        double[][] kExtr = new double[3][4];</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L222">            kExtr[i] = new double[] {r[i][0], r[i][1], r[i][2], t[i]};</span>
        }

<span class="fc" id="L225">        return kExtr;</span>
    }

    /**
     * TODO: revise and test.
     * not ready for use.  a quick rough method to estimate the 3D homogeneous point
     * from the 2D-homogenous point and this inverse camera matrix, with caveat 
     * about missing information on the last dimension.  
     * One should use reconstruction methods instead of this method.
     * to use:
     * &lt;pre&gt;
     * double[][] X = MatrixUtil.multiply(cameraInv, x);
     * then divide each column by the 3rd row.
     * &lt;/pre&gt;
     * 
     * @param k camera intrinsics matrix of size 3 x 3.
     * @param r camera extrinsic rotation matrix of size 3 x 3.
     * @param t camera extrinsic translation vector of length 2.
     * @return the inverse camera matrix resulting from intrinsic and extrinsic parameters.
     * the size is 4x3
     */
    public static double[][] createCameraInverse(double[][] k, double[][] r, double[] t) {
<span class="pc bpc" id="L247" title="2 of 4 branches missed.">        if (k.length != 3 || k[0].length != 3) {</span>
<span class="nc" id="L248">            throw new IllegalArgumentException(&quot;k must be 3 x 3&quot;);</span>
        }
<span class="pc bpc" id="L250" title="2 of 4 branches missed.">        if (r.length != 3 || r[0].length != 3) {</span>
<span class="nc" id="L251">            throw new IllegalArgumentException(&quot;r must be 3 x 3&quot;);</span>
        }
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (t.length != 3) {</span>
<span class="nc" id="L254">            throw new IllegalArgumentException(&quot;t must be length 3&quot;);</span>
        }
        
        /*
        translation matrix: inverse changes the signs of the translation elements, but not the diagonal.
        rotation matrix: inverse is the transpose of rotation matrix.
        scaling matrix: inverse is performed on each element, that is, the reciprocal.
        */
                
<span class="fc" id="L263">        double[] tInv = Arrays.copyOf(t, t.length);</span>
<span class="fc" id="L264">        tInv[0] *= -1;</span>
<span class="fc" id="L265">        tInv[1] *= -1;</span>
                
<span class="fc" id="L267">        double[] rTInv = MatrixUtil.multiplyMatrixByColumnVector(r, tInv);</span>
        
<span class="fc" id="L269">        double[][] kInv = Camera.createIntrinsicCameraMatrixInverse(k);</span>
        
        /*           
        inverse of   K * R * [I | -t]             
            
        is  | r  | r*tInv ]^T  * kInv
        */
        
<span class="fc" id="L277">        double[][] cInv = new double[3][4];</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L279">            cInv[i] = new double[4];</span>
<span class="fc" id="L280">            System.arraycopy(r[i], 0, cInv[i], 0, 3);</span>
<span class="fc" id="L281">            cInv[i][3] = rTInv[i];</span>
        }
<span class="fc" id="L283">        cInv = MatrixUtil.transpose(cInv);</span>
        
<span class="fc" id="L285">        cInv = MatrixUtil.multiply(cInv, kInv);</span>
        
<span class="fc" id="L287">        return cInv;</span>
    }
    
    /**
     * applies radial distortion to distortion-free camera centered coordinates
     * then multiplies by the camera intrinsics to result in distorted coordinates 
     * in the image reference frame in units of pixels.
     * In terms of Table 1 of Ma et al. 2004, the input is a double array of (x, y)
     * and the output is a double array of (u_d, v_d).
     * The radial distortion functions to choose are from Ma et al. 2004 Table 2.
        The choices are model #4, f(r) = 1 +k1*r^2 + k2*r^4,
        or model #3, f(r) = 1 +k1*r + k2*r^2.
        Note that if rCoeffs is null or empty, no radial distortion is applied.
     * Also useful reading is NVM Tools by Alex Locher
    https://github.com/alexlocher/nvmtools.git
     * @param xC distortion-free camera centered coordinates. 
     * format is 3XN for N points.  
     * In terms of Table 1 of Ma et al. 2004, this is a double array of (x, y).
     * @param rCoeffs radial distortion vector of length 2
     * distortion vector of length 5.  can be null to skip lens distortion correction.
     * if 
     * @param focalLength focal length of camera in units of pixels.
     * @param centerX x coordinate of principal point in pixels, usually image center.
     * @param centerY y coordinate of principal point in pixels, usually image center.
     * @return pixels in the reference frame of image with distortion applied.
     * In terms of Table 1 of Ma et al. 2004, this is a double array of (u_d, v_d)
     * @param useR2R4 if true use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4,
        else if false use model #3 f(r) = 1 +k1*r + k2*r^2.
        note that if rCoeffs is null or empty, no radial distortion is applied.
     */
    public static double[][] cameraToPixelCoordinates(double[][] xC, double[] rCoeffs,
        double focalLength, double centerX, double centerY, boolean useR2R4) {
        
        // http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html
        
<span class="fc" id="L323">        double[][] cc = MatrixUtil.copy(xC);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        for (int i = 0; i &lt; xC[0].length; ++i) {</span>
            // normalized pinhole projection X_c/Z_c and 
<span class="fc" id="L326">            cc[0][i] /= xC[2][i];</span>
<span class="fc" id="L327">            cc[1][i] /= xC[2][i];</span>
        }
        
<span class="pc bpc" id="L330" title="3 of 4 branches missed.">        if (rCoeffs != null &amp;&amp; rCoeffs.length &gt; 0) {</span>
            // input and output cc are in camera reference frame
<span class="nc" id="L332">            cc = CameraCalibration.applyRadialDistortion(cc, rCoeffs[0], rCoeffs[1],</span>
                useR2R4);
        }
         
//        focalLength = Math.abs(focalLength);
        
<span class="fc" id="L338">        double[][] cameraIntr = Camera.createIntrinsicCameraMatrix(focalLength, centerX, centerY);</span>
                       
<span class="fc" id="L340">        cc = MatrixUtil.multiply(cameraIntr, cc);</span>
        
<span class="fc" id="L342">        return cc;</span>
    }
    
    /**
     * applies radial distortion to distortion-free camera centered coordinates
     * then multiplies by the camera intrinsics to result in distorted coordinates 
     * in the image reference frame in units of pixels.
     * In terms of Table 1 of Ma et al. 2004, the input is a double array of (x, y)
     * and the output is a double array of (u_d, v_d).
     * Also useful reading is NVM Tools by Alex Locher
    https://github.com/alexlocher/nvmtools.git
     * @param xC distortion-free camera centered coordinates. 
     * format is 3XN for N points.  
     * In terms of Table 1 of Ma et al. 2004, this is a double array of (x, y).
     * @param kIntr
     *
     */
    public static double[][] cameraToPixelCoordinates(double[][] xC,
        CameraIntrinsicParameters kIntr) {
        
        // http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html
        
<span class="nc" id="L364">        double[][] cc = MatrixUtil.copy(xC);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        for (int i = 0; i &lt; xC[0].length; ++i) {</span>
            // normalized pinhole projection X_c/Z_c and 
<span class="nc" id="L367">            cc[0][i] /= xC[2][i];</span>
<span class="nc" id="L368">            cc[1][i] /= xC[2][i];</span>
        }

<span class="nc bnc" id="L371" title="All 4 branches missed.">        if (kIntr.getRadialDistortionCoeffs() != null &amp;&amp; kIntr.getRadialDistortionCoeffs().length &gt;= 2) {</span>
            // input and output cc are in camera reference frame
<span class="nc" id="L373">            cc = CameraCalibration.applyRadialDistortion(cc, kIntr.getRadialDistortionCoeffs()[0],</span>
<span class="nc" id="L374">                    kIntr.getRadialDistortionCoeffs()[1],</span>
<span class="nc" id="L375">                kIntr.useR2R4());</span>
        }
                                        
<span class="nc" id="L378">        cc = MatrixUtil.multiply(kIntr.getIntrinsic(), cc);</span>
        
<span class="nc" id="L380">        return cc;</span>
    }

    /**
     * applies radial distortion to distortion-free camera centered coordinates
     * then multiplies by the camera intrinsics to result in distorted coordinates
     * in the image reference frame in units of pixels.
     * In terms of Table 1 of Ma et al. 2004, the input is a double array of (x, y)
     * and the output is a double array of (u_d, v_d).
     * Also useful reading is NVM Tools by Alex Locher
     https://github.com/alexlocher/nvmtools.git
     * @param xC distortion-free camera centered coordinates.
     * format is 3XN for N points.
     * In terms of Table 1 of Ma et al. 2004, this is a double array of (x, y).
     * @param kIntr
     *
     */
    public static double[] cameraToPixelCoordinates(double[] xC,
                                                      CameraIntrinsicParameters kIntr) {

        // http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html

<span class="nc" id="L402">        double[] cc = Arrays.copyOf(xC, xC.length);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        for (int i = 0; i &lt; cc.length; ++i) {</span>
            // normalized pinhole projection X_c/Z_c and
<span class="nc" id="L405">            cc[i] /= cc[2];</span>
        }

<span class="nc bnc" id="L408" title="All 4 branches missed.">        if (kIntr.getRadialDistortionCoeffs() != null &amp;&amp; kIntr.getRadialDistortionCoeffs().length &gt;= 2) {</span>
            // input and output cc are in camera reference frame
<span class="nc" id="L410">            cc = CameraCalibration.applyRadialDistortion(cc, kIntr.getRadialDistortionCoeffs()[0],</span>
<span class="nc" id="L411">                    kIntr.getRadialDistortionCoeffs()[1],</span>
<span class="nc" id="L412">                    kIntr.useR2R4());</span>
        }

<span class="nc" id="L415">        cc = MatrixUtil.multiplyMatrixByColumnVector(kIntr.getIntrinsic(), cc);</span>

<span class="nc" id="L417">        return cc;</span>
    }
    
     /** converts pixel coordinates to normalized camera coordinates by transforming them to camera 
    reference frame then applying Lp2-normalization.
     * @param x points in the image reference frame.
     * format is 3XN for N points in row-major format. 
     * @param intrinsic 
     * @return pixels transformed to camera coordinate reerence frame then 
     * Lp2-normalized.
     * @throws no.uib.cipr.matrix.NotConvergedException
     */
    public static double[][] pixelToNormalizedCameraCoordinates(double[][] x,
        CameraIntrinsicParameters intrinsic) throws NotConvergedException {
        
<span class="nc" id="L432">        double[][] kIntrInv = Camera.createIntrinsicCameraMatrixInverse(intrinsic.getIntrinsic());</span>
        
        // the direction of the points is calculated by K^-1 * x
<span class="nc" id="L435">        double[][] xDirection = MatrixUtil.multiply(kIntrInv, x);</span>
        double sum;
        int i;
<span class="nc bnc" id="L438" title="All 2 branches missed.">        for (int col = 0; col &lt; x[0].length; ++col) {</span>
<span class="nc" id="L439">            sum = (x[0][col]*x[0][col]) + (x[1][col]*x[1][col]) + (x[2][col]*x[2][col]);</span>
<span class="nc" id="L440">            sum = Math.sqrt(sum);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L442">                xDirection[i][col] /= sum;</span>
            }
        }
                
<span class="nc" id="L446">        return xDirection;</span>
    }
    
    /**
     * transform the world coordinates xW to the camera reference frame using
     * (rot * xW + trans).
     * @param xW coordinates of objects in a world reference frame.  
     * The format is 3XN for N points.
     * @param rot the rotation matrix to apply to the translated coordinates.
     * the size is 3X3.
     * @param trans the translation to apply to coordinates xW in x, y, and z.
     * The length of the array is 3.
     * @return xW transformed to the camera reference frame.
     */
    public static double[][] worldToCameraCoordinates(double[][] xW, double[][] rot,
        double[] trans) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (xW.length != 3) {</span>
<span class="nc" id="L463">            throw new IllegalArgumentException(&quot;xW.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (trans.length != 3) {</span>
<span class="nc" id="L466">            throw new IllegalArgumentException(&quot;trans.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L468" title="All 4 branches missed.">        if (rot.length != 3 || rot[0].length != 3) {</span>
<span class="nc" id="L469">            throw new IllegalArgumentException(&quot;rot must be 3X3&quot;);</span>
        }
        
<span class="nc" id="L472">        int n = xW[0].length;</span>
<span class="nc" id="L473">        double[][] xC = MatrixUtil.copy(xW);</span>
<span class="nc" id="L474">        xC = MatrixUtil.multiply(rot, xC);</span>
        int i, j;
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L478">                xC[j][i] += trans[j];</span>
            }
        }
        
<span class="nc" id="L482">        return xC;</span>
    }
    
    /**
     * transform the world coordinate point xWPt to the camera reference frame using
     * (rot * xW + trans).
     * @param xWPt coordinates of an object in a world reference frame.  
     * The length is 3.
     * @param rot the rotation matrix to apply to the translated coordinates.
     * the size is 3X3.
     * @param trans the translation to apply to coordinates xW in x, y, and z.
     * The length of the array is 3.
     * @return the point xW transformed to the camera reference frame.
     */
    public static double[] worldToCameraCoordinates(double[] xWPt, double[][] rot,
        double[] trans) {
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (xWPt.length != 3) {</span>
<span class="nc" id="L499">            throw new IllegalArgumentException(&quot;xW.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (trans.length != 3) {</span>
<span class="nc" id="L502">            throw new IllegalArgumentException(&quot;trans.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L504" title="All 4 branches missed.">        if (rot.length != 3 || rot[0].length != 3) {</span>
<span class="nc" id="L505">            throw new IllegalArgumentException(&quot;rot must be 3X3&quot;);</span>
        }
        
<span class="nc" id="L508">        double[] xC = Arrays.copyOf(xWPt, xWPt.length);</span>
<span class="nc" id="L509">        xC = MatrixUtil.multiplyMatrixByColumnVector(rot, xC);</span>
        int j;
<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L512">            xC[j] += trans[j];</span>
        }
        
<span class="nc" id="L515">        return xC;</span>
    }
    
    /**
     * transform the world coordinate point xWPt to the camera reference frame using
     * (rot * xW + trans).
     * @param xWPt coordinates of an object in a world reference frame.  
     * The length is 3.
     * @param rot the rotation matrix to apply to the translated coordinates.
     * the size is 3X3.
     * @param trans the translation to apply to coordinates xW in x, y, and z.
     * The length of the array is 3.
     * @param aux an auxiliary array of length 3 used internally to hold
     * values for a calculation.  it's present to help the invoker reuse an
     * object instead of creating another.  it's values are not used.
     * @param out the point xW transformed to the camera reference frame.
     */
    public static void worldToCameraCoordinates(double[] xWPt, double[][] rot,
        double[] trans, double[] aux, double[] out) {
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (xWPt.length != 3) {</span>
<span class="nc" id="L535">            throw new IllegalArgumentException(&quot;xW.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (trans.length != 3) {</span>
<span class="nc" id="L538">            throw new IllegalArgumentException(&quot;trans.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L540" title="All 4 branches missed.">        if (rot.length != 3 || rot[0].length != 3) {</span>
<span class="nc" id="L541">            throw new IllegalArgumentException(&quot;rot must be 3X3&quot;);</span>
        }
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (out.length != 3) {</span>
<span class="nc" id="L544">            throw new IllegalArgumentException(&quot;out.length must be 3 (for x, y, z)&quot;);</span>
        }
                
        //point_camera = (1/x_z) * (R * point_world + translation) is called the normalized coordinate.

<span class="nc" id="L549">        MatrixUtil.multiplyMatrixByColumnVector(rot, xWPt, aux);</span>
        
        int j;
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L553">            out[j] = aux[j] + trans[j];</span>
        }        
<span class="nc" id="L555">    }</span>
    
    /**
     * transform the world coordinate point xWPt to the camera reference frame using
     * (rot * xW + trans).
     * @param xWPt coordinates of an object in a world reference frame.  
     * The length is 3.
     * @param rot the rotation matrix to apply to the translated coordinates.
     * the size is 3X3.
     * @param trans the translation to apply to coordinates xW in x, y, and z.
     * The length of the array is 3.
     * @param out the point transformed to the camera reference frame.
     */
    public static void worldToCameraCoordinates(double[] xWPt, double[][] rot,
        double[] trans, double[] out) {
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (xWPt.length != 3) {</span>
<span class="nc" id="L571">            throw new IllegalArgumentException(&quot;xW.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (trans.length != 3) {</span>
<span class="nc" id="L574">            throw new IllegalArgumentException(&quot;trans.length must be 3 (for x, y, z)&quot;);</span>
        }
<span class="nc bnc" id="L576" title="All 4 branches missed.">        if (rot.length != 3 || rot[0].length != 3) {</span>
<span class="nc" id="L577">            throw new IllegalArgumentException(&quot;rot must be 3X3&quot;);</span>
        }
<span class="nc" id="L579">        double[] x2 = Arrays.copyOf(xWPt, xWPt.length);</span>
<span class="nc" id="L580">        MatrixUtil.multiplyMatrixByColumnVector(rot, x2, out);</span>
        int j;
<span class="nc bnc" id="L582" title="All 2 branches missed.">        for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L583">            out[j] = x2[j] + trans[j];</span>
        }
        
<span class="nc" id="L586">    }</span>

    /** converts pixel coordinates to camera coordinates by transforming them to camera
    reference frame then removing radial distortion.
    The input in terms of Table 1 of Ma et al. 2004 is a double array of (u_d, v_d)
    and the output is a double array of (x, y).
    Also useful reading is NVM Tools by Alex Locher
    https://github.com/alexlocher/nvmtools.git

     * @param x points in the camera centered reference frame.
     * format is 3XN for N points.
     * @param kIntr
     * @return pixels in the reference frame of
     * @throws no.uib.cipr.matrix.NotConvergedException
     * @throws java.io.IOException
     */
    public static double[][] pixelToCameraCoordinates(double[][] x, CameraIntrinsicParameters kIntr)
        throws NotConvergedException, IOException {

<span class="fc" id="L605">        double[][] intr = MatrixUtil.copy(kIntr.getIntrinsic());</span>
<span class="fc" id="L606">        double[] rCoeffs = null;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (kIntr.getRadialDistortionCoeffs() != null) {</span>
<span class="fc" id="L608">            rCoeffs = Arrays.copyOf(kIntr.getRadialDistortionCoeffs(),</span>
<span class="fc" id="L609">                    kIntr.getRadialDistortionCoeffs().length);</span>
        }
<span class="fc" id="L611">        boolean useR2R4 = kIntr.useR2R4();</span>

<span class="fc" id="L613">        return pixelToCameraCoordinates(x, intr, rCoeffs, useR2R4);</span>
    }
    
    /** converts pixel coordinates to camera coordinates by transforming them to camera 
    reference frame then removing radial distortion.
    The input in terms of Table 1 of Ma et al. 2004 is a double array of (u_d, v_d)
    and the output is a double array of (x, y).
    Also useful reading is NVM Tools by Alex Locher
    https://github.com/alexlocher/nvmtools.git
    
     * @param x points in the camera centered reference frame. 
     * format is 3XN for N points.  
     * @param intr intrinsic camera parameters. dimensions aer [3 X 3]
     * @param rCoeffs radial distortion vector of length 2 or radial and tangential
     * distortion vector of length 5.  can be null to skip lens distortion correction.
     * @param useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
        f(r) = 1 +k1*r^2 + k2*r^4 if true,
        else use model #3 f(r) = 1 +k1*r + k2*r^2.
        note that if rCoeffs is null or empty, no radial distortion is removed.
     * @return pixels in the reference frame of 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     * @throws java.io.IOException 
     */
    public static double[][] pixelToCameraCoordinates(double[][] x, 
        double[][] intr, double[] rCoeffs, boolean useR2R4) 
        throws NotConvergedException, IOException {
        
        // http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html
                        
        // use absolute value of focal lengths
//        intr[0][0] = Math.abs(intr[0][0]);
//        intr[1][1] = Math.abs(intr[1][1]);

        //NOTE: this is same result as full column rank pseudoinverse of intr
<span class="fc" id="L647">        double[][] cameraIntrInv = Camera.createIntrinsicCameraMatrixInverse(</span>
            intr);

        // put x into camera coordinates reference frame:
<span class="fc" id="L651">        double[][] pix = MatrixUtil.multiply(cameraIntrInv, x);</span>
        
<span class="fc bfc" id="L653" title="All 2 branches covered.">        if (rCoeffs != null) {</span>
<span class="fc" id="L654">            pix = CameraCalibration.removeRadialDistortion(pix, rCoeffs[0], </span>
                rCoeffs[1], useR2R4);
        }
                
<span class="fc" id="L658">        return pix;</span>
    }
    
    /**
     * transform 2D pixel measurements x_i to unit norm 3D directions
     * &lt;pre&gt;
     * references Szeliski 2010, eqn (6.36)
     * &lt;/pre&gt;
     * @param x 2D pixel measurements in format 3XN where the rows are x, y, and &quot;1&quot;'s
     * and the columns are each point in the N points.
     * @param k camera intrinsic parameters
     * @return 
     */
    public static double[][] transformToUnitNormDirections(double[][] x, 
        CameraIntrinsicParameters k) {
        
<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (x.length != 3) {</span>
<span class="nc" id="L675">            throw new IllegalArgumentException(&quot;x length must be 3&quot;);</span>
        }
        
<span class="nc" id="L678">        double[][] kInv = Camera.createIntrinsicCameraMatrixInverse(k.intrinsic);</span>
        
        //(K^-1 * x_i)/(||K^-1 * x_i||)
<span class="nc" id="L681">        double[][] norm = MatrixUtil.multiply(kInv, x);</span>
                
        int i, j;
<span class="nc" id="L684">        double sum = 0;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        for (j = 0; j &lt; norm.length; ++j) {</span>
<span class="nc" id="L686">            sum = 0;</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">            for (i = 0; i &lt; norm.length; ++i) {</span>
<span class="nc" id="L688">                sum += (norm[i][j] *norm[i][j]);</span>
            }
<span class="nc" id="L690">            sum = Math.sqrt(sum);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            for (i = 0; i &lt; norm.length; ++i) {</span>
<span class="nc" id="L692">                norm[i][j] /= sum;</span>
            }
        }
<span class="nc" id="L695">        return norm;</span>
    }
    
    public static class CameraIntrinsicParameters {
        private double[][] intrinsic;
        private double[] radialDistortionCoeffs;
        private boolean useR2R4;
        private double lambda;
        
        public CameraIntrinsicParameters(double[][] k) {
            this.intrinsic = k;
        }

        /**
         *
         * @param k
         *
         *          @param radial the radialDistortion to set
         *          @param useR2R4 use radial distortion function from Ma et al. 2004 for model #4 in Table 2,
         *          f(r) = 1 +k1*r^2 + k2*r^4 if true,
         *          else use model #3 f(r) = 1 +k1*r + k2*r^2.
         */
        public CameraIntrinsicParameters(double[][] k, double[] radial,boolean useR2R4) {
            this.intrinsic = k;
            this.radialDistortionCoeffs = radial;
            this.useR2R4 = useR2R4;
        }
        
        public CameraIntrinsicParameters() {
        }

        public void setUseR2R4(boolean useR2R4) {
            this.useR2R4 = useR2R4;
        }
        public boolean useR2R4() {
            return useR2R4;
        }
        
        /**
         * @return the intrinsic parameters
         */
        public double[][] getIntrinsic() {
            return intrinsic;
        }
        /**
         * @param intrinsic the intrinsic parameters to set
         */
        public void setIntrinsic(double[][] intrinsic) {
            this.intrinsic = intrinsic;
        }

        /**
         * @return the lambda the scale factor used in projection
         */
        public double getLambda() {
            return lambda;
        }

        /**
         * @param lambda the lambda to set for scale factor of projection
         */
        public void setLambda(double lambda) {
            this.lambda = lambda;
        }

        public double[] getRadialDistortionCoeffs() {
            return radialDistortionCoeffs;
        }

        public void setRadialDistortionCoeffs(double[] radialDistortionCoeffs) {
            this.radialDistortionCoeffs = radialDistortionCoeffs;
        }
    }
    
    public static class CameraProjection {
        /**
         * the projection matrix of a camera which is a 3X4 matrix of
         * intrinsic times extrinsic parameter matrices
         */
        private double[][] p;
        public CameraProjection(double[][] projection) {
            this.p = projection;
        }

        /**
         * @return the p
         */
        public double[][] getP() {
            return p;
        }

        /**
         * @param p the p to set
         */
        public void setP(double[][] p) {
            this.p = p;
        }
    }

    public static class CameraParameters {
        private final CameraIntrinsicParameters intrinsicParameters;
        private final CameraExtrinsicParameters extrinsicParameters;

        public CameraParameters(CameraIntrinsicParameters intrinsics,
                CameraExtrinsicParameters extrinsics) {
            this.intrinsicParameters = intrinsics;
            this.extrinsicParameters = extrinsics;
        }

        /**
         * @return the intrinsicParameters
         */
        public CameraIntrinsicParameters getIntrinsicParameters() {
            return intrinsicParameters;
        }

        /**
         * @return the extrinsicParameters
         */
        public CameraExtrinsicParameters getExtrinsicParameters() {
            return extrinsicParameters;
        }
    }

    public static class CameraPoseParameters extends CameraParameters {
        private final double[] p3;
        public CameraPoseParameters(CameraIntrinsicParameters intrinsics, CameraExtrinsicParameters extrinsics,
                                    double[] p3) {
            super(intrinsics, extrinsics);
            this.p3 = p3;
        }

        /**
         the last column of the projection matrix P which was [3 X 4] in size.
         &lt;pre&gt;
         Regarding translation, p3 is included in the results.  p3 is the last column in the projection
         matrix calculated internally.  (2) and (4) outlined below are what you should consider using
         to estimate the translation, depending upon your system's use of translate then rotate or vice versa.

         If the user is assuming translate, then rotate: X_c = R * (X_wcs - t).
             (1) The projection matrix constructed would be [R*XW | -R*t]
                 where the last column is -R*t, R is rotation, t is translation,
                 XW is object in real world coordinate frame, X_c is the object location seen in
                 the camera reference frame.
                 In this case, one would extract the translation
                 using t = -1*(R^-1)*p3.  Note that when properly formed, R^-1 = R^T because rotation is orthogonal and unitary.
             (2) For the context of X_im = K * X_c, we have P = [K*R*XW | -K*R*t]
                 where K is the intrinsic parameter matrix for the camera.
                 In this case, one would extract the translation
                 using t = -1 * R^-1 * K^-1 * p3.
         If the user is assuming rotate then translate, X_c = R * X_wcs + t.
             (3) The projection matrix constructed would be [R*XW | t].
                 In this case, one would extract the translation
                 using t = p3.
             (4) For the context of X_im = K * X_c, we have P = [K*R*XW | K*t].
                 In this case, one would extract the translation
                 using t = K^-1 * p3.
         &lt;/pre&gt;
         * @return
         */
        public double[] getP3() {
            return p3;
        }
    }

    public static class CameraExtrinsicParameters {
        private double[][] rotation;
        private double[] translation;
        private double[] rodriguesVector;

        public CameraExtrinsicParameters(double[][] rotation, double[] rodriguesRotationVector, double[] translation) {
            this.rotation = rotation;
            this.rodriguesVector = rodriguesRotationVector;
            this.translation = translation;
        }

        public CameraExtrinsicParameters() {}

        /**
         * @return the rotation
         */
        public double[][] getRotation() {
            return rotation;
        }

        public static double[][] applyOrthoNormalization(double[][] r) throws NotConvergedException {
            //return Rotation.orthonormalizeUsingSkewCayley(r);
            return Rotation.orthonormalizeUsingSVD(r);
        }

        public void setRodriguesVector(double[] rVector) {
            this.rodriguesVector = rVector;
        }
        public double[] getRodriguesVector() {
            return this.rodriguesVector;
        }

        /**
         * @param rotation the rotation to set
         */
        public void setRotation(double[][] rotation) {
            this.rotation = rotation;
        }

        /**
         * @return the translation
         */
        public double[] getTranslation() {
            return translation;
        }

        /**
         * @param translation the translation to set
         */
        public void setTranslation(double[] translation) {
            this.translation = translation;
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;rot=\n&quot;);
            if (rotation != null) {
                sb.append(FormatArray.toString(rotation, &quot;%.4e&quot;));
            }
            sb.append(&quot;trans=\n&quot;);
            if (translation != null) {
                sb.append(FormatArray.toString(translation, &quot;%.4e&quot;));
            }
            return sb.toString();
        }
    }
    
    public static class CameraMatrices {
        private CameraIntrinsicParameters intrinsics;
        private List&lt;CameraExtrinsicParameters&gt; extrinsics = new ArrayList&lt;CameraExtrinsicParameters&gt;();

        /**
         * @return the radialDistortion
         */
        public double[] getRadialDistortCoeff() {
            return intrinsics.getRadialDistortionCoeffs();
        }
        
        /**
         * @return true if using radial distortion function from Ma et al. 2004 
         for model #4 in Table 2, f(r) = 1 +k1*r^2 + k2*r^4,
         else return false if using model #3 f(r) = 1 +k1*r + k2*r^2.
        */
        public boolean useR2R4() {
            return intrinsics.useR2R4();
        }

        /**
         * @return the intrinsics
         */
        public CameraIntrinsicParameters getIntrinsics() {
            return intrinsics;
        }

        /**
         * @param intrinsics the intrinsics to set
         */
        public void setIntrinsics(CameraIntrinsicParameters intrinsics) {
            this.intrinsics = intrinsics;
        }

        /**
         * @return the extrinsics
         */
        public List&lt;CameraExtrinsicParameters&gt; getExtrinsics() {
            return extrinsics;
        }

        /**
         * @param extrinsics the extrinsics to set
         */
        public void addExtrinsics(CameraExtrinsicParameters extrinsics) {
            this.extrinsics.add(extrinsics);
        }
        /**
         * @param extrinsics the extrinsics to set
         */
        public void addExtrinsics(List&lt;CameraExtrinsicParameters&gt; extrinsics) {
            this.extrinsics.addAll(extrinsics);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
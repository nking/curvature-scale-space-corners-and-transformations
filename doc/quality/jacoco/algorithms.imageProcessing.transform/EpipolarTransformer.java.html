<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EpipolarTransformer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">EpipolarTransformer.java</span></div><h1>EpipolarTransformer.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.imageProcessing.MiscellaneousCurveHelper;
import algorithms.imageProcessing.features.FeatureComparisonStat;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.util.PairFloatArray;
import algorithms.imageProcessing.util.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.util.PairInt;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.NotConvergedException;
import no.uib.cipr.matrix.SVD;

/**
 * class to solve for the epipoles for two images with stereo projection
 * and apply the solution.
 *
 * &lt;pre&gt;
 * The fundamental matrix is the projective solution for transformation
 * between 2 images of the same objects in pixel coordinates.
 * Present below is the solution for having 7 matched points between images
 * and the solution for having 8 or more matched points between the images.
 * Both use numerical conditioning and recipes suggested by Hartley
 * (see reference below).
 *
 * Following:
 *
 * IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, VOL. 19,
 * NO. 6, JUNE 1997
 * &quot;In Defense of the Eight-Point Algorithm&quot; by Richard Hartley

 * The 8-point algorithm matrix represents epipolar geometry, and can be
 * used with data from cameras whose characteristics are not known to solve
 * up to the projective transformation.
 *
 * Some definitions:
    u^T*v represents the inner product
    u*v^T is a matrix
    the norm of a vector f is the square root of the sum or squares of its
        entries.
    u_1 is the (x,y) points from image 1 and u_2 are the matched (x,y) points
        from image 2.

    the fundamental matrix is defined:
        u_2^T * F * u_1 = 0  where u are the x,y points in images _1 and _2

    u_1 = (x_1, y_1, 1)^T
    u_2 = (x_2, y_2, 1)^T

    x_1*x_2*F_1_1 + x_1*y_2*F_2_1 + x_1*F_3_1 + y_1*x_2*F_1_2 + y_1*y_2*F_2_2
        + y_1*F_3_2 + x_2*F_1_3 + y_2*F_2_3 + F_3_3 = 0

    A * f = 0

    where A = x_1*x_2, x_1*y_2, x_1, y_1*x_2, y_1*y_2, y_1, x_2, y_2, 1

    To avoid the trivial scale, ||f|| = 1 where f is the norm of f

    And we need least squares fits because the set may be over determined
    and not have a zero solution.

    we want the vector f that minimizes ||A*f|| subject to the constraint
    that ||f|| = f^T*f = 1

    the solution is the unit eigenvector corresponding to the smallest
    eigenvalue of A^T*A.

    Since A^T*A is semi-definite and symmetric, all of its eigenvectors
    are real and positive or zero.
    This eigenvector is what he calls the least eigenvector of A^T*A and
    it is found via the Jacobi algorithm or Singular Value Decomposition.

    The solved for matrix will in general not have rank 2 and needs to, so
    further corrections are necessary:
        matrix F is replaced by F' that minimizes the Frobenius norm
        ||F - F'|| subject to the condition det F' = 0.
        A convenient method of doing this is to use the Singular Value
        Decomposition (SVD).
           let F = U*D*V^T be the SVD of F, where D is diagonal matrix
           D = diag(r, s, t) satisfying r &gt;= s &gt;= t.
           let F' = U*diag(r, s, 0)*V^T.

 (1) Transforming the coordinates:

     Normalization for isotropic scaling.

     utrans = T * u ==&gt; u = utrans * inv(T)

     u_2^T * F * u_1 = 0

        becomes   utrans_2^T * inv(T_2) * F * inv(T_1) * utrans_1 = 0

        and inv(T_2) * F * inv(T_1) is the fundamental matrix for
        utrans_2 &lt; -- &gt; utrans_1 which when found, will be subsequently
        denormalized.

    a) points are translated so that their centroid is at the origin.
    b) points are then scaled so that the average distance from the
       origin is sqrt(2)
    c) the transformation is applied to each of the 2 images separately.

 (2) build matrix A with the normalized x,y points

 (3) compute linear least square solution to the least eigenvector of f.
     solve A = U * D * V^T   for A*f = [..x...]*f = 0
     A has rank 8.  f has rank 2.
     calculate [U,D,V] from svd(A)

 (4) make the fundamental matrix have a rank of 2
     by performing a svd and then reconstructing with the two largest
     singular values.
         [U,D,V] = svd(F,0);
         F = U * diag([D(1,1) D(2,2) 0]) * V^T;

 (5) denormalize the fundamental matrix
     The related part of the normalization equation: inv(T_2) * F * inv(T_1)
     so denormalizing is:

         F = (T_1)^T * F * T_2

 (6) estimate the error in the fundamental matrix by calculating epipolar
     lines for points in image 1 and find their nearest points in image 2
     and measure the perpendicular distance from the epipolar line for
     those nearest points.

 The 7-point algorithm is also implemented below and is similar to the
 8-point solution except that is solves for the null space of the fundamental
 matrix and results in one or 3 solutions which can for some geometries
 be reduced to a single solution.
 The normalization and denormalization steps before and following the solution,
 are the same as in the 8-point solution.
 * 

    right epipolar lines:
        fm * leftXY
    left epipolar lines:
        fm^T * rightXY
   
 * &lt;/pre&gt;
 *
 * @author nichole
 */
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">public class EpipolarTransformer {</span>

<span class="fc" id="L155">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

    /**
     * calculate the fundamental matrix for the given matched left and
     * right correspondence of 8 or more matched points.
     * 
     * @param pointsLeftXY
     * @param pointsRightXY
     * @return 
     */
    public DenseMatrix calculateEpipolarProjection(
        PairIntArray pointsLeftXY,  PairIntArray pointsRightXY) {

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (pointsLeftXY == null) {</span>
<span class="nc" id="L169">            throw new IllegalArgumentException(&quot;pointsLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (pointsRightXY == null) {</span>
<span class="nc" id="L172">            throw new IllegalArgumentException(&quot;pointsRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() != pointsRightXY.getN()) {</span>
<span class="nc" id="L175">            throw new IllegalArgumentException(</span>
                &quot;pointsLeftXY and pointsRightXY must be same size&quot;);
        }

<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() == 7) {</span>
<span class="nc" id="L180">            throw new IllegalArgumentException(</span>
                &quot;for 7 points, use calculateEpipolarProjectionFor7Points&quot;);
        }

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() &lt; 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L186">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot;
<span class="nc" id="L188">                + &quot; pointsLeftXY.n=&quot; + pointsLeftXY.getN());</span>
        }

<span class="fc" id="L191">        return calculateEpipolarProjection(</span>
<span class="fc" id="L192">            rewriteInto3ColumnMatrix(pointsLeftXY),</span>
<span class="fc" id="L193">            rewriteInto3ColumnMatrix(pointsRightXY));</span>
    }

    /**
     * calculate the epipolar projection for a set of 8 or more matched points.
     *
     * @param theLeftXY
     * @param theRightXY
     * @return
     */
    public DenseMatrix calculateEpipolarProjection(
        DenseMatrix theLeftXY, DenseMatrix theRightXY) {

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (theLeftXY == null) {</span>
<span class="nc" id="L207">            throw new IllegalArgumentException(&quot;theLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (theRightXY == null) {</span>
<span class="nc" id="L210">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (theLeftXY.numColumns()!= theRightXY.numColumns()) {</span>
<span class="nc" id="L213">            throw new IllegalArgumentException(</span>
                &quot;theLeftXY and theRightXY must be same size&quot;);
        }

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (theLeftXY.numColumns() == 7) {</span>
<span class="nc" id="L218">            throw new IllegalArgumentException(</span>
                &quot;for 7 points, use calculateEpipolarProjectionFor7Points&quot;);
        }

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (theLeftXY.numColumns() &lt; 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L224">            throw new IllegalArgumentException(</span>
                &quot;the algorithms require 7 or more points.&quot;
<span class="nc" id="L226">                + &quot; refactorLeftXY.n=&quot; +theLeftXY.numColumns());</span>
        }

        //the matrix convention is [mRows][nCols]

<span class="fc" id="L231">        DenseMatrix fundamentalMatrix = (DenseMatrix) calculateFundamentalMatrix(theLeftXY, </span>
<span class="fc" id="L232">            theRightXY).transpose();</span>

<span class="fc" id="L234">        return fundamentalMatrix;</span>
    }

    protected DenseMatrix calculateFundamentalMatrix(DenseMatrix leftXY,
        DenseMatrix rightXY) {

        //x is xy[0], y is xy[1], xy[2] is all 1's
<span class="fc" id="L241">        NormalizedXY normalizedXY1 = normalize(leftXY);</span>

<span class="fc" id="L243">        NormalizedXY normalizedXY2 = normalize(rightXY);</span>

<span class="fc" id="L245">        return calculateFundamentalMatrix(normalizedXY1, normalizedXY2);</span>
    }

    /*
    for 7-point algorithm:

    (1) SVD of matrix A (as is done in 8-point algorithm)
        giving a matrix of rank 7
    (2) The homogeneous system AX = 0 : X is the null space of matrix A.
        The system is nullable because rank 7 &lt; number of columns, 9.

        The nullable system must have a solution other than trivial where
        |A| = 0.

        There should be 9-7=2 linearly independent vectors u1, u2, ... , un-r
        that span the null space of A.

        The right null space of A reduced by SVD is then 2D and the last
        2 columns of V can be extracted and reshaped to [3x3] as F1 and F2.

        A linear convex combination of F1 and F2 form the estimate of F.

        F = α*F1 + (1 − α)*F2  where α is between 0 and 1

        The eigenvalues of F are possible only if the determinant of F is 0.
        The determinant of F is a polynomial function, the characteristic
        polynomial whose degree is the order of the matrix, which is 3 in this
        case. Therefore, the answer(s) to determinant(F) = 0 requires the cubic
        roots of the equation.

        det A = 0 ==&gt; det(α*F1 + (1 − α)*F2) = 0

        because det(F1 + F2) != det(F1) + det(F2), have to step through the
        determinant of the sums, and group the terms by a^3, a^2, a^1, and a^0
        and then solve for the cubic roots as the values of 'a'.

   The matrices multiplied and summed:

    a*ff1[0][0] + (1-a)*ff2[0][0]   a*ff1[0][1] + (1-a)*ff2[0][1]   a*ff1[0][2] + (1-a)*ff2[0][2]
    a*ff1[1][0] + (1-a)*ff2[1][0]   a*ff1[1][1] + (1-a)*ff2[1][1]   a*ff1[1][2] + (1-a)*ff2[1][2]
    a*ff1[2][0] + (1-a)*ff2[2][0]   a*ff1[2][1] + (1-a)*ff2[2][1]   a*ff1[2][2] + (1-a)*ff2[2][2]

    The terms are further grouped below in methods
       calculateCubicRoot...OrderCoefficientFor7Point(ff1, ff2)

    After the cubic root(s) are solved, they are back substituted into :
        Fi = a(i) * FF{1} + (1-a(i)) * FF{2};
    to get the solutions Fi which may be one or 3 solutions.
    */

    /**
     * calculate the epipolar projection for a set of matched points that are
     * at 7 points in length.
     *
     * @param pointsLeftXY
     * @param pointsRightXY
     * @return
     */
    public List&lt;DenseMatrix&gt; calculateEpipolarProjectionFor7Points(
        PairIntArray pointsLeftXY, PairIntArray pointsRightXY) {

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (pointsLeftXY == null) {</span>
<span class="nc" id="L307">            throw new IllegalArgumentException(&quot;refactorLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (pointsRightXY == null) {</span>
<span class="nc" id="L310">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() != pointsRightXY.getN()) {</span>
<span class="nc" id="L313">            throw new IllegalArgumentException(</span>
                &quot;refactorLeftXY and refactorRightXY must be same size&quot;);
        }

<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (pointsLeftXY.getN() != 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L319">            throw new IllegalArgumentException(</span>
                &quot;the 7-point problem requires 7 points.&quot;
<span class="nc" id="L321">                + &quot; pointsLeftXY.n=&quot; + pointsLeftXY.getN());</span>
        }

<span class="fc" id="L324">        return calculateEpipolarProjectionFor7Points(</span>
<span class="fc" id="L325">            rewriteInto3ColumnMatrix(pointsLeftXY),</span>
<span class="fc" id="L326">            rewriteInto3ColumnMatrix(pointsRightXY));</span>
    }

    /**
     * calculate the epipolar projection for a set of matched points that are
     * at 7 points in length.
     *
     * @param theLeftXY
     * @param theRightXY
     * @return
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public List&lt;DenseMatrix&gt; calculateEpipolarProjectionFor7Points(
        DenseMatrix theLeftXY, DenseMatrix theRightXY) {

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (theLeftXY == null) {</span>
<span class="nc" id="L342">            throw new IllegalArgumentException(&quot;refactorLeftXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (theRightXY == null) {</span>
<span class="nc" id="L345">            throw new IllegalArgumentException(&quot;refactorRightXY cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (theLeftXY.numRows() != theRightXY.numRows()) {</span>
<span class="nc" id="L348">            throw new IllegalArgumentException(</span>
                &quot;theLeftXY and theRightXY must be same size&quot;);
        }
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (theLeftXY.numColumns() != theRightXY.numColumns()) {</span>
<span class="nc" id="L352">            throw new IllegalArgumentException(</span>
                &quot;theLeftXY and theRightXY must be same size&quot;);
        }

<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (theLeftXY.numColumns() != 7) {</span>
            // cannot use this algorithm.
<span class="nc" id="L358">            throw new IllegalArgumentException(</span>
                &quot;the 7-point problem requires 7 points.&quot;
<span class="nc" id="L360">                + &quot; theLeftXY.n=&quot; + theLeftXY.numColumns());</span>
        }

        //x is xy[0], y is xy[1], xy[2] is all 1's
<span class="fc" id="L364">        NormalizedXY normalizedXY1 = normalize(theLeftXY);</span>

<span class="fc" id="L366">        NormalizedXY normalizedXY2 = normalize(theRightXY);</span>

<span class="fc" id="L368">        double[][] m = createFundamentalMatrix(</span>
<span class="fc" id="L369">            normalizedXY1.getXy(), normalizedXY2.getXy());</span>

<span class="fc" id="L371">        DenseMatrix aMatrix = new DenseMatrix(m);</span>
<span class="fc" id="L372">        SVD svd = null;</span>
        
        try {
<span class="fc" id="L375">            svd = SVD.factorize(aMatrix);</span>
<span class="nc" id="L376">        } catch (Throwable t) {</span>
<span class="nc" id="L377">            System.err.println(t.getMessage());</span>
<span class="nc" id="L378">            return null;</span>
<span class="fc" id="L379">        }</span>

        // nCols = 9        
<span class="fc" id="L382">        DenseMatrix nullSpace = MatrixUtil.nullSpace(svd);</span>

<span class="fc" id="L384">        double[][] ff1 = new double[3][3];</span>
<span class="fc" id="L385">        double[][] ff2 = new double[3][3];</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>

<span class="fc" id="L388">            ff1[i] = new double[3];</span>
<span class="fc" id="L389">            ff1[i][0] = nullSpace.get((i * 3) + 0, 0);</span>
<span class="fc" id="L390">            ff1[i][1] = nullSpace.get((i * 3) + 1, 0);</span>
<span class="fc" id="L391">            ff1[i][2] = nullSpace.get((i * 3) + 2, 0);</span>

<span class="fc" id="L393">            ff2[i] = new double[3];</span>
<span class="fc" id="L394">            ff2[i][0] = nullSpace.get((i * 3) + 0, 1);</span>
<span class="fc" id="L395">            ff2[i][1] = nullSpace.get((i * 3) + 1, 1);</span>
<span class="fc" id="L396">            ff2[i][2] = nullSpace.get((i * 3) + 2, 1);</span>
        }

<span class="fc" id="L399">        DenseMatrix[] solutions = solveFor7Point(ff1, ff2);</span>

        //denormalize:  F = (T_1)^T * F * T_2
        //    T_1 is normalizedXY1.getNormalizationMatrix();
        //    T2 is normalizedXY2.getNormalizationMatrix();

<span class="fc" id="L405">        List&lt;DenseMatrix&gt; denormalizedSolutions = new ArrayList&lt;DenseMatrix&gt;();</span>

<span class="fc" id="L407">        DenseMatrix t1Transpose = (DenseMatrix) normalizedXY1</span>
<span class="fc" id="L408">            .getNormalizationMatrix().transpose();</span>
<span class="fc" id="L409">        DenseMatrix t2 = normalizedXY2.getNormalizationMatrix();</span>

<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (DenseMatrix solution : solutions) {</span>

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            if (solution == null) {</span>
<span class="nc" id="L414">                continue;</span>
            }

<span class="fc" id="L417">            DenseMatrix denormFundamentalMatrix = </span>
<span class="fc" id="L418">                MatrixUtil.multiply(t1Transpose,</span>
<span class="fc" id="L419">                    MatrixUtil.multiply(solution, t2));</span>

<span class="fc" id="L421">            double s = 1./denormFundamentalMatrix.get(2, 2);</span>
<span class="fc" id="L422">            MatrixUtil.multiply(denormFundamentalMatrix, s);</span>

<span class="fc" id="L424">            denormFundamentalMatrix = (DenseMatrix) denormFundamentalMatrix.transpose();</span>

            /*
            DenseMatrix validated = validateSolution(denormFundamentalMatrix);

            if (validated != null) {
                denormalizedSolutions.add(validated);
            }*/
<span class="fc" id="L432">                denormalizedSolutions.add(denormFundamentalMatrix);</span>
        }

<span class="fc" id="L435">        return denormalizedSolutions;</span>
    }

    /**
     * The validation of the 7-point algorithm follows source code adapted
     * from this site and license:
     *
     * based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        &quot;MATLAB Functions for Multiple View Geometry&quot;

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a
        * copy of this software and associated documentation files
        * (the &quot;Software&quot;), to deal in the Software without restriction,
        * including without limitation the rights to use, copy, modify, merge,
        * publish, distribute, sublicense, and/or sell copies of the Software,
        * and to permit persons to whom the Software is furnished to do so,
        * subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        * in all copies or substantial portions of the Software.

        The software is provided &quot;as is&quot;, without warranty of any kind, express
        * or implied, including but not limited to the warranties of
        * merchantability, fitness for a particular purpose and noninfringement.
        * In no event shall the authors or copyright holders be liable for any
        * claim, damages or other liability, whether in an action of contract,
        * tort or otherwise, arising from, out of or in connection with the
        * software or the use or other dealings in the software.

       vgg_multiview/vgg_F_from_7pts_2img.m

       The method &quot;signs_OK&quot; validates the solution matrices:

        for i = 1:length(a)
          Fi = a(i)*FF{1} + (1-a(i))*FF{2};
          %for n = 1:7, disp(norm(x(:,n,1)'*Fi*x(:,n,2))), end  % test code
          if signs_OK(Fi,x1,x2)
            F = cat(3, F, Fi);
          end
        end

        return

        %%%%%%%%%%%%%%%%%%%%%%%%%

        % Checks sign consistence of F and x
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F');
        e1 = v(:,3);
        l1 = vgg_contreps(e1)*x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s&gt;0) | all(s less than 0);
        return

    More on the subject is present in &quot;Cheirality in Epipolar Geometry&quot; by
    Werner &amp; Pajdla, 2000 regarding realizability of two images.
    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.9013&amp;rep=rep1&amp;type=pdf

    Very clear paper on cheirality:
    * http://users.cecs.anu.edu.au/~hartley/Papers/cheiral/revision/cheiral.pdf
    * The cheirality of a point is whether it lies in front of or behind a given
    * camera.  It's used to  distinguish between four different possible scene
    * reconstructions from two views.
    * A transform is cheirality-reversing for a given point if it swaps the
    * point from the front to the back of the camera, or vice-versa.
    * Otherwise it is called cheirality-preserving.
    */
    @SuppressWarnings({&quot;unchecked&quot;})
    private DenseMatrix validateSolution(DenseMatrix solution, DenseMatrix leftXY,
        DenseMatrix rightXY) {

        /*
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F');
        e1 = v(:,3);
        l1 = vgg_contreps(e1)*x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s&gt;0) | all(s&lt;0);

        (F*x2) .* l1 ==&gt;  (solution * rightXY) .* (testE1 * leftXY)
        '.*' is mattlab notation to operate on each field

        'sum' is a matlab function to sum for each column

        'all' is a function that returns '1' is all items are non-zero, else
            returns 0
        */

<span class="nc" id="L529">        double[][] leftRightEpipoles = calculateEpipoles(solution);</span>

<span class="nc" id="L531">        double[] testE1 = leftRightEpipoles[0];</span>

<span class="nc" id="L533">        DenseMatrix l1 = leftXY.copy();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        for (int row = 0; row &lt; testE1.length; ++row){</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            for (int col = 0; col &lt; l1.numColumns(); ++col) {</span>
<span class="nc" id="L536">                double value = testE1[row] * l1.get(row, col);</span>
<span class="nc" id="L537">                l1.set(row, col, value);</span>
            }
        }

<span class="nc" id="L541">        double[] sum = new double[l1.numColumns()];</span>
<span class="nc" id="L542">        DenseMatrix t1 = MatrixUtil.multiply(solution, rightXY);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        for (int row = 0; row &lt; testE1.length; ++row){</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            for (int col = 0; col &lt; t1.numColumns(); ++col) {</span>
<span class="nc" id="L545">                double value = l1.get(row, col) * t1.get(row, col);</span>
<span class="nc" id="L546">                t1.set(row, col, value);</span>
<span class="nc" id="L547">                sum[col] += value;</span>
            }
        }

<span class="nc bnc" id="L551" title="All 2 branches missed.">        for (int i = 0; i &lt; sum.length; ++i) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (sum[i] == 0) {</span>
<span class="nc" id="L553">                return null;</span>
            }
        }

<span class="nc" id="L557">        return solution;</span>
    }

    DenseMatrix[] solveFor7Point(double[][] ff1, double[][] ff2) {

<span class="fc" id="L562">        double a0 = calculateCubicRoot3rdOrderCoefficientFor7Point(ff1, ff2);</span>
<span class="fc" id="L563">        double a1 = calculateCubicRoot2ndOrderCoefficientFor7Point(ff1, ff2);</span>
<span class="fc" id="L564">        double a2 = calculateCubicRoot1stOrderCoefficientFor7Point(ff1, ff2);</span>
<span class="fc" id="L565">        double a3 = calculateCubicRoot0thOrderCoefficientFor7Point(ff1, ff2);</span>

<span class="fc" id="L567">        double[] roots = MiscMath.solveCubicRoots(a0, a1, a2, a3);</span>

<span class="fc" id="L569">        double[][] m = new double[3][];</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L571">            m[i] = new double[3];</span>
        }

<span class="fc" id="L574">        DenseMatrix[] solutions = new DenseMatrix[roots.length];</span>

<span class="fc bfc" id="L576" title="All 2 branches covered.">        for (int i = 0; i &lt; roots.length; i++) {</span>

            //Fi = a(i)*FF{1} + (1-a(i))*FF{2};

<span class="fc" id="L580">            double a = roots[i];</span>

<span class="fc bfc" id="L582" title="All 2 branches covered.">            for (int row = 0; row &lt; 3; row++) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                for (int col = 0; col &lt; 3; col++) {</span>
<span class="fc" id="L584">                    m[row][col] = a*ff1[row][col] + (1. - a)*ff2[row][col];</span>
                }
            }

<span class="fc" id="L588">            solutions[i] = new DenseMatrix(m);</span>
        }

<span class="fc" id="L591">        return solutions;</span>
    }

    private double calculateCubicRoot3rdOrderCoefficientFor7Point(
        double[][] ff1, double[][] ff2) {

<span class="fc" id="L597">        double b = ff1[0][0];</span>
<span class="fc" id="L598">        double e = ff1[1][0];</span>
<span class="fc" id="L599">        double h = ff1[2][0];</span>
<span class="fc" id="L600">        double c = ff1[0][1];</span>
<span class="fc" id="L601">        double f = ff1[1][1];</span>
<span class="fc" id="L602">        double i = ff1[2][1];</span>
<span class="fc" id="L603">        double d = ff1[0][2];</span>
<span class="fc" id="L604">        double g = ff1[1][2];</span>
<span class="fc" id="L605">        double j = ff1[2][2];</span>

<span class="fc" id="L607">        double k = ff2[0][0];</span>
<span class="fc" id="L608">        double n = ff2[1][0];</span>
<span class="fc" id="L609">        double q = ff2[2][0];</span>
<span class="fc" id="L610">        double l = ff2[0][1];</span>
<span class="fc" id="L611">        double o = ff2[1][1];</span>
<span class="fc" id="L612">        double r = ff2[2][1];</span>
<span class="fc" id="L613">        double m = ff2[0][2];</span>
<span class="fc" id="L614">        double p = ff2[1][2];</span>
<span class="fc" id="L615">        double s = ff2[2][2];</span>

<span class="fc" id="L617">        double sum = h*g*c + h*o*d + h*o*m + h*p*l + i*e*d + i*g*k</span>
            + i*n*m + i*p*b + j*e*l + j*k*o + j*n*c + q*f*d
            + q*f*m + q*g*l + q*p*c + r*e*m + r*g*b + r*n*d
            + r*p*k + s*b*o + s*e*c + s*k*f + s*n*l + b*j*f
            - h*f*d - h*f*m - h*g*l - h*p*c - i*e*m - i*g*b
            - i*n*d - i*p*k - j*b*o - j*e*c - j*k*f - j*n*l
            - q*g*c - q*o*d - q*o*m - q*p*l - r*e*d - r*g*k
            - r*n*m - r*p*b - s*b*f - s*e*l - s*k*o - s*n*c;

<span class="fc" id="L626">        return sum;</span>
    }

    private double calculateCubicRoot2ndOrderCoefficientFor7Point(double[][] ff1,
        double[][] ff2) {

<span class="fc" id="L632">        double b = ff1[0][0];</span>
<span class="fc" id="L633">        double e = ff1[1][0];</span>
<span class="fc" id="L634">        double h = ff1[2][0];</span>
<span class="fc" id="L635">        double c = ff1[0][1];</span>
<span class="fc" id="L636">        double f = ff1[1][1];</span>
<span class="fc" id="L637">        double i = ff1[2][1];</span>
<span class="fc" id="L638">        double d = ff1[0][2];</span>
<span class="fc" id="L639">        double g = ff1[1][2];</span>
<span class="fc" id="L640">        double j = ff1[2][2];</span>

<span class="fc" id="L642">        double k = ff2[0][0];</span>
<span class="fc" id="L643">        double n = ff2[1][0];</span>
<span class="fc" id="L644">        double q = ff2[2][0];</span>
<span class="fc" id="L645">        double l = ff2[0][1];</span>
<span class="fc" id="L646">        double o = ff2[1][1];</span>
<span class="fc" id="L647">        double r = ff2[2][1];</span>
<span class="fc" id="L648">        double m = ff2[0][2];</span>
<span class="fc" id="L649">        double p = ff2[1][2];</span>
<span class="fc" id="L650">        double s = ff2[2][2];</span>

<span class="fc" id="L652">        double sum = h*f*m + h*g*l + h*p*c + i*e*m + i*n*d + i*p*k</span>
            + i*p*k + j*b*o + j*k*f + j*n*l + j*n*l + q*g*c
            + q*o*d + q*o*d + q*o*m + q*o*m + q*o*m + q*p*l
            + q*p*l + q*p*l + r*e*d + r*g*k + r*g*k + r*n*m
            + r*n*m + r*n*m + r*p*b + r*p*b + s*o*k + s*b*f
            + s*e*l + s*e*l + s*k*o + s*k*o + s*n*c + s*n*c
            - h*o*d - h*o*m - h*o*m - h*p*l - h*p*l - i*g*k
            - i*n*m - i*n*m - i*p*b - j*e*l - j*k*o - j*n*c
            - j*o*k - q*f*d - q*f*m - q*f*m - q*g*l - q*g*l
            - q*p*c - q*p*c - r*e*m - r*e*m - r*g*b - r*n*d
            - r*n*d - r*p*k - r*p*k - r*p*k - s*b*o - s*b*o
            - s*e*c - s*k*f - s*k*f - s*n*l - s*n*l - s*n*l;

<span class="fc" id="L665">        return sum;</span>
    }

    private double calculateCubicRoot1stOrderCoefficientFor7Point(double[][] ff1,
        double[][] ff2) {

        /*
        f1 =
         b c d
         e f g
         h i j
        f2 =
         k l m
         n o p
         q r s
        */

<span class="fc" id="L682">        double b = ff1[0][0];</span>
<span class="fc" id="L683">        double e = ff1[1][0];</span>
<span class="fc" id="L684">        double h = ff1[2][0];</span>
<span class="fc" id="L685">        double c = ff1[0][1];</span>
<span class="fc" id="L686">        double f = ff1[1][1];</span>
<span class="fc" id="L687">        double i = ff1[2][1];</span>
<span class="fc" id="L688">        double d = ff1[0][2];</span>
<span class="fc" id="L689">        double g = ff1[1][2];</span>
<span class="fc" id="L690">        double j = ff1[2][2];</span>

<span class="fc" id="L692">        double k = ff2[0][0];</span>
<span class="fc" id="L693">        double n = ff2[1][0];</span>
<span class="fc" id="L694">        double q = ff2[2][0];</span>
<span class="fc" id="L695">        double l = ff2[0][1];</span>
<span class="fc" id="L696">        double o = ff2[1][1];</span>
<span class="fc" id="L697">        double r = ff2[2][1];</span>
<span class="fc" id="L698">        double m = ff2[0][2];</span>
<span class="fc" id="L699">        double p = ff2[1][2];</span>
<span class="fc" id="L700">        double s = ff2[2][2];</span>

<span class="fc" id="L702">        double sum = h*o*m + h*p*l + i*n*m + j*o*k + q*f*m + q*g*l + q*p*c</span>
            + r*e*m + r*n*d + r*p*k + r*p*k + r*p*k + s*b*o + s*k*f
            + s*n*l + s*n*l + s*n*l
            - i*p*k - j*n*l - q*o*d - q*o*m - q*o*m - q*o*m
            - q*p*l - q*p*l - q*p*l - r*g*k - r*n*m - r*n*m
            - r*n*m - r*p*b - s*e*l - s*k*o - s*n*c - s*o*k
            - s*o*k;

<span class="fc" id="L710">        return sum;</span>
    }

    private double calculateCubicRoot0thOrderCoefficientFor7Point(
        double[][] ff1, double[][] ff2) {

        /*
        f1 =
         b c d
         e f g
         h i j
        f2 =
         k l m
         n o p
         q r s
        */

<span class="fc" id="L727">        double k = ff2[0][0];</span>
<span class="fc" id="L728">        double n = ff2[1][0];</span>
<span class="fc" id="L729">        double q = ff2[2][0];</span>
<span class="fc" id="L730">        double l = ff2[0][1];</span>
<span class="fc" id="L731">        double o = ff2[1][1];</span>
<span class="fc" id="L732">        double r = ff2[2][1];</span>
<span class="fc" id="L733">        double m = ff2[0][2];</span>
<span class="fc" id="L734">        double p = ff2[1][2];</span>
<span class="fc" id="L735">        double s = ff2[2][2];</span>

<span class="fc" id="L737">        double sum = q * o * m + q * p * l + r * n * m + s * o * k - r*p*k</span>
            - s*n*l;

<span class="fc" id="L740">        return sum;</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;})
    DenseMatrix calculateFundamentalMatrix(NormalizedXY normalizedXY1,
        NormalizedXY normalizedXY2) {

        //build the fundamental matrix
<span class="fc" id="L748">        double[][] m = createFundamentalMatrix(normalizedXY1.getXy(),</span>
<span class="fc" id="L749">            normalizedXY2.getXy());</span>

        /*
        compute linear least square solution:
            solve A = U * D * V^T   for A*f = [..x...]*f = 0
            A has rank 8.  f has rank 2.

        calculate [U,D,V] from svd(A):
           result has mRows = number of data points
                      nCols = 9
        */
<span class="fc" id="L760">        DenseMatrix aMatrix = new DenseMatrix(m);</span>
<span class="fc" id="L761">        SVD svd = null;</span>
        try {
<span class="fc" id="L763">            svd = SVD.factorize(aMatrix);</span>
<span class="nc" id="L764">        } catch (NotConvergedException e) {</span>
<span class="nc" id="L765">            log.severe(e.getMessage());</span>
<span class="nc" id="L766">            return null;</span>
<span class="fc" id="L767">        }</span>
        
<span class="fc" id="L769">        DenseMatrix V = svd.getVt();</span>

        // creates U as nXY1 x nXY1 matrix  (MXM)
        //         D as length 9 array      (NXN)
        //         V as 9 x 9 matrix        (NXN)

        // mRows = 9; nCols = 9
      
        // reshape V to 3x3  (just the last column)

<span class="fc" id="L779">        int vNCols = V.numColumns();</span>

<span class="fc" id="L781">        double[][] ff = new double[3][3];</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L783">            ff[i] = new double[3];</span>
<span class="fc" id="L784">            ff[i][0] = V.get((i * 3) + 0, vNCols - 1);</span>
<span class="fc" id="L785">            ff[i][1] = V.get((i * 3) + 1, vNCols - 1);</span>
<span class="fc" id="L786">            ff[i][2] = V.get((i * 3) + 2, vNCols - 1);</span>
        }
<span class="fc" id="L788">        DenseMatrix fMatrix = new DenseMatrix(ff);</span>

        /* make the fundamental matrix have a rank of 2
        by performing a svd and then reconstructing with the two largest
        singular values.
            [U,D,V] = svd(F,0);

        From [U,D,V] we create:
            F = U * diag([D(1,1) D(2,2) 0]) * V^T, where V^T is V transposed.
        */
        try {
<span class="fc" id="L799">            svd = SVD.factorize(fMatrix);</span>
<span class="nc" id="L800">        } catch (NotConvergedException e) {</span>
<span class="nc" id="L801">            log.severe(e.getMessage());</span>
<span class="nc" id="L802">            return null;</span>
<span class="fc" id="L803">        }</span>
        
        // creates U as 3 x 3 matrix
        //         D as length 3 array
        //         V as 3 x 3 matrix

<span class="fc" id="L809">        double[] sDiag = svd.getS();</span>
        
        // keep the largest 2 valus in sDiag to make the diagonal rank 2
<span class="fc" id="L812">        DenseMatrix d = new DenseMatrix(3, 3);</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if (sDiag.length &gt; 0) {</span>
<span class="fc" id="L814">            d.set(0, 0, sDiag[0]);</span>
        }
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">        if (sDiag.length &gt; 1) {</span>
<span class="fc" id="L817">            d.set(1, 1, sDiag[1]);</span>
        }

        /*
        multiply the terms:
             F = dot(U, dot(diag(D),V^T))
        */
<span class="fc" id="L824">        DenseMatrix dDotV = MatrixUtil.multiply(d, svd.getVt().transpose());</span>

        // 3x3
<span class="fc" id="L827">        DenseMatrix theFundamentalMatrix = MatrixUtil.multiply(svd.getU(), dDotV);</span>

<span class="fc" id="L829">        DenseMatrix denormFundamentalMatrix =</span>
<span class="fc" id="L830">            denormalizeTheFundamentalMatrix(theFundamentalMatrix,</span>
                normalizedXY1, normalizedXY2);

<span class="fc" id="L833">        return denormFundamentalMatrix;</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;})
    DenseMatrix denormalizeTheFundamentalMatrix(
        DenseMatrix normalizedFundamentalMatrix,
        NormalizedXY normalizedLeftXY, NormalizedXY normalizedRightXY) {

        /*
        denormalize
            F = (T_1)^T * F * T_2
            where T_1 is normalizedXY1.getNormalizationMatrix();
            and T2 is normalizedXY2.getNormalizationMatrix();
        */

<span class="fc" id="L848">        DenseMatrix t1Transpose = (DenseMatrix) normalizedLeftXY</span>
<span class="fc" id="L849">            .getNormalizationMatrix().transpose();</span>
<span class="fc" id="L850">        DenseMatrix t2 = normalizedRightXY.getNormalizationMatrix();</span>

<span class="fc" id="L852">        DenseMatrix denormFundamentalMatrix = </span>
<span class="fc" id="L853">            MatrixUtil.multiply(t1Transpose,</span>
<span class="fc" id="L854">                MatrixUtil.multiply(normalizedFundamentalMatrix, t2));</span>

<span class="fc" id="L856">        double factor = 1./denormFundamentalMatrix.get(2, 2);</span>
<span class="fc" id="L857">        MatrixUtil.multiply(denormFundamentalMatrix, factor);</span>

<span class="fc" id="L859">        return denormFundamentalMatrix;</span>
    }

    /**
     normalize the x,y coordinates as recommended by Hartley 1997 and return
     the matrix and coordinates.
     does not modify the state of this transformer instance.
     * @param xyPair
     * @return
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    NormalizedXY normalize(DenseMatrix xy) {

        /*
        uTransposed = T * u
        uTransposed * inv(T) = u

                uTransposed_2^T * inv(T_2) * F * inv(T_1) * uTransposed_1

        format the tensors T_1 and T_2 such that the applied translation
        and scaling have the effect of:

        a) points are translated so that their centroid is at the origin.
        b) points are then scaled so that the average distance from the
           origin is sqrt(2)
        c) the transformation is applied to each of the 2 images separately.
        */

<span class="fc" id="L887">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
        //x is xy[0], y is xy[1], xy[2] is all 1's
<span class="fc" id="L890">        double cen0 = 0;</span>
<span class="fc" id="L891">        double cen1 = 0;</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        for (int i = 0; i &lt; xy.numRows(); ++i) {</span>
<span class="fc" id="L893">            cen0 += xy.get(i, 0);</span>
<span class="fc" id="L894">            cen1 += xy.get(i, 1);</span>
        }
<span class="fc" id="L896">        cen0 /= (double)xy.numRows();</span>
<span class="fc" id="L897">        cen1 /= (double)xy.numRows();</span>

<span class="fc" id="L899">        double mean = 0;</span>
<span class="fc" id="L900">        int n = xy.numColumns();</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L902">            double diffX = xy.get(0, i) - cen0;</span>
<span class="fc" id="L903">            double diffY = xy.get(1, i) - cen1;</span>
<span class="fc" id="L904">            double dist = Math.sqrt((diffX * diffX) + (diffY * diffY));</span>
<span class="fc" id="L905">            mean += dist;</span>
        }

<span class="fc" id="L908">        mean /= (double)n;</span>

        /*
        mean * factor = sqrt(2)
        */
<span class="fc" id="L913">        double scaleFactor = Math.sqrt(2)/mean;</span>

<span class="fc" id="L915">        DenseMatrix tMatrix = createScaleTranslationMatrix(scaleFactor, cen0, cen1);</span>
        
<span class="fc" id="L917">        DenseMatrix normXY = new DenseMatrix(MatrixUtil.dot(tMatrix, xy));</span>
        
<span class="fc" id="L919">        NormalizedXY normalizedXY = new NormalizedXY();</span>
<span class="fc" id="L920">        normalizedXY.setCentroidXY(new double[]{cen0, cen1});</span>
<span class="fc" id="L921">        normalizedXY.setNormMatrix(tMatrix);</span>
<span class="fc" id="L922">        normalizedXY.setXy(normXY);</span>

<span class="fc" id="L924">        return normalizedXY;</span>
    }
    
    /**
     * create a matrix to be applied on the left side of the dot operator
     * with a matrix of points to transform the points by scale and translation.
     * @param scale
     * @param centroidX
     * @param centroidY
     * @return 
     */
    protected DenseMatrix createScaleTranslationMatrix(double scale, 
        double centroidX, double centroidY) {
        
        /*
        scale, rotate, then translate.
        let xc = x centroid
        let yc = y centroid
        let sX = scaleFactor in x
        let sY = scaleFactor in y
            here, sX = sY
        let r = rotation 
            here, rotation = 0, so math.cos(0)=1, math.sin(0)=0
        let tX = x translation
            here, tX = -xc*sX
        let tY = y translation
            here, tY = -yc*sY
        
        transformation equations for x are for translating the points to the 
        centroid, then scaling them
           x_transformed = xc*s + ((x - xc)*s) + tX = x*s - xc*s
           y_transformed = yc*s + ((y - yc)*s) + tY = y*s - yc*s
        
        matrix for xy matrix has format xy[row][col] 
            where row=0 is x and row=1 is y, and row=2 is placeholder of value 1
        x[0]  x[1]  x[2]  x[3]
        y[0]  y[1]  y[2]  y[3]
        1      1      1     1
        
        Formatting the scale and translation into a matrix that can be used
        with dot operator to transform the points.
        Because the xy points have the x and y along rows, this new transformation
        matrix must be used on the left side of the dot operation.
        
           t dot xy = tranformed xy

        t00     t01      t02
        t10     t11      t12
        0        0        1
        
        t00*x[0] + t01*y[0] + t02*1 = x[0]*s - xc*s
                         0
             =&gt; t00 = s
             =&gt; t01 = 0
             =&gt; t02 = -xc*s

        t10*x[0] + t11*y[0] + t12*1 = y[0]*s - yc*s      
            0
             =&gt; t10 = 0
             =&gt; t11 = s
             =&gt; t12 = -yc*s
        */

<span class="fc" id="L987">        double[][] t = new double[3][];</span>
<span class="fc" id="L988">        t[0] = new double[]{scale,       0,     -centroidX*scale};</span>
<span class="fc" id="L989">        t[1] = new double[]{0,           scale, -centroidY*scale};</span>
<span class="fc" id="L990">        t[2] = new double[]{0,           0,           1};</span>
<span class="fc" id="L991">        DenseMatrix tMatrix = new DenseMatrix(t);</span>

<span class="fc" id="L993">        return tMatrix;</span>
    }

    /**
     * write a matrix of size mRows = 3, nCols = xyPairs.getN()
     * @param xyPairs
     * @return
     */
    public DenseMatrix rewriteInto3ColumnMatrix(PairFloatArray xyPairs) {

<span class="nc" id="L1003">        DenseMatrix xy = new DenseMatrix(3, xyPairs.getN());</span>

        // rewrite xyPairs into a matrix of size 3 X xy.getN();
        // row 0 is x
        // row 1 is y
        // row 2 is all 1's
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        for (int i = 0; i &lt; xyPairs.getN(); i++) {</span>
<span class="nc" id="L1010">            xy.set(0, i, xyPairs.getX(i));</span>
<span class="nc" id="L1011">            xy.set(1, i, xyPairs.getY(i));</span>
<span class="nc" id="L1012">            xy.set(2, i, 1);</span>
        }

<span class="nc" id="L1015">        return xy;</span>
    }

    /**
     * write a matrix of size mRows = 3, nCols = xyPairs.getN()
     * @param xyPairs
     * @return
     */
    public DenseMatrix rewriteInto3ColumnMatrix(List&lt;PairInt&gt; xyPairs) {

<span class="nc" id="L1025">        DenseMatrix xy = new DenseMatrix(3, xyPairs.size());</span>

        // rewrite xyPairs into a matrix of size 3 X xy.getN();
        // row 0 is x
        // row 1 is y
        // row 2 is all 1's
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        for (int i = 0; i &lt; xyPairs.size(); i++) {</span>
<span class="nc" id="L1032">            PairInt p = xyPairs.get(i);</span>
<span class="nc" id="L1033">            xy.set(0, i, p.getX());</span>
<span class="nc" id="L1034">            xy.set(1, i, p.getY());</span>
<span class="nc" id="L1035">            xy.set(2, i, 1);</span>
        }

<span class="nc" id="L1038">        return xy;</span>
    }

    /**
     * write a matrix of size mRows = 3, nCols = xyPairs.getN()
     * @param xyPairs
     * @return
     */
    public DenseMatrix rewriteFirstItemInto3ColumnMatrix(List&lt;List&lt;PairInt&gt;&gt; xyPairs) {

<span class="nc" id="L1048">        DenseMatrix xy = new DenseMatrix(3, xyPairs.size());</span>

        // rewrite xyPairs into a matrix of size 3 X xy.getN();
        // row 0 is x
        // row 1 is y
        // row 2 is all 1's
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        for (int i = 0; i &lt; xyPairs.size(); i++) {</span>
<span class="nc" id="L1055">            List&lt;PairInt&gt; points = xyPairs.get(i);</span>
<span class="nc" id="L1056">            PairInt p = points.get(0);</span>
<span class="nc" id="L1057">            xy.set(0, i, p.getX());</span>
<span class="nc" id="L1058">            xy.set(1, i, p.getY());</span>
<span class="nc" id="L1059">            xy.set(2, i, 1);</span>
        }

<span class="nc" id="L1062">        return xy;</span>
    }

    /**
     * write a matrix of size mRows = 3, nCols = xyPairs.getN()
     * @param xyPairs
     * @return
     */
    public DenseMatrix rewriteInto3ColumnMatrix(PairIntArray xyPairs) {

<span class="fc" id="L1072">        DenseMatrix xy = new DenseMatrix(3, xyPairs.getN());</span>

        // rewrite xyPairs into a matrix of size 3 X xy.getN();
        // row 0 is x
        // row 1 is y
        // row 2 is all 1's
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        for (int i = 0; i &lt; xyPairs.getN(); i++) {</span>
<span class="fc" id="L1079">            xy.set(0, i, xyPairs.getX(i));</span>
<span class="fc" id="L1080">            xy.set(1, i, xyPairs.getY(i));</span>
<span class="fc" id="L1081">            xy.set(2, i, 1);</span>
        }

<span class="fc" id="L1084">        return xy;</span>
    }

    /**
     * @param normXY1 a matrix of size 3 x nPoints, where 1st column is x,
     * second is y.
     * @param normXY2 a matrix of size 3 x nPoints, where 1st column is x,
     * second is y.
     * @return
     */
    double[][] createFundamentalMatrix(DenseMatrix normXY1,
        DenseMatrix normXY2) {

<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">        if (normXY1 == null) {</span>
<span class="nc" id="L1098">            throw new IllegalArgumentException(&quot;normXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">        if (normXY2 == null) {</span>
<span class="nc" id="L1101">            throw new IllegalArgumentException(&quot;normXY2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">        if (normXY1.numColumns() != normXY2.numColumns()) {</span>
<span class="nc" id="L1104">            throw new IllegalArgumentException(</span>
            &quot;the number of columns in normXY1 != number of cols in normXY2&quot;);
        }

<span class="fc" id="L1108">        int nXY1 = normXY1.numColumns();</span>

        /*
        (2) each row in matrix A:
            x_1*x_2,  x_1*y_2,  x_1,  y_1*x_2,  y_1*y_2,  y_1,  x_2,  y_2,  1
        */
<span class="fc" id="L1114">        double[][] a = new double[nXY1][9];</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">        for (int i = 0; i &lt; nXY1; i++) {</span>
<span class="fc" id="L1116">            a[i] = new double[9];</span>
<span class="fc" id="L1117">            double x1 = normXY1.get(0, i);</span>
<span class="fc" id="L1118">            double x2 = normXY2.get(0, i);</span>
<span class="fc" id="L1119">            double y1 = normXY1.get(1, i);</span>
<span class="fc" id="L1120">            double y2 = normXY2.get(1, i);</span>
<span class="fc" id="L1121">            a[i][0] = x1 * x2;</span>
<span class="fc" id="L1122">            a[i][1] = x1 * y2;</span>
<span class="fc" id="L1123">            a[i][2] = x1;</span>
<span class="fc" id="L1124">            a[i][3] = y1 * x2;</span>
<span class="fc" id="L1125">            a[i][4] = y1 * y2;</span>
<span class="fc" id="L1126">            a[i][5] = y1;</span>
<span class="fc" id="L1127">            a[i][6] = x2;</span>
<span class="fc" id="L1128">            a[i][7] = y2;</span>
<span class="fc" id="L1129">            a[i][8] = 1;</span>
        }

<span class="fc" id="L1132">        return a;</span>
    }

    /**
     * calculate the epipoles of the fundamental matrix and return them as
     * an array with left epipole in column 0 and right epipole in column 1.
     * @param fundamentalMatrix
     * @return
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    double[][] calculateEpipoles(DenseMatrix fundamentalMatrix) {

        /*
        The representation of lines in homogeneous projective coordinates
        is:   line a*x + b*y + c = 0
            | a |
            | b |
            | c |
        The line can be rewritten in slope, intercept form:
            y = intercept + slope * x
              = -(c/b) - slope*(a/b)*x

        written as homogenization form of lines:
            | -a/b |
            | -c/b |


        From u_2^T * F * u_1 = 0

        epipoles:
             [U,D,V] = svd(denormalized FundamentalMatrix);
             e1 = last column of V divided by it's last item
             e2 = last column of U divided by it's last item

        */
        SVD svdE;
        try {
<span class="nc" id="L1169">            svdE = SVD.factorize(fundamentalMatrix);</span>
<span class="nc" id="L1170">        } catch (NotConvergedException ex) {</span>
<span class="nc" id="L1171">            Logger.getLogger(EpipolarTransformer.class.getName())</span>
<span class="nc" id="L1172">                .log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L1173">            return null;</span>
<span class="nc" id="L1174">        }</span>
<span class="nc" id="L1175">        DenseMatrix V = (DenseMatrix) svdE.getVt().transpose();</span>
<span class="nc" id="L1176">        double[] e1 = new double[V.numColumns()];</span>
<span class="nc" id="L1177">        double e1Div = V.get(2, 2);</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        for (int i = 0; i &lt; e1.length; i++) {</span>
<span class="nc" id="L1179">            e1[i] = V.get(i, 2)/e1Div;</span>
        }
<span class="nc" id="L1181">        DenseMatrix U = svdE.getU();</span>
<span class="nc" id="L1182">        double[] e2 = new double[U.numColumns()];</span>
<span class="nc" id="L1183">        double e2Div = U.get(2, 2);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        for (int i = 0; i &lt; e2.length; i++) {</span>
<span class="nc" id="L1185">            e2[i] = U.get(i, 2)/e2Div;</span>
        }

<span class="nc" id="L1188">        double[][] e = new double[2][];</span>
<span class="nc" id="L1189">        e[0] = e1;</span>
<span class="nc" id="L1190">        e[1] = e2;</span>

<span class="nc" id="L1192">        return e;</span>
    }

    private EpipolarFeatureTransformationFit combineErrors(EpipolarTransformationFit
        distanceErrors, EpipolarFeatureTransformationFit featureErrors) {
        
        /*
        in order to have the distance errors count as much as the SSD errors,
        need to scale them up or SSD down by a factor.
        
        will use the descriptor size and the average of the maximum SSD that 
        could be calculated and the minimum and make a factor for the
        distances of SSDFactor/tolerance.
        */
        
        // sum square diffs / size = (d0*d0) + (d3*d3).../n
<span class="nc" id="L1208">        double maxSSD = 255. * 255.;</span>
        
<span class="nc" id="L1210">        double distScaleFactor = (maxSSD/2.)/distanceErrors.getTolerance();</span>
        
<span class="nc" id="L1212">        Map&lt;Integer, Double&gt; indexSSDErrorsMap = new HashMap&lt;Integer, Double&gt;();</span>
<span class="nc" id="L1213">        Map&lt;Integer, FeatureComparisonStat&gt; indexFeatureMap = </span>
            new HashMap&lt;Integer, FeatureComparisonStat&gt;();
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        for (int i = 0; i &lt; featureErrors.getInlierIndexes().size(); ++i) {</span>
<span class="nc" id="L1216">            Integer index = featureErrors.getInlierIndexes().get(i);</span>
<span class="nc" id="L1217">            indexSSDErrorsMap.put(index, featureErrors.getErrors().get(i));</span>
<span class="nc" id="L1218">            indexFeatureMap.put(index,</span>
<span class="nc" id="L1219">                featureErrors.getFeatureComparisonStats().get(i));</span>
        }
        
<span class="nc" id="L1222">        List&lt;Integer&gt; outputInliers = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L1223">        List&lt;Double&gt; outputDistances = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L1224">        List&lt;FeatureComparisonStat&gt; fcs = new ArrayList&lt;FeatureComparisonStat&gt;();</span>
        
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        for (int i = 0; i &lt; distanceErrors.getInlierIndexes().size(); ++i) {</span>
<span class="nc" id="L1227">            Integer index = distanceErrors.getInlierIndexes().get(i);</span>
<span class="nc" id="L1228">            Double ssd = indexSSDErrorsMap.get(index);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">            if (ssd != null) {</span>
                
<span class="nc" id="L1231">                outputInliers.add(index);</span>
                
<span class="nc" id="L1233">                Double dist = distanceErrors.getErrors().get(i);</span>
<span class="nc" id="L1234">                double cost = dist.doubleValue() * ssd.doubleValue();</span>
<span class="nc" id="L1235">                outputDistances.add(Double.valueOf(cost));</span>
                
<span class="nc" id="L1237">                fcs.add(indexFeatureMap.get(index));</span>
            }
        }
<span class="nc" id="L1240">        double costTerm2 = 1./(double)outputDistances.size();</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        for (int i = 0; i &lt; outputDistances.size(); ++i) {</span>
<span class="nc" id="L1242">            double err = outputDistances.get(i).doubleValue() * costTerm2 * costTerm2</span>
                * distScaleFactor;
<span class="nc" id="L1244">            outputDistances.set(i, Double.valueOf(err));</span>
        }
        
<span class="nc" id="L1247">        EpipolarFeatureTransformationFit fit = </span>
            new EpipolarFeatureTransformationFit(
<span class="nc" id="L1249">            distanceErrors.getFundamentalMatrix(),</span>
            outputInliers, fcs,
<span class="nc" id="L1251">            distanceErrors.getErrorType(), outputDistances, </span>
<span class="nc" id="L1252">            distanceErrors.getTolerance());</span>
            
<span class="nc" id="L1254">        return fit;</span>
    }

    public static class NormalizedXY {

        /**
         * 3 dimensional matrix, with column 0 being x, column 1 being y,
         * and the last column is place holder 1's
         */
        private DenseMatrix xy = null;

        private double[] centroidXY = null;

        private DenseMatrix normalizationMatrix = null;

        /**
         * @return the centroidXY
         */
        public double[] getCentroidXY() {
            return centroidXY;
        }

        /**
         * @param centroidXY the centroidXY to set
         */
        public void setCentroidXY(double[] centroidXY) {
            this.centroidXY = centroidXY;
        }

        /**
         * @return the factor
         */
        public DenseMatrix getNormalizationMatrix() {
            return normalizationMatrix;
        }

        /**
         * @param normMatrix holding the scale and offsets to apply to x, y
         */
        public void setNormMatrix(DenseMatrix normMatrix) {
            this.normalizationMatrix = normMatrix;
        }

        /**
         * @return the xy
         */
        public DenseMatrix getXy() {
            return xy;
        }

        /**
         * @param xy the xy to set
         */
        public void setXy(DenseMatrix xy) {
            this.xy = xy;
        }
    }

    public PairIntArray getEpipolarLine(DenseMatrix epipolarLines, int imgWidth,
        int imgHeight, int pointNumber) {

<span class="nc" id="L1315">        int n = imgWidth/10;</span>

<span class="nc" id="L1317">        PairIntArray line = new PairIntArray(n);</span>

<span class="nc" id="L1319">        double a = epipolarLines.get(0, pointNumber);</span>
<span class="nc" id="L1320">        double b = epipolarLines.get(1, pointNumber);</span>
<span class="nc" id="L1321">        double c = epipolarLines.get(2, pointNumber);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">        boolean isHoriz = (Math.abs(a/b) &lt;= 1.0);</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        if (isHoriz) {</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            for (int x = 0; x &lt; imgWidth; x++) {</span>
                //y = - (a/b) * x - (c/b)
<span class="nc" id="L1326">                double y = (c + (a * (double)x)) / (-b);</span>
<span class="nc" id="L1327">                line.add(x, (int) Math.round(y));</span>
            }
        } else {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">            for (int y = 0; y &lt; imgHeight; y++) {</span>
                //y = - (a/b) * x - (c/b)
                //y+(c/b) = - (a/b) * x
                // ==&gt; x = (-b/a) * (y+(c/b)) = y*(-b/a) - (c/a)
<span class="nc" id="L1334">                double x = -(c + (b * (double)y))/a;</span>
<span class="nc" id="L1335">                line.add((int) Math.round(x), y);</span>
            }
        }

<span class="nc" id="L1339">        return line;</span>
    }

    /**
     * evaluate fit for already matched point lists
     * @param fm
     * @param leftPoints
     * @param rightPoints
     * @param tolerance
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError(
        DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints, 
        double tolerance) {
        
<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1355">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L1358">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L1361">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L1363">        int nRows = leftPoints.numRows();</span>
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L1365">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)

<span class="fc" id="L1370">        PairFloatArray distances = calculateDistancesFromEpipolar(fm,</span>
            leftPoints, rightPoints);

<span class="fc" id="L1373">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L1375">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L1377" title="All 2 branches covered.">        for (int i = 0; i &lt; distances.getN(); ++i) {</span>

<span class="fc" id="L1379">            float leftPtD = distances.getX(i);</span>

<span class="fc" id="L1381">            float rightPtD = distances.getY(i);</span>

<span class="fc" id="L1383">            float dist = (float)Math.sqrt(leftPtD*leftPtD + rightPtD*rightPtD);</span>

<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">            if (dist &gt; tolerance) {</span>
<span class="fc" id="L1386">                continue;</span>
            }

<span class="nc" id="L1389">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L1391">            errors.add(Double.valueOf(dist));</span>
        }
        
<span class="fc" id="L1394">        EpipolarTransformationFit fit = null;</span>
         
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L1397">            fit = new EpipolarTransformationFit(fm, inlierIndexes, </span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, errors, tolerance);
        } else {
<span class="fc" id="L1400">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(), </span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), tolerance);
        }

<span class="fc" id="L1404">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="fc" id="L1406">        return fit;</span>
    }

    /**
     * evaluate fit for already matched point lists
     * @param fm
     * @param leftPoints
     * @param rightPoints
     * @param tolerance
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceErrorThenFilter(
        DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints, 
        double tolerance) {
        
<span class="nc bnc" id="L1421" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1422">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1424" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L1425">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1427" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L1428">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L1430">        int nRows = leftPoints.numRows();</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L1432">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)

<span class="nc" id="L1437">        PairFloatArray distances = calculateDistancesFromEpipolar(fm,</span>
            leftPoints, rightPoints);

<span class="nc" id="L1440">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L1442">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L1444" title="All 2 branches missed.">        for (int i = 0; i &lt; distances.getN(); ++i) {</span>

<span class="nc" id="L1446">            float leftPtD = distances.getX(i);</span>

<span class="nc" id="L1448">            float rightPtD = distances.getY(i);</span>

<span class="nc" id="L1450">            float dist = (float)Math.sqrt(leftPtD*leftPtD + rightPtD*rightPtD);</span>

<span class="nc bnc" id="L1452" title="All 2 branches missed.">            if (dist &gt; tolerance) {</span>
<span class="nc" id="L1453">                continue;</span>
            }

<span class="nc" id="L1456">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L1458">            errors.add(Double.valueOf(dist));</span>
        }
        
<span class="nc" id="L1461">        filterForDegenerate(leftPoints, inlierIndexes, errors);</span>
<span class="nc" id="L1462">        filterForDegenerate(rightPoints, inlierIndexes, errors);</span>

<span class="nc" id="L1464">        EpipolarTransformationFit fit = null;</span>
         
<span class="nc bnc" id="L1466" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L1467">            fit = new EpipolarTransformationFit(fm, inlierIndexes, </span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, errors, tolerance);
        } else {
<span class="nc" id="L1470">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(), </span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), tolerance);
        }

<span class="nc" id="L1474">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="nc" id="L1476">        return fit;</span>
    }
    
    /**
     * find the distance of the given points from their respective projective
     * epipolar lines.
     * @param fm
     * @param rightEpipolarLines
     * @param leftEpipolarLines
     * @param leftPoints
     * @param rightPoints
     * @param tolerance
     * @return
     */
    public PairFloatArray calculateDistancesFromEpipolar(
        DenseMatrix fm, DenseMatrix matchedLeftPoints,
        DenseMatrix matchedRightPoints) {

<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1495">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">        if (matchedLeftPoints == null) {</span>
<span class="nc" id="L1498">            throw new IllegalArgumentException(&quot;matchedLeftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">        if (matchedRightPoints == null) {</span>
<span class="nc" id="L1501">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L1503">        int nRows = matchedLeftPoints.numRows();</span>
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">        if (nRows != matchedRightPoints.numRows()) {</span>
<span class="nc" id="L1505">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }
        
        /*
        u_2^T * F * u_1 = 0  where u are the x,y points in images _1 and _2
        u_1 = (x_1, y_1, 1)^T
        u_2 = (x_2, y_2, 1)^T
        */

<span class="fc" id="L1514">        int n = matchedLeftPoints.numColumns();</span>

<span class="fc" id="L1516">        PairFloatArray distances = new PairFloatArray(n);</span>

<span class="fc" id="L1518">        DenseMatrix rightEpipolarLines = MatrixUtil.multiply(fm, matchedLeftPoints);</span>

<span class="fc" id="L1520">        DenseMatrix leftEpipolarLines = MatrixUtil.multiply(fm.transpose(),</span>
            matchedRightPoints);

<span class="fc" id="L1523">        float[] output = new float[2];</span>
        
<span class="fc bfc" id="L1525" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedLeftPoints.numColumns(); i++) {</span>

<span class="fc" id="L1527">            calculatePerpDistFromLines(matchedLeftPoints, </span>
                matchedRightPoints, rightEpipolarLines, leftEpipolarLines,
                i, i, output);
            
<span class="fc" id="L1531">            distances.add(output[0], output[1]);</span>
        }

<span class="fc" id="L1534">        return distances;</span>
    }
    
    public void calculatePerpDistFromLines(DenseMatrix leftPoints, 
        DenseMatrix rightPoints, DenseMatrix epipolarLinesFromLeft,
        DenseMatrix epipolarLinesFromRight, int leftIdx, int rightIdx,
        float[] output) {
        
<span class="fc" id="L1542">        double a = epipolarLinesFromLeft.get(0, leftIdx);</span>
<span class="fc" id="L1543">        double b = epipolarLinesFromLeft.get(1, leftIdx);</span>
<span class="fc" id="L1544">        double c = epipolarLinesFromLeft.get(2, leftIdx);</span>

<span class="fc" id="L1546">        double aplusb = Math.sqrt((a*a) + (b*b));</span>

<span class="fc" id="L1548">        double xL = leftPoints.get(0, leftIdx);</span>
<span class="fc" id="L1549">        double yL = leftPoints.get(1, leftIdx);</span>

        //dist = (a*x + b*y + c)/sqrt(a^2 + b^2)

<span class="fc" id="L1553">        double x = rightPoints.get(0, rightIdx);</span>
<span class="fc" id="L1554">        double y = rightPoints.get(1, rightIdx);</span>

<span class="fc" id="L1556">        double d = (a*x + b*y + c)/aplusb;</span>

        // find the reverse distance by projection:
<span class="fc" id="L1559">        double aRev = epipolarLinesFromRight.get(0, rightIdx);</span>
<span class="fc" id="L1560">        double bRev = epipolarLinesFromRight.get(1, rightIdx);</span>
<span class="fc" id="L1561">        double cRev = epipolarLinesFromRight.get(2, rightIdx);</span>

<span class="fc" id="L1563">        double dRev = (aRev*xL + bRev*yL + cRev)/</span>
<span class="fc" id="L1564">            Math.sqrt((aRev*aRev + bRev*bRev));</span>

<span class="fc" id="L1566">        output[0] = (float)dRev;</span>
<span class="fc" id="L1567">        output[1] = (float)d;</span>
<span class="fc" id="L1568">    }</span>
    
    public EpipolarTransformationFit calculateErrorThenFilter(DenseMatrix fm,
        DenseMatrix x1, DenseMatrix x2, ErrorType errorType, double tolerance) {
         
<span class="nc bnc" id="L1573" title="All 2 branches missed.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="nc" id="L1574">            return calculateSampsonsErrorThenFilter(fm, x1, x2, tolerance);</span>
        } else {
<span class="nc" id="L1576">            return calculateEpipolarDistanceErrorThenFilter(fm, x1, x2, tolerance);</span>
        }
    }
    
    public EpipolarTransformationFit calculateError(DenseMatrix fm,
        DenseMatrix x1, DenseMatrix x2, ErrorType errorType, double tolerance) {
         
<span class="fc bfc" id="L1583" title="All 2 branches covered.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="nc" id="L1584">            return calculateSampsonsError(fm, x1, x2, tolerance);</span>
        } else {
<span class="fc" id="L1586">            return calculateEpipolarDistanceError(fm, x1, x2, tolerance);</span>
        }
    }
    
    public EpipolarTransformationFit calculateSampsonsError(DenseMatrix fm,
        DenseMatrix x1, DenseMatrix x2, double tolerance) {
        
<span class="pc bpc" id="L1593" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1594">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1596" title="1 of 2 branches missed.">        if (x1 == null) {</span>
<span class="nc" id="L1597">            throw new IllegalArgumentException(&quot;x1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1599" title="1 of 2 branches missed.">        if (x2 == null) {</span>
<span class="nc" id="L1600">            throw new IllegalArgumentException(&quot;x2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1602" title="2 of 4 branches missed.">        if (fm.numRows() != 3 || fm.numColumns() != 3) {</span>
<span class="nc" id="L1603">            throw new IllegalArgumentException(&quot;fm should have 3 rows and 3 columns&quot;);</span>
        }
<span class="pc bpc" id="L1605" title="2 of 4 branches missed.">        if (x1.numRows() != x2.numRows() || x1.numColumns() != x2.numColumns()) {</span>
<span class="nc" id="L1606">            throw new IllegalArgumentException(&quot;x1 and x2 must be same sizes&quot;);</span>
        }
        
        /*
        geometric error of the final solution or the 7-point sample trial,
        can be approximated by Sampson's error:
             (x2_i * F * x1_i^T)^2                 (x2_i * F * x1_i^T)^2
           ---------------------------------  +  ---------------------------
             (F*x1_i^T)_x^2 + (F*x1_i^T)_y^2     (x2_i*F)_x^2 + (x2_i*F)_y^2
        
        reference?
        */
        
<span class="fc" id="L1619">        List&lt;Integer&gt; outputInliers = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L1620">        List&lt;Double&gt; outputDistances = new ArrayList&lt;Double&gt;();</span>
                
<span class="fc" id="L1622">        DenseMatrix fmT = (DenseMatrix) fm.transpose();</span>
                
<span class="fc" id="L1624">        int n = x1.numColumns();</span>
        
        // 1 x n
<span class="fc" id="L1627">        DenseMatrix x2tFx1 = new DenseMatrix(1, n);</span>
        
<span class="fc" id="L1629">        boolean extractRow = false;</span>
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">        for (int col = 0; col &lt; n; ++col) {</span>
            // 3 x 1 ==&gt; T ==&gt; 1 x 3
<span class="nc" id="L1632">            DenseMatrix x2T_i = (DenseMatrix) MatrixUtil.extractAColumn(x2, col).transpose();</span>
            
            // x2T_i * F is 1X3 * 3X3 = 1X3
<span class="nc" id="L1635">            DenseMatrix x2T_iF = MatrixUtil.multiply(x2T_i, fm);</span>
            
            // 3 x 1
<span class="nc" id="L1638">            DenseMatrix x1_i = MatrixUtil.extractAColumn(x1, col);</span>
            
            // x2T_iF * x1_i is 1X3 * 3X1 = 1X1
<span class="nc" id="L1641">            DenseMatrix result = MatrixUtil.multiply(x2T_iF, x1_i);</span>
            
<span class="nc" id="L1643">            x2tFx1.set(0, col, result.get(0, 0));        </span>
        }
        
        //Fx1 = F * x1  is 3X3 * 3Xn = 3Xn
<span class="nc" id="L1647">        DenseMatrix fx1 = MatrixUtil.multiply(fm, x1);</span>
        
        //Ftx2 = F' * x2  is 3x3 * 3xn = 3xn
<span class="nc" id="L1650">        DenseMatrix ftx2 = MatrixUtil.multiply(fmT, x2);</span>
        
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        for (int col = 0; col &lt; n; ++col) {</span>
<span class="nc" id="L1653">            double x2tFx1_j = x2tFx1.get(0, col);</span>
<span class="nc" id="L1654">            double a = x2tFx1_j * x2tFx1_j;</span>
            
<span class="nc" id="L1656">            double t1 = fx1.get(0, col);</span>
<span class="nc" id="L1657">            t1 *= t1;</span>
            
<span class="nc" id="L1659">            double t2 = fx1.get(1, col);</span>
<span class="nc" id="L1660">            t2 *= t2;</span>
            
<span class="nc" id="L1662">            double t3 = ftx2.get(0, col);</span>
<span class="nc" id="L1663">            t3 *= t3;</span>
            
<span class="nc" id="L1665">            double t4 = ftx2.get(1, col);</span>
<span class="nc" id="L1666">            t4 *= t4;</span>
            
<span class="nc" id="L1668">            double b = t1 + t2 + t3 + t4;</span>
            
<span class="nc" id="L1670">            double error = a/b;</span>
                        
<span class="nc bnc" id="L1672" title="All 2 branches missed.">            if (error &lt; tolerance) {</span>
<span class="nc" id="L1673">                outputInliers.add(Integer.valueOf(col));</span>
<span class="nc" id="L1674">                outputDistances.add(Double.valueOf(error));</span>
            }
        }
        
<span class="nc" id="L1678">        EpipolarTransformationFit fit = new EpipolarTransformationFit(fm,</span>
            outputInliers, ErrorType.SAMPSONS, outputDistances, tolerance);
    
<span class="nc" id="L1681">        fit.setNMaxMatchable(x1.numColumns());</span>
        
<span class="nc" id="L1683">        return fit;</span>
    }
    
    //follow errors w/ filter for degeneracy
    public EpipolarTransformationFit calculateSampsonsErrorThenFilter(DenseMatrix fm,
        DenseMatrix x1, DenseMatrix x2, double tolerance) {
        
<span class="nc bnc" id="L1690" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L1691">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1693" title="All 2 branches missed.">        if (x1 == null) {</span>
<span class="nc" id="L1694">            throw new IllegalArgumentException(&quot;x1 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1696" title="All 2 branches missed.">        if (x2 == null) {</span>
<span class="nc" id="L1697">            throw new IllegalArgumentException(&quot;x2 cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1699" title="All 4 branches missed.">        if (fm.numRows() != 3 || fm.numColumns() != 3) {</span>
<span class="nc" id="L1700">            throw new IllegalArgumentException(&quot;fm should have 3 rows and 3 columns&quot;);</span>
        }
<span class="nc bnc" id="L1702" title="All 4 branches missed.">        if (x1.numRows() != x2.numRows() || x1.numColumns() != x2.numColumns()) {</span>
<span class="nc" id="L1703">            throw new IllegalArgumentException(&quot;x1 and x2 must be same sizes&quot;);</span>
        }
        
        /*
        geometric error of the final solution or the 7-point sample trial,
        can be approximated by Sampson's error:
             (x2_i * F * x1_i^T)^2                 (x2_i * F * x1_i^T)^2
           ---------------------------------  +  ---------------------------
             (F*x1_i^T)_x^2 + (F*x1_i^T)_y^2     (x2_i*F)_x^2 + (x2_i*F)_y^2
        
        reference?
        */
        
<span class="nc" id="L1716">        List&lt;Integer&gt; outputInliers = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L1717">        List&lt;Double&gt; outputDistances = new ArrayList&lt;Double&gt;();</span>
                
<span class="nc" id="L1719">        DenseMatrix fmT = (DenseMatrix) fm.transpose();</span>
                
<span class="nc" id="L1721">        int n = x1.numColumns();</span>
        
        // 1 x n
<span class="nc" id="L1724">        DenseMatrix x2tFx1 = new DenseMatrix(1, n);</span>
        
<span class="nc" id="L1726">        boolean extractRow = false;</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">        for (int col = 0; col &lt; n; ++col) {</span>
            // 3 x 1 ==&gt; T ==&gt; 1 x 3
<span class="nc" id="L1729">            DenseMatrix x2T_i = (DenseMatrix) MatrixUtil.extractAColumn(x2, col)</span>
<span class="nc" id="L1730">                .transpose();</span>
            
            // x2T_i * F is 1X3 * 3X3 = 1X3
<span class="nc" id="L1733">            DenseMatrix x2T_iF = MatrixUtil.multiply(x2T_i, fm);</span>
            
            // 3 x 1
<span class="nc" id="L1736">            DenseMatrix x1_i = MatrixUtil.extractAColumn(x1, col);</span>
            
            // x2T_iF * x1_i is 1X3 * 3X1 = 1X1
<span class="nc" id="L1739">            DenseMatrix result = MatrixUtil.multiply(x2T_iF, x1_i);</span>
            
<span class="nc" id="L1741">            x2tFx1.set(0, col, result.get(0, 0));            </span>
        }
        
        //Fx1 = F * x1  is 3X3 * 3Xn = 3Xn
<span class="nc" id="L1745">        DenseMatrix fx1 = MatrixUtil.multiply(fm, x1);</span>
        
        //Ftx2 = F' * x2  is 3x3 * 3xn = 3xn
<span class="nc" id="L1748">        DenseMatrix ftx2 = MatrixUtil.multiply(fmT, x2);</span>
        
<span class="nc bnc" id="L1750" title="All 2 branches missed.">        for (int col = 0; col &lt; n; ++col) {</span>
<span class="nc" id="L1751">            double x2tFx1_j = x2tFx1.get(0, col);</span>
<span class="nc" id="L1752">            double a = x2tFx1_j * x2tFx1_j;</span>
            
<span class="nc" id="L1754">            double t1 = fx1.get(0, col);</span>
<span class="nc" id="L1755">            t1 *= t1;</span>
            
<span class="nc" id="L1757">            double t2 = fx1.get(1, col);</span>
<span class="nc" id="L1758">            t2 *= t2;</span>
            
<span class="nc" id="L1760">            double t3 = ftx2.get(0, col);</span>
<span class="nc" id="L1761">            t3 *= t3;</span>
            
<span class="nc" id="L1763">            double t4 = ftx2.get(1, col);</span>
<span class="nc" id="L1764">            t4 *= t4;</span>
            
<span class="nc" id="L1766">            double b = t1 + t2 + t3 + t4;</span>
            
<span class="nc" id="L1768">            double error = a/b;</span>
                        
<span class="nc bnc" id="L1770" title="All 2 branches missed.">            if (error &lt; tolerance) {</span>
<span class="nc" id="L1771">                outputInliers.add(Integer.valueOf(col));</span>
<span class="nc" id="L1772">                outputDistances.add(Double.valueOf(error));</span>
            }
        }
        
<span class="nc" id="L1776">        filterForDegenerate(x1, outputInliers, outputDistances);</span>
<span class="nc" id="L1777">        filterForDegenerate(x2, outputInliers, outputDistances);</span>
        
<span class="nc" id="L1779">        EpipolarTransformationFit fit = new EpipolarTransformationFit(fm,</span>
            outputInliers, ErrorType.SAMPSONS, outputDistances, tolerance);
    
<span class="nc" id="L1782">        fit.setNMaxMatchable(x1.numColumns());</span>
        
<span class="nc" id="L1784">        return fit;</span>
    }
    
    private void filterForDegenerate(DenseMatrix xy1,
        List&lt;Integer&gt; outputInliers, List&lt;Double&gt; outputDistances) {
        
<span class="nc" id="L1790">        Map&lt;PairInt, List&lt;Integer&gt;&gt; pointIndexes = new HashMap&lt;PairInt, List&lt;Integer&gt;&gt;();</span>
        
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        for (int i = 0; i &lt; outputInliers.size(); ++i) {</span>
            
<span class="nc" id="L1794">            int idx = outputInliers.get(i);</span>
            
<span class="nc" id="L1796">            int x1 = (int)Math.round(xy1.get(0, idx));</span>
<span class="nc" id="L1797">            int y1 = (int)Math.round(xy1.get(1, idx));</span>
            
<span class="nc" id="L1799">            PairInt p1 = new PairInt(x1, y1);</span>
            
<span class="nc" id="L1801">            List&lt;Integer&gt; oIndexes = pointIndexes.get(p1);</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">            if (oIndexes == null) {</span>
<span class="nc" id="L1803">                oIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L1804">                pointIndexes.put(p1, oIndexes);</span>
            }
<span class="nc" id="L1806">            oIndexes.add(Integer.valueOf(i));            </span>
        }
        
<span class="nc" id="L1809">        List&lt;Integer&gt; remove = new ArrayList&lt;Integer&gt;();</span>
        
<span class="nc bnc" id="L1811" title="All 2 branches missed.">        for (Entry&lt;PairInt, List&lt;Integer&gt;&gt; entry : pointIndexes.entrySet()) {</span>
                        
<span class="nc" id="L1813">            List&lt;Integer&gt; oIndexes = entry.getValue();</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">            if (oIndexes.size() &lt; 2) {</span>
<span class="nc" id="L1815">                continue;</span>
            }
            
<span class="nc" id="L1818">            double minError = Double.MAX_VALUE;</span>
<span class="nc" id="L1819">            int minIdx = -1;</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">            for (Integer index : oIndexes) {</span>
<span class="nc" id="L1821">                int idx = index.intValue();</span>
<span class="nc" id="L1822">                double error = outputDistances.get(idx);</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                if (error &lt; minError) {</span>
<span class="nc" id="L1824">                    minError = error;</span>
<span class="nc" id="L1825">                    minIdx = idx;</span>
                }
<span class="nc" id="L1827">            }</span>
            
<span class="nc bnc" id="L1829" title="All 4 branches missed.">            assert(minIdx &gt; -1);</span>
            
<span class="nc bnc" id="L1831" title="All 2 branches missed.">            for (Integer index : oIndexes) {</span>
<span class="nc" id="L1832">                int idx = index.intValue();</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">                if (idx == minIdx) {</span>
<span class="nc" id="L1834">                    continue;</span>
                }
<span class="nc" id="L1836">                remove.add(Integer.valueOf(idx));</span>
<span class="nc" id="L1837">            }            </span>
<span class="nc" id="L1838">        }</span>
<span class="nc" id="L1839">        Collections.sort(remove);</span>
        
<span class="nc bnc" id="L1841" title="All 2 branches missed.">        for (int i = (remove.size() - 1); i &gt; -1; --i) {</span>
<span class="nc" id="L1842">            int idx = remove.get(i);</span>
<span class="nc" id="L1843">            outputDistances.remove(idx);</span>
<span class="nc" id="L1844">            outputInliers.remove(idx);</span>
        }        
<span class="nc" id="L1846">    }</span>

    /**
    calculate the 4 possible projection matrices from the essential matrix.
    * Note that the essential matrix is the transformation matrix between points
    */
    /*
    public DenseMatrix[] calculatePFromEssential(DenseMatrix essentialMatrix) {
    }
    */

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
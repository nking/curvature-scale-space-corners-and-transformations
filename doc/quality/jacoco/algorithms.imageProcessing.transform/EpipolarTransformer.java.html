<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EpipolarTransformer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">EpipolarTransformer.java</span></div><h1>EpipolarTransformer.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.misc.PolynomialRootSolver;
import algorithms.matrix.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.NotConvergedException;
import no.uib.cipr.matrix.SVD;
import algorithms.matrix.MatrixUtil.SVDProducts;
import algorithms.util.FormatArray;

/**
 * class to solve for the epipolar and/or essential matrices and their epipoles for two images with stereo projection
 * and apply the solution.
 *
 * the essential matrix contains information about the relative rotation between the 2 cameras and the direction of
 * translation between the two cameras.
 *
 * The fundamental matrix contains information about the relative rotation between the 2 cameras, the direction of
 * translation between the two cameras, and the intrinisc camera matrix.
 *
 * To recover scale one needs to use absolute orientation methods.
 *
 * &lt;pre&gt;
 *  The essential matrix is defined by the planes formed by the 3 vectors of optical centers of 2 cameras and the
 *  individual points X in 3D-space called world coordinate system (WCS).
 *  Each point X in 3-D space lies on a plane it forms with the optical centers.
 *  For each of those planes, the point X projected into image 1 is x1 and the point X projected into image 2 is x2.
 *  x1 and x2 can be described by the plane, and also by the rotation and translation between the cameras.
 *  let lambda1 and lambda2 be scale parameters.
 *  lambda1 * x2 = lambda2 * R * x1 + T.
 *
 *  The translation vector is along the baseline between the 2 cameras.
 *  If we pre-multiply both sides by the skew symmetric matrix of T to give us the cross products:
 *     lambda1 * [T]_x * x2 = lambda2 * [T]_x * R * x1 + [T]_x * T
           T cross product with itself is 0.
 *     lambda1 * [T]_x * x2 = lambda2 * [T]_x * R * x1 + [T]_x * T
 *                          = lambda2 * [T]_x * R * x1 + 0
 *         vector T is from epipolar point e1 to epipolar point e2.
 *         vector x2 is from epipolar point e2 to x2.
 *         [T]_x * x2 is perpendicular to x2
 *         so then x2^T * [T]_x * x2 is 0.
 *         we can use that to simplify the equation further when we pre-multiply both sides by x2^T
 *     lambda1 * x2^T * [T]_x * x2 = lambda2 * x2^T * [T]_x * R * x1
 *                0 = lambda2 * x2^T * [T]_x * R * x1
 *
 *     The essential matrix E is defined as [T]_x * R
 *         E = [T]_x * R
 *         x2^T * E * x1 = 0
 *
 *     Epipolar plane is intersection of o1, o2, X where o1 = optical center for camera 1, o2 = same for camera 2.
 *
 *     e1 and e2 are the projections of o1 and o2 into their images (and may exist outside of image bounds).
 *
 *     each point x1, x2 has an epipolar line l1, l2, in its image that is the intersection of x1 with e1, and x2 with e2.
 *
 *     e2^T * E = 0
 *     E * e1 = 0
 *     l2 = E * x1
 *     l1 = E^T * x2
 *     li^T * ei = 0
 *     li^T * xi = 0
 *
 * The fundamental matrix is the projective solution for transformation
 * between 2 images of the same objects in pixel coordinates.
 *
 *     E = K2^T * F * K1
 *     F = K^-T * E * K^-1
 *                  where K is the intrinsic camera matrix.
 *       = K^-T * [T]_x * R * K^-1  if det(K) ~ 1 else apply a scale factor too.
 *
 * Present below is the solution for having 7 matched points between images
 * and the solution for having 8 or more matched points between the images.
 * Both use numerical conditioning and recipes suggested by Hartley
 * (see reference below).
 * 
 * For the 8-point algorithm:
 * IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, VOL. 19,
 * NO. 6, JUNE 1997
 * &quot;In Defense of the Eight-Point Algorithm&quot; by Richard Hartley

 * The 8-point algorithm matrix represents epipolar geometry, and can be
 * used with data from cameras whose characteristics are not known to solve
 * up to the projective transformation.
 * ...a simple transformation (translation and scaling) of the points in 
 * the image before formulating the linear equations leads to an enormous 
 * improvement in the condition of the problem and hence of the stability 
 * of the result...
 *
 * Some definitions:
    vectors are treated as columns unless noted otherwise.
    vector as a row uses notation u^T.
    u^T*v represents the inner product (= dot product).  result is a scalar.
    u*v^T represents the outer product. result is a matrix.
    u_1 is the (x,y) points from image 1 and u_2 are the matched (x,y) points
        from image 2.

     Epipolar Plane:
        An epipolar plane is defined by the principal points o1, and o2 of the cameras and the point p.
     Epipoles:
         The projection of one camera center onto the other camera's image plane is an epipole.
         (the epipole can lie outside the image boundaries)
         in the Essential Matrix: e2 ~ T and e1 ~ R*T up to a scalar factor.
         e1 = right nullspace of FM = SVD(fm).V[*,2].
         e2 = left nullspace of FM = SVD(fm).U[*,2].
         e2^T*E = 0
         E*e1 = 0
     Epipolar line of p:
         intersection of the epipolar place of p with an image place is the epipolar line of p.
         l2 ~ E*x1
         l1 ~ E^T*x2

         l*e=0 for (l1,e1) and also (l2,e2)
         l^T*x=0 for (l1,x1) and also (l2,x2)

    the fundamental matrix is defined:
        u_2^T * F * u_1 = 0  
        where u are the x,y points in images _1 and _2
        and F is a 3 × 3 matrix of rank 2
        
    An explanation of the derivation of the fundamental matrix can be found in
    Zhengyou Zhang. &quot;Determining the Epipolar Geometry and its Uncertainty: A
    Review&quot;. RR-2927, INRIA. 1996. ffinria-00073771
    equations (1) and (2) 
    
    u_1 = (x_1, y_1, 1)^T
    u_2 = (x_2, y_2, 1)^T
     
    u_1   = x_1_i    x_1_i+1  ...    
            y_1_i    y_1_i+1  ...
            1        1        ...
 
    u_2^T = x_2_i    y_2_i    1
            x_2_i+1  y_2_i+1  1
            ...      ...      ...

    x_1*x_2*F_1_1 + x_1*y_2*F_2_1 + x_1*F_3_1 + y_1*x_2*F_1_2 + y_1*y_2*F_2_2
        + y_1*F_3_2 + x_2*F_1_3 + y_2*F_2_3 + F_3_3 = 0

    A * f = 0

    where A = x_1*x_2, x_1*y_2, x_1, y_1*x_2, y_1*y_2, y_1, x_2, y_2, 1
             (which is each element of column 0 of u_1 dotted separately with
             row 0 of u2_T)
             A is nData X 9
    and f is a nine-vector (size 9X1) containing the entries of the matrix F
 
    To avoid the trivial scale, ||f|| = 1 where f is the norm of f

    the rank of A is 8, but noise and other errors make it 9.
    if A is longer than 8, the system is over-determined (over specified) and
    so must be solved using least squares.  the set may be over determined
    and not have a zero solution.

    we want the vector f that minimizes ||A*f|| subject to the constraint
    that ||f|| = f^T*f = 1

    the solution is the unit eigenvector corresponding to the smallest
    eigenvalue of A^T*A.

    Since A^T*A is positive semi-definite and symmetric, all of its eigenvectors
    are real and positive or zero.
    This eigenvector is what he calls the least eigenvector of A^T*A and
    it is found via the Jacobi algorithm or Singular Value Decomposition.
    NOTE:
        SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
        SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U

    The solved for matrix will in general not have rank 2 and needs to, so
    further corrections are necessary:
        matrix F is replaced by F' that minimizes the Frobenius norm
        ||F - F'|| subject to the condition det F' = 0.
        A convenient method of doing this is to use the Singular Value
        Decomposition (SVD).
           let F = U*D*V^T be the SVD of F, where D is diagonal matrix
           D = diag(r, s, t) satisfying r &gt;= s &gt;= t.
           let F' = U*diag(r, s, 0)*V^T.

 (1) Transforming the coordinates:

     Normalization for isotropic scaling.
     1) The points are translated so that their centroid is at
        the origin.
     2) The points are then scaled so that the average distance
        from the origin is equal to 2 .
     3) This transformation is applied to each of the two images independently.

     NOTE: if needed to use non-isotropic scaling (e.g. rectangular pixels, etc):
     transform the points so that
     1) Their centroid is at the origin.
     2) The principal moments are both equal to unity
      
     
     scaling the coordinate so that the homogeneous coordinates are on the 
     average equal to unity will improve the condition of the matrix A^T*A.
     I talso allows use of error calculations such as Sampson's.

 (2) build matrix A with the normalized x,y points

 (3) compute linear least square solution to the least eigenvector of f:
     solve A = U * D * V^T   for A*f = [..x...]*f = 0
     A has rank 8.  F has rank 2.
     calculate [U,D,V] from svd(A)

 (4) make the fundamental matrix have a rank of 2
     by performing a svd and then reconstructing with the two largest
     singular values (similar to dimensionality reduction)
         [U,D,V] = svd(F,0);
         F = U * diag([D(1,1) D(2,2) 0]) * V^T;

 (5) denormalize the fundamental matrix
     The related part of the normalization equation: inv(T_2) * F * inv(T_1)
     so denormalizing is:

         F = (T_2)^T * F * T_1

 (6) estimate the error in the fundamental matrix by calculating epipolar
     lines for points in image 1 and find their nearest points in image 2
     and measure the perpendicular distance from the epipolar line for
     those nearest points.
     NOTE: This is best done using normalized coordinates and fundamental matrix,
     after step (4) and before step (5).

For the 7-point algorithm:
references are:
  the the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img
from a version of http://www.robots.ox.ac.uk/~vgg/hzbook/code/ which is part
of the supplementary material for their book &quot;Multiple View Geometry in Computer Vision
Second Edition&quot;
   and Hartley, R. I. (1994a). Projective reconstruction and invariants from 
multiple images. PAMI, 16(10):1036–1041
   and Torr, P. H. S. and Murray, D. (1997). 
&quot;The development and comparison of robust meth- ods for estimating the 
fundamental matrix. International Journal of Computer Vision&quot;, 24(3):271–300.

 The 7-point algorithm solves for the null space of the fundamental
 matrix and results in one or 3 solutions which can for some geometries
 be reduced to a single solution.
 The nullspace is where Ax=0 in reduced echelon, that is, the free variable rows.
 The normalization and denormalization steps before and following the solution,
 are the same as in the 8-point solution.

 this from comments in the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img:
   Solutions for the 7-points are pruned by requirement that
   scalars s in all equations s * cross(e1,u_1) == F*u_2 are positive.
   In case of multiple solutions, F has one dimension
   more such that F(:,:,n) is the n-th solution.

  note:
    because translation is not a linear transformation (see Strang Chap 7)
       one has to keep it as a separate transformation matrix when
       performing operations on a sequence of matrices such as inverse
       and transpose operations.

    translation matrix: inverse changes the signs of the translation elements,
        but not the diagonal

    rotation matrix: inverse is the transpose of rotation matrix.
     
    scaling matrix: inverse is performed on each element, that is, the reciprocal.

    (A*B*C)^-1 = (C^-1) * (B^-1) * (A^-1)

    also, when A * A^(-1) = I, one can use:
                    1
        A^(-1) =  ------ C^(T)  where C_ij = cofactor of a_ij
                   det A

  NOTE: the normalization suggested by Hartley is explored further in
  Chojnacki et al. 2003,  &quot;Revisiting Hartley’s Normalized Eight-Point Algorithm&quot;
  
  Some excerpts:
   
     xc is the centroid of x coordinates.
     yc is the centroid of y coordinates.
     s is the root mean square distance of (x-xc,y-yc) to origin divided by sqrt(2)
    
     u1_normalized = T1 * u1 
     u2_normalized = T2 * u2 

     denormalized F = T2^T * F_normalized * T1

     denormalized u1 = T1^-1 * u1_normalized and similar foru2

     FM_normalized = inverse(transpose(T2)) * FM * inverse(T1)

     denormalized FM = transpose(T2) * FM_normalized * T1 

     u2^T * FM * u1 = u2_normalized^T * FM_normalized * u1_normalized = residual
  
              | 1/s   0  0 |   | 1  0  -xc |   | 1/s    0   -xc/s |
          T = |  0  1/s  0 | * | 0  1  -yc | = |   0  1/s   -yc/s |
              |  0    0  1 |   | 0  0   1  |   |   0    0      1  |

                 | 1  0  xc |   | s  0   0 |   | s   0  xc |
          T^-1 = | 0  1  yc | * | 0  s   0 | = | 0   s  yc |
                 | 0  0   1 |   | 0  0   1 |   | 0   0   1 |
   
                        | 1  0  xc |   | s^2  0    0 |   | 1  0  0 |
          T^-1 * T^-T = | 0  1  yc | * | 0   s^2   0 | * | 0  1  0 |
                        | 0  0   1 |   | 0    0    1 |   | xc yc 1 |

                        | s^2 + xc^2   xc*yc       xc |
                      = | yc*xc        s^2 + yc^2  yc |
                        | xc           yc          1  |
        
                                  | s  0   0 |   | 1  0  0 |   |  s   0   0 |
        from that can see  T^-T = | 0  s   0 | * | 0  1  0 | = |  0   s   0 |
                                  | 0  0   1 |   | xc yc 1 |   | xc  yc   1 |
        
              |  1    0    0 |   | 1/s   0  0 |   |   1/s    0    0 |
        T^T = |  0    1    0 | * |  0  1/s  0 | = |     0   1/s   0 |
              |-xc  -yc    1 |   |  0    0  1 |   | -xc/s  -yc/s  1 |
        
                   ( | 1/s   0  0 | )^-1     |  1    0    0 |   |  s  0   0 |
        (T^T)^-1 = ( |  0  1/s  0 | )     *  |  0    1    0 | = |  0  s   0 |
                   ( |  0    0  1 | )        | xc   yc    1 |   | xc  yc  1 |
        
        can see that (T^-1)^T = (T^T)^-1        
 &lt;/pre&gt;
 
 &lt;pre&gt;
    The plunder-dl scoring can be used for comparison between different models.
    for example, comparing results of the 7-point and 8-point 
    solutions or comparing 7-point projection to 6-point affine, etc.

    plunder-dl is from equation 33 of
    Torr, Zisserman, &amp; Maybank 1996, 
    “Robust Detection of Degenerate Configurations whilst Estimating 
    the Fundamental Matrix&quot;
    https://www.robots.ox.ac.uk/~phst/Papers/CVIU97/m.ps.gz
     EQN 33: PL = DOF + (4*n_o + n_i dimension of model)
                   where n_i = number of inliers
                   n_o = number of outliers
                   DOF = 7 for this solver
    n=7               PL = DOF + 4*n_o + n_i* (model_dimension)
         ni=7, no=0   PL = 7   + 0     + 0 * md
         ni=5, no=2   PL = 7   + 8     + 8 * md
         ni=4, no=3   PL = 7   + 12    + 28 * md
    PLUNDER stands for Pick Least UNDEgenerate Randomly, Description Length

    For nPoints=8, model_dimension = 1.
    for nPoints=7 amd only 1 solution in the cubic constraints, model_dimension=2,
    else for nPoints=7, model_dimension = 3.
 &lt;/pre&gt;
 &lt;pre&gt;
 A summary of epipolar geometry is in chapter 5 of 
 Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;.
 
    e2 when normalized by 3rd coord is in coord space of left image and
       it is the location of the right camera center.
    e2 is the last column of svd.u
    e2 is the left nullspace of F
    (e2^T*F = 0  e2^T*E = 0)
      ==&gt; e2~T  where T is translation and ~ is equality up to a scale factor

    e1 is the last row of svd.vt
    e1 is the right nullspace of F
    (F*e1 = 0  E*e1 = 0)
      ==&gt; e1~R^T*T  where R is rotation and T is translation
    l2 = E*x1
    l1 = E^T*x2
    (x1^T*l1=0 and l1^T*e1=0)
    (x2^T*l2=0 and l2^T*e2=0)
 &lt;/pre&gt;
 
 NOTE:
For &quot;7-point&quot; correspondences, consider implementing MLESAC.
     &quot;MLESAC: A new robust estimator with application to estimating image geometry&quot;
     by P. H. S. Torr and A. Zisserman
     1996 http://www.robots.ox.ac.uk/~vgg/publications/papers/torr00.pdf
 
 TODO: implement Nister's 5-point algorithm to determine the essential matrix 
 * for the case where arguments are the camera intrinsic parameters and the correspondence.
 * @author nichole
 */
<span class="fc" id="L384">public class EpipolarTransformer {</span>

<span class="fc" id="L386">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L388">    private static double eps = 1e-12;</span>

    /**
     * calculate the epipolar projection.  no normalizations and de-normalizations are handled internally.
     * if the camera calibration is known, the essential matrix is returned.
     * @param leftXY the left image coordinates of the feature correspondences
     * @param rightXY the right image coordinates of the feature correspondences
     * @param calibrated whether or not the camera calibration is known.  if true, the essential matrix is returned.
     * @return the fundamental matrix (or essential matrix) of the epipolar projection, else null if SVD failed.
     */
    public double[][] calculateEpipolarProjection2(double[][] leftXY, double[][] rightXY,
                                                   boolean calibrated) throws IOException {

<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (leftXY.length != 3) {</span>
<span class="nc" id="L402">            throw new IllegalArgumentException(&quot;leftXY.length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (rightXY.length != 3) {</span>
<span class="nc" id="L405">            throw new IllegalArgumentException(&quot;rightXY.length must be 3&quot;);</span>
        }
<span class="fc" id="L407">        int n = leftXY[0].length;</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (rightXY[0].length != n) {</span>
<span class="nc" id="L409">            throw new IllegalArgumentException(&quot;leftXY and rightXY must have same dimensions&quot;);</span>
        }
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (n &lt; 7) {</span>
<span class="nc" id="L412">            throw new IllegalArgumentException(&quot;not enough points.  currently, this method only calculates the epipolar projection&quot; +</span>
                    &quot;matrix for 7 or more points&quot;);
        }

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (n == 7) {</span>
<span class="nc" id="L417">            return calculateEpipolarProjectionUsing7Points(leftXY, rightXY);</span>
        }

        //leftXY = MatrixUtil.copy(leftXY);
        //rightXY = MatrixUtil.copy(rightXY);

<span class="fc" id="L423">        double[][] a = createDesignMatrix(leftXY, rightXY);</span>

<span class="fc" id="L425">        SVDProducts svd0 = null;</span>
        try {
            // we only need V in first SVD operation, so can let the method use a or a^T*a
<span class="fc" id="L428">            svd0 = MatrixUtil.performSVD(MatrixUtil.createATransposedTimesA(a));</span>
<span class="nc" id="L429">        } catch (NotConvergedException ex) {</span>
            //Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
<span class="nc" id="L431">            return null;</span>
<span class="fc" id="L432">        }</span>
<span class="fc" id="L433">        int ns = 9;</span>
<span class="fc" id="L434">        double[][] vT = svd0.vT;</span>
<span class="pc bnc" id="L435" title="All 2 branches missed.">        assert(vT[0].length == ns);</span>
<span class="fc" id="L436">        double[][] ff = new double[3][3];</span>
        int i;
<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L439">            ff[i][0] = vT[ns - 1][(i * 3) + 0];</span>
<span class="fc" id="L440">            ff[i][1] = vT[ns - 1][(i * 3) + 1];</span>
<span class="fc" id="L441">            ff[i][2] = vT[ns - 1][(i * 3) + 2];</span>
        }

        // enforce rank=2
<span class="fc" id="L445">        SVD svd = null;</span>
        try {
            // we need to use &quot;U&quot; and &quot;V&quot; below
<span class="fc" id="L448">            svd = SVD.factorize(new DenseMatrix(ff));</span>
<span class="nc" id="L449">        } catch (NotConvergedException e) {</span>
<span class="nc" id="L450">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, e);</span>
<span class="nc" id="L451">            return null;</span>
<span class="fc" id="L452">        }</span>
        // keep the largest 2 values in sDiag to make the diagonal rank 2
        //TODO: follow up on Torry and Murray 1997 use of sqrt(lambda1), sqrt(lambda2).
        //      it's probably because they are using the square of the measurement matrix.
<span class="fc" id="L456">        double[] d = new double[3];</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if (calibrated) {</span>
            //from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
            // refers to Ma, Soatto, Kosecka, and Sastry 2003
            // &quot;An Invitation to 3D Vision From Images to Geometric Models&quot;, p. 114
            // if this is solving the Essential matrix instead of the Fundamental
            //    Matrix, the diagonal is
            // d = [lambda, lambda, 0] where lambda = (svd.s[0] + svd.s[1])/2.
            // MASKS Theorem 5.9
<span class="fc" id="L465">            double sig = (svd.getS()[0] + svd.getS()[1])/2.;</span>
<span class="fc" id="L466">            d[0] = sig;</span>
<span class="fc" id="L467">            d[1] = sig;</span>
            //NOTE: to normalize E, one can use sig = 1 here. see p. 122 of MASKS chapt 5.
<span class="fc" id="L469">        } else {</span>
<span class="fc" id="L470">            d[0] = svd.getS()[0];</span>
<span class="fc" id="L471">            d[1] = svd.getS()[1];</span>
        }

        /*
        multiply the terms:
             F = dot(U, dot(diag(D),V^T))
        */
<span class="fc" id="L478">        double[][] u = MatrixUtil.convertToRowMajor(svd.getU());</span>
<span class="fc" id="L479">        vT = MatrixUtil.convertToRowMajor(svd.getVt());</span>

        // 3x3 with rank 2
<span class="fc" id="L482">        double[][] fm = MatrixUtil.multiply(MatrixUtil.multiplyByDiagonal(u, d), vT);</span>

        // TODO: consider dividing by Frobenius norm

<span class="fc" id="L486">        return fm;</span>
    }

    /**
     * calculate the epipolar projection given 7 pairs of points.  all normalizations and de-normalizations are handled internally.
     * if the camera calibration is known, the essential matrix is returned.
     * @param leftXY the left image coordinates of the feature correspondences
     * @param rightXY the right image coordinates of the feature correspondences
     * @return the fundamental matrix (or essential matrix) of the epipolar projection.
     */
    public double[][] calculateEpipolarProjectionUsing7Points(double[][] leftXY, double[][] rightXY)
    throws IOException {

<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (leftXY.length != 3) {</span>
<span class="nc" id="L500">            throw new IllegalArgumentException(&quot;leftXY.length must be 3&quot;);</span>
        }
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (rightXY.length != 3) {</span>
<span class="nc" id="L503">            throw new IllegalArgumentException(&quot;rightXY.length must be 3&quot;);</span>
        }
<span class="nc" id="L505">        int n = 7;</span>
<span class="nc bnc" id="L506" title="All 4 branches missed.">        if (rightXY[0].length != n || leftXY[0].length != n) {</span>
<span class="nc" id="L507">            throw new IllegalArgumentException(&quot;leftXY and rightXY must have 7 points&quot;);</span>
        }

<span class="nc" id="L510">        double[][] a = createDesignMatrix(leftXY, rightXY);</span>

<span class="nc" id="L512">        SVDProducts svd = null;</span>
        try {
<span class="nc" id="L514">            svd = MatrixUtil.performSVD(MatrixUtil.createATransposedTimesA(a));</span>
<span class="nc" id="L515">        } catch (NotConvergedException ex) {</span>
<span class="nc" id="L516">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L517">            return null;</span>
<span class="nc" id="L518">        }</span>
<span class="nc" id="L519">        int ns = 9;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">        assert(svd.vT[0].length == ns);</span>
        // dimensions of V are nxn and n=9.  smallest eigenvector is last row of v^T and A
<span class="nc" id="L522">        double[][] ff1 = new double[3][3];</span>
<span class="nc" id="L523">        double[][] ff2 = new double[3][3];</span>
        int i;
<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L526">            ff1[i] = new double[3];</span>
<span class="nc" id="L527">            ff2[i] = new double[3];</span>

<span class="nc" id="L529">            ff1[i][0] = svd.vT[ns - 2][(i * 3) + 0];</span>
<span class="nc" id="L530">            ff1[i][1] = svd.vT[ns - 2][(i * 3) + 1];</span>
<span class="nc" id="L531">            ff1[i][2] = svd.vT[ns - 2][(i * 3) + 2];</span>

<span class="nc" id="L533">            ff2[i][0] = svd.vT[ns - 1][(i * 3) + 0];</span>
<span class="nc" id="L534">            ff2[i][1] = svd.vT[ns - 1][(i * 3) + 1];</span>
<span class="nc" id="L535">            ff2[i][2] = svd.vT[ns - 1][(i * 3) + 2];</span>
        }

        //det A = 0 ==&gt; det(α*F1 + (1 − α)*F2) = 0

        /*
        to solve for 'a' as the roots of a polynomial, write out the multiplication
        including that in the determinant in detail, then group by the powers of a to
        calculate the polynomial coefficients.
        see docs/miscNotes/fundamental_cube_roots.txt
         */

<span class="nc" id="L547">        double[] coeffs = calcOrderCoeffs(ff1, ff2);</span>

        //double[] coeffs3 = calculateCubicRootCoefficientsHartley(ff1, ff2);
        //System.out.printf(&quot;Hartley's coeffs:\n%s\n&quot;, FormatArray.toString(coeffs3, &quot;%.3e&quot;));
        //System.out.printf(&quot;coeffs current:\n%s\n&quot;, FormatArray.toString(coeffs, &quot;%.3e&quot;));

<span class="nc" id="L553">        double eps = 1E-4;</span>
        double[] roots;
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (Math.abs(coeffs[3]) &lt; 1E-7) {</span>
<span class="nc" id="L556">            roots = MiscMath.solveCubicRoots(coeffs[0], coeffs[1], coeffs[2], coeffs[3]);</span>
        } else {
            try {
<span class="nc" id="L559">                roots = PolynomialRootSolver.solveForRealUsingMPSolve(coeffs, eps);</span>
<span class="nc" id="L560">            } catch (IOException e) {</span>
<span class="nc" id="L561">                log.severe(&quot;PolynomialRootSolver error: &quot; + e.getMessage());</span>
<span class="nc" id="L562">                roots = MiscMath.solveCubicRoots(coeffs[0], coeffs[1], coeffs[2], coeffs[3]);</span>
<span class="nc" id="L563">            }</span>
        }

        // MASKS Appendix 6.A: usually only one of the solved 'a's is consistent with det(F1 + a*F2) = 0

<span class="nc" id="L568">        return filterForZeroDeterminant(ff1, ff2, roots, eps);</span>
    }

    private double[] calculateCubicRootCoefficientsHartley(double[][] ff1, double[][] ff2) {

        // follow Hartley's vgg_singF_from_FF.m to calc the coeffs:
        // which is rewritten by imkaywu.github.io for opencv
        //TODO: fill in those 2 references here
<span class="nc" id="L576">        double[][][] d = new double[2][2][2];</span>
<span class="nc" id="L577">        double[][] dTmp = MatrixUtil.zeros(3, 3);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        for (int i1 = 0; i1 &lt; 2; ++i1) {</span>
<span class="nc" id="L579">            d[i1] = new double[2][2];</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            for (int i2 = 0; i2 &lt; 2; ++i2) {</span>
<span class="nc" id="L581">                d[i1][i2] = new double[2];</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                for (int i3 = 0; i3 &lt; 2; ++i3) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">                    if (i1 == 0) {</span>
<span class="nc" id="L584">                        dTmp[0] = MatrixUtil.extractColumn(ff1, 0) ;</span>
                    } else {
<span class="nc" id="L586">                        dTmp[0] = MatrixUtil.extractColumn(ff2, 0) ;</span>
                    }
<span class="nc bnc" id="L588" title="All 2 branches missed.">                    if (i2 == 0) {</span>
<span class="nc" id="L589">                        dTmp[1] = MatrixUtil.extractColumn(ff1, 1) ;</span>
                    } else {
<span class="nc" id="L591">                        dTmp[1] = MatrixUtil.extractColumn(ff2, 1) ;</span>
                    }
<span class="nc bnc" id="L593" title="All 2 branches missed.">                    if (i3 == 0) {</span>
<span class="nc" id="L594">                        dTmp[2] = MatrixUtil.extractColumn(ff1, 2) ;</span>
                    } else {
<span class="nc" id="L596">                        dTmp[2] = MatrixUtil.extractColumn(ff2, 2) ;</span>
                    }
<span class="nc" id="L598">                    dTmp = MatrixUtil.transpose(dTmp);</span>
<span class="nc" id="L599">                    d[i1][i2][i3] = MatrixUtil.determinant(dTmp);</span>
                }
            }
        }

<span class="nc" id="L604">        double c3 = -d[1][0][0]+d[0][1][1]+d[0][0][0]+d[1][1][0]+d[1][0][1]-d[0][1][0]-d[0][0][1]-d[1][1][1];</span>
<span class="nc" id="L605">        double c2 = d[0][0][1]-2*d[0][1][1]-2*d[1][0][1]+d[1][0][0]-2*d[1][1][0]+d[0][1][0]+3*d[1][1][1];</span>
<span class="nc" id="L606">        double c1 = d[1][1][0]+d[0][1][1]+d[1][0][1]-3*d[1][1][1];</span>
<span class="nc" id="L607">        double c0 = d[1][1][1];</span>

<span class="nc" id="L609">        return new double[]{c3, c2, c1, c0};</span>
    }

    // det(α*F1 + (1 − α)*F2) = 0
    private double[][] filterForZeroDeterminant(double[][] f1, double[][] f2, double[] roots, double eps) {
        int i;
        int j;
<span class="nc" id="L616">        int c = 0;</span>
        double[][] f;
        double[][] t1;
        double[][] t2;
        double detF;
<span class="nc" id="L621">        double[][] solns = MatrixUtil.zeros(3*roots.length, 3);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">        for (i = 0; i &lt; roots.length; ++i) {</span>
<span class="nc" id="L623">            t1 = MatrixUtil.copy(f1);</span>
<span class="nc" id="L624">            t2 = MatrixUtil.copy(f2);</span>
<span class="nc" id="L625">            MatrixUtil.multiply(t1, roots[i]);</span>
<span class="nc" id="L626">            MatrixUtil.multiply(t2, 1. - roots[i]);</span>
<span class="nc" id="L627">            f = MatrixUtil.pointwiseAdd(t1, t2);</span>
<span class="nc" id="L628">            detF = MatrixUtil.determinant(f);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (Math.abs(detF) &lt; eps) {</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L631">                    solns[c * 3 + j] = f[j];</span>
<span class="nc" id="L632">                    System.arraycopy(f[j], 0, solns[c * 3 + j], 0, f[j].length);</span>
                }
<span class="nc" id="L634">                ++c;</span>
            }
        }
        // number of solutions is c
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (c &lt; roots.length) {</span>
<span class="nc" id="L639">            solns = MatrixUtil.copySubMatrix(solns, 0, 3*c - 1, 0, 2);</span>
        }
<span class="nc" id="L641">        return solns;</span>
    }

        /**
         * calculate the epipolar projection for a set of 8 or more matched points.
         * NOTE that for best results, the method should be given unit standard
         * normalized coordinates.
         * @param leftXY left image correspondence in format of
         * double array with x points on row 0, y points on row 1,
         *     and 1's on row 2.  the number of columns is the number of data points.
         * @param rightXY right image correspondence in format of
         * double array with x points on row 0, y points on row 1,
         *     and 1's on row 2.  the number of columns is the number of data points.
         * @param calibrated if true, solves for the Essential Matrix, else solves for the
         * Fundamental matrix.  The difference is only in the diagonal used for
         * dimension reduction.
         * @return
         */
    public DenseMatrix calculateEpipolarProjection(
        DenseMatrix leftXY, DenseMatrix rightXY, boolean calibrated) {

<span class="pc bpc" id="L662" title="2 of 4 branches missed.">        if (leftXY.numColumns() != rightXY.numColumns() || leftXY.numRows() != rightXY.numRows()) {</span>
<span class="nc" id="L663">            throw new IllegalArgumentException(</span>
                &quot;leftXY and rightXY must be same size&quot;);
        }

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (leftXY.numColumns() == 7) {</span>
<span class="nc" id="L668">            throw new IllegalArgumentException(</span>
                &quot;for 7 points, use calculateEpipolarProjectionFor7Points&quot;);
        }

<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (leftXY.numColumns() &lt; 8) {</span>
            // cannot use this algorithm.
<span class="nc" id="L674">            throw new IllegalArgumentException(</span>
                &quot;the algorithms requires 8 or more points.&quot;);
        }
        
<span class="fc" id="L678">        double[][] m = createKroneckerDesignMatrix(leftXY, rightXY);</span>
        
        /*
        compute linear least square solution:
            solve A = U * D * V^T   for A*f = [..x...]*f = 0
            A has rank 8.  f has rank 2.

        calculate [U,D,V] from svd(A):
        */
<span class="fc" id="L687">        double[][] aTa = MatrixUtil.createATransposedTimesA(m);</span>
        //DenseMatrix aMatrix = new DenseMatrix(m);
<span class="fc" id="L689">        DenseMatrix aTaMatrix = new DenseMatrix(aTa);</span>

        //System.out.printf(&quot;matrix A dimensions = %d x %d\n&quot;, m.length, m[0].length);
        
        //aMatrix is m x n  (== nData X 9)
        // U   is  m X m = nData X nData the left singular vectors, **column-wise**
        // S   is  min(m, n) the singular values (stored in descending order)
        // V^T is  n X n = 9x9    the right singular vectors, **row-wise**

        //A^T * A is 9x9

<span class="fc" id="L700">        SVDProducts svd = null;</span>
        try {
<span class="fc" id="L702">            svd = MatrixUtil.performSVD(aTaMatrix);</span>
<span class="nc" id="L703">        } catch (NotConvergedException e) {            </span>
<span class="nc" id="L704">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, e);</span>
<span class="nc" id="L705">            return null;</span>
<span class="fc" id="L706">        }</span>

        //when condition number is large, the 2 smallest eigenvalues are close to on another
        //and that makes their eigenvectors sensitive to small perturbations.
<span class="fc" id="L710">        double conditionNumber = svd.s[0]/svd.s[svd.s.length-2];</span>
<span class="fc" id="L711">        log.fine(&quot;conditionNumber=&quot; + conditionNumber);</span>
        
        /*        
        set f to be the eigenvector associated with the smallest eigenvalue
        (which is the last row of V^T or the last column of V).
         the smallest eigenvalue determines the plane of closest fit.
         */
      
<span class="fc" id="L719">        int n = svd.vT.length;</span>
<span class="pc bnc" id="L720" title="All 2 branches missed.">        assert(n == 9);</span>
<span class="pc bnc" id="L721" title="All 2 branches missed.">        assert(svd.vT[0].length == 9);</span>

        // dimensions of V are nxn and n=9.  smallest eigenvector is last row of v^T and A
<span class="fc" id="L724">        double[][] ff = new double[3][3];</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L726">            ff[i] = new double[3];</span>
          
<span class="fc" id="L728">            ff[i][0] = svd.vT[n - 1][(i * 3) + 0];</span>
<span class="fc" id="L729">            ff[i][1] = svd.vT[n - 1][(i * 3) + 1];</span>
<span class="fc" id="L730">            ff[i][2] = svd.vT[n - 1][(i * 3) + 2];</span>
        }
<span class="fc" id="L732">        DenseMatrix fMatrix = new DenseMatrix(ff);</span>

        /* make the fundamental matrix have a rank of 2
        by performing svd and reconstruction with the two largest
        singular values.
            [U,D,V] = svd(F,0);
        (a.k.a. dimension reduction.  
        see Chap 11 of book &quot;Mining of Massive Datasets&quot; 
        by Jure Leskovec, Anand Rajaraman, Jeff Ullman
        http://www.mmds.org/)

        From [U,D,V] we create:
            F = U * diag([D(1,1) D(2,2) 0]) * V^T, where V^T is V transposed.
        */
        
<span class="fc" id="L747">        SVD svd2 = null;</span>
        try {
<span class="fc" id="L749">            svd2 = SVD.factorize(fMatrix);</span>
<span class="nc" id="L750">        } catch (NotConvergedException e) {            </span>
<span class="nc" id="L751">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, e);</span>
<span class="nc" id="L752">            return null;</span>
<span class="fc" id="L753">        }</span>
       
        // creates U as 3 x 3 matrix
        //         D as length 3 array
        //         V as 3 x 3 matrix

        //F = U * diag([D(1,1) D(2,2) 0]) * V^T, where V^T is V transposed.

        // keep the largest 2 values in sDiag to make the diagonal rank 2
<span class="fc" id="L762">        DenseMatrix d = new DenseMatrix(3, 3);</span>
<span class="fc" id="L763">        d = (DenseMatrix)d.zero();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        if (calibrated) {</span>
            //from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
            // refers to Ma, Soatto, Kosecka, and Sastry 2003
            // &quot;An Invitation to 3D Vision From Images to Geometric Models&quot;, p. 114
            // if this is solving the Essential matrix instead of the Fundamental 
            //    Matrix, the diagonal is 
            // d = [lambda, lambda, 0] where lambda = (svd.s[0] + svd.s[1])/2.
            // MASKS Theorem 5.9
<span class="fc" id="L772">            double sig = (svd2.getS()[0] + svd2.getS()[1])/2.;</span>
<span class="fc" id="L773">            d.set(0, 0, sig);</span>
<span class="fc" id="L774">            d.set(1, 1, sig);</span>
            //NOTE: to normalize E, one can use sig = 1 here. see p. 122 of MASKS chapt 5.
<span class="fc" id="L776">        } else {</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">            if (svd2.getS().length &gt; 0) {</span>
<span class="fc" id="L778">                d.set(0, 0, svd2.getS()[0]);</span>
            }
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">            if (svd2.getS().length &gt; 1) {</span>
<span class="fc" id="L781">                d.set(1, 1, svd2.getS()[1]);</span>
            }
        }        
        
        // dimension reduction in this case zeroes out instead of reducing the
        // sizes of the matrices.  if wanted to reduce the size:
        //   remove the last column of U and the last row of V and
        //   the last item in the diagonal of S
                        
        /*
        multiply the terms:
             F = dot(U, dot(diag(D),V^T))
        */
<span class="fc" id="L794">        DenseMatrix dDotV = MatrixUtil.multiply(d, svd2.getVt());</span>

        // 3x3 with rank 2
<span class="fc" id="L797">        DenseMatrix fm = MatrixUtil.multiply(svd2.getU(), dDotV);</span>
 
<span class="fc" id="L799">        return fm;</span>
    }

    /*
    the 7-point algorithm.
    references are:
      the the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img
    from a version of http://www.robots.ox.ac.uk/~vgg/hzbook/code/ which is part
    of the supplementary material for their book &quot;Multiple View Geometry in Computer Vision
    Second Edition&quot;
       and Hartley, R. I. (1994a). Projective reconstruction and invariants from 
    multiple images. PAMI, 16(10):1036–1041
       and Torr, P. H. S. and Murray, D. (1997). 
    &quot;The development and comparison of robust meth- ods for estimating the 
    fundamental matrix. International Journal of Computer Vision&quot;, 24(3):271–300.

    (1) Transform the coordinates using unit normal standaridization.

    (2) build matrix A with the normalized x,y points.
    (3) The homogeneous system AX = 0 : X is the null space of matrix A.
        The system is nullable because rank 7 &lt; number of columns, 9.

        The nullable system must have a solution other than trivial where
        |A| = 0.

        There should be 9-7=2 linearly independent vectors u1, u2, ... , un-r
        that span the null space of A.

        The right null space of A reduced by SVD is then 2D and the last
        2 columns of V can be extracted and reshaped to [3x3] as F1 and F2.

        A linear convex combination of F1 and F2 form the estimate of F.

        F = α*F1 + (1 − α)*F2  where α is between 0 and 1

        The eigenvalues of F are possible only if the determinant of F is 0.
        The determinant of F is a polynomial function, the characteristic
        polynomial whose degree is the order of the matrix, which is 3 in this
        case. Therefore, the answer(s) to determinant(F) = 0 requires the cubic
        roots of the equation.

        det A = 0 ==&gt; det(α*F1 + (1 − α)*F2) = 0

        because det(F1 + F2) != det(F1) + det(F2), have to step through the
        determinant of the sums, and group the terms by a^3, a^2, a^1, and a^0
        and then solve for the cubic roots as the values of 'a'.

   The matrices multiplied and summed:

    a*ff1[0][0] + (1-a)*ff2[0][0]   a*ff1[0][1] + (1-a)*ff2[0][1]   a*ff1[0][2] + (1-a)*ff2[0][2]
    a*ff1[1][0] + (1-a)*ff2[1][0]   a*ff1[1][1] + (1-a)*ff2[1][1]   a*ff1[1][2] + (1-a)*ff2[1][2]
    a*ff1[2][0] + (1-a)*ff2[2][0]   a*ff1[2][1] + (1-a)*ff2[2][1]   a*ff1[2][2] + (1-a)*ff2[2][2]

    The terms are further grouped below in methods
       calculateCubicRoot...OrderCoefficientFor7Point(ff1, ff2)

    After the cubic root(s) are solved, they are back substituted into :
        Fi = a(i) * FF{1} + (1-a(i)) * FF{2};
    to get the solutions Fi which may be one or 3 solutions.
    */

    /**
     * calculate the epipolar projection for 7 correspondences and filter
     * with a chirality check.  returns a list of the filtered solutions.
     * NOTE that for best results, the method should be given unit standard
     * normalized coordinates.
     * references are:
        (1) the the Hartley &amp; Zisserman matlab code vgg_F_from_7pts_2img
        from a version of http://www.robots.ox.ac.uk/~vgg/hzbook/code/ which is part
        of the supplementary material for their book &quot;Multiple View Geometry in Computer Vision
        Second Edition&quot;
        (2) Section IVa of Hartley, R. I. (1994a). Projective reconstruction and invariants from 
        multiple images. PAMI, 16(10):1036–1041
        (3) Torr, P. H. S. and Murray, D. (1997). 
        &quot;The development and comparison of robust methods for estimating the 
        fundamental matrix. International Journal of Computer Vision&quot;, 24(3):271–300.
     * @param leftXY
     * @param rightXY
     * 
     * @return
     */
    public List&lt;DenseMatrix&gt; calculateEpipolarProjectionFor7Points(
        DenseMatrix leftXY, DenseMatrix rightXY) {

<span class="fc" id="L883">        final int nSet = 7;</span>
        
<span class="pc bpc" id="L885" title="2 of 4 branches missed.">        if (leftXY.numRows() != rightXY.numRows() || leftXY.numColumns() != rightXY.numColumns()) {</span>
<span class="nc" id="L886">            throw new IllegalArgumentException(&quot;leftXY and rightXY must have same dimensions&quot;);</span>
        }
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if (leftXY.numColumns() != nSet) {</span>
<span class="nc" id="L889">            throw new IllegalArgumentException(&quot;leftXY.numColumns must be at least 7&quot;);</span>
        }
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">        if (leftXY.numRows() != 3) {</span>
<span class="nc" id="L892">            throw new IllegalArgumentException(&quot;leftXY.numRows must be 3&quot;);</span>
        }

        // m is [nData X 9]
<span class="fc" id="L896">        double[][] m = createKroneckerDesignMatrix(leftXY, rightXY);</span>

        // [9X9]
<span class="fc" id="L899">        double[][] aTa = MatrixUtil.multiply(MatrixUtil.transpose(m), m);</span>

        // S   is  min(m, n) the singular values (stored in descending order)
        // V^T is  n X n = 9x9    the right singular vectors, **row-wise**

<span class="fc" id="L904">        SVDProducts svd = null;</span>
        try {
<span class="fc" id="L906">            svd = MatrixUtil.performSVD(aTa);</span>
<span class="nc" id="L907">        } catch (NotConvergedException e) {</span>
<span class="nc" id="L908">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, e);</span>
<span class="nc" id="L909">            return null;</span>
<span class="fc" id="L910">        }</span>

        //when condition number is large, the 2 smallest eigenvalues are close to on another
        //and that makes their eigenvectors sensitive to small perturbations.
<span class="fc" id="L914">        double conditionNumber = svd.s[0]/svd.s[svd.s.length-2];</span>
<span class="fc" id="L915">        log.fine(&quot;conditionNumber=&quot; + conditionNumber);</span>

        //for i &lt;=r:
        //    A*v_i = σ*u_i
        //for i &gt;r:
        //    A*v_i = 0 and A^T*u_i = 0

<span class="fc" id="L922">        int n = svd.vT.length;</span>
<span class="pc bnc" id="L923" title="All 2 branches missed.">        assert(n == 9);</span>

        // last singular value being 0, the last column of V is a solution to the nullspace, that is A*x=0

<span class="fc" id="L927">        double[][] ff1 = new double[3][3];</span>
<span class="fc" id="L928">        double[][] ff2 = new double[3][3];</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>

<span class="fc" id="L931">            ff1[i] = new double[3];</span>
<span class="fc" id="L932">            ff2[i] = new double[3];</span>
            
<span class="fc" id="L934">            ff1[i][0] = svd.vT[n - 2][(i * 3) + 0];</span>
<span class="fc" id="L935">            ff1[i][1] = svd.vT[n - 2][(i * 3) + 1];</span>
<span class="fc" id="L936">            ff1[i][2] = svd.vT[n - 2][(i * 3) + 2];</span>
            
<span class="fc" id="L938">            ff2[i][0] = svd.vT[n - 1][(i * 3) + 0];</span>
<span class="fc" id="L939">            ff2[i][1] = svd.vT[n - 1][(i * 3) + 1];</span>
<span class="fc" id="L940">            ff2[i][2] = svd.vT[n - 1][(i * 3) + 2];</span>
        }
        
<span class="fc" id="L943">        DenseMatrix[] solutions = solveFor7Point(ff1, ff2);</span>

<span class="fc" id="L945">        List&lt;DenseMatrix&gt; validatedFM = new ArrayList&lt;DenseMatrix&gt;();</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">        for (DenseMatrix solution : solutions) {</span>
            //System.out.printf(&quot;validating FM=\n%s\n&quot;, FormatArray.toString(solution, &quot;%.3e&quot;));
            // chirality (cheirality) check
<span class="fc bfc" id="L949" title="All 2 branches covered.">            if (validateSolution(solution, leftXY, rightXY)) {</span>
<span class="fc" id="L950">                validatedFM.add(solution);</span>
            }
        }

<span class="fc" id="L954">        return validatedFM;</span>
    }
   
    /**
     * The validation of the 7-point algorithm follows source code adapted
     * from this site and license:
     *
     * based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        &quot;MATLAB Functions for Multiple View Geometry&quot;

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a
        * copy of this software and associated documentation files
        * (the &quot;Software&quot;), to deal in the Software without restriction,
        * including without limitation the rights to use, copy, modify, merge,
        * publish, distribute, sublicense, and/or sell copies of the Software,
        * and to permit persons to whom the Software is furnished to do so,
        * subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        * in all copies or substantial portions of the Software.

        The software is provided &quot;as is&quot;, without warranty of any kind, express
        * or implied, including but not limited to the warranties of
        * merchantability, fitness for a particular purpose and noninfringement.
        * In no event shall the authors or copyright holders be liable for any
        * claim, damages or other liability, whether in an action of contract,
        * tort or otherwise, arising from, out of or in connection with the
        * software or the use or other dealings in the software.

       vgg_multiview/vgg_F_from_7pts_2img.m

       The method &quot;signs_OK&quot; validates the solution matrices:

        for i = 1:length(a)
          Fi = a(i)*FF{1} + (1-a(i))*FF{2};
          %for n = 1:7, disp(norm(x(:,n,1)'*Fi*x(:,n,2))), end  % test code
          if signs_OK(Fi,x1,x2)
            F = cat(3, F, Fi);
          end
        end

        return

        %%%%%%%%%%%%%%%%%%%%%%%%%

        % Checks sign consistence of F and x
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F');
        e1 = v(:,3);
        l1 = vgg_contreps(e1)*x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s&gt;0) | all(s less than 0);
        return

    More on the subject is present in &quot;Cheirality in Epipolar Geometry&quot; by
    Werner &amp; Pajdla, 2000 regarding realizability of two images.
    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.9013&amp;rep=rep1&amp;type=pdf

    Very clear paper on cheirality:
    * http://users.cecs.anu.edu.au/~hartley/Papers/cheiral/revision/cheiral.pdf
    * The cheirality of a point is whether it lies in front of or behind a given
    * camera.  It's used to  distinguish between four different possible scene
    * reconstructions from two views.
    * A transform is cheirality-reversing for a given point if it swaps the
    * point from the front to the back of the camera, or vice-versa.
    * Otherwise it is called cheirality-preserving.
    * 
    * note: alternate spelling is chirality.
    */
    @SuppressWarnings({&quot;unchecked&quot;})
    boolean validateSolution(DenseMatrix fm, DenseMatrix leftXY,
        DenseMatrix rightXY) {
        
        /*
        NOTE: vgg_contreps of a 3X1 vector e1 is
            Y = [0      e1(3)  -e1(2)
                -e1(3)  0      e1(1)
                 e1(2) -e1(1)  0];
        (looks like the skew-symmetric of e1)
        NOTE: '.*' is matlab notation to operate on each field
        NOTE: the ' is mathematica syntax for conjugate transpose, a.k.a.
               the Hermitian. it's a matrix with signs reversed for imaginary
                components of complex numbers and then the matrix transposed.
                
        function OK = signs_OK(F,x1,x2)
        [u,s,v] = svd(F'); where F' is the conjugate transpose of F
        e1 = v(:,3);
        l1 = vgg_contreps(e1) * x1;
        s = sum( (F*x2) .* l1 );
        OK = all(s&gt;0) | all(s&lt;0);

        NLK: note that SVD(F^T).VT = -transpose( SVD(F).U ) and so e1 = -1 * last row of SVD(F).U

        'sum' is a matlab function to sum for each column

        'all' is a function that returns '1' is all items are non-zero, else
            returns 0
        */

        // 3X3 * 3X7 = 3 X 7
<span class="fc" id="L1060">        DenseMatrix fX2 = MatrixUtil.multiply(fm, rightXY);</span>

        //SVD(F^T).VT = -transpose( SVD(F).U ) and so e1 = -1 * last row of U
<span class="fc" id="L1063">        double[][] leftRightEpipoles = calculateEpipoles(fm);</span>
<span class="fc" id="L1064">        double[] e1 = leftRightEpipoles[0];</span>

        // 3 columns (x,y,1):
        //vgg_contreps of a 3X1 vector e1 is
        //    Y = [0      e1(3)  -e1(2)
        //        -e1(3)  0      e1(1)
        //         e1(2) -e1(1)  0];
        //  [x y ] [x0 x1 x2 x3 x4 x5 x6]
        //         [y0 y1 y2 y3 y4 y5 y6]

<span class="fc" id="L1074">        double[][] contreps = MatrixUtil.skewSymmetric(e1);</span>
<span class="fc" id="L1075">        MatrixUtil.multiply(contreps, -1);</span>

        // sum of ( (F * x2) .*  [e2]_x*x1 )
        // =      ( l2 .*  [e2]_x*x1 )

        // from MASKS, have
        //    l2 ~ F*x1
        //    l1 ~ F^T*x2
        //     l^T*x=0 for (l1,x1) and also (l2,x2)
        // and l*e=0 for (l1,e1) and also (l2,e2)

        // 3 X 7
<span class="fc" id="L1087">        double[][] l1 = MatrixUtil.multiply(contreps, MatrixUtil.convertToRowMajor(leftXY));</span>

        // 3 x 7
<span class="fc" id="L1090">        double[][] fX2l1 = MatrixUtil.pointwiseMultiplication(MatrixUtil.convertToRowMajor(fX2), l1);</span>

        // matlab sum function:
        //    If A is a matrix, then sum(A) returns a row vector containing 
        //    the sum of each column.
<span class="fc" id="L1095">        double[] sum = new double[fX2l1[0].length];</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">        for (int row = 0; row &lt; fX2l1.length; ++row){</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">            for (int col = 0; col &lt; fX2l1[0].length; ++col) {</span>
<span class="fc" id="L1098">                sum[col] += fX2l1[row][col];</span>
            }
        }

        //'all' is a function that returns '1' is all items are non-zero, else
        //    returns 0
<span class="fc" id="L1104">        int nGTZ = 0;</span>
<span class="fc" id="L1105">        int nLTZ = 0;</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">        for (int i = 0; i &lt; sum.length; ++i) {</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">            if (sum[i] == 0) {</span>
<span class="nc" id="L1108">                return false;</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">            } else if (sum[i] &gt; 0) {</span>
<span class="fc" id="L1110">                nGTZ++;</span>
            } else {
<span class="fc" id="L1112">                nLTZ++;</span>
            }
        }

<span class="pc bpc" id="L1116" title="1 of 8 branches missed.">        return ((nGTZ &gt; 0 &amp;&amp; nLTZ == 0) || (nLTZ &gt; 0 &amp;&amp; nGTZ == 0));</span>
    }

    /**
     * Determine the camera matrices of an image pair up to a scene 
     * homography, given their fundamental matrix using algorithm
     * of Hartley and Zisserman 2004.
     * &lt;pre&gt;
     * If x2'*F*x1 = 0 for any pair of image points x1 and x2,
         then the camera matrices of the image pair are 
         P1 = [I 0] (as 3x4 matrix) and P2 = vgg_P_from_F(F), up to a scene homography.
     * &lt;/pre&gt;
     * algorithm follows source code for vgg_P_from_F.m 
     * adapted from this site and license:
     *
     * based upon code within  www.robots.ox.ac.uk/~vgg/hzbook/code/
        MIT License
        License for
        &quot;MATLAB Functions for Multiple View Geometry&quot;

        Copyright (c) 1995-2005 Visual Geometry Group
        Department of Engineering Science
        University of Oxford
        http://www.robots.ox.ac.uk/~vgg/
        Permission is hereby granted, free of charge, to any person obtaining a
        * copy of this software and associated documentation files
        * (the &quot;Software&quot;), to deal in the Software without restriction,
        * including without limitation the rights to use, copy, modify, merge,
        * publish, distribute, sublicense, and/or sell copies of the Software,
        * and to permit persons to whom the Software is furnished to do so,
        * subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        * in all copies or substantial portions of the Software.

        The software is provided &quot;as is&quot;, without warranty of any kind, express
        * or implied, including but not limited to the warranties of
        * merchantability, fitness for a particular purpose and noninfringement.
        * In no event shall the authors or copyright holders be liable for any
        * claim, damages or other liability, whether in an action of contract,
        * tort or otherwise, arising from, out of or in connection with the
        * software or the use or other dealings in the software.

       
        %%%%%%%%%%%%%%%%%%%%%%%%%
     * @param f fundamental matrix in format 3x3
     * @return camera matrices in format 3x4
    */
    @SuppressWarnings({&quot;unchecked&quot;})
    public DenseMatrix pFromF(DenseMatrix f) {
        
        /*
         // e2^T*F = 0  and F*e1 = 0
         // F^T * x2 = leftEpipolarLines, that is lines in left image 
                       due to epipolar projection of right points
         // F * x1 = rightEpipolarLines, that is lines in right image 
                       due to epipolar projection of left points
         // e1 = last column of U / last item of that column
         //    = the left image position of the epipolar projection of the right camera center
         // e2 = last row of V / last item of that row
         //    = the right image position of the epipolar projection of the left camera center
        */
        
        /*        
        NOTE: vgg_contreps of a 3X1 vector e1 is
            Y = [0      e1(3)  -e1(2)
                -e1(3)  0      e1(1)
                 e1(2) -e1(1)  0];
        (looks like the skew-symmetric of e1)
              
        function P = vgg_P_from_F(F)
        [U,S,V] = svd(F);
        e = U(:,3);
        P = [-vgg_contreps(e)*F e];
        return
        */
<span class="nc" id="L1192">        EpipolarTransformer tr = new EpipolarTransformer();</span>
        
<span class="nc" id="L1194">        SVDProducts svdE = null;</span>
        try {
<span class="nc" id="L1196">            svdE = MatrixUtil.performSVD(f);</span>
<span class="nc" id="L1197">        } catch (NotConvergedException ex) {</span>
<span class="nc" id="L1198">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L1199">            return null;</span>
<span class="nc" id="L1200">        }</span>
        
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        assert(svdE.u[0].length == 3);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        assert(svdE.u.length == 3);</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">        assert(svdE.vT[0].length == 3);</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">        assert(svdE.vT.length == 3);</span>
        // e2 = last column of U but not normalized by the last item of that column
<span class="nc" id="L1207">        double[] e2 = new double[svdE.u.length];</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        for (int i = 0; i &lt; e2.length; i++) {</span>
<span class="nc" id="L1209">            e2[i] = svdE.u[i][2];</span>
        }
        
        //-1* vgg_contreps of a 3X1 vector e is the skewSymmetric
        //    Y = [0      e(3)  -e(2)
        //        -e(3)  0      e(1)
        //         e(2) -e(1)  0];
<span class="nc" id="L1216">        double[][] contrepsE2 = new double[3][3];</span>
<span class="nc" id="L1217">        contrepsE2[0] = new double[]{0, -e2[2], e2[1]};</span>
<span class="nc" id="L1218">        contrepsE2[1] = new double[]{e2[2], 0, -e2[0]};</span>
<span class="nc" id="L1219">        contrepsE2[2] = new double[]{-e2[1], e2[0], 0};</span>
        
        // 3X3
<span class="nc" id="L1222">        double[][] P = MatrixUtil.copy(contrepsE2);</span>
<span class="nc" id="L1223">        P = MatrixUtil.multiply(P, MatrixUtil.convertToRowMajor(f));</span>
        
        // append e onto last column of P
<span class="nc" id="L1226">        double[][] out = new double[P.length][P[0].length + 1];</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        for (int row = 0; row &lt; P.length; ++row){</span>
<span class="nc" id="L1228">            out[row] = new double[P[0].length + 1];</span>
<span class="nc" id="L1229">            System.arraycopy(P[row], 0, out[row], 0, P[0].length);</span>
<span class="nc" id="L1230">            out[row][P[0].length] = e2[row];</span>
        }

<span class="nc" id="L1233">        return new DenseMatrix(out);</span>
    }

    DenseMatrix[] solveFor7Point(double[][] ff1, double[][] ff2) {

        //solve for the roots of equation a0 * x^3 + a1 * x^2 + a2 * x + a3 = 0;

<span class="fc" id="L1240">        double[] coeffs = calcOrderCoeffs(ff1, ff2);</span>
<span class="fc" id="L1241">        double[] roots = null;//MiscMath.solveCubicRoots(coeffs[0], coeffs[1], coeffs[2], coeffs[3]);</span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">        if (Math.abs(coeffs[3]) &lt; 1E-7) {</span>
<span class="fc" id="L1243">            roots = MiscMath.solveCubicRoots(coeffs[0], coeffs[1], coeffs[2], coeffs[3]);</span>
        } else {
            try {
<span class="fc" id="L1246">                roots = PolynomialRootSolver.solveForRealUsingMPSolve(coeffs, eps);</span>
<span class="nc" id="L1247">            } catch (IOException e) {</span>
<span class="nc" id="L1248">                log.severe(&quot;PolynomialRootSolver error: &quot; + e.getMessage());</span>
<span class="nc" id="L1249">                roots = MiscMath.solveCubicRoots(coeffs[0], coeffs[1], coeffs[2], coeffs[3]);</span>
<span class="fc" id="L1250">            }</span>
        }

<span class="fc" id="L1253">        double[][] m = new double[3][];</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L1255">            m[i] = new double[3];</span>
        }

<span class="fc" id="L1258">        DenseMatrix[] solutions = new DenseMatrix[roots.length];</span>

        double detF;
<span class="fc" id="L1261">        int c = 0;</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">        for (int i = 0; i &lt; roots.length; i++) {</span>
            //Fi = a(i)*FF{1} + (1-a(i))*FF{2};
<span class="fc" id="L1264">            double a = roots[i];</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">            for (int row = 0; row &lt; 3; row++) {</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">                for (int col = 0; col &lt; 3; col++) {</span>
<span class="fc" id="L1267">                    m[row][col] = a*ff1[row][col] + (1. - a)*ff2[row][col];</span>
                }
            }
            // MASKS Appendix 6.A: usually only one of the solved 'a's is consistent with det(F1 + a*F2) = 0
<span class="fc" id="L1271">            detF = MatrixUtil.determinant(m);</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">            if (Math.abs(detF) &lt; eps) {</span>
<span class="fc" id="L1273">                solutions[c] = new DenseMatrix(m);</span>
<span class="fc" id="L1274">                ++c;</span>
            }
        }
<span class="fc" id="L1277">        double eps = 1E-4;</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        if (c &lt; roots.length) {</span>
<span class="fc" id="L1279">            solutions = Arrays.copyOfRange(solutions,0, c);</span>
        }

<span class="fc" id="L1282">        return solutions;</span>
    }

    // see docs/miscNotes/fundamental_cube_roots.txt
    private double[] calcOrderCoeffs( double[][] ff1, double[][] ff2) {

<span class="fc" id="L1288">        double f100 = ff1[0][0];</span>
<span class="fc" id="L1289">        double f110 = ff1[1][0];</span>
<span class="fc" id="L1290">        double f120 = ff1[2][0];</span>
<span class="fc" id="L1291">        double f101 = ff1[0][1];</span>
<span class="fc" id="L1292">        double f111 = ff1[1][1];</span>
<span class="fc" id="L1293">        double f121 = ff1[2][1];</span>
<span class="fc" id="L1294">        double f102 = ff1[0][2];</span>
<span class="fc" id="L1295">        double f112 = ff1[1][2];</span>
<span class="fc" id="L1296">        double f122 = ff1[2][2];</span>

<span class="fc" id="L1298">        double f200 = ff2[0][0];</span>
<span class="fc" id="L1299">        double f210 = ff2[1][0];</span>
<span class="fc" id="L1300">        double f220 = ff2[2][0];</span>
<span class="fc" id="L1301">        double f201 = ff2[0][1];</span>
<span class="fc" id="L1302">        double f211 = ff2[1][1];</span>
<span class="fc" id="L1303">        double f221 = ff2[2][1];</span>
<span class="fc" id="L1304">        double f202 = ff2[0][2];</span>
<span class="fc" id="L1305">        double f212 = ff2[1][2];</span>
<span class="fc" id="L1306">        double f222 = ff2[2][2];</span>

<span class="fc" id="L1308">        double c3 = f100*f111*f122</span>
                - f100*f111*f222
                - f100*f112*f121
                + f100*f112*f221
                + f100*f121*f212
                - f100*f122*f211
                + f100*f211*f222
                - f100*f212*f221
                - f101*f110*f122
                + f101*f110*f222
                + f101*f112*f120
                - f101*f112*f220
                - f101*f120*f212
                + f101*f122*f210
                - f101*f210*f222
                + f101*f212*f220

                + f102*f110*f121
                - f102*f111*f120
                + f102*f111*f220
                + f102*f120*f211
                - f102*f121*f210
                + f102*f210*f221
                - f102*f211*f220

                - f110*f102*f221
                + f110*f122*f201
                - f110*f202*f121
                + f110*f202*f221
                - f110*f222*f201

                + f111*f120*f202
                + f111*f200*f222
                - f111*f200*f122
                - f111*f202*f220

                - f112*f120*f201
                + f112*f121*f200
                - f112*f221*f200
                + f112*f201*f220

                + f120*f201*f212
                - f120*f202*f211

                + f121*f202*f210
                - f121*f212*f200

                - f122*f201*f210
                + f122*f211*f200

                - f200*f211*f222
                + f200*f212*f221

                + f201*f210*f222
                - f201*f212*f220

                - f202*f210*f221
                + f202*f211*f220;

<span class="fc" id="L1367">        double c2 = f100*f111*f222</span>
                - f100*f112*f221
                - f100*f121*f212
                + f100*f122*f211
                - 2 * f100*f211*f222
                + 2 * f100*f212*f221

                - f101*f110*f222
                + f101*f112*f220
                + f101*f120*f212
                - f101*f122*f210
                + 2 * f101*f210*f222
                - 2 * f101*f212*f220

                + f102*f110*f221
                - f102*f111*f220
                + f102*f121*f210
                - f102*f120*f211
                - 2 * f102*f210*f221
                + 2 * f102*f211*f220

                + f110*f121*f202
                - f110*f122*f201
                + 2 * f110*f201*f222
                - 2 * f110*f202*f221

                - f111*f120*f202
                + f111*f122*f200
                - 2 * f111*f200*f222
                + 2 * f111*f202*f220

                + f112*f120*f201
                - f112*f121*f200
                + 2 * f112*f200*f221
                - 2 * f112*f201*f220

                - 2 * f120*f201*f212
                + 2 * f120*f202*f211

                - 2 * f122*f200*f211
                + 2 * f121*f200*f212
                - 2 * f121*f202*f210

                + 2 * f122*f201*f210

                + 3 * f200*f211*f222
                - 3 * f200*f212*f221

                - 3 * f201*f210*f222
                + 3 * f201*f212*f220

                + 3 * f202*f210*f221
                - 3 * f202*f211*f220;

<span class="fc" id="L1421">        double c1 = f100*f211*f222</span>
                - f100*f221*f212

                - f101*f210*f222
                + f101*f212*f220

                + f102*f210*f221
                - f102*f211*f220

                + f200*f111*f222
                - f200*f112*f221
                - f200*f121*f212
                + f200*f211*f122

                - 3 * f200*f211*f222

                + 3 * f200*f221*f212

                - f201*f110*f222
                + f201*f112*f220
                + f201*f120*f212
                - f201*f210*f122

                + 3 * f201*f210*f222

                - 3 * f201*f212*f220
                + f202*f110*f221
                - f202*f120*f211

                - f202*f111*f220
                + f202*f121*f210

                - 3 * f202*f210*f221

                + 3 * f202*f211*f220;

<span class="fc" id="L1457">        double c0 = f202*f210*f221</span>
                - f201*f210*f222
                - f202*f211*f220
                + f200*f211*f222
                - f200*f212*f221
                + f201*f212*f220;

<span class="fc" id="L1464">        return new double[]{c3, c2, c1, c0};</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;})
    DenseMatrix denormalizeTheFundamentalMatrix(
        DenseMatrix normalizedFundamentalMatrix,
        NormalizedXY normalizedLeftXY, NormalizedXY normalizedRightXY) {

<span class="nc" id="L1472">        return denormalizeTheFundamentalMatrix(normalizedFundamentalMatrix, </span>
<span class="nc" id="L1473">            normalizedLeftXY.getNormalizationMatrices(), </span>
<span class="nc" id="L1474">            normalizedRightXY.getNormalizationMatrices());</span>
       
    }

    /**
     Unit standard normalize the x,y coordinates so that mean=0 and standard deviation = 1.
     returns the transformation matrix and the normalized coordinates.
     * @param xy the data to normalize
     * @return the transformation matrix and the normalized coordinates
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public static NormalizedXY normalize(DenseMatrix xy) {
<span class="fc" id="L1486">        return normalizeUsingUnitStandard(xy);</span>
    }
    
   /**
    Unit standard normalize the x,y coordinates so that mean=0 and standard deviation = 1.
     returns the transformation matrix and the normalized coordinates.
     * @param xy the data to normalize
     * @return the transformation matrix and the normalized coordinates
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public static NormalizedXY normalizeUsingUnitStandard(DenseMatrix xy) {

        /*
        format points such that the applied translation
        and scaling have the effect of:

        a) points are translated so that their centroid is at the origin.
        b) points are then scaled so that the average distance from the
           origin is sqrt(2)
        c) the transformation is applied to each of the 2 images separately.
        */

<span class="fc" id="L1508">        int n = xy.numColumns();</span>

        //x is xy[0], y is xy[1], xy[2] is all 1's
<span class="fc" id="L1511">        double cen0 = 0;</span>
<span class="fc" id="L1512">        double cen1 = 0;</span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1514">            cen0 += xy.get(0, i);</span>
<span class="fc" id="L1515">            cen1 += xy.get(1, i);</span>
        }
<span class="fc" id="L1517">        cen0 /= (double)n;</span>
<span class="fc" id="L1518">        cen1 /= (double)n;</span>

<span class="fc" id="L1520">        double scale = 0;</span>
        double diffX, diffY;
<span class="fc bfc" id="L1522" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1523">            diffX = xy.get(0, i) - cen0;</span>
<span class="fc" id="L1524">            diffY = xy.get(1, i) - cen1;</span>
<span class="fc" id="L1525">            scale += (diffX*diffX + diffY*diffY);</span>
        }
<span class="fc" id="L1527">        scale = Math.sqrt(scale/(n-1.));</span>
        
<span class="fc" id="L1529">        NormalizationTransformations tMatrices = createScaleTranslationMatrices(</span>
            scale, cen0, cen1);
       
<span class="fc" id="L1532">        DenseMatrix normXY = MatrixUtil.multiply(new DenseMatrix(tMatrices.t), xy);</span>
        
<span class="fc" id="L1534">        NormalizedXY normalizedXY = new NormalizedXY();</span>
<span class="fc" id="L1535">        normalizedXY.setNormMatrices(tMatrices);</span>
<span class="fc" id="L1536">        normalizedXY.setXy(normXY);</span>

<span class="fc" id="L1538">        return normalizedXY;</span>
    }

    /**
     perform unit standard normalization of the points xy to result in a mean of 0 for xy and a standard deviation of 1,
     and return the mean of x, mean of y, st. dev of x and st dev of y.  note that no normalization is performed on the z coordinates.
     note that the normalization alters the input.
     * @param xy data points in format [3 X n].  e.g. xy[0][0] is x, xy[1][0] is y, xy[2][0] is z for point 0.
     * @return mean of x, mean of y, st. dev of x and st dev of y
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public static double[] normalizeUsingUnitStandard(double[][] xy) {

<span class="nc bnc" id="L1551" title="All 2 branches missed.">        if (xy.length != 3) {</span>
<span class="nc" id="L1552">            throw new IllegalArgumentException(&quot;xy.length must be 3&quot;);</span>
        }
<span class="nc" id="L1554">        int n = xy[0].length;</span>

<span class="nc" id="L1556">        double[] mS = new double[4];</span>

        int i;
        int j;
<span class="nc bnc" id="L1560" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">            for (j = 0; j &lt; 2; ++j) {</span>
<span class="nc" id="L1562">                mS[j] += xy[j][i];</span>
            }
        }

<span class="nc bnc" id="L1566" title="All 2 branches missed.">        for (j = 0; j &lt; 2; ++j) {</span>
<span class="nc" id="L1567">            mS[j] /= n;</span>
        }

        double d;
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">            for (j = 0; j &lt; 2; ++j) {</span>
<span class="nc" id="L1573">                d = (xy[j][i] - mS[j]);</span>
<span class="nc" id="L1574">                mS[j + 2] += (d * d);</span>
            }
        }
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        for (j = 2; j &lt; 4; ++j) {</span>
<span class="nc" id="L1578">            mS[j] = Math.sqrt(mS[j]/(n - 1.0));</span>
        }

<span class="nc" id="L1581">        double[][] t = new double[3][];</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">        for (int row = 0; row &lt; 2; ++row) {</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            if (mS[row + 2] == 0.) {</span>
                // std is 0 for row
<span class="nc" id="L1585">                System.out.println(&quot;WARNING: standard deviation of row &quot; + row</span>
                        + &quot; was 0, so consider using another normalization &quot; +
                        &quot;method like min-max instead&quot;);
<span class="nc" id="L1588">                t[row] = new double[]{1., 0, -mS[row]};</span>
            } else {
<span class="nc" id="L1590">                t[row] = new double[]{1. / mS[row + 2], 0, -mS[row] / mS[row + 2]};</span>
            }
        }
<span class="nc" id="L1593">        t[2] = new double[]{0,           0,           1};</span>

<span class="nc" id="L1595">        double[] chk = MatrixUtil.multiplyMatrixByColumnVector(t, MatrixUtil.extractColumn(xy, 0));</span>

<span class="nc" id="L1597">        double[][] xyN = MatrixUtil.multiply(t, xy);</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L1599">            System.arraycopy(xyN[i], 0, xy[i], 0, xyN[i].length);</span>
        }
<span class="nc" id="L1601">        return mS;</span>
    }

    /**
     * create 2 scale and translation matrices to normalize homogeneous 2D coordinates
     * by multiplying on the left side, and to de-normalize the normalized
     * coordinates by multiplying on the left side.
     * The normalization matrix transforms x by (x - centroidX)/scale and similarly transforms y.
     * The de-normalization matrix can be used to multiply by scale and add the centroid.
     * @param scale
     * @param centroidX
     * @param centroidY
     * @return
     */
    protected static NormalizationTransformations createScaleTranslationMatrices(
        double scale,
        double centroidX, double centroidY) {

<span class="pc bpc" id="L1619" title="1 of 2 branches missed.">        if (scale == 0.) {</span>
<span class="nc" id="L1620">            System.out.println(&quot;WARNING: scale == 0.  Changing scale to 1.0 for matrix transformations.&quot;);</span>
<span class="nc" id="L1621">            scale = 1.0;</span>
        }
        
        /*
        scale, rotate, then translate.
        let xc = x centroid
        let yc = y centroid
        let sX = scaleFactor in x
        let sY = scaleFactor in y
            here, sX = sY
        let r = rotation
            here, rotation = 0, so math.cos(0)=1, math.sin(0)=0
        let tX = x translation
            here, tX = -xc*sX
        let tY = y translation
            here, tY = -yc*sY

        transformation equations for x are for translating the points to the
        centroid, then scaling them
           x_transformed = xc*s + ((x - xc)*s) + tX = x*s - xc*s
           y_transformed = yc*s + ((y - yc)*s) + tY = y*s - yc*s

        matrix for xy matrix has format xy[row][col]
            where row=0 is x and row=1 is y, and row=2 is placeholder of value 1
        x[0]  x[1]  x[2]  x[3]
        y[0]  y[1]  y[2]  y[3]
        1      1      1     1

        t * xy = transformed xy

        to reverse the operation, that is de-normalize, need division by scale, 
        then addition of centroid    
        
        Revisiting Hartley’s Normalized Eight-Point Algorithm
        Chojnacki et al. 2003

        inverse changes the order of operations,
        inverse translation matrix: inverse changes the signs of the translation elements,
                but not the diagonal.
        inverse rotation matrix: inverse is the transpose of rotation matrix.
        inverse scaling matrix: inverse is performed on each element, that is, the reciprocal.

        denormalized x2 = transpose(normalized x2) * transpose(T2^1)
        denormalized x1 = (T1^-1) * (normalized x1)
        denormalized FM = transpose(T2) * FM_normalized * T1

                | 1/s   0  0 |   | 1  0  -xc |
            T = |  0  1/s  0 | * | 0  1  -yc |
                |  0    0  1 |   | 0  0   1  |
        */

<span class="fc" id="L1672">        double[][] t = new double[3][];</span>
<span class="fc" id="L1673">        t[0] = new double[]{1./scale,       0,     -centroidX/scale};</span>
<span class="fc" id="L1674">        t[1] = new double[]{0,           1./scale, -centroidY/scale};</span>
<span class="fc" id="L1675">        t[2] = new double[]{0,           0,           1};</span>

<span class="fc" id="L1677">        double[][] d = new double[3][];</span>
<span class="fc" id="L1678">        d[0] = new double[]{scale,       0,     centroidX};</span>
<span class="fc" id="L1679">        d[1] = new double[]{0,           scale, centroidY};</span>
<span class="fc" id="L1680">        d[2] = new double[]{0,           0,           1};</span>
        
<span class="fc" id="L1682">        NormalizationTransformations nt = new NormalizationTransformations();</span>
<span class="fc" id="L1683">        nt.t = t;</span>
<span class="fc" id="L1684">        nt.tDenorm = d;</span>
        
<span class="fc" id="L1686">        return nt;</span>
    }
    
    /**
     * 
     * @param normalizedFundamentalMatrix the normalized fundamental matrix, that is the solution for
     * the fundamental matrix using the normalized correspondence.
     * @param leftNT the transformations created for normalization and de-normalization
     * of the left image coordinates.
     * @param rightNT the transformations created for normalization and de-normalization
     * of the right image coordinates.
     * 
     * @return 
     */
    public static DenseMatrix denormalizeTheFundamentalMatrix(
        DenseMatrix normalizedFundamentalMatrix,
        NormalizationTransformations leftNT, NormalizationTransformations rightNT) {

        //NOTE: denormalized x2 = transpose(normalized x2) * transpose(T2^1)
        //      denormalized x1 = (T1^-1) * (normalized x1)
        //      denormalized FM = transpose(T2) * FM_normalized * T1

<span class="fc" id="L1708">        DenseMatrix t2T = new DenseMatrix(MatrixUtil.transpose(rightNT.t));</span>

<span class="fc" id="L1710">        DenseMatrix t1 = new DenseMatrix(leftNT.t);</span>

<span class="fc" id="L1712">        DenseMatrix denormFundamentalMatrix =</span>
<span class="fc" id="L1713">            MatrixUtil.multiply(t2T,</span>
<span class="fc" id="L1714">                    MatrixUtil.multiply(normalizedFundamentalMatrix, t1));</span>
        
<span class="fc" id="L1716">        double factor = 1./(denormFundamentalMatrix.get(2, 2) + eps);</span>
<span class="fc" id="L1717">        MatrixUtil.multiply(denormFundamentalMatrix, factor);</span>

<span class="fc" id="L1719">        return denormFundamentalMatrix;</span>
    }

    /**
     * a = xLeft ⊗ xRight
     * @param normXY1 a matrix of size 3 x nPoints, where 1st row is x,
     * second is y.
     * @param normXY2 a matrix of size 3 x nPoints, where 1st row is x,
     * second is y.
     * @return fundamental matrix of size [nPoints x 9]
     */
    public static double[][] createKroneckerDesignMatrix(DenseMatrix normXY1,
                                           DenseMatrix normXY2) {

<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">        if (normXY1 == null) {</span>
<span class="nc" id="L1734">            throw new IllegalArgumentException(&quot;normXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">        if (normXY2 == null) {</span>
<span class="nc" id="L1737">            throw new IllegalArgumentException(&quot;normXY2 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">        if (normXY1.numColumns() != normXY2.numColumns()) {</span>
<span class="nc" id="L1740">            throw new IllegalArgumentException(</span>
            &quot;the number of columns in normXY1 != number of cols in normXY2&quot;);
        }

<span class="fc" id="L1744">        int nXY1 = normXY1.numColumns();</span>

        /*
        (2) each row in matrix A:
            x_1*x_2,  x_1*y_2,  x_1,  y_1*x_2,  y_1*y_2,  y_1,  x_2,  y_2,  1
        */
        double x1, x2, y1, y2;
<span class="fc" id="L1751">        double[][] a = new double[nXY1][9];</span>
<span class="fc bfc" id="L1752" title="All 2 branches covered.">        for (int i = 0; i &lt; nXY1; i++) {</span>
<span class="fc" id="L1753">            a[i] = new double[9];</span>
<span class="fc" id="L1754">            x1 = normXY1.get(0, i);</span>
<span class="fc" id="L1755">            x2 = normXY2.get(0, i);</span>
<span class="fc" id="L1756">            y1 = normXY1.get(1, i);</span>
<span class="fc" id="L1757">            y2 = normXY2.get(1, i);</span>
<span class="fc" id="L1758">            a[i][0] = x1 * x2;</span>
<span class="fc" id="L1759">            a[i][1] = x1 * y2;</span>
<span class="fc" id="L1760">            a[i][2] = x1;</span>
<span class="fc" id="L1761">            a[i][3] = y1 * x2;</span>
<span class="fc" id="L1762">            a[i][4] = y1 * y2;</span>
<span class="fc" id="L1763">            a[i][5] = y1;</span>
<span class="fc" id="L1764">            a[i][6] = x2;</span>
<span class="fc" id="L1765">            a[i][7] = y2;</span>
<span class="fc" id="L1766">            a[i][8] = 1;</span>
        }

<span class="fc" id="L1769">        return a;</span>
    }

    /**
     * a = xLeft ⊗ xRight
     * @param normXY1 a matrix of size 3 x nPoints, where 1st row is x,
     * second is y.
     * @param normXY2 a matrix of size 3 x nPoints, where 1st row is x,
     * second is y.
     * @return fundamental matrix of size [nPoints x 9]
     */
    double[][] createDesignMatrix(double[][] normXY1,
                                  double[][] normXY2) {

<span class="pc bpc" id="L1783" title="1 of 2 branches missed.">        if (normXY1 == null) {</span>
<span class="nc" id="L1784">            throw new IllegalArgumentException(&quot;normXY1 cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">        if (normXY2 == null) {</span>
<span class="nc" id="L1787">            throw new IllegalArgumentException(&quot;normXY2 cannot be null&quot;);</span>
        }
<span class="fc" id="L1789">        int nXY1 = normXY1[0].length;</span>
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">        if (nXY1 != normXY2[0].length) {</span>
<span class="nc" id="L1791">            throw new IllegalArgumentException(</span>
                    &quot;the number of columns in normXY1 != number of cols in normXY2&quot;);
        }

        /*
        [nx9]
        (2) each row in matrix A:
            x_1*x_2,  x_1*y_2,  x_1,  y_1*x_2,  y_1*y_2,  y_1,  x_2,  y_2,  1
        */
        double x1, x2, y1, y2;
<span class="fc" id="L1801">        double[][] a = new double[nXY1][9];</span>
<span class="fc bfc" id="L1802" title="All 2 branches covered.">        for (int i = 0; i &lt; nXY1; i++) {</span>
<span class="fc" id="L1803">            a[i] = new double[9];</span>
<span class="fc" id="L1804">            x1 = normXY1[0][i];</span>
<span class="fc" id="L1805">            x2 = normXY2[0][i];</span>
<span class="fc" id="L1806">            y1 = normXY1[1][i];</span>
<span class="fc" id="L1807">            y2 = normXY2[1][i];</span>
<span class="fc" id="L1808">            a[i][0] = x1 * x2;</span>
<span class="fc" id="L1809">            a[i][1] = x1 * y2;</span>
<span class="fc" id="L1810">            a[i][2] = x1;</span>
<span class="fc" id="L1811">            a[i][3] = y1 * x2;</span>
<span class="fc" id="L1812">            a[i][4] = y1 * y2;</span>
<span class="fc" id="L1813">            a[i][5] = y1;</span>
<span class="fc" id="L1814">            a[i][6] = x2;</span>
<span class="fc" id="L1815">            a[i][7] = y2;</span>
<span class="fc" id="L1816">            a[i][8] = 1;</span>
        }

<span class="fc" id="L1819">        return a;</span>
    }

    /**
     * calculate the epipoles of the fundamental matrix and return them as
     * an array with left epipole in column 0 and right epipole in column 1.
     *Epipolar Plane:
     *       An epipolar plane is defined by the principal points o1, and o2 of the cameras and the point p.
     *    Epipoles:
     *       In the epipolar plane, the point where the camera principal point intersects it image is the
     *       epipole.  The location of the epipole in the other image can be thought of as the projection
     *       of the other camera center onto its image.
     *       (the epipole can lie outside the image boundaries).
     *       e1 = right nullspace of FM = SVD(fm).V[*,2].
     *       e2 = left nullspace of FM = SVD(fm).U[*,2].
     *         e2^T*E = 0.
     *         E*e1 = 0.
     *         this method returns e1 and e2 divided by their last columns.
     *         for the essential matrix: e2 ~ T and e1 ~ R*T up to a scalar factor.

     * @param fundamentalMatrix
     * @return a matrix holding whose first row holds e1 and 2nd row holds e2
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public static double[][] calculateEpipoles(DenseMatrix fundamentalMatrix) {

        /*
        A is mxn=[3x3].  U is [mxm=3x3], V is [nxn=3x3]
        NOTE:
            SVD(A).U == SVD(A^T).V == SVD(AA^T).U == SVD(AA^T).V
            SVD(A).V == SVD(A^T).U == SVD(A^TA).V == SVD(A^TA).U
        
        epipoles:
             [U,D,V] = svd(denormalized FundamentalMatrix);
             e1 = last column of V divided by its last item.  right nullspace.
             e2 = last column of U divided by its last item.  left nullspace.

        e2 when normalized by 3rd coord is in coord space of left image and
               it is the location of the right camera center.
        */
             
<span class="fc" id="L1860">        SVD svdE = null;</span>
        try {
<span class="fc" id="L1862">            svdE = SVD.factorize(fundamentalMatrix);</span>
<span class="nc" id="L1863">        } catch (NotConvergedException e) {</span>
<span class="nc" id="L1864">            Logger.getLogger(EpipolarTransformer.class.getName()).log(Level.SEVERE, null, e);</span>
<span class="nc" id="L1865">            return null;</span>
<span class="fc" id="L1866">        }</span>

        // left nullspace
<span class="fc" id="L1869">        double[] e2 = new double[3];</span>
<span class="fc" id="L1870">        double e2Div = svdE.getU().get(2, 2);</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">        for (int i = 0; i &lt; e2.length; i++) {</span>
<span class="fc" id="L1872">            e2[i] = svdE.getU().get(i, 2)/e2Div;</span>
        }

        //right nullspace
<span class="fc" id="L1876">        double[] e1 = new double[3];</span>
<span class="fc" id="L1877">        double e1Div = svdE.getVt().get(2, 2);</span>
<span class="fc bfc" id="L1878" title="All 2 branches covered.">        for (int i = 0; i &lt; e1.length; i++) {</span>
<span class="fc" id="L1879">            e1[i] = svdE.getVt().get(2, i)/e1Div;</span>
        }

<span class="fc" id="L1882">        double[][] e = new double[2][];</span>
<span class="fc" id="L1883">        e[0] = e1;</span>
<span class="fc" id="L1884">        e[1] = e2;</span>

<span class="fc" id="L1886">        return e;</span>
    }
    
    /**
     * convert the fundamental matrix into the essential matrix.
     * @param k1 camera 1 intrinsics matrix.
     * @param k2 camera 2 intrinsics matrix.
     * @param fm the fundamental matrix in the reference frame of the original image space
     * of pixel coordinates.
     * @return the essential matrix in the reference frame of normalized image
     * coordinates (origin is optical center of the image).
     */
    public static double[][] createEssentialFromFundamentalMatrix(
        double[][] k1, double[][] k2, double[][] fm) throws NotConvergedException {
        
        // E = K2^T * F * K1
        //   then SVD(E) to reform E:
        //   E = U * [1 0 0] * V^T
        //           [0 1 0]
        //           [0 0 0]
<span class="nc" id="L1906">        double[][] k2T = MatrixUtil.transpose(k2);</span>
        
<span class="nc" id="L1908">        double[][] em = MatrixUtil.multiply(k2T, fm);</span>
<span class="nc" id="L1909">        em = MatrixUtil.multiply(em, k1);</span>
        
<span class="nc" id="L1911">        System.out.printf(&quot;E before:\n%s\n&quot;, FormatArray.toString(em, &quot;%.3e&quot;));</span>
        
<span class="nc" id="L1913">        SVDProducts svd = MatrixUtil.performSVD(new DenseMatrix(em));</span>
<span class="nc" id="L1914">        double[][] d = MatrixUtil.createIdentityMatrix(3);</span>
<span class="nc" id="L1915">        d[2][2] = 0;</span>
<span class="nc" id="L1916">        em = MatrixUtil.multiply(svd.u, d);</span>
<span class="nc" id="L1917">        em = MatrixUtil.multiply(em, svd.vT);</span>
        
<span class="nc" id="L1919">        System.out.printf(&quot;E:\n%s\n&quot;, FormatArray.toString(em, &quot;%.3e&quot;));</span>
        
<span class="nc" id="L1921">        return em;</span>
    }
    
    /**
     * convert the essential matrix into the fundamental matrix using 
     * F= K2^-T * E * K1^-1
     * @param k1 camera 1 intrinsics matrix.
     * @param k2 camera 2 intrinsics matrix.
     * @param em the essential matrix in the reference frame of normalized image
     * coordinates (origin is optical center of the image)
     * @return the fundamental matrix .
     */
    public static double[][] createFundamentalFromEssentialMatrix(
        double[][] k1, double[][] k2, double[][] em) {
        
        // F= K2^-T * E * K1^-1
<span class="nc" id="L1937">        double[][] k1Inv = Camera.createIntrinsicCameraMatrixInverse(k1);</span>
<span class="nc" id="L1938">        double[][] k2Inv = Camera.createIntrinsicCameraMatrixInverse(k2);</span>
<span class="nc" id="L1939">        double[][] k2InvT = MatrixUtil.transpose(k2Inv);</span>
        
<span class="nc" id="L1941">        double[][] fm = MatrixUtil.multiply(k2InvT, em);</span>
<span class="nc" id="L1942">        fm = MatrixUtil.multiply(fm, k1Inv);</span>
        
<span class="nc" id="L1944">        return fm;</span>
    }
    
    public static class NormalizationTransformations {
        /**
         * a normalization matrix which subtracts a centroid and divides by a scale factor
         * to each of x and y.
         * The matrix is 3X3.  can use as t*xy where xy is size 3XN.
         */
        public double[][] t = null;
        
        /**
         * a de-normalization matrix which multiplies by a scale factor and adds 
         * a centroid to each of x and y
         * to each of x and y.
         * the matrix is 3X3. can use as t*xy where xy is size 3XN.
         */
        public double[][] tDenorm = null;
    } 
    
    public static class NormalizedXY {

        /**
         * 3 dimensional matrix, with column 0 being x, column 1 being y,
         * and the last column is place holder 1's
         */
        private DenseMatrix xy = null;
        
        private NormalizationTransformations normalizationMatrices = null;

        /**
         * @return the factor
         */
        public NormalizationTransformations getNormalizationMatrices() {
            return normalizationMatrices;
        }

        /**
         * @param normMatrices holding the scale and centroid offsets to apply to x, y
         */
        public void setNormMatrices(NormalizationTransformations normMatrices) {
            this.normalizationMatrices = normMatrices;
        }

        /**
         * @return the xy
         */
        public DenseMatrix getXy() {
            return xy;
        }

        /**
         * @param xy the xy to set
         */
        public void setXy(DenseMatrix xy) {
            this.xy = xy;
        }
    }

    public PairIntArray getEpipolarLine(DenseMatrix epipolarLines, int imgWidth,
        int imgHeight, int pointNumber) {

<span class="fc" id="L2006">        int n = imgWidth/10;</span>

<span class="fc" id="L2008">        PairIntArray line = new PairIntArray(n);</span>

<span class="fc" id="L2010">        double a = epipolarLines.get(0, pointNumber);</span>
<span class="fc" id="L2011">        double b = epipolarLines.get(1, pointNumber);</span>
<span class="fc" id="L2012">        double c = epipolarLines.get(2, pointNumber);</span>
<span class="fc bfc" id="L2013" title="All 2 branches covered.">        boolean isHoriz = (Math.abs(a/b) &lt;= 1.0);</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">        if (isHoriz) {</span>
<span class="fc bfc" id="L2015" title="All 2 branches covered.">            for (int x = 0; x &lt; imgWidth; x++) {</span>
                //y = - (a/b) * x - (c/b)
<span class="fc" id="L2017">                double y = (c + (a * (double)x)) / (-b);</span>
<span class="fc" id="L2018">                line.add(x, (int) Math.round(y));</span>
            }
        } else {
<span class="fc bfc" id="L2021" title="All 2 branches covered.">            for (int y = 0; y &lt; imgHeight; y++) {</span>
                //y = - (a/b) * x - (c/b)
                //y+(c/b) = - (a/b) * x
                // ==&gt; x = (-b/a) * (y+(c/b)) = y*(-b/a) - (c/a)
<span class="fc" id="L2025">                double x = -(c + (b * (double)y))/a;</span>
<span class="fc" id="L2026">                line.add((int) Math.round(x), y);</span>
            }
        }

<span class="fc" id="L2030">        return line;</span>
    }
    
    public static DenseMatrix extractIndices(DenseMatrix m, List&lt;Integer&gt; inlierIndexes) {
<span class="fc" id="L2034">        DenseMatrix out = new DenseMatrix(m.numRows(), inlierIndexes.size());</span>
<span class="fc" id="L2035">        int r = 0;</span>
<span class="fc bfc" id="L2036" title="All 2 branches covered.">        for (int i = 0; i &lt; inlierIndexes.size(); ++i) {</span>
<span class="fc" id="L2037">            int idx = inlierIndexes.get(i);</span>
<span class="fc bfc" id="L2038" title="All 2 branches covered.">            for (int j = 0; j &lt; m.numRows(); ++j) {</span>
<span class="fc" id="L2039">                out.set(j, r, m.get(j, idx));</span>
            }
<span class="fc" id="L2041">            r++;</span>
        }
<span class="fc" id="L2043">        return out;</span>
    }

    public static double[][] extractIndices(double[][] m, List&lt;Integer&gt; inlierIndexes) {
<span class="nc" id="L2047">        double[][] out = MatrixUtil.zeros(m.length, inlierIndexes.size());</span>
<span class="nc" id="L2048">        int r = 0;</span>
        int i, j;
<span class="nc bnc" id="L2050" title="All 2 branches missed.">        for (i = 0; i &lt; inlierIndexes.size(); ++i) {</span>
<span class="nc" id="L2051">            int idx = inlierIndexes.get(i);</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">            for (j = 0; j &lt; m.length; ++j) {</span>
<span class="nc" id="L2053">                out[j][r] = m[j][idx];</span>
            }
<span class="nc" id="L2055">            r++;</span>
        }
<span class="nc" id="L2057">        return out;</span>
    }

    /**
     * if assume gaussian errors and chi-squared statistics, for 1 degree of 
     * freedom (i.e. fitting a line, fundamental matrix, d^2 = 3.84*(st.dev^2)
     * @param standardDeviation
     * @return 
     */
    public static double estimateToleranceForDOF1(double standardDeviation) {
<span class="nc" id="L2067">        double d = Math.sqrt(3.84*standardDeviation*standardDeviation);</span>
<span class="nc" id="L2068">        return d;</span>
    }
    
    /**
     * if assume gaussian errors and chi-squared statistics, for 2 degree of freedom (i.e. fitting
     * a line, fundamental matrix, d^2 = 5.99*(st.dev^2)
     * @param standardDeviation
     * @return 
     */
    public static double estimateToleranceForDOF2(double standardDeviation) {
<span class="nc" id="L2078">        double d = Math.sqrt(5.99*standardDeviation*standardDeviation);</span>
<span class="nc" id="L2079">        return d;</span>
    }
    /**
     * if assume gaussian errors and chi-squared statistics, for 2 degree of freedom (i.e. fitting
     * a line, fundamental matrix, d^2 = 7.82*(st.dev^2)
     * @param standardDeviation
     * @return 
     */
    public static double estimateToleranceForDOF3(double standardDeviation) {
<span class="nc" id="L2088">        double d = Math.sqrt(7.82*standardDeviation*standardDeviation);</span>
<span class="nc" id="L2089">        return d;</span>
    }
    
    private String _toString(DenseMatrix a, String decimalFormat) {
<span class="nc" id="L2093">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">        for (int i = 0; i &lt; a.numRows(); ++i) {</span>
<span class="nc bnc" id="L2095" title="All 2 branches missed.">            for (int j = 0; j &lt; a.numColumns(); ++j) {</span>
<span class="nc" id="L2096">                sb.append(String.format(decimalFormat, a.get(i, j)));</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">                if (j &lt; (a.numColumns() - 1)) {</span>
<span class="nc" id="L2098">                    sb.append(&quot;, &quot;);</span>
                }
            }
<span class="nc" id="L2101">            sb.append(&quot;\n&quot;);</span>
        }
<span class="nc" id="L2103">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
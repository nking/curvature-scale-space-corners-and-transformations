<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Distances.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Distances.java</span></div><h1>Distances.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.imageProcessing.features.FeatureComparisonStat;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.matrix.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.misc.MiscMath0;
import algorithms.util.FormatArray;
import algorithms.util.PairFloatArray;
import gnu.trove.list.TIntList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;

/**
 *
 * @author nichole
 */
<span class="fc" id="L23">public class Distances {</span>

<span class="fc" id="L25">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L27">    private static double eps = 1e-12;</span>

    /*
    Consider the problem of computing the distance from a point (p,q) 
    to a general planar polynomial f(x,y)=0. The first order approximation of the 
    function f(x,y) about the point (p,q).
    
    
    
     */
    private EpipolarFeatureTransformationFit combineErrors(EpipolarTransformationFit distanceErrors, EpipolarFeatureTransformationFit featureErrors) {

        /*
        in order to have the distance errors count as much as the SSD errors,
        need to scale them up or SSD down by a factor.

        will use the descriptor size and the average of the maximum SSD that
        could be calculated and the minimum and make a factor for the
        distances of SSDFactor/tolerance.
         */
        // sum square diffs / size = (d0*d0) + (d3*d3).../n
<span class="nc" id="L48">        double maxSSD = 255. * 255.;</span>

<span class="nc" id="L50">        double distScaleFactor = (maxSSD / 2.) / distanceErrors.getTolerance();</span>

<span class="nc" id="L52">        Map&lt;Integer, Double&gt; indexSSDErrorsMap = new HashMap&lt;Integer, Double&gt;();</span>
<span class="nc" id="L53">        Map&lt;Integer, FeatureComparisonStat&gt; indexFeatureMap</span>
                = new HashMap&lt;Integer, FeatureComparisonStat&gt;();
<span class="nc bnc" id="L55" title="All 2 branches missed.">        for (int i = 0; i &lt; featureErrors.getInlierIndexes().size(); ++i) {</span>
<span class="nc" id="L56">            Integer index = featureErrors.getInlierIndexes().get(i);</span>
<span class="nc" id="L57">            indexSSDErrorsMap.put(index, featureErrors.getErrors().get(i));</span>
<span class="nc" id="L58">            indexFeatureMap.put(index,</span>
<span class="nc" id="L59">                    featureErrors.getFeatureComparisonStats().get(i));</span>
        }

<span class="nc" id="L62">        List&lt;Integer&gt; outputInliers = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L63">        List&lt;Double&gt; outputDistances = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L64">        List&lt;FeatureComparisonStat&gt; fcs = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (int i = 0; i &lt; distanceErrors.getInlierIndexes().size(); ++i) {</span>
<span class="nc" id="L67">            Integer index = distanceErrors.getInlierIndexes().get(i);</span>
<span class="nc" id="L68">            Double ssd = indexSSDErrorsMap.get(index);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (ssd != null) {</span>

<span class="nc" id="L71">                outputInliers.add(index);</span>

<span class="nc" id="L73">                Double dist = distanceErrors.getErrors().get(i);</span>
<span class="nc" id="L74">                double cost = dist.doubleValue() * ssd.doubleValue();</span>
<span class="nc" id="L75">                outputDistances.add(Double.valueOf(cost));</span>

<span class="nc" id="L77">                fcs.add(indexFeatureMap.get(index));</span>
            }
        }
<span class="nc" id="L80">        double costTerm2 = 1. / (double) outputDistances.size();</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (int i = 0; i &lt; outputDistances.size(); ++i) {</span>
<span class="nc" id="L82">            double err = outputDistances.get(i).doubleValue() * costTerm2 * costTerm2</span>
                    * distScaleFactor;
<span class="nc" id="L84">            outputDistances.set(i, Double.valueOf(err));</span>
        }

<span class="nc" id="L87">        EpipolarFeatureTransformationFit fit</span>
                = new EpipolarFeatureTransformationFit(
<span class="nc" id="L89">                        distanceErrors.getFundamentalMatrix(),</span>
                        outputInliers, fcs,
<span class="nc" id="L91">                        distanceErrors.getErrorType(), outputDistances,</span>
<span class="nc" id="L92">                        distanceErrors.getTolerance());</span>

<span class="nc" id="L94">        return fit;</span>
    }

    /**
     * evaluate fit for the distances of each correspondence point to the
     * epipolar line for it projected from it's pair in the other image.
      Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of 
     different methods and experimental results&quot;
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param threshhold
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError(
            DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
            double threshhold) {

<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L116">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L124">        int nRows = leftPoints.numRows();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="nc" id="L130">        double[][] distances = calculateDistancesFromEpipolar(fm,</span>
            leftPoints, rightPoints);

<span class="nc" id="L133">        double[] combinedDist = combineDistances(distances);</span>
                        
<span class="nc" id="L135">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L137">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (int i = 0; i &lt; combinedDist.length; ++i) {</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (combinedDist[i] &gt; threshhold) {</span>
<span class="nc" id="L142">                continue;</span>
            }

<span class="nc" id="L145">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L147">            errors.add(Double.valueOf(combinedDist[i]));</span>
        }

<span class="nc" id="L150">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L153">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, errors, threshhold);
        } else {
<span class="nc" id="L156">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), threshhold);
        }

<span class="nc" id="L160">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="nc" id="L162">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L164">        return fit;</span>
    }
    
    /**
     * For use upon data that have been unit normal standardized.
     * evaluate fit for already matched point lists
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param threshhold
     * @return
     */
    public EpipolarTransformationFit calculateSampsonsError(
            DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
            double threshhold) {

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L184">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L187">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L190">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L192">        int nRows = leftPoints.numRows();</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L194">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

<span class="fc" id="L197">        double[] distSquared = calculateEpipolarSampsonsDistanceSquared(fm, </span>
            leftPoints, rightPoints);

<span class="fc" id="L200">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L202">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

        double d;
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (int i = 0; i &lt; distSquared.length; ++i) {</span>

<span class="fc" id="L207">            d = Math.sqrt(distSquared[i]);</span>
            
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (d &gt; threshhold) {</span>
<span class="nc" id="L210">                continue;</span>
            }

<span class="fc" id="L213">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="fc" id="L215">            errors.add(d);</span>
        }

<span class="fc" id="L218">        EpipolarTransformationFit fit = null;</span>

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="fc" id="L221">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.SAMPSONS, errors, threshhold);
        } else {
<span class="nc" id="L224">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.SAMPSONS, new ArrayList&lt;Double&gt;(), threshhold);
        }

<span class="fc" id="L228">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="fc" id="L230">        fit.calculateErrorStatistics();</span>

<span class="fc" id="L232">        return fit;</span>
    }
    
    /**
     * given the fundamental matrix solution and the correspondence pairs,
     * use the Luong et al. 1993 distance for each correspondence pair as
     * the closest distance of a point from the projected epipolar line of
     * its pair.   The standard deviation of the errors,
     * and the chi-squared statistic factor are used to remove
     * outliers and return the results.
      Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of 
      different methods and experimental results&quot;.
      NOTE: there may be other references for this method.
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param chiSquaredStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError2(
            DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
            double chiSquaredStatFactor) {

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L262">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L265">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L267">        int nRows = leftPoints.numRows();</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L269">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="fc" id="L273">        double[][] distances = calculateDistancesFromEpipolar(fm,</span>
            leftPoints, rightPoints);
        
<span class="fc" id="L276">        double[] combinedDist = combineDistances(distances);</span>
        
<span class="fc" id="L278">        double[] meanAndStDev = MiscMath.getAvgAndStDev(combinedDist);</span>
        
<span class="fc" id="L280">        double t = chiSquaredStatFactor * meanAndStDev[1];</span>
        
<span class="fc" id="L282">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L284">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (int i = 0; i &lt; combinedDist.length; ++i) {</span>

<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if (combinedDist[i] &gt; t) {</span>
<span class="nc" id="L289">                continue;</span>
            }

<span class="fc" id="L292">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="fc" id="L294">            errors.add(combinedDist[i]);</span>
        }

<span class="fc" id="L297">        EpipolarTransformationFit fit = null;</span>

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="fc" id="L300">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, errors, t);
        } else {
<span class="nc" id="L303">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), t);
        }

<span class="fc" id="L307">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="fc" id="L309">        fit.calculateErrorStatistics();</span>

<span class="fc" id="L311">        return fit;</span>
    }
    
    /**
     * given rectified correspondence pairs in x1, x2, calculate the
     * square root of the sum of squares of the differences in the
     * y coordinates, or both x and y if useXToo is true.
     * Also uses MAD or Tukey fences to determine inliers.
     * 
     * @param x1 the image 1 set of correspondence points. format is 3 x N
     * where N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points) since
     * internally an identity matrix is used for K.
     * @param x2 the image 2 set of correspondence points. format is 3 x N where
     * N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points).
     * @param outErrors array of length x1[0].length to be used to return each
     * error as the square root of the sum of differences between each x1 and x2.
     * @param outInlierIndexes indexes of points which are within the robust 
     * statistics range for inliers (defined as not being outliers).
     * @param useXToo if true, the errors are not only the differences between the
     * y coordinates of x1 and x2, but also the x-xoordinates of x1 and x2.
     * @return square root of the sum of squared errors
     */
    public static double calculateRectificationErrors(
    double[][] x1, double[][] x2,
    double[] outErrors, TIntList outInlierIndexes, boolean useXToo) {
        
<span class="fc" id="L341">        int n = x1[0].length;</span>
<span class="pc bpc" id="L342" title="3 of 4 branches missed.">        if (x1.length !=3 &amp;&amp; x1.length != 2) {</span>
<span class="nc" id="L343">            throw new IllegalArgumentException(&quot;x1.length must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L345" title="3 of 4 branches missed.">        if (x2.length !=3 &amp;&amp; x2.length != 2) {</span>
<span class="nc" id="L346">            throw new IllegalArgumentException(&quot;x2.length  must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L349">            throw new IllegalArgumentException(&quot;x2 must be size 3Xn and the same as size of x1&quot;);</span>
        }
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (outErrors.length !=n) {</span>
<span class="nc" id="L352">            throw new IllegalArgumentException(&quot;outErrors.length  must be n&quot;);</span>
        }
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (outInlierIndexes == null) {</span>
<span class="nc" id="L355">            throw new IllegalArgumentException(&quot;outInlierIndexes cannot be null&quot;);</span>
        }
        double diff;
<span class="fc" id="L358">        double sum = 0;</span>
        double sumI;
        int i;
<span class="fc bfc" id="L361" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L362">            diff = x1[1][i] - x2[1][i];</span>
<span class="fc" id="L363">            sumI = diff*diff;</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            if (useXToo) {</span>
<span class="nc" id="L365">                diff = x1[0][i] - x2[0][i];</span>
<span class="nc" id="L366">                sumI += diff*diff;</span>
            }
<span class="fc" id="L368">            sum += sumI;</span>
<span class="fc" id="L369">            outErrors[i] = Math.sqrt(sumI);</span>
        }
<span class="fc" id="L371">        sum = Math.sqrt(sum);</span>
        
        // use MAD or Tukey fences
                
        //median of absolute deviation of x, median, min, and max.
<span class="fc" id="L376">        double[] mADMinMax = MiscMath0.calculateMedianOfAbsoluteDeviation(outErrors);</span>
<span class="fc" id="L377">        double kMAD = 1.4826;</span>
<span class="fc" id="L378">        double s = kMAD*mADMinMax[0];</span>
<span class="fc" id="L379">        double r0 = mADMinMax[1] - 3*s;</span>
<span class="fc" id="L380">        double r1 = mADMinMax[1] + 3*s;</span>
        
<span class="fc" id="L382">        int[] inliers2 = MiscMath0.findInliersUsingTukeyFences(outErrors);</span>
        
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L385">            diff = outErrors[i];</span>
<span class="pc bpc" id="L386" title="2 of 4 branches missed.">            if (diff &gt;= r0 &amp;&amp; diff &lt;= r1) {</span>
<span class="fc" id="L387">                outInlierIndexes.add(i);</span>
            }
        }
        
<span class="fc" id="L391">        System.out.printf(&quot;inliers using MAD=\n%s\ninliers using Tukey fences=\n%s\n&quot;, </span>
<span class="fc" id="L392">            Arrays.toString(outInlierIndexes.toArray()),</span>
<span class="fc" id="L393">            Arrays.toString(inliers2));</span>
        
<span class="fc" id="L395">        return sum;</span>
    }
    
    /**
     * For use upon data that have been unit normal standardized.
     * given the fundamental matrix solution and the correspondence pairs,
     * use the Sampson distance as an error for each correspondence pair, then use
     * the standard deviation of the errors,
     * and the chi-squared statistic factor to remove
     * outliers and return the results.
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param chiSquaredStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateSampsonsError2(
        DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
        double chiSquaredStatFactor) {

<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L419">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L425">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L427">        int nRows = leftPoints.numRows();</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L429">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        // dist^2:
<span class="fc" id="L433">        double[] dist = calculateEpipolarSampsonsDistanceSquared(fm, </span>
            leftPoints, rightPoints);
<span class="fc bfc" id="L435" title="All 2 branches covered.">        for (int i = 0; i &lt; dist.length; ++i) {</span>
<span class="fc" id="L436">            dist[i] = Math.sqrt(dist[i]);</span>
        }
        
<span class="fc" id="L439">        double[] meanAndStDev = MiscMath.getAvgAndStDev(dist);</span>
        
<span class="fc" id="L441">        double t = chiSquaredStatFactor * meanAndStDev[1];</span>
        
        //System.out.printf(&quot;t=%.3e\n&quot;, t);

<span class="fc" id="L445">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L447">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

        double d;
<span class="fc bfc" id="L450" title="All 2 branches covered.">        for (int i = 0; i &lt; dist.length; ++i) {</span>

<span class="fc" id="L452">            d = dist[i];</span>
            
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (d &gt; t) {</span>
<span class="fc" id="L455">                continue;</span>
            }

<span class="fc" id="L458">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="fc" id="L460">            errors.add(d);</span>
        }

<span class="fc" id="L463">        EpipolarTransformationFit fit = null;</span>

<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="fc" id="L466">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                ErrorType.SAMPSONS, errors, t);
        } else {
<span class="nc" id="L469">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                ErrorType.SAMPSONS, new ArrayList&lt;Double&gt;(), t);
        }

<span class="fc" id="L473">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="fc" id="L475">        fit.calculateErrorStatistics();</span>

<span class="fc" id="L477">        return fit;</span>
    }
    
    /**
     * find the distance of the given points from their respective projected
     * epipolar lines.
     Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of 
     different methods and experimental results&quot;
     
     * @param fm
     * @param matchedLeftPoints points from left image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @param matchedRightPoints points from right image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @return array of size[2][matchedLeftPoints.numColumns()]
     */
    public double[][] calculateDistancesFromEpipolar(
        DenseMatrix fm, DenseMatrix matchedLeftPoints,
        DenseMatrix matchedRightPoints) {

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L498">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if (matchedLeftPoints == null) {</span>
<span class="nc" id="L501">            throw new IllegalArgumentException(&quot;matchedLeftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (matchedRightPoints == null) {</span>
<span class="nc" id="L504">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L506">        int nRows = matchedLeftPoints.numRows();</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if (nRows != matchedRightPoints.numRows()) {</span>
<span class="nc" id="L508">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        /*
        u_2^T * F * u_1 = 0  where u are the x,y points in images _1 and _2
        u_1 = (x_1, y_1, 1)^T
        u_2 = (x_2, y_2, 1)^T
         */
<span class="fc" id="L516">        int n = matchedLeftPoints.numColumns();</span>

<span class="fc" id="L518">        double[][] distances = new double[2][n];</span>
<span class="fc" id="L519">        distances[0] = new double[n];</span>
<span class="fc" id="L520">        distances[1] = new double[n];</span>

        // F * u_1 = 3 x n
<span class="fc" id="L523">        DenseMatrix rightEpipolarLines = MatrixUtil.multiply(fm, matchedLeftPoints);</span>

        // F^T * u_2
<span class="fc" id="L526">        DenseMatrix leftEpipolarLines = MatrixUtil.multiply(</span>
<span class="fc" id="L527">            algorithms.matrix.MatrixUtil.transpose(fm),</span>
            matchedRightPoints);

<span class="fc" id="L530">        float[] output = new float[2];</span>

<span class="fc bfc" id="L532" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedLeftPoints.numColumns(); i++) {</span>

<span class="fc" id="L534">            calculatePerpDistFromLines(matchedLeftPoints, matchedRightPoints,</span>
                rightEpipolarLines, leftEpipolarLines,
                i, i, output);

<span class="fc" id="L538">            distances[0][i] = output[0];</span>
<span class="fc" id="L539">            distances[1][i] = output[1];</span>
        }

<span class="fc" id="L542">        return distances;</span>
    }
    
    /**
     * For use upon data that have been unit normal standardized.
     Sampson's distance measures the distance between a correspondence pair
     and its Sampson correction (Torr and Zissermann, 1997).
     Torr &amp; Murray 1997 describe the Sampson distance further:
     &quot;it represents the sum of squares of the algebraic residuals divided by 
     their standard deviations&quot; and provides a first order fit to the 
     Kendall &amp; Stuart (1983) minimization of the orthogonal distance of each 
     point to a curve/surface of the maximum likelihood solution. 
     * 
     perpendicular geometric distances...
     &lt;pre&gt;
     implemented from eqn 11 from Fathy, Husseina, &amp; Tolbaa, 2017
     &quot;Fundamental Matrix Estimation: A Study of Error Criteria&quot;
     https://arxiv.org/pdf/1706.07886.pdf
     which references Torr and Zisserman 1997, 
     Machine Vision and Applications 9 (5), 321–333,
     &quot; Performance characterization of fundamental matrix estimation under image 
     degradation&quot;
     
     &lt;/pre&gt;
     * @param fm
     * @param x1 points from left image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @param x2 points from right image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @return double array of length [n]
     */
    public double[] calculateEpipolarSampsonsDistanceSquared(
        DenseMatrix fm, DenseMatrix x1, DenseMatrix x2) {

<span class="fc" id="L576">        int m = fm.numRows();</span>
<span class="fc" id="L577">        int n = x1.numColumns();</span>
<span class="pc bpc" id="L578" title="2 of 4 branches missed.">        if (m != 3 || fm.numColumns() != 3) {</span>
<span class="nc" id="L579">            throw new IllegalArgumentException(&quot;fm must be 3x3&quot;);</span>
        }
<span class="pc bpc" id="L581" title="2 of 4 branches missed.">        if (x1.numRows() != 3 || x2.numRows() != 3) {</span>
<span class="nc" id="L582">            throw new IllegalArgumentException(&quot;x1 and x2 must have 3 rows&quot;);</span>
        }
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (x2.numColumns() != n) {</span>
<span class="nc" id="L585">            throw new IllegalArgumentException(&quot;x1 and x2 must have the same number of columns&quot;);</span>
        }
        
        /*
        R_i = u2_i^T * F * u1_i
        
        line2_i = F * u1_i = (a2_i, b2_i, c2_i)
        
        line1_i = F^T * u2_i = (a1_i, b1_i, c1_i)
        
        (dist_i)^2 = (R_i)^2 / ( (a1_i)^2 + (b1_i)^2 + (a2_i)^2 + (b2_i)^2 ) 
        */
        
<span class="fc" id="L598">        double[] distances = new double[n];</span>

        // 3 x n.  left points projected onto right image
<span class="fc" id="L601">        DenseMatrix fX1 = MatrixUtil.multiply(fm, x1);</span>

        // 3 X n.  right points projected onto left image
<span class="fc" id="L604">        DenseMatrix fTX2 = MatrixUtil.multiply(algorithms.matrix.MatrixUtil.transpose(fm),</span>
            x2);
        
        /*R_i is found in (row i, col i) of the result of u2^T * F * u1                                          \\//
        &gt;&gt; x2_00  x2_10  x2_20   *  f00 f01 f02  *  x1_00  x1_01
           x2_01  x2_11  x2_21      f10 f11 f12     x1_10  x1_11
                                    f20 f21 f22     x1_20  x1_21
        
        e.g. R_0 = (x2_00*f00 + x2_10*f10 + x2_20*f20) * x1_00   
                    + (x2_00*f01 + x2_10*f11 + x2_20*f21) * x1_10
                    + (x2_00*f02 + x2_10*f12 + x2_20*f22) * x1_20
        */
<span class="fc" id="L616">        DenseMatrix r = MatrixUtil.multiply(MatrixUtil.transpose(x2), fm);</span>
<span class="fc" id="L617">        r = MatrixUtil.multiply(r, x1);</span>

        double a1, b1, c1, a2, b2, c2, denom, ri;
<span class="fc bfc" id="L620" title="All 2 branches covered.">        for (int i = 0; i &lt; x1.numColumns(); i++) {</span>
            
<span class="fc" id="L622">            a1 = fTX2.get(0, i);</span>
<span class="fc" id="L623">            b1 = fTX2.get(1, i);</span>
<span class="fc" id="L624">            c1 = fTX2.get(2, i);</span>
            
<span class="fc" id="L626">            a2 = fX1.get(0, i);</span>
<span class="fc" id="L627">            b2 = fX1.get(1, i);</span>
<span class="fc" id="L628">            c2 = fX1.get(2, i);</span>

<span class="fc" id="L630">            denom = a1*a1 + b1*b1 + a2*a2 + b2*b2;</span>

<span class="fc" id="L632">            ri = r.get(i, i);</span>
<span class="fc" id="L633">            ri *= ri;</span>
<span class="fc" id="L634">            ri /= denom;</span>
           
<span class="fc" id="L636">            distances[i] = ri;</span>
        }

<span class="fc" id="L639">        return distances;</span>
    }

    /**
     *
     * @param u1 points from left image in matrix of size 3 X nPoints. row 0 is
     * x, row 1 is y, row 2 is all 1's
     * @param u2 points from right image in matrix of size 3 X nPoints. row 0 is
     * x, row 1 is y, row 2 is all 1's
     * @param fu1
     * @param fTu2
     * @param leftIdx
     * @param rightIdx
     * @param output an output variable to hold as element 0, the distance of
     * the right image point at rightIdx from from it's left epipolar line
     * projected into the right image. element 1 holds the reverse for the left
     * image point at leftIdx.
     */
    public void calculatePerpDistFromLines(DenseMatrix u1, DenseMatrix u2,
            DenseMatrix fu1, DenseMatrix fTu2,
            int leftIdx, int rightIdx, float[] output) {

        // see references for eqn (1) of within Fathy et al. 2017,
        // &quot;Fundamental Matrix Estimation: A Study of Error Criteria&quot;
<span class="fc" id="L663">        double a = fu1.get(0, leftIdx);</span>
<span class="fc" id="L664">        double b = fu1.get(1, leftIdx);</span>
<span class="fc" id="L665">        double c = fu1.get(2, leftIdx);</span>

<span class="fc" id="L667">        double aplusb = Math.sqrt((a * a) + (b * b));</span>

        //dist = (a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="fc" id="L670">        double x = u2.get(0, rightIdx);</span>
<span class="fc" id="L671">        double y = u2.get(1, rightIdx);</span>

<span class="fc" id="L673">        double d = (a * x + b * y + c) / aplusb;</span>

        // find the reverse distance by projection:
<span class="fc" id="L676">        double aRev = fTu2.get(0, rightIdx);</span>
<span class="fc" id="L677">        double bRev = fTu2.get(1, rightIdx);</span>
<span class="fc" id="L678">        double cRev = fTu2.get(2, rightIdx);</span>

<span class="fc" id="L680">        double xL = u1.get(0, leftIdx);</span>
<span class="fc" id="L681">        double yL = u1.get(1, leftIdx);</span>

<span class="fc" id="L683">        double dRev = (aRev * xL + bRev * yL + cRev)</span>
<span class="fc" id="L684">                / Math.sqrt(aRev * aRev + bRev * bRev);</span>

<span class="fc" id="L686">        output[0] = (float) dRev;</span>
<span class="fc" id="L687">        output[1] = (float) d;</span>
<span class="fc" id="L688">    }</span>

    public EpipolarTransformationFit calculateError(DenseMatrix fm,
        DenseMatrix x1, DenseMatrix x2, ErrorType errorType, double threshhold) {

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="fc" id="L694">            return calculateSampsonsError(fm, x1, x2, threshhold);</span>
        } else {
<span class="nc" id="L696">            return calculateEpipolarDistanceError(fm, x1, x2, threshhold);</span>
        }
    }
    
    /**
     * given the fundamental matrix solution and the correspondence pairs,
     * use the errorType to calculate errors for each point, then use
     * the standard deviation and the chi-squared statistic factor to remove
     * outliers and return the results.
     * 
     * @param fm
     * @param x1
     * @param x2
     * @param errorType
     * @param chiSqStatFactor
     * @return 
     */
    public EpipolarTransformationFit calculateError2(DenseMatrix fm,
            DenseMatrix x1, DenseMatrix x2, ErrorType errorType, 
            double chiSqStatFactor) {

<span class="fc bfc" id="L717" title="All 2 branches covered.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="fc" id="L718">            return calculateSampsonsError2(fm, x1, x2, chiSqStatFactor);</span>
        } else {
<span class="fc" id="L720">            return calculateEpipolarDistanceError2(fm, x1, x2, chiSqStatFactor);</span>
        }
    }
    
    /**
     * performs repmat(X(rowToTransposeAndReplicate,:)',1,3)
     * @param x matrix of size 3 X N.
     * @param rowToTransposeAndReplicate
     * @return matrix of size N X 3
     */
    private double[][] repmat3(double[][] x, int rowToTransposeAndReplicate) {
<span class="nc" id="L731">        int n = x[0].length;</span>
<span class="nc" id="L732">        double[][] out = new double[n][3];</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L734">            out[i] = new double[3];</span>
<span class="nc" id="L735">            out[i][0] = x[rowToTransposeAndReplicate][i];</span>
<span class="nc" id="L736">            out[i][1] = x[rowToTransposeAndReplicate][i];</span>
<span class="nc" id="L737">            out[i][2] = x[rowToTransposeAndReplicate][i];</span>
        }
<span class="nc" id="L739">        return out;</span>
    }
    
    /**
     * performs repmat(X(rowToReplicate,:),3,1)
     * @param x matrix of size 3XN
     * @param rowToReplicate
     * @return matrix of size 3 X N
     */
    private double[][] repmat_3(double[][] x, int rowToReplicate) {
<span class="nc" id="L749">        int n = x[0].length;</span>
<span class="nc" id="L750">        double[][] out = new double[3][n];</span>
<span class="nc" id="L751">        out[0] = Arrays.copyOf(x[rowToReplicate], x[rowToReplicate].length);</span>
<span class="nc" id="L752">        out[1] = Arrays.copyOf(out[0], out[0].length);</span>
<span class="nc" id="L753">        out[2] = Arrays.copyOf(out[0], out[0].length);</span>
<span class="nc" id="L754">        return out;</span>
    }
    
    /**
     * make an array composed of the concatenation of a, b, and c horizontally
     * as blocks of columns.
     * @param a
     * @param b
     * @param c
     * @return concatenated array of size [a.length][a[0].length + b[0].length + c[0].length]
     */
    private double[][] concatenateAsColumnBlocks(double[][] a, double[][] b, double[][] c) {
<span class="nc" id="L766">        int n0 = a[0].length;</span>
<span class="nc" id="L767">        int n1 = b[0].length;</span>
<span class="nc" id="L768">        int n2 = c[0].length;</span>
<span class="nc" id="L769">        int m = a.length;</span>
<span class="nc bnc" id="L770" title="All 4 branches missed.">        if (b.length != m || c.length != m) {</span>
<span class="nc" id="L771">            throw new IllegalArgumentException(&quot;a, b, and c must have same number of rows&quot;);</span>
        }
<span class="nc" id="L773">        int n = n0 + n1 + n2;</span>
        int j, nc;
<span class="nc" id="L775">        double[][] out = new double[m][n];</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L777">            out[i] = new double[n];</span>
<span class="nc" id="L778">            nc = 0;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">            for (j = 0; j &lt; n0; ++j) {</span>
<span class="nc" id="L780">                out[i][nc] = a[i][j];</span>
<span class="nc" id="L781">                nc++;</span>
            }
<span class="nc bnc" id="L783" title="All 2 branches missed.">            for (j = 0; j &lt; n1; ++j) {</span>
<span class="nc" id="L784">                out[i][nc] = b[i][j];</span>
<span class="nc" id="L785">                nc++;</span>
            }
<span class="nc bnc" id="L787" title="All 2 branches missed.">            for (j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L788">                out[i][nc] = c[i][j];</span>
<span class="nc" id="L789">                nc++;</span>
            }
        }
<span class="nc" id="L792">        return out;</span>
    }
    
    /**
     * make an array composed of the concatenation of a, b, and c vertically
     * as blocks of rows.
     * @param a
     * @param b
     * @param c
     * @return concatenated array of size [a.length + b.length + c.length][a[0].length]
     */
    private double[][] concatenateAsRowBlocks(double[][] a, double[][] b, double[][] c, double[][] d) {
<span class="nc" id="L804">        int m0 = a.length;</span>
<span class="nc" id="L805">        int m1 = b.length;</span>
<span class="nc" id="L806">        int m2 = c.length;</span>
<span class="nc" id="L807">        int m3 = d.length;</span>
<span class="nc" id="L808">        int n = a[0].length;</span>
<span class="nc bnc" id="L809" title="All 6 branches missed.">        if (b[0].length != n || c[0].length != n || d[0].length != n) {</span>
<span class="nc" id="L810">            throw new IllegalArgumentException(&quot;a, b, c and d must have same number of columns&quot;);</span>
        }
<span class="nc" id="L812">        int m = m0 + m1 + m2 + m3;</span>
        int i;
<span class="nc" id="L814">        double[][] out = new double[m][n];        </span>
<span class="nc" id="L815">        int mc = 0;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        for (i = 0; i &lt; m0; ++i) {</span>
<span class="nc" id="L817">            out[mc] = Arrays.copyOf(a[i], n);</span>
<span class="nc" id="L818">            mc++;</span>
        }
<span class="nc bnc" id="L820" title="All 2 branches missed.">        for (i = 0; i &lt; m1; ++i) {</span>
<span class="nc" id="L821">            out[mc] = Arrays.copyOf(b[i], n);</span>
<span class="nc" id="L822">            mc++;</span>
        }
<span class="nc bnc" id="L824" title="All 2 branches missed.">        for (i = 0; i &lt; m2; ++i) {</span>
<span class="nc" id="L825">            out[mc] = Arrays.copyOf(c[i], n);</span>
<span class="nc" id="L826">            mc++;</span>
        }
<span class="nc bnc" id="L828" title="All 2 branches missed.">        for (i = 0; i &lt; m3; ++i) {</span>
<span class="nc" id="L829">            out[mc] = Arrays.copyOf(d[i], n);</span>
<span class="nc" id="L830">            mc++;</span>
        }
        
<span class="nc" id="L833">        return out;</span>
    }
    
    /**
     * make an array composed of the concatenation of a, b, and c vertically
     * as rows.
     * @param a
     * @param b
     * @param c
     * @return concatenated array of size [4][a.length + b.length + c.length]
     */
    private double[][] concatenateAsRows(double[] a, double[] b, double[] c, double[] d) {
<span class="nc" id="L845">        int m0 = a.length;</span>
<span class="nc" id="L846">        int m1 = b.length;</span>
<span class="nc" id="L847">        int m2 = c.length;</span>
<span class="nc" id="L848">        int m3 = d.length;</span>
<span class="nc bnc" id="L849" title="All 6 branches missed.">        if (m1 != m0 || m2 != m0 || m3 != m0) {</span>
<span class="nc" id="L850">            throw new IllegalArgumentException(&quot;a, b, c and d must have same lengths&quot;);</span>
        }
<span class="nc" id="L852">        double[][] out = new double[4][m0];        </span>
<span class="nc" id="L853">        out[0] = Arrays.copyOf(a, m0);</span>
<span class="nc" id="L854">        out[1] = Arrays.copyOf(b, m0);</span>
<span class="nc" id="L855">        out[2] = Arrays.copyOf(c, m0);</span>
<span class="nc" id="L856">        out[3] = Arrays.copyOf(d, m0);</span>
        
<span class="nc" id="L858">        return out;</span>
    }

    private double[] combineDistances(double[][] distances) {
<span class="fc" id="L862">        double[] c = new double[distances[0].length];</span>
        double d;
<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (int i = 0; i &lt; distances[0].length; ++i) {</span>
<span class="fc" id="L865">            d = distances[0][i]*distances[0][i] + distances[1][i]*distances[1][i];</span>
<span class="fc" id="L866">            c[i] = Math.sqrt(d);</span>
        }
<span class="fc" id="L868">        return c;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
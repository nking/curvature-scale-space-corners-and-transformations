<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Distances.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Distances.java</span></div><h1>Distances.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.imageProcessing.features.FeatureComparisonStat;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.matrix.MatrixUtil;
import algorithms.misc.MiscMath;
import algorithms.misc.MiscMath0;
import algorithms.util.FormatArray;
import algorithms.util.PairFloatArray;
import gnu.trove.list.TIntList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import no.uib.cipr.matrix.DenseMatrix;

/**
 *
 * @author nichole
 */
<span class="fc" id="L23">public class Distances {</span>

<span class="fc" id="L25">    private Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L27">    private static double eps = 1e-12;</span>

    /*
    Consider the problem of computing the distance from a point (p,q) 
    to a general planar polynomial f(x,y)=0. The first order approximation of the 
    function f(x,y) about the point (p,q).
    
    
    
     */
    private EpipolarFeatureTransformationFit combineErrors(EpipolarTransformationFit distanceErrors, EpipolarFeatureTransformationFit featureErrors) {

        /*
        in order to have the distance errors count as much as the SSD errors,
        need to scale them up or SSD down by a factor.

        will use the descriptor size and the average of the maximum SSD that
        could be calculated and the minimum and make a factor for the
        distances of SSDFactor/tolerance.
         */
        // sum square diffs / size = (d0*d0) + (d3*d3).../n
<span class="nc" id="L48">        double maxSSD = 255. * 255.;</span>

<span class="nc" id="L50">        double distScaleFactor = (maxSSD / 2.) / distanceErrors.getTolerance();</span>

<span class="nc" id="L52">        Map&lt;Integer, Double&gt; indexSSDErrorsMap = new HashMap&lt;Integer, Double&gt;();</span>
<span class="nc" id="L53">        Map&lt;Integer, FeatureComparisonStat&gt; indexFeatureMap</span>
                = new HashMap&lt;Integer, FeatureComparisonStat&gt;();
<span class="nc bnc" id="L55" title="All 2 branches missed.">        for (int i = 0; i &lt; featureErrors.getInlierIndexes().size(); ++i) {</span>
<span class="nc" id="L56">            Integer index = featureErrors.getInlierIndexes().get(i);</span>
<span class="nc" id="L57">            indexSSDErrorsMap.put(index, featureErrors.getErrors().get(i));</span>
<span class="nc" id="L58">            indexFeatureMap.put(index,</span>
<span class="nc" id="L59">                    featureErrors.getFeatureComparisonStats().get(i));</span>
        }

<span class="nc" id="L62">        List&lt;Integer&gt; outputInliers = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L63">        List&lt;Double&gt; outputDistances = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L64">        List&lt;FeatureComparisonStat&gt; fcs = new ArrayList&lt;FeatureComparisonStat&gt;();</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (int i = 0; i &lt; distanceErrors.getInlierIndexes().size(); ++i) {</span>
<span class="nc" id="L67">            Integer index = distanceErrors.getInlierIndexes().get(i);</span>
<span class="nc" id="L68">            Double ssd = indexSSDErrorsMap.get(index);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (ssd != null) {</span>

<span class="nc" id="L71">                outputInliers.add(index);</span>

<span class="nc" id="L73">                Double dist = distanceErrors.getErrors().get(i);</span>
<span class="nc" id="L74">                double cost = dist.doubleValue() * ssd.doubleValue();</span>
<span class="nc" id="L75">                outputDistances.add(Double.valueOf(cost));</span>

<span class="nc" id="L77">                fcs.add(indexFeatureMap.get(index));</span>
            }
        }
<span class="nc" id="L80">        double costTerm2 = 1. / (double) outputDistances.size();</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (int i = 0; i &lt; outputDistances.size(); ++i) {</span>
<span class="nc" id="L82">            double err = outputDistances.get(i).doubleValue() * costTerm2 * costTerm2</span>
                    * distScaleFactor;
<span class="nc" id="L84">            outputDistances.set(i, Double.valueOf(err));</span>
        }

<span class="nc" id="L87">        EpipolarFeatureTransformationFit fit</span>
                = new EpipolarFeatureTransformationFit(
<span class="nc" id="L89">                        distanceErrors.getFundamentalMatrix(),</span>
                        outputInliers, fcs,
<span class="nc" id="L91">                        distanceErrors.getErrorType(), outputDistances,</span>
<span class="nc" id="L92">                        distanceErrors.getTolerance());</span>

<span class="nc" id="L94">        return fit;</span>
    }

    /**
     * evaluate fit for the distances of each correspondence point to the
     * epipolar line for it projected from it's pair in the other image.
      Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of 
     different methods and experimental results&quot;
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param threshhold
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError(
            DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
            double threshhold) {

<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L116">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L124">        int nRows = leftPoints.numRows();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="nc" id="L130">        double[][] distances = calculateDistancesFromEpipolar(fm,</span>
            leftPoints, rightPoints);

<span class="nc" id="L133">        double[] combinedDist = combineDistances(distances);</span>
                        
<span class="nc" id="L135">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L137">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (int i = 0; i &lt; combinedDist.length; ++i) {</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (combinedDist[i] &gt; threshhold) {</span>
<span class="nc" id="L142">                continue;</span>
            }

<span class="nc" id="L145">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L147">            errors.add(Double.valueOf(combinedDist[i]));</span>
        }

<span class="nc" id="L150">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L153">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, errors, threshhold);
        } else {
<span class="nc" id="L156">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), threshhold);
        }

<span class="nc" id="L160">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="nc" id="L162">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L164">        return fit;</span>
    }

    /**
     * evaluate fit for the distances of each correspondence point to the
     * epipolar line for it projected from it's pair in the other image.
     Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of
     different methods and experimental results&quot;
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param threshhold
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError(
            double[][] fm, double[][] leftPoints, double[][] rightPoints, double threshhold) {

<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L188">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L191">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L193">        int nRows = leftPoints.length;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (nRows != rightPoints.length) {</span>
<span class="nc" id="L195">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="nc" id="L199">        double[][] distances = calculateDistancesFromEpipolar(fm,</span>
                leftPoints, rightPoints);

<span class="nc" id="L202">        double[] combinedDist = combineDistances(distances);</span>

<span class="nc" id="L204">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L206">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">        for (int i = 0; i &lt; combinedDist.length; ++i) {</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (combinedDist[i] &gt; threshhold) {</span>
<span class="nc" id="L211">                continue;</span>
            }

<span class="nc" id="L214">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L216">            errors.add(Double.valueOf(combinedDist[i]));</span>
        }

<span class="nc" id="L219">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L222">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, errors, threshhold);
        } else {
<span class="nc" id="L225">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), threshhold);
        }

<span class="nc" id="L229">        fit.setNMaxMatchable(leftPoints[0].length);</span>

<span class="nc" id="L231">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L233">        return fit;</span>
    }

    /**
     * For use upon data that have been unit normal standardized.
     * evaluate fit for already matched point lists
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param threshhold
     * @return
     */
    public EpipolarTransformationFit calculateSampsonsError(
            double[][] fm, double[][] leftPoints, double[][] rightPoints,
            double threshhold) {

<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L253">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L256">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L261">        int nRows = leftPoints.length;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (nRows != rightPoints.length) {</span>
<span class="nc" id="L263">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

<span class="nc" id="L266">        double[] distSquared = calculateEpipolarSampsonsDistanceSquared(fm,</span>
                leftPoints, rightPoints);

<span class="nc" id="L269">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L271">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

        double d;
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (int i = 0; i &lt; distSquared.length; ++i) {</span>

<span class="nc" id="L276">            d = Math.sqrt(distSquared[i]);</span>

<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (d &gt; threshhold) {</span>
<span class="nc" id="L279">                continue;</span>
            }

<span class="nc" id="L282">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L284">            errors.add(d);</span>
        }

<span class="nc" id="L287">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L290">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.SAMPSONS, errors, threshhold);
        } else {
<span class="nc" id="L293">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.SAMPSONS, new ArrayList&lt;Double&gt;(), threshhold);
        }

<span class="nc" id="L297">        fit.setNMaxMatchable(leftPoints[0].length);</span>

<span class="nc" id="L299">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L301">        return fit;</span>
    }

    /**
     * For use upon data that have been unit normal standardized.
     * evaluate fit for already matched point lists
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param threshhold
     * @return
     */
    public EpipolarTransformationFit calculateSampsonsError(
            DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
            double threshhold) {

<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L321">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L324">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L327">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L329">        int nRows = leftPoints.numRows();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L331">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

<span class="nc" id="L334">        double[] distSquared = calculateEpipolarSampsonsDistanceSquared(fm, </span>
            leftPoints, rightPoints);

<span class="nc" id="L337">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L339">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

        double d;
<span class="nc bnc" id="L342" title="All 2 branches missed.">        for (int i = 0; i &lt; distSquared.length; ++i) {</span>

<span class="nc" id="L344">            d = Math.sqrt(distSquared[i]);</span>
            
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (d &gt; threshhold) {</span>
<span class="nc" id="L347">                continue;</span>
            }

<span class="nc" id="L350">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L352">            errors.add(d);</span>
        }

<span class="nc" id="L355">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L358">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.SAMPSONS, errors, threshhold);
        } else {
<span class="nc" id="L361">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.SAMPSONS, new ArrayList&lt;Double&gt;(), threshhold);
        }

<span class="nc" id="L365">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="nc" id="L367">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L369">        return fit;</span>
    }
    
    /**
     * given the fundamental matrix solution and the correspondence pairs,
     * use the Luong et al. 1993 distance for each correspondence pair as
     * the closest distance of a point from the projected epipolar line of
     * its pair.   The standard deviation of the errors,
     * and the chi-squared statistic factor are used to remove
     * outliers and return the results.
      Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of 
      different methods and experimental results&quot;.
      NOTE: there may be other references for this method.
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param chiSquaredStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError2(
            DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
            double chiSquaredStatFactor) {

<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L396">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L399">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L402">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L404">        int nRows = leftPoints.numRows();</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L406">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="fc" id="L410">        double[][] distances = calculateDistancesFromEpipolar(fm,</span>
            leftPoints, rightPoints);
        
<span class="fc" id="L413">        double[] combinedDist = combineDistances(distances);</span>
        
<span class="fc" id="L415">        double[] meanAndStDev = MiscMath.getAvgAndStDev(combinedDist);</span>
        
<span class="fc" id="L417">        double t = chiSquaredStatFactor * meanAndStDev[1];</span>
        
<span class="fc" id="L419">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L421">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">        for (int i = 0; i &lt; combinedDist.length; ++i) {</span>

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            if (combinedDist[i] &gt; t) {</span>
<span class="nc" id="L426">                continue;</span>
            }

<span class="fc" id="L429">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="fc" id="L431">            errors.add(combinedDist[i]);</span>
        }

<span class="fc" id="L434">        EpipolarTransformationFit fit = null;</span>

<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="fc" id="L437">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, errors, t);
        } else {
<span class="nc" id="L440">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), t);
        }

<span class="fc" id="L444">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="fc" id="L446">        fit.calculateErrorStatistics();</span>

<span class="fc" id="L448">        return fit;</span>
    }

    /**
     * given the fundamental matrix solution and the correspondence pairs,
     * use the Luong et al. 1993 distance for each correspondence pair as
     * the closest distance of a point from the projected epipolar line of
     * its pair.   The standard deviation of the errors,
     * and the chi-squared statistic factor are used to remove
     * outliers and return the results.
     Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of
     different methods and experimental results&quot;.
     NOTE: there may be other references for this method.
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param chiSquaredStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateEpipolarDistanceError2(
            double[][] fm, double[][] leftPoints, double[][] rightPoints,
            double chiSquaredStatFactor) {

<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L475">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L478">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L481">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L483">        int nRows = leftPoints.length;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (nRows != rightPoints.length) {</span>
<span class="nc" id="L485">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        //2D point (x,y) and line (a, b, c): dist=(a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="nc" id="L489">        double[][] distances = calculateDistancesFromEpipolar(fm,</span>
                leftPoints, rightPoints);

<span class="nc" id="L492">        double[] combinedDist = combineDistances(distances);</span>

<span class="nc" id="L494">        double[] meanAndStDev = MiscMath.getAvgAndStDev(combinedDist);</span>

<span class="nc" id="L496">        double t = chiSquaredStatFactor * meanAndStDev[1];</span>

<span class="nc" id="L498">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L500">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L502" title="All 2 branches missed.">        for (int i = 0; i &lt; combinedDist.length; ++i) {</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (combinedDist[i] &gt; t) {</span>
<span class="nc" id="L505">                continue;</span>
            }

<span class="nc" id="L508">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L510">            errors.add(combinedDist[i]);</span>
        }

<span class="nc" id="L513">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L516">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, errors, t);
        } else {
<span class="nc" id="L519">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.DIST_TO_EPIPOLAR_LINE, new ArrayList&lt;Double&gt;(), t);
        }

<span class="nc" id="L523">        fit.setNMaxMatchable(leftPoints[0].length);</span>

<span class="nc" id="L525">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L527">        return fit;</span>
    }

    /**
     * given rectified correspondence pairs in x1, x2, calculate the
     * square root of the sum of squares of the differences in the
     * y coordinates, or both x and y if useXToo is true.
     * Also uses MAD or Tukey fences to determine inliers.
     * 
     * @param x1 the image 1 set of correspondence points. format is 3 x N
     * where N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points) since
     * internally an identity matrix is used for K.
     * @param x2 the image 2 set of correspondence points. format is 3 x N where
     * N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points).
     * @param outErrors array of length x1[0].length to be used to return each
     * error as the square root of the sum of differences between each x1 and x2.
     * @param outInlierIndexes indexes of points which are within the robust 
     * statistics range for inliers (defined as not being outliers).
     * @param useXToo if true, the errors are not only the differences between the
     * y coordinates of x1 and x2, but also the x-xoordinates of x1 and x2.
     * @return square root of the sum of squared errors
     */
    public static double calculateRectificationErrors(
    double[][] x1, double[][] x2,
    double[] outErrors, TIntList outInlierIndexes, boolean useXToo) {
        
<span class="fc" id="L557">        int n = x1[0].length;</span>
<span class="pc bpc" id="L558" title="3 of 4 branches missed.">        if (x1.length !=3 &amp;&amp; x1.length != 2) {</span>
<span class="nc" id="L559">            throw new IllegalArgumentException(&quot;x1.length must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L561" title="3 of 4 branches missed.">        if (x2.length !=3 &amp;&amp; x2.length != 2) {</span>
<span class="nc" id="L562">            throw new IllegalArgumentException(&quot;x2.length  must be 3 or 2&quot;);</span>
        }
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L565">            throw new IllegalArgumentException(&quot;x2 must be size 3Xn and the same as size of x1&quot;);</span>
        }
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (outErrors.length !=n) {</span>
<span class="nc" id="L568">            throw new IllegalArgumentException(&quot;outErrors.length  must be n&quot;);</span>
        }
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        if (outInlierIndexes == null) {</span>
<span class="nc" id="L571">            throw new IllegalArgumentException(&quot;outInlierIndexes cannot be null&quot;);</span>
        }
        double diff;
<span class="fc" id="L574">        double sum = 0;</span>
        double sumI;
        int i;
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L578">            diff = x1[1][i] - x2[1][i];</span>
<span class="fc" id="L579">            sumI = diff*diff;</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">            if (useXToo) {</span>
<span class="fc" id="L581">                diff = x1[0][i] - x2[0][i];</span>
<span class="fc" id="L582">                sumI += diff*diff;</span>
            }
<span class="fc" id="L584">            sum += sumI;</span>
<span class="fc" id="L585">            outErrors[i] = Math.sqrt(sumI);</span>
        }
<span class="fc" id="L587">        sum = Math.sqrt(sum);</span>
        
        // use MAD or Tukey fences
                
        //median of absolute deviation of x, median, min, and max.
<span class="fc" id="L592">        double[] mADMinMax = MiscMath0.calculateMedianOfAbsoluteDeviation(outErrors);</span>
<span class="fc" id="L593">        double kMAD = 1.4826;</span>
<span class="fc" id="L594">        double s = kMAD*mADMinMax[0];</span>
<span class="fc" id="L595">        double r0 = mADMinMax[1] - 3*s;</span>
<span class="fc" id="L596">        double r1 = mADMinMax[1] + 3*s;</span>
        
<span class="fc" id="L598">        int[] inliers2 = MiscMath0.findInliersUsingTukeyFences(outErrors);</span>
        
<span class="fc bfc" id="L600" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L601">            diff = outErrors[i];</span>
<span class="pc bpc" id="L602" title="1 of 4 branches missed.">            if (diff &gt;= r0 &amp;&amp; diff &lt;= r1) {</span>
<span class="fc" id="L603">                outInlierIndexes.add(i);</span>
            }
        }
        
<span class="fc" id="L607">        System.out.printf(&quot;inliers using MAD=\n%s\ninliers using Tukey fences=\n%s\n&quot;, </span>
<span class="fc" id="L608">            Arrays.toString(outInlierIndexes.toArray()),</span>
<span class="fc" id="L609">            Arrays.toString(inliers2));</span>
        
<span class="fc" id="L611">        return sum;</span>
    }
    
    /**
     * For use upon data that have been unit normal standardized.
     * given the fundamental matrix solution and the correspondence pairs,
     * use the Sampson distance as an error for each correspondence pair, then use
     * the standard deviation of the errors,
     * and the chi-squared statistic factor to remove
     * outliers and return the results.
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param chiSquaredStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateSampsonsError2(
        DenseMatrix fm, DenseMatrix leftPoints, DenseMatrix rightPoints,
        double chiSquaredStatFactor) {

<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L635">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L638">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L641">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L643">        int nRows = leftPoints.numRows();</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        if (nRows != rightPoints.numRows()) {</span>
<span class="nc" id="L645">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        // dist^2:
<span class="fc" id="L649">        double[] dist = calculateEpipolarSampsonsDistanceSquared(fm, </span>
            leftPoints, rightPoints);
<span class="fc bfc" id="L651" title="All 2 branches covered.">        for (int i = 0; i &lt; dist.length; ++i) {</span>
<span class="fc" id="L652">            dist[i] = Math.sqrt(dist[i]);</span>
        }
        
<span class="fc" id="L655">        double[] meanAndStDev = MiscMath.getAvgAndStDev(dist);</span>
        
<span class="fc" id="L657">        double t = chiSquaredStatFactor * meanAndStDev[1];</span>
        
        //System.out.printf(&quot;t=%.3e\n&quot;, t);

<span class="fc" id="L661">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L663">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

        double d;
<span class="fc bfc" id="L666" title="All 2 branches covered.">        for (int i = 0; i &lt; dist.length; ++i) {</span>

<span class="fc" id="L668">            d = dist[i];</span>
            
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (d &gt; t) {</span>
<span class="fc" id="L671">                continue;</span>
            }

<span class="fc" id="L674">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="fc" id="L676">            errors.add(d);</span>
        }

<span class="fc" id="L679">        EpipolarTransformationFit fit = null;</span>

<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (errors.size() &gt; 0) {</span>
<span class="fc" id="L682">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                ErrorType.SAMPSONS, errors, t);
        } else {
<span class="fc" id="L685">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                ErrorType.SAMPSONS, new ArrayList&lt;Double&gt;(), t);
        }

<span class="fc" id="L689">        fit.setNMaxMatchable(leftPoints.numColumns());</span>

<span class="fc" id="L691">        fit.calculateErrorStatistics();</span>

<span class="fc" id="L693">        return fit;</span>
    }

    /**
     * For use upon data that have been unit normal standardized.
     * given the fundamental matrix solution and the correspondence pairs,
     * use the Sampson distance as an error for each correspondence pair, then use
     * the standard deviation of the errors,
     * and the chi-squared statistic factor to remove
     * outliers and return the results.
     *
     * @param fm
     * @param leftPoints points from left image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param rightPoints points from right image in matrix of size 3 X nPoints.
     * row 0 is x, row 1 is y, row 2 is all 1's
     * @param chiSquaredStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateSampsonsError2(
            double[][] fm, double[][] leftPoints, double[][] rightPoints,
            double chiSquaredStatFactor) {

<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L717">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (leftPoints == null) {</span>
<span class="nc" id="L720">            throw new IllegalArgumentException(&quot;leftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (rightPoints == null) {</span>
<span class="nc" id="L723">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L725">        int nRows = leftPoints.length;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (nRows != rightPoints.length) {</span>
<span class="nc" id="L727">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        // dist^2:
<span class="nc" id="L731">        double[] dist = calculateEpipolarSampsonsDistanceSquared(fm,</span>
                leftPoints, rightPoints);
<span class="nc bnc" id="L733" title="All 2 branches missed.">        for (int i = 0; i &lt; dist.length; ++i) {</span>
<span class="nc" id="L734">            dist[i] = Math.sqrt(dist[i]);</span>
        }

<span class="nc" id="L737">        double[] meanAndStDev = MiscMath.getAvgAndStDev(dist);</span>

<span class="nc" id="L739">        double t = chiSquaredStatFactor * meanAndStDev[1];</span>

        //System.out.printf(&quot;t=%.3e\n&quot;, t);

<span class="nc" id="L743">        List&lt;Double&gt; errors = new ArrayList&lt;Double&gt;();</span>

<span class="nc" id="L745">        List&lt;Integer&gt; inlierIndexes = new ArrayList&lt;Integer&gt;();</span>

        double d;
<span class="nc bnc" id="L748" title="All 2 branches missed.">        for (int i = 0; i &lt; dist.length; ++i) {</span>

<span class="nc" id="L750">            d = dist[i];</span>

<span class="nc bnc" id="L752" title="All 2 branches missed.">            if (d &gt; t) {</span>
<span class="nc" id="L753">                continue;</span>
            }

<span class="nc" id="L756">            inlierIndexes.add(Integer.valueOf(i));</span>

<span class="nc" id="L758">            errors.add(d);</span>
        }

<span class="nc" id="L761">        EpipolarTransformationFit fit = null;</span>

<span class="nc bnc" id="L763" title="All 2 branches missed.">        if (errors.size() &gt; 0) {</span>
<span class="nc" id="L764">            fit = new EpipolarTransformationFit(fm, inlierIndexes,</span>
                    ErrorType.SAMPSONS, errors, t);
        } else {
<span class="nc" id="L767">            fit = new EpipolarTransformationFit(fm, new ArrayList&lt;Integer&gt;(),</span>
                    ErrorType.SAMPSONS, new ArrayList&lt;Double&gt;(), t);
        }

<span class="nc" id="L771">        fit.setNMaxMatchable(leftPoints[0].length);</span>

<span class="nc" id="L773">        fit.calculateErrorStatistics();</span>

<span class="nc" id="L775">        return fit;</span>
    }

    /**
     * find the distance of the given points from their respective projected
     * epipolar lines.
     Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of 
     different methods and experimental results&quot;
     
     * @param fm
     * @param matchedLeftPoints points from left image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @param matchedRightPoints points from right image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @return array of size[2][matchedLeftPoints.numColumns()]
     */
    public double[][] calculateDistancesFromEpipolar(
        DenseMatrix fm, DenseMatrix matchedLeftPoints,
        DenseMatrix matchedRightPoints) {

<span class="pc bpc" id="L795" title="1 of 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L796">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">        if (matchedLeftPoints == null) {</span>
<span class="nc" id="L799">            throw new IllegalArgumentException(&quot;matchedLeftPoints cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        if (matchedRightPoints == null) {</span>
<span class="nc" id="L802">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="fc" id="L804">        int nRows = matchedLeftPoints.numRows();</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (nRows != matchedRightPoints.numRows()) {</span>
<span class="nc" id="L806">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        /*
        u_2^T * F * u_1 = 0  where u are the x,y points in images _1 and _2
        u_1 = (x_1, y_1, 1)^T
        u_2 = (x_2, y_2, 1)^T
         */
<span class="fc" id="L814">        int n = matchedLeftPoints.numColumns();</span>

<span class="fc" id="L816">        double[][] distances = new double[2][n];</span>
<span class="fc" id="L817">        distances[0] = new double[n];</span>
<span class="fc" id="L818">        distances[1] = new double[n];</span>

        // F * u_1 = 3 x n
<span class="fc" id="L821">        DenseMatrix rightEpipolarLines = MatrixUtil.multiply(fm, matchedLeftPoints);</span>

        // F^T * u_2
<span class="fc" id="L824">        DenseMatrix leftEpipolarLines = MatrixUtil.multiply(</span>
<span class="fc" id="L825">            algorithms.matrix.MatrixUtil.transpose(fm),</span>
            matchedRightPoints);

<span class="fc" id="L828">        float[] output = new float[2];</span>

<span class="fc bfc" id="L830" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedLeftPoints.numColumns(); i++) {</span>

<span class="fc" id="L832">            calculatePerpDistFromLines(matchedLeftPoints, matchedRightPoints,</span>
                rightEpipolarLines, leftEpipolarLines,
                i, i, output);

<span class="fc" id="L836">            distances[0][i] = output[0];</span>
<span class="fc" id="L837">            distances[1][i] = output[1];</span>
        }

<span class="fc" id="L840">        return distances;</span>
    }

    /**
     * find the distance of the given points from their respective projected
     * epipolar lines.
     Luong et al. 1993, &quot;On determining the fundamental matrix?: analysis of
     different methods and experimental results&quot;

     * @param fm
     * @param matchedLeftPoints points from left image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @param matchedRightPoints points from right image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @return array of size[2][matchedLeftPoints.numColumns()]
     */
    public double[][] calculateDistancesFromEpipolar(
            double[][] fm, double[][] matchedLeftPoints,
            double[][] matchedRightPoints) {

<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L861">            throw new IllegalArgumentException(&quot;fm cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (matchedLeftPoints == null) {</span>
<span class="nc" id="L864">            throw new IllegalArgumentException(&quot;matchedLeftPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (matchedRightPoints == null) {</span>
<span class="nc" id="L867">            throw new IllegalArgumentException(&quot;rightPoints cannot be null&quot;);</span>
        }
<span class="nc" id="L869">        int nRows = matchedLeftPoints.length;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (nRows != matchedRightPoints.length) {</span>
<span class="nc" id="L871">            throw new IllegalArgumentException(&quot;matrices must have same number of rows&quot;);</span>
        }

        /*
        u_2^T * F * u_1 = 0  where u are the x,y points in images _1 and _2
        u_1 = (x_1, y_1, 1)^T
        u_2 = (x_2, y_2, 1)^T
         */
<span class="nc" id="L879">        int n = matchedLeftPoints[0].length;</span>

<span class="nc" id="L881">        double[][] distances = new double[2][n];</span>
<span class="nc" id="L882">        distances[0] = new double[n];</span>
<span class="nc" id="L883">        distances[1] = new double[n];</span>

        // F * u_1 = 3 x n
<span class="nc" id="L886">        double[][] rightEpipolarLines = MatrixUtil.multiply(fm, matchedLeftPoints);</span>

        // F^T * u_2
<span class="nc" id="L889">        double[][] leftEpipolarLines = MatrixUtil.multiply(</span>
<span class="nc" id="L890">                algorithms.matrix.MatrixUtil.transpose(fm),</span>
                matchedRightPoints);

<span class="nc" id="L893">        float[] output = new float[2];</span>

<span class="nc bnc" id="L895" title="All 2 branches missed.">        for (int i = 0; i &lt; matchedLeftPoints[0].length; i++) {</span>

<span class="nc" id="L897">            calculatePerpDistFromLines(matchedLeftPoints, matchedRightPoints,</span>
                    rightEpipolarLines, leftEpipolarLines,
                    i, i, output);

<span class="nc" id="L901">            distances[0][i] = output[0];</span>
<span class="nc" id="L902">            distances[1][i] = output[1];</span>
        }

<span class="nc" id="L905">        return distances;</span>
    }

    /**
     * For use upon data that have been unit normal standardized.
     Sampson's distance measures the distance between a correspondence pair
     and its Sampson correction (Torr and Zissermann, 1997).
     Torr &amp; Murray 1997 describe the Sampson distance further:
     &quot;it represents the sum of squares of the algebraic residuals divided by 
     their standard deviations&quot; and provides a first order fit to the 
     Kendall &amp; Stuart (1983) minimization of the orthogonal distance of each 
     point to a curve/surface of the maximum likelihood solution. 
     * 
     perpendicular geometric distances...
     &lt;pre&gt;
     implemented from eqn 11 from Fathy, Husseina, &amp; Tolbaa, 2017
     &quot;Fundamental Matrix Estimation: A Study of Error Criteria&quot;
     https://arxiv.org/pdf/1706.07886.pdf
     which references Torr and Zisserman 1997, 
     Machine Vision and Applications 9 (5), 321–333,
     &quot; Performance characterization of fundamental matrix estimation under image 
     degradation&quot;
     
     &lt;/pre&gt;
     * @param fm
     * @param x1 points from left image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @param x2 points from right image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @return double array of length [n]
     */
    public double[] calculateEpipolarSampsonsDistanceSquared(
        DenseMatrix fm, DenseMatrix x1, DenseMatrix x2) {

<span class="fc" id="L939">        int m = fm.numRows();</span>
<span class="fc" id="L940">        int n = x1.numColumns();</span>
<span class="pc bpc" id="L941" title="2 of 4 branches missed.">        if (m != 3 || fm.numColumns() != 3) {</span>
<span class="nc" id="L942">            throw new IllegalArgumentException(&quot;fm must be 3x3&quot;);</span>
        }
<span class="pc bpc" id="L944" title="2 of 4 branches missed.">        if (x1.numRows() != 3 || x2.numRows() != 3) {</span>
<span class="nc" id="L945">            throw new IllegalArgumentException(&quot;x1 and x2 must have 3 rows&quot;);</span>
        }
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">        if (x2.numColumns() != n) {</span>
<span class="nc" id="L948">            throw new IllegalArgumentException(&quot;x1 and x2 must have the same number of columns&quot;);</span>
        }
        
        /*
        R_i = u2_i^T * F * u1_i
        
        line2_i = F * u1_i = (a2_i, b2_i, c2_i)
        
        line1_i = F^T * u2_i = (a1_i, b1_i, c1_i)
        
        (dist_i)^2 = (R_i)^2 / ( (a1_i)^2 + (b1_i)^2 + (a2_i)^2 + (b2_i)^2 ) 
        */
        
<span class="fc" id="L961">        double[] distances = new double[n];</span>

        // 3 x n.  left points projected onto right image
<span class="fc" id="L964">        DenseMatrix fX1 = MatrixUtil.multiply(fm, x1);</span>

        // 3 X n.  right points projected onto left image
<span class="fc" id="L967">        DenseMatrix fTX2 = MatrixUtil.multiply(algorithms.matrix.MatrixUtil.transpose(fm),</span>
            x2);
        
        /*R_i is found in (row i, col i) of the result of u2^T * F * u1                                          \\//
        &gt;&gt; x2_00  x2_10  x2_20   *  f00 f01 f02  *  x1_00  x1_01
           x2_01  x2_11  x2_21      f10 f11 f12     x1_10  x1_11
                                    f20 f21 f22     x1_20  x1_21
        
        e.g. R_0 = (x2_00*f00 + x2_10*f10 + x2_20*f20) * x1_00   
                    + (x2_00*f01 + x2_10*f11 + x2_20*f21) * x1_10
                    + (x2_00*f02 + x2_10*f12 + x2_20*f22) * x1_20
        */
<span class="fc" id="L979">        DenseMatrix r = MatrixUtil.multiply(MatrixUtil.transpose(x2), fm);</span>
<span class="fc" id="L980">        r = MatrixUtil.multiply(r, x1);</span>

        double a1, b1, c1, a2, b2, c2, denom, ri;
<span class="fc bfc" id="L983" title="All 2 branches covered.">        for (int i = 0; i &lt; x1.numColumns(); i++) {</span>
            
<span class="fc" id="L985">            a1 = fTX2.get(0, i);</span>
<span class="fc" id="L986">            b1 = fTX2.get(1, i);</span>
<span class="fc" id="L987">            c1 = fTX2.get(2, i);</span>
            
<span class="fc" id="L989">            a2 = fX1.get(0, i);</span>
<span class="fc" id="L990">            b2 = fX1.get(1, i);</span>
<span class="fc" id="L991">            c2 = fX1.get(2, i);</span>

<span class="fc" id="L993">            denom = a1*a1 + b1*b1 + a2*a2 + b2*b2;</span>

<span class="fc" id="L995">            ri = r.get(i, i);</span>
<span class="fc" id="L996">            ri *= ri;</span>
<span class="fc" id="L997">            ri /= denom;</span>
           
<span class="fc" id="L999">            distances[i] = ri;</span>
        }

<span class="fc" id="L1002">        return distances;</span>
    }

    /**
     * For use upon data that have been unit normal standardized.
     Sampson's distance measures the distance between a correspondence pair
     and its Sampson correction (Torr and Zissermann, 1997).
     Torr &amp; Murray 1997 describe the Sampson distance further:
     &quot;it represents the sum of squares of the algebraic residuals divided by
     their standard deviations&quot; and provides a first order fit to the
     Kendall &amp; Stuart (1983) minimization of the orthogonal distance of each
     point to a curve/surface of the maximum likelihood solution.
     *
     perpendicular geometric distances...
     &lt;pre&gt;
     implemented from eqn 11 from Fathy, Husseina, &amp; Tolbaa, 2017
     &quot;Fundamental Matrix Estimation: A Study of Error Criteria&quot;
     https://arxiv.org/pdf/1706.07886.pdf
     which references Torr and Zisserman 1997,
     Machine Vision and Applications 9 (5), 321–333,
     &quot; Performance characterization of fundamental matrix estimation under image
     degradation&quot;

     &lt;/pre&gt;
     * @param fm
     * @param x1 points from left image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @param x2 points from right image in matrix of size 3 X
     * nPoints. row 0 is x, row 1 is y, row 2 is all 1's
     * @return double array of length [n]
     */
    public double[] calculateEpipolarSampsonsDistanceSquared(
            double[][] fm, double[][] x1, double[][] x2) {

<span class="nc" id="L1036">        int m = fm.length;</span>
<span class="nc" id="L1037">        int n = x1[0].length;</span>
<span class="nc bnc" id="L1038" title="All 4 branches missed.">        if (m != 3 || fm[0].length != 3) {</span>
<span class="nc" id="L1039">            throw new IllegalArgumentException(&quot;fm must be 3x3&quot;);</span>
        }
<span class="nc bnc" id="L1041" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L1042">            throw new IllegalArgumentException(&quot;x1 and x2 must have 3 rows&quot;);</span>
        }
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L1045">            throw new IllegalArgumentException(&quot;x1 and x2 must have the same number of columns&quot;);</span>
        }

        /*
        R_i = u2_i^T * F * u1_i

        line2_i = F * u1_i = (a2_i, b2_i, c2_i)

        line1_i = F^T * u2_i = (a1_i, b1_i, c1_i)

        (dist_i)^2 = (R_i)^2 / ( (a1_i)^2 + (b1_i)^2 + (a2_i)^2 + (b2_i)^2 )
        */

<span class="nc" id="L1058">        double[] distances = new double[n];</span>

        // 3 x n.  left points projected onto right image
<span class="nc" id="L1061">        double[][] fX1 = MatrixUtil.multiply(fm, x1);</span>

        // 3 X n.  right points projected onto left image
<span class="nc" id="L1064">        double[][] fTX2 = MatrixUtil.multiply(MatrixUtil.transpose(fm), x2);</span>

        /*R_i is found in (row i, col i) of the result of u2^T * F * u1                                          \\//
        &gt;&gt; x2_00  x2_10  x2_20   *  f00 f01 f02  *  x1_00  x1_01
           x2_01  x2_11  x2_21      f10 f11 f12     x1_10  x1_11
                                    f20 f21 f22     x1_20  x1_21

        e.g. R_0 = (x2_00*f00 + x2_10*f10 + x2_20*f20) * x1_00
                    + (x2_00*f01 + x2_10*f11 + x2_20*f21) * x1_10
                    + (x2_00*f02 + x2_10*f12 + x2_20*f22) * x1_20
        */
<span class="nc" id="L1075">        double[][] r = MatrixUtil.multiply(MatrixUtil.transpose(x2), fm);</span>
<span class="nc" id="L1076">        r = MatrixUtil.multiply(r, x1);</span>

        double a1, b1, c1, a2, b2, c2, denom, ri;
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        for (int i = 0; i &lt; x1[0].length; i++) {</span>

<span class="nc" id="L1081">            a1 = fTX2[0][i];</span>
<span class="nc" id="L1082">            b1 = fTX2[1][i];</span>
<span class="nc" id="L1083">            c1 = fTX2[2][i];</span>

<span class="nc" id="L1085">            a2 = fX1[0][i];</span>
<span class="nc" id="L1086">            b2 = fX1[1][i];</span>
<span class="nc" id="L1087">            c2 = fX1[2][i];</span>

<span class="nc" id="L1089">            denom = a1*a1 + b1*b1 + a2*a2 + b2*b2;</span>

<span class="nc" id="L1091">            ri = r[i][i];</span>
<span class="nc" id="L1092">            ri *= ri;</span>
<span class="nc" id="L1093">            ri /= denom;</span>

<span class="nc" id="L1095">            distances[i] = ri;</span>
        }

<span class="nc" id="L1098">        return distances;</span>
    }

    /**
     *
     * @param u1 points from left image in matrix of size 3 X nPoints. row 0 is
     * x, row 1 is y, row 2 is all 1's
     * @param u2 points from right image in matrix of size 3 X nPoints. row 0 is
     * x, row 1 is y, row 2 is all 1's
     * @param fu1
     * @param fTu2
     * @param leftIdx
     * @param rightIdx
     * @param output an output variable to hold as element 0, the distance of
     * the right image point at rightIdx from from it's left epipolar line
     * projected into the right image. element 1 holds the reverse for the left
     * image point at leftIdx.
     */
    public void calculatePerpDistFromLines(DenseMatrix u1, DenseMatrix u2,
            DenseMatrix fu1, DenseMatrix fTu2,
            int leftIdx, int rightIdx, float[] output) {

        // see references for eqn (1) of within Fathy et al. 2017,
        // &quot;Fundamental Matrix Estimation: A Study of Error Criteria&quot;
<span class="fc" id="L1122">        double a = fu1.get(0, leftIdx);</span>
<span class="fc" id="L1123">        double b = fu1.get(1, leftIdx);</span>
<span class="fc" id="L1124">        double c = fu1.get(2, leftIdx);</span>

<span class="fc" id="L1126">        double aplusb = Math.sqrt((a * a) + (b * b));</span>

        //dist = (a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="fc" id="L1129">        double x = u2.get(0, rightIdx);</span>
<span class="fc" id="L1130">        double y = u2.get(1, rightIdx);</span>

<span class="fc" id="L1132">        double d = (a * x + b * y + c) / aplusb;</span>

        // find the reverse distance by projection:
<span class="fc" id="L1135">        double aRev = fTu2.get(0, rightIdx);</span>
<span class="fc" id="L1136">        double bRev = fTu2.get(1, rightIdx);</span>
<span class="fc" id="L1137">        double cRev = fTu2.get(2, rightIdx);</span>

<span class="fc" id="L1139">        double xL = u1.get(0, leftIdx);</span>
<span class="fc" id="L1140">        double yL = u1.get(1, leftIdx);</span>

<span class="fc" id="L1142">        double dRev = (aRev * xL + bRev * yL + cRev)</span>
<span class="fc" id="L1143">                / Math.sqrt(aRev * aRev + bRev * bRev);</span>

<span class="fc" id="L1145">        output[0] = (float) dRev;</span>
<span class="fc" id="L1146">        output[1] = (float) d;</span>
<span class="fc" id="L1147">    }</span>

    /**
     *
     * @param u1 points from left image in matrix of size 3 X nPoints. row 0 is
     * x, row 1 is y, row 2 is all 1's
     * @param u2 points from right image in matrix of size 3 X nPoints. row 0 is
     * x, row 1 is y, row 2 is all 1's
     * @param fu1
     * @param fTu2
     * @param leftIdx
     * @param rightIdx
     * @param output an output variable to hold as element 0, the distance of
     * the right image point at rightIdx from from it's left epipolar line
     * projected into the right image. element 1 holds the reverse for the left
     * image point at leftIdx.
     */
    public void calculatePerpDistFromLines(double[][] u1, double[][] u2,
                                           double[][] fu1, double[][] fTu2,
                                           int leftIdx, int rightIdx, float[] output) {

        // see references for eqn (1) of within Fathy et al. 2017,
        // &quot;Fundamental Matrix Estimation: A Study of Error Criteria&quot;
<span class="nc" id="L1170">        double a = fu1[0][leftIdx];</span>
<span class="nc" id="L1171">        double b = fu1[1][leftIdx];</span>
<span class="nc" id="L1172">        double c = fu1[2][leftIdx];</span>

<span class="nc" id="L1174">        double aplusb = Math.sqrt((a * a) + (b * b));</span>

        //dist = (a*x + b*y + c)/sqrt(a^2 + b^2)
<span class="nc" id="L1177">        double x = u2[0][rightIdx];</span>
<span class="nc" id="L1178">        double y = u2[1][rightIdx];</span>

<span class="nc" id="L1180">        double d = (a * x + b * y + c) / aplusb;</span>

        // find the reverse distance by projection:
<span class="nc" id="L1183">        double aRev = fTu2[0][rightIdx];</span>
<span class="nc" id="L1184">        double bRev = fTu2[1][rightIdx];</span>
<span class="nc" id="L1185">        double cRev = fTu2[2][rightIdx];</span>

<span class="nc" id="L1187">        double xL = u1[0][leftIdx];</span>
<span class="nc" id="L1188">        double yL = u1[1][leftIdx];</span>

<span class="nc" id="L1190">        double dRev = (aRev * xL + bRev * yL + cRev)</span>
<span class="nc" id="L1191">                / Math.sqrt(aRev * aRev + bRev * bRev);</span>

<span class="nc" id="L1193">        output[0] = (float) dRev;</span>
<span class="nc" id="L1194">        output[1] = (float) d;</span>
<span class="nc" id="L1195">    }</span>

    public EpipolarTransformationFit calculateError(DenseMatrix fm,
        DenseMatrix x1, DenseMatrix x2, ErrorType errorType, double threshhold) {

<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="nc" id="L1201">            return calculateSampsonsError(fm, x1, x2, threshhold);</span>
        } else {
<span class="nc" id="L1203">            return calculateEpipolarDistanceError(fm, x1, x2, threshhold);</span>
        }
    }

    public EpipolarTransformationFit calculateError(double[][] fm,
                                                    double[][] x1, double[][] x2, ErrorType errorType, double threshhold) {

<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="nc" id="L1211">            return calculateSampsonsError(fm, x1, x2, threshhold);</span>
        } else {
<span class="nc" id="L1213">            return calculateEpipolarDistanceError(fm, x1, x2, threshhold);</span>
        }
    }
    
    /**
     * given the fundamental matrix solution and the correspondence pairs,
     * use the errorType to calculate errors for each point, then use
     * the standard deviation and the chi-squared statistic factor to remove
     * outliers and return the results.
     * 
     * @param fm
     * @param x1
     * @param x2
     * @param errorType
     * @param chiSqStatFactor
     * @return 
     */
    public EpipolarTransformationFit calculateError2(DenseMatrix fm,
            DenseMatrix x1, DenseMatrix x2, ErrorType errorType, 
            double chiSqStatFactor) {

<span class="fc bfc" id="L1234" title="All 2 branches covered.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="fc" id="L1235">            return calculateSampsonsError2(fm, x1, x2, chiSqStatFactor);</span>
        } else {
<span class="fc" id="L1237">            return calculateEpipolarDistanceError2(fm, x1, x2, chiSqStatFactor);</span>
        }
    }

    /**
     * given the fundamental matrix solution and the correspondence pairs,
     * use the errorType to calculate errors for each point, then use
     * the standard deviation and the chi-squared statistic factor to remove
     * outliers and return the results.
     *
     * @param fm
     * @param x1
     * @param x2
     * @param errorType
     * @param chiSqStatFactor
     * @return
     */
    public EpipolarTransformationFit calculateError2(double[][] fm,
                                                     double[][] x1, double[][] x2, ErrorType errorType,
                                                     double chiSqStatFactor) {

<span class="nc bnc" id="L1258" title="All 2 branches missed.">        if (errorType.equals(ErrorType.SAMPSONS)) {</span>
<span class="nc" id="L1259">            return calculateSampsonsError2(fm, x1, x2, chiSqStatFactor);</span>
        } else {
<span class="nc" id="L1261">            return calculateEpipolarDistanceError2(fm, x1, x2, chiSqStatFactor);</span>
        }
    }

    /**
     * performs repmat(X(rowToTransposeAndReplicate,:)',1,3)
     * @param x matrix of size 3 X N.
     * @param rowToTransposeAndReplicate
     * @return matrix of size N X 3
     */
    private double[][] repmat3(double[][] x, int rowToTransposeAndReplicate) {
<span class="nc" id="L1272">        int n = x[0].length;</span>
<span class="nc" id="L1273">        double[][] out = new double[n][3];</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L1275">            out[i] = new double[3];</span>
<span class="nc" id="L1276">            out[i][0] = x[rowToTransposeAndReplicate][i];</span>
<span class="nc" id="L1277">            out[i][1] = x[rowToTransposeAndReplicate][i];</span>
<span class="nc" id="L1278">            out[i][2] = x[rowToTransposeAndReplicate][i];</span>
        }
<span class="nc" id="L1280">        return out;</span>
    }
    
    /**
     * performs repmat(X(rowToReplicate,:),3,1)
     * @param x matrix of size 3XN
     * @param rowToReplicate
     * @return matrix of size 3 X N
     */
    private double[][] repmat_3(double[][] x, int rowToReplicate) {
<span class="nc" id="L1290">        int n = x[0].length;</span>
<span class="nc" id="L1291">        double[][] out = new double[3][n];</span>
<span class="nc" id="L1292">        out[0] = Arrays.copyOf(x[rowToReplicate], x[rowToReplicate].length);</span>
<span class="nc" id="L1293">        out[1] = Arrays.copyOf(out[0], out[0].length);</span>
<span class="nc" id="L1294">        out[2] = Arrays.copyOf(out[0], out[0].length);</span>
<span class="nc" id="L1295">        return out;</span>
    }
    
    /**
     * make an array composed of the concatenation of a, b, and c horizontally
     * as blocks of columns.
     * @param a
     * @param b
     * @param c
     * @return concatenated array of size [a.length][a[0].length + b[0].length + c[0].length]
     */
    private double[][] concatenateAsColumnBlocks(double[][] a, double[][] b, double[][] c) {
<span class="nc" id="L1307">        int n0 = a[0].length;</span>
<span class="nc" id="L1308">        int n1 = b[0].length;</span>
<span class="nc" id="L1309">        int n2 = c[0].length;</span>
<span class="nc" id="L1310">        int m = a.length;</span>
<span class="nc bnc" id="L1311" title="All 4 branches missed.">        if (b.length != m || c.length != m) {</span>
<span class="nc" id="L1312">            throw new IllegalArgumentException(&quot;a, b, and c must have same number of rows&quot;);</span>
        }
<span class="nc" id="L1314">        int n = n0 + n1 + n2;</span>
        int j, nc;
<span class="nc" id="L1316">        double[][] out = new double[m][n];</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="nc" id="L1318">            out[i] = new double[n];</span>
<span class="nc" id="L1319">            nc = 0;</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">            for (j = 0; j &lt; n0; ++j) {</span>
<span class="nc" id="L1321">                out[i][nc] = a[i][j];</span>
<span class="nc" id="L1322">                nc++;</span>
            }
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            for (j = 0; j &lt; n1; ++j) {</span>
<span class="nc" id="L1325">                out[i][nc] = b[i][j];</span>
<span class="nc" id="L1326">                nc++;</span>
            }
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            for (j = 0; j &lt; n2; ++j) {</span>
<span class="nc" id="L1329">                out[i][nc] = c[i][j];</span>
<span class="nc" id="L1330">                nc++;</span>
            }
        }
<span class="nc" id="L1333">        return out;</span>
    }
    
    /**
     * make an array composed of the concatenation of a, b, and c vertically
     * as blocks of rows.
     * @param a
     * @param b
     * @param c
     * @return concatenated array of size [a.length + b.length + c.length][a[0].length]
     */
    private double[][] concatenateAsRowBlocks(double[][] a, double[][] b, double[][] c, double[][] d) {
<span class="nc" id="L1345">        int m0 = a.length;</span>
<span class="nc" id="L1346">        int m1 = b.length;</span>
<span class="nc" id="L1347">        int m2 = c.length;</span>
<span class="nc" id="L1348">        int m3 = d.length;</span>
<span class="nc" id="L1349">        int n = a[0].length;</span>
<span class="nc bnc" id="L1350" title="All 6 branches missed.">        if (b[0].length != n || c[0].length != n || d[0].length != n) {</span>
<span class="nc" id="L1351">            throw new IllegalArgumentException(&quot;a, b, c and d must have same number of columns&quot;);</span>
        }
<span class="nc" id="L1353">        int m = m0 + m1 + m2 + m3;</span>
        int i;
<span class="nc" id="L1355">        double[][] out = new double[m][n];        </span>
<span class="nc" id="L1356">        int mc = 0;</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        for (i = 0; i &lt; m0; ++i) {</span>
<span class="nc" id="L1358">            out[mc] = Arrays.copyOf(a[i], n);</span>
<span class="nc" id="L1359">            mc++;</span>
        }
<span class="nc bnc" id="L1361" title="All 2 branches missed.">        for (i = 0; i &lt; m1; ++i) {</span>
<span class="nc" id="L1362">            out[mc] = Arrays.copyOf(b[i], n);</span>
<span class="nc" id="L1363">            mc++;</span>
        }
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        for (i = 0; i &lt; m2; ++i) {</span>
<span class="nc" id="L1366">            out[mc] = Arrays.copyOf(c[i], n);</span>
<span class="nc" id="L1367">            mc++;</span>
        }
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        for (i = 0; i &lt; m3; ++i) {</span>
<span class="nc" id="L1370">            out[mc] = Arrays.copyOf(d[i], n);</span>
<span class="nc" id="L1371">            mc++;</span>
        }
        
<span class="nc" id="L1374">        return out;</span>
    }
    
    /**
     * make an array composed of the concatenation of a, b, and c vertically
     * as rows.
     * @param a
     * @param b
     * @param c
     * @return concatenated array of size [4][a.length + b.length + c.length]
     */
    private double[][] concatenateAsRows(double[] a, double[] b, double[] c, double[] d) {
<span class="nc" id="L1386">        int m0 = a.length;</span>
<span class="nc" id="L1387">        int m1 = b.length;</span>
<span class="nc" id="L1388">        int m2 = c.length;</span>
<span class="nc" id="L1389">        int m3 = d.length;</span>
<span class="nc bnc" id="L1390" title="All 6 branches missed.">        if (m1 != m0 || m2 != m0 || m3 != m0) {</span>
<span class="nc" id="L1391">            throw new IllegalArgumentException(&quot;a, b, c and d must have same lengths&quot;);</span>
        }
<span class="nc" id="L1393">        double[][] out = new double[4][m0];        </span>
<span class="nc" id="L1394">        out[0] = Arrays.copyOf(a, m0);</span>
<span class="nc" id="L1395">        out[1] = Arrays.copyOf(b, m0);</span>
<span class="nc" id="L1396">        out[2] = Arrays.copyOf(c, m0);</span>
<span class="nc" id="L1397">        out[3] = Arrays.copyOf(d, m0);</span>
        
<span class="nc" id="L1399">        return out;</span>
    }

    private double[] combineDistances(double[][] distances) {
<span class="fc" id="L1403">        double[] c = new double[distances[0].length];</span>
        double d;
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        for (int i = 0; i &lt; distances[0].length; ++i) {</span>
<span class="fc" id="L1406">            d = distances[0][i]*distances[0][i] + distances[1][i]*distances[1][i];</span>
<span class="fc" id="L1407">            c[i] = Math.sqrt(d);</span>
        }
<span class="fc" id="L1409">        return c;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reconstruction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Reconstruction.java</span></div><h1>Reconstruction.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.dimensionReduction.CURDecomposition;
import algorithms.dimensionReduction.CURDecomposition.CUR;
import algorithms.imageProcessing.features.RANSACSolver;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.imageProcessing.transform.Camera.CameraParameters;
import algorithms.imageProcessing.transform.Camera.CameraProjection;
import static algorithms.imageProcessing.transform.CameraPose.eps;
import algorithms.matrix.LinearEquations;
import algorithms.matrix.MatrixUtil;
import algorithms.matrix.MatrixUtil.SVDProducts;
import algorithms.util.FormatArray;
import java.util.Arrays;
import java.util.List;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.EVD;
import no.uib.cipr.matrix.NotConvergedException;

/**
 * given correspondence between two images calculate the camera
 * parameters as intrinsic and extrinsic parameters,
 * and the real world position.
 * 
 * Euler rotations:
        
        about z-axis (yaw):           about x-axis (roll):       about the y-axis (pitch):
            | cos φ   -sin φ    0 |    |    1       0       0 |  |  cos ψ    0  sin ψ |
            | sin φ    cos φ    0 |    |    0   cos θ   sin θ |  |      0    1      0 |
            |     0        0    1 |    |    0  -sin θ   cos θ |  | -sin ψ    0  cos ψ |        
        
 * useful reading:
  http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
  Fig 1.8 of &quot;Computing Intrinsic Images&quot; by Aloimonos 1986 for a snapshot in time of c.v. algorithms

   Motion - the rotation and translation of an object in front of a camera.
            sometimes represented as the 3X4 projection matria P = |R | t|
   Shape - the local surface orientation where surface orientation is 
           usually the surface normal vector.
           sometimes represented by X, the 3-D coordinates w.r.t. a world reference system.
           From &quot;Computing Intrinsic Images&quot; by Aloimonos 1986
             perspective projection is pinhole camera.
             Under orthographic projection, the image coordinates of a point 
             are equal to the corresponding 3-D coordinates, i.e. (x.y ) =(X,Y)
             and we do not know its depth.
   Depth - the Z-coordinate of a 3-D object in the world coordinate system.

   test datasets:
      https://www.cs.cmu.edu/afs/cs/project/vision/vasc/idb/www/html_permanent/index.html
      http://www.cs.cmu.edu/afs/cs/project/cil/www/v-images.html
       
      
 TODO: implement more of Chap 11 of MASKS (Ma, Soatto, Kosecká, and Sastry 2012, 
 * &quot;An Invitation to 3-D Vision&quot;)
 * 
 &lt;/pre&gt;

 * @author nichole
 */
<span class="pc" id="L60">public class Reconstruction {</span>
    
    /*
    // notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
    
    // homogeneous repr of a point is x_vec = (x, y, 1)^T
    // equation f a line is ell = a*x + b*y + c = 0;
    
    // line rewritten in homogeneous coordinatrs is x_vec^T * ell.
    
    // general conic in 3 dimensions is a*x^2 + b*x*y + c*y^2 + d*x*z + e*y*z + f*z^2 = 0.
    //     rewritten using 2D homogenouse coords, quadratice form: x_vec^T * C * x_vec = 0
    //                  [a   b/2   d/2 ]
    //        where C = [b/2   c   c/2 ]
    //                  [d/2 c/2     f ]
    //        C has 6 variable, 5 DOF, so need 5 points
    //     can then reformat x_vec^T * C * x_vec = 0 into
    //        the &quot;design matrix&quot; * &quot;the carrier vector&quot; = 0
    //               A * c = 0
    //        c = SVD(A).V^T[n-1], the eigenvector assoc w/ smallest eigenvalue.
    
    Parallel lines lines intersect in points at infinity (also known as ideal points) 
    and these points have the form (x, y, 0)^⊤
    the set of ideal points (i.e., points at infinity) is the set of points 
    where parallel lines intersect.
    
    The intersection of two lines is given by their vector cross product.
    
    The line passing through any two points is given by their cross product.
    
    The line at infinity is (0,0,1)^⊤ which can be seen by taking the cross
        product of 2 points at infinity.  e.g. (x1,y1,0)^⊤ cross (x2,y2,0)^⊤ = (0,0,1)^⊤
     
        The two circular points are defined as
           I = (1, i, 0)^⊤
           J = (1, −i, 0)^T
        The circular points lie on l∞, along with all other ideal points. All 
        circles intersect l∞ at points I and J.
    
        Recall the duality between points and lines:
           x2 = H*x1,  l2 = (H^−⊤)*l1
    
        The dual of a conic C is the set of lines satisfying:
           l^⊤ * C∗ * l = 0
           where C∗ is the adjoint in this case, so C∗ ∼ C^−1  
        Dual conics tranform under homography H as:
           C∗′ = H * C∗ * H^⊤
    
        The “conic dual to the circular points” is defined as
           C ∞∗ = I*J^⊤ + J*I^⊤
                ~ [ 1  0  0 ]
                  [ 0  1  0 ]
                  [ 0  0  0 ]
    
    Stratified Reconstruction (cahpters 8 and 6):
    
    Notes on stratified reconstruction in the 2D case (lec 6):
        Each stratum represents a different level of reconstruction we may wish 
        to obtain, namely projective, affine and Euclidean. 
        A general 2D homography can be decomposed into three components:
           H = H_p * H_a * H_e 
        which are the projective, affine and euclidean components.
              
          H = [  I   0 ] * [ K    0 ] * [ R   T ]
              [ v^T  1 ]   [ 0^T  1 ]   [ 0^T 1 ]
                 H_p           H_a         H_e
    
          H_e is a 2D rigid transformation
          H_a is an affine trnsformation
          H_p is a projective transformation known as an “elation.”
               v^T affets the line at infinity, l∞ = (0, 0, 1)^⊤.
               ** Only H_p can map l∞ to a finite line in the image plane, or vice versa.
               suppose the image of l∞ is some line l = (a, b, c)^⊤, then the
               following matrix H will send l back to infinity:
                                [ 1  0  0 ]
                      H = H_a * [ 0  1  0 ]
                                [ a  b  c ]
                          where where H_a is any affine transformation
          
       The key to the affine upgrade is the behavior of the line at infinity. 
       The counterpart to this for the Euclidean upgrade is the behavior of the 
       “circular points.”
    
       Chap 6, Section 3 has more about euclidean upgrades in transformation
          for circular points and conics.
    
    Notes from Lec 8:
        Levels of reconstruction of a scene: projective, affine and euclidean components.
    
        If the camera intrinisc parameters, K, are not known, then only the
        projective reconstruction is possible, but this can be upgraded to 
        affine (parallelism preserved) and Euclidean (parallelism and orthogonality preserved) reconstructions.
    
        Given a set of point correspondences between two views {(x′1,x′2)} 
        we can get the Projective Structure X_p.
        where x' = x * K, that is, x = x' * K^-1.  x' are the image coordinates as pixels.
           first calculate F from the point correspondences, then use F to
           get the projection matrix for camera 2, P2, then triangulate to get
           X_p (which is the 3D point in projective space).
           caveat is that K, R, T from in P2 will not be unique.
           The canonical choice for these two projection matrices is:
               P1 = [ I | 0 ]
               P2 = [ ([T']_x)^T  F  | T' ]
           where T' = K*T and ||T'|| = 1
           and recall that T′ ∼ e2
    
           The triangulation uses DLT and SVD.
    
           for the case where there is no noise:
                X_P is SVD(M).V^T[last row]
           for the case where there is noise, the SVD solution is the initial
                values for a non-linear optimization method.
    
    NOTE: to solve affine reconstruction for the case of pure translation, 
    see Example 6.6 of Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;&quot;.
    For the case of pure rotation, see Example 6.10.
    
    */
    
     /**
     * given 2 sets of correspondence from 2 different images taken from
     * 2 cameras whose intrinsic and extrinsic parameters are known,
     * determine the world scene coordinates of the correspondence points.
     * This method simply uses triangulation on each correspondence pair.
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     * http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     * 
     * &lt;/pre&gt;
     * @param camera1 image 1 camera matrices of intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     * @param camera2 image 2 camera matrices of intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     * @param x1 the image 1 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * @param x2 the image 2 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * @return the world scene coordinates and the intrinsic and extrinsic
     * camera matrices (the later were given to the code, but are convenient to return in results).
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static ReconstructionResults calculateReconstruction(
        CameraParameters camera1, CameraParameters camera2,
        double[][] x1, double[][] x2) throws NotConvergedException {
        
<span class="nc bnc" id="L205" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L206">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="nc" id="L208">        int n = x1[0].length;</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L210">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
        
        /*
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (3) For each point correspondence, compute the point X in 3D space (triangularization)
        */
                        
<span class="nc" id="L219">        double[][] XW = new double[4][n];</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="nc" id="L221">            XW[i] = new double[n];</span>
        }
        double[] XWPt;
        
<span class="nc" id="L225">        double[][] x1Pt = new double[3][1];</span>
<span class="nc" id="L226">        double[][] x2Pt = new double[3][1];</span>
        int i, ii;
<span class="nc bnc" id="L228" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L229">            x1Pt[i] = new double[1];</span>
<span class="nc" id="L230">            x2Pt[i] = new double[1];</span>
        }
                    
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            for (ii = 0; ii &lt; 3; ++ii) {</span>
<span class="nc" id="L235">                x1Pt[ii][0] = x1[ii][i];</span>
<span class="nc" id="L236">                x2Pt[ii][0] = x2[ii][i];</span>
            }
            //length is 4
<span class="nc" id="L239">            XWPt = Triangulation.calculateWCSPoint(camera1, camera2, x1Pt, x2Pt);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (ii = 0; ii &lt; 4; ++ii) {</span>
<span class="nc" id="L241">                XW[ii][i] = XWPt[ii];</span>
            } 
        }
                
<span class="nc" id="L245">        ReconstructionResults rr = new ReconstructionResults();</span>
<span class="nc" id="L246">        rr.XW = XW;</span>

<span class="nc" id="L248">        return rr;</span>
    }
    
    /**
     * This is also called Projective Structure From Motion for the
     * Two-camera case.   it's a distorted version of euclidean 3d.
     * 
     * NOTE that because the camera calibration, that is, intrinsic parameters,
     * are not known, only the projective reconstruction is possible,
     * but this can be upgraded to 
     affine (parallelism preserved) and Euclidean (parallelism and orthogonality preserved) 
     reconstructions.
     To upgrade to an affine projection, need 3 vanishing points
     (see Section 9.2.2 of Belongie lec 9).
     To directly upgrade from projective to euclidean projection, need
     5 ground truth points in general position, that is, no 4 points
     are coplanar (see Section 9.3 of Belongie lec 9).
     * NOTE: this solution is fine for cases with no noise, otherwise, the
     * results should be the initial values for a non-linear optimization method.
     
     * The method uses the fundamental matrix to compute the camera matrices P1, P2
     * and then uses triangulation on each correspondence pair.
     * 
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     * http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     * 
     * other references:
     * Sect 7.2.1 of Szeliski 2010
     * &lt;/pre&gt;
     * @param x1 the image 1 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * NOTE: since intrinsic parameters are not known, users of this method should 
     * presumably center the coordinates in some manner 
     * (e.g. subtract the image center or centroid of points) since internally
     * an identity matrix is used for K.  
     * @param x2 the image 2 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * NOTE: since intrinsic parameters are not known, users of this method should 
     * presumably center the coordinates in some manner 
     * (e.g. subtract the image center or centroid of points).
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ProjectionResults calculateProjectiveReconstruction(
        double[][] x1, double[][] x2) throws NotConvergedException {
                        
<span class="nc bnc" id="L294" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L295">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="nc" id="L297">        int n0 = x1[0].length;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (x2[0].length != n0) {</span>
<span class="nc" id="L299">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (n0 &lt; 7) {</span>
<span class="nc" id="L302">            throw new IllegalArgumentException(&quot;need at least 7 points for the uncalirated camera (s) 2 view solution&quot;);</span>
        }
        
        /*
        Similar to CameraPose.calculateUsingEssentialMatrix()
        except for use of uncalibrated points and use of a different diagonal
        in constrcting the fundamental matrix.
                        
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (1) compute fundamental matrix FM from the correspondence x1, x2
        (2) compute the camera matrices P1, P2 from FM.
        (3) For each point correspondence, compute the point X in 3D space (triangularization)
        
        see also notes above from notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
        */
        
<span class="nc" id="L319">        DenseMatrix x1M = new DenseMatrix(x1);</span>
<span class="nc" id="L320">        DenseMatrix x2M = new DenseMatrix(x2);</span>
        
<span class="nc" id="L322">        EpipolarTransformer.NormalizedXY normXY1 = EpipolarTransformer.normalize(x1M);</span>
<span class="nc" id="L323">        EpipolarTransformer.NormalizedXY normXY2 = EpipolarTransformer.normalize(x2M);</span>
<span class="nc" id="L324">        DenseMatrix leftM = normXY1.getXy();</span>
<span class="nc" id="L325">        DenseMatrix rightM = normXY2.getXy();</span>
        
<span class="nc" id="L327">        double tolerance = 3.84; //3.84 5.99 7.82        </span>
<span class="nc" id="L328">        boolean useToleranceAsStatFactor = true;</span>
<span class="nc" id="L329">        ErrorType errorType = ErrorType.SAMPSONS;</span>
<span class="nc" id="L330">        EpipolarTransformationFit fitR = null;</span>
        
<span class="nc" id="L332">        boolean reCalcIterations = true;</span>
        
        //EpipolarTransformer tr = new EpipolarTransformer();
        
        /*
        DenseMatrix normalizedFM = tr.calculateEpipolarProjection(leftM, rightM);
        DenseMatrix vNFM = tr.validateSolution(normalizedFM, leftM, rightM);
        
        Distances distances = new Distances();
        if (useToleranceAsStatFactor) {
            fitR = distances.calculateError2(normalizedFM, leftM, rightM,
                    errorType, tolerance);
        } else {
            fitR = distances.calculateError(normalizedFM, leftM, rightM,
                    errorType, tolerance);
        }
        */
        
<span class="nc" id="L350">        boolean calibrated = false;</span>
                
<span class="nc" id="L352">        RANSACSolver solver = new RANSACSolver();</span>
<span class="nc" id="L353">        fitR = solver.calculateEpipolarProjection(</span>
            leftM, rightM, errorType, useToleranceAsStatFactor, tolerance,
                reCalcIterations, calibrated);
        
<span class="nc" id="L357">        DenseMatrix fm = EpipolarTransformer.denormalizeTheFundamentalMatrix(</span>
<span class="nc" id="L358">            fitR.getFundamentalMatrix(), </span>
<span class="nc" id="L359">            normXY1.getNormalizationMatrices(),</span>
<span class="nc" id="L360">            normXY2.getNormalizationMatrices());</span>
        
<span class="nc" id="L362">        double[][] _fm = MatrixUtil.convertToRowMajor(fm);</span>
        
<span class="nc" id="L364">        x1M = extractIndices(x1M, fitR.inlierIndexes);</span>
<span class="nc" id="L365">        x2M = extractIndices(x2M, fitR.inlierIndexes);</span>
<span class="nc" id="L366">        x1 = MatrixUtil.convertToRowMajor(x1M);</span>
<span class="nc" id="L367">        x2 = MatrixUtil.convertToRowMajor(x2M);</span>
        
<span class="nc" id="L369">        int n = x1[0].length;</span>
        
<span class="nc" id="L371">        System.out.println(&quot;RANSAC fit=&quot; + fitR.toString());</span>
        
        //(2) compute the camera matrices P1, P2 from FM.
        
<span class="nc" id="L375">        MatrixUtil.SVDProducts svdF = MatrixUtil.performSVD(_fm);</span>
        
<span class="nc bnc" id="L377" title="All 4 branches missed.">        assert(svdF.u[0].length == 3 &amp;&amp; svdF.u.length == 3);</span>
        
<span class="nc" id="L379">        double detU = MatrixUtil.determinant(svdF.u);</span>
<span class="nc" id="L380">        double detV = MatrixUtil.determinant(svdF.vT);</span>
        
<span class="nc" id="L382">        System.out.printf(&quot;SVD.u=\n%s\n&quot;, FormatArray.toString(svdF.u, &quot;%.3e&quot;));</span>
<span class="nc" id="L383">        System.out.printf(&quot;SVD.s=\n%s\n&quot;, FormatArray.toString(svdF.s, &quot;%.3e&quot;));</span>
<span class="nc" id="L384">        System.out.printf(&quot;SVD.vT=\n%s\n&quot;, FormatArray.toString(svdF.vT, &quot;%.3e&quot;));</span>
<span class="nc" id="L385">        System.out.printf(&quot;det(SVD.u)=%.2f\n&quot;, detU);</span>
<span class="nc" id="L386">        System.out.printf(&quot;det(SVD.vT)=%.2f\n&quot;, detV);</span>
        
        //H = +U * R_Z(+-90)^T * sigma_hat * V^T
<span class="nc" id="L389">        double[][] r90T = new double[3][3];</span>
<span class="nc" id="L390">        r90T[0] = new double[]{0, 1, 0};</span>
<span class="nc" id="L391">        r90T[1] = new double[]{-1, 0, 0};</span>
<span class="nc" id="L392">        r90T[2] = new double[]{0, 0, 1};</span>
        
<span class="nc" id="L394">        double[][] h = MatrixUtil.multiply(</span>
<span class="nc" id="L395">            MatrixUtil.multiplyByDiagonal(</span>
<span class="nc" id="L396">                MatrixUtil.multiply(svdF.u, r90T),</span>
                new double[]{svdF.s[0], svdF.s[1], svdF.s[2]}),
            svdF.vT);
        
        // last column in u is the second epipole and is the direction of vector t
<span class="nc" id="L401">        double[] t1 = MatrixUtil.extractColumn(svdF.u, 2);</span>
<span class="nc" id="L402">        double[] e2 = t1;</span>
<span class="nc" id="L403">        double[] e1 = svdF.vT[2];</span>
        
<span class="nc" id="L405">        System.out.printf(&quot;e1=%s\n&quot;, FormatArray.toString(e1, &quot;%.3e&quot;));</span>
<span class="nc" id="L406">        System.out.printf(&quot;e2=%s\n&quot;, FormatArray.toString(e2, &quot;%.3e&quot;));</span>
         
        // camera matrix P for left image = [I | 0 ]
<span class="nc" id="L409">        double[][] camera1 = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L411">            camera1[i][i] = 1;</span>
        }
        
        // Szeliksi 2010 eqn 7.34:  P0 =[I|0] and P0 =[H|e],
        //    and then he finishes w/ triangulation
        // kitani lecture has P2 = [ [e1]_x * F | e2 ]
        // Hartley &amp; Zisserman: has P2 = [ -[e2]_x^T * F | e2 ]
        //    note that slide 59 of http://16720.courses.cs.cmu.edu/lec/sfm.pdf
        //    also uses the Hartley &amp; Zisserman: version of P2 and refers to proof in 
        //    Forsyth &amp; Ponce Sec 8.3
        // Belongie uses P2 = [ [e2]_x^T * F | e2 ] and so does Ma et al. textbook (msks, &quot;Invitation to 3D&quot;
        // 
        
        // NOTE: not necessary to normalize the epipoles by the last value
        
<span class="nc" id="L426">        double[][] camera2 = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L428">            camera2[i] = new double[4];</span>
<span class="nc" id="L429">            System.arraycopy(h[i], 0, camera2[i], 0, 3);</span>
<span class="nc" id="L430">            camera2[i][3] = e2[i];</span>
        }
        
<span class="nc" id="L433">        System.out.printf(&quot;Szeliski P2\n%s\n&quot;, FormatArray.toString(camera2, &quot;%.3e&quot;));</span>
        
<span class="nc" id="L435">        CameraProjection P1 = new CameraProjection(camera1);</span>
<span class="nc" id="L436">        CameraProjection P2 = new CameraProjection(camera2);</span>
        
        double[][] XW;
        double[] XWPt;
<span class="nc" id="L440">        XW = new double[4][n];</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="nc" id="L442">            XW[i] = new double[n];</span>
        }
        
<span class="nc" id="L445">        double[][] x1Pt = new double[3][1];</span>
<span class="nc" id="L446">        double[][] x2Pt = new double[3][1];</span>
        int i, j;
<span class="nc bnc" id="L448" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L449">            x1Pt[i] = new double[1];</span>
<span class="nc" id="L450">            x2Pt[i] = new double[1];</span>
        }
        
<span class="nc bnc" id="L453" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L455">                x1Pt[j][0] = x1[j][i];</span>
<span class="nc" id="L456">                x2Pt[j][0] = x2[j][i];</span>
            }
<span class="nc" id="L458">            XWPt = Triangulation.calculateWCSPoint(P1, P2, x1Pt, x2Pt);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            for (j = 0; j &lt; 4; ++j) {</span>
<span class="nc" id="L460">                XW[j][i] = XWPt[j];</span>
            }
        }
        
<span class="nc" id="L464">        System.out.printf(&quot;Szeliski reconstruction\n%s\n&quot;, FormatArray.toString(XW, &quot;%.3e&quot;));</span>
        
<span class="nc" id="L466">        ProjectionResults rr = new ProjectionResults();</span>
<span class="nc" id="L467">        rr.XW = XW;</span>
<span class="nc" id="L468">        rr.projectionMatrices = MatrixUtil.zeros(3*2, 4);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L470">            System.arraycopy(P1.getP()[i], 0, rr.projectionMatrices[i], 0, 4);</span>
        }
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L473">            System.arraycopy(P2.getP()[i], 0, rr.projectionMatrices[3 + i], 0, 4);</span>
        }
<span class="nc" id="L475">        return rr;</span>
    }
   
    /**
     * TODO: proof read the algorithm and write test for this.
     * for the case of un-calibrated cameras viewing the same scene features,
     * recover the 3-D coordinates in WCS and the projection matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * 
     * The method implements the Sturm &amp; Triggs 1996 algorithm: 
     &quot;a method for the recovery of projective shape and motion from multiple 
     images of a scene by the factorization of a matrix containing the images 
     of all points in all views. This factorization is only possible when the
     image points are correctly scaled. The major technical contribution of 
     this paper is a practical method for the recovery of these scalings, 
     using only fundamental matrices and epipoles estimated from the image data.&quot;
     &quot;[it is a] closed form solutions, not iterative bundle-adjustment...&quot;
     * &lt;pre&gt;
     * references:
     * 
     * Sturm and Triggs 1996, 
    &quot;A Factorization Based Algorithm for Multi-Image Projective Structure and Motion&quot;
     https://link.springer.com/content/pdf/10.1007/3-540-61123-1_183.pdf
    
    see also proj_recons_fsvd.m from http://lear.inrialpes.fr/people/triggs/src/
    which has a very liberal copyright in the file COPYRIGHT
    Copyright Bill Triggs (http://www.inrialpes.fr/movi/people/Triggs),
    INRIA (http://www.inria.fr) and CNRS (http://www.cnrs.fr),
    1995-2002. All rights reserved.

    You may use and distribute [*] this work with or without modification,
    for any purpose and without fee or royalty, subject to the following
    conditions:
       (see file COPYRIGHT)
    
     * &lt;/pre&gt;
     * 
     * NOTE: Sturm &amp; Triggs 1996 state in their code, &quot;% The projective output 
     frame is numerically well-conditioned, but otherwise *completely* 
     arbitrary. It has *no* relation to any Euclidean frame.
     * 
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ProjectionResults calculateProjectiveReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                        
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L531">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L534">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L536">        int nFeatures = x[0].length / mImages;</span>
        
        // need at least 7 points in each image for the point version of fundamental
        // matrix.
        // not implementing the line version as Triggs in another paper states
        //    that they may be more affected by outliers
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (nFeatures &lt; 7) {</span>
<span class="nc" id="L543">            throw new IllegalArgumentException(&quot;need at least 7 points per image&quot;);</span>
        }
        
        /*
        3.3 Outline of the Algorithm
        The complete algorithm is composed of the following steps.
        i. Normalize the image coordinates, by applying transformations Ti.
        2. Estimate the fundamental matrices and epipoles with the method of [Har95].
        3. Determine the scale factors Aip using equation (3).
        4. Build the rescaled measurement matrix W.
        5. Balance W by column-wise and &quot;triplet-of-rows&quot;-wise scalar mutliplications.
        6. Compute the SVD of the balanced matrix W.
        7. From the SVD, recover projective motion and shape.
        8. Adapt projective motion, to account for the normalization transformations Ti of
        step 1.
        */
                
        // following proj_recons_fsvd.m
        //    pairs of image sets can be formed either by using the first
        //    image as x1 for all images, or chaining them all together.
        // i.e. [(0,1), (0, 2), (0,3)] or [(0,1), (1,2), (2,3)].
        // choosing the later here.
        
<span class="nc" id="L566">        RANSACSolver ransac = new RANSACSolver();</span>
<span class="nc" id="L567">        double[] e12 = new double[3];</span>
        EpipolarTransformationFit fit;
        double[][] fm;
<span class="nc" id="L570">        ErrorType errorType = ErrorType.DIST_TO_EPIPOLAR_LINE;</span>
<span class="nc" id="L571">        boolean useToleranceAsStatFactor = true;</span>
<span class="nc" id="L572">        double tolerance = 3.84;</span>
        // TODO: estimate this:
<span class="nc bnc" id="L574" title="All 6 branches missed.">        boolean recalcIterations = (nFeatures &gt; 100 || (mImages &gt; 10 &amp;&amp; nFeatures &gt; 20));</span>
<span class="nc" id="L575">        boolean calibrated = false;</span>
        
        int i, j;
        // image pairs extracted from x:
        double[][] x1, x2;
        // the normalization centroidX, centroidY, and sigma values applied to x1 and x2:
<span class="nc" id="L581">        double[] tt = new double[3*mImages];</span>
        
        // use a reference depth of 1 for first image's features, as have no measurements for any depths to bootstrap from.
<span class="nc" id="L584">        double[][] lambdas = MatrixUtil.zeros(mImages, nFeatures);</span>
<span class="nc" id="L585">        Arrays.fill(lambdas[0], 1.);</span>
        
<span class="nc" id="L587">        x1 = extractAndNormalize(x, 0, nFeatures, tt);</span>
        DenseMatrix x1M, x2M;
<span class="nc" id="L589">        x1M = new DenseMatrix(x1);</span>
<span class="nc" id="L590">        double[] x1p = new double[3];</span>
<span class="nc" id="L591">        double[] x2p = new double[3];</span>
        double[] x2e, tmp;
        double tmp2, x2esq;
        
        // format x into shape W (3*mImages X nFeatures):
        //  row 0:2 = image 1 points where row 0 is the x coordinates, row 1 is the y coordinates
        //  row 3:5 = image 2 points
<span class="nc" id="L598">        double[][] w = MatrixUtil.zeros(3*mImages, nFeatures);</span>
<span class="nc" id="L599">        System.arraycopy(x1[0], 0, w[0], 0, nFeatures);</span>
<span class="nc" id="L600">        System.arraycopy(x1[1], 0, w[1], 0, nFeatures);</span>
<span class="nc" id="L601">        System.arraycopy(x1[2], 0, w[2], 0, nFeatures);</span>
        
<span class="nc bnc" id="L603" title="All 2 branches missed.">        for (i = 1; i &lt; mImages; ++i) {</span>
            
<span class="nc" id="L605">            x2 = extractAndNormalize(x, i, nFeatures, tt);</span>
<span class="nc" id="L606">            x2M = new DenseMatrix(x2);</span>
            
<span class="nc" id="L608">            System.arraycopy(x2[0], 0, w[i*3], 0, nFeatures);</span>
<span class="nc" id="L609">            System.arraycopy(x2[1], 0, w[i*3+1], 0, nFeatures);</span>
<span class="nc" id="L610">            System.arraycopy(x2[2], 0, w[i*3+2], 0, nFeatures);</span>
            
<span class="nc" id="L612">            fit = ransac.calculateEpipolarProjection(x1M, x2M, errorType, </span>
                useToleranceAsStatFactor, tolerance, recalcIterations, calibrated);
            
<span class="nc" id="L615">            fm = MatrixUtil.convertToRowMajor(fit.getFundamentalMatrix());</span>
            
            /*
            TODO: consider keeping only the inliers in a future version that handles
            occlusion.  by imputation or applied factorization or other means...
            x1M = extractIndices(x1M, fitR.inlierIndexes);
            x2M = extractIndices(x2M, fitR.inlierIndexes);
            x1 = MatrixUtil.convertToRowMajor(x1M);
            x2 = MatrixUtil.convertToRowMajor(x2M);
            int nFeaturesI = x1[0].length;
            */
            
            // note: e12 is not normalized by last component
<span class="nc" id="L628">            calculateLeftEpipole(fit.getFundamentalMatrix(), e12);</span>
            
<span class="nc bnc" id="L630" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L631">                extractColumn(x1, j, x1p);</span>
<span class="nc" id="L632">                extractColumn(x2, j, x2p);</span>
                
                //xe = cross(x2_j, e12);  // same as x2 cross -e21
<span class="nc" id="L635">                x2e = MatrixUtil.crossProduct(x2p, e12);</span>
                
                //lambda(i,j) = lambda(x1,j) * abs((x1_j' * FM * xe) / (xe' *xe));
                //    note: epipolar line2 = x1_j' * FM
<span class="nc" id="L639">                x2esq = MatrixUtil.innerProduct(x2e, x2e);</span>
                
<span class="nc" id="L641">                tmp = MatrixUtil.multiplyRowVectorByMatrix(x1p, fm);</span>
                
<span class="nc" id="L643">                tmp2 = MatrixUtil.innerProduct(tmp, x2e);</span>
<span class="nc" id="L644">                lambdas[i][j] = lambdas[i-1][j] * Math.abs(tmp2/x2esq);</span>
            }
            
<span class="nc" id="L647">            x1 = x2;</span>
<span class="nc" id="L648">            x1M = x2M;</span>
        }
        
        /*
        4. Build the rescaled measurement matrix W.
        5. Balance W by column-wise and &quot;triplet-of-rows&quot;-wise scalar mutliplications.
        
        as stated in Sturm &amp; Triggs 1996 Section 3.2, the balancing of the
        rescaled measurement matrix by Q's then P's can be replaced by
        balancing the m x n matrix lambdas instead of W because of the simplification
        of working with normalized image coordinates Q.
        The balance operations are demonstrated in proj_recons_fsvd.m
        */
<span class="nc" id="L661">        double eps = 1.e-11;</span>
        double[] lambdaj;
        int k;
        // authors find 2 iterations is heuristically enough:
<span class="nc bnc" id="L665" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L667">                lambdaj = MatrixUtil.extractColumn(lambdas, j);</span>
<span class="nc" id="L668">                tmp2 = MatrixUtil.lPSum(lambdaj, 2);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if (Math.abs(tmp2) &lt; eps) { </span>
<span class="nc" id="L670">                    tmp2 = eps;</span>
                }
<span class="nc bnc" id="L672" title="All 2 branches missed.">                for (k = 0; k &lt; mImages; ++k) {</span>
<span class="nc" id="L673">                    lambdas[k][j] = lambdaj[k] / tmp2;</span>
                }
            }
<span class="nc bnc" id="L676" title="All 2 branches missed.">            for (k = 0; k &lt; mImages; ++k) {</span>
<span class="nc" id="L677">                tmp2 = MatrixUtil.lPSum(lambdas[k], 2);</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                if (Math.abs(tmp2) &lt; eps) { </span>
<span class="nc" id="L679">                    tmp2 = eps;</span>
                }
<span class="nc" id="L681">                MatrixUtil.multiply(lambdas[k], 1./tmp2);</span>
            }
        }
        
        // rescale the image points
<span class="nc bnc" id="L686" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L688">                w[3*i + 0][j] *= lambdas[i][j];</span>
<span class="nc" id="L689">                w[3*i + 1][j] *= lambdas[i][j];</span>
<span class="nc" id="L690">                w[3*i + 2][j] *= lambdas[i][j];</span>
            }
        }
        
        /*
        6. Compute the SVD of the balanced matrix W.
        7. From the SVD, recover projective motion and shape.
        8. Adapt projective motion, to account for the normalization transformations Ti of
        step 1.
        */
        
        // if the number of images is larger than 10 or the number of features
        //   is greater than 30, will use cur decomposition
        double[][] u, vT;
        double[][] s;
        //double[][] wRescaled;
<span class="nc bnc" id="L706" title="All 4 branches missed.">        if (mImages &gt; 10 || nFeatures &gt; 30) {</span>
<span class="nc" id="L707">            CUR cur = CURDecomposition.calculateDecomposition(w, 4);</span>
<span class="nc" id="L708">            SVDProducts curSVD = cur.getApproximateSVD();</span>
<span class="nc" id="L709">            u = curSVD.u;</span>
<span class="nc" id="L710">            vT = curSVD.vT;</span>
<span class="nc" id="L711">            s = curSVD.sigma;</span>
            
            // Sturm &amp; Triggs divide by the largest eigenvalue:
<span class="nc" id="L714">            MatrixUtil.multiply(s, 1./s[0][0]);</span>
            
            //wRescaled = cur.getResult();
<span class="nc" id="L717">        } else {</span>
<span class="nc" id="L718">            SVDProducts svd = MatrixUtil.performSVD(w);</span>
            
            //reduce rank to 4
<span class="nc" id="L721">            u = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 3);</span>
<span class="nc" id="L722">            vT = MatrixUtil.copySubMatrix(svd.vT, 0, 3, 0, svd.vT[0].length-1);</span>
            
<span class="nc" id="L724">            s = MatrixUtil.zeros(4, 4);</span>
<span class="nc" id="L725">            s[0][0] = svd.s[0];</span>
<span class="nc" id="L726">            s[1][1] = svd.s[1];</span>
<span class="nc" id="L727">            s[2][2] = svd.s[2];</span>
<span class="nc" id="L728">            s[3][3] = svd.s[3];</span>
            
            /*double[][] sqrts4 = MatrixUtil.zeros(4, 4);
            sqrts4[0][0] = Math.sqrt(svd.s[0]);
            sqrts4[1][1] = Math.sqrt(svd.s[1]);
            sqrts4[2][2] = Math.sqrt(svd.s[2]);
            sqrts4[3][3] = Math.sqrt(svd.s[3]);

            u = MatrixUtil.multiply(u4, sqrts4);
            vT = MatrixUtil.multiply(sqrts4, vT4);
            wRescaled = MatrixUtil.multiply(u, vT);
            */
            
            // Sturm &amp; Triggs divide by the largest eigenvalue:
<span class="nc" id="L742">            MatrixUtil.multiply(s, 1./s[0][0]);</span>
        }
        
        //Ps = fliplr(U(:,1:4));             // 3*MImages X 4
        //Xs = flipud(S(1:4,1:4)*V(:,1:4)'); // 4 X 4*mImages
<span class="nc" id="L747">        double[][] ps = MatrixUtil.copy(u);</span>
<span class="nc" id="L748">        MatrixUtil.flipLR(ps);</span>
<span class="nc" id="L749">        double[][] XW = MatrixUtil.multiply(s, vT);</span>
<span class="nc" id="L750">        MatrixUtil.flipUD(XW);</span>
   
        //denormalize ps.  = ps * T^-1
        // tt is the normalization centroidX, centroidY, and sigma values applied to x1 and x2:
        /*
                 | 1  0  xc |   | s  0   0 |   | s   0  xc |
          T^-1 = | 0  1  yc | * | 0  s   0 | = | 0   s  yc |
                 | 0  0   1 |   | 0  0   1 |   | 0   0   1 |
        */
<span class="nc" id="L759">        double[][] tInv = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L760">        tInv[2][2] = 1;</span>
        double ts, txc, tyc;
        double[] p0, p1, p2;
<span class="nc" id="L763">        double[][] p = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L765">            txc = tt[3*i];</span>
<span class="nc" id="L766">            tyc = tt[3*i + 1];</span>
<span class="nc" id="L767">            ts = tt[3*i + 2];</span>
<span class="nc" id="L768">            tInv[0][0] = ts;</span>
<span class="nc" id="L769">            tInv[1][1] = ts;</span>
<span class="nc" id="L770">            tInv[0][2] = txc;</span>
<span class="nc" id="L771">            tInv[1][2] = tyc;</span>
            
<span class="nc" id="L773">            p0 = ps[3*mImages];</span>
<span class="nc" id="L774">            p1 = ps[3*mImages + 1];</span>
<span class="nc" id="L775">            p2 = ps[3*mImages + 2];</span>
<span class="nc" id="L776">            System.arraycopy(p0, 0, p[0], 0, 4);</span>
<span class="nc" id="L777">            System.arraycopy(p1, 0, p[1], 0, 4);</span>
<span class="nc" id="L778">            System.arraycopy(p2, 0, p[2], 0, 4);</span>
            
<span class="nc" id="L780">            p = MatrixUtil.multiply(p, tInv);</span>
            
<span class="nc" id="L782">            System.arraycopy(p[0], 0, ps[3*mImages], 0, 4);</span>
<span class="nc" id="L783">            System.arraycopy(p[1], 0, ps[3*mImages + 1], 0, 4);</span>
<span class="nc" id="L784">            System.arraycopy(p[2], 0, ps[3*mImages + 2], 0, 4);</span>
        }
        
<span class="nc" id="L787">        ProjectionResults rr = new ProjectionResults();</span>
<span class="nc" id="L788">        rr.XW = XW;</span>
<span class="nc" id="L789">        rr.projectionMatrices = ps;</span>
        
<span class="nc" id="L791">        return rr;</span>
    }
    
     /**
     * given correspondence between two images in image coordinates calculate 
     * the extrinsic camera parameters and the 3-D points.
     * 
     * This method calculates the essential matrix and uses the SVD of it to
     * extract the translation and possible rotation matrices which are
     * filtered to find the best while calculating triangulation for each point.
     * 
     * Note that the absolute translation between the two cameras can never be 
     * recovered from pure image measurements alone, regardless of how many 
     * cameras or points are used as ground control points are
     * needed.
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     Szeliski 2010, Chapter 7, and eqn (7.25).
     Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;, pg 121 
     * &lt;/pre&gt;
     * @param k1 intrinsic camera matrix for image 1 in units of pixels.
     * @param k2 intrinsic camera matrix for image 2 in units of pixels.
     * @param x1 the image 1 set of correspondence points in image reference frame.  
     * format is 3 x N where N is the number of points.
     * @param x2 the image 2 set of correspondence points in image reference frame.  
     * format is 3 x N where N is the number of points.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static ReconstructionResults calculateUsingEssentialMatrix(
        double[][] k1, double[][] k2,
        double[][] x1, double[][] x2) throws NotConvergedException {
                
<span class="pc bpc" id="L825" title="2 of 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L826">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="fc" id="L828">        int n = x1[0].length;</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L830">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
        
        /*
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (1) compute fundamental matrix FM from the correspondence x1, x2
        (2) compute the camera matrices P1, P2 from FM.
        (3) For each point correspondence, compute the point X in 3D space (triangularization)
        */
        
<span class="fc" id="L841">        double[][] k1IntrInv = Camera.createIntrinsicCameraMatrixInverse(k1);</span>
<span class="fc" id="L842">        double[][] k2IntrInv = Camera.createIntrinsicCameraMatrixInverse(k2);</span>
        
        // the direction of the points is calculated by K^-1 * x
<span class="fc" id="L845">        double[][] x1Direction = MatrixUtil.multiply(k1IntrInv, x1);</span>
<span class="fc" id="L846">        double[][] x2Direction = MatrixUtil.multiply(k2IntrInv, x2);</span>
                
<span class="fc" id="L848">        DenseMatrix x1M = new DenseMatrix(x1Direction);</span>
<span class="fc" id="L849">        DenseMatrix x2M = new DenseMatrix(x2Direction);</span>
        
        // normalizing by unit standard to improve results of epipolar solution:
<span class="fc" id="L852">        EpipolarTransformer.NormalizedXY normXY1 </span>
<span class="fc" id="L853">            = EpipolarTransformer.normalizeUsingUnitStandard(x1M);</span>
<span class="fc" id="L854">        EpipolarTransformer.NormalizedXY normXY2 </span>
<span class="fc" id="L855">            = EpipolarTransformer.normalizeUsingUnitStandard(x2M);</span>
        
<span class="fc" id="L857">        DenseMatrix leftM = normXY1.getXy();</span>
<span class="fc" id="L858">        DenseMatrix rightM = normXY2.getXy();</span>
        
<span class="fc" id="L860">        double tolerance = 3.84; //3.84 5.99 7.82        </span>
<span class="fc" id="L861">        boolean useToleranceAsStatFactor = true;</span>
<span class="fc" id="L862">        ErrorType errorType = ErrorType.SAMPSONS;</span>
<span class="fc" id="L863">        EpipolarTransformationFit fitR = null;</span>
<span class="fc" id="L864">        boolean reCalcIterations = true;</span>
        
        DenseMatrix normalizedE;
        
        /*EpipolarTransformer tr = new EpipolarTransformer();        
        normalizedE = tr.calculateEpipolarProjection(leftM, rightM);
        DenseMatrix vNFM = tr.validateSolution(normalizedFM, leftM, rightM);
        
        Distances distances = new Distances();
        if (useToleranceAsStatFactor) {
            fitR = distances.calculateError2(vNFM, leftM, rightM,
                    errorType, tolerance);
        } else {
            fitR = distances.calculateError(vNFM, leftM, rightM,
                    errorType, tolerance);
        }*/
        
        //if true, solves for the Essential Matrix, else solves
        //for the Fundamental Matrix.  The difference is in the diagonal used for
        //dimension reduction.
<span class="fc" id="L884">        boolean coordsAreInCameraRefFrame = true;</span>
        
<span class="fc" id="L886">        RANSACSolver solver = new RANSACSolver();</span>
<span class="fc" id="L887">        fitR = solver.calculateEpipolarProjection(</span>
            leftM, rightM, errorType, useToleranceAsStatFactor, tolerance,
                reCalcIterations, coordsAreInCameraRefFrame);
        
<span class="fc" id="L891">        System.out.println(&quot;RANSAC fit=&quot; + fitR.toString());</span>
        
<span class="fc" id="L893">        normalizedE = fitR.getFundamentalMatrix();</span>
        
        // this is now back in the reference frame of the x1Direction and x2Direction
<span class="fc" id="L896">        DenseMatrix essentialM = EpipolarTransformer.denormalizeTheFundamentalMatrix(</span>
<span class="fc" id="L897">            normalizedE, normXY1.getNormalizationMatrices(),</span>
<span class="fc" id="L898">            normXY2.getNormalizationMatrices());</span>
        
        //=========
<span class="fc" id="L901">        double[][] _essentialMatrix = MatrixUtil.convertToRowMajor(essentialM);</span>
        
<span class="fc" id="L903">        MatrixUtil.SVDProducts svdE = MatrixUtil.performSVD(_essentialMatrix);</span>
        
<span class="pc bnc" id="L905" title="All 4 branches missed.">        assert(svdE.u[0].length == 3 &amp;&amp; svdE.u.length == 3);</span>
        
<span class="fc" id="L907">        double detU = MatrixUtil.determinant(svdE.u);</span>
<span class="fc" id="L908">        double detV = MatrixUtil.determinant(svdE.vT);</span>
        
<span class="fc" id="L910">        System.out.printf(&quot;SVD.u=\n%s\n&quot;, FormatArray.toString(svdE.u, &quot;%.3e&quot;));</span>
<span class="fc" id="L911">        System.out.printf(&quot;SVD.s=\n%s\n&quot;, FormatArray.toString(svdE.s, &quot;%.3e&quot;));</span>
<span class="fc" id="L912">        System.out.printf(&quot;SVD.vT=\n%s\n&quot;, FormatArray.toString(svdE.vT, &quot;%.3e&quot;));</span>
<span class="fc" id="L913">        System.out.printf(&quot;det(SVD.u)=%.2f\n&quot;, detU);</span>
<span class="fc" id="L914">        System.out.printf(&quot;det(SVD.vT)=%.2f\n&quot;, detV);</span>
        
        /*
        Szeliski 2010 chap 7:
        Once an estimate for the essential matrix E has been recovered, 
        the direction of the translation vector t can be estimated. 
        
        Note that the absolute distance between the two cameras can never 
        be recovered from pure image measurements alone without knowledge 
        about absolute camera and point positions or distances, often called ground 
        control points in photogrammetry.
        */
        
        // det(R)=1 is a proper rotation matrix.  rotation angles are counterclockwise.
        //           it's a special orthogonal matrix and provides the
        //           defining matrix representation of the group of proper n-dimensional rotations, denoted
        //           by SO(n). http://scipp.ucsc.edu/~haber/ph251/rotreflect_17.pdf
        // det(R)=-1 is an improper rotation matrix representing rotations that
        //           require mirrors.
        //           The most general improper rotation matrix is a product of a proper rotation by an
        //           angle θ about some axis nˆ and a mirror reflection through a plane that passes through
        //           the origin and is perpendicular to nˆ.  NOTE: nˆ is determined by
        //           the right hand rule.
        
        /*
        Sect 7.2 of Szeliski 2010 eqn (7.25) introduces
        R3 and R4 constructed from -U as 2 more rotation possibilities to be tested
        and that is necessary in some cases where det(R) would otherwise be -1
        (reflection).
        ...we only know both E and tˆup to a sign. Furthermore, the matrices U and V
        are not guaranteed to be rotations (you can flip both their signs and 
        still get a valid SVD).   
        For this reason, we have to generate all four possible rotation matrices
        
        R = +-U * R_Z(+-90)^T * V^T
           and keep the 2 whose determinant = 1
        */
<span class="fc" id="L951">        double[][] r1 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L952">        double[][] r2 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L953">        double[][] u = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L954">        populateWithDet1Rs(svdE, r1, r2, u);</span>
        
        // last column in u is the second epipole and is the direction of vector t
<span class="fc" id="L957">        double[] t1 = MatrixUtil.extractColumn(u, 2);</span>
<span class="fc" id="L958">        double[] t2 = Arrays.copyOf(t1, t1.length);</span>
<span class="fc" id="L959">        MatrixUtil.multiply(t2, -1); </span>
        
<span class="fc" id="L961">        System.out.printf(&quot;R1=\n%s\n&quot;, FormatArray.toString(r1, &quot;%.3e&quot;));</span>
<span class="fc" id="L962">        System.out.printf(&quot;R2=\n%s\n&quot;, FormatArray.toString(r2, &quot;%.3e&quot;));</span>
<span class="fc" id="L963">        System.out.printf(&quot;t1=\n%s\n&quot;, FormatArray.toString(t1, &quot;%.3e&quot;));</span>
<span class="fc" id="L964">        System.out.printf(&quot;t2=\n%s\n&quot;, FormatArray.toString(t2, &quot;%.3e&quot;));</span>
        
        //then of the 4 possible choices find the one with largest number of positive Z.
          
        //NOTE: the last column vector in u is the smallest
        //    eigenvector.  it is epipole2, that is, the right image position 
        //    of the epipolar projection of the left camera center.
        //    it's int the left null space of E.
                        
<span class="fc" id="L973">        x1M = extractIndices(new DenseMatrix(x1Direction), fitR.inlierIndexes);</span>
<span class="fc" id="L974">        x2M = extractIndices(new DenseMatrix(x2Direction), fitR.inlierIndexes);</span>
<span class="fc" id="L975">        x1 = MatrixUtil.convertToRowMajor(x1M);</span>
<span class="fc" id="L976">        x2 = MatrixUtil.convertToRowMajor(x2M);</span>
        
<span class="fc" id="L978">        double[][] rSelected = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L979">        double[] tSelected = new double[3];</span>
<span class="fc" id="L980">        double[][] XW = MatrixUtil.zeros(4, x1[0].length);</span>
<span class="fc" id="L981">        bestInCheiralityTest(x1, x2, k1, k2, r1, r2, t1, t2, rSelected, tSelected, XW);  </span>
        
<span class="fc" id="L983">        ReconstructionResults rr = new ReconstructionResults();</span>
<span class="fc" id="L984">        rr.XW = XW;</span>
<span class="fc" id="L985">        rr.k1ExtrRot = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L986">        rr.k1ExtrTrans = new double[]{0, 0, 0};</span>
<span class="fc" id="L987">        rr.k1Intr = k1;</span>
<span class="fc" id="L988">        rr.k2ExtrRot = rSelected;</span>
<span class="fc" id="L989">        rr.k2ExtrTrans = tSelected;</span>
<span class="fc" id="L990">        rr.k2Intr = k2;</span>
<span class="fc" id="L991">        rr.essentialMatrix = _essentialMatrix;</span>
<span class="fc" id="L992">        rr.svd = svdE;</span>
<span class="fc" id="L993">        rr.fundamentalMatrix = null;</span>

<span class="fc" id="L995">        return rr;        </span>
    }

    /**
     * NOTE: not ready for use yet.
     * 
     * TODO: proof read the algorithm and write test for this.
     * for the case where the cameras are viewing small, distant scenes,
     * recover the 3-D coordinates in WCS and the rotation matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * assumes an orthographic camera model.
     * can use the orthographic camera model when
     *    (the average distance of an object from the camera) 
     *     .geq. 10*(the average width of the object (measured along the optical axis of the camera).
     * &lt;pre&gt;
     * references:
     * 
     * lecture 16 notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
     * http://www-cse.ucsd.edu/classes/sp04/cse252b/notes/lec16/lec16.pdf
     * 
     * lectures of Deva Ramanan at http://16720.courses.cs.cmu.edu/lec/sfm.pdf
     * .:w
     * 
     * Tomasi &amp; Kanade 1991, &quot;Shape and motion from image streams under 
     * orthography: a factorization method&quot;, International journal of computer vision 
     * 
     *  Morita and Kanade 1997 for solving Q.
         T. Morita and T. Kanade, A Sequential Factorization Method for Recovering Shape and Motion
         from Image Streams, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 19,
         no.8, pp.858-867, Aug 1997  (1994?)
         
     * Higham, 1988, “Computing a Nearest Symmetric Positive Semidefinite Matrix,” 
     *    Linear Algebra and Appl., 103:103-118, 1988
     * 
     * a great summary of the above:
     * http://note.sonots.com/SciSoftware/Factorization.html#cse252b
     * http://note.sonots.com/?plugin=attach&amp;refer=SciSoftware%2FFactorization&amp;openfile=Factorization.pdf
     * 
     * and a derivation of the geometry of the tracking equation:
     * Birchfield 1997, &quot;Derivation of Kanade-Lucas-Tomasi Tracking Equation&quot;
     * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.185.413&amp;rep=rep1&amp;type=pdf
     * &lt;/pre&gt;
     * NOTE: could overload this method to enable handling of occlusion 
     * following Section 5 of Tomasi &amp; Kanade 1991, but might want to alter the
     * algorithm to use geometric median in place of centroid so that the
     * &quot;centers&quot; are not as affected by removing or adding a point.
     * NOTE: comments from Poelman &amp; Kanade 1992:
     * Orthographic projection does not account for the apparent change in size 
     * of an object as it moves toward or away from the camera, nor the different 
     * angle from which an object is viewed as it moves parallel to the image plane.
     * NOTE: consider implementing Section 3.3 Sequential Factorization Algorithm
     * from the Morita &amp; Kanade 1997 paper (1994?)
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static OrthographicProjectionResults calculateAffineReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                                
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1062">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1065">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="fc" id="L1067">        int nFeatures = x[0].length / mImages;</span>

        //TODO: check this
        //2mn &gt;= 8m + 3n – 12
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1072">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        // Tomasi &amp; Kanade 1992: An image stream can be represented by the
        //  2*F X P measurment matrix W of image coordinates of P points
        // tracked through F frames.
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size is mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size is mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create matrix WC = W - t
        
        // row[0] = image_0_x[0], image_0_x[1], image_0_x[2], ...
        // row[1] = image_1_x[0], image_1_x[1], image_1_x[2], ...
        // ...
        // row[mImages+0] = image_0_y[0], image_0_y[1], image_0_y[2], ...
<span class="fc" id="L1094">        double[][] w = MatrixUtil.zeros(2*mImages, nFeatures);</span>
        // t points to the camera's focal point
<span class="fc" id="L1096">        double[] t = new double[2*mImages];</span>
        int i, j;
        int m, n, rowU, rowV, col;
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="fc" id="L1100">            rowU = m;</span>
<span class="fc" id="L1101">            rowV = mImages + m;</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="fc" id="L1103">                col = nFeatures*m + n;</span>
<span class="fc" id="L1104">                w[rowU][n] = x[0][col];</span>
<span class="fc" id="L1105">                t[rowU] += x[0][col];</span>
<span class="fc" id="L1106">                w[rowV][n] = x[1][col];</span>
<span class="fc" id="L1107">                t[rowV] += x[1][col];</span>
            }
<span class="fc" id="L1109">            t[rowU] /= (double)nFeatures;</span>
<span class="fc" id="L1110">            t[rowV] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="fc" id="L1114">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="fc" id="L1117">                wC[i][n] -= t[i];</span>
            }
        }
        
        // see Fig 3.1 of Tomasi &amp; Kanade 1991 or Fig 2. of Belongie lecture notes
        
        // under orthography, this coordinate centered matrix has rank 3
        // and can be factored into the product of 2 matrices, R and S:
        // the camera rotation matrix R (size 2FX3) and 
        // the shape matrix S (size 3XP) which is shape in a coordinate system 
        // attached to the object centroid.
        //The two components of the camera translation along the image plane
        // are computed as averages of the rows of W
                
        // the registered measurement matrix is highly rank deficient
        // eqn (3.11)
<span class="fc" id="L1133">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        
        // Tomasi &amp; Kanade 1992,eqn (3.12): 1st 3 columns of U, upper 3X3 of S, and first 3 rows of V^T
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="fc" id="L1139">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="fc" id="L1140">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L1141">        s3[0][0] = svd.s[0];</span>
<span class="fc" id="L1142">        s3[1][1] = svd.s[1];</span>
<span class="fc" id="L1143">        s3[2][2] = svd.s[2];</span>
<span class="fc" id="L1144">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="fc" id="L1145">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="fc" id="L1146">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="fc" id="L1147">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="fc" id="L1148">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="fc" id="L1155">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="fc" id="L1156">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
        
        //Tamasi &amp; Kanade
        // (2*mImages)X3
<span class="fc" id="L1160">        double[][] rC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="fc" id="L1162">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="fc" id="L1164">        System.out.printf(&quot;rC=\n%s\n&quot;, FormatArray.toString(rC, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L1166">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
<span class="fc" id="L1167">        System.out.printf(&quot;rC*sC=\n%s\n&quot;, FormatArray.toString(</span>
<span class="fc" id="L1168">            MatrixUtil.multiply(rC, sC), </span>
            &quot;%.4e&quot;));
        
        // wC = rC * sC  
        //rC and sC are linear translations of the true rotation matrix R and
        //  the true shape matrix S, respectively.
        // Morita and Kanade: the decomposition is not completely unique.  
        //     it's unique only up to an affine transformation
        
        //Tomasi &amp; Kanade eqn (3.15) and Belongie Section 16.4.4 (c)
        // metric constraints:  
        // note that R is composed of rows of unit vectors.
        // note that the first F rows in R are orthogonal to the last F rows in R.
        
        /*
        NOTE: can make a rotation matrix orthonormal:
        svd = MatrixUtil.performSVD(rotationMAtrix);
        ortho = MatrixUtil.multiply(svd.u, MatrixUtil.transpose(svd.vT));
        detR = MatrixUtil.determinant(ortho);
        assert(Math.abs(detR - 1.)&lt;1.e-7);

        if no translation, can use procrustes to get difference in rotation:
           double[][] ar = Rotation.procrustesAlgorithmForRotation(rot1, _r2);
        */
        
<span class="fc" id="L1193">        double[][] q = solveForTransformationToOrthoNormal(rC);</span>
        
       
        //Q is an affine transformation which transforms rC into R in motion space
        //   and the inverse of Q transforms sC into S in the shape space
        
        // finding Q is called &quot;Metric Transformation&quot;
        
        // rC size is  (2*mImages)X3
        // sC size is 3XnFeatures
<span class="fc" id="L1203">        double[][] r2 = MatrixUtil.multiply(rC, q);</span>
        
        //assertDotProductMetrics(r2, mImages);
        
<span class="fc" id="L1207">        double[][] s2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q), sC);</span>
        
        // assert that wC is the same as wC2
<span class="fc" id="L1210">        System.out.printf(&quot;r2*s2=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(r2, s2), </span>
            &quot;%.4e&quot;));
        
        /*
        from Tomasi &amp; Kanade 1992:
        If desired, align the first camera reference system with the world 
        reference system by forming the products R*R_0 and R_0^T*S, 
        where the orthonormal matrix R_0 = [i1 j1 k1] rotates the first camera 
        reference system into the identity matrix
        
        i0x i0y i0z    *  r0ix  r0jx  r0kx   = (i0 dot r0i)  (i0 dot r0j) (i0 dot r0k)
        i1x i1y i1z       r0iy  r0jy  r0ky
        i2x i2y i2z       r0iz  r0jz  r0kz
        i3x i3y i3z
        ...
        j0x j0y j0z
        j1x j1y j1z
        */
        
<span class="fc" id="L1229">        System.out.printf(&quot;r2=\n%s\n&quot;, FormatArray.toString(r2, &quot;%.4e&quot;));</span>
 
        /* r2 * R0 = I
                R0 = inv(r2)
        */
<span class="fc" id="L1234">        double[][] rFirst = new double[3][3];</span>
<span class="fc" id="L1235">        rFirst[0] = Arrays.copyOf(r2[0], r2[0].length);</span>
<span class="fc" id="L1236">        rFirst[1] = Arrays.copyOf(r2[mImages], r2[mImages].length);</span>
<span class="fc" id="L1237">        rFirst[2] = MatrixUtil.crossProduct(rFirst[0], rFirst[1]);</span>
<span class="fc" id="L1238">        double[][] r0 = MatrixUtil.pseudoinverseFullColumnRank(rFirst);</span>
        
<span class="fc" id="L1240">        System.out.printf(&quot;r0= \n%s\n&quot;, FormatArray.toString(r0,&quot;%.4e&quot;));</span>
        
<span class="fc" id="L1242">        System.out.printf(&quot;chk==1: \n%s\n&quot;, FormatArray.toString(</span>
<span class="fc" id="L1243">            MatrixUtil.multiply(rFirst, r0),&quot;%.4e&quot;));</span>
        
        // with orthographic, can only recover rotation, not translation
        //(2*mImages)X3
        //apply to indiv rotation matrices
         
        // r has the i and j direction and k=i cross j.
        // create a stack of rotation matrices, one per image.
<span class="fc" id="L1251">        double[][] rotStack = MatrixUtil.zeros(3*mImages, 3);</span>
<span class="fc" id="L1252">        double[][] r3 = new double[2*mImages][];//(2*mImages)X3</span>
<span class="fc" id="L1253">        double[][] rTmp = new double[3][];</span>
        //r2 size is (2*mImages)X3
<span class="fc bfc" id="L1255" title="All 2 branches covered.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc" id="L1256">            rTmp[0] = Arrays.copyOf(r2[i], r2[i].length);</span>
<span class="fc" id="L1257">            rTmp[1] = Arrays.copyOf(r2[mImages + i], r2[mImages + i].length);</span>
<span class="fc" id="L1258">            rTmp[2] = MatrixUtil.crossProduct(rTmp[0], rTmp[1]);</span>
<span class="fc" id="L1259">            rTmp = MatrixUtil.multiply(rTmp, r0);</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L1261">                rotStack[i*3 + j] = rTmp[j]; </span>
            }
<span class="fc" id="L1263">            r3[i] = rTmp[0];</span>
<span class="fc" id="L1264">            r3[i + mImages] = rTmp[1];</span>
        }
        
<span class="fc" id="L1267">        double[][] shape = MatrixUtil.multiply(rFirst, s2);</span>
        
<span class="fc" id="L1269">        System.out.printf(&quot;**r3=\n%s\n&quot;, FormatArray.toString(r3, </span>
            &quot;%.4e&quot;));
<span class="fc" id="L1271">        System.out.printf(&quot;**rot stack=\n%s\n&quot;, FormatArray.toString(rotStack, </span>
            &quot;%.4e&quot;));
        
<span class="fc" id="L1274">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(shape, </span>
            &quot;%.4e&quot;));
        
<span class="fc" id="L1277">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        
        //assert eqn (3.7) of Tomasi &amp; Kanade:
        // original measurement matrix 
        //    W = R*X + t*(e_p)^T 
        //        where t = the vector of centroids a_0, a_1,...a_(F-1),b_0,b_1,...b_(F-1)
        //         and e_P^T is a vector of P 1's.
<span class="fc" id="L1285">        double[] ep = new double[nFeatures];</span>
<span class="fc" id="L1286">        Arrays.fill(ep, 1);</span>
<span class="fc" id="L1287">        double[][] tep = MatrixUtil.outerProduct(t, ep);</span>
<span class="fc" id="L1288">        System.out.printf(&quot;W = R*X + t*(e_p)^T=\n%s\n&quot;, </span>
<span class="fc" id="L1289">            FormatArray.toString(MatrixUtil.pointwiseAdd(</span>
<span class="fc" id="L1290">                MatrixUtil.multiply(r3, shape), tep), </span>
            &quot;%.4e&quot;));
<span class="fc" id="L1292">        System.out.printf(&quot;orig W = \n%s\n&quot;, FormatArray.toString(w, </span>
            &quot;%.4e&quot;));
        
<span class="fc" id="L1295">        OrthographicProjectionResults results = new OrthographicProjectionResults();</span>
<span class="fc" id="L1296">        results.XW = shape;</span>
<span class="fc" id="L1297">        results.rotationMatrices = rotStack;</span>
                
<span class="fc" id="L1299">        return results;</span>
    }
    
    /**
     * a look at enforcing orthonormal rotation
     * 
     * @param x
     * @param mImages
     * @return
     * @throws NotConvergedException 
     */
    static OrthographicProjectionResults _DoNotUseThisCalculateAffineReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                                
<span class="nc bnc" id="L1313" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1314">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1317">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L1319">        int nFeatures = x[0].length / mImages;</span>

        //TODO: check this
        //2mn &gt;= 8m + 3n – 12
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1324">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        // Tomasi &amp; Kanade 1992: An image stream can be represented by the
        //  2*F X P measurment matrix W of image coordinates of P points
        // tracked through F frames.
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size is mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size is mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create matrix WC = W - t
        
        // row[0] = image_0_x[0], image_0_x[1], image_0_x[2], ...
        // row[1] = image_1_x[0], image_1_x[1], image_1_x[2], ...
        // ...
        // row[mImages+0] = image_0_y[0], image_0_y[1], image_0_y[2], ...
        //NOTE: adding the Z axis=1
<span class="nc" id="L1347">        double[][] w = MatrixUtil.zeros(3*mImages, nFeatures);</span>
<span class="nc" id="L1348">        double[] t = new double[3*mImages];</span>
        int i, j;
        int m, n, rowX, rowY, rowZ, col;
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="nc" id="L1352">            rowX = m;</span>
<span class="nc" id="L1353">            rowY = mImages + m;</span>
<span class="nc" id="L1354">            rowZ = 2*mImages + m;</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="nc" id="L1356">                col = nFeatures*m + n;</span>
<span class="nc" id="L1357">                w[rowX][n] = x[0][col];</span>
<span class="nc" id="L1358">                t[rowX] += x[0][col];</span>
<span class="nc" id="L1359">                w[rowY][n] = x[1][col];</span>
<span class="nc" id="L1360">                t[rowY] += x[1][col];</span>
<span class="nc" id="L1361">                w[rowZ][n] = 1;</span>
<span class="nc" id="L1362">                t[rowZ] += 1;</span>
            }
<span class="nc" id="L1364">            t[rowX] /= (double)nFeatures;</span>
<span class="nc" id="L1365">            t[rowY] /= (double)nFeatures;</span>
<span class="nc" id="L1366">            t[rowZ] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="nc" id="L1370">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="nc" id="L1373">                wC[i][n] -= t[i];</span>
            }
        }
        
        // see Fig 3.1 of Tomasi &amp; Kanade 1991 or Fig 2. of Belongie lecture notes
        
        // under orthography, this coordinate centered matrix has rank 3
        // and can be factored into the product of 2 matrices, R and S:
        // the camera rotation matrix R (size 2FX3) and 
        // the shape matrix S (size 3XP) which is shape in a coordinate system 
        // attached to the object centroid.
        //The two components of the camera translation along the image plane
        // are computed as averages of the rows of W
                
        // the registered measurement matrix is highly rank deficient
        // eqn (3.11)
<span class="nc" id="L1389">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        
        // Tomasi &amp; Kanade 1992,eqn (3.12): 1st 3 columns of U, upper 3X3 of S, and first 3 rows of V^T
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="nc" id="L1395">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="nc" id="L1396">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L1397">        s3[0][0] = svd.s[0];</span>
<span class="nc" id="L1398">        s3[1][1] = svd.s[1];</span>
<span class="nc" id="L1399">        s3[2][2] = svd.s[2];</span>
<span class="nc" id="L1400">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="nc" id="L1401">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="nc" id="L1402">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="nc" id="L1403">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="nc" id="L1404">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="nc" id="L1411">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="nc" id="L1412">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
        
        //Tamasi &amp; Kanade
        // (2*mImages)X3
<span class="nc" id="L1416">        double[][] rC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="nc" id="L1418">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="nc" id="L1420">        System.out.printf(&quot;rC=\n%s\n&quot;, FormatArray.toString(rC, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L1422">        System.out.printf(&quot;w=\n%s\n&quot;, FormatArray.toString(w, &quot;%.4e&quot;));</span>
<span class="nc" id="L1423">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
<span class="nc" id="L1424">        System.out.printf(&quot;rC*sC=\n%s\n&quot;, FormatArray.toString(</span>
<span class="nc" id="L1425">            MatrixUtil.multiply(rC, sC), </span>
            &quot;%.4e&quot;));
        
        // wC = rC * sC  
        //rC and sC are linear translations of the true rotation matrix R and
        //  the true shape matrix S, respectively.
        // Morita and Kanade: the decomposition is not completely unique.  
        //     it's unique only up to an affine transformation
        
        /*
        NLK: the rotation matrices aren't orthormal, so one needs to apply a linear
        transformation to rC that makes it orthonormal while applying the
        inverse transformation to sC to maintain the value of wC.
        
        wC = rC * sC

        let rC' be a single rotation matrix formed from the x-row of a frame in rC,
            the y-row of the same frame in rC, and the cross product of the x and y rows.
        rCO is obtained from SVD(rC').U*(SVD(rC').VT)^T)

        let R be the orthogonal rCO matrices reformatted into the x, y row format of rC
        
        since wC = R * Z * z^-1 * sC
              wC = R * Z^-1 * sC
              pseudoInv(R)*wC = pseudoInv(R)*R * Z^-1 * sC
              pseudoInv(R)*wC * pseudoInv(sC) = Z^-1 if inv(R)*R=I
               
              then can use Z^-1 to transform sC into s
        
        (3) Can continue with the rest of the Tomasi &amp; Kanade and Morita &amp; Kanade
            algorithm, eqn (3.15) below...
        */
        
        //sC is 3XnFeatures
        
        double[][] invR;
        
<span class="nc" id="L1462">        double[][] rot = new double[3*mImages][3];</span>
<span class="nc" id="L1463">        double[][] r3 = new double[2*mImages][3];</span>
<span class="nc" id="L1464">        double[][] shape = new double[3*mImages][nFeatures];</span>
        
        // 3X3
<span class="nc" id="L1467">        double[][] rCP = new double[3][];</span>
        double[] tmp;
        //3X3
        double[][] rCO;
        SVDProducts svdRC;
        double[][] si;
<span class="nc" id="L1473">        double[][] wCij = new double[3][];//3XnFeatures</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">        for (int ii = 0; ii &lt; mImages; ++ii) {</span>
<span class="nc" id="L1475">            rCP[0] = rC[ii];</span>
<span class="nc" id="L1476">            rCP[1] = rC[ii + mImages];</span>
<span class="nc" id="L1477">            rCP[2] = rC[ii + 2*mImages];</span>
<span class="nc" id="L1478">            tmp = MatrixUtil.crossProduct(rCP[0], rCP[1]);</span>
<span class="nc" id="L1479">            System.out.printf(&quot;compare %s to %s\n&quot;, </span>
<span class="nc" id="L1480">                FormatArray.toString(rCP[2], &quot;%.3e&quot;), FormatArray.toString(tmp, &quot;%.3e&quot;));</span>
    
<span class="nc" id="L1482">            System.out.printf(&quot;rC_%d=\n%s\n&quot;, ii, FormatArray.toString(rCP, &quot;%.4e&quot;));</span>
<span class="nc" id="L1483">            double detR = MatrixUtil.determinant(rCP);</span>
<span class="nc" id="L1484">            System.out.printf(&quot;det(rC_%d)=%.4e\n&quot;, ii, detR);</span>
            
<span class="nc" id="L1486">            svdRC = MatrixUtil.performSVD(rCP);</span>
<span class="nc" id="L1487">            rCO = MatrixUtil.multiply(svdRC.u, MatrixUtil.transpose(svdRC.vT));</span>
<span class="nc" id="L1488">            System.out.printf(&quot;r_uvtt=\n%s\n&quot;, FormatArray.toString(rCO, &quot;%.4e&quot;));</span>
<span class="nc" id="L1489">            detR = MatrixUtil.determinant(rCO);</span>
<span class="nc" id="L1490">            System.out.printf(&quot;det(r_uvtt_%d)=%.4e\n&quot;, ii, detR);</span>
           
<span class="nc" id="L1492">            System.out.printf(&quot;rC_%d * (rC_%d)^T=\n%s\n&quot;, ii, ii,</span>
<span class="nc" id="L1493">                FormatArray.toString(MatrixUtil.multiply(rCP, MatrixUtil.transpose(rCP)), &quot;%.4e&quot;));</span>
            
<span class="nc" id="L1495">            System.out.printf(&quot;r_uvtt_%d * (r_uvtt_%d)^T=\n%s\n&quot;, ii, ii,</span>
<span class="nc" id="L1496">                FormatArray.toString(MatrixUtil.multiply(rCO, MatrixUtil.transpose(rCO)), &quot;%.4e&quot;));</span>
            
<span class="nc" id="L1498">            System.out.flush();</span>
           
<span class="nc bnc" id="L1500" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L1501">                rot[ii*3 + j] = rCO[j];</span>
            }
<span class="nc" id="L1503">            r3[ii] = Arrays.copyOf(rCO[0], rCO[0].length);</span>
<span class="nc" id="L1504">            r3[ii + mImages] = Arrays.copyOf(rCO[1], rCO[1].length);</span>
            
            /*
            block[0] = rCP[0] times sC = 1XnFeatures
            block[1] = rCP[1] times sC
            block[2] = rCp[2] times sC 
            
            rC*z * (z^-1)*sC = 3X3*3X3*3XnFeatures = 3XnFeatures = block of wC
            rOrth * (z^-1)*sC= wC_i_j
            (z^-1)*sC= inv(rOth)*wC_i_j
            store in blocks of trans
            */     
<span class="nc" id="L1516">            invR = MatrixUtil.pseudoinverseFullColumnRank(rCO);</span>
            
            // 3XnFeatures
<span class="nc" id="L1519">            wCij[0] = wC[ii];</span>
<span class="nc" id="L1520">            wCij[1] = wC[ii + mImages];</span>
<span class="nc" id="L1521">            wCij[2] = wC[ii + 2*mImages];</span>
            
            //3XnFeatures
<span class="nc" id="L1524">            si = MatrixUtil.multiply(invR, wCij);</span>
            
            //double[][] trans = new double[3*mImages][nFeatures];
<span class="nc bnc" id="L1527" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L1528">                shape[ii*3 + j] = si[j];</span>
            }
            
            // TODO: need to consider the rotation and translation origins now
<span class="nc" id="L1532">            System.out.printf(&quot;for image%d have shape=\n%s\n&quot;, ii, FormatArray.toString(si, &quot;%.4e&quot;));</span>
        }
        
<span class="nc" id="L1535">        System.out.printf(&quot;rot stack=\n%s\n&quot;, FormatArray.toString(rot, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1538">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(shape, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1541">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        // shape size is
        //r3 = new double[2*mImages][3];
<span class="nc" id="L1545">        double[][] _si = new double[3][nFeatures];</span>
<span class="nc" id="L1546">        double[][] _ri = new double[2][3];</span>
        double[][] _rs;
<span class="nc bnc" id="L1548" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L1549">            _si[0] = shape[i*mImages + i];//3XnFeatures</span>
<span class="nc" id="L1550">            _si[1] = shape[i*mImages + i + 1];</span>
<span class="nc" id="L1551">            _si[2] = shape[i*mImages + i + 2]; </span>
<span class="nc" id="L1552">            _ri[0] = r3[i*mImages + 0];//2X3</span>
<span class="nc" id="L1553">            _ri[1] = r3[i*mImages + 1];</span>
<span class="nc" id="L1554">            _rs = MatrixUtil.multiply(_ri, _si);//2XnFeatures</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">            for (int k = 0; k &lt; nFeatures; ++k) {</span>
<span class="nc" id="L1556">                _rs[0][k] += t[i*mImages + i];</span>
<span class="nc" id="L1557">                _rs[1][k] += t[i*mImages + i + 1];</span>
            }
            
<span class="nc" id="L1560">            System.out.printf(&quot;W = R*X + t*(e_p)^T=\n%s\n&quot;, </span>
<span class="nc" id="L1561">                FormatArray.toString(_rs, &quot;%.4e&quot;));</span>
        }
<span class="nc" id="L1563">        System.out.printf(&quot;original W = \n%s\n&quot;, </span>
<span class="nc" id="L1564">            FormatArray.toString(w, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L1566">        OrthographicProjectionResults results = new OrthographicProjectionResults();</span>
<span class="nc" id="L1567">        results.XW = shape;</span>
<span class="nc" id="L1568">        results.rotationMatrices = rot;</span>
                
<span class="nc" id="L1570">        return results;</span>
           
    }
    
    /*
    TODO: proof read and write test for this.
    from Szeliski 2010 and Poelman &amp; Kanade 1992 (year?  a few published translations with different years):
    Para-perspective provides a more accurate projection model than scaled 
    orthography, without incurring the added complexity of per-pixel perspective 
    division, which invalidates traditional factoriza- tion methods 
    (Poelman and Kanade 1997).
    
    Scaled orthographic projection, sometimes referred to as &quot;weak perspective&quot;, 
    accounts for the scaling effect of an object as it moves towards and away 
    from the camera. Paraperspective projection, first introduced by Ohta in 
    [4] and named by Aloimonos in [1], accounts for the scaling effect as well 
    as the different angle from which an object is viewed as it moves in a 
    direction parallel to the image plane.

    */
          
    /**
     * for the case where the cameras are viewing small, distant scenes,
     * recover the 3-D coordinates in WCS and the projection matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * assumes a para-perspective camera model.
     *
     * Input set of P feature point coordinates (x_f_p,y_f_p) , for each of 
     * the F frames of the image sequence. From this information, our goal is 
     * to recover the estimated shape of the object, given by the position 
     * s_P, of every point, and the estimated motion of the
     camera, given by iHat_f, jHat_f, kHat_f for each frame in the sequence. 
     Rather than recover iHat_f in world coordinates, we generally recover 
     the three.eparate components tHat_f dot iHat_f, tHat_f dot jHat_f,
     tHat_f dot kHat_f.
 
      
     &lt;pre&gt;
      references:
      
     Poelman &amp; Kanade 1997 (1994), &quot;A Paraperspective Factorization Method for Shape 
     and Motion Recovery&quot; 
     
     Description from Poelman &amp; Kanade:
      
     Each feature point p that we track corresponds to a single world point, 
      located at position s. in some fixed world coordinate system.

      Each image f was taken at some specific camera orientation, which we 
      describe by the orthonormal unit vectors i_f, j_f and k_f 
      where kf_ points along the camera's line of sight, 
      i_f corresponds to the camera image plane's x-axis, 
      and j_f corresponds to the camera image's y-axis.
      
      t_f is a vector pointing from the origin of the fixed world coordinate system
      to the camera's focal plane.  it's the position of the camera in each fram f.
      
     &lt;/pre&gt;
     * 
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ParaperspectiveProjectionResults calculateParaperspectiveReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                        
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1644">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1647">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="fc" id="L1649">        int nFeatures = x[0].length / mImages;</span>

        //TODO: check this
        ///2mn &gt;= 8m + 3n – 12
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1654">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        //NOTE: assumes the camera's focal length = 1
        
        // create measurement matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size os mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size os mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create registered measurement matrix WC = W - t
<span class="fc" id="L1669">        double[][] w = MatrixUtil.zeros(2*mImages, nFeatures);</span>
        // t points to the camera's focal point
<span class="fc" id="L1671">        double[] t = new double[2*mImages];</span>
        int i, j;
        int m, n, rowU, rowV, col;
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="fc" id="L1675">            rowU = m;</span>
<span class="fc" id="L1676">            rowV = mImages + m;</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="fc" id="L1678">                col = nFeatures*m + n;</span>
<span class="fc" id="L1679">                w[rowU][n] = x[0][col];</span>
<span class="fc" id="L1680">                t[rowU] += x[0][col];</span>
<span class="fc" id="L1681">                w[rowV][n] = x[1][col];</span>
<span class="fc" id="L1682">                t[rowV] += x[1][col];</span>
            }
<span class="fc" id="L1684">            t[rowU] /= (double)nFeatures;</span>
<span class="fc" id="L1685">            t[rowV] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="fc" id="L1689">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="fc bfc" id="L1691" title="All 2 branches covered.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="fc" id="L1692">                wC[i][n] -= t[i];</span>
            }
        }
        
<span class="fc" id="L1696">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="fc" id="L1700">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="fc" id="L1701">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L1702">        s3[0][0] = svd.s[0];</span>
<span class="fc" id="L1703">        s3[1][1] = svd.s[1];</span>
<span class="fc" id="L1704">        s3[2][2] = svd.s[2];</span>
<span class="fc" id="L1705">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="fc" id="L1706">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="fc" id="L1707">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="fc" id="L1708">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="fc" id="L1709">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="fc" id="L1716">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="fc" id="L1717">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
                
        // (2*mImages)X3
<span class="fc" id="L1720">        double[][] mC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="fc" id="L1722">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="fc" id="L1724">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
        
        // assert that wC is the same as wC2
<span class="fc" id="L1727">        System.out.printf(&quot;mC*sC=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(mC, sC), </span>
            &quot;%.4e&quot;));
        
        /*
        ------------------------------------------------------------------
        Paraperspective Normalization
        ------------------------------------------------------------------
        
         3 constraints:

         eqn(15) of paper:
                 |m_f|^2/(1+x_f^2) - |n_f|^2/(1+y_f^2) = 0
         eqn(17) of paper:
                 m_f dot n_f = x_f * y*f * 0.5 * ( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2) )
         eqn(18) of paper:
                 |m_0|=1

         those are 2*F + 1 equations as metric constraints

         from the SVD of the registered measurement matrix, there is M and S
         `M is size 2*F X 3
         `M = vectorized( m_0, m_1, ... m_{F-1}, n_0, n_1, ... n_{F-1},

         let M = `M*A where A is a 3X3 matrix, and as before, Q = symmetric matrix, but Q=A^T*A.

         Equations (15), (17), and (18) give us 2F+ 1 equations,
         We compute the 3 X 3 matrix A such that M = `M*A best satisfies these metric constraints
         in the least sum-of-squares error sense.

         This is a simple problem because the constraints are linear in the 6 unique elements
         of the symmetric 3 x 3 matrix Q = A^TA.
        
         Thus we compute Q by solving the overconstrained linear system of 2F + 1 equations
         in 6 variables defined by the metric constraints, ...

             [ q1  q2  q3 ]
         Q = [ q2  q4  q5 ]
             [ q3  q5  q6 ]

         m_f = `m_f * Q = [`mf0  `mf1  `mf2] * [ q1  q2  q3 ]
                                               [ q2  q4  q5 ]
                                               [ q3  q5  q6 ]
                        = [ (q1*`mf0 + q2*`mf1 + q3*`mf2 )  (q2*`mf0 + q4*`mf1 + q5*`mf2 )  (q3*`mf0 + q5*`mf1 + q6*`mf2 ) ]

         |vector| is the magnitude of a vector = square root of the sum of squares of its components.
        
         as an aside, in case can simplify any future steps with this:
         and Q*Q = q1*q1 + q2*q2 + q3*q3   q1*q2 + q2*q4 + q3*q5   q1*q3 + q2*q5 + q3*q6
                   q1*q2 + q2*q4 + q3*q5   q2*q2 + q4*q4 + q5*q5   q2*q3 + q4*q5 + q5*q6
                   q1*q3 + q2*q5 + q3*q6   q2*q3 + q4*q5 + q5*q6   q3*q3 + q5*q5 + q6*q6
                 = Q_col0 dot Q_col0   Q_col0 dot Q_col1  Q_col0 dot Q_col2
                   Q_col0 dot Q_col1   Q_col1 dot Q_col1  Q_col1 dot Q_col2
                   Q_col0 dot Q_col2   Q_col1 dot Q_col2  Q_col2 dot Q_col2

        NOTE: below are the expanded details of the multiplication.
        The result can be rewritten using other notation:
        since need the dot product of vector `m_f*Q with itself, can use the inner product
        of the vector multiplied by its transpose:
            |m_f|^2 = `m_f*Q*Q^T*`m_f^T where m_f is a 1X3 vector and Q is a 3X3 symmetric matrix
                    = `m_f*Q^2*`m_f^T
                    = [`m_f*Q^2[:][0] `m_f*Q^2[:][1] `m_f*Q^2[:][2]] * `m_f^T
                    = ['m_f[0]*`m_f*Q^2[:][0] + 'm_f[1]*`m_f*Q^2[:][1] + 'm_f[2]*`m_f*Q^2[:][2]]


         expand |m_f|^2/(1+x_f^2) :
             (1/(1+x_f^2)) * [ (q1*`mf0 + q2*`mf1 + q3*`mf2 )^2 + (q2*`mf0 + q4*`mf1 + q5*`mf2 )^2 + (q3*`mf0 + q5*`mf1 + q6*`mf2 )^2 ]
             (1/(1+x_f^2)) * [ (q1*`mf0*q1*`mf0 + q1*`mf0*q2*`mf1 + q1*`mf0*q3*`mf2)
                              + (q2*`mf1*q1*`mf0 + q2*`mf1*q2*`mf1 + q2*`mf1*q3*`mf2)
                              + (q3*`mf2*q1*`mf0 + q3*`mf2*q2*`mf1 + q3*`mf2*q3*`mf2)
                              + (q2*`mf0*q2*`mf0 + q2*`mf0*q4*`mf1 + q2*`mf0*q5*`mf2 )
                              + (q4*`mf1*q2*`mf0 + q4*`mf1*q4*`mf1 + q4*`mf1*q5*`mf2 )
                              + (q5*`mf2*q2*`mf0 + q5*`mf2*q4*`mf1 + q5*`mf2*q5*`mf2 )
                              + (q3*`mf0*q3*`mf0 + q3*`mf0*q5*`mf1 + q3*`mf0*q6*`mf2 )
                              + (q5*`mf1*q3*`mf0 + q5*`mf1*q5*`mf1 + q5*`mf1*q6*`mf2 )
                              + (q6*`mf2*q3*`mf0 + q6*`mf2*q5*`mf1 + q6*`mf2*q6*`mf2 ) ]

             (1/(1+x_f^2))  * [ (q1*`mf0*q1*`mf0 + q1*`mf0*q2*`mf1 + q1*`mf0*q3*`mf2)
                              + (q1*`mf0*q2*`mf1 + q2*`mf1*q2*`mf1 + q2*`mf1*q3*`mf2)
                              + (q1*`mf0*q3*`mf2 + q2*`mf1*q3*`mf2 + q3*`mf2*q3*`mf2)
                              + (q2*`mf0*q2*`mf0 + q2*`mf0*q4*`mf1 + q2*`mf0*q5*`mf2 )
                              + (q2*`mf0*q4*`mf1 + q4*`mf1*q4*`mf1 + q4*`mf1*q5*`mf2 )
                              + (q2*`mf0*q5*`mf2 + q4*`mf1*q5*`mf2 + q5*`mf2*q5*`mf2 )
                              + (q3*`mf0*q3*`mf0 + q3*`mf0*q5*`mf1 + q3*`mf0*q6*`mf2 )
                              + (q3*`mf0*q5*`mf1 + q5*`mf1*q5*`mf1 + q5*`mf1*q6*`mf2 )
                              + (q3*`mf0*q6*`mf2 + q6*`mf2*q5*`mf1 + q6*`mf2*q6*`mf2 ) ]
        
                          (1/(1+x_f^2))  * [ q1*q1*`mf0*`mf0 + q1*q2*`mf0*`mf1 + q1*q3*`mf0*`mf2
                              + q1*q2*`mf0*`mf1 + q2*q2*`mf1*`mf1 + q2*q3*`mf1*`mf2
                              + q1*q3*`mf0*`mf2 + q2*q3*`mf1*`mf2 + q3*q3*`mf2*`mf2
                              + q2*q2*`mf0*`mf0 + q2*q4*`mf0*`mf1 + q2*q5*`mf0*`mf2
                              + q2*q4*`mf0*`mf1 + q4*q4*`mf1*`mf1 + q4*q5*`mf1*`mf2
                              + q2*q5*`mf0*`mf2 + q4*q5*`mf1*`mf2 + q5*q5*`mf2*`mf2
                              + q3*q3*`mf0*`mf0 + q3*q5*`mf0*`mf1 + q3*q6*`mf0*`mf2
                              + q3*q5*`mf0*`mf1 + q5*q5*`mf1*`mf1 + q5*q6*`mf1*`mf2
                              + q3*q6*`mf0*`mf2 + q6*q5*`mf2*`mf1 + q6*q6*`mf2*`mf2 ]

             (1/(1+x_f^2))  * [ q1*q1*`mf0*`mf0 + q2*q2*`mf0*`mf0 + q3*q3*`mf0*`mf0
                              + q1*q2*`mf0*`mf1 + q2*q4*`mf0*`mf1 + q3*q5*`mf0*`mf1   &lt;== 1st 3 lines of addition are:
                              + q1*q3*`mf0*`mf2 + q2*q5*`mf0*`mf2 + q3*q6*`mf0*`mf2       [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ] * [Q^2_col0]

                              + q1*q2*`mf0*`mf1 + q2*q4*`mf0*`mf1 + q3*q5*`mf0*`mf1   &lt;== 2nd 3 lines of addition are:
                              + q2*q2*`mf1*`mf1 + q4*q4*`mf1*`mf1 + q5*q5*`mf1*`mf1       [ `mf0*`mf1  `mf1*`mf1  `mf1*`mf2 ] * [Q^2_col1]
                              + q2*q3*`mf1*`mf2 + q4*q5*`mf1*`mf2 + q5*q6*`mf1*`mf2

                              + q1*q3*`mf0*`mf2 + q2*q5*`mf0*`mf2 + q3*q6*`mf0*`mf2   &lt;== 3rd 3 lines of addition are:
                              + q2*q3*`mf1*`mf2 + q4*q5*`mf1*`mf2 + q5*q6*`mf1*`mf2       [ `mf0*`mf2  `mf1*`mf2  `mf2*`mf2 ] * [Q^2_col2]
                              + q3*q3*`mf2*`mf2 + q5*q5*`mf2*`mf2 + q6*q6*`mf2*`mf2 ]

             let z0 = [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ]
                 z1 = [ `mf0*`mf1  `mf1*`mf1  `mf1*`mf2 ]
                 z2 = [ `mf0*`mf2  `mf1*`mf2  `mf2*`mf2 ]
             (1/(1+x_f^2))  * [ z0 z1 z2] * [Q^2_col0]
                                            [Q^2_col1]
                                            [Q^2_col2]

         reminder of Q*Q:
                 = q1*q1 + q2*q2 + q3*q3   q1*q2 + q2*q4 + q3*q5   q1*q3 + q2*q5 + q3*q6
                   q1*q2 + q2*q4 + q3*q5   q2*q2 + q4*q4 + q5*q5   q2*q3 + q4*q5 + q5*q6
                   q1*q3 + q2*q5 + q3*q6   q2*q3 + q4*q5 + q5*q6   q3*q3 + q5*q5 + q6*q6
                 = Q_col0 dot Q_col0   Q_col0 dot Q_col1  Q_col0 dot Q_col2
                   Q_col0 dot Q_col1   Q_col1 dot Q_col1  Q_col1 dot Q_col2
                   Q_col0 dot Q_col2   Q_col1 dot Q_col2  Q_col2 dot Q_col2
            
             let z0 = [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ]
                 z1 = [ `mf1*`mf0  `mf1*`mf1  `mf1*`mf2 ]
                 z2 = [ `mf2*`mf0  `mf2*`mf1  `mf2*`mf2 ]
             let y0 = [ `nf0*`nf0  `nf0*`nf1  `nf0*`nf2 ]
                 y1 = [ `nf1*`nf0  `nf1*`nf1  `nf1*`nf2 ]
                 y2 = [ `nf2*`nf0  `nf2*`nf1  `nf2*`nf2 ]
             let w0 = [ `mf0*`nf0  `mf0*`nf1  `mf0*`nf2 ]
                 w1 = [ `mf1*`nf0  `mf1*`nf1  `mf1*`nf2 ]
                 w2 = [ `mf2*`nf0  `mf2*`nf1  `mf2*`nf2 ]
             let c2 = (x_f*y_f*0.5)

        factoring the constraints to separate Q unknowns from m and n knowns:
         eqn(15) of paper:
                 |m_f|^2/(1+x_f^2) - |n_f|^2/(1+y_f^2) = 0

             (1/(1+x_f^2)) * [ z0 z1 z2] * [Q^2_col0]  -  (1/(1+y_f^2)) * [ y0 y1 y2] * [Q^2_col0] = 0
                                           [Q^2_col1]                                   [Q^2_col1]
                                           [Q^2_col2]                                   [Q^2_col2]

             [ (z0/(1+x_f^2) -y0/(1+y_f^2))  (z1/(1+x_f^2) -y1/(1+y_f^2))  (z2/(1+x_f^2) -y2/(1+y_f^2)) ] * [Q^2_col0] = 0
                                                                                                            [Q^2_col1]
                                                                                                            [Q^2_col2]

         eqn(17) of paper:
                 m_f dot n_f = x_f*y_f*0.5 * ( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2) )

                 [ w0 w1 w2] * [Q^2_col0] - c2 * [ z0 z1 z2] * [Q^2_col0]  -  c2 * [ y0 y1 y2] * [Q^2_col0] = 0
                               [Q^2_col1]                      [Q^2_col1]                        [Q^2_col1]
                               [Q^2_col2]                      [Q^2_col2]                        [Q^2_col2]

                 [ (w0 -z0*c2 -y0*c2)  (w1 -z1*c2 -y1*c2)  (w2 -z2*c2 -y2*c2)] * [Q^2_col0] = 0
                                                                                 [Q^2_col1]
                                                                                 [Q^2_col2]
         eqn(18) of paper:
                 |m_0|=1

                 square to use the same factorization by Q^2?

             let v0 = [ `m_0[0]*`mf0  `m_0[0]*`m_0[1]  `m_0[0]*`m_0[2] ]
                 v1 = [ `m_0[0]*`mf1  `m_0[1]*`m_0[1]  `m_0[1]*`m_0[2] ]
                 v2 = [ `m_0[0]*`mf2  `m_0[1]*`m_0[2]  `m_0[2]*`m_0[2] ]
             |m_0|^2 = [ v0 v1 v2] * [Q^2_col0] = 1
                                     [Q^2_col1]
                                     [Q^2_col2]
        */
        
<span class="fc" id="L1896">        double[][] g = new double[2*mImages + 1][9];</span>
<span class="fc" id="L1897">        double[] z0 = new double[3];</span>
<span class="fc" id="L1898">        double[] z1 = new double[3];</span>
<span class="fc" id="L1899">        double[] z2 = new double[3];</span>
<span class="fc" id="L1900">        double[] y0 = new double[3];</span>
<span class="fc" id="L1901">        double[] y1 = new double[3];</span>
<span class="fc" id="L1902">        double[] y2 = new double[3];</span>
<span class="fc" id="L1903">        double[] w0 = new double[3];</span>
<span class="fc" id="L1904">        double[] w1 = new double[3];</span>
<span class="fc" id="L1905">        double[] w2 = new double[3];</span>
        double c2, xf, yf, divXf, divYf;
        
<span class="fc bfc" id="L1908" title="All 2 branches covered.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc" id="L1909">            xf = t[i];</span>
<span class="fc" id="L1910">            yf = t[mImages + i];</span>
            
<span class="fc" id="L1912">            z0[0] = mC[i][0] * mC[i][0]; </span>
<span class="fc" id="L1913">            z0[1] = mC[i][0] * mC[i][1];</span>
<span class="fc" id="L1914">            z0[2] = mC[i][0] * mC[i][2];</span>
            
<span class="fc" id="L1916">            z1[0] = mC[i][1] * mC[i][0]; </span>
<span class="fc" id="L1917">            z1[1] = mC[i][1] * mC[i][1];</span>
<span class="fc" id="L1918">            z1[2] = mC[i][1] * mC[i][2];</span>
            
<span class="fc" id="L1920">            z2[0] = mC[i][2] * mC[i][0]; </span>
<span class="fc" id="L1921">            z2[1] = mC[i][2] * mC[i][1];</span>
<span class="fc" id="L1922">            z2[2] = mC[i][2] * mC[i][2];</span>
            
<span class="fc" id="L1924">            y0[0] = mC[mImages + i][0] * mC[mImages + i][0];</span>
<span class="fc" id="L1925">            y0[1] = mC[mImages + i][0] * mC[mImages + i][1];</span>
<span class="fc" id="L1926">            y0[2] = mC[mImages + i][0] * mC[mImages + i][2];</span>
            
<span class="fc" id="L1928">            y1[0] = mC[mImages + i][1] * mC[mImages + i][0];</span>
<span class="fc" id="L1929">            y1[1] = mC[mImages + i][1] * mC[mImages + i][1];</span>
<span class="fc" id="L1930">            y1[2] = mC[mImages + i][1] * mC[mImages + i][2];</span>
            
<span class="fc" id="L1932">            y2[0] = mC[mImages + i][2] * mC[mImages + i][0];</span>
<span class="fc" id="L1933">            y2[1] = mC[mImages + i][2] * mC[mImages + i][1];</span>
<span class="fc" id="L1934">            y2[2] = mC[mImages + i][2] * mC[mImages + i][2];</span>
            
<span class="fc" id="L1936">            w0[0] = mC[i][0] * mC[mImages + i][0];</span>
<span class="fc" id="L1937">            w0[1] = mC[i][0] * mC[mImages + i][1];</span>
<span class="fc" id="L1938">            w0[2] = mC[i][0] * mC[mImages + i][2];</span>
            
<span class="fc" id="L1940">            w1[0] = mC[i][1] * mC[mImages + i][0];</span>
<span class="fc" id="L1941">            w1[1] = mC[i][1] * mC[mImages + i][1];</span>
<span class="fc" id="L1942">            w1[2] = mC[i][1] * mC[mImages + i][2];</span>
            
<span class="fc" id="L1944">            w2[0] = mC[i][2] * mC[mImages + i][0];</span>
<span class="fc" id="L1945">            w2[1] = mC[i][2] * mC[mImages + i][1];</span>
<span class="fc" id="L1946">            w2[2] = mC[i][2] * mC[mImages + i][2];</span>
            
<span class="fc" id="L1948">            c2 = 0.5*xf*yf;</span>
            
<span class="fc" id="L1950">            divXf = 1./(1.+xf*xf);</span>
<span class="fc" id="L1951">            divYf = 1./(1.+yf*yf);</span>
            
            // length 9
            // eqn(15) of paper is the 1st mImages rows of g
            //   [ (z0/(1+x_f^2) -y0/(1+y_f^2))  (z1/(1+x_f^2) -y1/(1+y_f^2))  (z2/(1+x_f^2) -y2/(1+y_f^2)) ] ... = 0
<span class="fc" id="L1956">            g[i] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="fc bfc" id="L1957" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) { </span>
<span class="fc" id="L1958">                g[i][j] = (z0[j]*divXf - y0[j]*divYf);                </span>
<span class="fc" id="L1959">                g[i][3+j] = (z1[j]*divXf - y1[j]*divYf);</span>
<span class="fc" id="L1960">                g[i][6+j] = (z2[j]*divXf - y2[j]*divYf);                </span>
            }
            
            //eqn(17) of paper is the 2nd mImages rows of g
            //  [ (w0 -z0*c2 -y0*c2)  (w1 -z1*c2 -y1*c2)  (w2 -z2*c2 -y2*c2)] ... = 0
<span class="fc" id="L1965">            g[mImages + i] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) { </span>
<span class="fc" id="L1967">                g[mImages + i][j] = (w0[j] - z0[j]*c2 - y0[j]*c2);                </span>
<span class="fc" id="L1968">                g[mImages + i][3+j] = (w1[j] - z1[j]*c2 - y1[j]*c2);</span>
<span class="fc" id="L1969">                g[mImages + i][6+j] = (w2[j] - z2[j]*c2 - y2[j]*c2);               </span>
            }
        }
        
        //let v0 = [ `m_0[0]*`mf0  `m_0[0]*`m_0[1]  `m_0[0]*`m_0[2] ]
        //    v1 = [ `m_0[0]*`mf1  `m_0[1]*`m_0[1]  `m_0[1]*`m_0[2] ]
        //    v2 = [ `m_0[0]*`mf2  `m_0[1]*`m_0[2]  `m_0[2]*`m_0[2] ]
        // length 9
        // [ v0 v1 v2 ] = 1
<span class="fc" id="L1978">        i = 0;</span>
<span class="fc" id="L1979">        double[] v0 = new double[] {</span>
           mC[i][0] * mC[i][0], mC[i][0] * mC[i][1], mC[i][0] * mC[i][2]};
<span class="fc" id="L1981">        double[] v1 = new double[] {</span>
            mC[i][1] * mC[i][0], mC[i][1] * mC[i][1], mC[i][1] * mC[i][2]};
<span class="fc" id="L1983">        double[] v2 = new double[] {</span>
            mC[i][2] * mC[i][0], mC[i][2] * mC[i][1], mC[i][2] * mC[i][2]};
<span class="fc" id="L1985">        g[2*mImages] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="fc bfc" id="L1986" title="All 2 branches covered.">        for (j = 0; j &lt; 3; ++j) { </span>
<span class="fc" id="L1987">            g[2*mImages][j] = v0[j];                </span>
<span class="fc" id="L1988">            g[2*mImages][3+j] = v1[j];</span>
<span class="fc" id="L1989">            g[2*mImages][6+j] = v2[j];               </span>
        }
        
<span class="fc" id="L1992">        double[] c = new double[2*mImages + 1];</span>
<span class="fc" id="L1993">        c[2*mImages] = 1;</span>
        
<span class="fc" id="L1995">        double[][] gInv = MatrixUtil.pseudoinverseFullColumnRank(g);</span>
<span class="fc" id="L1996">        double[] iVector = MatrixUtil.multiplyMatrixByColumnVector(gInv, c);</span>
<span class="pc bnc" id="L1997" title="All 2 branches missed.">        assert(iVector.length == 9);</span>
        
        // 3X3
<span class="fc" id="L2000">        double[][] ell = new double[3][3];</span>
<span class="fc" id="L2001">        ell[0] = new double[]{iVector[0], iVector[1], iVector[2]};</span>
<span class="fc" id="L2002">        ell[1] = new double[]{iVector[1], iVector[3], iVector[4]};</span>
<span class="fc" id="L2003">        ell[2] = new double[]{iVector[2], iVector[4], iVector[5]};</span>

        // Q can be determined :
        //   as the square root of ell,
        //   or with the Cholesky decomposition
        //   or with eigendecomposition

<span class="fc" id="L2010">        double eps = 1e-16;//1.e-11; eps close to zero within machine precision to perturb the matrix to smallest eigenvalue of eps</span>
<span class="fc" id="L2011">        double[][] lPSD = MatrixUtil.nearestPositiveSemidefiniteToASymmetric(ell, eps);</span>
<span class="fc" id="L2012">        EVD evd2 = EVD.factorize(new DenseMatrix(lPSD));</span>
<span class="fc" id="L2013">        double[] eig = evd2.getRealEigenvalues();</span>
<span class="fc" id="L2014">        System.out.printf(&quot;eig(L_PSD)=\n%s\n&quot;, FormatArray.toString(eig, &quot;%.4e&quot;));</span>
<span class="fc" id="L2015">        double[][] aMinusPSD = MatrixUtil.pointwiseSubtract(ell, lPSD);</span>
<span class="fc" id="L2016">        double dist1 = MatrixUtil.frobeniusNorm(aMinusPSD);</span>
        
<span class="fc" id="L2018">        boolean ipd = MatrixUtil.isPositiveDefinite(lPSD);</span>
<span class="pc bnc" id="L2019" title="All 2 branches missed.">        assert(ipd);</span>
        
        //decompose Q = L * (sigma+) * L^T;  Q is size 3X3
<span class="fc" id="L2022">        double[][] q = LinearEquations.choleskyDecompositionViaMTJ(lPSD);</span>
        
        // (2*mImages)X3
<span class="fc" id="L2025">        double[][] _M = MatrixUtil.multiply(mC, q);</span>
        // 3XnFeatures
<span class="fc" id="L2027">        double[][] _S = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q), sC);</span>
        
<span class="fc" id="L2029">        System.out.printf(&quot;_M=\n%s\n&quot;, FormatArray.toString(_M, &quot;%.4e&quot;));</span>
        
        // assert that wC is the same as _M*_S
<span class="fc" id="L2032">        System.out.printf(&quot;_M*_S=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(_M, _S), </span>
            &quot;%.4e&quot;));
                
        /*
        --------------------------------
        Paraperspective Motion Recovery
        --------------------------------
        eqn(19) :
         `i_f = z_f*m_f + x_f*`k_f

         `j_f = z_f*n_f + y_f*`k_f


         Since the `i, `j, `k  produced must be orthonormal,
            they can be written as functions of only 3 rotational variables.
            We can then view the problem as, for each frame f,
              solving an overconstrained system of 6 equations
              (the expansion of (19) to each of its vector components)
              in 4 variables (the 3 rotational variables and zs).

              `i_f[0] = z_f * m_f[0] + x_f * `k_f[0]
              `i_f[1] = z_f * m_f[1] + x_f * `k_f[1]
              `i_f[2] = z_f * m_f[2] + x_f * `k_f[2]

              `j_f[0] = z_f * n_f[0] + y_f * `k_f[0]
              `j_f[1] = z_f * n_f[1] + y_f * `k_f[1]
              `j_f[2] = z_f * n_f[2] + y_f * `k_f[2]

          using the equalities of `k_f terms from eqn (19):
            `k_f[0]: (same for vector components [1] and [2]):

                (1/x_f)*(`i_f[0] - z_f * m_f[0]) = `k_f[0]

                (1/y_f)*(`j_f[0] - z_f * n_f[0]) = `k_f[0]

                (1/x_f)*(`i_f[0] - z_f * m_f[0]) = (1/y_f)*(`j_f[0] - z_f * n_f[0])
                `i_f[0] = z_f * m_f[0] + (x_f/y_f)*(`j_f[0] - z_f * n_f[0])
                        = `j_f[0]*(x_f/y_f) + z_f * m_f[0] - (x_f/y_f)*(z_f * n_f[0])
               generalized for each component::
                `i_f = `j_f*(x_f/y_f) + z_f*m_f - (x_f/y_f)*(z_f*n_f)
        
         rewriting `i_f, `j_f, and `k_f in terms of `j_f, m_f, n_f:
            `i_f = `j_f*(x_f/y_f) + z_f*m_f - (x_f/y_f)*(z_f*n_f)
            `j_f
            `k_f = `j_f*(1/y_f) - z_f*n_f*(1/y_f)

           dot product metrics:
            idoti: `i_f dot `i_f = 1
            jdotj: `j_f dot `j_f = 1
            idotj: `i_f dot `j_f = 0

            idoti: `i_f dot `i_f = 1:
                (`j_f dot `j_f)*(x_f/y_f)^2 + (m_f dot m_f)*(z_f)^2 - (n_f dot n_f)*(z_f)^2*(x_f/y_f)^2 = 1
                (1)*(x_f/y_f)^2 + (m_f dot m_f)*(z_f)^2 - (n_f dot n_f)*(z_f)^2*(x_f/y_f)^2 = 1
                (z_f)^2*((m_f dot m_f)-(n_f dot n_f)*(x_f/y_f)^2) + (x_f/y_f)^2 = 1
                (z_f)^2*((m_f[0]^2 + m_f[1]^2 + m_f[2]^2)-(n_f[0]^2 + n_f[1]^2 + n_f[2]^2)*(x_f/y_f)^2) + (x_f/y_f)^2 = 1
                (z_f)^2 = (1-(x_f/y_f)^2) / ((m_f[0]^2 + m_f[1]^2 + m_f[2]^2)-(n_f[0]^2 + n_f[1]^2 + n_f[2]^2)*(x_f/y_f)^2)
*          ====&gt; can solve for (z_f)^2 from this
           ==&gt;   Instead, using eqn (15) averages: 
                  zf^2 = (1/2)*( ((1+xf^2)/(mf*mf)) + ((1+yf^2)/(nf*nf)))

            jdotj:`j_f dot `j_f = 1:

            idotj:`i_f dot `j_f = 0:
                `j_f*(x_f/y_f) + z_f*m_f - (x_f/y_f)*(z_f*n_f) dot j_f = 0
                (`j_f dot `j_f)*(x_f/y_f) + (j_f dot m_f)*z_f - (j_f dot nf)*(z_f*x_f/y_f) = 0
                 (j_f dot m_f)*z_f - (j_f dot n_f)*(z_f*x_f/y_f) + (x_f/y_f) = 0
               factor this out for each component:
                (j_f[0]*m_f[0])*z_f - (j_f[0]*n_f[0])*(z_f*x_f/y_f) = -(x_f/y_f)
                j_f[0]*(m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f)) = -(x_f/y_f)
                j_f[0] = -(x_f/y_f)/ (m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f))
*            ===&gt; can solve for j_f from this

            rewrite `i_f from eqn (19) using the equalities of `k_f terms from above:
               `i_f[0] = `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f)
               `i_f[1] = `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*(z_f*x_f/y_f)
               `i_f[2] = `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*(z_f*x_f/y_f)
*            ===&gt; can solve for `i_f from this

          using orthogonality of `i_f,`j_f,`k_f to define `k_f:
               `k_f = `i_f cross `j_f
               `k_f[0] = `i_f[1]*`j_f[2] - `i_f[2]*`j_f[1]
               `k_f[1] = `i_f[2]*`j_f[0] - `i_f[0]*`j_f[2]
               `k_f[2] = `i_f[0]*`j_f[1] - `i_f[1]*`j_f[0]
*            ===&gt; can solve for `k_f from this
              uneeded details:
               `k_f[0] = `i_f[1]*`j_f[2] - `i_f[2]*`j_f[1]
                       = `j_f[2]*(`j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f))
                          - `j_f[1]*(`j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f))
               `k_f[1] = `i_f[2]*`j_f[0] - `i_f[0]*`j_f[2]
                       = `j_f[0]*(`j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f))
                          - `j_f[2]*(`j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f))
               `k_f[2] = `i_f[0]*`j_f[1] - `i_f[1]*`j_f[0]
                       = `j_f[1]*(`j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f))
                          - `j_f[0]*(`j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f))
    */    
        
        /*
        solve for z_f
           zf^2 = (1/2)*( ((1+xf^2)/(mf*mf)) + ((1+yf^2)/(nf*nf)))
        
        solve for `j_f:
            j_f[0] = -(x_f/y_f)/ (m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f))
                  ...
        
        solve for `i_f:
            `i_f[0] = `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f)
             i_f[1] = `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*(z_f*x_f/y_f)
             i_f[2] = `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*(z_f*x_f/y_f)
        
        solve for k_f:
            `k_f[0] = `i_f[1]*`j_f[2] - `i_f[2]*`j_f[1]
            `k_f[1] = `i_f[2]*`j_f[0] - `i_f[0]*`j_f[2]
            `k_f[2] = `i_f[0]*`j_f[1] - `i_f[1]*`j_f[0]
        */
                
<span class="fc" id="L2148">        double[] zf = new double[mImages];</span>
        double[] mf, nf, tmp1, tmp2, tmp3;
        double xDivY, mDotM, nDotN, tmp4, tmp5;
<span class="fc" id="L2151">        double[][] _MCameraOrientation2D = new double[2*mImages][3];</span>
<span class="fc bfc" id="L2152" title="All 2 branches covered.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc" id="L2153">            xf = t[i];</span>
<span class="fc" id="L2154">            yf = t[mImages + i];</span>
<span class="fc" id="L2155">            xDivY = xf/yf;</span>
<span class="fc" id="L2156">            mf = _M[i];</span>
<span class="fc" id="L2157">            nf = _M[mImages + i];</span>
<span class="fc" id="L2158">            mDotM = 0;</span>
<span class="fc" id="L2159">            nDotN = 0;</span>
<span class="fc bfc" id="L2160" title="All 2 branches covered.">            for (j=0; j&lt;mf.length; ++j) {</span>
<span class="fc" id="L2161">                mDotM += mf[i] * mf[i];</span>
<span class="fc" id="L2162">                nDotN += nf[i] * nf[i];</span>
            }
            //for z_f^2 take an average of eqn (15).  it's always positive
<span class="fc" id="L2165">            tmp4 = 1 + xf * xf;</span>
<span class="fc" id="L2166">            tmp4 /= mDotM;</span>
<span class="fc" id="L2167">            tmp5 = 1 + yf * yf;</span>
<span class="fc" id="L2168">            tmp5 /= nDotN;</span>
<span class="fc" id="L2169">            zf[i] = (tmp4 + tmp5) / 2.;</span>
<span class="fc" id="L2170">            zf[i] = Math.sqrt(zf[i]);</span>

            //j_f[0] = -(x_f/y_f)/ (m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f))
<span class="fc" id="L2173">            tmp1 = Arrays.copyOf(mf, mf.length);</span>
<span class="fc" id="L2174">            MatrixUtil.multiply(tmp1, zf[i]);</span>
<span class="fc" id="L2175">            tmp2 = Arrays.copyOf(nf, nf.length);</span>
<span class="fc" id="L2176">            MatrixUtil.multiply(tmp2, zf[i]);</span>
<span class="fc" id="L2177">            MatrixUtil.multiply(tmp2, xDivY);</span>
            // j_f
<span class="fc" id="L2179">            _MCameraOrientation2D[mImages + i] = new double[3];</span>
<span class="fc bfc" id="L2180" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L2181">                _MCameraOrientation2D[mImages + i][j] = -xDivY/(tmp1[j] - (tmp2[j]/yf));</span>
            }
            
            //`i_f = `j_f*(x_f/y_f) + m_f*z_f - n_f*(z_f*x_f/y_f)
<span class="fc" id="L2185">            tmp1 = Arrays.copyOf(_MCameraOrientation2D[mImages + i], _MCameraOrientation2D[mImages + i].length);</span>
<span class="fc" id="L2186">            MatrixUtil.multiply(tmp1, xDivY);</span>
<span class="fc" id="L2187">            tmp2 = Arrays.copyOf(mf, mf.length);</span>
<span class="fc" id="L2188">            MatrixUtil.multiply(tmp2, zf[i]);</span>
<span class="fc" id="L2189">            tmp3 = Arrays.copyOf(nf, nf.length);</span>
<span class="fc" id="L2190">            MatrixUtil.multiply(tmp3, zf[i]);</span>
<span class="fc" id="L2191">            MatrixUtil.multiply(tmp3, xDivY);</span>
            // i_f
<span class="fc" id="L2193">            _MCameraOrientation2D[i] = new double[3];</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L2195">                _MCameraOrientation2D[i][j] = tmp1[j] + tmp2[j] - tmp3[j];</span>
            }
        }
        
<span class="fc" id="L2199">        System.out.printf(&quot;_MCameraOrientation2D=\n%s\n&quot;, FormatArray.toString(_MCameraOrientation2D, &quot;%.4e&quot;));</span>
        
        // _M: rank is 3, mRows is &gt;= 4, nCols=3
        // _MCameraOrientation2D: rank is 3, mRows is &gt;= 4, nCols=3

        // _M * A = _MCameraOrientation2D
        // A = pseudoInv(_M)*_MCameraOrientation2D;
        // A^-1 = pseudoInv(_MCameraOrientation2D)*_M 
<span class="fc" id="L2207">        double[][] aInv = MatrixUtil.multiply(</span>
<span class="fc" id="L2208">            MatrixUtil.pseudoinverseFullColumnRank(_MCameraOrientation2D), _M);</span>
<span class="fc" id="L2209">        double[][] __S2 = MatrixUtil.multiply(aInv, _S);</span>
        
        
<span class="fc" id="L2212">        double[][] q2 = solveForTransformationToOrthoNormal(_MCameraOrientation2D);</span>
                
<span class="fc" id="L2214">        _MCameraOrientation2D = MatrixUtil.multiply(_MCameraOrientation2D, q2);</span>
        
        //assertDotProductMetrics(_MCameraOrientation2D, mImages);
        
        //_S2 is inv(q2)*shape
        //__S2 is inv(q2)*inv(a)*shape
<span class="fc" id="L2220">        double[][] _S2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q2), _S);</span>
<span class="fc" id="L2221">        __S2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q2), __S2);</span>
        
<span class="fc" id="L2223">        System.out.printf(&quot;after orthonormalization: _MCameraOrientation2D=\n%s\n&quot;, </span>
<span class="fc" id="L2224">            FormatArray.toString(_MCameraOrientation2D, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L2226">        System.out.printf(&quot;__S2=inv(q2)*inv(a)*_S=\n%s\n&quot;, FormatArray.toString(__S2, &quot;%.4e&quot;));</span>
<span class="fc" id="L2227">        System.out.printf(&quot;_S2=inv(q2)*_S=\n%s\n&quot;, FormatArray.toString(_S2, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L2229">        System.out.printf(&quot;_MCameraOrientation2D*__S2=\n%s\n&quot;, </span>
<span class="fc" id="L2230">            FormatArray.toString(MatrixUtil.multiply(_MCameraOrientation2D, __S2), &quot;%.4e&quot;));</span>
<span class="fc" id="L2231">        System.out.printf(&quot;_MCameraOrientation2D*_S2=\n%s\n&quot;, </span>
<span class="fc" id="L2232">            FormatArray.toString(MatrixUtil.multiply(_MCameraOrientation2D, _S2), &quot;%.4e&quot;));</span>
                  
        /*
        from Tomasi &amp; Kanade 1992:
        If desired, align the first camera reference system with the world
        reference system by forming the products R*R_0 and R_0^T*S,
        where the orthonormal matrix R_0 = [i1 j1 k1] rotates the ^Lfirst camera
        reference system into the identity matrix

        i0x i0y i0z    *  r0ix  r0jx  r0kx   = (i0 dot r0i)  (i0 dot r0j) (i0 dot r0k)
        i1x i1y i1z       r0iy  r0jy  r0ky
        i2x i2y i2z       r0iz  r0jz  r0kz
        i3x i3y i3z
        ...
        j0x j0y j0z
        j1x j1y j1z
        */
        

<span class="fc" id="L2251">        double[][] rFirst = new double[3][3];</span>
<span class="fc" id="L2252">        rFirst[0] = Arrays.copyOf(_MCameraOrientation2D[0], _MCameraOrientation2D[0].length);</span>
<span class="fc" id="L2253">        rFirst[1] = Arrays.copyOf(_MCameraOrientation2D[mImages], _MCameraOrientation2D[mImages].length);</span>
<span class="fc" id="L2254">        rFirst[2] = MatrixUtil.crossProduct(rFirst[0], rFirst[1]);</span>
        
<span class="fc" id="L2256">        double[][] r0 = MatrixUtil.pseudoinverseFullColumnRank(rFirst);</span>
        
<span class="fc" id="L2258">        System.out.printf(&quot;r0= \n%s\n&quot;, FormatArray.toString(r0,&quot;%.4e&quot;));</span>
        
<span class="fc" id="L2260">        System.out.printf(&quot;chk==1: \n%s\n&quot;, FormatArray.toString(</span>
<span class="fc" id="L2261">            MatrixUtil.multiply(rFirst, r0),&quot;%.4e&quot;));</span>
                  
        // multiply rotation matrices in the elements of the latest motion matrix by r0
<span class="fc" id="L2264">        double[][] rotStack = MatrixUtil.zeros(3*mImages, 3);</span>
<span class="fc" id="L2265">        double[][] _M3 = new double[3*mImages][];//(2*mImages)X3</span>
<span class="fc" id="L2266">        double[][] rTmp = new double[3][];</span>
<span class="fc bfc" id="L2267" title="All 2 branches covered.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc" id="L2268">            rTmp[0] = Arrays.copyOf(_MCameraOrientation2D[i], _MCameraOrientation2D[i].length);</span>
<span class="fc" id="L2269">            rTmp[1] = Arrays.copyOf(_MCameraOrientation2D[mImages + i], _MCameraOrientation2D[mImages + i].length);</span>
<span class="fc" id="L2270">            rTmp[2] = MatrixUtil.crossProduct(rTmp[0], rTmp[1]);</span>
<span class="fc" id="L2271">            rTmp = MatrixUtil.multiply(rTmp, r0);</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L2273">                rotStack[i*3 + j] = rTmp[j]; </span>
            }
<span class="fc" id="L2275">            _M3[i] = rTmp[0];</span>
<span class="fc" id="L2276">            _M3[i + mImages] = rTmp[1];</span>
<span class="fc" id="L2277">            _M3[i + 2*mImages] = rTmp[2];</span>
        }
        
<span class="fc" id="L2280">        double[][] _S3 = MatrixUtil.multiply(rFirst, __S2);</span>
        
<span class="fc" id="L2282">        System.out.printf(&quot;_M3=\n%s\n&quot;, FormatArray.toString(_M3,  &quot;%.4e&quot;));</span>
<span class="fc" id="L2283">        System.out.printf(&quot;rot stack=\n%s\n&quot;, FormatArray.toString(rotStack,  &quot;%.4e&quot;));</span>
<span class="fc" id="L2284">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(_S3, &quot;%.4e&quot;));</span>
<span class="fc" id="L2285">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        /*
        Poelman &amp; Kanade, last paragraph, Sect 3.4:
        All that remain to be computed are the translations for each frame. 
        We calculate the depth z_f from (15).  
        Once we know we x_f, y_f, z_f, `i_f, `j_f, `k_f 
        we can calculate `t_f using (4) and (5).
        
        eqn(4):
            z_f = -t_f dot k_f
        eqn (5):
            x_f = (-1/z_f)*(t_f dot i_f)
            and
            y_f = (-1/z_f)*(t_f dot j_f)

        use z_f equalities:
            z_f = -t_f dot k_f
                = -tf[0]*kf[0] + -tf[1]*kf[1] + -tf[2]*kf[2]

            z_f = (-1/x_f) * (t_f dot i_f)
                = -(1/xf)*tf[0]*if[0] + -(1/xf)*tf[1]*if[1] + -(1/xf)*tf[2]*if[2]

            z_f = (-1/y_f) * (t_f dot j_f)
                = -(1/yf)*tf[0]*jf[0] + -(1/yf)*tf[1]*jf[1] + -(1/yf)*tf[2]*jf[2]
            
        factor:
           tf[0]           tf[1]           tf[2]         const
           -------------------------------------------
            kf[0]           kf[1]          kf[2]         -zf
            (1/xf)*if[0]    (1/xf)*if[1]   (1/xf)*if[2]  -zf
            (1/yf)*jf[0]    (1/yf)*jf[1]   (1/yf)*jf[2]  -zf
        */
<span class="fc" id="L2318">        double[][] trans = new double[mImages][3];</span>
<span class="fc" id="L2319">        double[][] tf = MatrixUtil.zeros(3, 3);</span>
        double[][] g3Inv;
        double[] i3Vector;
<span class="fc" id="L2322">        double[] cs = new double[3];</span>
<span class="fc bfc" id="L2323" title="All 2 branches covered.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc" id="L2324">            Arrays.fill(cs, -zf[i]);</span>
<span class="fc" id="L2325">            xf = t[i];</span>
<span class="fc" id="L2326">            yf = t[mImages + i];</span>
            
            // i_f[i] is _M3[i]
            // j_f[i] is _M3[mImages + i]
            // k_f[i] is _M3[2*mImages + i]
<span class="fc bfc" id="L2331" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L2332">                tf[0][j] = _M3[2*mImages + i][j];</span>
<span class="fc" id="L2333">                tf[1][j] = _M3[i][j]/xf;</span>
<span class="fc" id="L2334">                tf[2][j] = _M3[mImages + i][j]/yf;</span>
            }            
            //SVDProducts svdi = MatrixUtil.performSVD(tf);
<span class="fc" id="L2337">            g3Inv = MatrixUtil.pseudoinverseFullColumnRank(tf);</span>
<span class="fc" id="L2338">            i3Vector = MatrixUtil.multiplyMatrixByColumnVector(g3Inv, cs);</span>
<span class="pc bnc" id="L2339" title="All 2 branches missed.">            assert(i3Vector.length == 3);</span>
            
<span class="fc" id="L2341">            trans[i] = new double[]{i3Vector[0], i3Vector[1], i3Vector[2]};</span>
        }
        
<span class="fc" id="L2344">        System.out.printf(&quot;trans=\n%s\n&quot;, FormatArray.toString(trans, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L2346">        ParaperspectiveProjectionResults results = new ParaperspectiveProjectionResults();</span>
<span class="fc" id="L2347">        results.XW = _S3; // or _S</span>
<span class="fc" id="L2348">        results.rotationMatrices = rotStack;</span>
<span class="fc" id="L2349">        results.translationVectors = trans;</span>
          
<span class="fc" id="L2351">        return results;        </span>
    }
    
    private static DenseMatrix extractIndices(DenseMatrix m, List&lt;Integer&gt; inlierIndexes) {
<span class="fc" id="L2355">        DenseMatrix out = new DenseMatrix(m.numRows(), inlierIndexes.size());</span>
<span class="fc" id="L2356">        int r = 0;</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">        for (int i = 0; i &lt; inlierIndexes.size(); ++i) {</span>
<span class="fc" id="L2358">            int idx = inlierIndexes.get(i);</span>
<span class="fc bfc" id="L2359" title="All 2 branches covered.">            for (int j = 0; j &lt; m.numRows(); ++j) {</span>
<span class="fc" id="L2360">                out.add(j, r, m.get(j, idx));</span>
            }
<span class="fc" id="L2362">            r++;</span>
        }
<span class="fc" id="L2364">        return out;</span>
    }

    private static double[] gT(double[] a, double[] b) {
<span class="fc" id="L2368">        double[] gT = new double[]{</span>
            a[0]*b[0], 
            a[0]*b[1] + a[1]*b[0],
            a[0]*b[2] + a[2]*b[0],
            a[1]*b[1],
            a[1]*b[2] + a[2]*b[1],
            a[2]*b[2]
        };
<span class="fc" id="L2376">        return gT;</span>
    }

    private static double[][] extractAndNormalize(double[][] x, int imageNumber, 
        int nFeatures, double[] outputNorm) {
        
<span class="nc" id="L2382">        double[][] xN = new double[3][nFeatures];</span>
<span class="nc" id="L2383">        xN[0] = new double[nFeatures];</span>
<span class="nc" id="L2384">        xN[1] = new double[nFeatures];</span>
<span class="nc" id="L2385">        xN[2] = new double[nFeatures];</span>
<span class="nc" id="L2386">        Arrays.fill(xN[2], 1);</span>
        
<span class="nc" id="L2388">        int imageIdx = (x.length/nFeatures)*imageNumber;</span>
        
<span class="nc" id="L2390">        double cen0 = 0;</span>
<span class="nc" id="L2391">        double cen1 = 0;</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2393">            cen0 += x[0][imageIdx + i];</span>
<span class="nc" id="L2394">            cen1 += x[0][imageIdx + i];</span>
        }
<span class="nc" id="L2396">        cen0 /= (double)nFeatures;</span>
<span class="nc" id="L2397">        cen1 /= (double)nFeatures;</span>

<span class="nc" id="L2399">        double scale = 0;</span>
        double diffX, diffY;
<span class="nc bnc" id="L2401" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2402">            diffX = x[0][imageIdx + i] - cen0;</span>
<span class="nc" id="L2403">            diffY = x[0][imageIdx + i] - cen1;</span>
<span class="nc" id="L2404">            scale += (diffX*diffX + diffY*diffY);</span>
        }
<span class="nc" id="L2406">        scale = Math.sqrt(scale/(2.*(nFeatures - 1.)));</span>
        // to use std dev instead: scale = Math.sqrt(scale/(n-1.));
        
<span class="nc" id="L2409">        outputNorm[imageNumber*3 + 0] = cen0;</span>
<span class="nc" id="L2410">        outputNorm[imageNumber*3 + 1] = cen1;</span>
<span class="nc" id="L2411">        outputNorm[imageNumber*3 + 2] = scale;</span>
        
<span class="nc bnc" id="L2413" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2414">            xN[0][i] = (x[0][imageIdx + i] - cen0)/scale;</span>
<span class="nc" id="L2415">            xN[1][i] = (x[1][imageIdx + i] - cen1)/scale;</span>
        }
        
<span class="nc" id="L2418">        return xN;</span>
    }

    private static void calculateLeftEpipole(DenseMatrix fundamentalMatrix,
        double[] outputE01) throws NotConvergedException {
        
<span class="nc bnc" id="L2424" title="All 2 branches missed.">        if (outputE01.length != 3) {</span>
<span class="nc" id="L2425">            throw new IllegalArgumentException(&quot;outputE01 length must be 3&quot;);</span>
        }
        
<span class="nc" id="L2428">        SVDProducts svdE = MatrixUtil.performSVD(fundamentalMatrix);</span>
        
        /*
         The left epipole is e1 = last column of U / last item of that column
         It is  the left image position of the epipolar projection of the right camera center
         The right epipole e2 = last row of V / last item of that row
         It is the right image position of the epipolar projection of the left camera center
        */
        
<span class="nc bnc" id="L2437" title="All 2 branches missed.">        assert(svdE.u[0].length == 3);</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">        assert(svdE.u.length == 3);</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">        assert(svdE.vT[0].length == 3);</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">        assert(svdE.vT.length == 3);</span>
        
        //double e1Div = svdE.vT[2][2];
<span class="nc bnc" id="L2443" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L2444">            outputE01[i] = svdE.vT[2][i];///e1Div;</span>
        }
<span class="nc" id="L2446">    }</span>

    private static void extractColumn(double[][] x, int idx, double[] outputPoint) {
<span class="nc" id="L2449">        outputPoint[0] = x[0][idx];</span>
<span class="nc" id="L2450">        outputPoint[1] = x[1][idx];</span>
<span class="nc" id="L2451">        outputPoint[2] = x[2][idx];</span>
<span class="nc" id="L2452">    }</span>

    /**
     * 
     * @param motion 2*F X 3 matrix of rotation for images
     * where the first F rows are the first rows of each image's rotation matrix
     * and the second F rows are the second rows of each image's rotation matrix.
     * the third row of rotation is recreated when needed using the cross
     * product of the first 2 rows of each image's rotation matrix;
     * @return
     * @throws NotConvergedException 
     */
    private static double[][] solveForTransformationToOrthoNormal(double[][] motion) throws NotConvergedException {
         /*
        The rows of R represent the orientations of the horizontal and vertical camera
        reference axes throughout the stream, 
        while the columns of S are the coordinates of the P feature
        points with respect to their centroid.
        
    motion = [ i_hat_0[0] i_hat_0[2] i_hat_0[2] ] where i_hat_f are unit vectors
             [ i_hat_1[0] i_hat_1[2] i_hat_1[2] ]
             [   ..._m-1 ...                    ]
             [ j_hat_0[0] j_hat_0[2] j_hat_0[2] ]
             [ j_hat_1[0] j_hat_1[2] j_hat_1[2] ] where j_hat_f are unit vectors
             [  ..._m-1 ... ]
        
    shape = [s_C_1  ...  s_C_m] is [3XP] where P is the number of points per image frame
        NOTE that the summation over columns of sC = 0 (they are centered w.r.t. image points)
        
        R = motion*Q
        S = (Q^-1)*shape
        
          eqn (1)  (`i_f)^T * Q * Q^T * (`i_f) = 1   [dimensions 1X3 * 3X3 * 3X1 = 1]
          eqn (2)  (`j_f)^T * Q * Q^T * (`j_f) = 1
          eqn (3)  (`i_f)^T * Q * Q^T * (`j_f) = 0
        
        find Q as a 3 × 3 matrix, non-singular matrix
        
        //Morita and Kanade
        L = Q^T * Q
        solve the linear system of equations for L 
            and use Cholesky decomposition to get Q.
            Correct the decomposition to enforce L to be positive definite
            symmetric.
        
        See notes reference Morita and Kanade for solving Q.
         T. Morita and T. Kanade, A Sequential Factorization Method for Recovering Shape and Motion
         from Image Streams, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 19,
         no.8, pp.858-867, Aug 1997  (1994?)
        
        http://note.sonots.com/SciSoftware/Factorization.html#cse252b
        
        L = [ l1 l2 l3 ]
            [ l2 l4 l5 ]
            [ l3 l5 l6 ]     

        the knowns are `i_f and `j_f, so we are solving for the 6 unknowns in L.

        expand the terms:

        eqn(1):
        if_0  if_1  if_2 ] * [ l1 l2 l3 ] * [ if_0 ] = 1
                             [ l2 l4 l5 ]   [ if_1 ]
                             [ l3 l5 l6 ]   [ if_2 ]
        eqn(2):
        jf_0  jf_1  jf_2 ] * [ l1 l2 l3 ] * [ jf_0 ] = 1
                             [ l2 l4 l5 ]   [ jf_1 ]
                             [ l3 l5 l6 ]   [ jf_2 ]
        eqn(3):
        if_0  if_1  if_2 ] * [ l1 l2 l3 ] * [ jf_0 ] = 0
                             [ l2 l4 l5 ]   [ jf_1 ]
                             [ l3 l5 l6 ]   [ jf_2 ]
        
        eqn(1):
        l1*if_0*if_0 + l2*if_1*if_0 + l3*if_2*if_0 + l2*if_0*if_1 + l4*if_1*if_1 + l5*if_2*if_1 + l3*if_0*if_2 + l5*if_1*if_2 + l6*if_2*if_2 = 1
        eqn(2):
        l1*jf_0*jf_0 + l2*jf_1*jf_0 + l3*jf_2*jf_0 + l2*jf_0*jf_1 + l4*jf_1*jf_1 + l5*jf_2*jf_1 + l3*jf_0*jf_2 + l5*jf_1*jf_2 + l6*jf_2*jf_2 = 1
        eqn(3):
        l1*if_0*jf_0 + l2*if_1*jf_0 + l3*if_2*jf_0 + l2*if_0*jf_1 + l4*if_1*jf_1 + l5*if_2*jf_1 + l3*if_0*jf_2 + l5*if_1*jf_2 + l6*if_2*jf_2 = 1
        
        factor out the L terms, linearly
        l1           l2                    l3                    l4           l5                    l6         const
        (if0*if0)    (if1*if0 + if0*if1)   (if2*if0 + if0*if2)   (if1*if1)    (if2*if1 + if1*if2)   (if2*if2)   1
        (jf0*jf0)    (jf1*jf0 + jf0*jf1)   (jf2*jf0 + jf0*jf2)   (jf1*jf1)    (jf2*jf1 + jf1*jf2)   (jf2*jf2)   1
        (if0*jf0)    (if1*jf0 + if0*jf1)   (if2*jf0 + if0*jf2)   (if1*jf1)    (if2*jf1 + if1*jf2)   (if2*jf2)   0

        since the terms in the rows have a similar pattern, can write the equation more concisely using
        a function to generate them:
           g(a,b) = [a0*b0         ]
                    [a0*b1 + a1*b0 ]
                    [a0*b2 + a2*b0 ]
                    [a1*b1         ]
                    [a1*b2 + a2*b1 ]
                    [a2*b2         ]

        G size is 3*F X 6
        L is a vector of length 6
        c size is 3*F
        
        the G = [ g(i_0, i_0)^T       ]   L_vectorized = [l1]    c = [2*F rows of 1]
                [ ...each row thru F  ]                  [l2]        [F rows of 0  ]
                [ g(j_0, j_0)^T       ]                  [l3]
                [ ...each row thru F  ]                  [l4]
                [ g(i_0, j_0)^T       ]                  [l5]
                [ ...each row thru F  ]                  [l6]

        G*L_vectorized = c ==&gt;  L_vectorized = G^-1 * c
        */
        
<span class="fc" id="L2561">         int mImages = motion.length/2;</span>
        
        int i, j;
<span class="fc" id="L2564">        double[] c = new double[3*mImages];</span>
<span class="fc bfc" id="L2565" title="All 2 branches covered.">        for (i = 0; i &lt; 2*mImages; ++i) {</span>
<span class="fc" id="L2566">            c[i] = 1;</span>
        }
        
        //g is 3F X 6
<span class="fc" id="L2570">        double[][] g = new double[3*mImages][6];</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">        for (i = 0; i &lt; 2*mImages; ++i) {</span>
<span class="fc" id="L2572">            g[i] = gT(motion[i], motion[i]);</span>
<span class="pc bnc" id="L2573" title="All 2 branches missed.">            assert(g[i].length == 6);</span>
        }
<span class="fc bfc" id="L2575" title="All 2 branches covered.">        for (i = 2*mImages, j=0; i &lt; 3*mImages; ++i, j++) {</span>
<span class="fc" id="L2576">            g[i] = gT(motion[j], motion[mImages + j]);</span>
        }
                
        // rank of G is 4
        //G * L = c
        // G^T * G * L = G^T * c
        // L = (G^T*G)^-1*G^T * c
        //     pseudoinverse of G is (G^T*G)^-1*G^T
<span class="fc" id="L2584">        double[][] gInv = MatrixUtil.pseudoinverseRankDeficient(g);</span>
        
        // 6X1
<span class="fc" id="L2587">        double[] lVector = MatrixUtil.multiplyMatrixByColumnVector(gInv, c);</span>
<span class="pc bnc" id="L2588" title="All 2 branches missed.">        assert(lVector.length == 6);</span>
        
        // 3X3
<span class="fc" id="L2591">        double[][] ell = new double[3][3];</span>
<span class="fc" id="L2592">        ell[0] = new double[]{lVector[0], lVector[1], lVector[2]};</span>
<span class="fc" id="L2593">        ell[1] = new double[]{lVector[1], lVector[3], lVector[4]};</span>
<span class="fc" id="L2594">        ell[2] = new double[]{lVector[2], lVector[4], lVector[5]};</span>
        
        // Q can be determined :
        //   as the square root of ell,
        //   or with the Cholesky decomposition
        //   or with eigendecomposition
        
        // enforcing positive definiteness of L (which is ell here).
<span class="fc" id="L2602">        double eps = 1e-16;//1.e-11; eps close to zero within machine precision to perturb the matrix to smallest eigenvalue of eps</span>
<span class="fc" id="L2603">        double[][] lPSD = MatrixUtil.nearestPositiveSemidefiniteToASymmetric(ell, eps);</span>

        // debugging
<span class="fc" id="L2606">        EVD evd2 = EVD.factorize(new DenseMatrix(lPSD));</span>
<span class="fc" id="L2607">        double[] eig = evd2.getRealEigenvalues();</span>
<span class="fc" id="L2608">        double[][] aMinusPSD = MatrixUtil.pointwiseSubtract(ell, lPSD);</span>
<span class="fc" id="L2609">        double dist1 = MatrixUtil.frobeniusNorm(aMinusPSD);</span>

<span class="fc" id="L2611">        boolean ipd = MatrixUtil.isPositiveDefinite(lPSD);</span>
<span class="pc bpc" id="L2612" title="1 of 2 branches missed.">        if (!ipd) {</span>
            //TODO: consider throwing an exception so i'll fix this...
<span class="nc" id="L2614">            System.err.printf(&quot;WARNING: matrix L_PSD is not positive semi-definite.&quot; +</span>
<span class="nc" id="L2615">                    &quot; The distance between L and L_PSD=%.3e, but should be near 0.\n&quot;, dist1);</span>
        }

       
        //decompose Q = L * (sigma+) * L^T;  Q is size 3X3
<span class="fc" id="L2620">        double[][] q = LinearEquations.choleskyDecompositionViaMTJ(lPSD);</span>
        
<span class="fc" id="L2622">        return q;</span>
    }

    private static void assertDotProductMetrics(double[][] motion,
        int mImages) {
        double[] tmp1, tmp2, tmp3;
        int i, j;
        double tmp4, tmp5, tmp6, tmp7;
<span class="nc bnc" id="L2630" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2631">            tmp1 = Arrays.copyOf(motion[i], motion[i].length);</span>
<span class="nc" id="L2632">            tmp2 = Arrays.copyOf(motion[mImages + i], motion[mImages + i].length);</span>
<span class="nc" id="L2633">            tmp3 = MatrixUtil.crossProduct(tmp1, tmp2);</span>
<span class="nc" id="L2634">            tmp4 = 0; // i dot i = 1</span>
<span class="nc" id="L2635">            tmp5 = 0; // j dot j = 1</span>
<span class="nc" id="L2636">            tmp6 = 0; // i dot j = 0</span>
<span class="nc" id="L2637">            tmp7 = 0; // k dot k = 1</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2639">                tmp4 += (tmp1[j]*tmp1[j]);</span>
<span class="nc" id="L2640">                tmp5 += (tmp2[j]*tmp2[j]);</span>
<span class="nc" id="L2641">                tmp6 += (tmp1[j]*tmp2[j]);</span>
<span class="nc" id="L2642">                tmp7 += (tmp3[j]*tmp3[j]);</span>
            }
<span class="nc" id="L2644">            System.out.printf(&quot;tmps:%.4e, %.4e, %.4e, %.4e\n&quot;, tmp4, tmp5, tmp7, tmp6);</span>
            /* if had perfect data:
            assert(Math.abs(tmp4 - 1) &lt; 1e-2);
            assert(Math.abs(tmp5 - 1) &lt; 1e-2);
            assert(Math.abs(tmp7 - 1) &lt; 1e-2);
            assert(Math.abs(tmp6) &lt; 1e-2);
            */
        }
<span class="nc" id="L2652">    }</span>

    /**
     * calculates the homography as the canonical pose for the un-calibrated camera
     * (the projective projection as the 2nd image's projection
     * in the canonical decomposition, pg 189 of MASKS).
     * &lt;pre&gt;
     * The homography H in [x2]_x*H*x1 = [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 ~ 0
     * where [b]_x is the skew-symmetric matrix of vector b.
     *
     * the skew symmetric matrix multiplication replaces the cross product.
     * x2 cross H*x1 ~ 0.
     *
     * Details from Chapter 6 of Ma, Soatto, Kosecka,&amp; Sastry (MASKS)
     * &quot;An Invitation to Computer Vision, From Images to Geometric Models&quot;
     *
     * let X' = K*X and T'=K*T where K is the intrinsic camera parameters matrix.
     *
     * from euclidean transformation, we can derive the
     * epipolar constraint:  x2'^T * [T']_x * K *R * K^-1 * x1' = 0
     *
     * x2^T*[T]_x*R*x1=0 &lt;==&gt; x2'^T * [T']_x * K *R * K^-1 * x1' = 0
    
    *     F = K^-T * [T]_x * R * K^-1 (when K=I, F=E)
            = [T']_x * K * R * K^-1 if det(K)=1, else it's approx (up to a scale factor)
    
    *    epipoles e2^T*F = 0, F*e1 = 0.
         e2 = K*T
         e1 = K*R^T*T
         
    epipolar constraint for uncalibrated cameras:
        x2'^T * [T']_x * K *R * K^-1 * x1' = x2'^T * [T']_x * (K*R*K^-1 + T'*v^T)*x1'
        = x2'^T * [T']_x * R' * x1'
           where v is an arbitraty vector
           
    since F = [T']_x * K *R * K^-1,
       fitting for the projection |(K*R*K^-1 + T'*v^T), v_4*T'|
    one can then approximate the uncalibrated camera pose.
    this is a 4-parameter family of ambiguous decompositions.
    pg 187 of MASKS.
    This method implements point 4 in algorithm 11.9 on pg 405, Section 11.5 of MASKS.    
     * &lt;/pre&gt;
     * @param x1P the image 1 (a.k.a. left) half of correspondence points. format is 3 x N
     * where N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points) since
     * internally an identity matrix is used for K.
     * @param x2P the image 2 (a.k.a. right) half of correspondence points. format is 3 x N where
     * N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points).
     * @param fm the fundamental matrix.  size is 3X3.
     * @param e2 the left null space in the left singular vector of F.
     * it's the last column of svd(fm).u and represents the location of
     * the image 1 optical center (a.k.a. camera center).
     * The epipole is the point where the baseline (the line joining the two
     * camera centers ol, O2) intersects the image plane in each view,
     * e2^T*F=0.  e2 = K*T where T is translation vector between cameras
     * (a.k.a. the extrinsic camera parameter called translation).
     * (NOTE: e1=K*R^T*T where R and T are extrinsic camera rotation and translation).
     * @return
     * @throws NotConvergedException
     */
    public static double[][] calculateProjectiveHomographyWithLeastSquares(double[][] x1P, double[][] x2P, double[][] fm, double[] e2) throws NotConvergedException {
        
        /*
        Compute the least-squares solution v from equation (11.30) using the
        set of matched feature points, and determine the matching homography
        
            [x2]_x*H*x1 = [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 ~ 0
            fit for v=[v0,v1,v2]^T w/ total least squares
        that is minarg_v( summation_over_j( || [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 ||^2)
        where j is the enumeration of points
                
        then determine H: = ([e2]_x)^T * F + e2*v^T
                
        calculate [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 in pieces, separating the multiplication
        that includes v from the rest:
        [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1
        = [x2]_x*( ([e2]_x)^T * F)*x1 + [x2]_x*( (e2*v^T)*x1 )
        [x2]_x =|0       -x2[2]  x2[1]  |
                |x2[2]   0       -x2[0] |
                |-x2[1]  x2[0]   0      |
    ([e2]_x)^T =| 0      -e2[2]   e2[1] |^T = | 0       e2[2]  -e2[1]|
                | e2[2]      0   -e2[0] |     | -e2[2]  0       e2[0]|
                | -e2[1]  e2[0]     0   |     | e2[1]   -e2[0]  0    |
                
 [e2]_x^T * F = | 0       e2[2]  -e2[1]| * | F00 F01 F02 |
                | -e2[2]  0       e2[0]|   | F10 F11 F12 |
                | e2[1]   -e2[0]  0    |   | F20 F21 F22 |
          
              = e2[2]*F10 - e2[1]*F20   e2[2]*F11 - e2[1]*F21   e2[2]*F12 - e2[1]*F22
                -e2[2]*F00 + e2[0]*F20  -e2[2]*F01 + e2[0]*F21  -e2[2]*F02 + e2[0]*F22
                e2[1]*F00 - e2[0]*F10   e2[1]*F01 - e2[0]*F11   e2[1]*F02 - e2[0]*F12
                
        for simpler notation,
         use e2STF = ([e2]_x)^T * F = | e2STF00 e2STF01 e2STF02 |
                                      | e2STF10 e2STF11 e2STF12 |
                                      | e2STF20 e2STF21 e2STF22 |
                
        let x1=[x10,x11,x12] and x1=[x20,x21,x22]
        ( ([e2]_x)^T * F)*x1
               =| e2STF00 e2STF01 e2STF02 | * | x10 |
                | e2STF10 e2STF11 e2STF12 |   | x11 |
                | e2STF20 e2STF21 e2STF22 |   | x12 |
               =| e2STF00*x10+e2STF01*x11+e2STF02*x12 |
                | e2STF10*x10+e2STF11*x11+e2STF12*x12 |
                | e2STF20*x10+e2STF21*x11+e2STF12*x22 |
                [x2]_x*( ([e2]_x)^T * F)*x1 = 3X3 * 3X1 = 3X1
        for simpler notation,
        using b = the 3X1 product of [x2]_x*( ([e2]_x)^T * F)*x1
        b = b0
            b1
            b2
                
        now the multiplication that includes v: [x2]_x*( (e2*v^T)*x1 )
        let e2[0]=e20, e2[1]=e21, e2[2]=e22
        let x1[0][i] = x10, x1[1][i] = x11, x1[1][i] = x11
        let x2[0][i] = x20, x2[1][i] = x21, x2[1][i] = x21
        let v=v1,v2,v3
                
        e2*v^T = e20*v0  e20*v1  e20*v2
                 e21*v0  e21*v1  e21*v2
                 e22*v0  e22*v1  e22*v2
                
        [x2]_x*(e2*v^T)*x1
        = |0     -x22  x21 | * | e20*v0  e20*v1  e20*v2 | * | x10 |
          |x22   0    -x20 |   | e21*v0  e21*v1  e21*v2 |   | x11 |
          |-x21  x20   0   |   | e22*v0  e22*v1  e22*v2 |   | x12 |
        = |0     -x22  x21 | * | e20*v0*x10 + e20*v1*x11 + e20*v2*x12 |
          |x22   0    -x20 |   | e21*v0*x10 + e21*v1*x11 + e21*v2*x12 |
          |-x21  x20   0   |   | e22*v0*x10 + e22*v1*x11 + e22*v2*x12 |
        = |-x22*(e21*v0*x10 + e21*v1*x11 + e21*v2*x12) + x21*(e22*v0*x10 + e22*v1*x11 + e22*v2*x12) |
          |x22*(e20*v0*x10 + e20*v1*x11 + e20*v2*x12) -x20*(e22*v0*x10 + e22*v1*x11 + e22*v2*x12)   |
          |-x21*(e20*v0*x10 + e20*v1*x11 + e20*v2*x12) + x20*(e21*v0*x10 + e21*v1*x11 + e21*v2*x12  |
        = |v0*(-x22*e21*x10+x21*e22*x10) + v1*(-x22*e21*x11+x21*e22*x11) + v2*(-x22*e21*x12+x21*e22*x12) |
          |v0*(x22*e20*x10-x20*e22*x10) + v1*(x22*e20*x11-x20*e22*x11) + v2*(x22*e20*x12-x20*e22*x12)    |
          |v0*(-x21*e20*x10+x20*e21*x10) + v1*(-x21*e20*x11+x20*e21*x11) + v2*(-x21*e20*x12+x20*e21*x12) |
                
        A * x = b where A_i is size 3X3 matrix of v factors
        x is size 1X3 vector to be solved for
        b is size 1X3 =  -1*remaining terms for each row of the objective
                
        |i=0: v0 factors  v1 factors  v2 factors | * |v0| = |-b0|
                                                     |v1|   |-b1|
                                                     |v2|   |-b2|
        
        can solve using
            v = SVD(A | b).vT[last row, first 3 elements)
        or v = pseudoInv(A) * b
        
        They both produce the same answer, though might need multiplication by -1.
        */
        // these are 3X3
<span class="fc" id="L2806">        double[][] e2SkewT = MatrixUtil.transpose(MatrixUtil.skewSymmetric(e2));</span>
<span class="fc" id="L2807">        double[][] e2SkewTF = MatrixUtil.multiply(e2SkewT, fm);</span>
<span class="fc" id="L2808">        int n = x1P[0].length;</span>
        int i;
<span class="fc" id="L2810">        double[] x1 = new double[3];</span>
<span class="fc" id="L2811">        double[] x2 = new double[3];</span>
        //3*n X 1
<span class="fc" id="L2813">        double[] b = new double[3 * n];</span>
        //3*n X 3
<span class="fc" id="L2815">        double[][] a = new double[3 * n][];</span>
        
        //3X3
<span class="fc" id="L2818">        double[][] x2Skew = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L2819">        double[][] tmp = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L2820">        double[] bI = new double[3];</span>
        double x10;
        double x11;
        double x12;
        double x20;
        double x21;
        double x22;
        double e20;
        double e21;
        double e22;
<span class="fc bfc" id="L2830" title="All 2 branches covered.">        for (i = 0; i &lt; x1P[0].length; ++i) {</span>
<span class="fc" id="L2831">            MatrixUtil.extractColumn(x1P, i, x1);</span>
<span class="fc" id="L2832">            MatrixUtil.extractColumn(x2P, i, x2);</span>
<span class="fc" id="L2833">            MatrixUtil.skewSymmetric(x2, x2Skew);</span>
            // 3X1  [x2]_x*( ([e2]_x)^T * F)*x1
<span class="fc" id="L2835">            MatrixUtil.multiply(x2Skew, e2SkewTF, tmp);</span>
<span class="fc" id="L2836">            MatrixUtil.multiplyMatrixByColumnVector(tmp, x1, bI);</span>
<span class="fc" id="L2837">            MatrixUtil.multiply(bI, -1);</span>
<span class="fc" id="L2838">            System.arraycopy(bI, 0, b, i * 3, 3);</span>
<span class="fc" id="L2839">            x10 = x1[0];</span>
<span class="fc" id="L2840">            x11 = x1[1];</span>
<span class="fc" id="L2841">            x12 = x1[2];</span>
<span class="fc" id="L2842">            x20 = x2[0];</span>
<span class="fc" id="L2843">            x21 = x2[1];</span>
<span class="fc" id="L2844">            x22 = x2[2];</span>
<span class="fc" id="L2845">            e20 = e2[0];</span>
<span class="fc" id="L2846">            e21 = e2[1];</span>
<span class="fc" id="L2847">            e22 = e2[2];</span>
            /*
            [x2]_x*(e2*v^T)*x1
              = |v0*(-x22*e21*x10+x21*e22*x10) + v1*(-x22*e21*x11+x21*e22*x11) + v2*(-x22*e21*x12+x21*e22*x12) |
                |v0*(x22*e20*x10-x20*e22*x10) + v1*(x22*e20*x11-x20*e22*x11) + v2*(x22*e20*x12-x20*e22*x12)    |
                |v0*(-x21*e20*x10+x20*e21*x10) + v1*(-x21*e20*x11+x20*e21*x11) + v2*(-x21*e20*x12+x20*e21*x12) |
             */
<span class="fc" id="L2854">            a[i * 3] = new double[]{-x22 * e21 * x10 + x21 * e22 * x10, -x22 * e21 * x11 + x21 * e22 * x11, -x22 * e21 * x12 + x21 * e22 * x12};</span>
<span class="fc" id="L2855">            a[i * 3 + 1] = new double[]{x22 * e20 * x10 - x20 * e22 * x10, x22 * e20 * x11 - x20 * e22 * x11, x22 * e20 * x12 - x20 * e22 * x12};</span>
<span class="fc" id="L2856">            a[i * 3 + 2] = new double[]{-x21 * e20 * x10 + x20 * e21 * x10, -x21 * e20 * x11 + x20 * e21 * x11, -x21 * e20 * x12 + x20 * e21 * x12};</span>
        }
        // 
        //    as -1*v below
        
        //A * x = b
        // x = A^-1 * b
        // 3 X n
<span class="fc" id="L2864">        double[][] aInv = MatrixUtil.pseudoinverseFullColumnRank(a);</span>
<span class="fc" id="L2865">        double[] v = MatrixUtil.multiplyMatrixByColumnVector(aInv, b);</span>
        //H = ([e2]_x)^T * F + e2*v^T
        //  = e2SkewTF + e2*v^T
<span class="fc" id="L2868">        double[][] h = MatrixUtil.pointwiseAdd(e2SkewTF, MatrixUtil.outerProduct(e2, v));</span>
<span class="fc" id="L2869">        return h;</span>
    }
    
    public static class ProjectionResults {
        /**
         * world coordinate system points in matrix of size 4 X nFeatures.
         * The points are stacked along columns sequentially.
         */
        public double[][] XW;
        
        /**
         * the projection matrices stacked along rows for each image.
         * so projection for image 0 will be in rows [0, 3);
         * projection for image 1 will be in rows [3, 6), etc.
         * This matrix's size is 3*nImages X 4
         */
        public double[][] projectionMatrices;
    }
    
    public static class OrthographicProjectionResults {
        /**
         * world coordinate system points
         */
        public double[][] XW;
        
        /**
         * the rotation matrices stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public double[][] rotationMatrices;
    }
    
    public static class ParaperspectiveProjectionResults {
        /**
         * world coordinate system points
         */
        private double[][] XW;
        
        /**
         * the rotation matrices (as extrinsic parameters) stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        private double[][] rotationMatrices;
        
        /**
         * the translation vectors (as extrinsic parameters) 
         * stacked along rows for each image.
         * 
         */
        private double[][] translationVectors;

        /**
         * @return the XW
         */
        public double[][] getXW() {
            return XW;
        }

        /**
         * @param XW the XW to set
         */
        public void setXW(double[][] XW) {
            this.XW = XW;
        }

        /**
         * @return the rotationMatrices (as extrinsic parameters) 
         * stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public double[][] getRotationStack() {
            return rotationMatrices;
        }

        /**
         * @param rotationMatrices the rotationMatrices to set.
         * the rotation matrices (as extrinsic parameters) stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public void setRotationStack(double[][] rotationMatrices) {
            this.rotationMatrices = rotationMatrices;
        }

        /**
         * @return the translationVectors
         */
        public double[][] getTranslationVectorStack() {
            return translationVectors;
        }

        /**
         * @param translationVectors the translationVectors to set
         */
        public void setTranslationVectorStack(double[][] translationVectors) {
            this.translationVectors = translationVectors;
        }
        
        public double[][] getExtrinsicProjection(int imageNumber) {
            double[][] p = new double[3][4];
            for (int i = 0; i &lt; 3; ++i) {
                p[i] = new double[4];
                System.arraycopy(rotationMatrices[imageNumber*3 + i], 0, p[i], 0, 3);
                p[i][4] = translationVectors[imageNumber][i];
            }
            return p;
        }
    }

    public static class ReconstructionResults {
        double[][] XW;
        double[][] k1Intr;
        double[][] k2Intr;
        double[][] k1ExtrRot;
        double[] k1ExtrTrans;
        double[][] k2ExtrRot;
        double[] k2ExtrTrans;
        double[][] essentialMatrix;
        SVDProducts svd;
        double[][] fundamentalMatrix;
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;XW=\n&quot;);
            if (XW != null) {
                sb.append(FormatArray.toString(XW, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 intrinsic=\n&quot;);
            if (k1Intr != null) {
                sb.append(FormatArray.toString(k1Intr, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 extrinsic rotation=\n&quot;);
            if (k1ExtrRot != null) {
                sb.append(FormatArray.toString(k1ExtrRot, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 extrinsic translation=\n&quot;);
            if (k1ExtrTrans != null) {
                sb.append(FormatArray.toString(k1ExtrTrans, &quot;%.4e&quot;));
                sb.append(&quot;\n&quot;);
            }
            sb.append(&quot;k2 intrinsic=\n&quot;);
            if (k2Intr != null) {
                sb.append(FormatArray.toString(k2Intr, &quot;%.4e&quot;));
            }
            sb.append(&quot;k2 extrinsic rotation=\n&quot;);
            if (k2ExtrRot != null) {
                sb.append(FormatArray.toString(k2ExtrRot, &quot;%.4e&quot;));
            }
            sb.append(&quot;k2 extrinsic translation=\n&quot;);
            if (k2ExtrTrans != null) {
                sb.append(FormatArray.toString(k2ExtrTrans, &quot;%.4e&quot;));
                sb.append(&quot;\n&quot;);
            }
            return sb.toString();
        }
    }
    
      /**
     * among the 4 rotation and translation combinations from R1, R1, T1, and T2, 
     * select the one with the largest number of projected Z coordinates which are
     * positive, that is, in front of both cameras.
     * NOTE that inaccuracies in this chirality are larger for points further 
     * away from the cameras and closer to the plane at infinity.
     * NOTE that the determinants of R1 and R2 should have already been checked to be +1.
     * @param x1 image 1 portion of the correspondence pairs.
     * @param x2 image 2 portion of the correspondence pairs.
     * @param k1 intrinsic camera matrix for camera 1
     * @param k2 intrinsic camera matrix for camera 2
     * @param R1 rotation matrix whose determinant is +1
     * @param R2 rotation matrix whose determinant is +1
     * @param t1 translation vector (the direction between camera centers)
     * @param t2 translation vector (the direction between camera centers)
     * @param rSelected output variable holding the R1 or R2, whichever was the 
     * first found as a valid solution.
     * @param tSelected output variable holding the t1 or t2, whichever was the 
     * first found as a valid solution.
     * @param outputX the real world coordinates of the projection of x1 and x2 using
     * triangulation. else null if no valid solution was found
     */
    private static void bestInCheiralityTest(double[][] x1, double[][] x2, 
        double[][] k1, double[][] k2,
        double[][] R1, double[][] R2, double[] t1, double[] t2, 
        double[][] rSelected, double[] tSelected, double[][] outputX) {
    
<span class="fc" id="L3057">        int n = x1[0].length;</span>
        
<span class="pc bpc" id="L3059" title="1 of 2 branches missed.">        if (outputX.length != 4) {</span>
<span class="nc" id="L3060">            throw new IllegalArgumentException(&quot;outputX.length must be 4&quot;);</span>
        }
<span class="pc bpc" id="L3062" title="1 of 2 branches missed.">        if (outputX[0].length != n) {</span>
<span class="nc" id="L3063">            throw new IllegalArgumentException(&quot;outputX[0].length must be the same as x1[0].length&quot;);</span>
        }
        
        // for this model, for the first image, the camera extrinsics are
        //    R = I and t = [0], which leaves all rotation and translation in
        //    the 2nd camera extrinsics w.r.t. the first.
<span class="fc" id="L3069">        double[][] k1ExtrRot = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L3070">        double[] k1ExtrTrans = new double[3];</span>
        
        // save the first that pass the tests for Z&gt;=0.
<span class="fc" id="L3073">        double[][] bestR = null;</span>
<span class="fc" id="L3074">        double[] bestT = null;</span>
<span class="fc" id="L3075">        double[][] bestXW = null;</span>
<span class="fc" id="L3076">        String bestLabel = null;</span>
<span class="fc" id="L3077">        int bestNPosZ = Integer.MIN_VALUE;</span>
        
        double[][] XW;
        double[] XWPt;
<span class="fc" id="L3081">        String label = null;</span>
        
<span class="fc" id="L3083">        XWPt = new double[4];</span>
<span class="fc" id="L3084">        XW = new double[4][n];</span>
<span class="fc bfc" id="L3085" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="fc" id="L3086">            XW[i] = new double[n];</span>
        }
            
<span class="fc" id="L3089">        double[][] rTst = null;</span>
<span class="fc" id="L3090">        double[] tTst = null;</span>
<span class="fc" id="L3091">        double[][] x1Pt = new double[3][1];</span>
<span class="fc" id="L3092">        double[][] x2Pt = new double[3][1];</span>
        int i, j, ii;
<span class="fc bfc" id="L3094" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3095">            x1Pt[i] = new double[1];</span>
<span class="fc" id="L3096">            x2Pt[i] = new double[1];</span>
        }
        
        int nPosZ; 
        
<span class="fc bfc" id="L3101" title="All 2 branches covered.">        for (j = 0; j &lt; 4; ++j) {</span>
<span class="fc bfc" id="L3102" title="All 4 branches covered.">            switch(j) {</span>
                case 0: {
<span class="fc" id="L3104">                    label = &quot;R1, T1&quot;;</span>
<span class="fc" id="L3105">                    rTst = R1;</span>
<span class="fc" id="L3106">                    tTst = t1;</span>
<span class="fc" id="L3107">                    break;</span>
                }
                case 1: {
<span class="fc" id="L3110">                    label = &quot;R1, T2&quot;;</span>
<span class="fc" id="L3111">                    rTst = R1;</span>
<span class="fc" id="L3112">                    tTst = t2;</span>
<span class="fc" id="L3113">                    break;</span>
                }
                case 2: {
<span class="fc" id="L3116">                    label = &quot;R2, T1&quot;;</span>
<span class="fc" id="L3117">                    rTst = R2;</span>
<span class="fc" id="L3118">                    tTst = t1;</span>
<span class="fc" id="L3119">                    break;</span>
                }
                default: {                    
<span class="fc" id="L3122">                    label = &quot;R2, T2&quot;;</span>
<span class="fc" id="L3123">                    rTst = R2;</span>
<span class="fc" id="L3124">                    tTst = t2;</span>
                    break;
                }
            }
<span class="fc" id="L3128">            nPosZ = 0;</span>
<span class="fc bfc" id="L3129" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L3130" title="All 2 branches covered.">                for (ii = 0; ii &lt; 3; ++ii) {</span>
<span class="fc" id="L3131">                    x1Pt[ii][0] = x1[ii][i];</span>
<span class="fc" id="L3132">                    x2Pt[ii][0] = x2[ii][i];</span>
                }
                //
<span class="fc" id="L3135">                XWPt = Triangulation.calculateWCSPoint(</span>
                    k1, k1ExtrRot, k1ExtrTrans, 
                    k2, rTst, tTst, 
                    x1Pt, x2Pt);
<span class="fc bfc" id="L3139" title="All 2 branches covered.">                if (XWPt[2] &gt;= 0) {</span>
<span class="fc" id="L3140">                    nPosZ++;</span>
                }
<span class="fc bfc" id="L3142" title="All 2 branches covered.">                for (ii = 0; ii &lt; 4; ++ii) {</span>
<span class="fc" id="L3143">                    XW[ii][i] = XWPt[ii];</span>
                } 
            }
<span class="fc bfc" id="L3146" title="All 2 branches covered.">            if (nPosZ &gt; bestNPosZ) {</span>
<span class="fc" id="L3147">                bestNPosZ = nPosZ;</span>
<span class="fc" id="L3148">                bestR = rTst;</span>
<span class="fc" id="L3149">                bestT = tTst;</span>
<span class="fc" id="L3150">                bestLabel = label;</span>
<span class="fc" id="L3151">                bestXW = MatrixUtil.copy(XW);</span>
            }
        }
        
<span class="pc bpc" id="L3155" title="1 of 2 branches missed.">        if (bestR == null) {</span>
<span class="nc" id="L3156">            return;</span>
        }
        
        // copy into output variables:
<span class="fc bfc" id="L3160" title="All 2 branches covered.">        for (i = 0; i &lt; bestR.length; ++i) {</span>
<span class="fc" id="L3161">            System.arraycopy(bestR[i], 0, rSelected[i], 0, bestR[i].length);</span>
        }
<span class="fc" id="L3163">        System.arraycopy(bestT, 0, tSelected, 0, bestT.length);</span>
        
<span class="fc" id="L3165">        System.out.println(&quot;choosing solution: &quot; + bestLabel);</span>
        //double estimatedRotY = Math.atan(R[0][2]/R[0][0]) * (180./Math.PI);
<span class="fc" id="L3167">        double estimatedRotZ = Math.atan(-bestR[1][0]/bestR[1][1]) * (180./Math.PI);</span>
<span class="fc" id="L3168">        System.out.printf(&quot;estimated rotation in degrees about z axis from R=%.2f\n&quot;, estimatedRotZ);</span>
        //System.out.printf(&quot;X_WCS=\n%s\n&quot;, FormatArray.toString(bestXW, &quot;%.3e&quot;));
<span class="fc" id="L3170">        System.out.flush();</span>
        
<span class="fc bfc" id="L3172" title="All 2 branches covered.">        for (i = 0; i &lt; XW.length; ++i) {</span>
<span class="fc" id="L3173">            System.arraycopy(bestXW[i], 0, outputX[i], 0, bestXW[i].length);</span>
        }
        
<span class="fc" id="L3176">    }</span>

    static void populateWithDet1Rs(MatrixUtil.SVDProducts svdE, 
        double[][] r1Out, double[][] r2Out, double[][] uOut) {
        
        //Szeliski 2010, eqn (7.25)
        
        // R_Z+90 and R_Z_-90 from 
        // Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;, pg 121
        
        //R_z_90^T  = [ [0, 1, 0], [0, -1, 0], [0, 0, 1] ]
        //R_z_-90^T = [ [0, -1, 0], [0, 1, 0], [0, 0, 1] ]
         
        //R_z_90
<span class="fc" id="L3190">        double[][] r90T = new double[3][3];</span>
<span class="fc" id="L3191">        r90T[0] = new double[]{0, 1, 0};</span>
<span class="fc" id="L3192">        r90T[1] = new double[]{-1, 0, 0};</span>
<span class="fc" id="L3193">        r90T[2] = new double[]{0, 0, 1};</span>
<span class="fc" id="L3194">        double[][] r90NegT = MatrixUtil.transpose(r90T);</span>
        
<span class="fc" id="L3196">        double[][] u = svdE.u;</span>
<span class="fc" id="L3197">        double[][] uNeg = MatrixUtil.copy(u);</span>
<span class="fc" id="L3198">        MatrixUtil.multiply(uNeg, -1);</span>
        
<span class="fc" id="L3200">        double[][] rr1 = MatrixUtil.multiply(MatrixUtil.multiply(u, r90T), svdE.vT);</span>
<span class="fc" id="L3201">        double[][] rr2 = MatrixUtil.multiply(MatrixUtil.multiply(uNeg, r90T), svdE.vT);</span>
<span class="fc" id="L3202">        double[][] rr3 = MatrixUtil.multiply(MatrixUtil.multiply(u, r90NegT), svdE.vT);</span>
<span class="fc" id="L3203">        double[][] rr4 = MatrixUtil.multiply(MatrixUtil.multiply(uNeg, r90NegT), svdE.vT);</span>
        
<span class="fc" id="L3205">        double det1 = MatrixUtil.determinant(rr1);</span>
<span class="fc" id="L3206">        double det2 = MatrixUtil.determinant(rr2);</span>
<span class="fc" id="L3207">        double det3 = MatrixUtil.determinant(rr3);</span>
<span class="fc" id="L3208">        double det4 = MatrixUtil.determinant(rr4);</span>
        
<span class="fc" id="L3210">        System.out.printf(&quot;det(r1,r2,r3,r4)=%.3e,%.3e,%.3e,%.3e\n&quot;, det1, det2, det3, det4);</span>
<span class="fc" id="L3211">        System.out.printf(&quot;r1:\n%s\n&quot;, FormatArray.toString(rr1, &quot;%.4e&quot;));</span>
<span class="fc" id="L3212">        System.out.printf(&quot;r2:\n%s\n&quot;, FormatArray.toString(rr2, &quot;%.4e&quot;));</span>
<span class="fc" id="L3213">        System.out.printf(&quot;r3:\n%s\n&quot;, FormatArray.toString(rr3, &quot;%.4e&quot;));</span>
<span class="fc" id="L3214">        System.out.printf(&quot;r4:\n%s\n&quot;, FormatArray.toString(rr4, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L3216">        boolean useUPos = true;</span>
        
        int i;
<span class="fc bfc" id="L3219" title="All 2 branches covered.">        if (Math.abs(det1 - 1.) &lt; eps) {</span>
<span class="fc" id="L3220">            System.out.printf(&quot;using +U\n&quot;);</span>
<span class="fc bfc" id="L3221" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3222">                System.arraycopy(rr1[i], 0, r1Out[i], 0, rr1[i].length);</span>
            }
<span class="pc bpc" id="L3224" title="1 of 2 branches missed.">        } else if (Math.abs(det2 - 1.) &lt; eps) {</span>
<span class="fc" id="L3225">            System.out.printf(&quot;using -U\n&quot;);</span>
<span class="fc" id="L3226">            useUPos = false;</span>
<span class="fc bfc" id="L3227" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3228">                System.arraycopy(rr2[i], 0, r1Out[i], 0, rr2[i].length);</span>
            }
        } else {
<span class="nc" id="L3231">            throw new IllegalStateException(&quot;neither rotation matrix is SO(3)&quot;);</span>
        }
<span class="fc bfc" id="L3233" title="All 2 branches covered.">        if (Math.abs(det3 - 1.) &lt; eps) {</span>
<span class="pc bpc" id="L3234" title="1 of 2 branches missed.">            if (!useUPos) {</span>
<span class="nc" id="L3235">                throw new IllegalStateException(&quot;expecting to need +U&quot;);</span>
            }
<span class="fc" id="L3237">            System.out.printf(&quot;using +U\n&quot;);</span>
<span class="fc bfc" id="L3238" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3239">                System.arraycopy(rr3[i], 0, r2Out[i], 0, rr3[i].length);</span>
            }
<span class="pc bpc" id="L3241" title="1 of 2 branches missed.">        } else if (Math.abs(det4 - 1.) &lt; eps) {</span>
<span class="pc bpc" id="L3242" title="1 of 2 branches missed.">            if (useUPos) {</span>
<span class="nc" id="L3243">                throw new IllegalStateException(&quot;expecting to need -U&quot;);</span>
            }
<span class="fc" id="L3245">            System.out.printf(&quot;using -U\n&quot;);</span>
<span class="fc bfc" id="L3246" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3247">                System.arraycopy(rr4[i], 0, r2Out[i], 0, rr4[i].length);</span>
            }
        } else {
<span class="nc" id="L3250">            throw new IllegalStateException(&quot;neither rotation matrix is SO(3)&quot;);</span>
        }
        
<span class="fc bfc" id="L3253" title="All 2 branches covered.">        if (useUPos) {</span>
<span class="fc bfc" id="L3254" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3255">                System.arraycopy(u[i], 0, uOut[i], 0, u[i].length);</span>
            }
        } else {
<span class="fc bfc" id="L3258" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3259">                System.arraycopy(uNeg[i], 0, uOut[i], 0, uNeg[i].length);</span>
            }
        }
<span class="fc" id="L3262">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
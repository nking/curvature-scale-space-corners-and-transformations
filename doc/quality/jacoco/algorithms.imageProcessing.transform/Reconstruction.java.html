<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reconstruction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Reconstruction.java</span></div><h1>Reconstruction.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.dimensionReduction.CURDecomposition;
import algorithms.dimensionReduction.CURDecomposition.CUR;
import algorithms.imageProcessing.features.RANSACSolver;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.imageProcessing.transform.Camera.CameraParameters;
import static algorithms.imageProcessing.transform.CameraPose.eps;
import algorithms.matrix.LinearEquations;
import algorithms.matrix.MatrixUtil;
import algorithms.matrix.MatrixUtil.SVDProducts;
import algorithms.util.FormatArray;
import java.util.Arrays;
import java.util.List;

import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.EVD;
import no.uib.cipr.matrix.NotConvergedException;
import no.uib.cipr.matrix.SVD;

/**
 *  This class has/will have methods for Structure from Motion and 3-D point reconstruction.
 * given correspondence between two images calculate the camera
 * parameters as intrinsic and extrinsic parameters,
 * and the real world position.
 *
 * TODO: implement affine reconstruction for the case of pure translation,
 *     see Example 6.6 of Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;&quot;.
 *     For the case of pure rotation, see Example 6.10.
 *
 * Euler rotations:
        
        about z-axis (yaw):           about x-axis (roll):       about the y-axis (pitch):
            | cos φ   -sin φ    0 |    |    1       0       0 |  |  cos ψ    0  sin ψ |
            | sin φ    cos φ    0 |    |    0   cos θ   sin θ |  |      0    1      0 |
            |     0        0    1 |    |    0  -sin θ   cos θ |  | -sin ψ    0  cos ψ |        
        
 * useful reading:
  http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
  Fig 1.8 of &quot;Computing Intrinsic Images&quot; by Aloimonos 1986 for a snapshot in time of c.v. algorithms

   Motion - the rotation and translation of an object in front of a camera.
            sometimes represented as the 3X4 projection matria P = |R | t|
   Shape - the local surface orientation where surface orientation is 
           usually the surface normal vector.
           sometimes represented by X, the 3-D coordinates w.r.t. a world reference system.
           From &quot;Computing Intrinsic Images&quot; by Aloimonos 1986
             perspective projection is pinhole camera.
             Under orthographic projection, the image coordinates of a point 
             are equal to the corresponding 3-D coordinates, i.e. (x.y ) =(X,Y)
             and we do not know its depth.
   Depth - the Z-coordinate of a 3-D object in the world coordinate system.

   test datasets:
      https://www.cs.cmu.edu/afs/cs/project/vision/vasc/idb/www/html_permanent/index.html
      http://www.cs.cmu.edu/afs/cs/project/cil/www/v-images.html
       
      
 TODO: implement more of Chap 11 of MASKS (Ma, Soatto, Kosecká, and Sastry 2012, 
 * &quot;An Invitation to 3-D Vision&quot;)
 * 
 &lt;/pre&gt;

 * @author nichole
 */
<span class="pc" id="L66">public class Reconstruction {</span>
    
    /*
    // notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
    
    // homogeneous repr of a point is x_vec = (x, y, 1)^T
    // equation f a line is ell = a*x + b*y + c = 0;
    
    // line rewritten in homogeneous coordinates is x_vec^T * ell.
    
    // general conic in 3 dimensions is a*x^2 + b*x*y + c*y^2 + d*x*z + e*y*z + f*z^2 = 0.
    //     rewritten using 2D homogeneous coords, quadratic form: x_vec^T * C * x_vec = 0
    //                  [a   b/2   d/2 ]
    //        where C = [b/2   c   c/2 ]
    //                  [d/2 c/2     f ]
    //        C has 6 variable, 5 DOF, so need 5 points
    //     can then reformat x_vec^T * C * x_vec = 0 into
    //        the &quot;design matrix&quot; * &quot;the carrier vector&quot; = 0
    //               A * c = 0
    //        c = SVD(A).V^T[n-1], the eigenvector assoc w/ smallest eigenvalue.
    
    Parallel lines intersect in points at infinity (also known as ideal points)
    and these points have the form (x, y, 0)^⊤
    the set of ideal points (i.e., points at infinity) is the set of points 
    where parallel lines intersect.
    
    The intersection of two lines is given by their vector cross product.
    
    The line passing through any two points is given by their cross product.
    
    The line at infinity is (0,0,1)^⊤ which can be seen by taking the cross
        product of 2 points at infinity.  e.g. (x1,y1,0)^⊤ cross (x2,y2,0)^⊤ = (0,0,1)^⊤
     
        The two circular points are defined as
           I = (1, i, 0)^⊤
           J = (1, −i, 0)^T
        The circular points lie on l∞, along with all other ideal points. All 
        circles intersect l∞ at points I and J.
    
        Recall the duality between points and lines:
           x2 = H*x1,  l2 = (H^−⊤)*l1
    
        The dual of a conic C is the set of lines satisfying:
           l^⊤ * C∗ * l = 0
           where C∗ is the adjoint in this case, so C∗ ∼ C^−1  
        Dual conics transform under homography H as:
           C∗′ = H * C∗ * H^⊤
    
        The “conic dual to the circular points” is defined as
           C ∞∗ = I*J^⊤ + J*I^⊤
                ~ [ 1  0  0 ]
                  [ 0  1  0 ]
                  [ 0  0  0 ]
    
    Stratified Reconstruction (cahpters 8 and 6):
    
    Notes on stratified reconstruction in the 2D case (lec 6):
        Each stratum represents a different level of reconstruction we may wish 
        to obtain, namely projective, affine and Euclidean. 
        A general 2D homography can be decomposed into three components:
           H = H_p * H_a * H_e 
        which are the projective, affine and euclidean components.
              
          H = [  I   0 ] * [ K    0 ] * [ R   T ]
              [ v^T  1 ]   [ 0^T  1 ]   [ 0^T 1 ]
                 H_p           H_a         H_e
    
          H_e is a 2D rigid transformation
          H_a is an affine trnsformation
          H_p is a projective transformation known as an “elation.”
               v^T affets the line at infinity, l∞ = (0, 0, 1)^⊤.
               ** Only H_p can map l∞ to a finite line in the image plane, or vice versa.
               suppose the image of l∞ is some line l = (a, b, c)^⊤, then the
               following matrix H will send l back to infinity:
                                [ 1  0  0 ]
                      H = H_a * [ 0  1  0 ]
                                [ a  b  c ]
                          where where H_a is any affine transformation
          
       The key to the affine upgrade is the behavior of the line at infinity. 
       The counterpart to this for the Euclidean upgrade is the behavior of the 
       “circular points.”
    
       Chap 6, Section 3 has more about euclidean upgrades in transformation
          for circular points and conics.
    
    Notes from Lec 8:
        Levels of reconstruction of a scene: projective, affine and euclidean components.
    
        If the camera intrinisc parameters, K, are not known, then only the
        projective reconstruction is possible, but this can be upgraded to 
        affine (parallelism preserved) and Euclidean (parallelism and orthogonality preserved) reconstructions.
    
        Given a set of point correspondences between two views {(x′1,x′2)} 
        we can get the Projective Structure X_p.
        where x' = x * K, that is, x = x' * K^-1.  x' are the image coordinates as pixels.
           first calculate F from the point correspondences, then use F to
           get the projection matrix for camera 2, P2, then triangulate to get
           X_p (which is the 3D point in projective space).
           caveat is that K, R, T from in P2 will not be unique.
           The canonical choice for these two projection matrices is:
               P1 = [ I | 0 ]
               P2 = [ ([T']_x)^T  F  | T' ]
           where T' = K*T and ||T'|| = 1
           and recall that T′ ∼ e2
    
           The triangulation uses DLT and SVD.
    
           for the case where there is no noise:
                X_P is SVD(M).V^T[last row]
           for the case where there is noise, the SVD solution is the initial
                values for a non-linear optimization method.
    
    NOTE: to solve affine reconstruction for the case of pure translation, 
    see Example 6.6 of Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;&quot;.
    For the case of pure rotation, see Example 6.10.
    
    */
    
     /**
      *
     * given 2 sets of correspondence from 2 different images taken from
     * 2 cameras whose intrinsic and extrinsic parameters are known,
     * determine the world scene coordinates of the correspondence points.
     * This method simply uses triangulation on each correspondence pair.
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     * http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     * 
     * &lt;/pre&gt;
     * @param camera1 image 1 camera matrices of intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     * @param camera2 image 2 camera matrices of intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     * @param x1 the image 1 set of correspondence points in image coordinates.  format is 3 x N where
     * N is the number of points.
     * @param x2 the image 2 set of correspondence points in image coordinates.  format is 3 x N where
     * N is the number of points.
     * @return the world scene coordinates and the intrinsic and extrinsic
     * camera matrices (the later were given to the code, but are convenient to return in results).
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static ReconstructionResults calculateReconstruction(
            CameraParameters camera1, CameraParameters camera2,
            double[][] x1, double[][] x2) throws NotConvergedException {

<span class="nc bnc" id="L212" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L213">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="nc" id="L215">        int n = x1[0].length;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L217">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
        
        /*
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (3) For each point correspondence, compute the point X in 3D space (triangulation)
        */
                        
<span class="nc" id="L226">        double[][] XW = new double[4][n];</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="nc" id="L228">            XW[i] = new double[n];</span>
        }
        double[] XWPt;
        
<span class="nc" id="L232">        double[][] x1Pt = new double[3][1];</span>
<span class="nc" id="L233">        double[][] x2Pt = new double[3][1];</span>
        int i, ii;
<span class="nc bnc" id="L235" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L236">            x1Pt[i] = new double[1];</span>
<span class="nc" id="L237">            x2Pt[i] = new double[1];</span>
        }
                    
<span class="nc bnc" id="L240" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            for (ii = 0; ii &lt; 3; ++ii) {</span>
<span class="nc" id="L242">                x1Pt[ii][0] = x1[ii][i];</span>
<span class="nc" id="L243">                x2Pt[ii][0] = x2[ii][i];</span>
            }
            //length is 4

            // x1, x2 must be in image reference frame
<span class="nc" id="L248">            Triangulation.WCSPt wcsPt = Triangulation.calculateWCSPoint(camera1, camera2, x1Pt, x2Pt);</span>
<span class="nc" id="L249">            XWPt = wcsPt.X;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            for (ii = 0; ii &lt; 4; ++ii) {</span>
<span class="nc" id="L251">                XW[ii][i] = XWPt[ii];</span>
            } 
        }
                
<span class="nc" id="L255">        ReconstructionResults rr = new ReconstructionResults();</span>
<span class="nc" id="L256">        rr.XW = XW;</span>

<span class="nc" id="L258">        return rr;</span>
    }

    /**
     * adapted from MASKS exp_matrix.m, but see also methods in this project in Rotation.java
     * @param rotation 3X3 rotation matrix
     * @param outAxis array of length 3 to populate with extracted axis
     * @return
     */
    private static double extractAxisAndAngle(double[][] rotation, double[] outAxis) {
<span class="nc" id="L268">        double theta = Math.acos((rotation[0][0] + rotation[1][1] + rotation[2][2])/2.);</span>
        double[] omega;
        //matlab: A ~= B returns a logical array with elements set to logical 1 (true) where arrays A and B are not equal;
        // otherwise, the element is logical 0 (false)
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (Math.abs(theta) &gt; 1E-6) {</span>
<span class="nc" id="L273">            omega = new double[]{rotation[2][1] - rotation[1][2],</span>
                    rotation[0][2] - rotation[2][0],
                    rotation[1][0] - rotation[0][1],
            };
<span class="nc" id="L277">            MatrixUtil.multiply(omega, 1./(2.*Math.sin(theta)));</span>
        } else {
            // rotation matrix is arbitrary
<span class="nc" id="L280">            omega = new double[]{1, 0, 0};</span>
<span class="nc" id="L281">            theta = 0;</span>
        }
<span class="nc" id="L283">        System.arraycopy(omega, 0, outAxis, 0, omega.length);</span>
<span class="nc" id="L284">        return theta;</span>
    }
    /**
     * calculate the triple product as a x (b X c).
     * adapted from MASKS example code triple_product.m.
     * see also similar methods in this project in Rotation.java.
     * @param a array of length 3
     * @param b array of length 3
     * @param c array of length 3
     * @return triple product of a, b, c.
     */
    private static double tripleProduct(double[] a, double[] b, double[] c) {
        // from Boas &quot;Mathematical Methods in the Physical Sciences&quot;, eqn 3.8
        // a X (b X c) = (a dot c)*B - (a dot b) * c
<span class="nc" id="L298">        return c[0]*(a[1]*b[2] - b[1]*a[2])</span>
                + c[1]*(a[2]*b[0] - b[2]*a[0])
                + c[2]*(a[0]*b[1] - b[0]*a[1]);
    }

    /**
     * adapted from MASKS example code rot_matrix.m.
     * see also similar methods in this project in Rotation.java.
     * @param omega
     * @param theta
     * @return
     */
    private static double[][] createRodriguesRotationMatrix(double[] omega, double theta) {

<span class="nc" id="L312">        double[][] omegaSkew = MatrixUtil.skewSymmetric(omega);</span>
<span class="nc" id="L313">        double normOmega = 0;</span>
        try {
<span class="nc" id="L315">            normOmega = MatrixUtil.spectralNorm(omegaSkew);</span>
<span class="nc" id="L316">        } catch (NotConvergedException e) {</span>
            // should not fail as is using SVD(a^T*A)
<span class="nc" id="L318">            e.printStackTrace();</span>
<span class="nc" id="L319">        }</span>
<span class="nc" id="L320">        MatrixUtil.multiply(omegaSkew, 1./normOmega);</span>

<span class="nc" id="L322">        double[][] r = MatrixUtil.createIdentityMatrix(3);</span>

        //matlab: A ~= B returns a logical array with elements set to logical 1 (true) where arrays A and B are not equal;
        // otherwise, the element is logical 0 (false)
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (Math.abs(normOmega) &gt; 1E-6) {</span>
<span class="nc" id="L327">            double[][] r2 = MatrixUtil.copy(omegaSkew);</span>
<span class="nc" id="L328">            MatrixUtil.multiply(r2, Math.sin(normOmega * theta));</span>
<span class="nc" id="L329">            double[][] r3 = MatrixUtil.multiply(omegaSkew, omegaSkew);</span>
<span class="nc" id="L330">            MatrixUtil.multiply(r3, 1. - Math.cos(normOmega * theta));</span>
<span class="nc" id="L331">            r = MatrixUtil.pointwiseAdd(r, r2);</span>
<span class="nc" id="L332">            r = MatrixUtil.pointwiseAdd(r, r3);</span>
        } // else normOmega = 0 and r = I

<span class="nc" id="L335">        return r;</span>
    }

    /**
     * estimate the extrinsic camera matrix P2 (notion) assuming P1 is[I|0]
     * using epipolar geometry given correspondence points between 2 images (structure).
     * The essential matrix contains information about the relative position
     * T and orientation R between 2 cameras (the camera pose).
     * The best of 4 solutions constructed from the essential matrix is returned
     * where the best is defined using the volume of each point's epipolar plane
     * with respect to the signs of the scales (scale in x = scale * P * X).

     * The projective calibration can be upgraded to
     affine (parallelism preserved) and Euclidean (parallelism and orthogonality preserved) 
     reconstructions.
     To upgrade to an affine projection, need 3 vanishing points
     (see Section 9.2.2 of Belongie lec 9).
     To directly upgrade from projective to euclidean projection, need
     5 ground truth points in general position, that is, no 4 points
     are coplanar (see Section 9.3 of Belongie lec 9).
     * NOTE: this solution is fine for cases with no noise, otherwise, the
     * results should be the initial values for a non-linear optimization method.

     * &lt;pre&gt;
     * MASKS chap. 5 and their code essentialDiscrete.m
     * &lt;/pre&gt;
     * @param x1 the camera 1 set of image correspondence points in the reference frame of the camera.
     * format is 3 x N where N is the number of points.
     * NOTE: one can guess at the camera intrinsic matrix if needed, in order to calibrate the camera.
     * MASKS gives advice in Algorithm 11.6 step 1.
     * @param x2 the camera 2 set of image correspondence points in the reference frame of the camera.
     * format is 3 x N where N is the number of points.
     * NOTE: one can guess at the camera intrinsic matrix if needed, in order to calibrate the camera.
     * MASKS gives advice in Algorithm 11.6 step 1.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points.
     */
    public static Camera.CameraExtrinsicParameters calculateProjectiveMotion(
        double[][] x1, double[][] x2) throws NotConvergedException {

<span class="nc bnc" id="L374" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L375">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="nc" id="L377">        int n0 = x1[0].length;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (x2[0].length != n0) {</span>
<span class="nc" id="L379">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (n0 &lt; 7) {</span>
<span class="nc" id="L382">            throw new IllegalArgumentException(&quot;need at least 7 points for the uncalirated camera (s) 2 view solution&quot;);</span>
        }
        
        /*
        the MASKS approach below is similar to this lecture and the lecture on camera pose.
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (1) compute essential matrix EM from the correspondence x1, x2
        (2) compute the extrinsic camera matrices P1, P2 from FM.
        (3) For each point correspondence, compute the point X in 3D space (triangulation)
        
        see also notes above from notes from Serge Belongie/Kris Katani lectures from Computer Vision II, CSE 252B, USSD
        */

<span class="nc" id="L396">        DenseMatrix x1M = new DenseMatrix(x1);</span>
<span class="nc" id="L397">        DenseMatrix x2M = new DenseMatrix(x2);</span>

<span class="nc" id="L399">        int n = x1[0].length;</span>
<span class="nc" id="L400">        double tol = 1E-7;</span>

        /*
        from MASKS chap 5:
        the epipolar constraint allows us to recover the essential matrix only up to a scalar factor
        (since the epipolar constraint (5.2) is homogeneous in E, it is not modified by multiplying
        it by any nonzero constant). A typical choice to fix this ambiguity is to assume a unit translation,
        that is, |T| = |E|| = 1. We call the resulting essential matrix normalized.
        see essentialDiscrete.m from MASKS example code:
        [U,S,V] = svd(A);
        % pick the eigenvector corresponding to the smallest eigenvalue
        e = V(:,9);
        % normalization here:
        e = (round(1.0e+10*e))*(1.0e-10);
        % essential matrix
        E = reshape(e, 3, 3);
         */
<span class="nc" id="L417">        double[][] a = EpipolarTransformer.createKroneckerDesignMatrix(x1M, x2M);</span>
<span class="nc" id="L418">        SVD svd = SVD.factorize(new DenseMatrix(a));</span>
<span class="nc" id="L419">        double[][] vT = MatrixUtil.convertToRowMajor(svd.getVt());</span>
<span class="nc" id="L420">        double[] e1 = Arrays.copyOf(vT[vT.length - 1], vT[0].length);</span>

        int i;
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (i = 0; i &lt; e1.length; ++i) {</span>
<span class="nc" id="L424">            e1[i] = (Math.round(1.0e+10*e1[i]))*(1.0e-10);</span>
        }
        // essential matrix
<span class="nc" id="L427">        double[][] em = new double[3][3];</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        for (i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L429">            em[i] = new double[3];</span>
<span class="nc" id="L430">            em[i][0] = e1[(i * 3) + 0];</span>
<span class="nc" id="L431">            em[i][1] = e1[(i * 3) + 1];</span>
<span class="nc" id="L432">            em[i][2] = e1[(i * 3) + 2];</span>
        }

<span class="nc" id="L435">        System.out.printf(&quot;EM=\n%s\n&quot;, FormatArray.toString(em, &quot;%.4e&quot;));</span>

        //(2) compute the camera matrices P1, P2 from FM.
<span class="nc" id="L438">        svd = SVD.factorize(new DenseMatrix(em));</span>
<span class="nc" id="L439">        double detU = MatrixUtil.determinant(svd.getU());</span>
<span class="nc" id="L440">        double detV = MatrixUtil.determinant(svd.getVt());</span>
        
        //System.out.printf(&quot;SVD.u=\n%s\n&quot;, svd.getU().toString());
        //System.out.printf(&quot;SVD.s=\n%s\n&quot;, FormatArray.toString(svd.getS(), &quot;%.3e&quot;));
        //System.out.printf(&quot;SVD.vT=\n%s\n&quot;, svd.getVt().toString());
        //System.out.printf(&quot;det(SVD.u)=%.2f\n&quot;, detU);
        //System.out.printf(&quot;det(SVD.vT)=%.2f\n&quot;, detV);

        //H = +U * R_Z(+-90)^T * sigma_hat * V^T

        // rotation by -pi/2 around z-axis
<span class="nc" id="L451">        double[][] rZN = new double[3][3];</span>
<span class="nc" id="L452">        rZN[0] = new double[]{0, 1, 0};</span>
<span class="nc" id="L453">        rZN[1] = new double[]{-1, 0, 0};</span>
<span class="nc" id="L454">        rZN[2] = new double[]{0, 0, 1};</span>
        // rotation by p1/2 around z axis
<span class="nc" id="L456">        double[][] rZP = MatrixUtil.transpose(rZN);</span>

        //MASKS essentialDiscrete.m replaces svd.s with [1, 1, 0] here
<span class="nc" id="L459">        double[] s = Arrays.copyOf(svd.getS(), svd.getS().length);</span>
<span class="nc" id="L460">        s = new double[]{1, 1, 0};</span>

<span class="nc" id="L462">        vT = MatrixUtil.convertToRowMajor(svd.getVt());</span>
<span class="nc" id="L463">        double[][] v = MatrixUtil.transpose(vT);</span>
<span class="nc" id="L464">        double[][] u = MatrixUtil.convertToRowMajor(svd.getU());</span>
<span class="nc" id="L465">        detU = MatrixUtil.determinant(u);</span>
<span class="nc" id="L466">        detV = MatrixUtil.determinant(v);</span>
<span class="nc bnc" id="L467" title="All 4 branches missed.">        if (detU &lt; 0 &amp;&amp; detV &lt; 0) {</span>
<span class="nc" id="L468">            MatrixUtil.multiply(u, -1);</span>
<span class="nc" id="L469">            MatrixUtil.multiply(vT, -1);</span>
<span class="nc bnc" id="L470" title="All 4 branches missed.">        } else if (detU &lt; 0 &amp;&amp; detV &gt; 0) {</span>
            //S1 = Rzp * S;
<span class="nc" id="L472">            double[][] s1 = MatrixUtil.multiplyByDiagonal(rZP, s);</span>
<span class="nc" id="L473">            double[][] c = createRodriguesRotationMatrix(new double[]{s1[2][1], s1[0][2], s1[1][0]}, Math.PI);</span>
<span class="nc" id="L474">            MatrixUtil.multiply(u, -1);</span>
<span class="nc" id="L475">            u = MatrixUtil.multiply(u, c);</span>
<span class="nc" id="L476">            u = MatrixUtil.multiply(u, rZP);</span>
<span class="nc" id="L477">            v  = MatrixUtil.multiply(v, rZP);</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">        } else if (detU &gt; 0 &amp;&amp; detV &lt; 0) {</span>
<span class="nc" id="L479">            double[][] s1 = MatrixUtil.multiplyByDiagonal(rZP, s);</span>
<span class="nc" id="L480">            double[][] c = createRodriguesRotationMatrix(new double[]{s1[2][1], s1[0][2], s1[1][0]}, Math.PI);</span>
<span class="nc" id="L481">            u = MatrixUtil.multiply(u, c);</span>
<span class="nc" id="L482">            u = MatrixUtil.multiply(u, rZP);</span>
<span class="nc" id="L483">            v  = MatrixUtil.multiply(v, rZP);</span>
<span class="nc" id="L484">            MatrixUtil.multiply(v, -1);</span>
        }

<span class="nc" id="L487">        double[][] r0 = MatrixUtil.multiply(u, MatrixUtil.transpose(rZP));</span>
<span class="nc" id="L488">        r0 = MatrixUtil.multiply(r0, MatrixUtil.transpose(v));</span>

<span class="nc" id="L490">        double[][] tH0 = MatrixUtil.multiplyByDiagonal(MatrixUtil.multiply(u, rZP), s);</span>
<span class="nc" id="L491">        tH0 = MatrixUtil.multiply(tH0, MatrixUtil.transpose(u));</span>

<span class="nc" id="L493">        double[] t0 = new double[]{-tH0[1][2], tH0[0][2], -tH0[0][1]};</span>

        // axis of rotation:
<span class="nc" id="L496">        double[] omega0 = new double[3];</span>
<span class="nc" id="L497">        double theta0 = extractAxisAndAngle(r0, omega0);</span>

        //----
<span class="nc" id="L500">        double[][] r1 = MatrixUtil.multiply(u, MatrixUtil.transpose(rZN));</span>
<span class="nc" id="L501">        r1 = MatrixUtil.multiply(r1, MatrixUtil.transpose(v));</span>

<span class="nc" id="L503">        double[][] tH1 = MatrixUtil.multiplyByDiagonal(MatrixUtil.multiply(u, rZN), s);</span>
<span class="nc" id="L504">        tH1 = MatrixUtil.multiply(tH1, MatrixUtil.transpose(u));</span>

<span class="nc" id="L506">        double[] t1 = new double[]{-tH1[1][2], tH1[0][2], -tH1[0][1]};</span>

        // axis of rotation:
<span class="nc" id="L509">        double[] omega1 = new double[3];</span>
<span class="nc" id="L510">        double theta1 = extractAxisAndAngle(r1, omega1);</span>

<span class="nc" id="L512">        double[][] minusEM = MatrixUtil.copy(em);</span>
<span class="nc" id="L513">        MatrixUtil.multiply(minusEM, -1);</span>

<span class="nc" id="L515">        svd = SVD.factorize(new DenseMatrix(minusEM));</span>
<span class="nc" id="L516">        s = new double[]{1, 1, 0};</span>
<span class="nc" id="L517">        vT = MatrixUtil.convertToRowMajor(svd.getVt());</span>
<span class="nc" id="L518">        v = MatrixUtil.transpose(vT);</span>
<span class="nc" id="L519">        u = MatrixUtil.convertToRowMajor(svd.getU());</span>
<span class="nc" id="L520">        detU = MatrixUtil.determinant(u);</span>
<span class="nc" id="L521">        detV = MatrixUtil.determinant(v);</span>
<span class="nc bnc" id="L522" title="All 4 branches missed.">        if (detU &lt; 0 &amp;&amp; detV &lt; 0) {</span>
<span class="nc" id="L523">            MatrixUtil.multiply(u, -1);</span>
<span class="nc" id="L524">            MatrixUtil.multiply(vT, -1);</span>
<span class="nc bnc" id="L525" title="All 4 branches missed.">        } else if (detU &lt; 0 &amp;&amp; detV &gt; 0) {</span>
            //S1 = Rzp * S;
<span class="nc" id="L527">            double[][] s1 = MatrixUtil.multiplyByDiagonal(rZP, s);</span>
<span class="nc" id="L528">            double[][] c = createRodriguesRotationMatrix(new double[]{s1[2][1], s1[0][2], s1[1][0]}, Math.PI);</span>
<span class="nc" id="L529">            MatrixUtil.multiply(u, -1);</span>
<span class="nc" id="L530">            u = MatrixUtil.multiply(u, c);</span>
<span class="nc" id="L531">            u = MatrixUtil.multiply(u, rZP);</span>
<span class="nc" id="L532">            v  = MatrixUtil.multiply(v, rZP);</span>
<span class="nc bnc" id="L533" title="All 4 branches missed.">        } else if (detU &gt; 0 &amp;&amp; detV &lt; 0) {</span>
<span class="nc" id="L534">            double[][] s1 = MatrixUtil.multiplyByDiagonal(rZP, s);</span>
<span class="nc" id="L535">            double[][] c = createRodriguesRotationMatrix(new double[]{s1[2][1], s1[0][2], s1[1][0]}, Math.PI);</span>
<span class="nc" id="L536">            u = MatrixUtil.multiply(u, c);</span>
<span class="nc" id="L537">            u = MatrixUtil.multiply(u, rZP);</span>
<span class="nc" id="L538">            v  = MatrixUtil.multiply(v, rZP);</span>
<span class="nc" id="L539">            MatrixUtil.multiply(v, -1);</span>
        }

<span class="nc" id="L542">        double[][] r2 = MatrixUtil.multiply(u, MatrixUtil.transpose(rZP));</span>
<span class="nc" id="L543">        r2 = MatrixUtil.multiply(r2, MatrixUtil.transpose(v));</span>

<span class="nc" id="L545">        double[][] tH2 = MatrixUtil.multiplyByDiagonal(MatrixUtil.multiply(u, rZP), s);</span>
<span class="nc" id="L546">        tH2 = MatrixUtil.multiply(tH2, MatrixUtil.transpose(u));</span>

<span class="nc" id="L548">        double[] t2 = new double[]{-tH2[1][2], tH2[0][2], -tH2[0][1]};</span>

        // axis of rotation:
<span class="nc" id="L551">        double[] omega2 = new double[3];</span>
<span class="nc" id="L552">        double theta2 = extractAxisAndAngle(r2, omega2);</span>

        //-----
<span class="nc" id="L555">        double[][] r3 = MatrixUtil.multiply(u, MatrixUtil.transpose(rZN));</span>
<span class="nc" id="L556">        r3 = MatrixUtil.multiply(r3, MatrixUtil.transpose(v));</span>

<span class="nc" id="L558">        double[][] tH3 = MatrixUtil.multiplyByDiagonal(MatrixUtil.multiply(u, rZN), s);</span>
<span class="nc" id="L559">        tH3 = MatrixUtil.multiply(tH3, MatrixUtil.transpose(u));</span>

<span class="nc" id="L561">        double[] t3 = new double[]{-tH3[1][2], tH3[0][2], -tH3[0][1]};</span>

        // axis of rotation:
<span class="nc" id="L564">        double[] omega3 = new double[3];</span>
<span class="nc" id="L565">        double theta3 = extractAxisAndAngle(r3, omega3);</span>

        //-----
        /* pick the correct solution based on positive depth constraint
         there are two ways (below 2. is used):
            1. Compute both scales and pick the solution where the majority is
            positive in both frames
            2. Compute volume, which has to be positive if the two scales have
            the same sign and then check whether one of the scale is positive
            (similar solution suggested by Kanatani, 1993 book).
        */
        double[][] _r;
        double[][] _tH;
        double[] _t;

        // transpose x1 and x2 so can replace extraction of columns 4 times with a one time cost of building rows
<span class="nc" id="L581">        double[][] x1T = MatrixUtil.transpose(x1);</span>
<span class="nc" id="L582">        double[][] x2T = MatrixUtil.transpose(x2);</span>

        // temporary variables
        double[] rX1;
        double[] tHX2;
        double volume;
        double[][] skewX2;
        double[] tmp1;
        double[] tmp2;
        double norm;
        double alpha1;
        double[][] skewRX1;
        double alpha2;
        int volSumSign;
        int depth1SumSign;
        int depth2SumSign;

        // compute the volume as the triple product of (o1, o2, wcsPt) for each epipolar plane
        // where o1 and o2 are camera1 and camera2 optical centers, respectively.
        // equivalently the volume is determined for
        // (T, R*x1, R*K^-1*x2)

        int j;
<span class="nc" id="L605">        int index = -1;</span>
<span class="nc" id="L606">        int[] posdepth = new int[4];</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        for (i = 0; i &lt; 4; ++i) {</span>
<span class="nc bnc" id="L608" title="All 4 branches missed.">            switch(i) {</span>
                case 0:
<span class="nc" id="L610">                    _r = r0;</span>
<span class="nc" id="L611">                    _tH = tH0;</span>
<span class="nc" id="L612">                    _t = t0;</span>
<span class="nc" id="L613">                    break;</span>
                case 1:
<span class="nc" id="L615">                    _r = r1;</span>
<span class="nc" id="L616">                    _tH = tH1;</span>
<span class="nc" id="L617">                    _t = t1;</span>
<span class="nc" id="L618">                    break;</span>
                case 2:
<span class="nc" id="L620">                    _r = r2;</span>
<span class="nc" id="L621">                    _tH = tH2;</span>
<span class="nc" id="L622">                    _t = t2;</span>
<span class="nc" id="L623">                    break;</span>
                default:
<span class="nc" id="L625">                    _r = r3;</span>
<span class="nc" id="L626">                    _tH = tH3;</span>
<span class="nc" id="L627">                    _t = t3;</span>
                    break;
            }
<span class="nc" id="L630">            volSumSign = 0;</span>
<span class="nc" id="L631">            depth1SumSign = 0;</span>
<span class="nc" id="L632">            depth2SumSign = 0;</span>
            //Compute volume, which has to be positive if the two scales have
            //the same sign and then check whether one of the scale is positive
<span class="nc bnc" id="L635" title="All 2 branches missed.">            for (j = 0; j &lt; n; ++j) {</span>
                //if the depths have the same sign the triple product has to be greater then 0
<span class="nc" id="L637">                rX1 = MatrixUtil.multiplyMatrixByColumnVector(_r, x1T[j]);</span>
<span class="nc" id="L638">                tHX2 = MatrixUtil.multiplyMatrixByColumnVector(_tH, x2T[j]);</span>
<span class="nc" id="L639">                skewX2 = MatrixUtil.skewSymmetric(x2T[j]);</span>
<span class="nc" id="L640">                skewRX1 = MatrixUtil.skewSymmetric(rX1);</span>

<span class="nc" id="L642">                volume = tripleProduct(_t, rX1, tHX2);</span>

<span class="nc" id="L644">                tmp1 = MatrixUtil.multiplyMatrixByColumnVector(skewX2, _t);</span>
<span class="nc" id="L645">                tmp2 = MatrixUtil.multiplyMatrixByColumnVector(</span>
<span class="nc" id="L646">                        MatrixUtil.multiply(skewX2, _r), x1T[j]);</span>
<span class="nc" id="L647">                norm = MatrixUtil.lPSum(</span>
<span class="nc" id="L648">                        MatrixUtil.multiplyMatrixByColumnVector(skewX2, _t), 2);</span>
<span class="nc" id="L649">                alpha1 = MatrixUtil.innerProduct(tmp1,tmp2)/norm;</span>

<span class="nc" id="L651">                tmp1 = MatrixUtil.multiplyMatrixByColumnVector(skewRX1, x2T[j]);</span>
<span class="nc" id="L652">                tmp2 = MatrixUtil.multiplyMatrixByColumnVector(skewRX1, _t);</span>
<span class="nc" id="L653">                norm = MatrixUtil.lPSum(</span>
<span class="nc" id="L654">                        MatrixUtil.multiplyMatrixByColumnVector(skewRX1, x2T[j]), 2);</span>
<span class="nc" id="L655">                norm *= norm;</span>
<span class="nc" id="L656">                alpha2 = MatrixUtil.innerProduct(tmp1,tmp2)/norm;</span>

<span class="nc bnc" id="L658" title="All 2 branches missed.">                if (Math.abs(volume) &gt; tol) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                    if (volume &gt; 0) {</span>
<span class="nc" id="L660">                        ++volSumSign;</span>
                    } else {
<span class="nc" id="L662">                        --volSumSign;</span>
                    }
                }
<span class="nc bnc" id="L665" title="All 2 branches missed.">                if (Math.abs(alpha1) &gt; tol) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                    if (alpha1 &gt; 0) {</span>
<span class="nc" id="L667">                        ++depth1SumSign;</span>
                    } else {
<span class="nc" id="L669">                        --depth1SumSign;</span>
                    }
                }
<span class="nc bnc" id="L672" title="All 2 branches missed.">                if (Math.abs(alpha2) &gt; tol) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                    if (alpha2 &gt; 0) {</span>
<span class="nc" id="L674">                        ++depth2SumSign;</span>
                    } else {
<span class="nc" id="L676">                        --depth2SumSign;</span>
                    }
                }
            }
<span class="nc" id="L680">            System.out.printf(&quot;%d) sum(sign(vol))=%d, sum(sign(alpha1))=%d, sum(sign(alpha2))=%d\n&quot;,</span>
<span class="nc" id="L681">                    i, volSumSign, depth1SumSign, depth2SumSign);</span>
<span class="nc" id="L682">            posdepth[i] = volSumSign + depth1SumSign;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (index == -1) {</span>
<span class="nc bnc" id="L684" title="All 6 branches missed.">                if ((posdepth[i] &gt; 0) &amp;&amp; (depth1SumSign &gt; 0 || depth2SumSign &gt; 0)) {</span>
<span class="nc" id="L685">                    index = i;</span>
                }
<span class="nc bnc" id="L687" title="All 6 branches missed.">            } else if ((posdepth[i] &gt; posdepth[index]) &amp;&amp; (depth1SumSign &gt; 0 || depth2SumSign &gt; 0)) {</span>
<span class="nc" id="L688">                index = i;</span>
            }
        }
<span class="nc" id="L691">        System.out.printf(&quot;solution %d is best\n&quot;, index);</span>
<span class="nc" id="L692">        Camera.CameraExtrinsicParameters p2 = new Camera.CameraExtrinsicParameters();</span>

<span class="nc bnc" id="L694" title="All 4 branches missed.">        switch (index) {</span>
            case 0:
<span class="nc" id="L696">                p2.setRotation(r0);</span>
<span class="nc" id="L697">                p2.setTranslation(t0);</span>
<span class="nc" id="L698">                break;</span>
            case 1:
<span class="nc" id="L700">                p2.setRotation(r1);</span>
<span class="nc" id="L701">                p2.setTranslation(t1);</span>
<span class="nc" id="L702">                break;</span>
            case 2:
<span class="nc" id="L704">                p2.setRotation(r2);</span>
<span class="nc" id="L705">                p2.setTranslation(t2);</span>
<span class="nc" id="L706">                break;</span>
            default:
<span class="nc" id="L708">                p2.setRotation(r3);</span>
<span class="nc" id="L709">                p2.setTranslation(t3);</span>
                break;
        }

<span class="nc" id="L713">        return p2;</span>
    }

    public static boolean isInFrontOfCamera(double[] x, double[][] p, double[] XW) {
        /*
        from projection:
           scaleFactor * x = P * XW  (we don't have it, but it is a positive number)
           let M = P[0:2][0:2] the left 3x3 matrix of P
           let m3 = last row in M = M[2]
           where XW = [X Y Z W]^T and x = [u v 1]^T

           depth = scaleFactor * sign( det(M) ) / (W * lpsum(m3, 2))

           return depth &gt;= 0
         */
<span class="nc bnc" id="L728" title="All 2 branches missed.">        double W = (XW.length == 4) ? XW[3] : 1;</span>
<span class="nc" id="L729">        double[][] m = MatrixUtil.copySubMatrix(p, 0, 2, 0, 2);</span>
        //double[] m3 = Arrays.copyOfRange(m[2], 0, 3);
<span class="nc" id="L731">        double detM = MatrixUtil.determinant(m);</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">        return (detM / W) &gt; 0;</span>
    }

    /**
     * estimate the rotation and direction of motion using planar homography.
     * This is also called Projective Structure From Motion for the
     * Two-camera case.   it's a distorted version of euclidean 3d.
     * 4 solutions are returned and the user should decide between them by which produces
     * the larger number of points in front of the camera via triangulation of each pair of
     * correspondence.
     *
     * The results can be used to form a homography and then the essential matrix.
     * H2 = (R + ((1/d)*outerproduct(T, N^T))
     *             and then
     *             EM = essential matrix = [T]_x * H2
     *
     To upgrade to an affine projection, need 3 vanishing points
     (see Example 6.5 of MASKS).
     To directly upgrade from projective to euclidean projection, need
     5 ground truth points in general position (a.k.a. control points, points in WCS), that is, no 4 points
     are coplanar (see Section 9.3 of Belongie lec 9. and MASKS chap 5 &quot;Historical Notes&quot; and Algorithm 11.7).

     * &lt;pre&gt;
     * following &quot;An Invitation to 3-D Vision&quot; by Ma,  Soatto,  Kosecká, and Sastry
     * noted as MASKS.
     * Algorithm 5.2 in Chapter 5 and their code homography2Motion.m from
     * https://cs.gmu.edu/~kosecka/bookcode.html
     * which is free for non-commercial use.
     * &lt;/pre&gt;
     * @param x1c the image 1 set of correspondence points in camera coordinates.  format is 3 x N where
     * N is the number of points.
     * NOTE: since intrinsic parameters are not known, users of this method should
     * presumably center the coordinates in some manner
     * (e.g. unit standard normalization) since internally
     * an identity matrix is used for K.
     * @param x2c the image 1 set of correspondence points in camera coordinates.  format is 3 x N where
     *      * N is the number of points.
     *      * NOTE: since intrinsic parameters are not known, users of this method should
     *      * presumably center the coordinates in some manner
     *      * (e.g. unit standard normalization) since internally
     *      * an identity matrix is used for K.
     * @return the 2 solutions for the set of {estimated projections P1 and P2, and the triangulation of x1 and x2 in WCS}
     *
     */
    public static MotionAndStructure[] solve4RotationAndDirection(double[][] x1c, double[][] x2c) throws NotConvergedException {

<span class="pc bpc" id="L778" title="2 of 4 branches missed.">        if (x1c.length != 3 || x2c.length != 3) {</span>
<span class="nc" id="L779">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="fc" id="L781">        int n0 = x1c[0].length;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        if (x2c[0].length != n0) {</span>
<span class="nc" id="L783">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (n0 &lt; 4) {</span>
<span class="nc" id="L786">            throw new IllegalArgumentException(&quot;need at least 4 points to solve for the homography&quot;);</span>
        }

<span class="fc" id="L789">        int n = x1c[0].length;</span>
        int i, j;

        // just in case, normalize so that z=1
<span class="fc" id="L793">        x1c = MatrixUtil.copy(x1c);</span>
<span class="fc" id="L794">        x2c = MatrixUtil.copy(x2c);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L797">                x1c[j][i] /= x1c[2][i];</span>
<span class="fc" id="L798">                x2c[j][i] /= x2c[2][i];</span>
            }
        }

<span class="fc" id="L802">        boolean useNormConditioning = false;</span>
<span class="fc" id="L803">        double[][] tI = null;</span>
<span class="fc" id="L804">        double[][] tW = null;</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (useNormConditioning) {</span>
<span class="nc" id="L806">            x1c = MatrixUtil.copy(x1c);</span>
<span class="nc" id="L807">            x2c = MatrixUtil.copy(x2c);</span>
<span class="nc" id="L808">            tI = EpipolarNormalizationHelper.unitStandardNormalize(x1c);</span>
<span class="nc" id="L809">            tW = EpipolarNormalizationHelper.unitStandardNormalize(x2c);</span>
        }

        /*
        MASKS Chapter 5 and homography2Motion.m

        4 - point pairs homography with constraint that no 3 of the 4 are collinear.
        (1) normalize the homography Lemma 5.18 of Masks, end of Section 5.3.2.
        (2) decompose the planar homography into motion and structure parameters
             (R, (1/d)*T, N) where R is the rotation matrix transforming frame 1 to frame 2,
             T is the translation vector transforming frame 1 into frame 2,
             d is the distance from the world coordinate plane P to the optical center of the first camera,
             d &gt; 0, and N is the unit normal vector of the plane P with respect to
             the first camera frame.
        see Figure 5.10 of MASKS.
         */

        /*
        B = [];
        for i = 1:NPOINTS
             B = [B; makeRows(p(:,i), q(:,i))];
        end;
        0        0      0      -x1[0]  -x1[1]  -x1[2]   x2[1]*x1[0]  x2[1]*x1[1]  x2[1]*x1[2]
        x1[0]  x1[1]  x1[2]      0      0        0     -x2[0]*x1[0]  -x2[0]*x1[1]  -x2[0]*x1[2]

        NOTE: that is the same as  eqn(15) of Ma et al. 2003 in CameraCalibration.solveForHomgraphy()
        except that line [2*i] is multiplied by -1.
         */
<span class="fc" id="L837">        double[][] ell = new double[2*n][12];</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L839">            ell[2*i] = new double[]{0, 0, 0,</span>
                    -x1c[0][i], -x1c[1][i], -x1c[2][i],
                    x2c[1][i]* x1c[0][i],  x2c[1][i]* x1c[1][i],  x2c[1][i]*x1c[2][i]};
<span class="fc" id="L842">            ell[2*i + 1] = new double[]{x1c[0][i], x1c[1][i], x1c[2][i],</span>
                    0, 0, 0,
                    -x2c[0][i]* x1c[0][i], -x2c[0][i]* x1c[1][i], -x2c[0][i]*x1c[2][i]};
        }

<span class="fc" id="L847">        SVD svd = SVD.factorize(new DenseMatrix(ell));</span>
<span class="fc" id="L848">        double[][] vT = MatrixUtil.convertToRowMajor(svd.getVt());</span>
        double[][] u;
<span class="fc" id="L850">        double[] xOrth = vT[vT.length - 1];</span>

<span class="fc" id="L852">        int n2 = vT.length;//9</span>
<span class="fc" id="L853">        double[][] hEst = new double[3][3];</span>
        // reshape and transpose.  matlab reshape fills along columns, so transpose fills along rows
<span class="fc bfc" id="L855" title="All 2 branches covered.">        for (i = 0; i &lt; 3; i++) {</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L857">                hEst[i][j] = xOrth[(i * 3) + j];</span>
            }
        }

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (useNormConditioning) {</span>
<span class="nc" id="L862">            hEst = MatrixUtil.multiply(EpipolarNormalizationHelper.inverseT(tI), hEst);</span>
<span class="nc" id="L863">            hEst = MatrixUtil.multiply(hEst, tW);</span>
        }

<span class="fc" id="L866">        System.out.printf(&quot;HEst=\n%s\n&quot;, FormatArray.toString(hEst, &quot;%.3e&quot;));</span>

        //decomposition of H into motion and structure in case of calibration case
<span class="fc" id="L869">        svd = SVD.factorize(new DenseMatrix(hEst));</span>
        //System.out.printf(&quot;SVD(hEst).U=\n%s\n&quot;, svd.getU().toString());
        //System.out.printf(&quot;SVD(hEst).VT=\n%s\n&quot;, svd.getVt().toString());
        //System.out.printf(&quot;SVD(hEst).s=\n%s\n&quot;, Arrays.toString(svd.getS()));

        // H holds information about Kintr, R, and T (though only the direction of T)
<span class="fc" id="L875">        double[][] h = MatrixUtil.copy(hEst);</span>
<span class="fc" id="L876">        MatrixUtil.multiply(h, 1./svd.getS()[1]);</span>

<span class="fc" id="L878">        System.out.printf(&quot;h=HEst/svd(HEst).s[1]=\n%s\n&quot;, FormatArray.toString(h, &quot;%.3e&quot;));</span>

        // ** U and V here are equal SVD(hEst).V because SVD(A^T*A).VT == SVD(A^T*A).U == SVD(A).VT
<span class="fc" id="L881">        svd = SVD.factorize(new DenseMatrix(MatrixUtil.createATransposedTimesA(h)));</span>
        //System.out.printf(&quot;SVD(const* hEst^T * hEst ).U=\n%s\n&quot;, svd.getU().toString());
        //System.out.printf(&quot;SVD(const* hEst^T * hEst ).VT=\n%s\n&quot;, svd.getVt().toString());
        //System.out.printf(&quot;SVD(const* hEst^T * hEst ).s=\n%s\n&quot;, Arrays.toString(svd.getS()));

<span class="fc" id="L886">        u = MatrixUtil.convertToRowMajor(svd.getU());</span>
        // check that the 2nd singular value of H^T*H is &quot;1&quot;
<span class="pc bnc" id="L888" title="All 2 branches missed.">        assert(Math.abs(svd.getS()[1] - 1) &lt; 1E-3);</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">        if (MatrixUtil.determinant(u) &lt; 0) {</span>
<span class="nc" id="L890">            MatrixUtil.multiply(u, -1);</span>
        }
        // V1, V2, V3 are the e2 from SVD(H^T*H), which is V from SVD(H)
<span class="fc" id="L893">        double[][] uT = MatrixUtil.transpose(u);</span>
<span class="fc" id="L894">        double[] v1 = Arrays.copyOf(uT[0], uT[0].length);// column 0 of u == row 0 of uT</span>
<span class="fc" id="L895">        double[] v2 = Arrays.copyOf(uT[1], uT[1].length);</span>
<span class="fc" id="L896">        double[] v3 = Arrays.copyOf(uT[2], uT[2].length);</span>
<span class="fc" id="L897">        double[] orthToH = Arrays.copyOf(v3, v3.length);</span>
        // is left singular vector representing null space solution, but because left==right for A^T*A,
        // this is the right singular vector representing null space solution

        //v1*sqrt(1-s3)
<span class="fc" id="L902">        double[] v1t0 = Arrays.copyOf(v1, v1.length);</span>
<span class="fc" id="L903">        MatrixUtil.multiply(v1t0, Math.sqrt(1.-svd.getS()[2]));</span>

        //v3*sqrt(s1 -1)
<span class="fc" id="L906">        double[] v3t0 = Arrays.copyOf(v3, v3.length);</span>
<span class="fc" id="L907">        MatrixUtil.multiply(v3t0, Math.sqrt(svd.getS()[0] - 1.));</span>

<span class="fc" id="L909">        double s1s3 = 1./Math.sqrt(svd.getS()[0] - svd.getS()[2]);</span>

<span class="pc bpc" id="L911" title="1 of 2 branches missed.">        if (Double.isNaN(s1s3)) {</span>
            // should not happen
<span class="nc" id="L913">            return null;</span>
        }

<span class="fc" id="L916">        double[] u1 = Arrays.copyOf(v1t0, v1t0.length);</span>
<span class="fc" id="L917">        u1 = MatrixUtil.add(u1, v3t0);</span>
<span class="fc" id="L918">        MatrixUtil.multiply(u1, s1s3);</span>

<span class="fc" id="L920">        double[] u2 = Arrays.copyOf(v1t0, v1t0.length);</span>
<span class="fc" id="L921">        u2 = MatrixUtil.subtract(u2, v3t0);</span>
<span class="fc" id="L922">        MatrixUtil.multiply(u2, s1s3);</span>

<span class="fc" id="L924">        double[] sv2u1 = MatrixUtil.multiplyMatrixByColumnVector(MatrixUtil.skewSymmetric(v2), u1);</span>
<span class="fc" id="L925">        double[] sv2u2 = MatrixUtil.multiplyMatrixByColumnVector(MatrixUtil.skewSymmetric(v2), u2);</span>
<span class="fc" id="L926">        double[] hv2 = MatrixUtil.multiplyMatrixByColumnVector(h, v2);</span>
<span class="fc" id="L927">        double[] hu1 = MatrixUtil.multiplyMatrixByColumnVector(h, u1);</span>
<span class="fc" id="L928">        double[] hu2 = MatrixUtil.multiplyMatrixByColumnVector(h, u2);</span>
<span class="fc" id="L929">        double[][] shv2 = MatrixUtil.skewSymmetric(hv2);</span>
<span class="fc" id="L930">        double[] shv2hu1 = MatrixUtil.multiplyMatrixByColumnVector(shv2, hu1);</span>
<span class="fc" id="L931">        double[] shv2hu2 = MatrixUtil.multiplyMatrixByColumnVector(shv2, hu2);</span>

        /*
         U1 = [v2, u1, skew(v2)*u1];  &lt;== column 0 = v2, column 1 = u1, ...
         U2 = [v2, u2, skew(v2)*u2];
         W1 = [H*v2, H*u1, skew(H*v2)*H*u1];
         W2 = [H*v2, H*u2, skew(H*v2)*H*u2];
         */
<span class="fc" id="L939">        double[][] U1 = new double[3][3];</span>
<span class="fc" id="L940">        double[][] U2 = new double[3][3];</span>
<span class="fc" id="L941">        double[][] W1 = new double[3][3];</span>
<span class="fc" id="L942">        double[][] W2 = new double[3][3];</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L944">            U1[i][0] = v2[i];</span>
<span class="fc" id="L945">            U1[i][1] = u1[i];</span>
<span class="fc" id="L946">            U1[i][2] = sv2u1[i];</span>

<span class="fc" id="L948">            U2[i][0] = v2[i];</span>
<span class="fc" id="L949">            U2[i][1] = u2[i];</span>
<span class="fc" id="L950">            U2[i][2] = sv2u2[i];</span>

<span class="fc" id="L952">            W1[i][0] = hv2[i];</span>
<span class="fc" id="L953">            W1[i][1] = hu1[i];</span>
<span class="fc" id="L954">            W1[i][2] = shv2hu1[i];</span>

<span class="fc" id="L956">            W2[i][0] = hv2[i];</span>
<span class="fc" id="L957">            W2[i][1] = hu2[i];</span>
<span class="fc" id="L958">            W2[i][2] = shv2hu2[i];</span>
        }

<span class="fc" id="L961">        double[] N1 = Arrays.copyOf(sv2u1, sv2u1.length);</span>
<span class="fc" id="L962">        double[] N2 = Arrays.copyOf(sv2u2, sv2u2.length);</span>

        //out of the 4 solutions, the 2 which have N^T*e3 = n3 &gt; 0 pass the positive depth constraint.
        // that is, solutions with n1[2] &gt; 0 or n2[2] &gt; 0 are in front of the camera.

        //H = +- (R + (1/d)T*N^T).
        /*
        (R, (1/d)*T, N) where R is the rotation matrix transforming frame 1 to frame 2,
             T is the translation vector transforming frame 1 into frame 2,
             d is the distance from the world coordinate plane P to the optical center of the first camera,
             d &gt; 0, and N is the unit normal vector of the plane P with respect to
             the first camera frame.
         */
<span class="fc" id="L975">        double[][] W1U1T = MatrixUtil.multiply(W1, MatrixUtil.transpose(U1));</span>
<span class="fc" id="L976">        double[][] W2U2T = MatrixUtil.multiply(W2, MatrixUtil.transpose(U2));</span>

        // checking rotation and rounding for numerical inaccuracies
<span class="fc" id="L979">        double det1 = Math.round(MatrixUtil.determinant(W1U1T) * 1E11)/1E11;</span>
<span class="fc" id="L980">        double det2 = Math.round(MatrixUtil.determinant(W2U2T) * 1E11)/1E11;</span>
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">        if (Math.abs(det1 - 1) &gt; 1E-7) {</span>
            ///% project the rotation matrix to SO(3);
            //[U,S,V] = svd(R);
            //R = U*V';
<span class="nc" id="L985">            W1U1T = Rotation.orthonormalizeUsingSVD(W1U1T);</span>
<span class="nc" id="L986">            System.out.println(&quot;WARNING: expecting det(r) = 1 for proper rotation matrix&quot;);</span>
        }
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">        if (Math.abs(det2 - 1) &gt; 1E-7) {</span>
            ///% project the rotation matrix to SO(3);
            //[U,S,V] = svd(R);
            //R = U*V';
<span class="nc" id="L992">            W2U2T = Rotation.orthonormalizeUsingSVD(W2U2T);</span>
<span class="nc" id="L993">            System.out.println(&quot;WARNING: expecting det(r) = 1 for proper rotation matrix&quot;);</span>
        }

        /*
         U1 columns 0 and 1 are products of singular vectors of H, column 2 is orthogonal to columns 0 and 1
         U2 '''
         W1 is U1 with multiplication by H
         W2 is U2 with multiplication by H
         N1 is orthogonal to u1, v2
         N2 is orthogonal to u2, v2
         */

<span class="fc" id="L1005">        MotionAndStructure[] ms = new MotionAndStructure[2];</span>
<span class="fc" id="L1006">        ms[0] = new MotionAndStructure();</span>
<span class="fc" id="L1007">        ms[0].r = MatrixUtil.copy(W1U1T);</span>
<span class="fc" id="L1008">        ms[0].tDivD = MatrixUtil.multiplyMatrixByColumnVector(MatrixUtil.pointwiseSubtract(h, W1U1T), N1);</span>
<span class="fc" id="L1009">        ms[0].nHat = Arrays.copyOf(N1, N1.length);</span>
<span class="fc" id="L1010">        ms[0].orthToH = Arrays.copyOf(orthToH, orthToH.length);</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (N1[2] &lt; 0) {</span>
<span class="fc" id="L1012">            MatrixUtil.multiply(ms[0].tDivD, -1);</span>
<span class="fc" id="L1013">            MatrixUtil.multiply(ms[0].nHat, -1);</span>
        }

<span class="fc" id="L1016">        ms[1] = new MotionAndStructure();</span>
<span class="fc" id="L1017">        ms[1].r = MatrixUtil.copy(W2U2T);</span>
<span class="fc" id="L1018">        ms[1].tDivD = MatrixUtil.multiplyMatrixByColumnVector(MatrixUtil.pointwiseSubtract(h, W2U2T), N2);</span>
<span class="fc" id="L1019">        ms[1].nHat = Arrays.copyOf(N2, N2.length);</span>
<span class="fc" id="L1020">        ms[1].orthToH = Arrays.copyOf(orthToH, orthToH.length);</span>
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">        if (N2[2] &lt; 0) {</span>
<span class="fc" id="L1022">            MatrixUtil.multiply(ms[1].tDivD, -1);</span>
<span class="fc" id="L1023">            MatrixUtil.multiply(ms[1].nHat, -1);</span>
        }

<span class="fc" id="L1026">        return ms;</span>
    }

    /**
     * NOT READY FOR USE
     * TODO: proof read the algorithm and write test for this.
     * for the case of un-calibrated cameras viewing the same scene features,
     * recover the 3-D coordinates in WCS and the projection matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * 
     * The method implements the Sturm &amp; Triggs 1996 algorithm: 
     &quot;a method for the recovery of projective shape and motion from multiple 
     images of a scene by the factorization of a matrix containing the images 
     of all points in all views. This factorization is only possible when the
     image points are correctly scaled. The major technical contribution of 
     this paper is a practical method for the recovery of these scalings, 
     using only fundamental matrices and epipoles estimated from the image data.&quot;
     &quot;[it is a] closed form solutions, not iterative bundle-adjustment...&quot;
     * &lt;pre&gt;
     * references:
     * 
     * Sturm and Triggs 1996, 
    &quot;A Factorization Based Algorithm for Multi-Image Projective Structure and Motion&quot;
     https://link.springer.com/content/pdf/10.1007/3-540-61123-1_183.pdf
    
    see also proj_recons_fsvd.m from http://lear.inrialpes.fr/people/triggs/src/
    which has a very liberal copyright in the file COPYRIGHT
    Copyright Bill Triggs (http://www.inrialpes.fr/movi/people/Triggs),
    INRIA (http://www.inria.fr) and CNRS (http://www.cnrs.fr),
    1995-2002. All rights reserved.

    You may use and distribute [*] this work with or without modification,
    for any purpose and without fee or royalty, subject to the following
    conditions:
       (see file COPYRIGHT)
    
     * &lt;/pre&gt;
     * 
     * NOTE: Sturm &amp; Triggs 1996 state in their code, &quot;% The projective output 
     frame is numerically well-conditioned, but otherwise *completely* 
     arbitrary. It has *no* relation to any Euclidean frame.
     * 
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ProjectionResults calculateProjectiveReconstruction(
        double[][] x, int mImages) throws NotConvergedException {

        //TODO: fix this.
        // normalization should be performed by caller of the method and advice to denormalize translation results.
        // also add references.

<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1087">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1090">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L1092">        int nFeatures = x[0].length / mImages;</span>
        
        // need at least 7 points in each image for the point version of fundamental
        // matrix.
        // not implementing the line version as Triggs in another paper states
        //    that they may be more affected by outliers
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        if (nFeatures &lt; 7) {</span>
<span class="nc" id="L1099">            throw new IllegalArgumentException(&quot;need at least 7 points per image&quot;);</span>
        }
        
        /*
        3.3 Outline of the Algorithm
        The complete algorithm is composed of the following steps.
        i. Normalize the image coordinates, by applying transformations Ti.
        2. Estimate the fundamental matrices and epipoles with the method of [Har95].
        3. Determine the scale factors Aip using equation (3).
        4. Build the rescaled measurement matrix W.
        5. Balance W by column-wise and &quot;triplet-of-rows&quot;-wise scalar multiplications.
        6. Compute the SVD of the balanced matrix W.
        7. From the SVD, recover projective motion and shape.
        8. Adapt projective motion, to account for the normalization transformations Ti of
        step 1.
        */
                
        // following proj_recons_fsvd.m from triggs_projrecons-25-Feb-01
        //    pairs of image sets can be formed either by using the first
        //    image as x1 for all images, or chaining them all together.
        // i.e. [(0,1), (0, 2), (0,3)] or [(0,1), (1,2), (2,3)].
        // choosing the later here.
        
<span class="nc" id="L1122">        RANSACSolver ransac = new RANSACSolver();</span>
<span class="nc" id="L1123">        double[] e12 = new double[3];</span>
        EpipolarTransformationFit fit;
        double[][] fm;
<span class="nc" id="L1126">        ErrorType errorType = ErrorType.DIST_TO_EPIPOLAR_LINE;</span>
<span class="nc" id="L1127">        boolean useToleranceAsStatFactor = true;</span>
<span class="nc" id="L1128">        double tolerance = 3.84;</span>
        // TODO: estimate this:
<span class="nc bnc" id="L1130" title="All 6 branches missed.">        boolean recalcIterations = (nFeatures &gt; 100 || (mImages &gt; 10 &amp;&amp; nFeatures &gt; 20));</span>
<span class="nc" id="L1131">        boolean calibrated = false;</span>
        
        int i, j;
        // image pairs extracted from x:
        double[][] x1, x2;
        // the normalization centroidX, centroidY, and sigma values applied to x1 and x2:
<span class="nc" id="L1137">        double[] tt = new double[3*mImages];</span>
        
        // use a reference depth of 1 for first image's features, as have no measurements for any depths to bootstrap from.
<span class="nc" id="L1140">        double[][] lambdas = MatrixUtil.zeros(mImages, nFeatures);</span>
<span class="nc" id="L1141">        Arrays.fill(lambdas[0], 1.);</span>
        
<span class="nc" id="L1143">        x1 = extractAndNormalize(x, 0, nFeatures, tt);</span>
        DenseMatrix x1M, x2M;
<span class="nc" id="L1145">        x1M = new DenseMatrix(x1);</span>
<span class="nc" id="L1146">        double[] x1p = new double[3];</span>
<span class="nc" id="L1147">        double[] x2p = new double[3];</span>
        double[] x2e, tmp;
        double tmp2, x2esq;
        
        // format x into shape W (3*mImages X nFeatures):
        //  row 0:2 = image 1 points where row 0 is the x coordinates, row 1 is the y coordinates
        //  row 3:5 = image 2 points
<span class="nc" id="L1154">        double[][] w = MatrixUtil.zeros(3*mImages, nFeatures);</span>
<span class="nc" id="L1155">        System.arraycopy(x1[0], 0, w[0], 0, nFeatures);</span>
<span class="nc" id="L1156">        System.arraycopy(x1[1], 0, w[1], 0, nFeatures);</span>
<span class="nc" id="L1157">        System.arraycopy(x1[2], 0, w[2], 0, nFeatures);</span>
        
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        for (i = 1; i &lt; mImages; ++i) {</span>
            
<span class="nc" id="L1161">            x2 = extractAndNormalize(x, i, nFeatures, tt);</span>
<span class="nc" id="L1162">            x2M = new DenseMatrix(x2);</span>
            
<span class="nc" id="L1164">            System.arraycopy(x2[0], 0, w[i*3], 0, nFeatures);</span>
<span class="nc" id="L1165">            System.arraycopy(x2[1], 0, w[i*3+1], 0, nFeatures);</span>
<span class="nc" id="L1166">            System.arraycopy(x2[2], 0, w[i*3+2], 0, nFeatures);</span>
            
<span class="nc" id="L1168">            fit = ransac.calculateEpipolarProjection(x1M, x2M, errorType, </span>
                useToleranceAsStatFactor, tolerance, recalcIterations, calibrated);
            
<span class="nc" id="L1171">            fm = MatrixUtil.convertToRowMajor(fit.getFundamentalMatrix());</span>
            
            /*
            TODO: consider keeping only the inliers in a future version that handles
            occlusion.  by imputation or applied factorization or other means...
            x1M = extractIndices(x1M, fitR.inlierIndexes);
            x2M = extractIndices(x2M, fitR.inlierIndexes);
            x1 = MatrixUtil.convertToRowMajor(x1M);
            x2 = MatrixUtil.convertToRowMajor(x2M);
            int nFeaturesI = x1[0].length;
            */
            
            // calc left epipole
<span class="nc" id="L1184">            e12 = EpipolarTransformer.calculateEpipoles(fit.getFundamentalMatrix())[1];</span>

<span class="nc bnc" id="L1186" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L1187">                extractColumn(x1, j, x1p);</span>
<span class="nc" id="L1188">                extractColumn(x2, j, x2p);</span>
                
                //xe = cross(x2_j, e12);  // same as x2 cross -e21
<span class="nc" id="L1191">                x2e = MatrixUtil.crossProduct(x2p, e12);</span>
                
                //lambda(i,j) = lambda(x1,j) * abs((x1_j' * FM * xe) / (xe' *xe));
                //    note: epipolar line2 = x1_j' * FM
<span class="nc" id="L1195">                x2esq = MatrixUtil.innerProduct(x2e, x2e);</span>
                
<span class="nc" id="L1197">                tmp = MatrixUtil.multiplyRowVectorByMatrix(x1p, fm);</span>
                
<span class="nc" id="L1199">                tmp2 = MatrixUtil.innerProduct(tmp, x2e);</span>
<span class="nc" id="L1200">                lambdas[i][j] = lambdas[i-1][j] * Math.abs(tmp2/x2esq);</span>
            }
            
<span class="nc" id="L1203">            x1 = x2;</span>
<span class="nc" id="L1204">            x1M = x2M;</span>
        }
        
        /*
        4. Build the rescaled measurement matrix W.
        5. Balance W by column-wise and &quot;triplet-of-rows&quot;-wise scalar mutliplications.
        
        as stated in Sturm &amp; Triggs 1996 Section 3.2, the balancing of the
        rescaled measurement matrix by Q's then P's can be replaced by
        balancing the m x n matrix lambdas instead of W because of the simplification
        of working with normalized image coordinates Q.
        The balance operations are demonstrated in proj_recons_fsvd.m
        */
<span class="nc" id="L1217">        double eps = 1.e-11;</span>
        double[] lambdaj;
        int k;
        // authors find 2 iterations is heuristically enough:
<span class="nc bnc" id="L1221" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L1223">                lambdaj = MatrixUtil.extractColumn(lambdas, j);</span>
<span class="nc" id="L1224">                tmp2 = MatrixUtil.lPSum(lambdaj, 2);</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                if (Math.abs(tmp2) &lt; eps) { </span>
<span class="nc" id="L1226">                    tmp2 = eps;</span>
                }
<span class="nc bnc" id="L1228" title="All 2 branches missed.">                for (k = 0; k &lt; mImages; ++k) {</span>
<span class="nc" id="L1229">                    lambdas[k][j] = lambdaj[k] / tmp2;</span>
                }
            }
<span class="nc bnc" id="L1232" title="All 2 branches missed.">            for (k = 0; k &lt; mImages; ++k) {</span>
<span class="nc" id="L1233">                tmp2 = MatrixUtil.lPSum(lambdas[k], 2);</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                if (Math.abs(tmp2) &lt; eps) { </span>
<span class="nc" id="L1235">                    tmp2 = eps;</span>
                }
<span class="nc" id="L1237">                MatrixUtil.multiply(lambdas[k], 1./tmp2);</span>
            }
        }
        
        // rescale the image points
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L1244">                w[3*i + 0][j] *= lambdas[i][j];</span>
<span class="nc" id="L1245">                w[3*i + 1][j] *= lambdas[i][j];</span>
<span class="nc" id="L1246">                w[3*i + 2][j] *= lambdas[i][j];</span>
            }
        }
        
        /*
        6. Compute the SVD of the balanced matrix W.
        7. From the SVD, recover projective motion and shape.
        8. Adapt projective motion, to account for the normalization transformations Ti of
        step 1.
        */
        
        // if the number of images is larger than 10 or the number of features
        //   is greater than 30, will use cur decomposition
        double[][] u, vT;
        double[][] s;
        //double[][] wRescaled;
<span class="nc bnc" id="L1262" title="All 4 branches missed.">        if (mImages &gt; 10 || nFeatures &gt; 30) {</span>
<span class="nc" id="L1263">            CUR cur = CURDecomposition.calculateDecomposition(w, 4);</span>
<span class="nc" id="L1264">            SVDProducts curSVD = cur.getApproximateSVD();</span>
<span class="nc" id="L1265">            u = curSVD.u;</span>
<span class="nc" id="L1266">            vT = curSVD.vT;</span>
<span class="nc" id="L1267">            s = curSVD.sigma;</span>
            
            // Sturm &amp; Triggs divide by the largest eigenvalue:
<span class="nc" id="L1270">            MatrixUtil.multiply(s, 1./s[0][0]);</span>
            
            //wRescaled = cur.getResult();
<span class="nc" id="L1273">        } else {</span>
<span class="nc" id="L1274">            SVDProducts svd = MatrixUtil.performSVD(w);</span>
            
            //reduce rank to 4
<span class="nc" id="L1277">            u = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 3);</span>
<span class="nc" id="L1278">            vT = MatrixUtil.copySubMatrix(svd.vT, 0, 3, 0, svd.vT[0].length-1);</span>
            
<span class="nc" id="L1280">            s = MatrixUtil.zeros(4, 4);</span>
<span class="nc" id="L1281">            s[0][0] = svd.s[0];</span>
<span class="nc" id="L1282">            s[1][1] = svd.s[1];</span>
<span class="nc" id="L1283">            s[2][2] = svd.s[2];</span>
<span class="nc" id="L1284">            s[3][3] = svd.s[3];</span>
            
            /*double[][] sqrts4 = MatrixUtil.zeros(4, 4);
            sqrts4[0][0] = Math.sqrt(svd.s[0]);
            sqrts4[1][1] = Math.sqrt(svd.s[1]);
            sqrts4[2][2] = Math.sqrt(svd.s[2]);
            sqrts4[3][3] = Math.sqrt(svd.s[3]);

            u = MatrixUtil.multiply(u4, sqrts4);
            vT = MatrixUtil.multiply(sqrts4, vT4);
            wRescaled = MatrixUtil.multiply(u, vT);
            */
            
            // Sturm &amp; Triggs divide by the largest eigenvalue:
<span class="nc" id="L1298">            MatrixUtil.multiply(s, 1./s[0][0]);</span>
        }
        
        //Ps = fliplr(U(:,1:4));             // 3*MImages X 4
        //Xs = flipud(S(1:4,1:4)*V(:,1:4)'); // 4 X 4*mImages
<span class="nc" id="L1303">        double[][] ps = MatrixUtil.copy(u);</span>
<span class="nc" id="L1304">        MatrixUtil.flipLR(ps);</span>
<span class="nc" id="L1305">        double[][] XW = MatrixUtil.multiply(s, vT);</span>
<span class="nc" id="L1306">        MatrixUtil.flipUD(XW);</span>
   
        //denormalize ps.  = ps * T^-1
        // tt is the normalization centroidX, centroidY, and sigma values applied to x1 and x2:
        /*
                 | 1  0  xc |   | s  0   0 |   | s   0  xc |
          T^-1 = | 0  1  yc | * | 0  s   0 | = | 0   s  yc |
                 | 0  0   1 |   | 0  0   1 |   | 0   0   1 |
        */
<span class="nc" id="L1315">        double[][] tInv = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L1316">        tInv[2][2] = 1;</span>
        double ts, txc, tyc;
        double[] p0, p1, p2;
<span class="nc" id="L1319">        double[][] p = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L1321">            txc = tt[3*i];</span>
<span class="nc" id="L1322">            tyc = tt[3*i + 1];</span>
<span class="nc" id="L1323">            ts = tt[3*i + 2];</span>
<span class="nc" id="L1324">            tInv[0][0] = ts;</span>
<span class="nc" id="L1325">            tInv[1][1] = ts;</span>
<span class="nc" id="L1326">            tInv[0][2] = txc;</span>
<span class="nc" id="L1327">            tInv[1][2] = tyc;</span>
            
<span class="nc" id="L1329">            p0 = ps[3*mImages];</span>
<span class="nc" id="L1330">            p1 = ps[3*mImages + 1];</span>
<span class="nc" id="L1331">            p2 = ps[3*mImages + 2];</span>
<span class="nc" id="L1332">            System.arraycopy(p0, 0, p[0], 0, 4);</span>
<span class="nc" id="L1333">            System.arraycopy(p1, 0, p[1], 0, 4);</span>
<span class="nc" id="L1334">            System.arraycopy(p2, 0, p[2], 0, 4);</span>
            
<span class="nc" id="L1336">            p = MatrixUtil.multiply(p, tInv);</span>
            
<span class="nc" id="L1338">            System.arraycopy(p[0], 0, ps[3*mImages], 0, 4);</span>
<span class="nc" id="L1339">            System.arraycopy(p[1], 0, ps[3*mImages + 1], 0, 4);</span>
<span class="nc" id="L1340">            System.arraycopy(p[2], 0, ps[3*mImages + 2], 0, 4);</span>
        }
        
<span class="nc" id="L1343">        ProjectionResults rr = new ProjectionResults();</span>
<span class="nc" id="L1344">        rr.XW = XW;</span>
<span class="nc" id="L1345">        rr.projectionMatrices = ps;</span>
        
<span class="nc" id="L1347">        return rr;</span>
    }

     /**
      * NOTE: the method needs improvement to choose the best 2 solutions, meanwhile prefer to use
      * calculateProjectiveReconstruction(double[][] x1c, double[][] x2c).
     * given correspondence between two images in image coordinates calculate 
     * the extrinsic camera parameters and the 3-D points.
     * 
     * This method calculates the essential matrix and uses the SVD of it to
     * extract the translation and possible rotation matrices which are
     * filtered to find the best while calculating triangulation for each point.
     * 
     * Note that the absolute translation between the two cameras can never be 
     * recovered from pure image measurements alone, regardless of how many 
     * cameras or points are used as ground control points are
     * needed.
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     Szeliski 2010, Chapter 7, and eqn (7.25).
     Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;, pg 121 
     * &lt;/pre&gt;
     * @param intr1 intrinsic camera matrix for image 1 in units of pixels.
     * @param intr2 intrinsic camera matrix for image 2 in units of pixels.
     * @param x1 the image 1 set of correspondence points in image reference frame.
     * format is 3 x N where N is the number of points.
     * @param x2 the image 2 set of correspondence points in image reference frame.
     * format is 3 x N where N is the number of points.
     * @return
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static ReconstructionResults calculateUsingEssentialMatrix(
            double[][] intr1, double[][] intr2,
            double[][] x1, double[][] x2) throws NotConvergedException {
                
<span class="pc bpc" id="L1383" title="2 of 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L1384">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="fc" id="L1386">        int n = x1[0].length;</span>
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L1388">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
        
        /*
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (1) compute fundamental matrix FM from the correspondence x1, x2
        (2) compute the camera matrices P1, P2 from FM.
        (3) For each point correspondence, compute the point X in 3D space (triangulation)
        */
        
<span class="fc" id="L1399">        double[][] k1IntrInv = Camera.createIntrinsicCameraMatrixInverse(intr1);</span>
<span class="fc" id="L1400">        double[][] k2IntrInv = Camera.createIntrinsicCameraMatrixInverse(intr2);</span>
        
        // the direction of the points is calculated by K^-1 * x
<span class="fc" id="L1403">        double[][] x1C = MatrixUtil.multiply(k1IntrInv, x1);</span>
<span class="fc" id="L1404">        double[][] x2C = MatrixUtil.multiply(k2IntrInv, x2);</span>
                
<span class="fc" id="L1406">        DenseMatrix x1M = new DenseMatrix(x1C);</span>
<span class="fc" id="L1407">        DenseMatrix x2M = new DenseMatrix(x2C);</span>

<span class="fc" id="L1409">        double tolerance = 3; //3.84 5.99 7.82</span>
<span class="fc" id="L1410">        boolean useToleranceAsStatFactor = true;</span>
<span class="fc" id="L1411">        ErrorType errorType = ErrorType.SAMPSONS;</span>
<span class="fc" id="L1412">        EpipolarTransformationFit fitR = null;</span>
<span class="fc" id="L1413">        boolean reCalcIterations = true;</span>

        //if true, solves for the Essential Matrix, else solves
        //for the Fundamental Matrix.  The difference is in the diagonal used for
        //dimension reduction.
<span class="fc" id="L1418">        boolean coordsAreInCameraRefFrame = true;</span>
        
<span class="fc" id="L1420">        RANSACSolver solver = new RANSACSolver();</span>
<span class="fc" id="L1421">        fitR = solver.calculateEpipolarProjection(</span>
            x1M, x2M, errorType, useToleranceAsStatFactor, tolerance,
                reCalcIterations, coordsAreInCameraRefFrame);
        
<span class="fc" id="L1425">        System.out.println(&quot;RANSAC fit=&quot; + fitR.toString());</span>
        
<span class="fc" id="L1427">        DenseMatrix em = fitR.getFundamentalMatrix();</span>

<span class="fc" id="L1429">        SVD svdE = SVD.factorize(em);</span>

<span class="fc" id="L1431">        double[][] u = MatrixUtil.convertToRowMajor(svdE.getU());</span>
<span class="fc" id="L1432">        double[][] vT = MatrixUtil.convertToRowMajor(svdE.getVt());</span>

<span class="fc" id="L1434">        double detU = MatrixUtil.determinant(u);</span>
<span class="fc" id="L1435">        double detV = MatrixUtil.determinant(vT);</span>
        
<span class="fc" id="L1437">        System.out.printf(&quot;SVD.u=\n%s\n&quot;, FormatArray.toString(u, &quot;%.3e&quot;));</span>
<span class="fc" id="L1438">        System.out.printf(&quot;SVD.s=\n%s\n&quot;, FormatArray.toString(svdE.getS(), &quot;%.3e&quot;));</span>
<span class="fc" id="L1439">        System.out.printf(&quot;SVD.vT=\n%s\n&quot;, FormatArray.toString(vT, &quot;%.3e&quot;));</span>
<span class="fc" id="L1440">        System.out.printf(&quot;det(SVD.u)=%.2f\n&quot;, detU);</span>
<span class="fc" id="L1441">        System.out.printf(&quot;det(SVD.vT)=%.2f\n&quot;, detV);</span>
        
        /*
        Szeliski 2010 chap 7:
        Once an estimate for the essential matrix E has been recovered, 
        the direction of the translation vector t can be estimated. 
        
        Note that the absolute distance between the two cameras can never 
        be recovered from pure image measurements alone without knowledge 
        about absolute camera and point positions or distances, often called ground 
        control points in photogrammetry.
        */
        
        // det(R)=1 is a proper rotation matrix.  rotation angles are counterclockwise.
        //           it's a special orthogonal matrix and provides the
        //           defining matrix representation of the group of proper n-dimensional rotations, denoted
        //           by SO(n). http://scipp.ucsc.edu/~haber/ph251/rotreflect_17.pdf
        // det(R)=-1 is an improper rotation matrix representing rotations that
        //           require mirrors.
        //           The most general improper rotation matrix is a product of a proper rotation by an
        //           angle θ about some axis nˆ and a mirror reflection through a plane that passes through
        //           the origin and is perpendicular to nˆ.  NOTE: nˆ is determined by
        //           the right hand rule.
        
        /*
        Sect 7.2 of Szeliski 2010 eqn (7.25) introduces
        R3 and R4 constructed from -U as 2 more rotation possibilities to be tested
        and that is necessary in some cases where det(R) would otherwise be -1
        (reflection).
        ...we only know both E and tˆup to a sign. Furthermore, the matrices U and V
        are not guaranteed to be rotations (you can flip both their signs and 
        still get a valid SVD).   
        For this reason, we have to generate all four possible rotation matrices
        
        R = +-U * R_Z(+-90)^T * V^T
           and keep the 2 whose determinant = 1
        */
<span class="fc" id="L1478">        double[][] r1 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L1479">        double[][] r2 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L1480">        populateWithDet1Rs(u, vT, r1, r2);</span>
        
        // last column in u is the second epipole and is the direction of vector t
<span class="fc" id="L1483">        double[] t1 = MatrixUtil.extractColumn(u, 2);</span>
<span class="fc" id="L1484">        double[] t2 = Arrays.copyOf(t1, t1.length);</span>
<span class="fc" id="L1485">        MatrixUtil.multiply(t2, -1); </span>
        
<span class="fc" id="L1487">        System.out.printf(&quot;R1=\n%s\n&quot;, FormatArray.toString(r1, &quot;%.3e&quot;));</span>
<span class="fc" id="L1488">        System.out.printf(&quot;R2=\n%s\n&quot;, FormatArray.toString(r2, &quot;%.3e&quot;));</span>
<span class="fc" id="L1489">        System.out.printf(&quot;t1=\n%s\n&quot;, FormatArray.toString(t1, &quot;%.3e&quot;));</span>
<span class="fc" id="L1490">        System.out.printf(&quot;t2=\n%s\n&quot;, FormatArray.toString(t2, &quot;%.3e&quot;));</span>
        
        //then of the 4 possible choices find the one with the largest number of positive Z.
          
        //NOTE: the last column vector in u is the smallest
        //    eigenvector.  it is epipole2, that is, the right image position 
        //    of the epipolar projection of the left camera center.
        //    it's int the left null space of E.

        // reset the image coordinate list to the inliers only
<span class="fc" id="L1500">        x1M = extractIndices(new DenseMatrix(x1), fitR.inlierIndexes);</span>
<span class="fc" id="L1501">        x2M = extractIndices(new DenseMatrix(x2), fitR.inlierIndexes);</span>
<span class="fc" id="L1502">        x1 = MatrixUtil.convertToRowMajor(x1M);</span>
<span class="fc" id="L1503">        x2 = MatrixUtil.convertToRowMajor(x2M);</span>
        
<span class="fc" id="L1505">        double[][] rSelected = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L1506">        double[] tSelected = new double[3];</span>
<span class="fc" id="L1507">        double[][] XW = MatrixUtil.zeros(4, x1[0].length);</span>

<span class="fc" id="L1509">        x1C = MatrixUtil.multiply(k1IntrInv, x1);</span>
<span class="fc" id="L1510">        x2C = MatrixUtil.multiply(k2IntrInv, x2);</span>

        // this method needs x1 and x2 in camera coordinates
<span class="fc" id="L1513">        bestInCheiralityTest(x1C, x2C, intr1, intr2, r1, r2, t1, t2, rSelected, tSelected, XW);</span>
        
<span class="fc" id="L1515">        ReconstructionResults rr = new ReconstructionResults();</span>
<span class="fc" id="L1516">        rr.XW = XW;</span>
<span class="fc" id="L1517">        rr.k1ExtrRot = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L1518">        rr.k1ExtrTrans = new double[]{0, 0, 0};</span>
<span class="fc" id="L1519">        rr.k1Intr = intr1;</span>
<span class="fc" id="L1520">        rr.k2ExtrRot = rSelected;</span>
<span class="fc" id="L1521">        rr.k2ExtrTrans = tSelected;</span>
<span class="fc" id="L1522">        rr.k2Intr = intr2;</span>
<span class="fc" id="L1523">        rr.essentialMatrix = MatrixUtil.convertToRowMajor(em);</span>
<span class="fc" id="L1524">        rr.fundamentalMatrix = null;</span>
<span class="fc" id="L1525">        rr.svdU = u;</span>
<span class="fc" id="L1526">        rr.svdVt = vT;</span>
<span class="fc" id="L1527">        rr.svdS = Arrays.copyOf(svdE.getS(), svdE.getS().length);</span>

<span class="fc" id="L1529">        return rr;        </span>
    }

    /**
     * NOTE: not ready for use yet.
     * 
     * TODO: proof read the algorithm and write test for this.
     * for the case where the cameras are viewing small, distant scenes,
     * recover the 3-D coordinates in WCS and the rotation matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * assumes an orthographic camera model.
     * can use the orthographic camera model when
     *    (the average distance of an object from the camera) 
     *     .geq. 10*(the average width of the object (measured along the optical axis of the camera).
     * &lt;pre&gt;
     * references:
     * 
     * lecture 16 notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
     * http://www-cse.ucsd.edu/classes/sp04/cse252b/notes/lec16/lec16.pdf
     * 
     * lectures of Deva Ramanan at http://16720.courses.cs.cmu.edu/lec/sfm.pdf
     * .:w
     * 
     * Tomasi &amp; Kanade 1991, &quot;Shape and motion from image streams under 
     * orthography: a factorization method&quot;, International journal of computer vision 
     * 
     *  Morita and Kanade 1997 for solving Q.
         T. Morita and T. Kanade, A Sequential Factorization Method for Recovering Shape and Motion
         from Image Streams, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 19,
         no.8, pp.858-867, Aug 1997  (1994?)
         
     * Higham, 1988, “Computing a Nearest Symmetric Positive Semidefinite Matrix,” 
     *    Linear Algebra and Appl., 103:103-118, 1988
     * 
     * a great summary of the above:
     * http://note.sonots.com/SciSoftware/Factorization.html#cse252b
     * http://note.sonots.com/?plugin=attach&amp;refer=SciSoftware%2FFactorization&amp;openfile=Factorization.pdf
     * 
     * and a derivation of the geometry of the tracking equation:
     * Birchfield 1997, &quot;Derivation of Kanade-Lucas-Tomasi Tracking Equation&quot;
     * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.185.413&amp;rep=rep1&amp;type=pdf
     * &lt;/pre&gt;
     * NOTE: could overload this method to enable handling of occlusion 
     * following Section 5 of Tomasi &amp; Kanade 1991, but might want to alter the
     * algorithm to use geometric median in place of centroid so that the
     * &quot;centers&quot; are not as affected by removing or adding a point.
     * NOTE: comments from Poelman &amp; Kanade 1992:
     * Orthographic projection does not account for the apparent change in size 
     * of an object as it moves toward or away from the camera, nor the different 
     * angle from which an object is viewed as it moves parallel to the image plane.
     * NOTE: consider implementing Section 3.3 Sequential Factorization Algorithm
     * from the Morita &amp; Kanade 1997 paper (1994?)
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static OrthographicProjectionResults calculateAffineReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                                
<span class="nc bnc" id="L1595" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1596">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1599">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L1601">        int nFeatures = x[0].length / mImages;</span>

        //TODO: check this
        //2mn &gt;= 8m + 3n – 12
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1606">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        // Tomasi &amp; Kanade 1992: An image stream can be represented by the
        //  2*F X P measurment matrix W of image coordinates of P points
        // tracked through F frames.
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size is mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size is mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create matrix WC = W - t
        
        // row[0] = image_0_x[0], image_0_x[1], image_0_x[2], ...
        // row[1] = image_1_x[0], image_1_x[1], image_1_x[2], ...
        // ...
        // row[mImages+0] = image_0_y[0], image_0_y[1], image_0_y[2], ...
<span class="nc" id="L1628">        double[][] w = MatrixUtil.zeros(2*mImages, nFeatures);</span>
        // t points to the camera's focal point
<span class="nc" id="L1630">        double[] t = new double[2*mImages];</span>
        int i, j;
        int m, n, rowU, rowV, col;
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="nc" id="L1634">            rowU = m;</span>
<span class="nc" id="L1635">            rowV = mImages + m;</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="nc" id="L1637">                col = nFeatures*m + n;</span>
<span class="nc" id="L1638">                w[rowU][n] = x[0][col];</span>
<span class="nc" id="L1639">                t[rowU] += x[0][col];</span>
<span class="nc" id="L1640">                w[rowV][n] = x[1][col];</span>
<span class="nc" id="L1641">                t[rowV] += x[1][col];</span>
            }
<span class="nc" id="L1643">            t[rowU] /= (double)nFeatures;</span>
<span class="nc" id="L1644">            t[rowV] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="nc" id="L1648">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="nc" id="L1651">                wC[i][n] -= t[i];</span>
            }
        }
        
        // see Fig 3.1 of Tomasi &amp; Kanade 1991 or Fig 2. of Belongie lecture notes
        
        // under orthography, this coordinate centered matrix has rank 3
        // and can be factored into the product of 2 matrices, R and S:
        // the camera rotation matrix R (size 2FX3) and 
        // the shape matrix S (size 3XP) which is shape in a coordinate system 
        // attached to the object centroid.
        //The two components of the camera translation along the image plane
        // are computed as averages of the rows of W
                
        // the registered measurement matrix is highly rank deficient
        // eqn (3.11)
<span class="nc" id="L1667">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        
        // Tomasi &amp; Kanade 1992,eqn (3.12): 1st 3 columns of U, upper 3X3 of S, and first 3 rows of V^T
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="nc" id="L1673">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="nc" id="L1674">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L1675">        s3[0][0] = svd.s[0];</span>
<span class="nc" id="L1676">        s3[1][1] = svd.s[1];</span>
<span class="nc" id="L1677">        s3[2][2] = svd.s[2];</span>
<span class="nc" id="L1678">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="nc" id="L1679">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="nc" id="L1680">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="nc" id="L1681">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="nc" id="L1682">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="nc" id="L1689">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="nc" id="L1690">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
        
        //Tamasi &amp; Kanade
        // (2*mImages)X3
<span class="nc" id="L1694">        double[][] rC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="nc" id="L1696">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="nc" id="L1698">        System.out.printf(&quot;rC=\n%s\n&quot;, FormatArray.toString(rC, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L1700">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
<span class="nc" id="L1701">        System.out.printf(&quot;rC*sC=\n%s\n&quot;, FormatArray.toString(</span>
<span class="nc" id="L1702">            MatrixUtil.multiply(rC, sC), </span>
            &quot;%.4e&quot;));
        
        // wC = rC * sC  
        //rC and sC are linear translations of the true rotation matrix R and
        //  the true shape matrix S, respectively.
        // Morita and Kanade: the decomposition is not completely unique.  
        //     it's unique only up to an affine transformation
        
        //Tomasi &amp; Kanade eqn (3.15) and Belongie Section 16.4.4 (c)
        // metric constraints:  
        // note that R is composed of rows of unit vectors.
        // note that the first F rows in R are orthogonal to the last F rows in R.
        
        /*
        NOTE: can make a rotation matrix orthonormal:
        svd = MatrixUtil.performSVD(rotationMAtrix);
        ortho = MatrixUtil.multiply(svd.u, MatrixUtil.transpose(svd.vT));
        detR = MatrixUtil.determinant(ortho);
        assert(Math.abs(detR - 1.)&lt;1.e-7);

        if no translation, can use procrustes to get difference in rotation:
           double[][] ar = Rotation.procrustesAlgorithmForRotation(rot1, _r2);
        */
        
<span class="nc" id="L1727">        double[][] q = solveForTransformationToOrthoNormal(rC);</span>
        
       
        //Q is an affine transformation which transforms rC into R in motion space
        //   and the inverse of Q transforms sC into S in the shape space
        
        // finding Q is called &quot;Metric Transformation&quot;
        
        // rC size is  (2*mImages)X3
        // sC size is 3XnFeatures
<span class="nc" id="L1737">        double[][] r2 = MatrixUtil.multiply(rC, q);</span>
        
        //assertDotProductMetrics(r2, mImages);
        
<span class="nc" id="L1741">        double[][] s2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q), sC);</span>
        
        // assert that wC is the same as wC2
<span class="nc" id="L1744">        System.out.printf(&quot;r2*s2=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(r2, s2), </span>
            &quot;%.4e&quot;));
        
        /*
        from Tomasi &amp; Kanade 1992:
        If desired, align the first camera reference system with the world 
        reference system by forming the products R*R_0 and R_0^T*S, 
        where the orthonormal matrix R_0 = [i1 j1 k1] rotates the first camera 
        reference system into the identity matrix
        
        i0x i0y i0z    *  r0ix  r0jx  r0kx   = (i0 dot r0i)  (i0 dot r0j) (i0 dot r0k)
        i1x i1y i1z       r0iy  r0jy  r0ky
        i2x i2y i2z       r0iz  r0jz  r0kz
        i3x i3y i3z
        ...
        j0x j0y j0z
        j1x j1y j1z
        */
        
<span class="nc" id="L1763">        System.out.printf(&quot;r2=\n%s\n&quot;, FormatArray.toString(r2, &quot;%.4e&quot;));</span>
 
        /* r2 * R0 = I
                R0 = inv(r2)
        */
<span class="nc" id="L1768">        double[][] rFirst = new double[3][3];</span>
<span class="nc" id="L1769">        rFirst[0] = Arrays.copyOf(r2[0], r2[0].length);</span>
<span class="nc" id="L1770">        rFirst[1] = Arrays.copyOf(r2[mImages], r2[mImages].length);</span>
<span class="nc" id="L1771">        rFirst[2] = MatrixUtil.crossProduct(rFirst[0], rFirst[1]);</span>
<span class="nc" id="L1772">        double[][] r0 = MatrixUtil.pseudoinverseFullColumnRank(rFirst);</span>
        
<span class="nc" id="L1774">        System.out.printf(&quot;r0= \n%s\n&quot;, FormatArray.toString(r0,&quot;%.4e&quot;));</span>
        
<span class="nc" id="L1776">        System.out.printf(&quot;chk==1: \n%s\n&quot;, FormatArray.toString(</span>
<span class="nc" id="L1777">            MatrixUtil.multiply(rFirst, r0),&quot;%.4e&quot;));</span>
        
        // with orthographic, can only recover rotation, not translation
        //(2*mImages)X3
        //apply to indiv rotation matrices
         
        // r has the i and j direction and k=i cross j.
        // create a stack of rotation matrices, one per image.
<span class="nc" id="L1785">        double[][] rotStack = MatrixUtil.zeros(3*mImages, 3);</span>
<span class="nc" id="L1786">        double[][] r3 = new double[2*mImages][];//(2*mImages)X3</span>
<span class="nc" id="L1787">        double[][] rTmp = new double[3][];</span>
        //r2 size is (2*mImages)X3
<span class="nc bnc" id="L1789" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L1790">            rTmp[0] = Arrays.copyOf(r2[i], r2[i].length);</span>
<span class="nc" id="L1791">            rTmp[1] = Arrays.copyOf(r2[mImages + i], r2[mImages + i].length);</span>
<span class="nc" id="L1792">            rTmp[2] = MatrixUtil.crossProduct(rTmp[0], rTmp[1]);</span>
<span class="nc" id="L1793">            rTmp = MatrixUtil.multiply(rTmp, r0);</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L1795">                rotStack[i*3 + j] = rTmp[j]; </span>
            }
<span class="nc" id="L1797">            r3[i] = rTmp[0];</span>
<span class="nc" id="L1798">            r3[i + mImages] = rTmp[1];</span>
        }
        
<span class="nc" id="L1801">        double[][] shape = MatrixUtil.multiply(rFirst, s2);</span>
        
<span class="nc" id="L1803">        System.out.printf(&quot;**r3=\n%s\n&quot;, FormatArray.toString(r3, </span>
            &quot;%.4e&quot;));
<span class="nc" id="L1805">        System.out.printf(&quot;**rot stack=\n%s\n&quot;, FormatArray.toString(rotStack, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1808">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(shape, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1811">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        
        //assert eqn (3.7) of Tomasi &amp; Kanade:
        // original measurement matrix 
        //    W = R*X + t*(e_p)^T 
        //        where t = the vector of centroids a_0, a_1,...a_(F-1),b_0,b_1,...b_(F-1)
        //         and e_P^T is a vector of P 1's.
<span class="nc" id="L1819">        double[] ep = new double[nFeatures];</span>
<span class="nc" id="L1820">        Arrays.fill(ep, 1);</span>
<span class="nc" id="L1821">        double[][] tep = MatrixUtil.outerProduct(t, ep);</span>
<span class="nc" id="L1822">        System.out.printf(&quot;W = R*X + t*(e_p)^T=\n%s\n&quot;, </span>
<span class="nc" id="L1823">            FormatArray.toString(MatrixUtil.pointwiseAdd(</span>
<span class="nc" id="L1824">                MatrixUtil.multiply(r3, shape), tep), </span>
            &quot;%.4e&quot;));
<span class="nc" id="L1826">        System.out.printf(&quot;orig W = \n%s\n&quot;, FormatArray.toString(w, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1829">        OrthographicProjectionResults results = new OrthographicProjectionResults();</span>
<span class="nc" id="L1830">        results.XW = shape;</span>
<span class="nc" id="L1831">        results.rotationMatrices = rotStack;</span>
                
<span class="nc" id="L1833">        return results;</span>
    }
    
    /**
     * NOT READY FOR USE.
     * a look at enforcing orthonormal rotation
     * 
     * @param x
     * @param mImages
     * @return
     * @throws NotConvergedException 
     */
    static OrthographicProjectionResults _DoNotUseThisCalculateAffineReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                                
<span class="nc bnc" id="L1848" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1849">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L1851" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1852">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L1854">        int nFeatures = x[0].length / mImages;</span>

        //TODO: check this
        //2mn &gt;= 8m + 3n – 12
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1859">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        // Tomasi &amp; Kanade 1992: An image stream can be represented by the
        //  2*F X P measurment matrix W of image coordinates of P points
        // tracked through F frames.
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size is mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size is mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create matrix WC = W - t
        
        // row[0] = image_0_x[0], image_0_x[1], image_0_x[2], ...
        // row[1] = image_1_x[0], image_1_x[1], image_1_x[2], ...
        // ...
        // row[mImages+0] = image_0_y[0], image_0_y[1], image_0_y[2], ...
        //NOTE: adding the Z axis=1
<span class="nc" id="L1882">        double[][] w = MatrixUtil.zeros(3*mImages, nFeatures);</span>
<span class="nc" id="L1883">        double[] t = new double[3*mImages];</span>
        int i, j;
        int m, n, rowX, rowY, rowZ, col;
<span class="nc bnc" id="L1886" title="All 2 branches missed.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="nc" id="L1887">            rowX = m;</span>
<span class="nc" id="L1888">            rowY = mImages + m;</span>
<span class="nc" id="L1889">            rowZ = 2*mImages + m;</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="nc" id="L1891">                col = nFeatures*m + n;</span>
<span class="nc" id="L1892">                w[rowX][n] = x[0][col];</span>
<span class="nc" id="L1893">                t[rowX] += x[0][col];</span>
<span class="nc" id="L1894">                w[rowY][n] = x[1][col];</span>
<span class="nc" id="L1895">                t[rowY] += x[1][col];</span>
<span class="nc" id="L1896">                w[rowZ][n] = 1;</span>
<span class="nc" id="L1897">                t[rowZ] += 1;</span>
            }
<span class="nc" id="L1899">            t[rowX] /= (double)nFeatures;</span>
<span class="nc" id="L1900">            t[rowY] /= (double)nFeatures;</span>
<span class="nc" id="L1901">            t[rowZ] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="nc" id="L1905">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="nc" id="L1908">                wC[i][n] -= t[i];</span>
            }
        }
        
        // see Fig 3.1 of Tomasi &amp; Kanade 1991 or Fig 2. of Belongie lecture notes
        
        // under orthography, this coordinate centered matrix has rank 3
        // and can be factored into the product of 2 matrices, R and S:
        // the camera rotation matrix R (size 2FX3) and 
        // the shape matrix S (size 3XP) which is shape in a coordinate system 
        // attached to the object centroid.
        //The two components of the camera translation along the image plane
        // are computed as averages of the rows of W
                
        // the registered measurement matrix is highly rank deficient
        // eqn (3.11)
<span class="nc" id="L1924">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        
        // Tomasi &amp; Kanade 1992,eqn (3.12): 1st 3 columns of U, upper 3X3 of S, and first 3 rows of V^T
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="nc" id="L1930">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="nc" id="L1931">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L1932">        s3[0][0] = svd.s[0];</span>
<span class="nc" id="L1933">        s3[1][1] = svd.s[1];</span>
<span class="nc" id="L1934">        s3[2][2] = svd.s[2];</span>
<span class="nc" id="L1935">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="nc" id="L1936">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="nc" id="L1937">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="nc" id="L1938">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="nc" id="L1939">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="nc" id="L1946">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="nc" id="L1947">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
        
        //Tamasi &amp; Kanade
        // (2*mImages)X3
<span class="nc" id="L1951">        double[][] rC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="nc" id="L1953">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="nc" id="L1955">        System.out.printf(&quot;rC=\n%s\n&quot;, FormatArray.toString(rC, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L1957">        System.out.printf(&quot;w=\n%s\n&quot;, FormatArray.toString(w, &quot;%.4e&quot;));</span>
<span class="nc" id="L1958">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
<span class="nc" id="L1959">        System.out.printf(&quot;rC*sC=\n%s\n&quot;, FormatArray.toString(</span>
<span class="nc" id="L1960">            MatrixUtil.multiply(rC, sC), </span>
            &quot;%.4e&quot;));
        
        // wC = rC * sC  
        //rC and sC are linear translations of the true rotation matrix R and
        //  the true shape matrix S, respectively.
        // Morita and Kanade: the decomposition is not completely unique.  
        //     it's unique only up to an affine transformation
        
        /*
        NLK: the rotation matrices aren't orthormal, so one needs to apply a linear
        transformation to rC that makes it orthonormal while applying the
        inverse transformation to sC to maintain the value of wC.
        
        wC = rC * sC

        let rC' be a single rotation matrix formed from the x-row of a frame in rC,
            the y-row of the same frame in rC, and the cross product of the x and y rows.
        rCO is obtained from SVD(rC').U*(SVD(rC').VT)^T)

        let R be the orthogonal rCO matrices reformatted into the x, y row format of rC
        
        since wC = R * Z * z^-1 * sC
              wC = R * Z^-1 * sC
              pseudoInv(R)*wC = pseudoInv(R)*R * Z^-1 * sC
              pseudoInv(R)*wC * pseudoInv(sC) = Z^-1 if inv(R)*R=I
               
              then can use Z^-1 to transform sC into s
        
        (3) Can continue with the rest of the Tomasi &amp; Kanade and Morita &amp; Kanade
            algorithm, eqn (3.15) below...
        */
        
        //sC is 3XnFeatures
        
        double[][] invR;
        
<span class="nc" id="L1997">        double[][] rot = new double[3*mImages][3];</span>
<span class="nc" id="L1998">        double[][] r3 = new double[2*mImages][3];</span>
<span class="nc" id="L1999">        double[][] shape = new double[3*mImages][nFeatures];</span>
        
        // 3X3
<span class="nc" id="L2002">        double[][] rCP = new double[3][];</span>
        double[] tmp;
        //3X3
        double[][] rCO;
        SVDProducts svdRC;
        double[][] si;
<span class="nc" id="L2008">        double[][] wCij = new double[3][];//3XnFeatures</span>
<span class="nc bnc" id="L2009" title="All 2 branches missed.">        for (int ii = 0; ii &lt; mImages; ++ii) {</span>
<span class="nc" id="L2010">            rCP[0] = rC[ii];</span>
<span class="nc" id="L2011">            rCP[1] = rC[ii + mImages];</span>
<span class="nc" id="L2012">            rCP[2] = rC[ii + 2*mImages];</span>
<span class="nc" id="L2013">            tmp = MatrixUtil.crossProduct(rCP[0], rCP[1]);</span>
<span class="nc" id="L2014">            System.out.printf(&quot;compare %s to %s\n&quot;, </span>
<span class="nc" id="L2015">                FormatArray.toString(rCP[2], &quot;%.3e&quot;), FormatArray.toString(tmp, &quot;%.3e&quot;));</span>
    
<span class="nc" id="L2017">            System.out.printf(&quot;rC_%d=\n%s\n&quot;, ii, FormatArray.toString(rCP, &quot;%.4e&quot;));</span>
<span class="nc" id="L2018">            double detR = MatrixUtil.determinant(rCP);</span>
<span class="nc" id="L2019">            System.out.printf(&quot;det(rC_%d)=%.4e\n&quot;, ii, detR);</span>
            
<span class="nc" id="L2021">            svdRC = MatrixUtil.performSVD(rCP);</span>
<span class="nc" id="L2022">            rCO = MatrixUtil.multiply(svdRC.u, MatrixUtil.transpose(svdRC.vT));</span>
<span class="nc" id="L2023">            System.out.printf(&quot;r_uvtt=\n%s\n&quot;, FormatArray.toString(rCO, &quot;%.4e&quot;));</span>
<span class="nc" id="L2024">            detR = MatrixUtil.determinant(rCO);</span>
<span class="nc" id="L2025">            System.out.printf(&quot;det(r_uvtt_%d)=%.4e\n&quot;, ii, detR);</span>
           
<span class="nc" id="L2027">            System.out.printf(&quot;rC_%d * (rC_%d)^T=\n%s\n&quot;, ii, ii,</span>
<span class="nc" id="L2028">                FormatArray.toString(MatrixUtil.multiply(rCP, MatrixUtil.transpose(rCP)), &quot;%.4e&quot;));</span>
            
<span class="nc" id="L2030">            System.out.printf(&quot;r_uvtt_%d * (r_uvtt_%d)^T=\n%s\n&quot;, ii, ii,</span>
<span class="nc" id="L2031">                FormatArray.toString(MatrixUtil.multiply(rCO, MatrixUtil.transpose(rCO)), &quot;%.4e&quot;));</span>
            
<span class="nc" id="L2033">            System.out.flush();</span>
           
<span class="nc bnc" id="L2035" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2036">                rot[ii*3 + j] = rCO[j];</span>
            }
<span class="nc" id="L2038">            r3[ii] = Arrays.copyOf(rCO[0], rCO[0].length);</span>
<span class="nc" id="L2039">            r3[ii + mImages] = Arrays.copyOf(rCO[1], rCO[1].length);</span>
            
            /*
            block[0] = rCP[0] times sC = 1XnFeatures
            block[1] = rCP[1] times sC
            block[2] = rCp[2] times sC 
            
            rC*z * (z^-1)*sC = 3X3*3X3*3XnFeatures = 3XnFeatures = block of wC
            rOrth * (z^-1)*sC= wC_i_j
            (z^-1)*sC= inv(rOth)*wC_i_j
            store in blocks of trans
            */     
<span class="nc" id="L2051">            invR = MatrixUtil.pseudoinverseFullColumnRank(rCO);</span>
            
            // 3XnFeatures
<span class="nc" id="L2054">            wCij[0] = wC[ii];</span>
<span class="nc" id="L2055">            wCij[1] = wC[ii + mImages];</span>
<span class="nc" id="L2056">            wCij[2] = wC[ii + 2*mImages];</span>
            
            //3XnFeatures
<span class="nc" id="L2059">            si = MatrixUtil.multiply(invR, wCij);</span>
            
            //double[][] trans = new double[3*mImages][nFeatures];
<span class="nc bnc" id="L2062" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2063">                shape[ii*3 + j] = si[j];</span>
            }
            
            // TODO: need to consider the rotation and translation origins now
<span class="nc" id="L2067">            System.out.printf(&quot;for image%d have shape=\n%s\n&quot;, ii, FormatArray.toString(si, &quot;%.4e&quot;));</span>
        }
        
<span class="nc" id="L2070">        System.out.printf(&quot;rot stack=\n%s\n&quot;, FormatArray.toString(rot, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L2073">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(shape, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L2076">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        // shape size is
        //r3 = new double[2*mImages][3];
<span class="nc" id="L2080">        double[][] _si = new double[3][nFeatures];</span>
<span class="nc" id="L2081">        double[][] _ri = new double[2][3];</span>
        double[][] _rs;
<span class="nc bnc" id="L2083" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2084">            _si[0] = shape[i*mImages + i];//3XnFeatures</span>
<span class="nc" id="L2085">            _si[1] = shape[i*mImages + i + 1];</span>
<span class="nc" id="L2086">            _si[2] = shape[i*mImages + i + 2]; </span>
<span class="nc" id="L2087">            _ri[0] = r3[i*mImages + 0];//2X3</span>
<span class="nc" id="L2088">            _ri[1] = r3[i*mImages + 1];</span>
<span class="nc" id="L2089">            _rs = MatrixUtil.multiply(_ri, _si);//2XnFeatures</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">            for (int k = 0; k &lt; nFeatures; ++k) {</span>
<span class="nc" id="L2091">                _rs[0][k] += t[i*mImages + i];</span>
<span class="nc" id="L2092">                _rs[1][k] += t[i*mImages + i + 1];</span>
            }
            
<span class="nc" id="L2095">            System.out.printf(&quot;W = R*X + t*(e_p)^T=\n%s\n&quot;, </span>
<span class="nc" id="L2096">                FormatArray.toString(_rs, &quot;%.4e&quot;));</span>
        }
<span class="nc" id="L2098">        System.out.printf(&quot;original W = \n%s\n&quot;, </span>
<span class="nc" id="L2099">            FormatArray.toString(w, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L2101">        OrthographicProjectionResults results = new OrthographicProjectionResults();</span>
<span class="nc" id="L2102">        results.XW = shape;</span>
<span class="nc" id="L2103">        results.rotationMatrices = rot;</span>
                
<span class="nc" id="L2105">        return results;</span>
           
    }
    
    /*
    TODO: proof read and write test for this.
    from Szeliski 2010 and Poelman &amp; Kanade 1992 (year?  a few published translations with different years):
    Para-perspective provides a more accurate projection model than scaled 
    orthography, without incurring the added complexity of per-pixel perspective 
    division, which invalidates traditional factoriza- tion methods 
    (Poelman and Kanade 1997).
    
    Scaled orthographic projection, sometimes referred to as &quot;weak perspective&quot;, 
    accounts for the scaling effect of an object as it moves towards and away 
    from the camera. Paraperspective projection, first introduced by Ohta in 
    [4] and named by Aloimonos in [1], accounts for the scaling effect as well 
    as the different angle from which an object is viewed as it moves in a 
    direction parallel to the image plane.

    */
          
    /**
     * NOT READY FOR USE.
     * for the case where the cameras are viewing small, distant scenes,
     * recover the 3-D coordinates in WCS and the projection matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * assumes a para-perspective camera model.
     *
     * Input set of P feature point coordinates (x_f_p,y_f_p) , for each of 
     * the F frames of the image sequence. From this information, our goal is 
     * to recover the estimated shape of the object, given by the position 
     * s_P, of every point, and the estimated motion of the
     camera, given by iHat_f, jHat_f, kHat_f for each frame in the sequence. 
     Rather than recover iHat_f in world coordinates, we generally recover 
     the three.eparate components tHat_f dot iHat_f, tHat_f dot jHat_f,
     tHat_f dot kHat_f.
 
      
     &lt;pre&gt;
      references:
      
     Poelman &amp; Kanade 1997 (1994), &quot;A Paraperspective Factorization Method for Shape 
     and Motion Recovery&quot; 
     
     Description from Poelman &amp; Kanade:
      
     Each feature point p that we track corresponds to a single world point, 
      located at position s. in some fixed world coordinate system.

      Each image f was taken at some specific camera orientation, which we 
      describe by the orthonormal unit vectors i_f, j_f and k_f 
      where kf_ points along the camera's line of sight, 
      i_f corresponds to the camera image plane's x-axis, 
      and j_f corresponds to the camera image's y-axis.
      
      t_f is a vector pointing from the origin of the fixed world coordinate system
      to the camera's focal plane.  it's the position of the camera in each fram f.
      
     &lt;/pre&gt;
     * 
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ParaperspectiveProjectionResults calculateParaperspectiveReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                        
<span class="nc bnc" id="L2179" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L2180">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L2182" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L2183">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L2185">        int nFeatures = x[0].length / mImages;</span>

        //TODO: check this
        ///2mn &gt;= 8m + 3n – 12
<span class="nc bnc" id="L2189" title="All 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L2190">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        //NOTE: assumes the camera's focal length = 1
        
        // create measurement matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size os mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size os mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create registered measurement matrix WC = W - t
<span class="nc" id="L2205">        double[][] w = MatrixUtil.zeros(2*mImages, nFeatures);</span>
        // t points to the camera's focal point
<span class="nc" id="L2207">        double[] t = new double[2*mImages];</span>
        int i, j;
        int m, n, rowU, rowV, col;
<span class="nc bnc" id="L2210" title="All 2 branches missed.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="nc" id="L2211">            rowU = m;</span>
<span class="nc" id="L2212">            rowV = mImages + m;</span>
<span class="nc bnc" id="L2213" title="All 2 branches missed.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="nc" id="L2214">                col = nFeatures*m + n;</span>
<span class="nc" id="L2215">                w[rowU][n] = x[0][col];</span>
<span class="nc" id="L2216">                t[rowU] += x[0][col];</span>
<span class="nc" id="L2217">                w[rowV][n] = x[1][col];</span>
<span class="nc" id="L2218">                t[rowV] += x[1][col];</span>
            }
<span class="nc" id="L2220">            t[rowU] /= (double)nFeatures;</span>
<span class="nc" id="L2221">            t[rowV] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="nc" id="L2225">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="nc" id="L2228">                wC[i][n] -= t[i];</span>
            }
        }
        
<span class="nc" id="L2232">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="nc" id="L2236">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="nc" id="L2237">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L2238">        s3[0][0] = svd.s[0];</span>
<span class="nc" id="L2239">        s3[1][1] = svd.s[1];</span>
<span class="nc" id="L2240">        s3[2][2] = svd.s[2];</span>
<span class="nc" id="L2241">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="nc" id="L2242">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="nc" id="L2243">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="nc" id="L2244">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="nc" id="L2245">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="nc" id="L2252">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="nc" id="L2253">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
                
        // (2*mImages)X3
<span class="nc" id="L2256">        double[][] mC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="nc" id="L2258">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="nc" id="L2260">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
        
        // assert that wC is the same as wC2
<span class="nc" id="L2263">        System.out.printf(&quot;mC*sC=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(mC, sC), </span>
            &quot;%.4e&quot;));
        
        /*
        ------------------------------------------------------------------
        Paraperspective Normalization
        ------------------------------------------------------------------
        
         3 constraints:

         eqn(15) of paper:
                 |m_f|^2/(1+x_f^2) - |n_f|^2/(1+y_f^2) = 0
         eqn(17) of paper:
                 m_f dot n_f = x_f * y*f * 0.5 * ( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2) )
         eqn(18) of paper:
                 |m_0|=1

         those are 2*F + 1 equations as metric constraints

         from the SVD of the registered measurement matrix, there is M and S
         `M is size 2*F X 3
         `M = vectorized( m_0, m_1, ... m_{F-1}, n_0, n_1, ... n_{F-1},

         let M = `M*A where A is a 3X3 matrix, and as before, Q = symmetric matrix, but Q=A^T*A.

         Equations (15), (17), and (18) give us 2F+ 1 equations,
         We compute the 3 X 3 matrix A such that M = `M*A best satisfies these metric constraints
         in the least sum-of-squares error sense.

         This is a simple problem because the constraints are linear in the 6 unique elements
         of the symmetric 3 x 3 matrix Q = A^TA.
        
         Thus we compute Q by solving the overconstrained linear system of 2F + 1 equations
         in 6 variables defined by the metric constraints, ...

             [ q1  q2  q3 ]
         Q = [ q2  q4  q5 ]
             [ q3  q5  q6 ]

         m_f = `m_f * Q = [`mf0  `mf1  `mf2] * [ q1  q2  q3 ]
                                               [ q2  q4  q5 ]
                                               [ q3  q5  q6 ]
                        = [ (q1*`mf0 + q2*`mf1 + q3*`mf2 )  (q2*`mf0 + q4*`mf1 + q5*`mf2 )  (q3*`mf0 + q5*`mf1 + q6*`mf2 ) ]

         |vector| is the magnitude of a vector = square root of the sum of squares of its components.
        
         as an aside, in case can simplify any future steps with this:
         and Q*Q = q1*q1 + q2*q2 + q3*q3   q1*q2 + q2*q4 + q3*q5   q1*q3 + q2*q5 + q3*q6
                   q1*q2 + q2*q4 + q3*q5   q2*q2 + q4*q4 + q5*q5   q2*q3 + q4*q5 + q5*q6
                   q1*q3 + q2*q5 + q3*q6   q2*q3 + q4*q5 + q5*q6   q3*q3 + q5*q5 + q6*q6
                 = Q_col0 dot Q_col0   Q_col0 dot Q_col1  Q_col0 dot Q_col2
                   Q_col0 dot Q_col1   Q_col1 dot Q_col1  Q_col1 dot Q_col2
                   Q_col0 dot Q_col2   Q_col1 dot Q_col2  Q_col2 dot Q_col2

        NOTE: below are the expanded details of the multiplication.
        The result can be rewritten using other notation:
        since need the dot product of vector `m_f*Q with itself, can use the inner product
        of the vector multiplied by its transpose:
            |m_f|^2 = `m_f*Q*Q^T*`m_f^T where m_f is a 1X3 vector and Q is a 3X3 symmetric matrix
                    = `m_f*Q^2*`m_f^T
                    = [`m_f*Q^2[:][0] `m_f*Q^2[:][1] `m_f*Q^2[:][2]] * `m_f^T
                    = ['m_f[0]*`m_f*Q^2[:][0] + 'm_f[1]*`m_f*Q^2[:][1] + 'm_f[2]*`m_f*Q^2[:][2]]


         expand |m_f|^2/(1+x_f^2) :
             (1/(1+x_f^2)) * [ (q1*`mf0 + q2*`mf1 + q3*`mf2 )^2 + (q2*`mf0 + q4*`mf1 + q5*`mf2 )^2 + (q3*`mf0 + q5*`mf1 + q6*`mf2 )^2 ]
             (1/(1+x_f^2)) * [ (q1*`mf0*q1*`mf0 + q1*`mf0*q2*`mf1 + q1*`mf0*q3*`mf2)
                              + (q2*`mf1*q1*`mf0 + q2*`mf1*q2*`mf1 + q2*`mf1*q3*`mf2)
                              + (q3*`mf2*q1*`mf0 + q3*`mf2*q2*`mf1 + q3*`mf2*q3*`mf2)
                              + (q2*`mf0*q2*`mf0 + q2*`mf0*q4*`mf1 + q2*`mf0*q5*`mf2 )
                              + (q4*`mf1*q2*`mf0 + q4*`mf1*q4*`mf1 + q4*`mf1*q5*`mf2 )
                              + (q5*`mf2*q2*`mf0 + q5*`mf2*q4*`mf1 + q5*`mf2*q5*`mf2 )
                              + (q3*`mf0*q3*`mf0 + q3*`mf0*q5*`mf1 + q3*`mf0*q6*`mf2 )
                              + (q5*`mf1*q3*`mf0 + q5*`mf1*q5*`mf1 + q5*`mf1*q6*`mf2 )
                              + (q6*`mf2*q3*`mf0 + q6*`mf2*q5*`mf1 + q6*`mf2*q6*`mf2 ) ]

             (1/(1+x_f^2))  * [ (q1*`mf0*q1*`mf0 + q1*`mf0*q2*`mf1 + q1*`mf0*q3*`mf2)
                              + (q1*`mf0*q2*`mf1 + q2*`mf1*q2*`mf1 + q2*`mf1*q3*`mf2)
                              + (q1*`mf0*q3*`mf2 + q2*`mf1*q3*`mf2 + q3*`mf2*q3*`mf2)
                              + (q2*`mf0*q2*`mf0 + q2*`mf0*q4*`mf1 + q2*`mf0*q5*`mf2 )
                              + (q2*`mf0*q4*`mf1 + q4*`mf1*q4*`mf1 + q4*`mf1*q5*`mf2 )
                              + (q2*`mf0*q5*`mf2 + q4*`mf1*q5*`mf2 + q5*`mf2*q5*`mf2 )
                              + (q3*`mf0*q3*`mf0 + q3*`mf0*q5*`mf1 + q3*`mf0*q6*`mf2 )
                              + (q3*`mf0*q5*`mf1 + q5*`mf1*q5*`mf1 + q5*`mf1*q6*`mf2 )
                              + (q3*`mf0*q6*`mf2 + q6*`mf2*q5*`mf1 + q6*`mf2*q6*`mf2 ) ]
        
                          (1/(1+x_f^2))  * [ q1*q1*`mf0*`mf0 + q1*q2*`mf0*`mf1 + q1*q3*`mf0*`mf2
                              + q1*q2*`mf0*`mf1 + q2*q2*`mf1*`mf1 + q2*q3*`mf1*`mf2
                              + q1*q3*`mf0*`mf2 + q2*q3*`mf1*`mf2 + q3*q3*`mf2*`mf2
                              + q2*q2*`mf0*`mf0 + q2*q4*`mf0*`mf1 + q2*q5*`mf0*`mf2
                              + q2*q4*`mf0*`mf1 + q4*q4*`mf1*`mf1 + q4*q5*`mf1*`mf2
                              + q2*q5*`mf0*`mf2 + q4*q5*`mf1*`mf2 + q5*q5*`mf2*`mf2
                              + q3*q3*`mf0*`mf0 + q3*q5*`mf0*`mf1 + q3*q6*`mf0*`mf2
                              + q3*q5*`mf0*`mf1 + q5*q5*`mf1*`mf1 + q5*q6*`mf1*`mf2
                              + q3*q6*`mf0*`mf2 + q6*q5*`mf2*`mf1 + q6*q6*`mf2*`mf2 ]

             (1/(1+x_f^2))  * [ q1*q1*`mf0*`mf0 + q2*q2*`mf0*`mf0 + q3*q3*`mf0*`mf0
                              + q1*q2*`mf0*`mf1 + q2*q4*`mf0*`mf1 + q3*q5*`mf0*`mf1   &lt;== 1st 3 lines of addition are:
                              + q1*q3*`mf0*`mf2 + q2*q5*`mf0*`mf2 + q3*q6*`mf0*`mf2       [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ] * [Q^2_col0]

                              + q1*q2*`mf0*`mf1 + q2*q4*`mf0*`mf1 + q3*q5*`mf0*`mf1   &lt;== 2nd 3 lines of addition are:
                              + q2*q2*`mf1*`mf1 + q4*q4*`mf1*`mf1 + q5*q5*`mf1*`mf1       [ `mf0*`mf1  `mf1*`mf1  `mf1*`mf2 ] * [Q^2_col1]
                              + q2*q3*`mf1*`mf2 + q4*q5*`mf1*`mf2 + q5*q6*`mf1*`mf2

                              + q1*q3*`mf0*`mf2 + q2*q5*`mf0*`mf2 + q3*q6*`mf0*`mf2   &lt;== 3rd 3 lines of addition are:
                              + q2*q3*`mf1*`mf2 + q4*q5*`mf1*`mf2 + q5*q6*`mf1*`mf2       [ `mf0*`mf2  `mf1*`mf2  `mf2*`mf2 ] * [Q^2_col2]
                              + q3*q3*`mf2*`mf2 + q5*q5*`mf2*`mf2 + q6*q6*`mf2*`mf2 ]

             let z0 = [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ]
                 z1 = [ `mf0*`mf1  `mf1*`mf1  `mf1*`mf2 ]
                 z2 = [ `mf0*`mf2  `mf1*`mf2  `mf2*`mf2 ]
             (1/(1+x_f^2))  * [ z0 z1 z2] * [Q^2_col0]
                                            [Q^2_col1]
                                            [Q^2_col2]

         reminder of Q*Q:
                 = q1*q1 + q2*q2 + q3*q3   q1*q2 + q2*q4 + q3*q5   q1*q3 + q2*q5 + q3*q6
                   q1*q2 + q2*q4 + q3*q5   q2*q2 + q4*q4 + q5*q5   q2*q3 + q4*q5 + q5*q6
                   q1*q3 + q2*q5 + q3*q6   q2*q3 + q4*q5 + q5*q6   q3*q3 + q5*q5 + q6*q6
                 = Q_col0 dot Q_col0   Q_col0 dot Q_col1  Q_col0 dot Q_col2
                   Q_col0 dot Q_col1   Q_col1 dot Q_col1  Q_col1 dot Q_col2
                   Q_col0 dot Q_col2   Q_col1 dot Q_col2  Q_col2 dot Q_col2
            
             let z0 = [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ]
                 z1 = [ `mf1*`mf0  `mf1*`mf1  `mf1*`mf2 ]
                 z2 = [ `mf2*`mf0  `mf2*`mf1  `mf2*`mf2 ]
             let y0 = [ `nf0*`nf0  `nf0*`nf1  `nf0*`nf2 ]
                 y1 = [ `nf1*`nf0  `nf1*`nf1  `nf1*`nf2 ]
                 y2 = [ `nf2*`nf0  `nf2*`nf1  `nf2*`nf2 ]
             let w0 = [ `mf0*`nf0  `mf0*`nf1  `mf0*`nf2 ]
                 w1 = [ `mf1*`nf0  `mf1*`nf1  `mf1*`nf2 ]
                 w2 = [ `mf2*`nf0  `mf2*`nf1  `mf2*`nf2 ]
             let c2 = (x_f*y_f*0.5)

        factoring the constraints to separate Q unknowns from m and n knowns:
         eqn(15) of paper:
                 |m_f|^2/(1+x_f^2) - |n_f|^2/(1+y_f^2) = 0

             (1/(1+x_f^2)) * [ z0 z1 z2] * [Q^2_col0]  -  (1/(1+y_f^2)) * [ y0 y1 y2] * [Q^2_col0] = 0
                                           [Q^2_col1]                                   [Q^2_col1]
                                           [Q^2_col2]                                   [Q^2_col2]

             [ (z0/(1+x_f^2) -y0/(1+y_f^2))  (z1/(1+x_f^2) -y1/(1+y_f^2))  (z2/(1+x_f^2) -y2/(1+y_f^2)) ] * [Q^2_col0] = 0
                                                                                                            [Q^2_col1]
                                                                                                            [Q^2_col2]

         eqn(17) of paper:
                 m_f dot n_f = x_f*y_f*0.5 * ( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2) )

                 [ w0 w1 w2] * [Q^2_col0] - c2 * [ z0 z1 z2] * [Q^2_col0]  -  c2 * [ y0 y1 y2] * [Q^2_col0] = 0
                               [Q^2_col1]                      [Q^2_col1]                        [Q^2_col1]
                               [Q^2_col2]                      [Q^2_col2]                        [Q^2_col2]

                 [ (w0 -z0*c2 -y0*c2)  (w1 -z1*c2 -y1*c2)  (w2 -z2*c2 -y2*c2)] * [Q^2_col0] = 0
                                                                                 [Q^2_col1]
                                                                                 [Q^2_col2]
         eqn(18) of paper:
                 |m_0|=1

                 square to use the same factorization by Q^2?

             let v0 = [ `m_0[0]*`mf0  `m_0[0]*`m_0[1]  `m_0[0]*`m_0[2] ]
                 v1 = [ `m_0[0]*`mf1  `m_0[1]*`m_0[1]  `m_0[1]*`m_0[2] ]
                 v2 = [ `m_0[0]*`mf2  `m_0[1]*`m_0[2]  `m_0[2]*`m_0[2] ]
             |m_0|^2 = [ v0 v1 v2] * [Q^2_col0] = 1
                                     [Q^2_col1]
                                     [Q^2_col2]
        */
        
<span class="nc" id="L2432">        double[][] g = new double[2*mImages + 1][9];</span>
<span class="nc" id="L2433">        double[] z0 = new double[3];</span>
<span class="nc" id="L2434">        double[] z1 = new double[3];</span>
<span class="nc" id="L2435">        double[] z2 = new double[3];</span>
<span class="nc" id="L2436">        double[] y0 = new double[3];</span>
<span class="nc" id="L2437">        double[] y1 = new double[3];</span>
<span class="nc" id="L2438">        double[] y2 = new double[3];</span>
<span class="nc" id="L2439">        double[] w0 = new double[3];</span>
<span class="nc" id="L2440">        double[] w1 = new double[3];</span>
<span class="nc" id="L2441">        double[] w2 = new double[3];</span>
        double c2, xf, yf, divXf, divYf;
        
<span class="nc bnc" id="L2444" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2445">            xf = t[i];</span>
<span class="nc" id="L2446">            yf = t[mImages + i];</span>
            
<span class="nc" id="L2448">            z0[0] = mC[i][0] * mC[i][0]; </span>
<span class="nc" id="L2449">            z0[1] = mC[i][0] * mC[i][1];</span>
<span class="nc" id="L2450">            z0[2] = mC[i][0] * mC[i][2];</span>
            
<span class="nc" id="L2452">            z1[0] = mC[i][1] * mC[i][0]; </span>
<span class="nc" id="L2453">            z1[1] = mC[i][1] * mC[i][1];</span>
<span class="nc" id="L2454">            z1[2] = mC[i][1] * mC[i][2];</span>
            
<span class="nc" id="L2456">            z2[0] = mC[i][2] * mC[i][0]; </span>
<span class="nc" id="L2457">            z2[1] = mC[i][2] * mC[i][1];</span>
<span class="nc" id="L2458">            z2[2] = mC[i][2] * mC[i][2];</span>
            
<span class="nc" id="L2460">            y0[0] = mC[mImages + i][0] * mC[mImages + i][0];</span>
<span class="nc" id="L2461">            y0[1] = mC[mImages + i][0] * mC[mImages + i][1];</span>
<span class="nc" id="L2462">            y0[2] = mC[mImages + i][0] * mC[mImages + i][2];</span>
            
<span class="nc" id="L2464">            y1[0] = mC[mImages + i][1] * mC[mImages + i][0];</span>
<span class="nc" id="L2465">            y1[1] = mC[mImages + i][1] * mC[mImages + i][1];</span>
<span class="nc" id="L2466">            y1[2] = mC[mImages + i][1] * mC[mImages + i][2];</span>
            
<span class="nc" id="L2468">            y2[0] = mC[mImages + i][2] * mC[mImages + i][0];</span>
<span class="nc" id="L2469">            y2[1] = mC[mImages + i][2] * mC[mImages + i][1];</span>
<span class="nc" id="L2470">            y2[2] = mC[mImages + i][2] * mC[mImages + i][2];</span>
            
<span class="nc" id="L2472">            w0[0] = mC[i][0] * mC[mImages + i][0];</span>
<span class="nc" id="L2473">            w0[1] = mC[i][0] * mC[mImages + i][1];</span>
<span class="nc" id="L2474">            w0[2] = mC[i][0] * mC[mImages + i][2];</span>
            
<span class="nc" id="L2476">            w1[0] = mC[i][1] * mC[mImages + i][0];</span>
<span class="nc" id="L2477">            w1[1] = mC[i][1] * mC[mImages + i][1];</span>
<span class="nc" id="L2478">            w1[2] = mC[i][1] * mC[mImages + i][2];</span>
            
<span class="nc" id="L2480">            w2[0] = mC[i][2] * mC[mImages + i][0];</span>
<span class="nc" id="L2481">            w2[1] = mC[i][2] * mC[mImages + i][1];</span>
<span class="nc" id="L2482">            w2[2] = mC[i][2] * mC[mImages + i][2];</span>
            
<span class="nc" id="L2484">            c2 = 0.5*xf*yf;</span>
            
<span class="nc" id="L2486">            divXf = 1./(1.+xf*xf);</span>
<span class="nc" id="L2487">            divYf = 1./(1.+yf*yf);</span>
            
            // length 9
            // eqn(15) of paper is the 1st mImages rows of g
            //   [ (z0/(1+x_f^2) -y0/(1+y_f^2))  (z1/(1+x_f^2) -y1/(1+y_f^2))  (z2/(1+x_f^2) -y2/(1+y_f^2)) ] ... = 0
<span class="nc" id="L2492">            g[i] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="nc bnc" id="L2493" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) { </span>
<span class="nc" id="L2494">                g[i][j] = (z0[j]*divXf - y0[j]*divYf);                </span>
<span class="nc" id="L2495">                g[i][3+j] = (z1[j]*divXf - y1[j]*divYf);</span>
<span class="nc" id="L2496">                g[i][6+j] = (z2[j]*divXf - y2[j]*divYf);                </span>
            }
            
            //eqn(17) of paper is the 2nd mImages rows of g
            //  [ (w0 -z0*c2 -y0*c2)  (w1 -z1*c2 -y1*c2)  (w2 -z2*c2 -y2*c2)] ... = 0
<span class="nc" id="L2501">            g[mImages + i] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) { </span>
<span class="nc" id="L2503">                g[mImages + i][j] = (w0[j] - z0[j]*c2 - y0[j]*c2);                </span>
<span class="nc" id="L2504">                g[mImages + i][3+j] = (w1[j] - z1[j]*c2 - y1[j]*c2);</span>
<span class="nc" id="L2505">                g[mImages + i][6+j] = (w2[j] - z2[j]*c2 - y2[j]*c2);               </span>
            }
        }
        
        //let v0 = [ `m_0[0]*`mf0  `m_0[0]*`m_0[1]  `m_0[0]*`m_0[2] ]
        //    v1 = [ `m_0[0]*`mf1  `m_0[1]*`m_0[1]  `m_0[1]*`m_0[2] ]
        //    v2 = [ `m_0[0]*`mf2  `m_0[1]*`m_0[2]  `m_0[2]*`m_0[2] ]
        // length 9
        // [ v0 v1 v2 ] = 1
<span class="nc" id="L2514">        i = 0;</span>
<span class="nc" id="L2515">        double[] v0 = new double[] {</span>
           mC[i][0] * mC[i][0], mC[i][0] * mC[i][1], mC[i][0] * mC[i][2]};
<span class="nc" id="L2517">        double[] v1 = new double[] {</span>
            mC[i][1] * mC[i][0], mC[i][1] * mC[i][1], mC[i][1] * mC[i][2]};
<span class="nc" id="L2519">        double[] v2 = new double[] {</span>
            mC[i][2] * mC[i][0], mC[i][2] * mC[i][1], mC[i][2] * mC[i][2]};
<span class="nc" id="L2521">        g[2*mImages] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">        for (j = 0; j &lt; 3; ++j) { </span>
<span class="nc" id="L2523">            g[2*mImages][j] = v0[j];                </span>
<span class="nc" id="L2524">            g[2*mImages][3+j] = v1[j];</span>
<span class="nc" id="L2525">            g[2*mImages][6+j] = v2[j];               </span>
        }
        
<span class="nc" id="L2528">        double[] c = new double[2*mImages + 1];</span>
<span class="nc" id="L2529">        c[2*mImages] = 1;</span>
        
<span class="nc" id="L2531">        double[][] gInv = MatrixUtil.pseudoinverseFullColumnRank(g);</span>
<span class="nc" id="L2532">        double[] iVector = MatrixUtil.multiplyMatrixByColumnVector(gInv, c);</span>
<span class="nc bnc" id="L2533" title="All 2 branches missed.">        assert(iVector.length == 9);</span>
        
        // 3X3
<span class="nc" id="L2536">        double[][] ell = new double[3][3];</span>
<span class="nc" id="L2537">        ell[0] = new double[]{iVector[0], iVector[1], iVector[2]};</span>
<span class="nc" id="L2538">        ell[1] = new double[]{iVector[1], iVector[3], iVector[4]};</span>
<span class="nc" id="L2539">        ell[2] = new double[]{iVector[2], iVector[4], iVector[5]};</span>

        // Q can be determined :
        //   as the square root of ell,
        //   or with the Cholesky decomposition
        //   or with eigendecomposition

<span class="nc" id="L2546">        double eps = 1e-16;//1.e-11; eps close to zero within machine precision to perturb the matrix to smallest eigenvalue of eps</span>
<span class="nc" id="L2547">        double[][] lPSD = MatrixUtil.nearestPositiveSemidefiniteToASymmetric(ell, eps);</span>
<span class="nc" id="L2548">        EVD evd2 = EVD.factorize(new DenseMatrix(lPSD));</span>
<span class="nc" id="L2549">        double[] eig = evd2.getRealEigenvalues();</span>
<span class="nc" id="L2550">        System.out.printf(&quot;eig(L_PSD)=\n%s\n&quot;, FormatArray.toString(eig, &quot;%.4e&quot;));</span>
<span class="nc" id="L2551">        double[][] aMinusPSD = MatrixUtil.pointwiseSubtract(ell, lPSD);</span>
<span class="nc" id="L2552">        double dist1 = MatrixUtil.frobeniusNorm(aMinusPSD);</span>
        
<span class="nc" id="L2554">        boolean ipd = MatrixUtil.isPositiveDefinite(lPSD);</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">        assert(ipd);</span>
        
        //decompose Q = L * (sigma+) * L^T;  Q is size 3X3
<span class="nc" id="L2558">        double[][] q = LinearEquations.choleskyDecompositionViaMTJ(lPSD);</span>
        
        // (2*mImages)X3
<span class="nc" id="L2561">        double[][] _M = MatrixUtil.multiply(mC, q);</span>
        // 3XnFeatures
<span class="nc" id="L2563">        double[][] _S = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q), sC);</span>
        
<span class="nc" id="L2565">        System.out.printf(&quot;_M=\n%s\n&quot;, FormatArray.toString(_M, &quot;%.4e&quot;));</span>
        
        // assert that wC is the same as _M*_S
<span class="nc" id="L2568">        System.out.printf(&quot;_M*_S=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(_M, _S), </span>
            &quot;%.4e&quot;));
                
        /*
        --------------------------------
        Paraperspective Motion Recovery
        --------------------------------
        eqn(19) :
         `i_f = z_f*m_f + x_f*`k_f

         `j_f = z_f*n_f + y_f*`k_f


         Since the `i, `j, `k  produced must be orthonormal,
            they can be written as functions of only 3 rotational variables.
            We can then view the problem as, for each frame f,
              solving an overconstrained system of 6 equations
              (the expansion of (19) to each of its vector components)
              in 4 variables (the 3 rotational variables and zs).

              `i_f[0] = z_f * m_f[0] + x_f * `k_f[0]
              `i_f[1] = z_f * m_f[1] + x_f * `k_f[1]
              `i_f[2] = z_f * m_f[2] + x_f * `k_f[2]

              `j_f[0] = z_f * n_f[0] + y_f * `k_f[0]
              `j_f[1] = z_f * n_f[1] + y_f * `k_f[1]
              `j_f[2] = z_f * n_f[2] + y_f * `k_f[2]

          using the equalities of `k_f terms from eqn (19):
            `k_f[0]: (same for vector components [1] and [2]):

                (1/x_f)*(`i_f[0] - z_f * m_f[0]) = `k_f[0]

                (1/y_f)*(`j_f[0] - z_f * n_f[0]) = `k_f[0]

                (1/x_f)*(`i_f[0] - z_f * m_f[0]) = (1/y_f)*(`j_f[0] - z_f * n_f[0])
                `i_f[0] = z_f * m_f[0] + (x_f/y_f)*(`j_f[0] - z_f * n_f[0])
                        = `j_f[0]*(x_f/y_f) + z_f * m_f[0] - (x_f/y_f)*(z_f * n_f[0])
               generalized for each component::
                `i_f = `j_f*(x_f/y_f) + z_f*m_f - (x_f/y_f)*(z_f*n_f)
        
         rewriting `i_f, `j_f, and `k_f in terms of `j_f, m_f, n_f:
            `i_f = `j_f*(x_f/y_f) + z_f*m_f - (x_f/y_f)*(z_f*n_f)
            `j_f
            `k_f = `j_f*(1/y_f) - z_f*n_f*(1/y_f)

           dot product metrics:
            idoti: `i_f dot `i_f = 1
            jdotj: `j_f dot `j_f = 1
            idotj: `i_f dot `j_f = 0

            idoti: `i_f dot `i_f = 1:
                (`j_f dot `j_f)*(x_f/y_f)^2 + (m_f dot m_f)*(z_f)^2 - (n_f dot n_f)*(z_f)^2*(x_f/y_f)^2 = 1
                (1)*(x_f/y_f)^2 + (m_f dot m_f)*(z_f)^2 - (n_f dot n_f)*(z_f)^2*(x_f/y_f)^2 = 1
                (z_f)^2*((m_f dot m_f)-(n_f dot n_f)*(x_f/y_f)^2) + (x_f/y_f)^2 = 1
                (z_f)^2*((m_f[0]^2 + m_f[1]^2 + m_f[2]^2)-(n_f[0]^2 + n_f[1]^2 + n_f[2]^2)*(x_f/y_f)^2) + (x_f/y_f)^2 = 1
                (z_f)^2 = (1-(x_f/y_f)^2) / ((m_f[0]^2 + m_f[1]^2 + m_f[2]^2)-(n_f[0]^2 + n_f[1]^2 + n_f[2]^2)*(x_f/y_f)^2)
*          ====&gt; can solve for (z_f)^2 from this
           ==&gt;   Instead, using eqn (15) averages: 
                  zf^2 = (1/2)*( ((1+xf^2)/(mf*mf)) + ((1+yf^2)/(nf*nf)))

            jdotj:`j_f dot `j_f = 1:

            idotj:`i_f dot `j_f = 0:
                `j_f*(x_f/y_f) + z_f*m_f - (x_f/y_f)*(z_f*n_f) dot j_f = 0
                (`j_f dot `j_f)*(x_f/y_f) + (j_f dot m_f)*z_f - (j_f dot nf)*(z_f*x_f/y_f) = 0
                 (j_f dot m_f)*z_f - (j_f dot n_f)*(z_f*x_f/y_f) + (x_f/y_f) = 0
               factor this out for each component:
                (j_f[0]*m_f[0])*z_f - (j_f[0]*n_f[0])*(z_f*x_f/y_f) = -(x_f/y_f)
                j_f[0]*(m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f)) = -(x_f/y_f)
                j_f[0] = -(x_f/y_f)/ (m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f))
*            ===&gt; can solve for j_f from this

            rewrite `i_f from eqn (19) using the equalities of `k_f terms from above:
               `i_f[0] = `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f)
               `i_f[1] = `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*(z_f*x_f/y_f)
               `i_f[2] = `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*(z_f*x_f/y_f)
*            ===&gt; can solve for `i_f from this

          using orthogonality of `i_f,`j_f,`k_f to define `k_f:
               `k_f = `i_f cross `j_f
               `k_f[0] = `i_f[1]*`j_f[2] - `i_f[2]*`j_f[1]
               `k_f[1] = `i_f[2]*`j_f[0] - `i_f[0]*`j_f[2]
               `k_f[2] = `i_f[0]*`j_f[1] - `i_f[1]*`j_f[0]
*            ===&gt; can solve for `k_f from this
              uneeded details:
               `k_f[0] = `i_f[1]*`j_f[2] - `i_f[2]*`j_f[1]
                       = `j_f[2]*(`j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f))
                          - `j_f[1]*(`j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f))
               `k_f[1] = `i_f[2]*`j_f[0] - `i_f[0]*`j_f[2]
                       = `j_f[0]*(`j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f))
                          - `j_f[2]*(`j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f))
               `k_f[2] = `i_f[0]*`j_f[1] - `i_f[1]*`j_f[0]
                       = `j_f[1]*(`j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f))
                          - `j_f[0]*(`j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f))
    */    
        
        /*
        solve for z_f
           zf^2 = (1/2)*( ((1+xf^2)/(mf*mf)) + ((1+yf^2)/(nf*nf)))
        
        solve for `j_f:
            j_f[0] = -(x_f/y_f)/ (m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f))
                  ...
        
        solve for `i_f:
            `i_f[0] = `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f)
             i_f[1] = `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*(z_f*x_f/y_f)
             i_f[2] = `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*(z_f*x_f/y_f)
        
        solve for k_f:
            `k_f[0] = `i_f[1]*`j_f[2] - `i_f[2]*`j_f[1]
            `k_f[1] = `i_f[2]*`j_f[0] - `i_f[0]*`j_f[2]
            `k_f[2] = `i_f[0]*`j_f[1] - `i_f[1]*`j_f[0]
        */
                
<span class="nc" id="L2684">        double[] zf = new double[mImages];</span>
        double[] mf, nf, tmp1, tmp2, tmp3;
        double xDivY, mDotM, nDotN, tmp4, tmp5;
<span class="nc" id="L2687">        double[][] _MCameraOrientation2D = new double[2*mImages][3];</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2689">            xf = t[i];</span>
<span class="nc" id="L2690">            yf = t[mImages + i];</span>
<span class="nc" id="L2691">            xDivY = xf/yf;</span>
<span class="nc" id="L2692">            mf = _M[i];</span>
<span class="nc" id="L2693">            nf = _M[mImages + i];</span>
<span class="nc" id="L2694">            mDotM = 0;</span>
<span class="nc" id="L2695">            nDotN = 0;</span>
<span class="nc bnc" id="L2696" title="All 2 branches missed.">            for (j=0; j&lt;mf.length; ++j) {</span>
<span class="nc" id="L2697">                mDotM += mf[i] * mf[i];</span>
<span class="nc" id="L2698">                nDotN += nf[i] * nf[i];</span>
            }
            //for z_f^2 take an average of eqn (15).  it's always positive
<span class="nc" id="L2701">            tmp4 = 1 + xf * xf;</span>
<span class="nc" id="L2702">            tmp4 /= mDotM;</span>
<span class="nc" id="L2703">            tmp5 = 1 + yf * yf;</span>
<span class="nc" id="L2704">            tmp5 /= nDotN;</span>
<span class="nc" id="L2705">            zf[i] = (tmp4 + tmp5) / 2.;</span>
<span class="nc" id="L2706">            zf[i] = Math.sqrt(zf[i]);</span>

            //j_f[0] = -(x_f/y_f)/ (m_f[0]*z_f - (n_f[0]*z_f*x_f/y_f))
<span class="nc" id="L2709">            tmp1 = Arrays.copyOf(mf, mf.length);</span>
<span class="nc" id="L2710">            MatrixUtil.multiply(tmp1, zf[i]);</span>
<span class="nc" id="L2711">            tmp2 = Arrays.copyOf(nf, nf.length);</span>
<span class="nc" id="L2712">            MatrixUtil.multiply(tmp2, zf[i]);</span>
<span class="nc" id="L2713">            MatrixUtil.multiply(tmp2, xDivY);</span>
            // j_f
<span class="nc" id="L2715">            _MCameraOrientation2D[mImages + i] = new double[3];</span>
<span class="nc bnc" id="L2716" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2717">                _MCameraOrientation2D[mImages + i][j] = -xDivY/(tmp1[j] - (tmp2[j]/yf));</span>
            }
            
            //`i_f = `j_f*(x_f/y_f) + m_f*z_f - n_f*(z_f*x_f/y_f)
<span class="nc" id="L2721">            tmp1 = Arrays.copyOf(_MCameraOrientation2D[mImages + i], _MCameraOrientation2D[mImages + i].length);</span>
<span class="nc" id="L2722">            MatrixUtil.multiply(tmp1, xDivY);</span>
<span class="nc" id="L2723">            tmp2 = Arrays.copyOf(mf, mf.length);</span>
<span class="nc" id="L2724">            MatrixUtil.multiply(tmp2, zf[i]);</span>
<span class="nc" id="L2725">            tmp3 = Arrays.copyOf(nf, nf.length);</span>
<span class="nc" id="L2726">            MatrixUtil.multiply(tmp3, zf[i]);</span>
<span class="nc" id="L2727">            MatrixUtil.multiply(tmp3, xDivY);</span>
            // i_f
<span class="nc" id="L2729">            _MCameraOrientation2D[i] = new double[3];</span>
<span class="nc bnc" id="L2730" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2731">                _MCameraOrientation2D[i][j] = tmp1[j] + tmp2[j] - tmp3[j];</span>
            }
        }
        
<span class="nc" id="L2735">        System.out.printf(&quot;_MCameraOrientation2D=\n%s\n&quot;, FormatArray.toString(_MCameraOrientation2D, &quot;%.4e&quot;));</span>
        
        // _M: rank is 3, mRows is &gt;= 4, nCols=3
        // _MCameraOrientation2D: rank is 3, mRows is &gt;= 4, nCols=3

        // _M * A = _MCameraOrientation2D
        // A = pseudoInv(_M)*_MCameraOrientation2D;
        // A^-1 = pseudoInv(_MCameraOrientation2D)*_M 
<span class="nc" id="L2743">        double[][] aInv = MatrixUtil.multiply(</span>
<span class="nc" id="L2744">            MatrixUtil.pseudoinverseFullColumnRank(_MCameraOrientation2D), _M);</span>
<span class="nc" id="L2745">        double[][] __S2 = MatrixUtil.multiply(aInv, _S);</span>
        
        
<span class="nc" id="L2748">        double[][] q2 = solveForTransformationToOrthoNormal(_MCameraOrientation2D);</span>
                
<span class="nc" id="L2750">        _MCameraOrientation2D = MatrixUtil.multiply(_MCameraOrientation2D, q2);</span>
        
        //assertDotProductMetrics(_MCameraOrientation2D, mImages);
        
        //_S2 is inv(q2)*shape
        //__S2 is inv(q2)*inv(a)*shape
<span class="nc" id="L2756">        double[][] _S2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q2), _S);</span>
<span class="nc" id="L2757">        __S2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q2), __S2);</span>
        
<span class="nc" id="L2759">        System.out.printf(&quot;after orthonormalization: _MCameraOrientation2D=\n%s\n&quot;, </span>
<span class="nc" id="L2760">            FormatArray.toString(_MCameraOrientation2D, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L2762">        System.out.printf(&quot;__S2=inv(q2)*inv(a)*_S=\n%s\n&quot;, FormatArray.toString(__S2, &quot;%.4e&quot;));</span>
<span class="nc" id="L2763">        System.out.printf(&quot;_S2=inv(q2)*_S=\n%s\n&quot;, FormatArray.toString(_S2, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L2765">        System.out.printf(&quot;_MCameraOrientation2D*__S2=\n%s\n&quot;, </span>
<span class="nc" id="L2766">            FormatArray.toString(MatrixUtil.multiply(_MCameraOrientation2D, __S2), &quot;%.4e&quot;));</span>
<span class="nc" id="L2767">        System.out.printf(&quot;_MCameraOrientation2D*_S2=\n%s\n&quot;, </span>
<span class="nc" id="L2768">            FormatArray.toString(MatrixUtil.multiply(_MCameraOrientation2D, _S2), &quot;%.4e&quot;));</span>
                  
        /*
        from Tomasi &amp; Kanade 1992:
        If desired, align the first camera reference system with the world
        reference system by forming the products R*R_0 and R_0^T*S,
        where the orthonormal matrix R_0 = [i1 j1 k1] rotates the ^Lfirst camera
        reference system into the identity matrix

        i0x i0y i0z    *  r0ix  r0jx  r0kx   = (i0 dot r0i)  (i0 dot r0j) (i0 dot r0k)
        i1x i1y i1z       r0iy  r0jy  r0ky
        i2x i2y i2z       r0iz  r0jz  r0kz
        i3x i3y i3z
        ...
        j0x j0y j0z
        j1x j1y j1z
        */
        

<span class="nc" id="L2787">        double[][] rFirst = new double[3][3];</span>
<span class="nc" id="L2788">        rFirst[0] = Arrays.copyOf(_MCameraOrientation2D[0], _MCameraOrientation2D[0].length);</span>
<span class="nc" id="L2789">        rFirst[1] = Arrays.copyOf(_MCameraOrientation2D[mImages], _MCameraOrientation2D[mImages].length);</span>
<span class="nc" id="L2790">        rFirst[2] = MatrixUtil.crossProduct(rFirst[0], rFirst[1]);</span>
        
<span class="nc" id="L2792">        double[][] r0 = MatrixUtil.pseudoinverseFullColumnRank(rFirst);</span>
        
<span class="nc" id="L2794">        System.out.printf(&quot;r0= \n%s\n&quot;, FormatArray.toString(r0,&quot;%.4e&quot;));</span>
        
<span class="nc" id="L2796">        System.out.printf(&quot;chk==1: \n%s\n&quot;, FormatArray.toString(</span>
<span class="nc" id="L2797">            MatrixUtil.multiply(rFirst, r0),&quot;%.4e&quot;));</span>
                  
        // multiply rotation matrices in the elements of the latest motion matrix by r0
<span class="nc" id="L2800">        double[][] rotStack = MatrixUtil.zeros(3*mImages, 3);</span>
<span class="nc" id="L2801">        double[][] _M3 = new double[3*mImages][];//(2*mImages)X3</span>
<span class="nc" id="L2802">        double[][] rTmp = new double[3][];</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2804">            rTmp[0] = Arrays.copyOf(_MCameraOrientation2D[i], _MCameraOrientation2D[i].length);</span>
<span class="nc" id="L2805">            rTmp[1] = Arrays.copyOf(_MCameraOrientation2D[mImages + i], _MCameraOrientation2D[mImages + i].length);</span>
<span class="nc" id="L2806">            rTmp[2] = MatrixUtil.crossProduct(rTmp[0], rTmp[1]);</span>
<span class="nc" id="L2807">            rTmp = MatrixUtil.multiply(rTmp, r0);</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2809">                rotStack[i*3 + j] = rTmp[j]; </span>
            }
<span class="nc" id="L2811">            _M3[i] = rTmp[0];</span>
<span class="nc" id="L2812">            _M3[i + mImages] = rTmp[1];</span>
<span class="nc" id="L2813">            _M3[i + 2*mImages] = rTmp[2];</span>
        }
        
<span class="nc" id="L2816">        double[][] _S3 = MatrixUtil.multiply(rFirst, __S2);</span>
        
<span class="nc" id="L2818">        System.out.printf(&quot;_M3=\n%s\n&quot;, FormatArray.toString(_M3,  &quot;%.4e&quot;));</span>
<span class="nc" id="L2819">        System.out.printf(&quot;rot stack=\n%s\n&quot;, FormatArray.toString(rotStack,  &quot;%.4e&quot;));</span>
<span class="nc" id="L2820">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(_S3, &quot;%.4e&quot;));</span>
<span class="nc" id="L2821">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        /*
        Poelman &amp; Kanade, last paragraph, Sect 3.4:
        All that remain to be computed are the translations for each frame. 
        We calculate the depth z_f from (15).  
        Once we know we x_f, y_f, z_f, `i_f, `j_f, `k_f 
        we can calculate `t_f using (4) and (5).
        
        eqn(4):
            z_f = -t_f dot k_f
        eqn (5):
            x_f = (-1/z_f)*(t_f dot i_f)
            and
            y_f = (-1/z_f)*(t_f dot j_f)

        use z_f equalities:
            z_f = -t_f dot k_f
                = -tf[0]*kf[0] + -tf[1]*kf[1] + -tf[2]*kf[2]

            z_f = (-1/x_f) * (t_f dot i_f)
                = -(1/xf)*tf[0]*if[0] + -(1/xf)*tf[1]*if[1] + -(1/xf)*tf[2]*if[2]

            z_f = (-1/y_f) * (t_f dot j_f)
                = -(1/yf)*tf[0]*jf[0] + -(1/yf)*tf[1]*jf[1] + -(1/yf)*tf[2]*jf[2]
            
        factor:
           tf[0]           tf[1]           tf[2]         const
           -------------------------------------------
            kf[0]           kf[1]          kf[2]         -zf
            (1/xf)*if[0]    (1/xf)*if[1]   (1/xf)*if[2]  -zf
            (1/yf)*jf[0]    (1/yf)*jf[1]   (1/yf)*jf[2]  -zf
        */
<span class="nc" id="L2854">        double[][] trans = new double[mImages][3];</span>
<span class="nc" id="L2855">        double[][] tf = MatrixUtil.zeros(3, 3);</span>
        double[][] g3Inv;
        double[] i3Vector;
<span class="nc" id="L2858">        double[] cs = new double[3];</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2860">            Arrays.fill(cs, -zf[i]);</span>
<span class="nc" id="L2861">            xf = t[i];</span>
<span class="nc" id="L2862">            yf = t[mImages + i];</span>
            
            // i_f[i] is _M3[i]
            // j_f[i] is _M3[mImages + i]
            // k_f[i] is _M3[2*mImages + i]
<span class="nc bnc" id="L2867" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L2868">                tf[0][j] = _M3[2*mImages + i][j];</span>
<span class="nc" id="L2869">                tf[1][j] = _M3[i][j]/xf;</span>
<span class="nc" id="L2870">                tf[2][j] = _M3[mImages + i][j]/yf;</span>
            }            
            //SVDProducts svdi = MatrixUtil.performSVD(tf);
<span class="nc" id="L2873">            g3Inv = MatrixUtil.pseudoinverseFullColumnRank(tf);</span>
<span class="nc" id="L2874">            i3Vector = MatrixUtil.multiplyMatrixByColumnVector(g3Inv, cs);</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">            assert(i3Vector.length == 3);</span>
            
<span class="nc" id="L2877">            trans[i] = new double[]{i3Vector[0], i3Vector[1], i3Vector[2]};</span>
        }
        
<span class="nc" id="L2880">        System.out.printf(&quot;trans=\n%s\n&quot;, FormatArray.toString(trans, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L2882">        ParaperspectiveProjectionResults results = new ParaperspectiveProjectionResults();</span>
<span class="nc" id="L2883">        results.XW = _S3; // or _S</span>
<span class="nc" id="L2884">        results.rotationMatrices = rotStack;</span>
<span class="nc" id="L2885">        results.translationVectors = trans;</span>
          
<span class="nc" id="L2887">        return results;        </span>
    }
    
    private static DenseMatrix extractIndices(DenseMatrix m, List&lt;Integer&gt; inlierIndexes) {
<span class="fc" id="L2891">        DenseMatrix out = new DenseMatrix(m.numRows(), inlierIndexes.size());</span>
<span class="fc" id="L2892">        int r = 0;</span>
<span class="fc bfc" id="L2893" title="All 2 branches covered.">        for (int i = 0; i &lt; inlierIndexes.size(); ++i) {</span>
<span class="fc" id="L2894">            int idx = inlierIndexes.get(i);</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">            for (int j = 0; j &lt; m.numRows(); ++j) {</span>
<span class="fc" id="L2896">                out.add(j, r, m.get(j, idx));</span>
            }
<span class="fc" id="L2898">            r++;</span>
        }
<span class="fc" id="L2900">        return out;</span>
    }

    private static double[] gT(double[] a, double[] b) {
<span class="nc" id="L2904">        double[] gT = new double[]{</span>
            a[0]*b[0], 
            a[0]*b[1] + a[1]*b[0],
            a[0]*b[2] + a[2]*b[0],
            a[1]*b[1],
            a[1]*b[2] + a[2]*b[1],
            a[2]*b[2]
        };
<span class="nc" id="L2912">        return gT;</span>
    }

    private static double[][] extractAndNormalize(double[][] x, int imageNumber, 
        int nFeatures, double[] outputNorm) {
        
<span class="nc" id="L2918">        double[][] xN = new double[3][nFeatures];</span>
<span class="nc" id="L2919">        xN[0] = new double[nFeatures];</span>
<span class="nc" id="L2920">        xN[1] = new double[nFeatures];</span>
<span class="nc" id="L2921">        xN[2] = new double[nFeatures];</span>
<span class="nc" id="L2922">        Arrays.fill(xN[2], 1);</span>
        
<span class="nc" id="L2924">        int imageIdx = (x.length/nFeatures)*imageNumber;</span>
        
<span class="nc" id="L2926">        double cen0 = 0;</span>
<span class="nc" id="L2927">        double cen1 = 0;</span>
<span class="nc bnc" id="L2928" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2929">            cen0 += x[0][imageIdx + i];</span>
<span class="nc" id="L2930">            cen1 += x[0][imageIdx + i];</span>
        }
<span class="nc" id="L2932">        cen0 /= (double)nFeatures;</span>
<span class="nc" id="L2933">        cen1 /= (double)nFeatures;</span>

<span class="nc" id="L2935">        double scale = 0;</span>
        double diffX, diffY;
<span class="nc bnc" id="L2937" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2938">            diffX = x[0][imageIdx + i] - cen0;</span>
<span class="nc" id="L2939">            diffY = x[0][imageIdx + i] - cen1;</span>
<span class="nc" id="L2940">            scale += (diffX*diffX + diffY*diffY);</span>
        }
<span class="nc" id="L2942">        scale = Math.sqrt(scale/(2.*(nFeatures - 1.)));</span>
        // to use std dev instead: scale = Math.sqrt(scale/(n-1.));
        
<span class="nc" id="L2945">        outputNorm[imageNumber*3 + 0] = cen0;</span>
<span class="nc" id="L2946">        outputNorm[imageNumber*3 + 1] = cen1;</span>
<span class="nc" id="L2947">        outputNorm[imageNumber*3 + 2] = scale;</span>
        
<span class="nc bnc" id="L2949" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2950">            xN[0][i] = (x[0][imageIdx + i] - cen0)/scale;</span>
<span class="nc" id="L2951">            xN[1][i] = (x[1][imageIdx + i] - cen1)/scale;</span>
        }
        
<span class="nc" id="L2954">        return xN;</span>
    }

    private static void extractColumn(double[][] x, int idx, double[] outputPoint) {
<span class="nc" id="L2958">        outputPoint[0] = x[0][idx];</span>
<span class="nc" id="L2959">        outputPoint[1] = x[1][idx];</span>
<span class="nc" id="L2960">        outputPoint[2] = x[2][idx];</span>
<span class="nc" id="L2961">    }</span>

    /**
     * 
     * @param motion 2*F X 3 matrix of rotation for images
     * where the first F rows are the first rows of each image's rotation matrix
     * and the second F rows are the second rows of each image's rotation matrix.
     * the third row of rotation is recreated when needed using the cross
     * product of the first 2 rows of each image's rotation matrix;
     * @return
     * @throws NotConvergedException 
     */
    private static double[][] solveForTransformationToOrthoNormal(double[][] motion) throws NotConvergedException {
         /*
        The rows of R represent the orientations of the horizontal and vertical camera
        reference axes throughout the stream, 
        while the columns of S are the coordinates of the P feature
        points with respect to their centroid.
        
    motion = [ i_hat_0[0] i_hat_0[2] i_hat_0[2] ] where i_hat_f are unit vectors
             [ i_hat_1[0] i_hat_1[2] i_hat_1[2] ]
             [   ..._m-1 ...                    ]
             [ j_hat_0[0] j_hat_0[2] j_hat_0[2] ]
             [ j_hat_1[0] j_hat_1[2] j_hat_1[2] ] where j_hat_f are unit vectors
             [  ..._m-1 ... ]
        
    shape = [s_C_1  ...  s_C_m] is [3XP] where P is the number of points per image frame
        NOTE that the summation over columns of sC = 0 (they are centered w.r.t. image points)
        
        R = motion*Q
        S = (Q^-1)*shape
        
          eqn (1)  (`i_f)^T * Q * Q^T * (`i_f) = 1   [dimensions 1X3 * 3X3 * 3X1 = 1]
          eqn (2)  (`j_f)^T * Q * Q^T * (`j_f) = 1
          eqn (3)  (`i_f)^T * Q * Q^T * (`j_f) = 0
        
        find Q as a 3 × 3 matrix, non-singular matrix
        
        //Morita and Kanade
        L = Q^T * Q
        solve the linear system of equations for L 
            and use Cholesky decomposition to get Q.
            Correct the decomposition to enforce L to be positive definite
            symmetric.
        
        See notes reference Morita and Kanade for solving Q.
         T. Morita and T. Kanade, A Sequential Factorization Method for Recovering Shape and Motion
         from Image Streams, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 19,
         no.8, pp.858-867, Aug 1997  (1994?)
        
        http://note.sonots.com/SciSoftware/Factorization.html#cse252b
        
        L = [ l1 l2 l3 ]
            [ l2 l4 l5 ]
            [ l3 l5 l6 ]     

        the knowns are `i_f and `j_f, so we are solving for the 6 unknowns in L.

        expand the terms:

        eqn(1):
        if_0  if_1  if_2 ] * [ l1 l2 l3 ] * [ if_0 ] = 1
                             [ l2 l4 l5 ]   [ if_1 ]
                             [ l3 l5 l6 ]   [ if_2 ]
        eqn(2):
        jf_0  jf_1  jf_2 ] * [ l1 l2 l3 ] * [ jf_0 ] = 1
                             [ l2 l4 l5 ]   [ jf_1 ]
                             [ l3 l5 l6 ]   [ jf_2 ]
        eqn(3):
        if_0  if_1  if_2 ] * [ l1 l2 l3 ] * [ jf_0 ] = 0
                             [ l2 l4 l5 ]   [ jf_1 ]
                             [ l3 l5 l6 ]   [ jf_2 ]
        
        eqn(1):
        l1*if_0*if_0 + l2*if_1*if_0 + l3*if_2*if_0 + l2*if_0*if_1 + l4*if_1*if_1 + l5*if_2*if_1 + l3*if_0*if_2 + l5*if_1*if_2 + l6*if_2*if_2 = 1
        eqn(2):
        l1*jf_0*jf_0 + l2*jf_1*jf_0 + l3*jf_2*jf_0 + l2*jf_0*jf_1 + l4*jf_1*jf_1 + l5*jf_2*jf_1 + l3*jf_0*jf_2 + l5*jf_1*jf_2 + l6*jf_2*jf_2 = 1
        eqn(3):
        l1*if_0*jf_0 + l2*if_1*jf_0 + l3*if_2*jf_0 + l2*if_0*jf_1 + l4*if_1*jf_1 + l5*if_2*jf_1 + l3*if_0*jf_2 + l5*if_1*jf_2 + l6*if_2*jf_2 = 1
        
        factor out the L terms, linearly
        l1           l2                    l3                    l4           l5                    l6         const
        (if0*if0)    (if1*if0 + if0*if1)   (if2*if0 + if0*if2)   (if1*if1)    (if2*if1 + if1*if2)   (if2*if2)   1
        (jf0*jf0)    (jf1*jf0 + jf0*jf1)   (jf2*jf0 + jf0*jf2)   (jf1*jf1)    (jf2*jf1 + jf1*jf2)   (jf2*jf2)   1
        (if0*jf0)    (if1*jf0 + if0*jf1)   (if2*jf0 + if0*jf2)   (if1*jf1)    (if2*jf1 + if1*jf2)   (if2*jf2)   0

        since the terms in the rows have a similar pattern, can write the equation more concisely using
        a function to generate them:
           g(a,b) = [a0*b0         ]
                    [a0*b1 + a1*b0 ]
                    [a0*b2 + a2*b0 ]
                    [a1*b1         ]
                    [a1*b2 + a2*b1 ]
                    [a2*b2         ]

        G size is 3*F X 6
        L is a vector of length 6
        c size is 3*F
        
        the G = [ g(i_0, i_0)^T       ]   L_vectorized = [l1]    c = [2*F rows of 1]
                [ ...each row thru F  ]                  [l2]        [F rows of 0  ]
                [ g(j_0, j_0)^T       ]                  [l3]
                [ ...each row thru F  ]                  [l4]
                [ g(i_0, j_0)^T       ]                  [l5]
                [ ...each row thru F  ]                  [l6]

        G*L_vectorized = c ==&gt;  L_vectorized = G^-1 * c
        */
        
<span class="nc" id="L3070">         int mImages = motion.length/2;</span>
        
        int i, j;
<span class="nc" id="L3073">        double[] c = new double[3*mImages];</span>
<span class="nc bnc" id="L3074" title="All 2 branches missed.">        for (i = 0; i &lt; 2*mImages; ++i) {</span>
<span class="nc" id="L3075">            c[i] = 1;</span>
        }
        
        //g is 3F X 6
<span class="nc" id="L3079">        double[][] g = new double[3*mImages][6];</span>
<span class="nc bnc" id="L3080" title="All 2 branches missed.">        for (i = 0; i &lt; 2*mImages; ++i) {</span>
<span class="nc" id="L3081">            g[i] = gT(motion[i], motion[i]);</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">            assert(g[i].length == 6);</span>
        }
<span class="nc bnc" id="L3084" title="All 2 branches missed.">        for (i = 2*mImages, j=0; i &lt; 3*mImages; ++i, j++) {</span>
<span class="nc" id="L3085">            g[i] = gT(motion[j], motion[mImages + j]);</span>
        }
                
        // rank of G is 4
        //G * L = c
        // G^T * G * L = G^T * c
        // L = (G^T*G)^-1*G^T * c
        //     pseudoinverse of G is (G^T*G)^-1*G^T
<span class="nc" id="L3093">        double[][] gInv = MatrixUtil.pseudoinverseRankDeficient(g);</span>
        
        // 6X1
<span class="nc" id="L3096">        double[] lVector = MatrixUtil.multiplyMatrixByColumnVector(gInv, c);</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">        assert(lVector.length == 6);</span>
        
        // 3X3
<span class="nc" id="L3100">        double[][] ell = new double[3][3];</span>
<span class="nc" id="L3101">        ell[0] = new double[]{lVector[0], lVector[1], lVector[2]};</span>
<span class="nc" id="L3102">        ell[1] = new double[]{lVector[1], lVector[3], lVector[4]};</span>
<span class="nc" id="L3103">        ell[2] = new double[]{lVector[2], lVector[4], lVector[5]};</span>
        
        // Q can be determined :
        //   as the square root of ell,
        //   or with the Cholesky decomposition
        //   or with eigendecomposition
        
        // enforcing positive definiteness of L (which is ell here).
<span class="nc" id="L3111">        double eps = 1e-16;//1.e-11; eps close to zero within machine precision to perturb the matrix to smallest eigenvalue of eps</span>
<span class="nc" id="L3112">        double[][] lPSD = MatrixUtil.nearestPositiveSemidefiniteToASymmetric(ell, eps);</span>

        // debugging
<span class="nc" id="L3115">        EVD evd2 = EVD.factorize(new DenseMatrix(lPSD));</span>
<span class="nc" id="L3116">        double[] eig = evd2.getRealEigenvalues();</span>
<span class="nc" id="L3117">        double[][] aMinusPSD = MatrixUtil.pointwiseSubtract(ell, lPSD);</span>
<span class="nc" id="L3118">        double dist1 = MatrixUtil.frobeniusNorm(aMinusPSD);</span>

<span class="nc" id="L3120">        boolean ipd = MatrixUtil.isPositiveDefinite(lPSD);</span>
<span class="nc bnc" id="L3121" title="All 2 branches missed.">        if (!ipd) {</span>
            //TODO: consider throwing an exception so i'll fix this...
<span class="nc" id="L3123">            System.err.printf(&quot;WARNING: matrix L_PSD is not positive semi-definite.&quot; +</span>
<span class="nc" id="L3124">                    &quot; The distance between L and L_PSD=%.3e, but should be near 0.\n&quot;, dist1);</span>
        }

       
        //decompose Q = L * (sigma+) * L^T;  Q is size 3X3
<span class="nc" id="L3129">        double[][] q = LinearEquations.choleskyDecompositionViaMTJ(lPSD);</span>
        
<span class="nc" id="L3131">        return q;</span>
    }

    private static void assertDotProductMetrics(double[][] motion,
        int mImages) {
        double[] tmp1, tmp2, tmp3;
        int i, j;
        double tmp4, tmp5, tmp6, tmp7;
<span class="nc bnc" id="L3139" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L3140">            tmp1 = Arrays.copyOf(motion[i], motion[i].length);</span>
<span class="nc" id="L3141">            tmp2 = Arrays.copyOf(motion[mImages + i], motion[mImages + i].length);</span>
<span class="nc" id="L3142">            tmp3 = MatrixUtil.crossProduct(tmp1, tmp2);</span>
<span class="nc" id="L3143">            tmp4 = 0; // i dot i = 1</span>
<span class="nc" id="L3144">            tmp5 = 0; // j dot j = 1</span>
<span class="nc" id="L3145">            tmp6 = 0; // i dot j = 0</span>
<span class="nc" id="L3146">            tmp7 = 0; // k dot k = 1</span>
<span class="nc bnc" id="L3147" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L3148">                tmp4 += (tmp1[j]*tmp1[j]);</span>
<span class="nc" id="L3149">                tmp5 += (tmp2[j]*tmp2[j]);</span>
<span class="nc" id="L3150">                tmp6 += (tmp1[j]*tmp2[j]);</span>
<span class="nc" id="L3151">                tmp7 += (tmp3[j]*tmp3[j]);</span>
            }
<span class="nc" id="L3153">            System.out.printf(&quot;tmps:%.4e, %.4e, %.4e, %.4e\n&quot;, tmp4, tmp5, tmp7, tmp6);</span>
            /* if had perfect data:
            assert(Math.abs(tmp4 - 1) &lt; 1e-2);
            assert(Math.abs(tmp5 - 1) &lt; 1e-2);
            assert(Math.abs(tmp7 - 1) &lt; 1e-2);
            assert(Math.abs(tmp6) &lt; 1e-2);
            */
        }
<span class="nc" id="L3161">    }</span>

    /**
     * NOT READY FOR USE YET.  Looks like there's an error in the last column of the result as
     * the numbers are too large.
     *
     * calculates the homography as the canonical pose for the un-calibrated camera
     * (the projective projection as the 2nd image's projection
     * in the canonical decomposition, pg 189 of MASKS).
     * &lt;pre&gt;
     * The homography H in [x2]_x*H*x1 = [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 ~ 0
     * where [b]_x is the skew-symmetric matrix of vector b.
     *
     * the skew symmetric matrix multiplication replaces the cross product.
     * x2 cross H*x1 ~ 0.
     *
     * Details from Chapter 6 of Ma, Soatto, Kosecka,&amp; Sastry (MASKS)
     * &quot;An Invitation to Computer Vision, From Images to Geometric Models&quot;
     *
     * let X' = K*X and T'=K*T where K is the intrinsic camera parameters matrix.
     *
     * from euclidean transformation, we can derive the
     * epipolar constraint:  x2'^T * [T']_x * K *R * K^-1 * x1' = 0
     *
     * x2^T*[T]_x*R*x1=0 &lt;==&gt; x2'^T * [T']_x * K *R * K^-1 * x1' = 0
    
    *     F = K^-T * [T]_x * R * K^-1 (when K=I, F=E)
            = [T']_x * K * R * K^-1 if det(K)=1, else it's approx (up to a scale factor)
    
    *    epipoles e2^T*F = 0, F*e1 = 0.
         e2 = K*T
         e1 = K*R^T*T
         
    epipolar constraint for uncalibrated cameras:
        x2'^T * [T']_x * K *R * K^-1 * x1' = x2'^T * [T']_x * (K*R*K^-1 + T'*v^T)*x1'
        = x2'^T * [T']_x * R' * x1'
           where v is an arbitrary vector
           
    since F = [T']_x * K *R * K^-1,
       fitting for the projection |(K*R*K^-1 + T'*v^T), v_4*T'|
    one can then approximate the uncalibrated camera pose.
     choosing solution  this is a 4-parameter family of ambiguous decompositions.
    pg 187 of MASKS.
    This method implements point 4 in algorithm 11.9 on pg 405, Section 11.5 of MASKS.    
     * &lt;/pre&gt;
     * @param x1P the image 1 (a.k.a. left) half of correspondence points. format is 3 x N
     * where N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points) since
     * internally an identity matrix is used for K.
     * @param x2P the image 2 (a.k.a. right) half of correspondence points. format is 3 x N where
     * N is the number of points. NOTE: since intrinsic parameters are not
     * known, users of this method should presumably center the coordinates in
     * some manner (e.g. subtract the image center or centroid of points).
     * @param fm the fundamental matrix.  size is 3X3.
     * @param e2 the left null space in the left singular vector of F.
     * it's the last column of svd(fm).u and represents the location of
     * the image 1 optical center (a.k.a. camera center).
     * The epipole is the point where the baseline (the line joining the two
     * camera centers ol, O2) intersects the image plane in each view,
     * e2^T*F=0.  e2 = K*T where T is translation vector between cameras
     * (a.k.a. the extrinsic camera parameter called translation).
     * (NOTE: e1=K*R^T*T where R and T are extrinsic camera rotation and translation).
     * @return
     * @throws NotConvergedException
     */
    public static double[][] calculateProjectiveHomographyWithLeastSquares(
            double[][] x1P, double[][] x2P, double[][] fm, double[] e2) throws NotConvergedException {
        
        /*
        This method implements point 4 in algorithm 11.9 on pg 405, Section 11.5 of MASKS.

        Compute the least-squares solution v from equation (11.30) using the
        set of matched feature points, and determine the matching homography

        e1 = right nullspace of FM = SVD(fm).V[*,2]
        e2 = left nullspace of FM = SVD(fm).U[*,2]

            [x2]_x*H*x1 = [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 ~ 0
            fit for v=[v0,v1,v2]^T w/ total least squares
        that is minarg_v( summation_over_j( || [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 ||^2)
        where j is the enumeration of points
                
        then determine H: = ([e2]_x)^T * F + e2*v^T
                
        calculate [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1 in pieces, separating the multiplication
        that includes v from the rest:
        [x2]_x*( ([e2]_x)^T * F + e2*v^T)*x1
        = [x2]_x*( ([e2]_x)^T * F)*x1 + [x2]_x*( (e2*v^T)*x1 )
        [x2]_x =|0       -x2[2]  x2[1]  |
                |x2[2]   0       -x2[0] |
                |-x2[1]  x2[0]   0      |
    ([e2]_x)^T =| 0      -e2[2]   e2[1] |^T = | 0       e2[2]  -e2[1]|
                | e2[2]      0   -e2[0] |     | -e2[2]  0       e2[0]|
                | -e2[1]  e2[0]     0   |     | e2[1]   -e2[0]  0    |
                
 [e2]_x^T * F = | 0       e2[2]  -e2[1]| * | F00 F01 F02 |
                | -e2[2]  0       e2[0]|   | F10 F11 F12 |
                | e2[1]   -e2[0]  0    |   | F20 F21 F22 |
          
              = e2[2]*F10 - e2[1]*F20   e2[2]*F11 - e2[1]*F21   e2[2]*F12 - e2[1]*F22
                -e2[2]*F00 + e2[0]*F20  -e2[2]*F01 + e2[0]*F21  -e2[2]*F02 + e2[0]*F22
                e2[1]*F00 - e2[0]*F10   e2[1]*F01 - e2[0]*F11   e2[1]*F02 - e2[0]*F12
                
        for simpler notation,
         use e2STF = ([e2]_x)^T * F = | e2STF00 e2STF01 e2STF02 |
                                      | e2STF10 e2STF11 e2STF12 |
                                      | e2STF20 e2STF21 e2STF22 |
                
        let x1=[x10,x11,x12] and x1=[x20,x21,x22]
        ( ([e2]_x)^T * F)*x1
               =| e2STF00 e2STF01 e2STF02 | * | x10 |
                | e2STF10 e2STF11 e2STF12 |   | x11 |
                | e2STF20 e2STF21 e2STF22 |   | x12 |
               =| e2STF00*x10+e2STF01*x11+e2STF02*x12 |
                | e2STF10*x10+e2STF11*x11+e2STF12*x12 |
                | e2STF20*x10+e2STF21*x11+e2STF12*x22 |
                [x2]_x*( ([e2]_x)^T * F)*x1 = 3X3 * 3X1 = 3X1
        for simpler notation,
        using b = the 3X1 product of [x2]_x*( ([e2]_x)^T * F)*x1
        b = b0
            b1
            b2
                
        now the multiplication that includes v: [x2]_x*( (e2*v^T)*x1 )
        let e2[0]=e20, e2[1]=e21, e2[2]=e22
        let x1[0][i] = x10, x1[1][i] = x11, x1[1][i] = x11
        let x2[0][i] = x20, x2[1][i] = x21, x2[1][i] = x21
        let v=v1,v2,v3
                
        e2*v^T = e20*v0  e20*v1  e20*v2
                 e21*v0  e21*v1  e21*v2
                 e22*v0  e22*v1  e22*v2
                
        [x2]_x*(e2*v^T)*x1
        = |0     -x22  x21 | * | e20*v0  e20*v1  e20*v2 | * | x10 |
          |x22   0    -x20 |   | e21*v0  e21*v1  e21*v2 |   | x11 |
          |-x21  x20   0   |   | e22*v0  e22*v1  e22*v2 |   | x12 |
        = |0     -x22  x21 | * | e20*v0*x10 + e20*v1*x11 + e20*v2*x12 |
          |x22   0    -x20 |   | e21*v0*x10 + e21*v1*x11 + e21*v2*x12 |
          |-x21  x20   0   |   | e22*v0*x10 + e22*v1*x11 + e22*v2*x12 |
        = |-x22*(e21*v0*x10 + e21*v1*x11 + e21*v2*x12) + x21*(e22*v0*x10 + e22*v1*x11 + e22*v2*x12) |
          |x22*(e20*v0*x10 + e20*v1*x11 + e20*v2*x12) -x20*(e22*v0*x10 + e22*v1*x11 + e22*v2*x12)   |
          |-x21*(e20*v0*x10 + e20*v1*x11 + e20*v2*x12) + x20*(e21*v0*x10 + e21*v1*x11 + e21*v2*x12  |
        = |v0*(-x22*e21*x10+x21*e22*x10) + v1*(-x22*e21*x11+x21*e22*x11) + v2*(-x22*e21*x12+x21*e22*x12) |
          |v0*(x22*e20*x10-x20*e22*x10) + v1*(x22*e20*x11-x20*e22*x11) + v2*(x22*e20*x12-x20*e22*x12)    |
          |v0*(-x21*e20*x10+x20*e21*x10) + v1*(-x21*e20*x11+x20*e21*x11) + v2*(-x21*e20*x12+x20*e21*x12) |
                
        A * x = b where A_i is size 3X3 matrix of v factors
        x is size 1X3 vector to be solved for
        b is size 1X3 =  -1*remaining terms for each row of the objective
                
        |i=0: v0 factors  v1 factors  v2 factors | * |v0| = |-b0|
                                                     |v1|   |-b1|
                                                     |v2|   |-b2|
        
        can solve using
            v = SVD(A | b).vT[last row, first 3 elements)
        or v = pseudoInv(A) * b
        
        They both produce the same answer, though might need multiplication by -1.
        */
        // these are 3X3
<span class="fc" id="L3324">        double[][] e2SkewT = MatrixUtil.transpose(MatrixUtil.skewSymmetric(e2));</span>
<span class="fc" id="L3325">        double[][] e2SkewTF = MatrixUtil.multiply(e2SkewT, fm);</span>
<span class="fc" id="L3326">        int n = x1P[0].length;</span>
        int i;
<span class="fc" id="L3328">        double[] x1 = new double[3];</span>
<span class="fc" id="L3329">        double[] x2 = new double[3];</span>
        //3*n X 1
<span class="fc" id="L3331">        double[] b = new double[3 * n];</span>
        //3*n X 3
<span class="fc" id="L3333">        double[][] a = new double[3 * n][];</span>
        
        //3X3
<span class="fc" id="L3336">        double[][] x2Skew = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L3337">        double[][] tmp = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L3338">        double[] bI = new double[3];</span>
        double x10;
        double x11;
        double x12;
        double x20;
        double x21;
        double x22;
        double e20;
        double e21;
        double e22;
<span class="fc bfc" id="L3348" title="All 2 branches covered.">        for (i = 0; i &lt; x1P[0].length; ++i) {</span>
<span class="fc" id="L3349">            MatrixUtil.extractColumn(x1P, i, x1);</span>
<span class="fc" id="L3350">            MatrixUtil.extractColumn(x2P, i, x2);</span>
<span class="fc" id="L3351">            MatrixUtil.skewSymmetric(x2, x2Skew);</span>
            // 3X1  [x2]_x*( ([e2]_x)^T * F)*x1
<span class="fc" id="L3353">            MatrixUtil.multiply(x2Skew, e2SkewTF, tmp);</span>
<span class="fc" id="L3354">            MatrixUtil.multiplyMatrixByColumnVector(tmp, x1, bI);</span>
<span class="fc" id="L3355">            MatrixUtil.multiply(bI, -1);</span>
<span class="fc" id="L3356">            System.arraycopy(bI, 0, b, i * 3, 3);</span>
<span class="fc" id="L3357">            x10 = x1[0];</span>
<span class="fc" id="L3358">            x11 = x1[1];</span>
<span class="fc" id="L3359">            x12 = x1[2];</span>
<span class="fc" id="L3360">            x20 = x2[0];</span>
<span class="fc" id="L3361">            x21 = x2[1];</span>
<span class="fc" id="L3362">            x22 = x2[2];</span>
<span class="fc" id="L3363">            e20 = e2[0];</span>
<span class="fc" id="L3364">            e21 = e2[1];</span>
<span class="fc" id="L3365">            e22 = e2[2];</span>
            /*
            [x2]_x*(e2*v^T)*x1
              = |v0*(-x22*e21*x10+x21*e22*x10) + v1*(-x22*e21*x11+x21*e22*x11) + v2*(-x22*e21*x12+x21*e22*x12) |
                |v0*(x22*e20*x10-x20*e22*x10) + v1*(x22*e20*x11-x20*e22*x11) + v2*(x22*e20*x12-x20*e22*x12)    |
                |v0*(-x21*e20*x10+x20*e21*x10) + v1*(-x21*e20*x11+x20*e21*x11) + v2*(-x21*e20*x12+x20*e21*x12) |
             */
<span class="fc" id="L3372">            a[i * 3] = new double[]{-x22 * e21 * x10 + x21 * e22 * x10, -x22 * e21 * x11 + x21 * e22 * x11, -x22 * e21 * x12 + x21 * e22 * x12};</span>
<span class="fc" id="L3373">            a[i * 3 + 1] = new double[]{x22 * e20 * x10 - x20 * e22 * x10, x22 * e20 * x11 - x20 * e22 * x11, x22 * e20 * x12 - x20 * e22 * x12};</span>
<span class="fc" id="L3374">            a[i * 3 + 2] = new double[]{-x21 * e20 * x10 + x20 * e21 * x10, -x21 * e20 * x11 + x20 * e21 * x11, -x21 * e20 * x12 + x20 * e21 * x12};</span>
        }
        // 
        //    as -1*v below
        
        //A * x = b
        // x = A^-1 * b
        // 3 X n
<span class="fc" id="L3382">        double[][] aInv = MatrixUtil.pseudoinverseFullColumnRank(a);</span>
<span class="fc" id="L3383">        double[] v = MatrixUtil.multiplyMatrixByColumnVector(aInv, b);</span>
        //H = ([e2]_x)^T * F + e2*v^T
        //  = e2SkewTF + e2*v^T
<span class="fc" id="L3386">        double[][] h = MatrixUtil.pointwiseAdd(e2SkewTF, MatrixUtil.outerProduct(e2, v));</span>
<span class="fc" id="L3387">        return h;</span>
    }
    
    public static class ProjectionResults {
        /**
         * world coordinate system points in matrix of size 4 X nFeatures.
         * The points are stacked along columns sequentially.
         */
        public double[][] XW;
        
        /**
         * the projection matrices stacked along rows for each image.
         * so projection for image 0 will be in rows [0, 3);
         * projection for image 1 will be in rows [3, 6), etc.
         * This matrix's size is 3*nImages X 4.
         * The projection matrices here are composed of extrinsic camera parameters only.
         */
        public double[][] projectionMatrices;
    }
    
    public static class OrthographicProjectionResults {
        /**
         * world coordinate system points
         */
        public double[][] XW;
        
        /**
         * the rotation matrices stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public double[][] rotationMatrices;
    }
    
    public static class ParaperspectiveProjectionResults {
        /**
         * world coordinate system points
         */
        private double[][] XW;
        
        /**
         * the rotation matrices (as extrinsic parameters) stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        private double[][] rotationMatrices;
        
        /**
         * the translation vectors (as extrinsic parameters) 
         * stacked along rows for each image.
         * 
         */
        private double[][] translationVectors;

        /**
         * @return the XW
         */
        public double[][] getXW() {
            return XW;
        }

        /**
         * @param XW the XW to set
         */
        public void setXW(double[][] XW) {
            this.XW = XW;
        }

        /**
         * @return the rotationMatrices (as extrinsic parameters) 
         * stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public double[][] getRotationStack() {
            return rotationMatrices;
        }

        /**
         * @param rotationMatrices the rotationMatrices to set.
         * the rotation matrices (as extrinsic parameters) stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public void setRotationStack(double[][] rotationMatrices) {
            this.rotationMatrices = rotationMatrices;
        }

        /**
         * @return the translationVectors
         */
        public double[][] getTranslationVectorStack() {
            return translationVectors;
        }

        /**
         * @param translationVectors the translationVectors to set
         */
        public void setTranslationVectorStack(double[][] translationVectors) {
            this.translationVectors = translationVectors;
        }
        
        public double[][] getExtrinsicProjection(int imageNumber) {
            double[][] p = new double[3][4];
            for (int i = 0; i &lt; 3; ++i) {
                p[i] = new double[4];
                System.arraycopy(rotationMatrices[imageNumber*3 + i], 0, p[i], 0, 3);
                p[i][4] = translationVectors[imageNumber][i];
            }
            return p;
        }
    }

    public static class MotionAndStructure {

        /**
         r is the rotation matrix transforming frame 1 to frame 2,
         */
        public double[][] r;
        /**
         tDivD is t / d where
         t is the translation vector transforming frame 1 into frame 2.
         d is the distance from the world coordinate plane P to the optical center of the first camera and is &gt; 0.
         In other words, we get the direction of translation, but not the scale.
         */
        public double[] tDivD;

        /**
         * nHat is the unit normal vector of the plane P with respect to the first camera frame.
         */
        public double[] nHat;

        /**
         * the singular vector of null space of H (from H H * orthToH = 0)
         */
        public double[] orthToH;
    }

    public static class ReconstructionResults {
        double[][] XW;
        double[][] k1Intr;
        double[][] k2Intr;
        double[][] k1ExtrRot;
        double[] k1ExtrTrans;
        double[][] k2ExtrRot;
        double[] k2ExtrTrans;
        double[][] essentialMatrix;
        double[][] fundamentalMatrix;
        double[][] svdU;
        double[][] svdVt;
        double[] svdS;
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;XW=\n&quot;);
            if (XW != null) {
                sb.append(FormatArray.toString(XW, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 intrinsic=\n&quot;);
            if (k1Intr != null) {
                sb.append(FormatArray.toString(k1Intr, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 extrinsic rotation=\n&quot;);
            if (k1ExtrRot != null) {
                sb.append(FormatArray.toString(k1ExtrRot, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 extrinsic translation=\n&quot;);
            if (k1ExtrTrans != null) {
                sb.append(FormatArray.toString(k1ExtrTrans, &quot;%.4e&quot;));
                sb.append(&quot;\n&quot;);
            }
            sb.append(&quot;k2 intrinsic=\n&quot;);
            if (k2Intr != null) {
                sb.append(FormatArray.toString(k2Intr, &quot;%.4e&quot;));
            }
            sb.append(&quot;k2 extrinsic rotation=\n&quot;);
            if (k2ExtrRot != null) {
                sb.append(FormatArray.toString(k2ExtrRot, &quot;%.4e&quot;));
            }
            sb.append(&quot;k2 extrinsic translation=\n&quot;);
            if (k2ExtrTrans != null) {
                sb.append(FormatArray.toString(k2ExtrTrans, &quot;%.4e&quot;));
                sb.append(&quot;\n&quot;);
            }
            return sb.toString();
        }
    }
    
      /**
     * among the 4 rotation and translation combinations from R1, R1, T1, and T2, 
     * select the one with the largest number of projected Z coordinates which are
     * positive, that is, in front of both cameras.
     * NOTE that inaccuracies in this chirality are larger for points further 
     * away from the cameras and closer to the plane at infinity.
     * NOTE that the determinants of R1 and R2 should have already been checked to be +1.
     * @param x1 image 1 portion of the correspondence pairs in camera reference frame.
     * @param x2 image 2 portion of the correspondence pairs in camera reference frame.
     * @param k1 intrinsic camera matrix for camera 1
     * @param k2 intrinsic camera matrix for camera 2
     * @param R1 rotation matrix whose determinant is +1
     * @param R2 rotation matrix whose determinant is +1
     * @param t1 translation vector (the direction between camera centers)
     * @param t2 translation vector (the direction between camera centers)
     * @param rSelected output variable holding the R1 or R2, whichever was the 
     * first found as a valid solution.
     * @param tSelected output variable holding the t1 or t2, whichever was the 
     * first found as a valid solution.
     * @param outputX the real world coordinates of the projection of x1 and x2 using
     * triangulation. else null if no valid solution was found
     */
    private static void bestInCheiralityTest(double[][] x1, double[][] x2, 
        double[][] k1, double[][] k2,
        double[][] R1, double[][] R2, double[] t1, double[] t2, 
        double[][] rSelected, double[] tSelected, double[][] outputX) {
    
<span class="fc" id="L3603">        int n = x1[0].length;</span>
        
<span class="pc bpc" id="L3605" title="1 of 2 branches missed.">        if (outputX.length != 4) {</span>
<span class="nc" id="L3606">            throw new IllegalArgumentException(&quot;outputX.length must be 4&quot;);</span>
        }
<span class="pc bpc" id="L3608" title="1 of 2 branches missed.">        if (outputX[0].length != n) {</span>
<span class="nc" id="L3609">            throw new IllegalArgumentException(&quot;outputX[0].length must be the same as x1[0].length&quot;);</span>
        }
        
        // for this model, for the first image, the camera extrinsics are
        //    R = I and t = [0], which leaves all rotation and translation in
        //    the 2nd camera extrinsics w.r.t. the first.
<span class="fc" id="L3615">        double[][] k1ExtrRot = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L3616">        double[] k1ExtrTrans = new double[3];</span>
        
        // save the first that pass the tests for Z&gt;=0.
<span class="fc" id="L3619">        double[][] bestR = null;</span>
<span class="fc" id="L3620">        double[] bestT = null;</span>
<span class="fc" id="L3621">        double[][] bestXW = null;</span>
<span class="fc" id="L3622">        String bestLabel = null;</span>
<span class="fc" id="L3623">        int bestNPosZ = Integer.MIN_VALUE;</span>
        
        double[][] XW;
        double[] XWPt;
<span class="fc" id="L3627">        String label = null;</span>
        
<span class="fc" id="L3629">        XWPt = new double[4];</span>
<span class="fc" id="L3630">        XW = new double[4][n];</span>
<span class="fc bfc" id="L3631" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="fc" id="L3632">            XW[i] = new double[n];</span>
        }
            
<span class="fc" id="L3635">        double[][] rTst = null;</span>
<span class="fc" id="L3636">        double[] tTst = null;</span>
<span class="fc" id="L3637">        double[][] x1Pt = new double[3][1];</span>
<span class="fc" id="L3638">        double[][] x2Pt = new double[3][1];</span>
        int i, j, ii;
<span class="fc bfc" id="L3640" title="All 2 branches covered.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3641">            x1Pt[i] = new double[1];</span>
<span class="fc" id="L3642">            x2Pt[i] = new double[1];</span>
        }
        
        int nPosZ;
        int nPosNZ;

<span class="fc bfc" id="L3648" title="All 2 branches covered.">        for (j = 0; j &lt; 4; ++j) {</span>
<span class="fc bfc" id="L3649" title="All 4 branches covered.">            switch(j) {</span>
                case 0: {
<span class="fc" id="L3651">                    label = &quot;R1, T1&quot;;</span>
<span class="fc" id="L3652">                    rTst = R1;</span>
<span class="fc" id="L3653">                    tTst = t1;</span>
<span class="fc" id="L3654">                    break;</span>
                }
                case 1: {
<span class="fc" id="L3657">                    label = &quot;R1, T2&quot;;</span>
<span class="fc" id="L3658">                    rTst = R1;</span>
<span class="fc" id="L3659">                    tTst = t2;</span>
<span class="fc" id="L3660">                    break;</span>
                }
                case 2: {
<span class="fc" id="L3663">                    label = &quot;R2, T1&quot;;</span>
<span class="fc" id="L3664">                    rTst = R2;</span>
<span class="fc" id="L3665">                    tTst = t1;</span>
<span class="fc" id="L3666">                    break;</span>
                }
                default: {                    
<span class="fc" id="L3669">                    label = &quot;R2, T2&quot;;</span>
<span class="fc" id="L3670">                    rTst = R2;</span>
<span class="fc" id="L3671">                    tTst = t2;</span>
                    break;
                }
            }
<span class="fc" id="L3675">            nPosZ = 0;</span>
<span class="fc" id="L3676">            nPosNZ = 0;</span>
<span class="fc bfc" id="L3677" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L3678" title="All 2 branches covered.">                for (ii = 0; ii &lt; 3; ++ii) {</span>
<span class="fc" id="L3679">                    x1Pt[ii][0] = x1[ii][i];</span>
<span class="fc" id="L3680">                    x2Pt[ii][0] = x2[ii][i];</span>
                }
                // x1Pt and y1 Pt must be in image reference frame.
<span class="fc" id="L3683">                Triangulation.WCSPt wcsPt = Triangulation.calculateWCSPoint(</span>
                    k1, k1ExtrRot, k1ExtrTrans, 
                    k2, rTst, tTst, 
                    x1Pt, x2Pt);
<span class="fc" id="L3687">                XWPt = wcsPt.X;</span>
<span class="fc" id="L3688">                MatrixUtil.multiply(wcsPt.X, 1./wcsPt.X[3]);</span>
<span class="fc bfc" id="L3689" title="All 2 branches covered.">                if (XWPt[2] &gt;= 0) {</span>
<span class="fc" id="L3690">                    nPosZ++;</span>
                } else {
<span class="fc" id="L3692">                    nPosNZ++;</span>
                }
<span class="fc bfc" id="L3694" title="All 2 branches covered.">                for (ii = 0; ii &lt; 4; ++ii) {</span>
<span class="fc" id="L3695">                    XW[ii][i] = XWPt[ii];</span>
                } 
            }
<span class="fc" id="L3698">            System.out.printf(&quot;Soln %d %s) N+=%d, N-=%d\n&quot;, j, label, nPosZ, nPosNZ);</span>
<span class="fc bfc" id="L3699" title="All 2 branches covered.">            if (nPosZ &gt; bestNPosZ) {</span>
<span class="fc" id="L3700">                bestNPosZ = nPosZ;</span>
<span class="fc" id="L3701">                bestR = rTst;</span>
<span class="fc" id="L3702">                bestT = tTst;</span>
<span class="fc" id="L3703">                bestLabel = label;</span>
<span class="fc" id="L3704">                bestXW = MatrixUtil.copy(XW);</span>
            }
        }
        
<span class="pc bpc" id="L3708" title="1 of 2 branches missed.">        if (bestR == null) {</span>
<span class="nc" id="L3709">            return;</span>
        }
        
        // copy into output variables:
<span class="fc bfc" id="L3713" title="All 2 branches covered.">        for (i = 0; i &lt; bestR.length; ++i) {</span>
<span class="fc" id="L3714">            System.arraycopy(bestR[i], 0, rSelected[i], 0, bestR[i].length);</span>
        }
<span class="fc" id="L3716">        System.arraycopy(bestT, 0, tSelected, 0, bestT.length);</span>
        
<span class="fc" id="L3718">        System.out.println(&quot;choosing solution: &quot; + bestLabel);</span>
        //double estimatedRotY = Math.atan(R[0][2]/R[0][0]) * (180./Math.PI);
<span class="fc" id="L3720">        double estimatedRotZ = Math.atan(-bestR[1][0]/bestR[1][1]) * (180./Math.PI);</span>
<span class="fc" id="L3721">        System.out.printf(&quot;estimated rotation in degrees about z axis from R=%.2f\n&quot;, estimatedRotZ);</span>
        //System.out.printf(&quot;X_WCS=\n%s\n&quot;, FormatArray.toString(bestXW, &quot;%.3e&quot;));
<span class="fc" id="L3723">        System.out.flush();</span>
        
<span class="fc bfc" id="L3725" title="All 2 branches covered.">        for (i = 0; i &lt; XW.length; ++i) {</span>
<span class="fc" id="L3726">            System.arraycopy(bestXW[i], 0, outputX[i], 0, bestXW[i].length);</span>
        }
        
<span class="fc" id="L3729">    }</span>

    static void populateWithDet1Rs(double[][] u, double[][] vT,
        double[][] r1Out, double[][] r2Out) {
        
        //Szeliski 2010, eqn (7.25)
        
        // R_Z+90 and R_Z_-90 from 
        // Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;, pg 121
        
        //R_z_90^T  = [ [0, 1, 0], [0, -1, 0], [0, 0, 1] ]
        //R_z_-90^T = [ [0, -1, 0], [0, 1, 0], [0, 0, 1] ]
         
        //R_z_90
<span class="fc" id="L3743">        double[][] r90T = new double[3][3];</span>
<span class="fc" id="L3744">        r90T[0] = new double[]{0, 1, 0};</span>
<span class="fc" id="L3745">        r90T[1] = new double[]{-1, 0, 0};</span>
<span class="fc" id="L3746">        r90T[2] = new double[]{0, 0, 1};</span>
<span class="fc" id="L3747">        double[][] r90NegT = MatrixUtil.transpose(r90T);</span>
        
<span class="fc" id="L3749">        double[][] uNeg = MatrixUtil.copy(u);</span>
<span class="fc" id="L3750">        MatrixUtil.multiply(uNeg, -1);</span>
        
<span class="fc" id="L3752">        double[][] rr1 = MatrixUtil.multiply(MatrixUtil.multiply(u, r90T), vT);</span>
<span class="fc" id="L3753">        double[][] rr2 = MatrixUtil.multiply(MatrixUtil.multiply(uNeg, r90T), vT);</span>
<span class="fc" id="L3754">        double[][] rr3 = MatrixUtil.multiply(MatrixUtil.multiply(u, r90NegT), vT);</span>
<span class="fc" id="L3755">        double[][] rr4 = MatrixUtil.multiply(MatrixUtil.multiply(uNeg, r90NegT), vT);</span>
        
<span class="fc" id="L3757">        double det1 = MatrixUtil.determinant(rr1);</span>
<span class="fc" id="L3758">        double det2 = MatrixUtil.determinant(rr2);</span>
<span class="fc" id="L3759">        double det3 = MatrixUtil.determinant(rr3);</span>
<span class="fc" id="L3760">        double det4 = MatrixUtil.determinant(rr4);</span>
        
<span class="fc" id="L3762">        System.out.printf(&quot;det(r1,r2,r3,r4)=%.3e,%.3e,%.3e,%.3e\n&quot;, det1, det2, det3, det4);</span>
<span class="fc" id="L3763">        System.out.printf(&quot;r1:\n%s\n&quot;, FormatArray.toString(rr1, &quot;%.4e&quot;));</span>
<span class="fc" id="L3764">        System.out.printf(&quot;r2:\n%s\n&quot;, FormatArray.toString(rr2, &quot;%.4e&quot;));</span>
<span class="fc" id="L3765">        System.out.printf(&quot;r3:\n%s\n&quot;, FormatArray.toString(rr3, &quot;%.4e&quot;));</span>
<span class="fc" id="L3766">        System.out.printf(&quot;r4:\n%s\n&quot;, FormatArray.toString(rr4, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L3768">        boolean useUPos = true;</span>
        
        int i;
<span class="pc bpc" id="L3771" title="1 of 2 branches missed.">        if (Math.abs(det1 - 1.) &lt; eps) {</span>
<span class="nc" id="L3772">            System.out.printf(&quot;using +U\n&quot;);</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L3774">                System.arraycopy(rr1[i], 0, r1Out[i], 0, rr1[i].length);</span>
            }
<span class="pc bpc" id="L3776" title="1 of 2 branches missed.">        } else if (Math.abs(det2 - 1.) &lt; eps) {</span>
<span class="fc" id="L3777">            System.out.printf(&quot;using -U\n&quot;);</span>
<span class="fc" id="L3778">            useUPos = false;</span>
<span class="fc bfc" id="L3779" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3780">                System.arraycopy(rr2[i], 0, r1Out[i], 0, rr2[i].length);</span>
            }
        } else {
<span class="nc" id="L3783">            throw new IllegalStateException(&quot;neither rotation matrix is SO(3)&quot;);</span>
        }
<span class="pc bpc" id="L3785" title="1 of 2 branches missed.">        if (Math.abs(det3 - 1.) &lt; eps) {</span>
<span class="nc bnc" id="L3786" title="All 2 branches missed.">            if (!useUPos) {</span>
<span class="nc" id="L3787">                throw new IllegalStateException(&quot;expecting to need +U&quot;);</span>
            }
<span class="nc" id="L3789">            System.out.printf(&quot;using +U\n&quot;);</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L3791">                System.arraycopy(rr3[i], 0, r2Out[i], 0, rr3[i].length);</span>
            }
<span class="pc bpc" id="L3793" title="1 of 2 branches missed.">        } else if (Math.abs(det4 - 1.) &lt; eps) {</span>
<span class="pc bpc" id="L3794" title="1 of 2 branches missed.">            if (useUPos) {</span>
<span class="nc" id="L3795">                throw new IllegalStateException(&quot;expecting to need -U&quot;);</span>
            }
<span class="fc" id="L3797">            System.out.printf(&quot;using -U\n&quot;);</span>
<span class="fc bfc" id="L3798" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3799">                System.arraycopy(rr4[i], 0, r2Out[i], 0, rr4[i].length);</span>
            }
        } else {
<span class="nc" id="L3802">            throw new IllegalStateException(&quot;neither rotation matrix is SO(3)&quot;);</span>
        }
        
<span class="pc bpc" id="L3805" title="1 of 2 branches missed.">        if (!useUPos) {</span>
<span class="fc bfc" id="L3806" title="All 2 branches covered.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="fc" id="L3807">                System.arraycopy(uNeg[i], 0, u[i], 0, uNeg[i].length);</span>
            }
        }
<span class="fc" id="L3810">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>